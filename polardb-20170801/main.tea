/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-qingdao = 'polardb.aliyuncs.com',
    cn-beijing = 'polardb.aliyuncs.com',
    cn-hangzhou = 'polardb.aliyuncs.com',
    cn-shanghai = 'polardb.aliyuncs.com',
    cn-shenzhen = 'polardb.aliyuncs.com',
    cn-hongkong = 'polardb.aliyuncs.com',
    ap-southeast-1 = 'polardb.aliyuncs.com',
    us-west-1 = 'polardb.aliyuncs.com',
    us-east-1 = 'polardb.aliyuncs.com',
    cn-hangzhou-finance = 'polardb.aliyuncs.com',
    cn-shanghai-finance-1 = 'polardb.aliyuncs.com',
    cn-shenzhen-finance-1 = 'polardb.aliyuncs.com',
    ap-northeast-2-pop = 'polardb.aliyuncs.com',
    cn-beijing-finance-1 = 'polardb.aliyuncs.com',
    cn-beijing-finance-pop = 'polardb.aliyuncs.com',
    cn-beijing-gov-1 = 'polardb.aliyuncs.com',
    cn-beijing-nu16-b01 = 'polardb.aliyuncs.com',
    cn-edge-1 = 'polardb.aliyuncs.com',
    cn-fujian = 'polardb.aliyuncs.com',
    cn-haidian-cm12-c01 = 'polardb.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'polardb.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'polardb.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'polardb.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'polardb.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'polardb.aliyuncs.com',
    cn-hangzhou-test-306 = 'polardb.aliyuncs.com',
    cn-hongkong-finance-pop = 'polardb.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'polardb.aliyuncs.com',
    cn-north-2-gov-1 = 'polardb.aliyuncs.com',
    cn-qingdao-nebula = 'polardb.aliyuncs.com',
    cn-shanghai-et15-b01 = 'polardb.aliyuncs.com',
    cn-shanghai-et2-b01 = 'polardb.aliyuncs.com',
    cn-shanghai-inner = 'polardb.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'polardb.aliyuncs.com',
    cn-shenzhen-inner = 'polardb.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'polardb.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'polardb.aliyuncs.com',
    cn-wuhan = 'polardb.aliyuncs.com',
    cn-wulanchabu = 'polardb.aliyuncs.com',
    cn-yushanfang = 'polardb.aliyuncs.com',
    cn-zhangbei = 'polardb.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'polardb.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'polardb.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'polardb.aliyuncs.com',
    eu-west-1-oxs = 'polardb.aliyuncs.com',
    rus-west-1-pop = 'polardb.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('polardb', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CancelScheduleTasksRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](~~98094~~) operation to query the information of all clusters that are deployed in a specified region, such as the cluster IDs.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  taskId?: string(name='TaskId', description='The ID of the scheduled task that you want to cancel.

> *   You can call the [DescribeScheduleTasks](~~199648~~) operation to query the details of all scheduled tasks that belong to the current account, such as the task IDs.
>*   You can cancel only the tasks whose status is `pending`.``', example='ec8c4723-eac5-4f12-becb-01ac08******'),
}

model CancelScheduleTasksResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7F2007D3-7E74-4ECB-89A8-BF130D******'),
  success?: boolean(name='Success', description='Indicates whether the request is successful.', example='true'),
}

model CancelScheduleTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelScheduleTasksResponseBody(name='body'),
}

async function cancelScheduleTasksWithOptions(request: CancelScheduleTasksRequest, runtime: Util.RuntimeOptions): CancelScheduleTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelScheduleTasks',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelScheduleTasks(request: CancelScheduleTasksRequest): CancelScheduleTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelScheduleTasksWithOptions(request, runtime);
}

model CheckAccountNameRequest {
  accountName?: string(name='AccountName', description='The name of the account.', example='test_acc'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckAccountNameResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='925B84D9-CA72-432C-95CF-738C22******'),
}

model CheckAccountNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckAccountNameResponseBody(name='body'),
}

async function checkAccountNameWithOptions(request: CheckAccountNameRequest, runtime: Util.RuntimeOptions): CheckAccountNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckAccountName',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkAccountName(request: CheckAccountNameRequest): CheckAccountNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkAccountNameWithOptions(request, runtime);
}

model CheckDBNameRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query information about all clusters that are deployed in a region, such as the cluster IDs.', example='pc-****************'),
  DBName?: string(name='DBName', description='The name of the database.', example='test_db'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckDBNameResponseBody = {
  DBName?: string(name='DBName', description='The name of the database.', example='test_db'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CDB3258F-B5DE-43C4-8935-CBA0CA******'),
}

model CheckDBNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckDBNameResponseBody(name='body'),
}

async function checkDBNameWithOptions(request: CheckDBNameRequest, runtime: Util.RuntimeOptions): CheckDBNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckDBName',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkDBName(request: CheckDBNameRequest): CheckDBNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkDBNameWithOptions(request, runtime);
}

model CheckKMSAuthorizedRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](~~98094~~) operation to query the information of all clusters that are deployed in a specific region, such as the cluster IDs.', example='pc-************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region.

>  You can call the [DescribeRegions](~~98041~~) operation to query all regions that are available for your account, such as the region IDs.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  TDERegion?: string(name='TDERegion', description='The region in which the TDE key resides.', example='cn-beijing'),
}

model CheckKMSAuthorizedResponseBody = {
  authorizationState?: int32(name='AuthorizationState', description='Indicates whether the cluster is authorized to use KMS. Valid values:

*   **0**: no.
*   **1**: yes.', example='0'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-************'),
  requestId?: string(name='RequestId', description='The request ID.', example='A7E6A8FD-C50B-46B2-BA85-D8B8D3******'),
  roleArn?: string(name='RoleArn', description='The Alibaba Cloud Resource Name (ARN) of the RAM role. A RAM role is a virtual identity that you can create within your Alibaba Cloud account. For more information, see [RAM role overview](~~93689~~).', example='acs:ram::1406926*****:role/aliyunrdsinstanceencryptiondefaultrole'),
}

model CheckKMSAuthorizedResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckKMSAuthorizedResponseBody(name='body'),
}

async function checkKMSAuthorizedWithOptions(request: CheckKMSAuthorizedRequest, runtime: Util.RuntimeOptions): CheckKMSAuthorizedResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.TDERegion)) {
    query['TDERegion'] = request.TDERegion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckKMSAuthorized',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkKMSAuthorized(request: CheckKMSAuthorizedRequest): CheckKMSAuthorizedResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkKMSAuthorizedWithOptions(request, runtime);
}

model CheckServiceLinkedRoleRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckServiceLinkedRoleResponseBody = {
  hasServiceLinkedRole?: boolean(name='HasServiceLinkedRole', description='Indicates whether the SLR is created.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3F9E6A3B-C13E-4064-A010-18582A******'),
}

model CheckServiceLinkedRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckServiceLinkedRoleResponseBody(name='body'),
}

async function checkServiceLinkedRoleWithOptions(request: CheckServiceLinkedRoleRequest, runtime: Util.RuntimeOptions): CheckServiceLinkedRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckServiceLinkedRole',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkServiceLinkedRole(request: CheckServiceLinkedRoleRequest): CheckServiceLinkedRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkServiceLinkedRoleWithOptions(request, runtime);
}

model CloseAITaskRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CloseAITaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='936C7025-27A5-4CB1-BB31-540E1F0CCA12'),
  taskId?: string(name='TaskId', description='The ID of the task for disabling the PolarDB for AI feature.', example='53879cdb-9a00-428e-acaf-ff4cff******'),
}

model CloseAITaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloseAITaskResponseBody(name='body'),
}

async function closeAITaskWithOptions(request: CloseAITaskRequest, runtime: Util.RuntimeOptions): CloseAITaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloseAITask',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function closeAITask(request: CloseAITaskRequest): CloseAITaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return closeAITaskWithOptions(request, runtime);
}

model CloseDBClusterMigrationRequest {
  continueEnableBinlog?: boolean(name='ContinueEnableBinlog', description='Specifies whether to continue to enable binary logging. Valid values:

*   **true**: continues to enable binary logging.
*   **false**: disables binary logging.

Default value: **true**.

> If binary logging is disabled, your PolarDB cluster is restarted.', example='true'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CloseDBClusterMigrationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='3AA69096-757C-4647-B36C-29EBC2******'),
}

model CloseDBClusterMigrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloseDBClusterMigrationResponseBody(name='body'),
}

/**
  * *   You can call this operation to cancel the migration task before data migration.
  * *   You can call this operation to perform the migration task after data migration.
  * > Before you call this operation, ensure that a one-click upgrade task has been created for the cluster. You can call the [CreateDBCluster](~~98169~~) operation to create an upgrade task. Set the **CreationOption** parameter to **MigrationFromRDS**. For more information, see [Create a PolarDB for MySQL cluster by using the Migration from RDS method](~~121582~~).
  *
  * @param request CloseDBClusterMigrationRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CloseDBClusterMigrationResponse
 */
async function closeDBClusterMigrationWithOptions(request: CloseDBClusterMigrationRequest, runtime: Util.RuntimeOptions): CloseDBClusterMigrationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.continueEnableBinlog)) {
    query['ContinueEnableBinlog'] = request.continueEnableBinlog;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloseDBClusterMigration',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   You can call this operation to cancel the migration task before data migration.
  * *   You can call this operation to perform the migration task after data migration.
  * > Before you call this operation, ensure that a one-click upgrade task has been created for the cluster. You can call the [CreateDBCluster](~~98169~~) operation to create an upgrade task. Set the **CreationOption** parameter to **MigrationFromRDS**. For more information, see [Create a PolarDB for MySQL cluster by using the Migration from RDS method](~~121582~~).
  *
  * @param request CloseDBClusterMigrationRequest
  * @return CloseDBClusterMigrationResponse
 */
async function closeDBClusterMigration(request: CloseDBClusterMigrationRequest): CloseDBClusterMigrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return closeDBClusterMigrationWithOptions(request, runtime);
}

model CreateAccountRequest {
  accountDescription?: string(name='AccountDescription', description='The description of the account. The description must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must be 2 to 256 characters in length.', example='testdes'),
  accountName?: string(name='AccountName', description='The name of the account. The name must meet the following requirements:

*   It must start with a lowercase letter and end with a letter or a digit.
*   It can contain lowercase letters, digits, and underscores (\\_).
*   It must be 2 to 16 characters in length.
*   It cannot be root, admin, or another username that is reserved by the system.', example='testacc'),
  accountPassword?: string(name='AccountPassword', description='The password of the account. The password must meet the following requirements:

*   It must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.
*   It must be 8 to 32 characters in length.
*   Special characters include `! @ # $ % ^ & * ( ) _ + - =`', example='Test1111'),
  accountPrivilege?: string(name='AccountPrivilege', description='The permissions that are granted to the account. Valid values:

*   **ReadWrite**: read and write permissions
*   **ReadOnly**: read-only permissions
*   **DMLOnly**: the permissions to execute only DML statements
*   **DDLOnly**: the permissions to execute only DDL statements
*   **ReadIndex**: the read and index permissions

> 

*   The `AccountPrivilege` parameter is valid only after you specify the `DBName` parameter.

*   If multiple database names are specified by the `DBName` parameter, you must grant permissions on the databases. Separate multiple permissions with commas (,). For example, if you want to grant the account the read and write permissions on DB1 and the read-only permissions on DB2, set `DBName` to `DB1,DB2`, and set `AccountPrivilege` to `ReadWrite,ReadOnly`.
*   This parameter is valid only for standard accounts of PolarDB for MySQL clusters.', example='ReadWrite'),
  accountType?: string(name='AccountType', description='The type of the account. Valid values:

*   **Normal**: standard account
*   **Super**: privileged account

> 

*   If you leave this parameter empty, the default value **Super** is used.

*   You can create multiple privileged accounts for a PolarDB for Oracle or PolarDB for PostgreSQL cluster. A privileged account is granted more permissions than a standard account. For more information about how to create a database account, see [Create a database account](~~68508~~).
*   You can create only one privileged account for a PolarDB for MySQL cluster. A privileged account is granted more permissions than a standard account. For more information about how to create a database account, see [Create a database account](~~68508~~).', example='Normal'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-**************'),
  DBName?: string(name='DBName', description='The name of the database that can be accessed by the account. To enter multiple database names, separate the names with commas (,).

> This parameter is valid only for standard accounts of PolarDB for MySQL clusters.', example='testdb'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  privForAllDB?: string(name='PrivForAllDB'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateAccountResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CED079B7-A408-41A1-BFF1-EC608E******'),
}

model CreateAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAccountResponseBody(name='body'),
}

async function createAccountWithOptions(request: CreateAccountRequest, runtime: Util.RuntimeOptions): CreateAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDescription)) {
    query['AccountDescription'] = request.accountDescription;
  }
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.accountPrivilege)) {
    query['AccountPrivilege'] = request.accountPrivilege;
  }
  if (!Util.isUnset(request.accountType)) {
    query['AccountType'] = request.accountType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.privForAllDB)) {
    query['PrivForAllDB'] = request.privForAllDB;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccount',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAccount(request: CreateAccountRequest): CreateAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccountWithOptions(request, runtime);
}

model CreateBackupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateBackupResponseBody = {
  backupJobId?: string(name='BackupJobId', description='The ID of the backup set.', example='11111111'),
  requestId?: string(name='RequestId', description='The request ID.', example='F3322AFE-083E-4D77-A074-421301******'),
}

model CreateBackupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBackupResponseBody(name='body'),
}

/**
  * > 
  * *   You can manually create up to three backups for each cluster.
  * *   The `Exceeding the daily backup times of this DB cluster` error message indicates that three manual backups already exist in your cluster. You must delete existing backups before you call this operation to manually create backups. For more information about how to delete backups, see [Delete backups](~~98101~~).
  * *   After you call this operation, a backup task is created in the backend. The task may be time-consuming if you want to back up large amounts of data.
  *
  * @param request CreateBackupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateBackupResponse
 */
async function createBackupWithOptions(request: CreateBackupRequest, runtime: Util.RuntimeOptions): CreateBackupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBackup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   You can manually create up to three backups for each cluster.
  * *   The `Exceeding the daily backup times of this DB cluster` error message indicates that three manual backups already exist in your cluster. You must delete existing backups before you call this operation to manually create backups. For more information about how to delete backups, see [Delete backups](~~98101~~).
  * *   After you call this operation, a backup task is created in the backend. The task may be time-consuming if you want to back up large amounts of data.
  *
  * @param request CreateBackupRequest
  * @return CreateBackupResponse
 */
async function createBackup(request: CreateBackupRequest): CreateBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBackupWithOptions(request, runtime);
}

model CreateColdStorageInstanceRequest {
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f5********************'),
  coldStorageInstanceDescription?: string(name='ColdStorageInstanceDescription', example='xxxxxxxxx'),
  DBClusterId?: string(name='DBClusterId', example='pc-wz9ye3xrtj60ua6d1'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateColdStorageInstanceResponseBody = {
  coldStorageInstanceId?: string(name='ColdStorageInstanceId', example='pcs_2zeth2gf4i83e578t'),
  requestId?: string(name='RequestId', example='F6EBB4ED-D12F-5F49-824C-9DD9C0EC4CF2'),
}

model CreateColdStorageInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateColdStorageInstanceResponseBody(name='body'),
}

async function createColdStorageInstanceWithOptions(request: CreateColdStorageInstanceRequest, runtime: Util.RuntimeOptions): CreateColdStorageInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.coldStorageInstanceDescription)) {
    query['ColdStorageInstanceDescription'] = request.coldStorageInstanceDescription;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateColdStorageInstance',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createColdStorageInstance(request: CreateColdStorageInstanceRequest): CreateColdStorageInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createColdStorageInstanceWithOptions(request, runtime);
}

model CreateDBClusterRequest {
  allowShutDown?: string(name='AllowShutDown', description='Specifies whether to enable the no-activity suspension feature. Default value: false. Valid values:

*   **true**
*   **false**

> This parameter is valid only for serverless clusters.', example='true'),
  architecture?: string(name='Architecture'),
  autoRenew?: boolean(name='AutoRenew', description='Specifies whether to enable automatic renewal. Valid values:

*   **true**
*   **false**

Default value: **false**.

> This parameter is valid only when the **PayType** parameter is set to **Prepaid**.', example='true'),
  backupRetentionPolicyOnClusterDeletion?: string(name='BackupRetentionPolicyOnClusterDeletion', description='The retention policy for the backup sets when you delete the cluster. Valid values:

*   **ALL**: permanently retains all backups.
*   **LATEST**: permanently retains the last backup. A backup is automatically created before you delete the cluster.
*   **NONE**: No backup sets are retained after the cluster is deleted.

The default value is **NONE** after you create a cluster.

> 

*   This parameter is valid only when the **DBType** parameter is set to **MySQL**.

*   This parameter is invalid for serverless clusters.', example='NONE'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f5********************'),
  cloneDataPoint?: string(name='CloneDataPoint', description='The point in time when you want to clone data. Valid values:

*   **LATEST**: The data of the latest point in time is cloned.
*   **BackupID**: You can specify the ID of a backup set. In this case, data is cloned based on the specified backup set.
*   **Timestamp**: You can specify a point in time in the past in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

Default value: **LATEST**.

> If the **CreationOption** parameter is set to **CloneFromRDS**, the value of this parameter must be **LATEST**.', example='LATEST'),
  clusterNetworkType?: string(name='ClusterNetworkType', description='The network type of the cluster. Only virtual private clouds (VPCs) are supported. Set the value to **VPC**.', example='VPC'),
  creationCategory?: string(name='CreationCategory', description='The edition of the cluster. Default value: Normal. Valid values:

*   **Normal**: Cluster Edition
*   **Basic**: Single Node Edition
*   **ArchiveNormal**: X-Engine Edition
*   **NormalMultimaster**: Multi-master Cluster Edition

> 

*   Only when the **DBType** parameter is set to **MySQL** and **the DBVersion** parameter is set to **5.6**, **5.7**, or **8.0**, you can set this parameter to **Basic**.

*   Only when the **DBType** parameter is set to **MySQL** and the **DBVersion** parameter is set to **8.0**, you can set this parameter to **ArchiveNormal** or **NormalMultimaster**.

For more information, see [Product editions](~~183258~~).', example='Normal'),
  creationOption?: string(name='CreationOption', description='The method that is used to create a cluster. Valid values:

*   **Normal**: creates a PolarDB cluster. For more information about how to perform this operation in the console, see the following topics:

    *   [Create a PolarDB for MySQL cluster](~~58769~~)
    *   [Create a PolarDB for PostgreSQL cluster](~~118063~~)
    *   [Create a PolarDB for Oracle cluster](~~118182~~)

*   **CloneFromPolarDB**: clones data from an existing PolarDB cluster to a new PolarDB cluster. For more information about how to perform this operation in the console, see the following topics:

    *   [Clone a PolarDB for MySQL cluster](~~87966~~)
    *   [Clone a PolarDB for PostgreSQL cluster](~~118108~~)
    *   [Clone a PolarDB for Oracle cluster](~~118221~~)

*   **CloneFromRDS**: clones data from an existing ApsaraDB RDS for MySQL instance to a new PolarDB for MySQL cluster. For more information about how to perform this operation in the console, see [Create a PolarDB for MySQL cluster by cloning an ApsaraDB RDS for MySQL instance](~~121812~~).

*   **MigrationFromRDS**: migrates data from an existing ApsaraDB RDS for MySQL instance to a new PolarDB for MySQL cluster. By default, the created PolarDB cluster is in read-only mode, and the binary logging feature is enabled. For more information about how to perform this operation in the console, see [Create a PolarDB for MySQL cluster from an ApsaraDB RDS for MySQL instance](~~121582~~).

*   **CreateGdnStandby**: creates a secondary cluster. For more information about how to perform this operation in the console, see [Add a secondary cluster](~~160381~~).

Default value: **Normal**.

> 

*   If the **DBType** parameter is set to **MySQL** and the **DBVersion** parameter is set to **5.6** or **5.7**, this parameter can be set to **CloneFromRDS** or **MigrationFromRDS**.

*   If the **DBType** parameter is set to **MySQL** and the **DBVersion** parameter is set to **8.0**, this parameter can be set to **CreateGdnStandby**.', example='Normal'),
  DBClusterDescription?: string(name='DBClusterDescription', description='The name of the cluster. The name must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must be 2 to 256 characters in length.', example='test'),
  DBMinorVersion?: string(name='DBMinorVersion', description='The minor version of the database engine. Valid values:

*   **8.0.2**
*   **8.0.1**

> This parameter is valid only when the **DBType** parameter is set to **MySQL** and the **DBVersion** parameter is set to **8.0**.', example='8.0.1'),
  DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node.

*   For more information about specifications supported by PolarDB for MySQL, see [Specifications of compute nodes](~~102542~~).
*   For information about node specifications supported by the Oracle database engine, see [Specifications of compute nodes](~~207921~~).
*   For information about node specifications supported by the PostgreSQL database engine, see [Specifications of compute nodes](~~209380~~).', example='polar.mysql.x2.medium'),
  DBNodeNum?: int32(name='DBNodeNum', description='标准版节点个数。', example='1'),
  DBType?: string(name='DBType', description='The type of the database engine. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.

*   Valid values for the MySQL database engine:

    *   **5.6**
    *   **5.7**
    *   **8.0**

*   Valid values for the PostgreSQL database engine:

    *   **11**
    *   **14**

*   Valid value for the Oracle database engine: **11**', example='5.6'),
  defaultTimeZone?: string(name='DefaultTimeZone', description='The time zone of the cluster. The time must be in UTC. You can set the parameter to a value that is on the hour from **-12:00 to +13:00**. Example: 00:00. Default value: **SYSTEM**, which means that the value is the same as the time zone of the region.

> This parameter is valid only when the **DBType** parameter is set to **MySQL**.', example='SYSTEM'),
  GDNId?: string(name='GDNId', description='The ID of the Global Database Network (GDN).

> This parameter is required only when the **CreationOption** parameter is set to **CreateGdnStandby**.', example='gdn-***********'),
  hotStandbyCluster?: string(name='HotStandbyCluster', example='ON'),
  loosePolarLogBin?: string(name='LoosePolarLogBin', description='开启Binlog功能，取值范围如下：

- **ON**：集群开启Binlog功能
- **OFF**：集群关闭Binlog功能
> 当参数**DBType**为**MySQL**时，该参数才生效。', example='ON'),
  looseXEngine?: string(name='LooseXEngine', description='开启X-Engine存储引擎功能，取值范围如下：

- **ON**：集群开启X-Engine引擎
- **OFF**：集群关闭X-Engine引擎
> 当参数**CreationOption**不等于**CreateGdnStandby**，**DBType**为**MySQL**且**DBVersion**为**8.0**时，该参数才生效。开启X-Engine引擎的节点内存规格必须大于等于16 GB。', example='ON'),
  looseXEngineUseMemoryPct?: string(name='LooseXEngineUseMemoryPct', description='设置开启X-Engine存储引擎比例，取值范围10~90的整数。
> 当参数**LooseXEngine**为**ON**时，该参数才生效。', example='50'),
  lowerCaseTableNames?: string(name='LowerCaseTableNames', description='Specifies whether the table names are case-sensitive. Valid values:

*   **1**: The table names are case-insensitive.
*   **0**: The table names are case-sensitive.

Default value: **1**.

> This parameter is valid only when the **DBType** parameter is set to **MySQL**.', example='1'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template.

> You can call the [DescribeParameterGroups](~~207178~~) operation to query the details of all parameter templates of a specified region, such as the ID of a parameter template.', example='pcpg-**************'),
  payType?: string(name='PayType', description='The billing method. Valid values:

*   **Postpaid**: pay-as-you-go
*   **Prepaid**: subscription', example='Postpaid'),
  period?: string(name='Period', description='The subscription type of the subscription cluster. This parameter is required only when the PayType parameter is set to **Prepaid**. Valid values:

*   **Year**: annual subscription. Unit: years.
*   **Month**: monthly subscription. Unit: months.', example='Month'),
  provisionedIops?: long(name='ProvisionedIops'),
  proxyClass?: string(name='ProxyClass', description='标准版数据库代理规格。', example='polar.maxscale.g2.medium.c'),
  proxyType?: string(name='ProxyType', description='数据库代理类型，取值范围如下：

- **Exclusive**：企业独享版
- **General**：企业通用版', example='Exclusive'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

> You can call the [DescribeRegions](~~98041~~) operation to query available regions.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scaleMax?: string(name='ScaleMax', description='The maximum number of PCUs per node for scaling. Valid values: 1 PCU to 32 PCUs.

> This parameter is valid only for serverless clusters.', example='3'),
  scaleMin?: string(name='ScaleMin', description='The minimum number of PCUs per node for scaling. Valid values: 1 PCU to 31 PCUs.

> This parameter is valid only for serverless clusters.', example='1'),
  scaleRoNumMax?: string(name='ScaleRoNumMax', description='The maximum number of read-only nodes for scaling. Valid values: 0 to 15.

> This parameter is valid only for serverless clusters.', example='4'),
  scaleRoNumMin?: string(name='ScaleRoNumMin', description='The minimum number of read-only nodes for scaling. Valid values: 0 to 15.

> This parameter is valid only for serverless clusters.', example='2'),
  securityIPList?: string(name='SecurityIPList', description='The IP whitelist of the cluster.

> The whitelist can contain multiple IP addresses. Separate multiple IP addresses with commas (,).', example='10.***.***.***'),
  serverlessType?: string(name='ServerlessType', description='The type of the serverless cluster. Set the value to **AgileServerless**.

> This parameter is valid only for serverless clusters.', example='AgileServerless'),
  sourceResourceId?: string(name='SourceResourceId', description='The ID of the source ApsaraDB RDS instance or PolarDB cluster. This parameter is required only when the **CreationOption** parameter is set to **MigrationFromRDS**, **CloneFromRDS**, or **CloneFromPolarDB**.

*   If the **CreationOption** parameter is set to **MigrationFromRDS** or **CloneFromRDS**, you must set this parameter to the ID of the source ApsaraDB RDS instance. The source ApsaraDB RDS instance must use ApsaraDB RDS for MySQL 5.6, 5.7, or 8.0 High-availability Edition.
*   If the **CreationOption** parameter is set to **CloneFromPolarDB**, you must set this parameter to the ID of the source PolarDB cluster. By default, the value of DBType of the destination cluster must be the same as that of the source cluster. For example, if a MySQL 8.0 cluster is used as the source cluster, you must set the **DBType** parameter to **MySQL** and the **DBVersion** parameter to **8.0** for the destination cluster.', example='rm-*************'),
  standbyAZ?: string(name='StandbyAZ', description='存储热备集群的可用区。适用于标准版3AZ场景。

> 开启了多可用区数据强一致，该参数才生效。', example='cn-hangzhou-g'),
  storageAutoScale?: string(name='StorageAutoScale'),
  storagePayType?: string(name='StoragePayType'),
  storageSpace?: long(name='StorageSpace', description='The storage space that uses the subscription billing method. Unit: GB.', example='50'),
  storageType?: string(name='StorageType', description='The storage type. Valid values for Enterprise Edition:

*   **PSL5**
*   **PSL4**

Valid values for Standard Edition:

*   **ESSDPL1**
*   **ESSDPL2**
*   **ESSDPL3**

> This parameter is invalid for serverless clusters.', example='PSL4'),
  storageUpperBound?: long(name='StorageUpperBound'),
  strictConsistency?: string(name='StrictConsistency', description='集群是否开启了多可用区数据强一致。取值范围：

- **ON**：表示开启了多可用区数据强一致，适用于标准版3AZ场景。

- **OFF**：表示未开启多可用区数据强一致。', example='ON'),
  TDEStatus?: boolean(name='TDEStatus', description='Specifies whether to enable transparent data encryption (TDE). Default value: false. Valid values:

*   **true**
*   **false**

> 

*   This parameter is valid only when the **DBType** parameter is set to **PostgreSQL** or **Oracle**.

*   You can call the [ModifyDBClusterTDE](~~167982~~) operation to enable TDE for a PolarDB for MySQL cluster.
*   TDE cannot be disabled after it is enabled.', example='true'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag that you want to create for the cluster. To create multiple tags for a cluster at a time, click the **+** icon.

> You can create up to 20 key-value pairs of tags at a time. Each value of the `Tag.N.Key` parameter is paired with a value of the `Tag.N.Value` parameter.', example='type'),
      value?: string(name='Value', description='The value of the tag that you want to create for the cluster. To create multiple tags for a cluster at a time, click the **+** icon.

> You can create up to 20 key-value pairs of tags at a time. Each value of the `Tag.N.Value` parameter is paired with a value of the `Tag.N.Key` parameter.', example='test'),
    }
  ](name='Tag', description='1'),
  usedTime?: string(name='UsedTime', description='*   If the **Period** parameter is set to **Month**, the **UsedTime** parameter can be set to `1, 2, 3, 4, 5, 6, 7, 8, or 9`.
*   If the **Period** parameter is set to **Year**, the **UsedTime** parameter can be set to `1, 2, or 3`.', example='1'),
  VPCId?: string(name='VPCId', description='The virtual private cloud (VPC) ID of the cluster.', example='vpc-**********'),
  vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the cluster.

> If the VPCId parameter is specified, the VSwitchId parameter is required.', example='vsw-**********'),
  zoneId?: string(name='ZoneId', description='The zone ID of the cluster.

> You can call the [DescribeRegions](~~98041~~) operation to query available zones.', example='cn-hangzhou-g'),
}

model CreateDBClusterResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-bp1s826a1up******'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='211454967******'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E56531A4-E552-40BA-9C58-137B80******'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-***************'),
}

model CreateDBClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDBClusterResponseBody(name='body'),
}

async function createDBClusterWithOptions(request: CreateDBClusterRequest, runtime: Util.RuntimeOptions): CreateDBClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allowShutDown)) {
    query['AllowShutDown'] = request.allowShutDown;
  }
  if (!Util.isUnset(request.architecture)) {
    query['Architecture'] = request.architecture;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.backupRetentionPolicyOnClusterDeletion)) {
    query['BackupRetentionPolicyOnClusterDeletion'] = request.backupRetentionPolicyOnClusterDeletion;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.cloneDataPoint)) {
    query['CloneDataPoint'] = request.cloneDataPoint;
  }
  if (!Util.isUnset(request.clusterNetworkType)) {
    query['ClusterNetworkType'] = request.clusterNetworkType;
  }
  if (!Util.isUnset(request.creationCategory)) {
    query['CreationCategory'] = request.creationCategory;
  }
  if (!Util.isUnset(request.creationOption)) {
    query['CreationOption'] = request.creationOption;
  }
  if (!Util.isUnset(request.DBClusterDescription)) {
    query['DBClusterDescription'] = request.DBClusterDescription;
  }
  if (!Util.isUnset(request.DBMinorVersion)) {
    query['DBMinorVersion'] = request.DBMinorVersion;
  }
  if (!Util.isUnset(request.DBNodeClass)) {
    query['DBNodeClass'] = request.DBNodeClass;
  }
  if (!Util.isUnset(request.DBNodeNum)) {
    query['DBNodeNum'] = request.DBNodeNum;
  }
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.defaultTimeZone)) {
    query['DefaultTimeZone'] = request.defaultTimeZone;
  }
  if (!Util.isUnset(request.GDNId)) {
    query['GDNId'] = request.GDNId;
  }
  if (!Util.isUnset(request.hotStandbyCluster)) {
    query['HotStandbyCluster'] = request.hotStandbyCluster;
  }
  if (!Util.isUnset(request.loosePolarLogBin)) {
    query['LoosePolarLogBin'] = request.loosePolarLogBin;
  }
  if (!Util.isUnset(request.looseXEngine)) {
    query['LooseXEngine'] = request.looseXEngine;
  }
  if (!Util.isUnset(request.looseXEngineUseMemoryPct)) {
    query['LooseXEngineUseMemoryPct'] = request.looseXEngineUseMemoryPct;
  }
  if (!Util.isUnset(request.lowerCaseTableNames)) {
    query['LowerCaseTableNames'] = request.lowerCaseTableNames;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupId)) {
    query['ParameterGroupId'] = request.parameterGroupId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.provisionedIops)) {
    query['ProvisionedIops'] = request.provisionedIops;
  }
  if (!Util.isUnset(request.proxyClass)) {
    query['ProxyClass'] = request.proxyClass;
  }
  if (!Util.isUnset(request.proxyType)) {
    query['ProxyType'] = request.proxyType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scaleMax)) {
    query['ScaleMax'] = request.scaleMax;
  }
  if (!Util.isUnset(request.scaleMin)) {
    query['ScaleMin'] = request.scaleMin;
  }
  if (!Util.isUnset(request.scaleRoNumMax)) {
    query['ScaleRoNumMax'] = request.scaleRoNumMax;
  }
  if (!Util.isUnset(request.scaleRoNumMin)) {
    query['ScaleRoNumMin'] = request.scaleRoNumMin;
  }
  if (!Util.isUnset(request.securityIPList)) {
    query['SecurityIPList'] = request.securityIPList;
  }
  if (!Util.isUnset(request.serverlessType)) {
    query['ServerlessType'] = request.serverlessType;
  }
  if (!Util.isUnset(request.sourceResourceId)) {
    query['SourceResourceId'] = request.sourceResourceId;
  }
  if (!Util.isUnset(request.standbyAZ)) {
    query['StandbyAZ'] = request.standbyAZ;
  }
  if (!Util.isUnset(request.storageAutoScale)) {
    query['StorageAutoScale'] = request.storageAutoScale;
  }
  if (!Util.isUnset(request.storagePayType)) {
    query['StoragePayType'] = request.storagePayType;
  }
  if (!Util.isUnset(request.storageSpace)) {
    query['StorageSpace'] = request.storageSpace;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  if (!Util.isUnset(request.storageUpperBound)) {
    query['StorageUpperBound'] = request.storageUpperBound;
  }
  if (!Util.isUnset(request.strictConsistency)) {
    query['StrictConsistency'] = request.strictConsistency;
  }
  if (!Util.isUnset(request.TDEStatus)) {
    query['TDEStatus'] = request.TDEStatus;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDBCluster(request: CreateDBClusterRequest): CreateDBClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBClusterWithOptions(request, runtime);
}

model CreateDBClusterEndpointRequest {
  autoAddNewNodes?: string(name='AutoAddNewNodes', description='Specifies whether to automatically associate newly added nodes with the cluster endpoint. Valid values:

*   **Enable**: Newly added nodes are automatically associated with the cluster endpoint.
*   **Disable**: Newly added nodes are not automatically associated with the cluster endpoint.

Default value: **Disable**.', example='Disable'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f******************'),
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-**************'),
  DBEndpointDescription?: string(name='DBEndpointDescription', description='The name of the custom cluster endpoint.', example='test'),
  endpointConfig?: string(name='EndpointConfig', description='The advanced configurations of the cluster endpoint. You must specify the configurations in the JSON format. You can specify the configurations of the following attributes: consistency level, transaction splitting, connection pool, and offload reads from the primary node.

*   Specify the consistency level in the format of `{"ConsistLevel":"Consistency level"}`. Default value: 1. Valid values:

    *   **0**: eventual consistency.
    *   **1**: session consistency.
    *   **2**: global consistency.

*   Specify the transaction splitting feature in the format of `{"DistributedTransaction":"Transaction splitting"}`. Valid values:

    *   **on**: enables the transaction splitting feature. By default, the feature is enabled.
    *   **off**: disables the transaction splitting feature.

*   Specify the offload reads from the primary node feature in the format of `{"MasterAcceptReads":"Offload reads from the primary node"}`. Default value: off. Valid values:

    *   **on**: The primary node accepts read requests.
    *   **off**: The primary node does not accept read requests.

*   Specify the connection pool in the format of `{"ConnectionPersist":"Connection pool"}`. Default value: off. Valid values:

    *   **off**: disables the connection pool.
    *   **Session**: enables the session-level connection pool.
    *   **Transaction**: enables the transaction-level connection pool.

>- You can specify the transaction splitting, connection pool, and offload reads from the primary node features for a PolarDB for MySQL cluster only if ReadWriteMode is set to ReadWrite for the cluster endpoint.
>- Only PolarDB for MySQL supports global consistency.
>- If the **ReadWriteMode** parameter is set to **ReadOnly**, the consistency level must be **0**.
>- You can use one record to specify the consistency level, transaction splitting, connection pool, and offload reads from the primary node features, such as `{"ConsistLevel":"1","DistributedTransaction":"on","ConnectionPersist":"Session","MasterAcceptReads":"on"}`.
>- The transaction splitting settings are restricted by the consistency level settings. For example, if you set the consistency level to **0**, transaction splitting cannot be enabled. If you set the consistency level to **1** or **2**, transaction splitting can be enabled.', example='{"ConsistLevel": "1","DistributedTransaction": "on"}'),
  endpointType?: string(name='EndpointType', description='The type of the cluster endpoint. Set the value to **Custom**.', example='Custom'),
  nodes?: string(name='Nodes', description='The reader nodes that you want to associate with the endpoint. If you want to specify multiple reader nodes, separate the reader nodes with commas (,). If you do not specify this parameter, all nodes are used.

>- You need to specify the node IDs for a PolarDB for MySQL cluster.
>- You need to specify the role name of each node for a PolarDB for PostgreSQL cluster or a PolarDB for PostgreSQL (Compatible with Oracle) cluster. Example: `Writer, Reader1, Reader2`.
>- If you set **ReadWriteMode** to **ReadOnly**, you can associate only one node with the endpoint. If the only node becomes faulty, the cluster endpoint may be unavailable for up to 1 hour. We recommend that you associate more than one node with the cluster endpoint in production environments. We recommend that you associate at least two nodes with the cluster endpoint to improve service availability.
>- If you set **ReadWriteMode** to **ReadWrite**, you need to associate at least two nodes with the cluster endpoint.
>- PolarDB for MySQL does not impose a limit on the types of the two nodes. If the nodes are read-only nodes, write requests are forwarded to the primary node. 
>- PolarDB for PostgreSQL and PolarDB for PostgreSQL (compatible with Oracle) require a primary node.', example='pi-**********,pi-*********'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  readWriteMode?: string(name='ReadWriteMode', description='The read/write mode. Valid values:

*   **ReadWrite**: receives and forwards read and write requests. Automatic read/write splitting is enabled.
*   **ReadOnly**: The account has the read-only permissions on the database.

Default value: **ReadOnly**.', example='ReadOnly'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateDBClusterEndpointResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CD35F3-F3-44CA-AFFF-BAF869******'),
}

model CreateDBClusterEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDBClusterEndpointResponseBody(name='body'),
}

async function createDBClusterEndpointWithOptions(request: CreateDBClusterEndpointRequest, runtime: Util.RuntimeOptions): CreateDBClusterEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoAddNewNodes)) {
    query['AutoAddNewNodes'] = request.autoAddNewNodes;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointDescription)) {
    query['DBEndpointDescription'] = request.DBEndpointDescription;
  }
  if (!Util.isUnset(request.endpointConfig)) {
    query['EndpointConfig'] = request.endpointConfig;
  }
  if (!Util.isUnset(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!Util.isUnset(request.nodes)) {
    query['Nodes'] = request.nodes;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.readWriteMode)) {
    query['ReadWriteMode'] = request.readWriteMode;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBClusterEndpoint',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDBClusterEndpoint(request: CreateDBClusterEndpointRequest): CreateDBClusterEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBClusterEndpointWithOptions(request, runtime);
}

model CreateDBEndpointAddressRequest {
  connectionStringPrefix?: string(name='ConnectionStringPrefix', description='The prefix of the new endpoint. The prefix of the endpoint must meet the following requirements:

*   The prefix can contain lowercase letters, digits, and hyphens (-).
*   The prefix must start with a letter and end with a digit or a letter.
*   The prefix must be 6 to 40 characters in length.', example='test-1'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-**************'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.

>  You can call the [DescribeDBClusterEndpoints](~~98205~~) operation to query endpoint details.', example='pe-**************'),
  netType?: string(name='NetType', description='The network type of the endpoint. Set the value to **Public**.', example='Public'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the ECS security group.', example='sg-bp**************'),
  VPCId?: string(name='VPCId', description='The ID of the virtual private cloud (VPC).', example='vpc-**********'),
  zoneInfo?: [ 
    {
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-**********'),
      zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-b'),
    }
  ](name='ZoneInfo', description='The details of the zones.'),
}

model CreateDBEndpointAddressResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6BD9CDE4-5E7B-4BF3-9BB8-83C73E******'),
}

model CreateDBEndpointAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDBEndpointAddressResponseBody(name='body'),
}

/**
  * > You can create a public endpoint for the primary endpoint, the default cluster endpoint, or a custom cluster endpoint.
  *
  * @param request CreateDBEndpointAddressRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateDBEndpointAddressResponse
 */
async function createDBEndpointAddressWithOptions(request: CreateDBEndpointAddressRequest, runtime: Util.RuntimeOptions): CreateDBEndpointAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionStringPrefix)) {
    query['ConnectionStringPrefix'] = request.connectionStringPrefix;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.zoneInfo)) {
    query['ZoneInfo'] = request.zoneInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBEndpointAddress',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > You can create a public endpoint for the primary endpoint, the default cluster endpoint, or a custom cluster endpoint.
  *
  * @param request CreateDBEndpointAddressRequest
  * @return CreateDBEndpointAddressResponse
 */
async function createDBEndpointAddress(request: CreateDBEndpointAddressRequest): CreateDBEndpointAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBEndpointAddressWithOptions(request, runtime);
}

model CreateDBLinkRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the source cluster that the database link connects.

>  You can call the [DescribeDBClusters](~~173433~~) operation to query PolarDB clusters.', example='pc-a************'),
  DBLinkName?: string(name='DBLinkName', description='The name of the database link.

*   The name must contain lowercase letters and can also contain digits and underscores (\\_).
*   The name must start with a letter and end with a letter or digit.
*   The name must be 1 to 64 characters in length.', example='dblink_test'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region.

>  You can call the [DescribeRegions](~~98041~~) operation to query information about regions.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceDBName?: string(name='SourceDBName', description='The name of the source database.

>  You can call the [DescribeDatabases](~~173558~~) operation to query information about databases in a PolarDB cluster.', example='testdb1'),
  targetDBAccount?: string(name='TargetDBAccount', description='The account of the destination database.

>  You can call the [DescribeAccounts](~~173549~~) operation to query the account of a PolarDB cluster.', example='testacc'),
  targetDBInstanceName?: string(name='TargetDBInstanceName', description='The ID of the destination cluster that the database link connects.

> *   If the destination cluster is a user-created Oracle database on an ECS instance, set the value to `null`.
> *   You can call the [DescribeDBClusters](~~173433~~) operation to query PolarDB clusters.', example='pc-b************'),
  targetDBName?: string(name='TargetDBName', description='The name of the destination database.

>  You can call the [DescribeDatabases](~~173558~~) operation to query information about databases in a PolarDB cluster.', example='testdb2'),
  targetDBPasswd?: string(name='TargetDBPasswd', description='The account password of the destination database.', example='Test1111'),
  targetIp?: string(name='TargetIp', description='The IP address of the user-created Oracle database on an ECS instance.', example='192.**.**.46'),
  targetPort?: string(name='TargetPort', description='The port number of the user-created Oracle database on an ECS instance.', example='1521'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).

>  You can call the [DescribeVpcs](~~35739~~) operation to query information about VPCs.', example='vpc-bp1qpo0kug3a20qqe****'),
}

model CreateDBLinkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F9F1CB1A-B1D5-4EF5-A53A-************'),
}

model CreateDBLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDBLinkResponseBody(name='body'),
}

/**
  * A database link can be used to connect two PolarDB for PostgreSQL(Compatible with Oracle) clusters, or connect a PolarDB for PostgreSQL(Compatible with Oracle) cluster to a user-created PostgreSQL database that is hosted on an Elastic Compute Service (ECS) instance. You can use database links to query data across clusters.
  * > *   You can create up to 10 database links for a cluster.
  * > *   Each database link connects a source cluster and a destination cluster.
  * > *   The source cluster and the destination cluster or the destination ECS instance must be located in the same region.
  *
  * @param request CreateDBLinkRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateDBLinkResponse
 */
async function createDBLinkWithOptions(request: CreateDBLinkRequest, runtime: Util.RuntimeOptions): CreateDBLinkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBLinkName)) {
    query['DBLinkName'] = request.DBLinkName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceDBName)) {
    query['SourceDBName'] = request.sourceDBName;
  }
  if (!Util.isUnset(request.targetDBAccount)) {
    query['TargetDBAccount'] = request.targetDBAccount;
  }
  if (!Util.isUnset(request.targetDBInstanceName)) {
    query['TargetDBInstanceName'] = request.targetDBInstanceName;
  }
  if (!Util.isUnset(request.targetDBName)) {
    query['TargetDBName'] = request.targetDBName;
  }
  if (!Util.isUnset(request.targetDBPasswd)) {
    query['TargetDBPasswd'] = request.targetDBPasswd;
  }
  if (!Util.isUnset(request.targetIp)) {
    query['TargetIp'] = request.targetIp;
  }
  if (!Util.isUnset(request.targetPort)) {
    query['TargetPort'] = request.targetPort;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBLink',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * A database link can be used to connect two PolarDB for PostgreSQL(Compatible with Oracle) clusters, or connect a PolarDB for PostgreSQL(Compatible with Oracle) cluster to a user-created PostgreSQL database that is hosted on an Elastic Compute Service (ECS) instance. You can use database links to query data across clusters.
  * > *   You can create up to 10 database links for a cluster.
  * > *   Each database link connects a source cluster and a destination cluster.
  * > *   The source cluster and the destination cluster or the destination ECS instance must be located in the same region.
  *
  * @param request CreateDBLinkRequest
  * @return CreateDBLinkResponse
 */
async function createDBLink(request: CreateDBLinkRequest): CreateDBLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBLinkWithOptions(request, runtime);
}

model CreateDBNodesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-*************'),
  DBNode?: [ 
    {
      targetClass?: string(name='TargetClass', description='The specifications of the read-only node that you want to add, which must be the same as the specifications of the existing nodes. For more information, see the following topics:

*   PolarDB for MySQL: [Specifications of compute nodes](~~102542~~)
*   PolarDB for PostgreSQL (Compatible with Oracle): [Specifications of compute nodes](~~207921~~)
*   PolarDB for PostgreSQL: [Specifications of compute nodes](~~209380~~)

>- You need to specify either DBNode.N.ZoneId or DBNode.N.TargetClass. N is an integer that starts from 1. The maximum value of N is equal to 16 minus the number of existing nodes.
>- You can add multiple read-only nodes at the same time only to PolarDB for MySQL clusters, which can contain up to of 15 read-only nodes.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters. This parameter is optional for PolarDB for MySQL clusters.', example='polar.mysql.x4.medium'),
      zoneId?: string(name='ZoneId', description='The zone ID of the node that you want to add, which must be the same as the zone ID of existing nodes. You can call the [DescribeRegions](~~98041~~) operation to query the IDs of zones.

>- You need to specify either DBNode.N.ZoneId or DBNode.N.TargetClass. N is an integer that starts from 1. The maximum value of N is equal to 16 minus the number of existing nodes.
>- You can add multiple read-only nodes at the same time only to PolarDB for MySQL clusters, which can contain up to of 15 read-only nodes.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters. This parameter is optional for PolarDB for MySQL clusters.', example='cn-qingdao-c'),
    }
  ](name='DBNode', description='The details of the read-only node.'),
  DBNodeType?: string(name='DBNodeType', description='The type of the node. Valid values:

*   RO
*   STANDBY', example='RO'),
  endpointBindList?: string(name='EndpointBindList', description='The ID of the cluster endpoint to which the read-only node is added. If you want to add the read-only node to multiple endpoints at the same time, separate the endpoint IDs with commas (,).
> - You can call the [DescribeDBClusterEndpoints](~~98205~~) operation to query the details of cluster endpoints, including endpoint IDs.
>- You can enter the ID of the default cluster endpoint or a custom cluster endpoint.
>- If you leave this parameter empty, the read-only node is added to all cluster endpoints for which the **Automatically Associate New Nodes** feature is enabled. If you set `AutoAddNewNodes` to `Enable`, the Automatically Associate New Nodes feature is enabled.', example='pe-****************,pe-****************'),
  imciSwitch?: string(name='ImciSwitch', description='Specifies whether to enable the In-Memory Column Index (IMCI) feature. Default value: OFF. Valid values:

*   **ON**
*   **OFF**

> This parameter is invalid for a PolarDB for Oracle or PolarDB for PostgreSQL cluster.', example='ON'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time for upgrading the specifications within the scheduled time period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

>- The value of this parameter must be at least 30 minutes later than the value of PlannedStartTime.
>- If you specify `PlannedStartTime` but do not specify PlannedEndTime, the latest start time of the task is set to a value that is calculated by using the following formula: `PlannedEndTime value + 30 minutes`. For example, if you set `PlannedStartTime` to `2021-01-14T09:00:00Z` and you do not specify PlannedEndTime, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time of the scheduled task for adding the read-only node. The scheduled task specifies that the task is run in the required period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

>- The earliest start time of the scheduled task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in time between `2021-01-14T09:00:00Z` and `2021-01-15T09:00:00Z`.
>- If you leave this parameter empty, the task for adding the read-only node is immediately run by default.', example='2021-01-14T09:00:00Z'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateDBNodesResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-***************'),
  DBNodeIds?: {
    DBNodeId?: [ string ](name='DBNodeId')
  }(name='DBNodeIds', description='Details about the nodes.'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2148126708*****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E053E730-5755-4AA9-AA9D-A47867******'),
}

model CreateDBNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDBNodesResponseBody(name='body'),
}

async function createDBNodesWithOptions(request: CreateDBNodesRequest, runtime: Util.RuntimeOptions): CreateDBNodesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNode)) {
    query['DBNode'] = request.DBNode;
  }
  if (!Util.isUnset(request.DBNodeType)) {
    query['DBNodeType'] = request.DBNodeType;
  }
  if (!Util.isUnset(request.endpointBindList)) {
    query['EndpointBindList'] = request.endpointBindList;
  }
  if (!Util.isUnset(request.imciSwitch)) {
    query['ImciSwitch'] = request.imciSwitch;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBNodes',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDBNodes(request: CreateDBNodesRequest): CreateDBNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBNodesWithOptions(request, runtime);
}

model CreateDatabaseRequest {
  accountName?: string(name='AccountName', description='The name of the account that is authorized to access the database. You can call the [DescribeAccounts](~~98107~~) operation to query account information.
>- You can specify only a standard account. By default, privileged accounts have all permissions on all databases. You do not need to grant privileged accounts the permissions to access the database.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters. This parameter is optional for PolarDB for MySQL clusters.', example='testacc'),
  accountPrivilege?: string(name='AccountPrivilege', description='The permissions that are granted to the account. Valid values:

*   **ReadWrite**: read and write permissions.
*   **ReadOnly**: read-only permissions.
*   **DMLOnly**: the permissions to execute only DML statements.
*   **DDLOnly**: the permissions to execute only DDL statements.
*   **ReadIndex**: the read-only and index permissions.

If you leave this parameter empty, the default value **ReadWrite** is used.

>- This parameter is valid only if you specify **AccountName**.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is optional for PolarDB for MySQL clusters.', example='ReadWrite'),
  characterSetName?: string(name='CharacterSetName', description='The character set that is used by the cluster. For more information, see [Character set tables](~~99716~~).', example='utf8'),
  collate?: string(name='Collate', description='The language that indicates the collation of the databases that are created.

> *   The language must be compatible with the character set that is specified by **CharacterSetName**.
>*   This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters. This parameter is not supported by PolarDB for MySQL clusters.

To view the valid values for this parameter, perform the following steps: Log on to the PolarDB console and click the ID of a cluster. In the left-side navigation pane, choose **Settings and Management** > **Databases**. Then, click **Create Database**.', example='C'),
  ctype?: string(name='Ctype', description='The language that indicates the character type of the database.

>- The language must be compatible with the character set that is specified by **CharacterSetName**.
>- The value that you specify must be the same as the value of **Collate**.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters. This parameter is optional for PolarDB for MySQL clusters.

To view the valid values for this parameter, perform the following steps: Log on to the PolarDB console and click the ID of a cluster. In the left-side navigation pane, choose **Settings and Management** > **Databases**. Then, click **Create Database**.', example='C'),
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-**************'),
  DBDescription?: string(name='DBDescription', description='The description of the database. The description must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must be 2 to 256 characters in length.

> This parameter is required for a PolarDB for Oracle or PolarDB for PostgreSQL cluster. This parameter is optional for a PolarDB for MySQL cluster.', example='testdesc'),
  DBName?: string(name='DBName', description='The name of the database. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, hyphens (-), and underscores (\\_).
*   The name must start with a lowercase letter and end with a lowercase letter or a digit. The name must be 1 to 64 characters in length.

> Do not use reserved words as database names, such as `test` or `mysql`.', example='testDB'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateDatabaseResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='93E98F25-BE02-40DA-83E3-F77F8D******'),
}

model CreateDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDatabaseResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that the following requirements are met:
  * *   The cluster is in the Running state.
  * *   The cluster is unlocked.
  *
  * @param request CreateDatabaseRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateDatabaseResponse
 */
async function createDatabaseWithOptions(request: CreateDatabaseRequest, runtime: Util.RuntimeOptions): CreateDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPrivilege)) {
    query['AccountPrivilege'] = request.accountPrivilege;
  }
  if (!Util.isUnset(request.characterSetName)) {
    query['CharacterSetName'] = request.characterSetName;
  }
  if (!Util.isUnset(request.collate)) {
    query['Collate'] = request.collate;
  }
  if (!Util.isUnset(request.ctype)) {
    query['Ctype'] = request.ctype;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBDescription)) {
    query['DBDescription'] = request.DBDescription;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDatabase',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, make sure that the following requirements are met:
  * *   The cluster is in the Running state.
  * *   The cluster is unlocked.
  *
  * @param request CreateDatabaseRequest
  * @return CreateDatabaseResponse
 */
async function createDatabase(request: CreateDatabaseRequest): CreateDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDatabaseWithOptions(request, runtime);
}

model CreateGlobalDatabaseNetworkRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the primary cluster.', example='pc-bp1q76364ird*****'),
  GDNDescription?: string(name='GDNDescription', description='The description of the GDN. The description must meet the following requirements:

*   It cannot start with [http:// or https://.](http://https://。)
*   It must start with a letter.
*   It can contain letters, digits, underscores (\\_), and hyphens (-).
*   It must be 2 to 126 characters in length.', example='GDN-fortest'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model CreateGlobalDatabaseNetworkResponseBody = {
  GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gd-m5ex5wqfqbou*****'),
  requestId?: string(name='RequestId', description='The request ID.', example='C61892A4-0850-4516-9E26-44D96C1782DE'),
}

model CreateGlobalDatabaseNetworkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGlobalDatabaseNetworkResponseBody(name='body'),
}

/**
  * >  A cluster belongs to only one GDN.
  *
  * @param request CreateGlobalDatabaseNetworkRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateGlobalDatabaseNetworkResponse
 */
async function createGlobalDatabaseNetworkWithOptions(request: CreateGlobalDatabaseNetworkRequest, runtime: Util.RuntimeOptions): CreateGlobalDatabaseNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.GDNDescription)) {
    query['GDNDescription'] = request.GDNDescription;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGlobalDatabaseNetwork',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  A cluster belongs to only one GDN.
  *
  * @param request CreateGlobalDatabaseNetworkRequest
  * @return CreateGlobalDatabaseNetworkResponse
 */
async function createGlobalDatabaseNetwork(request: CreateGlobalDatabaseNetworkRequest): CreateGlobalDatabaseNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGlobalDatabaseNetworkWithOptions(request, runtime);
}

model CreateGlobalSecurityIPGroupRequest {
  GIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Multiple IP addresses are separated by commas (,). You can create up to 1,000 IP addresses or CIDR blocks for all IP whitelists.', example='192.168.0.1'),
  globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (\\_).
*   The name must start with a letter and end with a letter or digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model CreateGlobalSecurityIPGroupResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      GIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (\\_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroup', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model CreateGlobalSecurityIPGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGlobalSecurityIPGroupResponseBody(name='body'),
}

async function createGlobalSecurityIPGroupWithOptions(request: CreateGlobalSecurityIPGroupRequest, runtime: Util.RuntimeOptions): CreateGlobalSecurityIPGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.GIpList)) {
    query['GIpList'] = request.GIpList;
  }
  if (!Util.isUnset(request.globalIgName)) {
    query['GlobalIgName'] = request.globalIgName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGlobalSecurityIPGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGlobalSecurityIPGroup(request: CreateGlobalSecurityIPGroupRequest): CreateGlobalSecurityIPGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGlobalSecurityIPGroupWithOptions(request, runtime);
}

model CreateParameterGroupRequest {
  DBType?: string(name='DBType', description='The type of the database engine. Only **MySQL** is supported.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine. Valid values:

*   **5.6**
*   **5.7**
*   **8.0**', example='8.0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parameterGroupDesc?: string(name='ParameterGroupDesc', description='The description of the parameter template. It must be 0 to 199 characters in length.', example='test_group'),
  parameterGroupName?: string(name='ParameterGroupName', description='The name of the parameter template. The name must meet the following requirements:

*   It can contain letters, digits, and underscores (\\_). It must start with a letter and cannot end with an underscore.**
*   It must be 8 to 64 characters in length.', example='test_group'),
  parameters?: string(name='Parameters', description='The JSON string that consists of parameters and values. The parameter values are strings. Example: `{"wait_timeout":"86400","innodb_old_blocks_time":"1000"}`.

> You can call the [DescribeParameterTemplates](~~207428~~) operation to query the details of all parameters in the cluster of a specified engine version, such as the parameter name and valid values.', example='{"wait_timeout":"86400","innodb_old_blocks_time":"1000"}'),
  regionId?: string(name='RegionId', description='The region ID.

> You can call the [DescribeRegions](~~98041~~) operation to query available regions.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateParameterGroupResponseBody = {
  parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template.

> You can call the [DescribeParameterGroups](~~207178~~) operation to query the details of all parameter templates of a specified region, such as the ID of a parameter template.', example='pcpg-**************'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='514D1D87-E243-4A5F-A87D-2785C3******'),
}

model CreateParameterGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateParameterGroupResponseBody(name='body'),
}

/**
  * You can use parameter templates to manage multiple parameters at a time and apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](~~207009~~).
  * > You can call this operation only on a PolarDB for MySQL cluster.
  *
  * @param request CreateParameterGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateParameterGroupResponse
 */
async function createParameterGroupWithOptions(request: CreateParameterGroupRequest, runtime: Util.RuntimeOptions): CreateParameterGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupDesc)) {
    query['ParameterGroupDesc'] = request.parameterGroupDesc;
  }
  if (!Util.isUnset(request.parameterGroupName)) {
    query['ParameterGroupName'] = request.parameterGroupName;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateParameterGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can use parameter templates to manage multiple parameters at a time and apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](~~207009~~).
  * > You can call this operation only on a PolarDB for MySQL cluster.
  *
  * @param request CreateParameterGroupRequest
  * @return CreateParameterGroupResponse
 */
async function createParameterGroup(request: CreateParameterGroupRequest): CreateParameterGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createParameterGroupWithOptions(request, runtime);
}

model CreateServiceLinkedRoleRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateServiceLinkedRoleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='3F9E6A3B-C13E-4064-A010-18582A******'),
}

model CreateServiceLinkedRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceLinkedRoleResponseBody(name='body'),
}

async function createServiceLinkedRoleWithOptions(request: CreateServiceLinkedRoleRequest, runtime: Util.RuntimeOptions): CreateServiceLinkedRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceLinkedRole',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createServiceLinkedRole(request: CreateServiceLinkedRoleRequest): CreateServiceLinkedRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceLinkedRoleWithOptions(request, runtime);
}

model CreateStoragePlanRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value. Make sure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='6000170000591aed949d0f5********************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: string(name='Period', description='The unit of the subscription duration for the storage plan. Valid values:

*   **Month**
*   **Year**', example='Month'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  storageClass?: string(name='StorageClass', description='The capacity of the storage plan. Unit: GB. Valid values: 50, 100, 200, 300, 500, 1000, 2000, 3000, 5000, 10000, 15000, 20000, 25000, 30000, 50000, 100000, and 200000', example='500'),
  storageType?: string(name='StorageType', description='The type of the storage plan. Valid values:

*   **Mainland**: The storage plan is used inside the Chinese mainland.
*   **Overseas**: The storage plan is used outside the Chinese mainland.', example='Mainland'),
  usedTime?: string(name='UsedTime', description='The subscription duration of the storage plan.

*   If **Period** is set to **Month**, the value ranges from 1 to 9.
*   If **Period** is set to **Year**, the value can be 1, 2, 3, or 5.', example='3'),
}

model CreateStoragePlanResponseBody = {
  DBInstanceId?: string(name='DBInstanceId', description='The instance ID.', example='POLARDB-cn-**************'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2035638*******'),
  requestId?: string(name='RequestId', description='The request ID.', example='69A85BAF-1089-4CDF-A82F-0A140F******'),
}

model CreateStoragePlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateStoragePlanResponseBody(name='body'),
}

async function createStoragePlanWithOptions(request: CreateStoragePlanRequest, runtime: Util.RuntimeOptions): CreateStoragePlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.storageClass)) {
    query['StorageClass'] = request.storageClass;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateStoragePlan',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createStoragePlan(request: CreateStoragePlanRequest): CreateStoragePlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return createStoragePlanWithOptions(request, runtime);
}

model DeleteAccountRequest {
  accountName?: string(name='AccountName', description='The username of the account.', example='testacc'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteAccountResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model DeleteAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAccountResponseBody(name='body'),
}

/**
  * > Before you call this operation, make sure that the cluster is in the Running state. Otherwise, the operation fails.
  *
  * @param request DeleteAccountRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteAccountResponse
 */
async function deleteAccountWithOptions(request: DeleteAccountRequest, runtime: Util.RuntimeOptions): DeleteAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAccount',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > Before you call this operation, make sure that the cluster is in the Running state. Otherwise, the operation fails.
  *
  * @param request DeleteAccountRequest
  * @return DeleteAccountResponse
 */
async function deleteAccount(request: DeleteAccountRequest): DeleteAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccountWithOptions(request, runtime);
}

model DeleteBackupRequest {
  backupId?: string(name='BackupId', description='The backup ID. If you need to specify multiple backup IDs, separate the backup IDs with commas (,).

>  You can call the [DescribeBackups](~~98102~~) operation to query the backup IDs.', example='11111111'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteBackupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='3CF4F9FE-BF77-4739-8D68-B8DF5D******'),
}

model DeleteBackupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBackupResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that the cluster meets the following requirements:
  * *   The cluster is in the Running state.
  * *   The backup sets are in the Success state.
  * > *   You can call the [DescribeBackups](~~98102~~) operation to query the status of backup sets.
  * >*   After you delete the backup set file, the storage space that is occupied by the file is released. The released storage space is smaller than the size of the file because your snapshots share some data blocks
  *
  * @param request DeleteBackupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteBackupResponse
 */
async function deleteBackupWithOptions(request: DeleteBackupRequest, runtime: Util.RuntimeOptions): DeleteBackupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBackup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, make sure that the cluster meets the following requirements:
  * *   The cluster is in the Running state.
  * *   The backup sets are in the Success state.
  * > *   You can call the [DescribeBackups](~~98102~~) operation to query the status of backup sets.
  * >*   After you delete the backup set file, the storage space that is occupied by the file is released. The released storage space is smaller than the size of the file because your snapshots share some data blocks
  *
  * @param request DeleteBackupRequest
  * @return DeleteBackupResponse
 */
async function deleteBackup(request: DeleteBackupRequest): DeleteBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBackupWithOptions(request, runtime);
}

model DeleteDBClusterRequest {
  backupRetentionPolicyOnClusterDeletion?: string(name='BackupRetentionPolicyOnClusterDeletion', description='The retention policy for the backup sets when you delete the cluster. Valid values:

*   **ALL**: permanently retains all backups.
*   **LATEST**: permanently retains the most recent backup. A backup is automatically created before you delete the cluster.
*   **NONE**: No backup sets are retained after you delete the cluster.', example='NONE'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDBClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model DeleteDBClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDBClusterResponseBody(name='body'),
}

async function deleteDBClusterWithOptions(request: DeleteDBClusterRequest, runtime: Util.RuntimeOptions): DeleteDBClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupRetentionPolicyOnClusterDeletion)) {
    query['BackupRetentionPolicyOnClusterDeletion'] = request.backupRetentionPolicyOnClusterDeletion;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDBCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDBCluster(request: DeleteDBClusterRequest): DeleteDBClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBClusterWithOptions(request, runtime);
}

model DeleteDBClusterEndpointRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-******************'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the custom cluster endpoint.', example='pe-******************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDBClusterEndpointResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CD3FA5F3-FAF3-44CA-AFFF-BAF869******'),
}

model DeleteDBClusterEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDBClusterEndpointResponseBody(name='body'),
}

async function deleteDBClusterEndpointWithOptions(request: DeleteDBClusterEndpointRequest, runtime: Util.RuntimeOptions): DeleteDBClusterEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDBClusterEndpoint',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDBClusterEndpoint(request: DeleteDBClusterEndpointRequest): DeleteDBClusterEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBClusterEndpointWithOptions(request, runtime);
}

model DeleteDBEndpointAddressRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

>  You can call the [DescribeDBClusters](~~98094~~) operation to query the details of all clusters that belong to your account, such as the cluster ID.', example='pc-************'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.

>  You can call the [DescribeDBClusterEndpoints](~~98205~~) operation to query the endpoints of a specified PolarDB cluster.', example='pe-***************'),
  netType?: string(name='NetType', description='The network type of the endpoint. Set the value to **Public** (public network).', example='Public'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDBEndpointAddressResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model DeleteDBEndpointAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDBEndpointAddressResponseBody(name='body'),
}

/**
  * > *   You can delete a public-facing or classic network endpoint of the primary endpoint, the default cluster endpoint, or a custom cluster endpoint.
  * > *   Classic network endpoints are supported only on the China site (aliyun.com). Therefore, you do not need to delete classic network endpoints on the International site (alibabacloud.com).
  *
  * @param request DeleteDBEndpointAddressRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDBEndpointAddressResponse
 */
async function deleteDBEndpointAddressWithOptions(request: DeleteDBEndpointAddressRequest, runtime: Util.RuntimeOptions): DeleteDBEndpointAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDBEndpointAddress',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > *   You can delete a public-facing or classic network endpoint of the primary endpoint, the default cluster endpoint, or a custom cluster endpoint.
  * > *   Classic network endpoints are supported only on the China site (aliyun.com). Therefore, you do not need to delete classic network endpoints on the International site (alibabacloud.com).
  *
  * @param request DeleteDBEndpointAddressRequest
  * @return DeleteDBEndpointAddressResponse
 */
async function deleteDBEndpointAddress(request: DeleteDBEndpointAddressRequest): DeleteDBEndpointAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBEndpointAddressWithOptions(request, runtime);
}

model DeleteDBLinkRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the source cluster where a database link is to be deleted.

>  You can call the [DescribeDBClusters](~~173433~~) operation to query PolarDB clusters.', example='pc-**************'),
  DBLinkName?: string(name='DBLinkName', description='The name of the database link to be deleted.', example='dblink_test'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDBLinkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F9F1CB1A-B1D5-4EF5-A53A-************'),
}

model DeleteDBLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDBLinkResponseBody(name='body'),
}

async function deleteDBLinkWithOptions(request: DeleteDBLinkRequest, runtime: Util.RuntimeOptions): DeleteDBLinkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBLinkName)) {
    query['DBLinkName'] = request.DBLinkName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDBLink',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDBLink(request: DeleteDBLinkRequest): DeleteDBLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBLinkWithOptions(request, runtime);
}

model DeleteDBNodesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a42***********'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-**************'),
  DBNodeId?: [ string ](name='DBNodeId', description='The IDs of the nodes.

> You can call the [DescribeDBClusters](~~185342~~) operation to query the details of all clusters that belong to your Alibaba Cloud account, such as the cluster ID.', example='pi-************'),
  DBNodeType?: string(name='DBNodeType', description='The type of the node. Valid values:

*   RO
*   STANDBY', example='RO'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDBNodesResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-**************'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2035638*******'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6566B2E6-3157-4B57-A693-AFB751******'),
}

model DeleteDBNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDBNodesResponseBody(name='body'),
}

async function deleteDBNodesWithOptions(request: DeleteDBNodesRequest, runtime: Util.RuntimeOptions): DeleteDBNodesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeId)) {
    query['DBNodeId'] = request.DBNodeId;
  }
  if (!Util.isUnset(request.DBNodeType)) {
    query['DBNodeType'] = request.DBNodeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDBNodes',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDBNodes(request: DeleteDBNodesRequest): DeleteDBNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBNodesWithOptions(request, runtime);
}

model DeleteDatabaseRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*************'),
  DBName?: string(name='DBName', description='The name of the database.', example='testdb'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDatabaseResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model DeleteDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDatabaseResponseBody(name='body'),
}

/**
  * >- The cluster must be in the Running state and unlocked. Otherwise, the specified database cannot be deleted.
  * >- The delete operation is performed in an asynchronous manner. A long period of time may be required to delete a large database. A success response for this operation only indicates that the request to delete the database is sent. You must query the database to check whether the database is deleted.
  *
  * @param request DeleteDatabaseRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDatabaseResponse
 */
async function deleteDatabaseWithOptions(request: DeleteDatabaseRequest, runtime: Util.RuntimeOptions): DeleteDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDatabase',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >- The cluster must be in the Running state and unlocked. Otherwise, the specified database cannot be deleted.
  * >- The delete operation is performed in an asynchronous manner. A long period of time may be required to delete a large database. A success response for this operation only indicates that the request to delete the database is sent. You must query the database to check whether the database is deleted.
  *
  * @param request DeleteDatabaseRequest
  * @return DeleteDatabaseResponse
 */
async function deleteDatabase(request: DeleteDatabaseRequest): DeleteDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDatabaseWithOptions(request, runtime);
}

model DeleteGlobalDatabaseNetworkRequest {
  GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gdn-bp1fttxsrmv*****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DeleteGlobalDatabaseNetworkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C61892A4-0850-4516-9E26-44D96C1782DE'),
}

model DeleteGlobalDatabaseNetworkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGlobalDatabaseNetworkResponseBody(name='body'),
}

/**
  * >  You can delete a GDN only when the GDN includes only a primary cluster.
  *
  * @param request DeleteGlobalDatabaseNetworkRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteGlobalDatabaseNetworkResponse
 */
async function deleteGlobalDatabaseNetworkWithOptions(request: DeleteGlobalDatabaseNetworkRequest, runtime: Util.RuntimeOptions): DeleteGlobalDatabaseNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.GDNId)) {
    query['GDNId'] = request.GDNId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGlobalDatabaseNetwork',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can delete a GDN only when the GDN includes only a primary cluster.
  *
  * @param request DeleteGlobalDatabaseNetworkRequest
  * @return DeleteGlobalDatabaseNetworkResponse
 */
async function deleteGlobalDatabaseNetwork(request: DeleteGlobalDatabaseNetworkRequest): DeleteGlobalDatabaseNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGlobalDatabaseNetworkWithOptions(request, runtime);
}

model DeleteGlobalSecurityIPGroupRequest {
  globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name of the IP whitelist template must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (\\_).
*   The name must start with a letter and end with a letter or digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
  globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DeleteGlobalSecurityIPGroupResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      DBInstances?: [ string ](name='DBInstances', description='The clusters that are associated with the IP address whitelist template.'),
      GIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Multiple IP addresses are separated by commas (,). You can create up to 1,000 IP addresses or CIDR blocks for all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the global IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (\\_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the global IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroup', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model DeleteGlobalSecurityIPGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGlobalSecurityIPGroupResponseBody(name='body'),
}

async function deleteGlobalSecurityIPGroupWithOptions(request: DeleteGlobalSecurityIPGroupRequest, runtime: Util.RuntimeOptions): DeleteGlobalSecurityIPGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalIgName)) {
    query['GlobalIgName'] = request.globalIgName;
  }
  if (!Util.isUnset(request.globalSecurityGroupId)) {
    query['GlobalSecurityGroupId'] = request.globalSecurityGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGlobalSecurityIPGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGlobalSecurityIPGroup(request: DeleteGlobalSecurityIPGroupRequest): DeleteGlobalSecurityIPGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGlobalSecurityIPGroupWithOptions(request, runtime);
}

model DeleteMaskingRulesRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.', example='pc-*****************'),
  ruleNameList?: string(name='RuleNameList', description='The name of the masking rule. You can specify multiple masking rules at a time. Separate the masking rules with commas (,).

> You can call the [DescribeMaskingRules](~~212573~~) operation to query details of all the masking rules for a specified cluster, such as the names of the masking rules.', example='testrule'),
}

model DeleteMaskingRulesResponseBody = {
  message?: string(name='Message', description='The message that is returned for the request.

> If the request is successful, `Successful` is returned. If the request fails, an error message such as an error code is returned.', example='Successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2BCEE25B-797C-426B-BA7B-D28CCF******'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid value:

*   **true**
*   **false**', example='true'),
}

model DeleteMaskingRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMaskingRulesResponseBody(name='body'),
}

async function deleteMaskingRulesWithOptions(request: DeleteMaskingRulesRequest, runtime: Util.RuntimeOptions): DeleteMaskingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ruleNameList)) {
    query['RuleNameList'] = request.ruleNameList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMaskingRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMaskingRules(request: DeleteMaskingRulesRequest): DeleteMaskingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMaskingRulesWithOptions(request, runtime);
}

model DeleteParameterGroupRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parameterGroupId?: string(name='ParameterGroupId', description='The parameter template ID.

 
>  You can call the [DescribeParameterGroups](~~207178~~) operation to query the parameter template ID.', example='pcpg-**************'),
  regionId?: string(name='RegionId', description='The region ID.
 
>  You can call the [DescribeRegions](~~98041~~) operation to query available regions.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteParameterGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F7195E7-5F74-479D-AF59-1B4BF9******'),
}

model DeleteParameterGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteParameterGroupResponseBody(name='body'),
}

/**
  * You can use parameter templates to manage multiple parameters at a time and quickly apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](~~207009~~).
  * >  When you delete a parameter template, the parameter settings that are applied to PolarDB clusters are not affected.
  *
  * @param request DeleteParameterGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteParameterGroupResponse
 */
async function deleteParameterGroupWithOptions(request: DeleteParameterGroupRequest, runtime: Util.RuntimeOptions): DeleteParameterGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupId)) {
    query['ParameterGroupId'] = request.parameterGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteParameterGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can use parameter templates to manage multiple parameters at a time and quickly apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](~~207009~~).
  * >  When you delete a parameter template, the parameter settings that are applied to PolarDB clusters are not affected.
  *
  * @param request DeleteParameterGroupRequest
  * @return DeleteParameterGroupResponse
 */
async function deleteParameterGroup(request: DeleteParameterGroupRequest): DeleteParameterGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteParameterGroupWithOptions(request, runtime);
}

model DescribeAITaskStatusRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-xxxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAITaskStatusResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-xxxxxxxxxx'),
  requestId?: string(name='RequestId', description='The request ID.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
  status?: string(name='Status', description='The state of the PolarDB for AI feature. Valid values:

*   **1**: The feature is enabled.
*   **2**: The feature is disabled.', example='1'),
  statusName?: string(name='StatusName', description='The state description of the PolarDB for AI feature.'),
}

model DescribeAITaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAITaskStatusResponseBody(name='body'),
}

async function describeAITaskStatusWithOptions(request: DescribeAITaskStatusRequest, runtime: Util.RuntimeOptions): DescribeAITaskStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAITaskStatus',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAITaskStatus(request: DescribeAITaskStatusRequest): DescribeAITaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAITaskStatusWithOptions(request, runtime);
}

model DescribeAccountsRequest {
  accountName?: string(name='AccountName', description='The name of the account.', example='test_acc'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-***************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. Set this parameter to an integer that is larger than 0. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAccountsResponseBody = {
  accounts?: [ 
    {
      accountDescription?: string(name='AccountDescription', description='The description of the account.', example='test'),
      accountLockState?: string(name='AccountLockState', description='The locking state of the account. Valid values:

*   **UnLock**
*   **Lock**', example='UnLock'),
      accountName?: string(name='AccountName', description='The name of the account.', example='test_acc'),
      accountPasswordValidTime?: string(name='AccountPasswordValidTime', description='The validity period of the password.', example='undefined'),
      accountStatus?: string(name='AccountStatus', description='The state of the account. Valid values:

*   **Creating**: The account is being created.
*   **Available**: The account is available.
*   **Deleting**: The account is being deleted', example='Available'),
      accountType?: string(name='AccountType', description='The type of the account. Valid values:

*   **Normal**: a standard account
*   **Super**: a privileged account', example='Normal'),
      databasePrivileges?: [ 
        {
          accountPrivilege?: string(name='AccountPrivilege', description='The permissions that the account is granted on the database. Valid values:', example='ReadOnly'),
          DBName?: string(name='DBName', description='The name of the database.', example='DBtest'),
        }
      ](name='DatabasePrivileges', description='The list of database permissions that are granted to the account.'),
    }
  ](name='Accounts', description='The details of the account.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page returned.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='155462B9-205F-4FFC-BB43-4855FE******'),
}

model DescribeAccountsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAccountsResponseBody(name='body'),
}

async function describeAccountsWithOptions(request: DescribeAccountsRequest, runtime: Util.RuntimeOptions): DescribeAccountsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAccounts',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAccounts(request: DescribeAccountsRequest): DescribeAccountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccountsWithOptions(request, runtime);
}

model DescribeAutoRenewAttributeRequest {
  DBClusterIds?: string(name='DBClusterIds', description='The ID of the cluster. If you need to specify multiple cluster IDs, separate the cluster IDs with commas (,).', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value must be an integer that is larger than 0 and does not exceed the maximum value of the INTEGER data type. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 30, 50, and 100. Default value: 30.', example='30'),
  regionId?: string(name='RegionId', description='The ID of the region.

>  You can call the [DescribeRegions](~~98041~~) operation to query the region ID details.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-re*********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAutoRenewAttributeResponseBody = {
  items?: {
    autoRenewAttribute?: [ 
    {
      autoRenewEnabled?: boolean(name='AutoRenewEnabled', description='Indicates whether the auto-renewal feature is enabled. Valid values:

*   true: enabled
*   false: disabled', example='true'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-*****************'),
      duration?: int32(name='Duration', description='The renewal duration.', example='4'),
      periodUnit?: string(name='PeriodUnit', description='The unit of the duration. Valid values:

*   Year
*   Month', example='Month'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      renewalStatus?: string(name='RenewalStatus', description='The renewal status. Valid values:

*   AutoRenewal: The cluster is automatically renewed.
*   Normal: The cluster is manually renewed. The system sends a text message to remind you before the cluster expires.
*   NotRenewal: The cluster is not renewed. The system does not send a reminder for expiration but only sends a text message three days before the cluster expires to remind you that the cluster is not renewed.', example='AutoRenewal'),
    }
  ](name='AutoRenewAttribute')
  }(name='Items', description='The renewal information about the clusters.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page returned.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The total number of pages returned.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='65D7ACE6-4A61-4B6E-B357-8CB24A******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of entries.', example='1'),
}

model DescribeAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAutoRenewAttributeResponseBody(name='body'),
}

async function describeAutoRenewAttributeWithOptions(request: DescribeAutoRenewAttributeRequest, runtime: Util.RuntimeOptions): DescribeAutoRenewAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterIds)) {
    query['DBClusterIds'] = request.DBClusterIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAutoRenewAttribute',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAutoRenewAttribute(request: DescribeAutoRenewAttributeRequest): DescribeAutoRenewAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAutoRenewAttributeWithOptions(request, runtime);
}

model DescribeBackupLogsRequest {
  backupRegion?: string(name='BackupRegion', description='The region for the backup data.', example='cn-hangzhou'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-**************'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.', example='2020-02-12T15:00Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. The value must be an integer that is larger than 0. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.', example='2020-02-01T15:00Z'),
}

model DescribeBackupLogsResponseBody = {
  items?: {
    backupLog?: [ 
    {
      backupLogEndTime?: string(name='BackupLogEndTime', description='The time when the backup task ended. The time follows the ISO 8601 standard in the `YYYY-MM-DD\\"T\\"HH:mm:ssZ` format. The time is displayed in UTC.', example='2020-02-12T03:55:31Z'),
      backupLogId?: string(name='BackupLogId', description='The ID of the backup log.', example='1111111111'),
      backupLogName?: string(name='BackupLogName', description='The name of the backup log.', example='ib_logfile1'),
      backupLogSize?: string(name='BackupLogSize', description='The size of the backup log. Unit: bytes.', example='1073741824'),
      backupLogStartTime?: string(name='BackupLogStartTime', description='The time when the backup task started. The time follows the ISO 8601 standard in the `YYYY-MM-DD\\"T\\"HH:mm:ssZ` format. The time is displayed in UTC.', example='2020-02-12T03:54:43Z'),
      downloadLink?: string(name='DownloadLink', description='The public URL used to download the backup log.', example='http://***********.oss-cn-hangzhou.aliyuncs.com'),
      intranetDownloadLink?: string(name='IntranetDownloadLink', description='The internal URL used to download the backup log.', example='http://***********.oss-cn-hangzhou-internal.aliyuncs.com'),
      linkExpiredTime?: string(name='LinkExpiredTime', description='The time when the download URL expires.', example='2020-02-14T08:40:50Z'),
    }
  ](name='BackupLog')
  }(name='Items', description='The details of the backup logs.'),
  pageNumber?: string(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageRecordCount?: string(name='PageRecordCount', description='The number of entries returned per page.', example='2'),
  requestId?: string(name='RequestId', description='The request ID.', example='ADAC63DB-0691-4ECE-949A-FAEA68******'),
  totalRecordCount?: string(name='TotalRecordCount', description='The total number of returned entries.', example='2'),
}

model DescribeBackupLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupLogsResponseBody(name='body'),
}

async function describeBackupLogsWithOptions(request: DescribeBackupLogsRequest, runtime: Util.RuntimeOptions): DescribeBackupLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupRegion)) {
    query['BackupRegion'] = request.backupRegion;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupLogs',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupLogs(request: DescribeBackupLogsRequest): DescribeBackupLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupLogsWithOptions(request, runtime);
}

model DescribeBackupPolicyRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.', example='pc-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeBackupPolicyResponseBody = {
  backupFrequency?: string(name='BackupFrequency', description='The backup frequency. Default value: Normal. Valid values:

*   **Normal**: standard backup. The system backs up data once a day.
*   **2/24H**: enhanced backup. The system backs up data every 2 hours.
*   **3/24H**: enhanced backup. The system backs up data every 3 hours.
*   **4/24H**: enhanced backup. The system backs up data every 4 hours.

> - If enhanced backup is enabled, all backups are retained for 24 hours. Backups are automatically deleted when the retention period ends. However, the system permanently retains the first backup that is created after 00:00 every day.
>-  If enhanced backup is enabled, **PreferredBackupPeriod** is automatically set to all days in a week (from Monday to Sunday).', example='Normal'),
  backupRetentionPolicyOnClusterDeletion?: string(name='BackupRetentionPolicyOnClusterDeletion', description='Indicates whether backups are retained when you delete a cluster. Valid values:

*   **ALL**: permanently retains all backups.
*   **LATEST**: permanently retains only the last backup.
*   **NONE**: does not retain backups.', example='NONE'),
  dataLevel1BackupFrequency?: string(name='DataLevel1BackupFrequency', description='The backup frequency of level-1 backups. Default value: Normal. Valid values:

*   **Normal**: standard backup. The system backs up data once a day.
*   **2/24H**: frequent backup. The system backs up data every 2 hours.
*   **3/24H**: frequent backup. The system backs up data every 3 hours.
*   **4/24H**: frequent backup. The system backs up data every 4 hours.

>- This parameter is not supported for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is unavailable if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about regions that support the cross-region backup feature, see [Overview](~~72672~~).', example='Normal'),
  dataLevel1BackupPeriod?: string(name='DataLevel1BackupPeriod', description='The backup cycle of level-1 backups. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is not supported for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is unavailable if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about regions that support the cross-region backup feature, see [Overview](~~72672~~).', example='Monday,Tuesday'),
  dataLevel1BackupRetentionPeriod?: string(name='DataLevel1BackupRetentionPeriod', description='The retention period of level-1 backups. Valid values: 3 to 14. Unit: day.', example='7'),
  dataLevel1BackupTime?: string(name='DataLevel1BackupTime', description='The period of time during which automatic backup is performed. The value must be in the `hh:mmZ-hh:mmZ` format. The time must be in UTC. The start time and the end time must be on the hour and must have an interval of 1 hour. Example: `14:00Z-15:00Z`.

>- This parameter is not supported for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is unavailable if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about regions that support the cross-region backup feature, see [Overview](~~72672~~).', example='15:00Z-16:00Z'),
  dataLevel2BackupAnotherRegionRegion?: string(name='DataLevel2BackupAnotherRegionRegion', description='The region where the cross-region level-2 backup is stored. For information about regions that support the cross-region backup feature, see [Overview](~~72672~~).', example='cn-hangzhou'),
  dataLevel2BackupAnotherRegionRetentionPeriod?: string(name='DataLevel2BackupAnotherRegionRetentionPeriod', description='The retention period of cross-region level-2 backups. Valid values:

*   **0**: The cross-region level-2 backup feature is disabled.
*   **30 to 7300**: Cross-region level-2 backups are retained for 30 to 7,300 days.
*   **1**: Cross-region level-2 backups are permanently retained.

> The default value is **0**. By default, the level-2 backup feature is disabled when you create a cluster.', example='30'),
  dataLevel2BackupPeriod?: string(name='DataLevel2BackupPeriod', description='The backup cycle of level-2 backups. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is not supported for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is unavailable if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about regions that support the cross-region backup feature, see [Overview](~~72672~~).', example='Monday,Tuesday'),
  dataLevel2BackupRetentionPeriod?: string(name='DataLevel2BackupRetentionPeriod', description='The retention period of level-2 backups. Valid values:

*   0: The level-2 backup feature is disabled.
*   30 to 7300: Level-2 backups are retained for 30 to 7,300 days.
*   \\-1: Level-2 backups are permanently retained.

> The default value is **0**. By default, the level-2 backup feature is disabled when you create a cluster.', example='0'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod', description='The backup cycle. Valid values:

*   Monday
*   Tuesday
*   Wednesday
*   Thursday
*   Friday
*   Saturday
*   Sunday', example='Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday'),
  preferredBackupTime?: string(name='PreferredBackupTime', description='The time period when automatic backups are performed. The format is `HH:mmZ-HH:mmZ`. The time is displayed in UTC.', example='07:00Z-08:00Z'),
  preferredNextBackupTime?: string(name='PreferredNextBackupTime', description='The time when the next automatic backup will be performed. The format is `YYYY-MM-DDThh:mmZ`. The time is displayed in UTC.', example='2020-11-16T07:30Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EADFCE0F-9FB5-4685-B395-1440B******'),
}

model DescribeBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupPolicyResponseBody(name='body'),
}

async function describeBackupPolicyWithOptions(request: DescribeBackupPolicyRequest, runtime: Util.RuntimeOptions): DescribeBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupPolicy',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupPolicy(request: DescribeBackupPolicyRequest): DescribeBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupPolicyWithOptions(request, runtime);
}

model DescribeBackupTasksRequest {
  backupJobId?: string(name='BackupJobId', description='The ID of the backup task.', example='11111111'),
  backupMode?: string(name='BackupMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Manual'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-***************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeBackupTasksResponseBody = {
  items?: {
    backupJob?: [ 
    {
      backupJobId?: string(name='BackupJobId', description='The ID of the backup task.', example='11111111'),
      backupProgressStatus?: string(name='BackupProgressStatus', description='The state of the backup task. Valid values:

*   **NoStart**
*   **Preparing**
*   **Waiting**
*   **Uploading**
*   **Checking**
*   **Finished**', example='NoStart'),
      jobMode?: string(name='JobMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Automated'),
      process?: string(name='Process', description='The progress of the backup task in percentage.', example='0'),
      startTime?: string(name='StartTime', description='The time when the backup task started. The time follows the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.', example='2020-08-08T07:24:01Z'),
      taskAction?: string(name='TaskAction', description='The type of the backup task. Valid values:

*   **TempBackupTask**: The backup task is an adhoc backup task.
*   **NormalBackupTask**: The backup task is a common backup task.', example='NormalBackupTask'),
    }
  ](name='BackupJob')
  }(name='Items', description='The details of the backup task.'),
  requestId?: string(name='RequestId', description='The request ID.', example='FA8C1EF1-E3D4-44D7-B809-823187******'),
}

model DescribeBackupTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupTasksResponseBody(name='body'),
}

async function describeBackupTasksWithOptions(request: DescribeBackupTasksRequest, runtime: Util.RuntimeOptions): DescribeBackupTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupJobId)) {
    query['BackupJobId'] = request.backupJobId;
  }
  if (!Util.isUnset(request.backupMode)) {
    query['BackupMode'] = request.backupMode;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupTasks',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupTasks(request: DescribeBackupTasksRequest): DescribeBackupTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupTasksWithOptions(request, runtime);
}

model DescribeBackupsRequest {
  backupId?: string(name='BackupId', description='The ID of the backup set.', example='11111111'),
  backupMode?: string(name='BackupMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Automated'),
  backupRegion?: string(name='BackupRegion', description='The region where the cross-region data backup file of the instance is stored.

> This parameter is valid only for PolarDB for MySQL clusters.', example='cn-hangzhou'),
  backupStatus?: string(name='BackupStatus', description='The status of the backup set. Valid values:

*   **Success**
*   **Failed**', example='Success'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-****************'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the `YYYY-MM-DDThh:mmZ` format. The time must be in UTC. The end time must be later than the start time.', example='2020-11-16T00:00Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value must be a positive integer that does not exceed the maximum value of the INTEGER data type. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.', example='2020-11-14T00:00Z'),
}

model DescribeBackupsResponseBody = {
  items?: {
    backup?: [ 
    {
      backupEndTime?: string(name='BackupEndTime', description='The end time of the backup task. The time is displayed in UTC.', example='2020-11-15T07:30:20Z'),
      backupId?: string(name='BackupId', description='The ID of the backup set.', example='61*******'),
      backupMethod?: string(name='BackupMethod', description='The backup method. Only **Snapshot** may be returned.', example='Snapshot'),
      backupMode?: string(name='BackupMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Automated'),
      backupSetSize?: string(name='BackupSetSize', description='The size of the backup set. Unit: bytes.

> After you delete the target snapshot backups, the storage space that is consumed by the backups is released. The released storage space is smaller than the size of the backup file, because the snapshots share specific data blocks. For more information, see [FAQ about backup](~~164881~~).', example='4639948800'),
      backupStartTime?: string(name='BackupStartTime', description='The start time of the backup task. The time is displayed in UTC. Unit: seconds.', example='2020-11-15T07:30:05Z'),
      backupStatus?: string(name='BackupStatus', description='The status of the backup set. Valid values:

*   **Success**
*   **Failed**', example='Success'),
      backupType?: string(name='BackupType', description='The type of the backup. Only **FullBackup** may be returned.', example='FullBackup'),
      backupsLevel?: string(name='BackupsLevel', description='The level of the backup set. Valid values:

*   **Level-1**
*   **Level-2**', example='Level-1'),
      consistentTime?: string(name='ConsistentTime', description='The snapshot checkpoint time. The value follows the Unix time format. Unit: seconds.', example='1605425407'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-****************'),
      expectExpireTime?: string(name='ExpectExpireTime', description='�The expected expiration time of the backup set (This parameter is supported only for instances that are enabled with sparse backup).', example='2022-10-24T08:13:23Z'),
      expectExpireType?: string(name='ExpectExpireType', description='The expected expiration type of the backup set (This parameter is supported only for instances that are enabled with sparse backup).

Valid values:

*   NEVER

    <!-- -->

    <!-- -->

    <!-- -->

*   EXPIRED

    <!-- -->

    <!-- -->

    <!-- -->

*   DELAY

    <!-- -->

    <!-- -->

    <!-- -->', example='EXPIRED  '),
      isAvail?: string(name='IsAvail', description='Indicates whether the backup set is available. Valid values:

*   **0**: The backup set is unavailable.
*   **1**: The backup set is available.', example='0'),
    }
  ](name='Backup')
  }(name='Items', description='The details of backup sets.'),
  pageNumber?: string(name='PageNumber', description='The page number.', example='1'),
  pageRecordCount?: string(name='PageRecordCount', description='The number of entries per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='24A1990B-4F6E-482B-B8CB-75C612******'),
  totalRecordCount?: string(name='TotalRecordCount', description='The total number of returned entries.', example='1'),
}

model DescribeBackupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupsResponseBody(name='body'),
}

async function describeBackupsWithOptions(request: DescribeBackupsRequest, runtime: Util.RuntimeOptions): DescribeBackupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.backupMode)) {
    query['BackupMode'] = request.backupMode;
  }
  if (!Util.isUnset(request.backupRegion)) {
    query['BackupRegion'] = request.backupRegion;
  }
  if (!Util.isUnset(request.backupStatus)) {
    query['BackupStatus'] = request.backupStatus;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackups',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackups(request: DescribeBackupsRequest): DescribeBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupsWithOptions(request, runtime);
}

model DescribeCharacterSetNameRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can only query character sets that PolarDB for MySQL clusters support. If you enter the ID of a PolarDB for PostgreSQL or PolarDB for Oracle cluster, the returned value of the `CharacterSetNameItems` parameter is an empty string.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

> You can call the [DescribeRegions](~~98041~~) operation to query available regions.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeCharacterSetNameResponseBody = {
  characterSetNameItems?: {
    characterSetName?: [ string ](name='CharacterSetName')
  }(name='CharacterSetNameItems', description='The character sets that are supported.'),
  engine?: string(name='Engine', description='The type of the database engine.', example='POLARDB'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='34458CD3-33E0-4624-BFEF-840C15******'),
}

model DescribeCharacterSetNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCharacterSetNameResponseBody(name='body'),
}

async function describeCharacterSetNameWithOptions(request: DescribeCharacterSetNameRequest, runtime: Util.RuntimeOptions): DescribeCharacterSetNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCharacterSetName',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCharacterSetName(request: DescribeCharacterSetNameRequest): DescribeCharacterSetNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCharacterSetNameWithOptions(request, runtime);
}

model DescribeClassListRequest {
  commodityCode?: string(name='CommodityCode', description='The maximum number of IOPS.', example='polardb_sub'),
  masterHa?: string(name='MasterHa', description='The number of nodes. Valid values:

*   single
*   cluster
*   all', example='cluster'),
  orderType?: string(name='OrderType', description='The specification type of the cluster.', example='BUY'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The number of CPU cores.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the request.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeClassListResponseBody = {
  items?: [ 
    {
      classCode?: string(name='ClassCode', description='The specifications of the cluster.', example='polar.mysql.x4.medium'),
      classGroup?: string(name='ClassGroup', description='The instance family of the cluster. Valid values:

*   Exclusive package: dedicated
*   Exclusive physical machine: dedicated host
*   Beginner: starter
*   Historical specifications: historical', example='Exclusive package'),
      classTypeLevel?: string(name='ClassTypeLevel', description='The specification type of the cluster.', example='enterprise'),
      cpu?: string(name='Cpu', description='The number of vCPU cores. Unit: cores.', example='8'),
      maxConnections?: string(name='MaxConnections', description='The maximum number of concurrent connections in the cluster.', example='8000'),
      maxIOPS?: string(name='MaxIOPS', description='The maximum IOPS. Unit: operations per second.', example='32000'),
      maxStorageCapacity?: string(name='MaxStorageCapacity', description='The maximum storage capacity. Unit: TB.', example='20'),
      memoryClass?: string(name='MemoryClass', description='The memory size. Unit: GB.', example='32'),
      pl1MaxIOPS?: string(name='Pl1MaxIOPS', description='The maximum IOPS of an enhanced SSD (ESSD) of performance level 1 (PL1). Unit: operations per second.', example='50000'),
      pl2MaxIOPS?: string(name='Pl2MaxIOPS', description='The maximum IOPS of an ESSD of performance level 2 (PL2). Unit: operations per second.', example='100000'),
      pl3MaxIOPS?: string(name='Pl3MaxIOPS', description='The maximum IOPS of an ESSD of performance level 3 (PL3). Unit: operations per second.', example='1000000'),
      psl4MaxIOPS?: string(name='Psl4MaxIOPS', description='The maximum Input/output operations per second (IOPS) for PolarStore Level 4 (PSL4). Unit: operations per second.', example='48000'),
      psl5MaxIOPS?: string(name='Psl5MaxIOPS', description='The maximum IOPS for PolarStore Level 5 (PSL5). Unit: operations per second.', example='96000'),
      referenceExtPrice?: string(name='ReferenceExtPrice', description='The additional price.

Unit: cents (USD).

>- If you set MasterHa to cluster or single, the value of ReferenceExtPrice is the same as the value of ReferencePrice.
>- If you set MasterHa to cluster or single, the value of ReferenceExtPrice is the price of the single-node cluster.', example='200000'),
      referencePrice?: string(name='ReferencePrice', description='The price.

Unit: cents (USD).

>- If you set CommodityCode to a commodity that uses the pay-as-you-go billing method, ReferencePrice indicates the hourly fee that you need to pay.
>- If you set CommodityCode to a commodity that uses the subscription billing method, ReferencePrice indicates the monthly fee that you need to pay.', example='200000'),
    }
  ](name='Items', description='The specifications of the cluster.'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='The price.

Unit: cents (US dollars).

> *   If you set the CommodityCode parameter to a value that indicates the pay-as-you-go billing method, the ReferencePrice parameter specifies the hourly fee that you must pay.
> *   If you set the CommodityCode parameter to a value that indicates the subscription billing method, the ReferencePrice parameter specifies the monthly fee that you must pay.', example='69A85BAF-1089-4CDF-A82F-0A140F******'),
}

model DescribeClassListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClassListResponseBody(name='body'),
}

async function describeClassListWithOptions(request: DescribeClassListRequest, runtime: Util.RuntimeOptions): DescribeClassListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.commodityCode)) {
    query['CommodityCode'] = request.commodityCode;
  }
  if (!Util.isUnset(request.masterHa)) {
    query['MasterHa'] = request.masterHa;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClassList',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClassList(request: DescribeClassListRequest): DescribeClassListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClassListWithOptions(request, runtime);
}

model DescribeDBClusterAccessWhitelistRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the PolarDB cluster.', example='pc-***************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterAccessWhitelistResponseBody = {
  DBClusterSecurityGroups?: {
    DBClusterSecurityGroup?: [ 
    {
      securityGroupId?: string(name='SecurityGroupId', description='The ID of the ECS security group.', example='sg-bp**************'),
      securityGroupName?: string(name='SecurityGroupName', description='The name of the ECS security group.', example='vpc-********************'),
    }
  ](name='DBClusterSecurityGroup')
  }(name='DBClusterSecurityGroups', description='The Elastic Compute Service (ECS) security groups that are associated with the cluster.'),
  items?: {
    DBClusterIPArray?: [ 
    {
      DBClusterIPArrayAttribute?: string(name='DBClusterIPArrayAttribute', description='The attributes of the IP whitelist group. Set this parameter to **hidden** to hide the IP whitelist group in the console.

> *   The IP whitelist group that has appeared in the console cannot be hidden.
> *   This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='hidden'),
      DBClusterIPArrayName?: string(name='DBClusterIPArrayName', description='The name of the IP whitelist group. The group name must be 2 to 120 characters in length and consists of lowercase letters and digits. It must start with a letter, and end with a letter or a digit.

*   If the specified whitelist group name does not exist, the whitelist group is created.
*   If the specified whitelist group name exists, the whitelist group is modified.
*   If you do not specify this parameter, the default group is modified.

> *   You can create a maximum of 50 IP whitelist groups for a cluster.
>*   This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='default'),
      securityIps?: string(name='SecurityIps', description='The IP addresses or Classless Inter-Domain Routing (CIDR) blocks in the IP whitelist group. You can add 1,000 IP addresses or CIDR blocks to all the IP whitelist groups. Separate multiple IP addresses with commas (,). The following two formats are supported:

*   IP addresses. Example: 10.23.12.24.
*   CIDR blocks. Example: 10.23.12.24/24. 24 indicates the length of the prefix of the CIDR block. The length is the range of 1 to 32.

>  This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='11.***.***.***,11.***.***.***'),
    }
  ](name='DBClusterIPArray')
  }(name='Items', description='The details about the cluster.'),
  requestId?: string(name='RequestId', description='The request ID.', example='559E91A2-CDA3-4E9F-808B-29D738******'),
}

model DescribeDBClusterAccessWhitelistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBClusterAccessWhitelistResponseBody(name='body'),
}

async function describeDBClusterAccessWhitelistWithOptions(request: DescribeDBClusterAccessWhitelistRequest, runtime: Util.RuntimeOptions): DescribeDBClusterAccessWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterAccessWhitelist',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBClusterAccessWhitelist(request: DescribeDBClusterAccessWhitelistRequest): DescribeDBClusterAccessWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterAccessWhitelistWithOptions(request, runtime);
}

model DescribeDBClusterAttributeRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.', example='pc-*****************'),
  describeType?: string(name='DescribeType', description='Specifies whether to query information about AI-related nodes.', example='AI'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterAttributeResponseBody = {
  aiType?: string(name='AiType', description='The information status of the AI node. Valid values:

*   SearchNode: search node.
*   DLNode: AI node', example='DLNode'),
  architecture?: string(name='Architecture'),
  blktagTotal?: long(name='BlktagTotal', description='Maximum blktags in file system.', example='7,864,320'),
  blktagUsed?: long(name='BlktagUsed', description='The current blktag usage.', example='5,242,880'),
  category?: string(name='Category', description='[The edition of PolarDB](~~183258~~). Valid values:

*   **Normal**: Cluster Edition.
*   **Basic**: Single Node Edition.
*   **Archive**: X-Engine Edition.
*   **NormalMultimaster**: Multi-master Cluster Edition.
*   **SENormal**: Standard Edition.

>-  Only PolarDB for MySQL supports Single Node Edition.
>- Only PolarDB for MySQL 8.0.1 supports Standard Edition.
>- Only PolarDB for MySQL 8.0 supports X-Engine Edition and Multi-master Cluster Edition.', example='Normal'),
  compressStorageMode?: string(name='CompressStorageMode'),
  creationTime?: string(name='CreationTime', description='The time when the cluster was created.', example='2020-08-14T05:58:42Z'),
  DBClusterDescription?: string(name='DBClusterDescription', description='The description of the cluster.', example='test'),
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-*****************'),
  DBClusterNetworkType?: string(name='DBClusterNetworkType', description='The network type of the cluster.', example='VPC'),
  DBClusterStatus?: string(name='DBClusterStatus', description='The status of the cluster. For information about the valid values, see [Cluster states](~~99286~~).', example='Running'),
  DBNodes?: [ 
    {
      addedCpuCores?: string(name='AddedCpuCores', description='The number of CPU cores for compute node scale-out within seconds.', example='6'),
      cpuCores?: string(name='CpuCores'),
      creationTime?: string(name='CreationTime', description='The time when the node was created.', example='2020-03-23T21:35:43Z'),
      DBNodeClass?: string(name='DBNodeClass', description='The type of the node.', example='polar.mysql.x4.large'),
      DBNodeId?: string(name='DBNodeId', description='The ID of the node.', example='pi-****************'),
      DBNodeRole?: string(name='DBNodeRole', description='The role of the node. Valid values:

*   **Writer**: The node is the primary node.
*   **Reader**: The node is a read-only node.', example='Reader'),
      DBNodeStatus?: string(name='DBNodeStatus', description='The status of the node. Valid values:

*   **Creating**: The cluster is being created.
*   **Running**: The cluster is running.
*   **Deleting**: The cluster is being deleted.
*   **Rebooting**: The cluster is restarting.
*   **DBNodeCreating**: PolarProxy is being added.
*   **DBNodeDeleting**: PolarProxy is being deleted.
*   **ClassChanging**: The specification type of PolarProxy are being modified.
*   **NetAddressCreating**: The network connection is being created.
*   **NetAddressDeleting**: The network connection is being deleted.
*   **NetAddressModifying**: The network connection is being modified.
*   **MinorVersionUpgrading**: The minor version is being updated.
*   **Maintaining**: The cluster is being maintained.
*   **Switching**: A failover is being performed.', example='Running'),
      failoverPriority?: int32(name='FailoverPriority', description='The failover priority. Each node is assigned a failover priority. If a failover occurs, a node can be selected as a primary node. The priority determines the probability at which a node is selected as a primary node. A larger value indicates a higher priority. Valid values: 1 to 15.', example='1'),
      hotReplicaMode?: string(name='HotReplicaMode', description='Indicates whether the hot standby feature is enabled. Valid values:

*   **ON**
*   **OFF**', example='ON'),
      imciSwitch?: string(name='ImciSwitch', description='Indicates whether the In-Memory Column Index (IMCI) feature is enabled. Valid values:

*   **ON**
*   **OFF**', example='ON'),
      masterId?: string(name='MasterId', description='The ID of the primary node in the cluster that runs Multi-master Cluster Edition.', example='pi-bp18z52akld3*****'),
      maxConnections?: int32(name='MaxConnections', description='The maximum number of concurrent connections in the cluster.', example='8000'),
      maxIOPS?: int32(name='MaxIOPS', description='The maximum input/output operations per second (IOPS).', example='32000'),
      memorySize?: string(name='MemorySize'),
      sccMode?: string(name='SccMode', description='Indicates whether the global consistency (high-performance mode) feature is enabled for the node. Valid values:

*   **ON**
*   **OFF**', example='ON'),
      serverWeight?: string(name='ServerWeight', description='The routing weight of the node. Valid values: 1 to 100 Default value: 1.', example='1'),
      serverlessType?: string(name='ServerlessType', description='The type of the serverless node. Only **AgileServerless** can be returned.

> This parameter is supported only for serverless clusters.', example='AgileServerless'),
      subCluster?: string(name='SubCluster'),
      zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-i'),
    }
  ](name='DBNodes', description='The details of the nodes.'),
  DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='8.0'),
  DBVersionStatus?: string(name='DBVersionStatus', description='The status of the minor version. Valid values:

*   **Stable**: The minor version is stable.
*   **Old**: The minor version is outdated. We recommend that you upgrade the cluster to the latest version.
*   **HighRisk**: The minor version has critical defects. We recommend that you immediately upgrade the cluster to the latest version.

> For more information about how to upgrade the minor version, see [Upgrade versions](~~158572~~).', example='Stable'),
  dataLevel1BackupChainSize?: long(name='DataLevel1BackupChainSize', description='The total physical storage of level-1 backups (snapshots). Unit: bytes.', example='74448896'),
  dataSyncMode?: string(name='DataSyncMode', description='Indicates the rule of data replication. Valid values: AsyncSync: asynchronous. SemiSync: semi-synchronous.', example='AsyncSync'),
  deletionLock?: int32(name='DeletionLock', description='Indicates whether the cluster is locked and can be deleted. Valid values:

*   **0**: The cluster is not locked and can be deleted.
*   **1**: The cluster is locked and cannot be deleted.', example='0'),
  engine?: string(name='Engine', description='The database type.', example='POLARDB'),
  expireTime?: string(name='ExpireTime', description='The time when the cluster expires.

> A specific value will be returned only for subscription (**Prepaid**) clusters. For pay-as-you-go (**Postpaid**) clusters, an empty string will be returned.', example='2020-11-14T16:00:00Z'),
  expired?: string(name='Expired', description='Indicates whether the cluster has expired. Valid values:

> This parameter is returned only for subscription (**Prepaid**) clusters.', example='false'),
  hasCompleteStandbyRes?: boolean(name='HasCompleteStandbyRes', description='Indicates whether to replenish resources for the primary database after a cross-zone switchover. Valid values: true false', example='false'),
  hotStandbyCluster?: string(name='HotStandbyCluster'),
  inodeTotal?: long(name='InodeTotal', description='Maximum inodes in file system.', example='6,291,456'),
  inodeUsed?: long(name='InodeUsed', description='The current inode usage.', example='4,194,304'),
  isLatestVersion?: boolean(name='IsLatestVersion', description='Indicates whether the kernel is of the latest version. Valid values:

*   **true**
*   **false**', example='false'),
  isProxyLatestVersion?: boolean(name='IsProxyLatestVersion', description='Indicates whether PolarProxy uses the latest version. Valid values:

*   **true**
*   **false**', example='false'),
  lockMode?: string(name='LockMode', description='The lock mode. Valid values:

*   **Unlock**: The cluster is not locked.
*   **ManualLock**: The cluster is manually locked.
*   **LockByExpiration**: The cluster is automatically locked due to cluster expiration.', example='Unlock'),
  maintainTime?: string(name='MaintainTime', description='The maintenance window of the cluster. The format is `HH:mmZ-HH:mmZ`. The time is displayed in UTC. For example, the value `16:00Z-17:00Z` indicates that the cluster can be maintained from 00:00 to 01:00 (UTC+08:00).', example='18:00Z-19:00Z'),
  payType?: string(name='PayType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go.
*   **Prepaid**: subscription', example='Prepaid'),
  provisionedIops?: string(name='ProvisionedIops'),
  proxyCpuCores?: string(name='ProxyCpuCores', description='The number of CPU cores for PolarProxy.', example='4'),
  proxyServerlessType?: string(name='ProxyServerlessType', description='The type of the serverless PolarProxy. Valid value: AgileServerless.', example='AgileServerless'),
  proxyStandardCpuCores?: string(name='ProxyStandardCpuCores', description='The number of CPU cores for PolarProxy Standard Enterprise Edition.', example='2'),
  proxyStatus?: string(name='ProxyStatus', description='The status of PolarProxy. Valid values:

*   **Creating**: PolarProxy is being created.
*   **Running**: PolarProxy is running.
*   **Deleting**: PolarProxy is being released.
*   **Rebooting**: PolarProxy is restarting.
*   **DBNodeCreating**: PolarProxy is being added.
*   **DBNodeDeleting**: PolarProxy is being deleted.
*   **ClassChanging**: The specifications of PolarProxy are being changed.
*   **NetAddressCreating**: The network connection is being created.
*   **NetAddressDeleting**: The network connection is being deleted.
*   **NetAddressModifying**: The network connection is being modified.
*   **Deleted**: PolarProxy is released.', example='Running'),
  proxyType?: string(name='ProxyType', description='The type of PolarProxy. Valid values:

*   **Exclusive**: Dedicated Enterprise Edition
*   **General**: Standard Enterprise Edition', example='Exclusive'),
  regionId?: string(name='RegionId', description='The region ID of the security group.', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='074467EF-86B9-4C23-ACBF-E9B81A******'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of your Alibaba Cloud resource group.', example='rg-***************'),
  SQLSize?: long(name='SQLSize', description='The storage of SQL. Unit: bytes. If the value is -1, no data is stored.', example='0'),
  serverlessType?: string(name='ServerlessType', description='The type of the serverless cluster. Only **AgileServerless** can be returned.', example='AgileServerless'),
  standbyHAMode?: string(name='StandbyHAMode', description='Indicates whether the cross-zone disaster recovery feature is enabled. Valid values: ON OFF 0: Customer Drill Mode', example='OFF'),
  storageMax?: long(name='StorageMax', description='The maximum storage capacity of the current cluster specification. Unit: bytes.', example='10995116277760'),
  storagePayType?: string(name='StoragePayType', description='The billing method of the storage. Valid values:

*   **Postpaid**: pay-as-you-go
*   **Prepaid**: subscription.', example='Prepaid'),
  storageSpace?: long(name='StorageSpace', description='The storage space that uses the subscription billing method. Unit: bytes.', example='50'),
  storageType?: string(name='StorageType', description='The storage type. Set the value to **HighPerformance**.', example='HighPerformance'),
  storageUsed?: long(name='StorageUsed', description='The storage space consumed by the cluster. Unit: bytes.', example='3012558848'),
  strictConsistency?: string(name='StrictConsistency', description='Indicates whether the multi-zone data consistency feature is enabled for the cluster. Valid values:

*   **ON**: Multi-zone data consistency is enabled, which is suitable for Standard Edition clusters that run Multi-zone Edition.
*   **OFF**', example='ON'),
  subCategory?: string(name='SubCategory', description='The specification type of the compute node. Valid values:

*   **Exclusive**: dedicated.
*   **General**: general-purpose.

> This parameter is supported only for PolarDB for MySQL clusters of Cluster Edition.', example='Exclusive'),
  tags?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='test'),
      value?: string(name='Value', description='The value of the tag.', example='MySQL'),
    }
  ](name='Tags', description='Details about the tags.'),
  VPCId?: string(name='VPCId', description='The VPC ID of the cluster.', example='vpc-*******************'),
  vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the cluster.', example='vsw-*********************'),
  zoneIds?: string(name='ZoneIds', description='The zone ID of the cluster.', example='cn-hangzhou-i,cn-hangzhou-g'),
}

model DescribeDBClusterAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBClusterAttributeResponseBody(name='body'),
}

async function describeDBClusterAttributeWithOptions(request: DescribeDBClusterAttributeRequest, runtime: Util.RuntimeOptions): DescribeDBClusterAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.describeType)) {
    query['DescribeType'] = request.describeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterAttribute',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBClusterAttribute(request: DescribeDBClusterAttributeRequest): DescribeDBClusterAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterAttributeWithOptions(request, runtime);
}

model DescribeDBClusterAuditLogCollectorRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-***************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterAuditLogCollectorResponseBody = {
  collectorStatus?: string(name='CollectorStatus', description='The status of SQL data collector. Valid values:

*   Enable: SQL data collector is enabled.
*   Disabled: SQL data collector is disabled.', example='Disabled'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='59011D2B-2A38-4207-A86C-72BC1F882D19'),
}

model DescribeDBClusterAuditLogCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBClusterAuditLogCollectorResponseBody(name='body'),
}

async function describeDBClusterAuditLogCollectorWithOptions(request: DescribeDBClusterAuditLogCollectorRequest, runtime: Util.RuntimeOptions): DescribeDBClusterAuditLogCollectorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterAuditLogCollector',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBClusterAuditLogCollector(request: DescribeDBClusterAuditLogCollectorRequest): DescribeDBClusterAuditLogCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterAuditLogCollectorWithOptions(request, runtime);
}

model DescribeDBClusterAvailableResourcesRequest {
  DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node. For more information, see [Specifications of compute nodes](~~102542~~).', example='polar.mysql.x4.large'),
  DBType?: string(name='DBType', description='The type of the database engine. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine. Valid values for the MySQL database engine:

*   **5.6**
*   **5.7**
*   **8.0**

Valid values for the PostgreSQL database engine:

*   **11**
*   **14**

Valid value for the Oracle database engine: **11**

> This parameter is required when you specify the **DBType** parameter.', example='5.6'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go
*   **Prepaid**: subscription', example='Postpaid'),
  regionId?: string(name='RegionId', description='The region ID of the cluster. Default value: **cn-hangzhou**.

> You can call the [DescribeRegions](~~98041~~) operation to query the available regions.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId', description='The zone ID of the cluster.

> You can call the [DescribeRegions](~~98041~~) operation to query the available zones.', example='cn-hangzhou-i'),
}

model DescribeDBClusterAvailableResourcesResponseBody = {
  availableZones?: [ 
    {
      regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
      supportedEngines?: [ 
        {
          availableResources?: [ 
            {
              category?: string(name='Category', description='The edition of the cluster. Valid values:

*   **Normal**: Cluster Edition.
*   **Basic**: Single Node Edition.
*   **ArchiveNormal**: X-Engine.
*   **NormalMultimaster**: Multi-master Cluster (Database/Table) Edition.
*   **SENormal**: Standard Edition.

>- Only PolarDB for MySQL supports Single Node Edition.
>- Only PolarDB for MySQL 8.0 supports X-Engine Edition and Multi-master Cluster (Database/Table) Edition.', example='Normal'),
              DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node.', example='polar.mysql.x4.large'),
            }
          ](name='AvailableResources', description='The available resources.'),
          engine?: string(name='Engine', description='The version of the database engine.', example='mysql57'),
        }
      ](name='SupportedEngines', description='The database engines that the available resources support.'),
      zoneId?: string(name='ZoneId', description='The zone ID of the cluster.', example='cn-hangzhou-i'),
    }
  ](name='AvailableZones', description='The available zones of the cluster.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2B19F698-8FFC-4918-B9E2-58D878******'),
}

model DescribeDBClusterAvailableResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBClusterAvailableResourcesResponseBody(name='body'),
}

async function describeDBClusterAvailableResourcesWithOptions(request: DescribeDBClusterAvailableResourcesRequest, runtime: Util.RuntimeOptions): DescribeDBClusterAvailableResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBNodeClass)) {
    query['DBNodeClass'] = request.DBNodeClass;
  }
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterAvailableResources',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBClusterAvailableResources(request: DescribeDBClusterAvailableResourcesRequest): DescribeDBClusterAvailableResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterAvailableResourcesWithOptions(request, runtime);
}

model DescribeDBClusterConnectivityRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-xxxxxxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  sourceIpAddress?: string(name='SourceIpAddress', description='The source IP address.', example='192.***.***.1'),
}

model DescribeDBClusterConnectivityResponseBody = {
  connCheckErrorCode?: string(name='ConnCheckErrorCode', description='The error code for connection diagnosis. Valid values:

*   **SRC_IP_NOT_IN_USER_WHITELIST**: The source IP address is not added to the whitelist.
*   **CONNECTION_ABNORMAL**: The connection to the cluster is normal.', example='SRC_IP_NOT_IN_USER_WHITELIST'),
  connCheckErrorMessage?: string(name='ConnCheckErrorMessage', description='The error message for connection diagnosis.', example='Src ip:192.***.***.1 not in user whitelist'),
  connCheckResult?: string(name='ConnCheckResult', description='The connection diagnosis result. Valid values:

*   **Success**
*   **Failed**', example='Failed'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-xxxxxxxxxxxxx'),
  requestId?: string(name='RequestId', description='The request ID.', example='73A85BAF-1039-4CDE-A83F-1A140F******'),
}

model DescribeDBClusterConnectivityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBClusterConnectivityResponseBody(name='body'),
}

async function describeDBClusterConnectivityWithOptions(request: DescribeDBClusterConnectivityRequest, runtime: Util.RuntimeOptions): DescribeDBClusterConnectivityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.sourceIpAddress)) {
    query['SourceIpAddress'] = request.sourceIpAddress;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterConnectivity',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBClusterConnectivity(request: DescribeDBClusterConnectivityRequest): DescribeDBClusterConnectivityResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterConnectivityWithOptions(request, runtime);
}

model DescribeDBClusterEndpointsRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.', example='pc-*************'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.', example='pe-*************'),
  describeType?: string(name='DescribeType', example='AI'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterEndpointsResponseBody = {
  items?: [ 
    {
      addressItems?: [ 
        {
          connectionString?: string(name='ConnectionString', description='The endpoint.', example='********.rwlb.polardb-pg-public.rds.aliyuncs.com'),
          IPAddress?: string(name='IPAddress', description='The IP address.', example='192.***.***.***'),
          netType?: string(name='NetType', description='The network type of the endpoint. Valid values:

*   **Public**
*   **Private**', example='Private'),
          port?: string(name='Port', description='The port.', example='1521'),
          privateZoneConnectionString?: string(name='PrivateZoneConnectionString', description='The private domain name that is bound to the endpoint.', example='***.***.**.com'),
          VPCId?: string(name='VPCId', description='The ID of the VPC.', example='vpc-***************'),
          vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-************'),
          vpcInstanceId?: string(name='VpcInstanceId', description='The ID of the virtual private cloud (VPC) instance.

> This parameter is returned for only PolarDB for MySQL clusters.', example='pe-*************'),
        }
      ](name='AddressItems', description='The details of the endpoint.'),
      autoAddNewNodes?: string(name='AutoAddNewNodes', description='Indicates whether new nodes are automatically associated with the default cluster endpoint. Valid values:

*   **Enable**
*   **Disable**', example='Enable'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-bp1s826a1up******'),
      DBEndpointDescription?: string(name='DBEndpointDescription', description='The name of the endpoint.', example='test'),
      DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.', example='pe-*************'),
      endpointConfig?: string(name='EndpointConfig', description='The advanced configurations of the endpoint.

*   **DistributedTransaction**: indicates whether transaction splitting is enabled. Valid values:

    *   **on**
    *   **off**

*   **ConsistLevel**: the consistency level of sessions. Valid values:

    *   **0**: eventual consistency.
    *   **1**: session consistency.
    *   **2**: global consistency.

*   **LoadBalanceStrategy**: the load balancing policy that automatically schedules loads. Only **load** may be returned.

*   **MasterAcceptReads**: indicates whether the primary node processes read requests. Valid values:

    *   **on**
    *   **off**', example='{\\"DistributedTransaction\\":\\"off\\",\\"ConsistLevel\\":\\"0\\",\\"LoadBalanceStrategy\\":\\"load\\",\\"MasterAcceptReads\\":\\"on\\"}'),
      endpointType?: string(name='EndpointType', description='The type of the endpoint. Valid values:

*   **Cluster**: the default endpoint.
*   **Primary**: the primary endpoint.
*   **Custom**: a custom cluster endpoint.', example='Custom'),
      nodeWithRoles?: string(name='NodeWithRoles', description='The role name of each node in the endpoint. The role name of the primary node is **Writer**. Multiple read-only nodes can be associated with an endpoint. Therefore, the role name of each read-only node is suffixed with a number, such as **Reader1** and **Reader2**.

> This parameter is valid only for PolarDB for PostgreSQL clusters and PolarDB for PostgreSQL (Compatible with Oracle)) clusters.', example='Reader1'),
      nodes?: string(name='Nodes', description='The nodes in the endpoint.', example='pi-***************,pi-***************'),
      readWriteMode?: string(name='ReadWriteMode', description='The read/write mode. Valid values:

*   **ReadWrite**: handles read and write requests. Automatic read/write splitting is enabled.
*   **ReadOnly**: handles read-only requests.', example='ReadOnly'),
    }
  ](name='Items', description='The details of the endpoints.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2DC120BF-6EBA-4C63-BE99-B09F9E******'),
}

model DescribeDBClusterEndpointsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBClusterEndpointsResponseBody(name='body'),
}

async function describeDBClusterEndpointsWithOptions(request: DescribeDBClusterEndpointsRequest, runtime: Util.RuntimeOptions): DescribeDBClusterEndpointsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.describeType)) {
    query['DescribeType'] = request.describeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterEndpoints',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBClusterEndpoints(request: DescribeDBClusterEndpointsRequest): DescribeDBClusterEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterEndpointsWithOptions(request, runtime);
}

model DescribeDBClusterMigrationRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterMigrationResponseBody = {
  comment?: string(name='Comment', description='The description of a migration exception. If no exception occurs during the migration, an empty string is returned.', example='test'),
  DBClusterEndpointList?: [ 
    {
      addressItems?: [ 
        {
          connectionString?: string(name='ConnectionString', description='The connection string.', example='pc-**************.rwlb.rds.aliyuncs.com'),
          IPAddress?: string(name='IPAddress', description='The IP address of the endpoint.', example='192.***.***.10'),
          netType?: string(name='NetType', description='The network type of the endpoint. Valid values:

*   **Public**: the public endpoint
*   **Private**: the internal endpoint (VPC)
*   **Inner**: the internal endpoint (classic network)', example='Private'),
          port?: string(name='Port', description='The port number.', example='3306'),
          SSLEnabled?: string(name='SSLEnabled', description='Indicates whether SSL encryption is enabled. Valid values:

*   **Enabled**
*   **Disabled**', example='Enabled'),
          VPCId?: string(name='VPCId', description='The VPC ID.', example='vpc-**********'),
          vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-**********'),
        }
      ](name='AddressItems', description='Details about the endpoints.'),
      DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.', example='pe-***********'),
      endpointType?: string(name='EndpointType', description='The type of the endpoint. Valid values:

*   **Cluster**: the default cluster endpoint
*   **Primary**: the primary endpoint
*   **Custom**: the custom cluster endpoint', example='Cluster'),
      readWriteMode?: string(name='ReadWriteMode'),
    }
  ](name='DBClusterEndpointList', description='The endpoints of the PolarDB cluster.'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-****************'),
  DBClusterReadWriteMode?: string(name='DBClusterReadWriteMode', description='The mode of the PolarDB cluster. Valid values:

*   **rw**: read and write mode
*   **ro**: read-only mode', example='ro'),
  delayedSeconds?: int32(name='DelayedSeconds', description='The replication latency between the ApsaraDB RDS instance and the PolarDB cluster. Unit: seconds.', example='0'),
  dtsInstanceId?: string(name='DtsInstanceId', description='The ID of the synchronous task.', example='dts**********618bs'),
  expiredTime?: string(name='ExpiredTime', description='The expiration time of the replication between ApsaraDB RDS and PolarDB. The time is in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.', example='2020-06-17T01:56:36Z'),
  migrationStatus?: string(name='MigrationStatus', description='The migration state of the PolarDB cluster. Valid values:

*   **NO_MIGRATION**: No migration task is running.
*   **RDS2POLARDB_CLONING**: Data is being replicated.
*   **RDS2POLARDB_SYNCING**: Data is being replicated. During the replication, the PolarDB cluster is running in read-only mode and the source ApsaraDB RDS instance is running in read and write mode.
*   **SWITCHING**: Databases are being switched.
*   **POLARDB2RDS_SYNCING**: Databases are switched. The PolarDB cluster is running in read and write mode and the source ApsaraDB RDS instance is running in read-only mode. In this state, you can modify the endpoints for your applications.
*   **ROLLBACK**: The migration is being rolled back. After the rollback is complete, the value **RDS2POLARDB_SYNCING** is returned.
*   **CLOSING_MIGRATION**: The migration task is being terminated.', example='RDS2POLARDB_SYNCING'),
  rdsEndpointList?: [ 
    {
      addressItems?: [ 
        {
          connectionString?: string(name='ConnectionString', description='The connection string.', example='rm-***********.mysql.rds.aliyuncs.com'),
          IPAddress?: string(name='IPAddress', description='The IP address of the endpoint.', example='172.***.***.173'),
          netType?: string(name='NetType', description='The network type of the endpoint. Valid values:

*   **Public**: the public endpoint
*   **Private**: the internal endpoint (VPC)
*   **Inner**: the internal endpoint (classic network)', example='Private'),
          port?: string(name='Port', description='The port number.', example='3306'),
          SSLEnabled?: string(name='SSLEnabled', description='Indicates whether SSL encryption is enabled. Valid values:

*   **Enabled**
*   **Disabled**', example='Enabled'),
          VPCId?: string(name='VPCId', description='The VPC ID.', example='vpc-************'),
          vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-**************'),
        }
      ](name='AddressItems', description='Details about the endpoints.'),
      custinsType?: string(name='CustinsType'),
      DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.', example='rm-************-normal'),
      endpointType?: string(name='EndpointType', description='The type of the endpoint. Valid values:

*   **Normal**: the standard endpoint
*   **ReadWriteSplitting**: the read/write splitting endpoint', example='Normal'),
    }
  ](name='RdsEndpointList', description='The endpoints of the ApsaraDB RDS instance.'),
  rdsReadWriteMode?: string(name='RdsReadWriteMode', description='The mode of the source ApsaraDB RDS instance. Valid values:

*   **rw**: read and write mode
*   **ro**: read-only mode', example='rw'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F2A9EFA7-915F-4572-8299-85A307******'),
  sourceRDSDBInstanceId?: string(name='SourceRDSDBInstanceId', description='The ID of the source ApsaraDB RDS instance.', example='rm-************'),
  srcDbType?: string(name='SrcDbType', description='The type of the source database. Valid values:

*   **PolarDBMySQL**: The source database is a PolarDB for MySQL database when the major version of your PolarDB cluster is upgraded.
*   **RDS**: The source database is an ApsaraDB RDS database when data is migrated from ApsaraDB RDS to PolarDB for MySQL.', example='PolarDBMySQL'),
  topologies?: string(name='Topologies', description='The synchronization direction. Valid values:

*   **RDS2POLARDB**: Data is replicated from an ApsaraDB RDS instance to a PolarDB cluster.
*   **POLARDB2RDS**: Data is replicated from a PolarDB cluster to an ApsaraDB RDS instance.', example='RDS2POLARDB'),
}

model DescribeDBClusterMigrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBClusterMigrationResponseBody(name='body'),
}

/**
  * *   You can call this operation to query the status of data migration from an ApsaraDB RDS instance to a PolarDB cluster. For more information, see [Upgrade ApsaraDB RDS for MySQL to PolarDB for MySQL with one click](~~121582~~).
  * *   Before you call this operation, make sure that a one-click upgrade task has been created for the cluster. You can call the [CreateDBCluster](~~98169~~) operation to create an upgrade task. Set the **CreationOption** parameter to **MigrationFromRDS**.
  *
  * @param request DescribeDBClusterMigrationRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDBClusterMigrationResponse
 */
async function describeDBClusterMigrationWithOptions(request: DescribeDBClusterMigrationRequest, runtime: Util.RuntimeOptions): DescribeDBClusterMigrationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterMigration',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   You can call this operation to query the status of data migration from an ApsaraDB RDS instance to a PolarDB cluster. For more information, see [Upgrade ApsaraDB RDS for MySQL to PolarDB for MySQL with one click](~~121582~~).
  * *   Before you call this operation, make sure that a one-click upgrade task has been created for the cluster. You can call the [CreateDBCluster](~~98169~~) operation to create an upgrade task. Set the **CreationOption** parameter to **MigrationFromRDS**.
  *
  * @param request DescribeDBClusterMigrationRequest
  * @return DescribeDBClusterMigrationResponse
 */
async function describeDBClusterMigration(request: DescribeDBClusterMigrationRequest): DescribeDBClusterMigrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterMigrationWithOptions(request, runtime);
}

model DescribeDBClusterMonitorRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterMonitorResponseBody = {
  period?: string(name='Period', description='The interval at which monitoring data is collected. Unit: seconds.', example='60'),
  requestId?: string(name='RequestId', description='The request ID.', example='593AE1C5-B70C-463F-9207-074639******'),
}

model DescribeDBClusterMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBClusterMonitorResponseBody(name='body'),
}

async function describeDBClusterMonitorWithOptions(request: DescribeDBClusterMonitorRequest, runtime: Util.RuntimeOptions): DescribeDBClusterMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterMonitor',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBClusterMonitor(request: DescribeDBClusterMonitorRequest): DescribeDBClusterMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterMonitorWithOptions(request, runtime);
}

model DescribeDBClusterParametersRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-**********'),
  describeType?: string(name='DescribeType', description='The kernel parameter. Valid values:

*   **Normal**: the kernel parameters.
*   **MigrationFromRDS**: compares the current parameters with the parameters of the source RDS instance.', example='Normal'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterParametersResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-bp1s826a1up******'),
  DBType?: string(name='DBType', description='The database engine that the cluster runs. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine. 

- Valid values for the MySQL database engine:    - **5.6**
  - **5.7**
  - **8.0**
- Valid value for the PostgreSQL database engine:    - **11**
  - **14**
- Valid value for the Oracle database engine: **11**', example='5.6'),
  engine?: string(name='Engine', description='The cluster engine.', example='POLARDB'),
  parameterNumbers?: string(name='ParameterNumbers', description='The number of parameters.', example='1'),
  parameters?: {
    parameters?: [ 
    {
      isEqual?: string(name='IsEqual', description='Indicates whether the source parameters and current parameters have the same value.', example='true'),
      distParameterDescription?: string(name='distParameterDescription', description='The description of the parameter of the current cluster.', example='The server\\"s default character set.'),
      distParameterName?: string(name='distParameterName', description='The name of the parameter of the current cluster.', example='character_set_server'),
      distParameterOptional?: string(name='distParameterOptional', description='The valid values of the parameter of the current cluster.', example='- utf8
- gbk'),
      distParameterValue?: string(name='distParameterValue', description='The value of the parameter of the current cluster.', example='utf8'),
      rdsParameterDescription?: string(name='rdsParameterDescription', description='The description of the parameter of the source instance.', example='The server\\"s default character set.'),
      rdsParameterName?: string(name='rdsParameterName', description='The name of the parameter of the source instance.', example='character_set_server'),
      rdsParameterOptional?: string(name='rdsParameterOptional', description='The valid values of the parameter of the source instance.', example='- utf8
- gbk'),
      rdsParameterValue?: string(name='rdsParameterValue', description='The value of the parameter of the source instance.', example='utf8'),
    }
  ](name='Parameters')
  }(name='Parameters', description='A comparison between the current parameters of the PolarDB cluster and the parameters of the source RDS instance before migration.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EBEAA83D-1734-42E3-85E3-E25F6E******'),
  runningParameters?: {
    parameter?: [ 
    {
      checkingCode?: string(name='CheckingCode', description='The valid values of the parameter.', example='[utf8|latin1|gbk|utf8mb4]'),
      dataType?: string(name='DataType', description='The data type of the parameter value. Valid values:

*   **INT**
*   **STRING**
*   **B**', example='INT'),
      defaultParameterValue?: string(name='DefaultParameterValue', description='The default value of the parameter.', example='utf8'),
      factor?: string(name='Factor', description='A divisor of the parameter. For a parameter of the integer or byte type, the valid values must be a multiple of Factor unless you set Factor to 0.', example='20'),
      forceRestart?: boolean(name='ForceRestart', description='Indicates whether a cluster restart is required to allow the parameter modification to take effect. Valid values:

*   **false**
*   **true**', example='true'),
      isModifiable?: boolean(name='IsModifiable', description='Indicates whether the parameter can be modified. Valid values:

*   **false**
*   **true**', example='true'),
      isNodeAvailable?: string(name='IsNodeAvailable', description='Indicates whether the parameter is a global parameter. Valid values:

*   **0**: yes. The modified parameter value is synchronized to other nodes.
*   **1**: no. You can customize the nodes to which the modified parameter value can be synchronized.', example='0'),
      paramRelyRule?: string(name='ParamRelyRule', description='The dependencies of the parameter.', example='utf8'),
      parameterDescription?: string(name='ParameterDescription', description='The description of the parameter.', example='The server\\"s default character set.'),
      parameterName?: string(name='ParameterName', description='The name of the parameter.', example='character_set_server'),
      parameterStatus?: string(name='ParameterStatus', description='The status of the parameter. Valid values:

*   **Normal**
*   **Modifying**', example='Normal'),
      parameterValue?: string(name='ParameterValue', description='The value of the parameter.', example='utf8'),
    }
  ](name='Parameter')
  }(name='RunningParameters', description='The parameters that are in use.'),
}

model DescribeDBClusterParametersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBClusterParametersResponseBody(name='body'),
}

async function describeDBClusterParametersWithOptions(request: DescribeDBClusterParametersRequest, runtime: Util.RuntimeOptions): DescribeDBClusterParametersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.describeType)) {
    query['DescribeType'] = request.describeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterParameters',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBClusterParameters(request: DescribeDBClusterParametersRequest): DescribeDBClusterParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterParametersWithOptions(request, runtime);
}

model DescribeDBClusterPerformanceRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-****************'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.', example='2020-09-23T01:00Z'),
  key?: string(name='Key', description='The performance metrics that you want to query. Separate multiple metrics with commas (,). For more information, see [Performance parameters](~~141787~~).

>  You can specify a maximum of five performance metrics.', example='PolarDBDiskUsage'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.', example='2020-09-23T01:01Z'),
}

model DescribeDBClusterPerformanceResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*****************'),
  DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='8.0'),
  endTime?: string(name='EndTime', description='The end time of the query. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:01:00Z'),
  performanceKeys?: {
    performanceItem?: [ 
    {
      DBNodeId?: string(name='DBNodeId', description='The ID of the cluster node.

>  The value of this parameter is not returned if the `Key` parameter is set to `PolarDBDiskUsage`.', example='pi-*************'),
      measurement?: string(name='Measurement', description='The performance metrics that are returned.', example='PolarDBDiskUsage'),
      metricName?: string(name='MetricName', description='The name of the performance metric.', example='mean_data_size'),
      points?: {
        performanceItemValue?: [ 
        {
          timestamp?: long(name='Timestamp', description='The timestamp of the metric. This value is a UNIX timestamp. Unit: millisecond.', example='1600822800000'),
          value?: string(name='Value', description='The value of the metric.', example='42.38'),
        }
      ](name='PerformanceItemValue')
      }(name='Points', description='The performance metrics.'),
    }
  ](name='PerformanceItem')
  }(name='PerformanceKeys', description='The cluster performance metrics.'),
  requestId?: string(name='RequestId', description='The request ID.', example='35D3E3DA-4650-407A-BFF5-59BFF1******'),
  startTime?: string(name='StartTime', description='The start time of the query. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:00:00Z'),
}

model DescribeDBClusterPerformanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBClusterPerformanceResponseBody(name='body'),
}

/**
  * *   When the monitoring data is collected every 5 seconds:
  *     *   If the query time range is less than or equal to 1 hour, the data is displayed at intervals of 5 seconds.
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  * *   When the monitoring data is collected every 60 seconds:
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  * >  By default, the monitoring data is collected once every 60 seconds. You can call the [ModifyDBClusterMonitor](~~159557~~) operation to set the data collection interval to every 5 seconds.
  *
  * @param request DescribeDBClusterPerformanceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDBClusterPerformanceResponse
 */
async function describeDBClusterPerformanceWithOptions(request: DescribeDBClusterPerformanceRequest, runtime: Util.RuntimeOptions): DescribeDBClusterPerformanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterPerformance',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   When the monitoring data is collected every 5 seconds:
  *     *   If the query time range is less than or equal to 1 hour, the data is displayed at intervals of 5 seconds.
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  * *   When the monitoring data is collected every 60 seconds:
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  * >  By default, the monitoring data is collected once every 60 seconds. You can call the [ModifyDBClusterMonitor](~~159557~~) operation to set the data collection interval to every 5 seconds.
  *
  * @param request DescribeDBClusterPerformanceRequest
  * @return DescribeDBClusterPerformanceResponse
 */
async function describeDBClusterPerformance(request: DescribeDBClusterPerformanceRequest): DescribeDBClusterPerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterPerformanceWithOptions(request, runtime);
}

model DescribeDBClusterSSLRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.', example='pc-************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterSSLResponseBody = {
  items?: [ 
    {
      DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.', example='pe-************'),
      SSLConnectionString?: string(name='SSLConnectionString', description='The SSL connection string.', example='pc-************.mysql.polardb.rds.aliyuncs.com'),
      SSLEnabled?: string(name='SSLEnabled', description='Indicates whether SSL encryption is enabled. Valid values:

*   **Enabled**: SSL is enabled.
*   **Disable**: SSL is disabled.', example='Enabled'),
      SSLExpireTime?: string(name='SSLExpireTime', description='The time when the server certificate expires. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2021-11-13T07:14:22Z'),
    }
  ](name='Items', description='The list of SSL connections.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C890995A-CF06-4F4D-8DB8-DD26C2******'),
  SSLAutoRotate?: string(name='SSLAutoRotate', description='Indicates whether automatic rotation of SSL certificates is enabled. Valid values:

*   **Enable**: The feature is enabled.
*   **Disable**: The feature is disabled.

> This parameter is valid only for a PolarDB for MySQL cluster.', example='Enable'),
}

model DescribeDBClusterSSLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBClusterSSLResponseBody(name='body'),
}

async function describeDBClusterSSLWithOptions(request: DescribeDBClusterSSLRequest, runtime: Util.RuntimeOptions): DescribeDBClusterSSLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterSSL',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBClusterSSL(request: DescribeDBClusterSSLRequest): DescribeDBClusterSSLResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterSSLWithOptions(request, runtime);
}

model DescribeDBClusterServerlessConfRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the serverless cluster.', example='pc-bp10gr51qasnl****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterServerlessConfResponseBody = {
  allowShutDown?: string(name='AllowShutDown', description='Indicates whether the no-activity suspension feature is enabled. Default value: false. Valid values:

*   **true**
*   **false**', example='true'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the serverless cluster.', example='pc-bp10gr51qasnl****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5E71541A-6007-4DCC-A38A-F872C31FEB45'),
  scaleApRoNumMax?: string(name='ScaleApRoNumMax'),
  scaleApRoNumMin?: string(name='ScaleApRoNumMin'),
  scaleMax?: string(name='ScaleMax', description='The maximum number of PCUs per node for scaling. Valid values: 1 PCU to 32 PCUs.', example='3'),
  scaleMin?: string(name='ScaleMin', description='The minimum number of PCUs per node for scaling. Valid values: 1 PCU to 31 PCUs.', example='1'),
  scaleRoNumMax?: string(name='ScaleRoNumMax', description='The maximum number of read-only nodes for scaling. Valid values: 0 to 15.', example='4'),
  scaleRoNumMin?: string(name='ScaleRoNumMin', description='The minimum number of read-only nodes for scaling. Valid values: 0 to 15.', example='2'),
  secondsUntilAutoPause?: string(name='SecondsUntilAutoPause', description='The detection period for no-activity suspension. Valid values: 300 to 86400. Unit: seconds. The value must be a multiple of 300.', example='10'),
  switchs?: string(name='Switchs'),
}

model DescribeDBClusterServerlessConfResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBClusterServerlessConfResponseBody(name='body'),
}

async function describeDBClusterServerlessConfWithOptions(request: DescribeDBClusterServerlessConfRequest, runtime: Util.RuntimeOptions): DescribeDBClusterServerlessConfResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterServerlessConf',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBClusterServerlessConf(request: DescribeDBClusterServerlessConfRequest): DescribeDBClusterServerlessConfResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterServerlessConfWithOptions(request, runtime);
}

model DescribeDBClusterTDERequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-***************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterTDEResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-***************'),
  encryptNewTables?: string(name='EncryptNewTables', description='Indicates whether automatic encryption is enabled for new tables. Valid values:

*   **ON**
*   **OFF**', example='ON'),
  encryptionKey?: string(name='EncryptionKey', description='The ID of the custom key.', example='2a4f4ac2-****-****-****-************'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E37D1508-EC3B-4E06-A24A-C7AC31******'),
  TDERegion?: string(name='TDERegion', description='The region where the TDE key resides.', example='cn-beijing'),
  TDEStatus?: string(name='TDEStatus', description='Indicates whether TDE encryption is enabled. Valid values:

*   **Enabled**
*   **Disabled**', example='Enabled'),
}

model DescribeDBClusterTDEResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBClusterTDEResponseBody(name='body'),
}

async function describeDBClusterTDEWithOptions(request: DescribeDBClusterTDERequest, runtime: Util.RuntimeOptions): DescribeDBClusterTDEResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterTDE',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBClusterTDE(request: DescribeDBClusterTDERequest): DescribeDBClusterTDEResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterTDEWithOptions(request, runtime);
}

model DescribeDBClusterVersionRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query the details of all the clusters for your account, such as the cluster ID.', example='pc-****************'),
  describeType?: string(name='DescribeType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterVersionResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-****************'),
  DBLatestVersion?: string(name='DBLatestVersion', description='The latest version of the database engine.', example='8.0.1.1.16'),
  DBMinorVersion?: string(name='DBMinorVersion', description='The minor version of the database engine.

*   If `DBVersion` is **8.0**, the valid values of this parameter are:

    *   **8.0.2**
    *   **8.0.1**

*   If `DBVersion` is **5.7**, set the value of this parameter to **5.7.28**.

*   If `DBVersion` is **5.6**, the value of this parameter is **5.6.16**.', example='8.0.1'),
  DBRevisionVersion?: string(name='DBRevisionVersion', description='The revision version of the database engine.

> For a cluster of the PolarDB for MySQL 5.6, the `DBRevisionVersion` parameter returns the revision version information only if the revision version is released later than August 31, 2020. Otherwise, this parameter returns an empty value. For more information about the kernel version of a cluster that runs the PolarDB for MySQL, see [PolarDB for MySQL](~~423884~~).', example='8.0.1.1.7'),
  DBRevisionVersionList?: [ 
    {
      releaseNote?: string(name='ReleaseNote', description='版本发布说明。'),
      releaseType?: string(name='ReleaseType', description='数据库版本发布状态。取值范围如下：
* **Stable**：当前版本状态稳定。
* **Old**：当前版本过旧，不建议升级到该版本。
* **HighRisk**：当前版本有严重缺陷，不建议升级到该版本。', example='Stable'),
      revisionVersionCode?: string(name='RevisionVersionCode', description='数据库引擎的修订版本Code，用于指定升级到该目标版本。', example='20230707'),
      revisionVersionName?: string(name='RevisionVersionName', description='数据库引擎的修订版本号。', example='8.0.1.1.35.1'),
    }
  ](name='DBRevisionVersionList', description='可升级的版本信息列表。'),
  DBVersion?: string(name='DBVersion', description='The major version of the database engine. Valid values:

*   **8.0**
*   **5.7**
*   **5.6**', example='8.0'),
  DBVersionStatus?: string(name='DBVersionStatus', description='The status of the minor version. Valid values:

*   **Stable**: The minor version is stable.
*   **Old**: The minor version is outdated. We recommend that you upgrade the cluster to the latest version.
*   **HighRisk**: The minor version has critical defects. We recommend that you immediately upgrade the cluster to the latest version.

> For more information about how to upgrade the minor version, see [Upgrade versions](~~158572~~).', example='Stable'),
  isLatestVersion?: string(name='IsLatestVersion', description='Indicates whether the kernel version is the latest version. Valid values:

*   **true**
*   **false**', example='true'),
  isProxyLatestVersion?: string(name='IsProxyLatestVersion', description='Indicates whether PolarProxy is the latest version. Valid values:

*   **true**
*   **false**', example='true'),
  proxyLatestVersion?: string(name='ProxyLatestVersion', description='The latest version of PolarProxy.', example='2.4.17'),
  proxyRevisionVersion?: string(name='ProxyRevisionVersion', description='The version of PolarProxy.', example='2.4.15'),
  proxyVersionStatus?: string(name='ProxyVersionStatus', description='The status of PolarProxy. Valid values:

*   **Stable**: The minor version is stable.
*   **Old**: The minor version is outdated. We recommend that you upgrade the cluster to the latest version.
*   **HighRisk**: The minor version has critical defects. We recommend that you immediately upgrade the cluster to the latest version.

> For more information about how to upgrade the PolarProxy version, see [Upgrade versions](~~158572~~).', example='Stable'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='47921222-0D37-4133-8C0D-017DC3******'),
}

model DescribeDBClusterVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBClusterVersionResponseBody(name='body'),
}

/**
  * > For more information, see [Engine versions](~~471239~~) and [PolarDB for MySQL](~~172561~~).
  *
  * @param request DescribeDBClusterVersionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDBClusterVersionResponse
 */
async function describeDBClusterVersionWithOptions(request: DescribeDBClusterVersionRequest, runtime: Util.RuntimeOptions): DescribeDBClusterVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.describeType)) {
    query['DescribeType'] = request.describeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterVersion',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > For more information, see [Engine versions](~~471239~~) and [PolarDB for MySQL](~~172561~~).
  *
  * @param request DescribeDBClusterVersionRequest
  * @return DescribeDBClusterVersionResponse
 */
async function describeDBClusterVersion(request: DescribeDBClusterVersionRequest): DescribeDBClusterVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterVersionWithOptions(request, runtime);
}

model DescribeDBClustersRequest {
  connectionString?: string(name='ConnectionString', description='The endpoint of the cluster.', example='********.rwlb.polardb-pg-public.rds.aliyuncs.com'),
  DBClusterDescription?: string(name='DBClusterDescription', description='The description of the cluster. Fuzzy match is supported.', example='pc-****************'),
  DBClusterIds?: string(name='DBClusterIds', description='The ID of the cluster. Separate multiple cluster IDs with commas (,).', example='pc-****************'),
  DBClusterStatus?: string(name='DBClusterStatus', description='The state of the cluster that you want to query. For information about valid values, see [Cluster states](~~99286~~).', example='Running'),
  DBNodeIds?: string(name='DBNodeIds', description='The ID of the node. You can specify multiple node IDs. Separate multiple node IDs with commas (,).', example='pi-***************'),
  DBType?: string(name='DBType', description='The database engine that the cluster runs. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The database engine version of the cluster.', example='5.6'),
  expired?: boolean(name='Expired', description='Specifies whether the cluster has expired. Valid values:

*   **true**
*   **false**', example='true'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. The value must be an integer that is greater than 0. Default value: **1**.', example='10'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page. Valid values: **30**, **50**, or **100**.

Default value: **30**.', example='30'),
  payType?: string(name='PayType', description='The billing method. Valid values:

*   **Postpaid**: pay-as-you-go
*   **Prepaid**: subscription', example='Postpaid'),
  recentCreationInterval?: int32(name='RecentCreationInterval', description='Filters clusters created in the last N days. Valid values: 0 to 15.', example='7'),
  recentExpirationInterval?: int32(name='RecentExpirationInterval', description='Filters clusters that expire after N days. Valid values: 0 to 15.', example='6'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

> You can call the [DescribeRegions](~~98041~~) operation to query the available regions.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag. You can use tags to filter clusters. You can specify up to 20 tags. N specifies the serial number of each tag. The values that you specify for N must be unique and consecutive integers that start from 1. The value of Tag.N.Key is Tag.N.Value.

> The tag key can be up to 64 characters in length and cannot start with `aliyun`, `acs:`, `http://`, or `https://`.', example='MySQL'),
      value?: string(name='Value', description='The value of the tag.

> The tag value can be up to 64 characters in length and cannot start with `aliyun`, `acs:`, `http://`, or `https://`.', example='5.6'),
    }
  ](name='Tag', description='The tags of the cluster.'),
}

model DescribeDBClustersResponseBody = {
  items?: {
    DBCluster?: [ 
    {
      aiType?: string(name='AiType', description='The type of the AI node. Valid values:

*   SearchNode: Search node
*   DLNode: ai node

Enumeration values:

*   SearchNode | DLNode

    <!-- -->

    :

    <!-- -->

    both

    <!-- -->

    .

*   DLNode

    <!-- -->

    :

    <!-- -->

    DLNode

    <!-- -->

    .

*   DLNode

    <!-- -->

    :

    <!-- -->

    DLNode

    <!-- -->

    .', example='SearchNode'),
      category?: string(name='Category', description='The edition of the cluster. Valid values:

*   **Normal**: Cluster Edition
*   **Basic**: Single Node Edition
*   **Archive**: X-Engine Edition
*   **NormalMultimaster**: Multi-master Cluster (Database/Table)', example='Normal'),
      createTime?: string(name='CreateTime', description='The time when the cluster was created.', example='2020-08-14T05:58:42Z'),
      DBClusterDescription?: string(name='DBClusterDescription', description='The description of the cluster.', example='GDN-1'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-****************'),
      DBClusterNetworkType?: string(name='DBClusterNetworkType', description='The network type of the cluster.', example='VPC'),
      DBClusterStatus?: string(name='DBClusterStatus', description='The status of the cluster.', example='Running'),
      DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node.', example='polar.mysql.x4.large'),
      DBNodeNumber?: int32(name='DBNodeNumber', description='The number of nodes.', example='2'),
      DBNodes?: {
        DBNode?: [ 
        {
          DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node.', example='polar.mysql.x4.large'),
          DBNodeId?: string(name='DBNodeId', description='The ID of the node.', example='pi-****************'),
          DBNodeRole?: string(name='DBNodeRole', description='The role of the node. Valid values:

*   **Writer**: The node is the primary node.
*   **Reader**: The node is a read-only node.', example='Reader'),
          hotReplicaMode?: string(name='HotReplicaMode', description='Indicates whether the hot standby feature is enabled. Valid values:

*   **ON**
*   **OFF**', example='OFF'),
          imciSwitch?: string(name='ImciSwitch', description='Indicates whether the In-Memory Column Index (IMCI) feature is enabled. Valid values:

*   **ON**
*   **OFF**', example='OFF'),
          regionId?: string(name='RegionId', description='The ID of the region in which the node resides.', example='cn-hangzhou'),
          serverless?: string(name='Serverless', description='Indicates whether the serverless feature is enabled for the current node. **ON** indicates that the serverless feature is enabled. An empty value indicates that the serverless feature is disabled.', example='ON'),
          zoneId?: string(name='ZoneId', description='The zone ID of the node.', example='cn-hangzhou-i'),
        }
      ](name='DBNode')
      }(name='DBNodes', description='The nodes of the cluster.'),
      DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database.', example='5.6'),
      deletionLock?: int32(name='DeletionLock', description='Indicates whether the cluster is protected from deletion. Valid values:

*   **0**: The cluster is not locked.
*   **1**: The cluster is locked.

> If the cluster is locked, you cannot delete the cluster.', example='0'),
      engine?: string(name='Engine', description='The engine of the cluster.', example='POLARDB'),
      expireTime?: string(name='ExpireTime', description='The expiration time of the cluster.

> A specific value is returned only for subscription (**Prepaid**) clusters. For pay-as-you-go (**Postpaid**) clusters, an empty string is returned.', example='2020-11-14T16:00:00Z'),
      expired?: string(name='Expired', description='Indicates whether the cluster has expired. Valid values:

*   **true**
*   **false**

> A specific value is returned only for subscription (**Prepaid**) clusters.', example='false'),
      lockMode?: string(name='LockMode', description='The lock status of the cluster. Valid values:

*   **Unlock**: The cluster is not locked.
*   **ManualLock**: The cluster is manually locked.
*   **LockByExpiration**: The cluster is automatically locked due to cluster expiration.', example='Unlock'),
      payType?: string(name='PayType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go.
*   **Prepaid**: subscription.', example='Prepaid'),
      regionId?: string(name='RegionId', description='The ID of the region in which the node resides.', example='cn-hangzhou'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
      serverlessType?: string(name='ServerlessType', description='Indicates whether the cluster is a serverless cluster. **AgileServerless** indicates a serverless cluster. An empty value indicates a common cluster.', example='AgileServerless'),
      storagePayType?: string(name='StoragePayType', description='The billing method of the storage space. Valid values:

*   **Postpaid**: pay-as-you-go.
*   **Prepaid**: subscription.', example='Prepaid'),
      storageSpace?: long(name='StorageSpace', description='The storage space that is billed based on the subscription billing method. Unit: bytes.', example='50'),
      storageUsed?: long(name='StorageUsed', description='The storage space this is occupied by the cluster. Unit: bytes.', example='3009413120'),
      strictConsistency?: string(name='StrictConsistency', description='Indicates whether multi-zone data consistency is enabled for the cluster. Valid values:

*   **ON**: multi-zone data consistency is enabled, which is suitable for Standard Edition clusters of Multi-zone Edition.
*   **OFF**: multi-zone data consistency is disabled.', example='ON'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key', description='The key of the tag.', example='MySQL'),
          value?: string(name='Value', description='The value of the tag.', example='5.6'),
        }
      ](name='Tag')
      }(name='Tags', description='The tags of the cluster.'),
      vpcId?: string(name='VpcId', description='The VPC ID of the cluster.', example='vpc-****************'),
      vswitchId?: string(name='VswitchId', description='The vSwitch ID of the cluster.', example='vsw-***************'),
      zoneId?: string(name='ZoneId', description='The zone ID of the cluster.', example='cn-hangzhou-i'),
    }
  ](name='DBCluster')
  }(name='Items', description='The details of the cluster.'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='12'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of clusters returned per page.', example='5'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of returned entries.', example='16'),
}

model DescribeDBClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBClustersResponseBody(name='body'),
}

async function describeDBClustersWithOptions(request: DescribeDBClustersRequest, runtime: Util.RuntimeOptions): DescribeDBClustersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionString)) {
    query['ConnectionString'] = request.connectionString;
  }
  if (!Util.isUnset(request.DBClusterDescription)) {
    query['DBClusterDescription'] = request.DBClusterDescription;
  }
  if (!Util.isUnset(request.DBClusterIds)) {
    query['DBClusterIds'] = request.DBClusterIds;
  }
  if (!Util.isUnset(request.DBClusterStatus)) {
    query['DBClusterStatus'] = request.DBClusterStatus;
  }
  if (!Util.isUnset(request.DBNodeIds)) {
    query['DBNodeIds'] = request.DBNodeIds;
  }
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.expired)) {
    query['Expired'] = request.expired;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.recentCreationInterval)) {
    query['RecentCreationInterval'] = request.recentCreationInterval;
  }
  if (!Util.isUnset(request.recentExpirationInterval)) {
    query['RecentExpirationInterval'] = request.recentExpirationInterval;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusters',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBClusters(request: DescribeDBClustersRequest): DescribeDBClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClustersWithOptions(request, runtime);
}

model DescribeDBClustersWithBackupsRequest {
  DBClusterDescription?: string(name='DBClusterDescription', description='The name of the cluster. The name must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must be 2 to 256 characters in length.', example='test'),
  DBClusterIds?: string(name='DBClusterIds', description='The ID of the cluster. If you need to specify multiple cluster IDs, separate the cluster IDs with commas (,).', example='pc-**************'),
  DBType?: string(name='DBType', description='The type of the database engine. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.

*   Valid values for the MySQL database engine:

    *   **5.6**
    *   **5.7**
    *   **8.0**

*   Valid values for the PostgreSQL database engine:

    *   **11**
    *   **14**

*   Valid value for the Oracle database engine: **11**', example='8.0'),
  isDeleted?: int32(name='IsDeleted', description='Specifies whether the cluster is deleted. Valid values:

*   **0**: not deleted
*   **1**: deleted', example='0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. The value must be a positive integer that does not exceed the maximum value of the INTEGER data type. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: 30.', example='30'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

> You can call the [DescribeRegions](~~98041~~) operation to query information about regions.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClustersWithBackupsResponseBody = {
  items?: {
    DBCluster?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the cluster was created.', example='2022-05-09T09:33:51Z'),
      DBClusterDescription?: string(name='DBClusterDescription', description='The name of the cluster.', example='test'),
      DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-****************'),
      DBClusterNetworkType?: string(name='DBClusterNetworkType', description='The network type of the cluster.', example='VPC'),
      DBClusterStatus?: string(name='DBClusterStatus', description='The status of the cluster. Valid values:

*   Creating: The cluster is being created.
*   Running: The cluster is running.
*   Deleting: The cluster is being released.
*   Rebooting: The cluster is restarting.
*   DBNodeCreating: The node is being added.
*   DBNodeDeleting: The node is being deleted.
*   ClassChanging: The specifications of the node are being changed.
*   NetAddressCreating: The network connection is being created.
*   NetAddressDeleting: The network connection is being deleted.
*   NetAddressModifying: The network connection is being modified.
*   Deleted: The cluster has been released.', example='Running'),
      DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node.', example='polar.mysql.x4.medium'),
      DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='8.0'),
      deletedTime?: string(name='DeletedTime', description='The time when the cluster was deleted.', example='2022-05-12T03:25:37Z'),
      deletionLock?: int32(name='DeletionLock', description='Indicates whether the cluster is locked and can be deleted. Valid values:

*   **0**: The cluster is not locked and can be deleted.
*   **1**: The cluster is locked and cannot be deleted.', example='0'),
      engine?: string(name='Engine', description='The type of the database engine.', example='POLARDB'),
      expireTime?: string(name='ExpireTime', description='The time when the cluster expires.

> A specific value will be returned only for subscription clusters. For pay-as-you-go clusters, an empty string will be returned.', example='2022-09-14T16:00:00Z'),
      expired?: string(name='Expired', description='Indicates whether the cluster has expired.

> A specific value will be returned only for subscription clusters.', example='false'),
      isDeleted?: int32(name='IsDeleted', description='Indicates whether the cluster was released. Valid values:

*   1: released
*   0: not released', example='1'),
      lockMode?: string(name='LockMode', description='The state of the cluster lock. Valid values:

*   **Unlock**: The cluster is not locked.
*   **ManualLock**: The cluster is manually locked.
*   **LockByExpiration**: The cluster is automatically locked after the cluster expires.', example='Unlock'),
      payType?: string(name='PayType', description='The billing method. Valid values:

*   **Postpaid**: pay-as-you-go.
*   **Prepaid**: subscription', example='Postpaid'),
      regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
      vpcId?: string(name='VpcId', description='The VPC ID of the cluster.', example='vpc-******************'),
      zoneId?: string(name='ZoneId', description='The ID of the zone in which the instance is located.', example='cn-hangzhou-h'),
    }
  ](name='DBCluster')
  }(name='Items', description='The details about the cluster.'),
  pageNumber?: int32(name='PageNumber', description='The total number of returned pages.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of clusters returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F8529AA2-522F-4B30-B80B-8F7D39******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of returned entries.', example='1'),
}

model DescribeDBClustersWithBackupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBClustersWithBackupsResponseBody(name='body'),
}

async function describeDBClustersWithBackupsWithOptions(request: DescribeDBClustersWithBackupsRequest, runtime: Util.RuntimeOptions): DescribeDBClustersWithBackupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterDescription)) {
    query['DBClusterDescription'] = request.DBClusterDescription;
  }
  if (!Util.isUnset(request.DBClusterIds)) {
    query['DBClusterIds'] = request.DBClusterIds;
  }
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.isDeleted)) {
    query['IsDeleted'] = request.isDeleted;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClustersWithBackups',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBClustersWithBackups(request: DescribeDBClustersWithBackupsRequest): DescribeDBClustersWithBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClustersWithBackupsWithOptions(request, runtime);
}

model DescribeDBInitializeVariableRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBInitializeVariableResponseBody = {
  DBType?: string(name='DBType', description='The type of the database engine. Valid values:

*   Oracle
*   PostgreSQL', example='PostgreSQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='11'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='475F58B7-F394-4394-AA6E-4F1CBA******'),
  variables?: {
    variable?: [ 
    {
      charset?: string(name='Charset', description='The character set that is supported.', example='EUC_CN'),
      collate?: string(name='Collate', description='The language that indicates the collation of the databases that are created.

>- The language must be compatible with the character set that is specified by **CharacterSetName**.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is optional for PolarDB for MySQL clusters.

To view the valid values for this parameter, perform the following steps: Log on to the PolarDB console and click the ID of a cluster. In the left-side navigation pane, choose **Settings and Management** > **Databases**. Then, click **Create Database**.', example='C'),
      ctype?: string(name='Ctype', description='The language that indicates the character type of the database.

>- The language must be compatible with the character set that is specified by **CharacterSetName**.
>- The specified value must be the same as the value of **Collate**.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is optional for PolarDB for MySQL clusters.

To view the valid values for this parameter, perform the following steps: Log on to the PolarDB console and click the ID of a cluster. In the left-side navigation pane, choose **Settings and Management** > **Databases**. Then, click **Create Database**.', example='C'),
    }
  ](name='Variable')
  }(name='Variables', description='The attributes that are returned.'),
}

model DescribeDBInitializeVariableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInitializeVariableResponseBody(name='body'),
}

async function describeDBInitializeVariableWithOptions(request: DescribeDBInitializeVariableRequest, runtime: Util.RuntimeOptions): DescribeDBInitializeVariableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInitializeVariable',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInitializeVariable(request: DescribeDBInitializeVariableRequest): DescribeDBInitializeVariableResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInitializeVariableWithOptions(request, runtime);
}

model DescribeDBLinksRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster for which you want to query the database links.

> You can call the [DescribeDBClusters](~~173433~~) operation to query PolarDB clusters.', example='pc-a*************'),
  DBLinkName?: string(name='DBLinkName', description='The name of the database link. If you leave this parameter empty, the system returns all the database links.', example='dblink_test'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBLinksResponseBody = {
  DBInstanceName?: string(name='DBInstanceName', description='The ID of the cluster.', example='pc-a*************'),
  DBLinkInfos?: [ 
    {
      DBInstanceName?: string(name='DBInstanceName', description='The ID of the source cluster that the database link connects.', example='pc-a*************'),
      DBLinkName?: string(name='DBLinkName', description='The name of the database link.', example='dblink_test'),
      sourceDBName?: string(name='SourceDBName', description='The name of the source database of the database link.', example='testdb1'),
      targetAccount?: string(name='TargetAccount', description='The account of the destination database of the database link.', example='testacc'),
      targetDBInstanceName?: string(name='TargetDBInstanceName', description='The ID of the destination cluster that the database link connects.

> If the destination cluster is not a PolarDB for Oracle cluster, the returned value is empty.', example='pc-b************'),
      targetDBName?: string(name='TargetDBName', description='The name of the destination database of the database link.', example='testdb2'),
    }
  ](name='DBLinkInfos', description='Details about the database links.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='45D24263-7E3A-4140-9472-************'),
}

model DescribeDBLinksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBLinksResponseBody(name='body'),
}

/**
  * > You can query only the database links that use a PolarDB for Oracle cluster as the source.
  *
  * @param request DescribeDBLinksRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDBLinksResponse
 */
async function describeDBLinksWithOptions(request: DescribeDBLinksRequest, runtime: Util.RuntimeOptions): DescribeDBLinksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBLinkName)) {
    query['DBLinkName'] = request.DBLinkName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBLinks',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > You can query only the database links that use a PolarDB for Oracle cluster as the source.
  *
  * @param request DescribeDBLinksRequest
  * @return DescribeDBLinksResponse
 */
async function describeDBLinks(request: DescribeDBLinksRequest): DescribeDBLinksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBLinksWithOptions(request, runtime);
}

model DescribeDBNodePerformanceRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-****************'),
  DBNodeId?: string(name='DBNodeId', description='The ID of the cluster node.', example='pi-*************'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.', example='2020-09-23T01:01Z'),
  key?: string(name='Key', description='The performance metrics that you want to query. Separate multiple metrics with commas (,). For more information, see [Performance parameters](~~141787~~).

>  You can specify a maximum of five performance metrics.', example='PolarDBDiskUsage'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.', example='2020-09-23T01:00Z'),
}

model DescribeDBNodePerformanceResponseBody = {
  DBNodeId?: string(name='DBNodeId', description='The ID of the cluster node.', example='pi-*****************'),
  DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='8.0'),
  endTime?: string(name='EndTime', description='The end time of the query. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:01:00Z'),
  performanceKeys?: {
    performanceItem?: [ 
    {
      measurement?: string(name='Measurement', description='The performance metrics that you want to query.', example='PolarDBDiskUsage'),
      metricName?: string(name='MetricName', description='The name of the performance metric.', example='mean_sys_dir_size'),
      points?: {
        performanceItemValue?: [ 
        {
          timestamp?: long(name='Timestamp', description='The timestamp of the metric. This value is a UNIX timestamp. Unit: millisecond.', example='1600822800000'),
          value?: string(name='Value', description='The value of the metric.', example='9.33'),
        }
      ](name='PerformanceItemValue')
      }(name='Points', description='The performance metrics.'),
    }
  ](name='PerformanceItem')
  }(name='PerformanceKeys', description='The cluster performance metrics.'),
  requestId?: string(name='RequestId', description='The request ID.', example='E2FDB684-751D-424D-98B9-704BEA******'),
  startTime?: string(name='StartTime', description='The start time of the query. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:00:00Z'),
}

model DescribeDBNodePerformanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBNodePerformanceResponseBody(name='body'),
}

/**
  * *   When the monitoring data is collected every 5 seconds:
  *     *   If the query time range is less than or equal to 1 hour, the data is displayed at intervals of 5 seconds.
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  * *   When the monitoring data is collected every 60 seconds:
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  * >  By default, the monitoring data is collected once every 60 seconds. You can call the [ModifyDBClusterMonitor](~~159557~~) operation to set the data collection interval to every 5 seconds.
  *
  * @param request DescribeDBNodePerformanceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDBNodePerformanceResponse
 */
async function describeDBNodePerformanceWithOptions(request: DescribeDBNodePerformanceRequest, runtime: Util.RuntimeOptions): DescribeDBNodePerformanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeId)) {
    query['DBNodeId'] = request.DBNodeId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBNodePerformance',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   When the monitoring data is collected every 5 seconds:
  *     *   If the query time range is less than or equal to 1 hour, the data is displayed at intervals of 5 seconds.
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  * *   When the monitoring data is collected every 60 seconds:
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  * >  By default, the monitoring data is collected once every 60 seconds. You can call the [ModifyDBClusterMonitor](~~159557~~) operation to set the data collection interval to every 5 seconds.
  *
  * @param request DescribeDBNodePerformanceRequest
  * @return DescribeDBNodePerformanceResponse
 */
async function describeDBNodePerformance(request: DescribeDBNodePerformanceRequest): DescribeDBNodePerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBNodePerformanceWithOptions(request, runtime);
}

model DescribeDBNodesParametersRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-****************'),
  DBNodeIds?: string(name='DBNodeIds', description='The node ID. You can specify multiple node IDs. Separate multiple node IDs with commas (,).', example='pi-****************,pi-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBNodesParametersResponseBody = {
  DBNodeIds?: [ 
    {
      DBNodeId?: string(name='DBNodeId', description='The ID of the node.', example='pi-bp1r4qe3s534*****'),
      runningParameters?: [ 
        {
          checkingCode?: string(name='CheckingCode', description='The valid values of the parameter.', example='[utf8|latin1|gbk|utf8mb4]'),
          dataType?: string(name='DataType', description='The data type of the parameter value. Valid values:

*   **INT**
*   **STRING**
*   **B**', example='INT'),
          defaultParameterValue?: string(name='DefaultParameterValue', description='The default value of the parameter.', example='utf8'),
          factor?: string(name='Factor', description='A divisor of the parameter. For a parameter of the integer or byte type, the valid values must be a multiple of Factor unless you set Factor to 0.', example='20'),
          forceRestart?: boolean(name='ForceRestart', description='Indicates whether a cluster restart is required to allow the parameter modification to take effect. Valid values:

*   **false**
*   **true**', example='true'),
          isModifiable?: boolean(name='IsModifiable', description='Indicates whether the parameter can be modified. Valid values:

*   **false**
*   **true**', example='true'),
          isNodeAvailable?: string(name='IsNodeAvailable', description='Indicates whether the parameter is a global parameter. Valid values:

*   **0**: yes. The modified parameter value is synchronized to other nodes.
*   **1**: no. You can customize the nodes to which the modified parameter value can be synchronized to.', example='1'),
          paramRelyRule?: string(name='ParamRelyRule', description='The dependencies of the parameter.', example='utf8'),
          parameterDescription?: string(name='ParameterDescription', description='The description of the parameter.', example='The server\\"s default character set.'),
          parameterName?: string(name='ParameterName', description='The name of the parameter.', example='character_set_server'),
          parameterStatus?: string(name='ParameterStatus', description='The status of the parameter. Valid values:

*   **normal**
*   **modifying**', example='normal'),
          parameterValue?: string(name='ParameterValue', description='The value of the parameter.', example='utf8'),
        }
      ](name='RunningParameters', description='The parameters of the current node.'),
    }
  ](name='DBNodeIds', description='The IDs of the nodes.'),
  DBType?: string(name='DBType', description='The type of the database engine. Set the value to **MySQL**.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the MySQL database engine. Valid values:

*   **5.6**
*   **5.7**
*   **8.0**', example='5.6'),
  engine?: string(name='Engine', description='The cluster engine.', example='POLARDB'),
  requestId?: string(name='RequestId', description='The request ID.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model DescribeDBNodesParametersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBNodesParametersResponseBody(name='body'),
}

async function describeDBNodesParametersWithOptions(request: DescribeDBNodesParametersRequest, runtime: Util.RuntimeOptions): DescribeDBNodesParametersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeIds)) {
    query['DBNodeIds'] = request.DBNodeIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBNodesParameters',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBNodesParameters(request: DescribeDBNodesParametersRequest): DescribeDBNodesParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBNodesParametersWithOptions(request, runtime);
}

model DescribeDBProxyPerformanceRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-****************'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.', example='2020-09-24T02:08Z'),
  key?: string(name='Key', description='The performance metrics that you want to query. Separate multiple indicators with commas (,). For more information, see [Performance parameters](~~141787~~).', example='PolarProxy_CpuUsage'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.', example='2020-09-23T01:01Z'),
}

model DescribeDBProxyPerformanceResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-*****************'),
  DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='8.0'),
  endTime?: string(name='EndTime', description='The end time of the query. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:01:00Z'),
  performanceKeys?: {
    performanceItem?: [ 
    {
      DBNodeId?: string(name='DBNodeId', description='The ID of the node.', example='pi-*************'),
      measurement?: string(name='Measurement', description='The performance metric.', example='PolarProxy_CpuUsage'),
      metricName?: string(name='MetricName', description='The name of the performance metric.', example='service_connections_ps'),
      points?: {
        performanceItemValue?: [ 
        {
          timestamp?: long(name='Timestamp', description='The time when the metric value was collected. This value is a timestamp in milliseconds.', example='1600822800000'),
          value?: string(name='Value', description='The value of the metric.', example='10'),
        }
      ](name='PerformanceItemValue')
      }(name='Points', description='The list of the performance metrics.'),
    }
  ](name='PerformanceItem')
  }(name='PerformanceKeys', description='Details about the performance metrics.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='35D3E3DA-4650-407A-BFF5-59BFF1******'),
  startTime?: string(name='StartTime', description='The start time of the query. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:00:00Z'),
}

model DescribeDBProxyPerformanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBProxyPerformanceResponseBody(name='body'),
}

/**
  * > This operation is applicable only to PolarDB for MySQL clusters.
  *
  * @param request DescribeDBProxyPerformanceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDBProxyPerformanceResponse
 */
async function describeDBProxyPerformanceWithOptions(request: DescribeDBProxyPerformanceRequest, runtime: Util.RuntimeOptions): DescribeDBProxyPerformanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBProxyPerformance',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > This operation is applicable only to PolarDB for MySQL clusters.
  *
  * @param request DescribeDBProxyPerformanceRequest
  * @return DescribeDBProxyPerformanceResponse
 */
async function describeDBProxyPerformance(request: DescribeDBProxyPerformanceRequest): DescribeDBProxyPerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBProxyPerformanceWithOptions(request, runtime);
}

model DescribeDasConfigRequest {
  DBClusterId?: string(name='DBClusterId', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDasConfigResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='593AE1C5-B70C-463F-9207-074639******'),
  storageAutoScale?: string(name='StorageAutoScale', example='Enable'),
  storageUpperBound?: long(name='StorageUpperBound', example='800'),
}

model DescribeDasConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDasConfigResponseBody(name='body'),
}

async function describeDasConfigWithOptions(request: DescribeDasConfigRequest, runtime: Util.RuntimeOptions): DescribeDasConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDasConfig',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDasConfig(request: DescribeDasConfigRequest): DescribeDasConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDasConfigWithOptions(request, runtime);
}

model DescribeDatabasesRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-**************'),
  DBName?: string(name='DBName', description='The name of the database.

> You cannot specify multiple database names.', example='test_db'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value must be a positive integer that does not exceed the maximum value of the INTEGER data type. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDatabasesResponseBody = {
  databases?: {
    database?: [ 
    {
      accounts?: {
        account?: [ 
        {
          accountName?: string(name='AccountName', description='The username of the account.

> A PolarDB for MySQL cluster does not support privileged accounts.', example='test_acc'),
          accountPrivilege?: string(name='AccountPrivilege', description='The permissions that are granted to the account. Valid values:

*   **ReadWrite**: read and write permissions
*   **ReadOnly**: read-only permissions
*   **DMLOnly**: The account is granted the permissions to execute only DML statements on the database.
*   **DDLOnly**: The account is granted the permissions to execute only DDL statements on the database.
*   **ReadIndex**: The account has the read and index permissions on the database.', example='ReadOnly'),
          accountStatus?: string(name='AccountStatus', description='The state of the account. Valid values:

*   **Creating**
*   **Available**
*   **Deleting**', example='Available'),
          privilegeStatus?: string(name='PrivilegeStatus', description='The authorization state of the account. Valid values:

*   **Empowering**: The system is granting permissions to the account.
*   **Empowered**: Permissions are granted to the account.
*   **Removing**: The system is revoking permissions from the account.', example='Empowered'),
        }
      ](name='Account')
      }(name='Accounts', description='Details about the accounts.

> A PolarDB for MySQL cluster does not support privileged accounts.'),
      characterSetName?: string(name='CharacterSetName', description='The character set that the database uses. For more information, see [Character set tables](~~99716~~).', example='utf8mb4'),
      DBDescription?: string(name='DBDescription', description='The description of the database.', example='test_des'),
      DBName?: string(name='DBName', description='The name of the database.', example='test_db'),
      DBStatus?: string(name='DBStatus', description='The state of the database. Valid values:

*   **Creating**
*   **Running**
*   **Deleting**', example='Running'),
      engine?: string(name='Engine', description='The type of the database engine. Valid values:

*   **MySQL**
*   **Oracle**
*   **PostgreSQL**', example='MySQL'),
      masterID?: string(name='MasterID', description='The ID of the primary node in the cluster of Multi-master Cluster (Database/Table) Edition.', example='2'),
    }
  ](name='Database')
  }(name='Databases', description='Details about databases.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of entries per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E1DF8CA6-2300-448B-9ABF-760C4B******'),
}

model DescribeDatabasesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDatabasesResponseBody(name='body'),
}

async function describeDatabasesWithOptions(request: DescribeDatabasesRequest, runtime: Util.RuntimeOptions): DescribeDatabasesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDatabases',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDatabases(request: DescribeDatabasesRequest): DescribeDatabasesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDatabasesWithOptions(request, runtime);
}

model DescribeDetachedBackupsRequest {
  backupId?: string(name='BackupId', description='The ID of the backup set.', example='111111111'),
  backupMode?: string(name='BackupMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Manual'),
  backupRegion?: string(name='BackupRegion', description='The region where the cross-region data backup file of the instance is stored.

> This parameter is valid only for PolarDB for MySQL clusters.', example='cn-hangzhou'),
  backupStatus?: string(name='BackupStatus', description='The status of the backup set. Valid values:

*   **Success**
*   **Failed**', example='Success'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-****************'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the `YYYY-MM-DDThh:mmZ` format. The time must be in UTC. The end time must be later than the start time.', example='2020-05-14T00:00Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value must be a positive integer that does not exceed the maximum value of the INTEGER data type. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.', example='2020-05-01T00:00Z'),
}

model DescribeDetachedBackupsResponseBody = {
  items?: {
    backup?: [ 
    {
      backupEndTime?: string(name='BackupEndTime', description='The end time of the backup task. The time is displayed in UTC.', example='2020-05-12T03:25:55Z'),
      backupId?: string(name='BackupId', description='The ID of the backup set.', example='111111111'),
      backupMethod?: string(name='BackupMethod', description='The backup method. Only snapshot backups are supported. The value is set to **Snapshot**.', example='Snapshot'),
      backupMode?: string(name='BackupMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Manual'),
      backupSetSize?: string(name='BackupSetSize', description='The size of the backup set. Unit: bytes.

> After you delete the target snapshot backups, the storage space consumed by the backups is released. The released storage space is smaller than the size of the backup file, because the snapshots share certain data blocks.', example='7251056'),
      backupStartTime?: string(name='BackupStartTime', description='The start time of the backup task. The time is displayed in UTC.', example='2020-05-12T03:25:44Z'),
      backupStatus?: string(name='BackupStatus', description='The status of the backup set. Valid values:

*   **Success**
*   **Failed**', example='Success'),
      backupType?: string(name='BackupType', description='The type of the backup. Only full backups are supported. The value is set to **FullBackup**.', example='FullBackup'),
      backupsLevel?: string(name='BackupsLevel', description='The level of the backup set. Valid values:

*   **Level-1**: level-1 backup set
*   **Level-2**: level-2 backup set', example='Level-2'),
      consistentTime?: string(name='ConsistentTime', description='The snapshot checkpoint time. The value is a Unix timestamp.', example='1589253947'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-**************'),
      isAvail?: string(name='IsAvail', description='Indicates whether the backup set is available. Valid values:

*   **0**: The data backup set is unavailable.
*   **1**: The data backup set is available.', example='1'),
      storeStatus?: string(name='StoreStatus', description='Indicates whether the backup set can be deleted. Valid values:

*   **Enabled**: The backup set can be deleted.
*   **Disabled**: The backup set cannot be deleted.', example='Disabled'),
    }
  ](name='Backup')
  }(name='Items', description='Details about the backup sets.'),
  pageNumber?: string(name='PageNumber', description='The page number.', example='1'),
  pageRecordCount?: string(name='PageRecordCount', description='The number of entries per page.', example='15'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='717B2382-BB14-4DCB-BBC2-32DBE0******'),
  totalRecordCount?: string(name='TotalRecordCount', description='The total number of returned entries.', example='50'),
}

model DescribeDetachedBackupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDetachedBackupsResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that the PolarDB cluster is in the **Released** state. You must also confirm that the **Retain All Backups Permanently** or **Retain Last Automatic Backup Permanently** backup retention policy takes effect after you release the cluster. If you delete all backup sets after the cluster is released, you cannot use this API operation to query the cluster.
  * > You can call the [DescribeDBClusterAttribute](~~98181~~) operation to query the cluster status.
  *
  * @param request DescribeDetachedBackupsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDetachedBackupsResponse
 */
async function describeDetachedBackupsWithOptions(request: DescribeDetachedBackupsRequest, runtime: Util.RuntimeOptions): DescribeDetachedBackupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.backupMode)) {
    query['BackupMode'] = request.backupMode;
  }
  if (!Util.isUnset(request.backupRegion)) {
    query['BackupRegion'] = request.backupRegion;
  }
  if (!Util.isUnset(request.backupStatus)) {
    query['BackupStatus'] = request.backupStatus;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDetachedBackups',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, make sure that the PolarDB cluster is in the **Released** state. You must also confirm that the **Retain All Backups Permanently** or **Retain Last Automatic Backup Permanently** backup retention policy takes effect after you release the cluster. If you delete all backup sets after the cluster is released, you cannot use this API operation to query the cluster.
  * > You can call the [DescribeDBClusterAttribute](~~98181~~) operation to query the cluster status.
  *
  * @param request DescribeDetachedBackupsRequest
  * @return DescribeDetachedBackupsResponse
 */
async function describeDetachedBackups(request: DescribeDetachedBackupsRequest): DescribeDetachedBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDetachedBackupsWithOptions(request, runtime);
}

model DescribeGlobalDatabaseNetworkRequest {
  GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gdn-bp1fttxsrmv*****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeGlobalDatabaseNetworkResponseBody = {
  connections?: [ 
    {
      connectionString?: string(name='ConnectionString', description='The URL of the endpoint.', example='abc.polardb.rds.aliyuncs.com'),
      netType?: string(name='NetType', description='The network type of the endpoint.', example='Private'),
      port?: string(name='Port', description='The port number of the endpoint.', example='3306'),
    }
  ](name='Connections', description='The information about the connection to the cluster.'),
  createTime?: string(name='CreateTime', description='The time at which the GDN was created.', example='2020-02-24T11:57:54Z'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-bp1s826a1up******'),
  DBClusters?: [ 
    {
      DBClusterDescription?: string(name='DBClusterDescription', description='The description of the cluster.', example='test'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster in the GDN.', example='pc-wz9fb5nn44u1d****'),
      DBClusterStatus?: string(name='DBClusterStatus', description='The status of the cluster in the GDN. For more information, see [Cluster status table](~~99286~~).', example='Running'),
      DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node in the cluster.', example='polar.mysql.x4.large'),
      DBNodes?: [ 
        {
          creationTime?: string(name='CreationTime', description='The time when the node was created.', example='2020-03-23T21:35:43Z'),
          DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node in the cluster.', example='polar.mysql.x4.large'),
          DBNodeId?: string(name='DBNodeId', description='The ID of the node.', example='pi-****************'),
          DBNodeRole?: string(name='DBNodeRole', description='The role of the node. Valid values:

*   **Writer**: The node is the primary node.
*   **Reader**: The node is a read-only node.', example='Reader'),
          DBNodeStatus?: string(name='DBNodeStatus', description='The status of the node. Valid values:

*   **Creating**: The cluster is being created.
*   **Running**: The cluster is running.
*   **Deleting**: The cluster is being deleted.
*   **Rebooting**: The cluster is restarting.
*   **DBNodeCreating**: PolarProxy is being added.
*   **DBNodeDeleting**: PolarProxy is being deleted.
*   **ClassChanging**: The specifications of PolarProxy are being changed.
*   **NetAddressCreating**: The network connection is being created.
*   **NetAddressDeleting**: The network connection is being deleted.
*   **NetAddressModifying**: The network connection is being modified.
*   **MinorVersionUpgrading**: The minor version is being updated.
*   **Maintaining**: The cluster is being maintained.
*   **Switching**: A failover is being performed.', example='Running'),
          failoverPriority?: int32(name='FailoverPriority', description='The priority of failover. Each node is assigned a failover priority. If a failover occurs, a node can be selected as the primary node based on the priority. A larger value indicates a higher priority. Valid values: 1 to 15.', example='1'),
          maxConnections?: int32(name='MaxConnections', description='The maximum number of concurrent connections to the cluster.', example='8000'),
          maxIOPS?: int32(name='MaxIOPS', description='The maximum input/output operations per second (IOPS).', example='32000'),
          zoneId?: string(name='ZoneId', description='The zone ID of the cluster.', example='cn-hangzhou-i'),
        }
      ](name='DBNodes', description='The details of the node.'),
      DBType?: string(name='DBType', description='The type of the database engine. Only MySQL is supported.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine. Only version 8.0 is supported.', example='8.0'),
      expireTime?: string(name='ExpireTime', description='The expiration time of the cluster.

> A specific value is returned only for subscription (**Prepaid**) clusters. For pay-as-you-go (**Postpaid**) clusters, an empty string is returned.', example='2020-11-14T16:00:00Z'),
      expired?: string(name='Expired', description='Indicates whether the cluster is expired. Valid values:

*   **true**
*   **false**

> This parameter is returned only for subscription (**Prepaid**) clusters.', example='false'),
      payType?: string(name='PayType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go.
*   **Prepaid**: subscription.', example='Prepaid'),
      regionId?: string(name='RegionId', description='The ID of the region in which the cluster resides.', example='cn-hangzhou'),
      replicaLag?: string(name='ReplicaLag', description='The latency of cross-region data replication between the primary cluster and secondary clusters. Unit: seconds.', example='1'),
      role?: string(name='Role', description='The role of the cluster. Valid values:

*   **Primary**: the primary cluster
*   **standby**: the secondary cluster

> A GDN consists of one primary cluster and up to four secondary clusters.', example='primary'),
      storageUsed?: string(name='StorageUsed', description='The storage space that is occupied by the cluster. Unit: bytes.', example='3012558848'),
    }
  ](name='DBClusters', description='The clusters that are included in the GDN.'),
  DBType?: string(name='DBType', description='The type of the database engine. Only MySQL is supported.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine. Only version 8.0 is supported.', example='8.0'),
  GDNDescription?: string(name='GDNDescription', description='The description of the GDN. The description must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must start with a letter.
*   It can contain letters, digits, underscores (\\_), and hyphens (-).
*   It must be 2 to 126 characters in length.', example='GDN-fortest'),
  GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gdn-bp1fttxsrmv*****'),
  GDNStatus?: string(name='GDNStatus', description='The status of the GDN. Valid values:

*   **Creating**: The GDN is being created.
*   **active**: The GDN is running.
*   **deleting**: The GDN is being deleted.
*   **locked**: The GDN is locked. If the GDN is locked, you cannot perform operations on clusters in the GDN.
*   **removing_member**: The secondary cluster is being removed from the GDN.', example='active'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='67F2E75F-AE67-4FB2-821F-A81237EACD15'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
}

model DescribeGlobalDatabaseNetworkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGlobalDatabaseNetworkResponseBody(name='body'),
}

async function describeGlobalDatabaseNetworkWithOptions(request: DescribeGlobalDatabaseNetworkRequest, runtime: Util.RuntimeOptions): DescribeGlobalDatabaseNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.GDNId)) {
    query['GDNId'] = request.GDNId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGlobalDatabaseNetwork',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGlobalDatabaseNetwork(request: DescribeGlobalDatabaseNetworkRequest): DescribeGlobalDatabaseNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGlobalDatabaseNetworkWithOptions(request, runtime);
}

model DescribeGlobalDatabaseNetworksRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.', example='pc-**************'),
  filterRegion?: string(name='FilterRegion', description='Specify the region in which you want to query GDNs. You can create secondary clusters for the GDNs.', example='cn-beijing'),
  GDNDescription?: string(name='GDNDescription', description='The description of the GDN. The description must meet the following requirements:

*   It cannot start with [http:// or https://.](http://https://。)
*   It must start with a letter.
*   It can contain letters, digits, underscores (\\_), and hyphens (-).
*   It must be 2 to 126 characters in length.', example='test'),
  GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gdn-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: 1. The value must be an integer that is greater than 0.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 30. Valid values:

*   30
*   50
*   100', example='30'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeGlobalDatabaseNetworksResponseBody = {
  items?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the GDN was created. The time is in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.', example='2020-03-23T05:46:54Z'),
      DBClusters?: [ 
        {
          DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-****************'),
          regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
          role?: string(name='Role', description='The role of the cluster. Valid values:

*   **Primary**: the primary cluster
*   **standby**: the secondary cluster

> A GDN consists of one primary cluster and up to four secondary clusters. For more information, see [GDN](~~160381~~).', example='primary'),
        }
      ](name='DBClusters', description='Details about clusters in the GDN.'),
      DBType?: string(name='DBType', description='The type of the database engine. Only **MySQL** is supported.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine. Only the **8.0** version is supported.', example='8.0'),
      GDNDescription?: string(name='GDNDescription', description='The description of the GDN. The description must meet the following requirements:

*   It cannot start with [http:// or https://.](http://https://。)
*   It must start with a letter.
*   It can contain letters, digits, underscores (\\_), and hyphens (-).
*   It must be 2 to 126 characters in length.', example='test'),
      GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gdn-****************'),
      GDNStatus?: string(name='GDNStatus', description='The status of the GDN. Valid values:

*   **Creating**: The GDN is being created.
*   **active**: The GDN is running.
*   **deleting**: The GDN is being deleted.
*   **locked**: The GDN is locked. If the GDN is locked, you cannot perform operations on clusters in the GDN.
*   **removing_member**: The secondary cluster is being removed from the GDN.', example='active'),
    }
  ](name='Items', description='Details about the GDNs.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of records on the current page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='69A85BAF-1089-4CDF-A82F-0A140F******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of returned entries.', example='1'),
}

model DescribeGlobalDatabaseNetworksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGlobalDatabaseNetworksResponseBody(name='body'),
}

async function describeGlobalDatabaseNetworksWithOptions(request: DescribeGlobalDatabaseNetworksRequest, runtime: Util.RuntimeOptions): DescribeGlobalDatabaseNetworksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.filterRegion)) {
    query['FilterRegion'] = request.filterRegion;
  }
  if (!Util.isUnset(request.GDNDescription)) {
    query['GDNDescription'] = request.GDNDescription;
  }
  if (!Util.isUnset(request.GDNId)) {
    query['GDNId'] = request.GDNId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGlobalDatabaseNetworks',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGlobalDatabaseNetworks(request: DescribeGlobalDatabaseNetworksRequest): DescribeGlobalDatabaseNetworksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGlobalDatabaseNetworksWithOptions(request, runtime);
}

model DescribeGlobalSecurityIPGroupRequest {
  globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the IP whitelist template.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeGlobalSecurityIPGroupResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      DBInstances?: [ string ](name='DBInstances', description='The details of the clusters that are associated with the global IP address whitelist template.'),
      GIpList?: string(name='GIpList', description='The IP address in the global IP whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the global IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (\\_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the global IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroup', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model DescribeGlobalSecurityIPGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGlobalSecurityIPGroupResponseBody(name='body'),
}

async function describeGlobalSecurityIPGroupWithOptions(request: DescribeGlobalSecurityIPGroupRequest, runtime: Util.RuntimeOptions): DescribeGlobalSecurityIPGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalSecurityGroupId)) {
    query['GlobalSecurityGroupId'] = request.globalSecurityGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGlobalSecurityIPGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGlobalSecurityIPGroup(request: DescribeGlobalSecurityIPGroupRequest): DescribeGlobalSecurityIPGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGlobalSecurityIPGroupWithOptions(request, runtime);
}

model DescribeGlobalSecurityIPGroupRelationRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-*****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the IP whitelist template.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeGlobalSecurityIPGroupRelationResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-*****************'),
  globalSecurityIPGroupRel?: [ 
    {
      GIpList?: string(name='GIpList', description='The IP address in the global IP whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the global IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (\\_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the global IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroupRel', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model DescribeGlobalSecurityIPGroupRelationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGlobalSecurityIPGroupRelationResponseBody(name='body'),
}

async function describeGlobalSecurityIPGroupRelationWithOptions(request: DescribeGlobalSecurityIPGroupRelationRequest, runtime: Util.RuntimeOptions): DescribeGlobalSecurityIPGroupRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGlobalSecurityIPGroupRelation',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGlobalSecurityIPGroupRelation(request: DescribeGlobalSecurityIPGroupRelationRequest): DescribeGlobalSecurityIPGroupRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGlobalSecurityIPGroupRelationWithOptions(request, runtime);
}

model DescribeLogBackupPolicyRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

>  You can call the [DescribeDBClusters](~~98094~~) operation to query all the information about the available clusters in the target region, including the cluster ID.', example='pc-*****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeLogBackupPolicyResponseBody = {
  enableBackupLog?: int32(name='EnableBackupLog', description='Indicates whether the log backup feature is enabled. Valid values:

*   0: The log backup feature is disabled.
*   1: The log backup feature is enabled. By default, the log backup feature is enabled and cannot be disabled.', example='1'),
  logBackupAnotherRegionRegion?: string(name='LogBackupAnotherRegionRegion', description='The region in which you want to store cross-region log backups. For more information about regions that support the cross-region backup feature, see [Overview](~~72672~~).', example='cn-beijing'),
  logBackupAnotherRegionRetentionPeriod?: string(name='LogBackupAnotherRegionRetentionPeriod', description='The retention period of cross-region log backups. Valid values:

*   **0**: The cross-region backup feature is disabled.
*   **30 to 7300**: Cross-region log backups are retained for 30 to 7,300 days.
*   **-1**: The log backups are permanently retained.

>  When you create a cluster, the default value of this parameter is **0**.', example='0'),
  logBackupRetentionPeriod?: int32(name='LogBackupRetentionPeriod', description='The retention period of the log backups. Valid values:

*   3 to 7300: The log backups are retained for 3 to 7,300 days.
*   \\-1: The log backups are permanently retained.', example='7'),
  requestId?: string(name='RequestId', description='The request ID.', example='62EE0051-102B-488D-9C79-D607B8******'),
}

model DescribeLogBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLogBackupPolicyResponseBody(name='body'),
}

async function describeLogBackupPolicyWithOptions(request: DescribeLogBackupPolicyRequest, runtime: Util.RuntimeOptions): DescribeLogBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLogBackupPolicy',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLogBackupPolicy(request: DescribeLogBackupPolicyRequest): DescribeLogBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogBackupPolicyWithOptions(request, runtime);
}

model DescribeMaskingRulesRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.', example='pc-*****************'),
  ruleNameList?: string(name='RuleNameList', description='The name of the masking rule.', example='testrule'),
}

model DescribeMaskingRulesResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-bp1s826a1up******'),
  data?: {
    ruleList?: [ string ](name='RuleList', description='Details about the masking rules.'),
  }(name='Data', description='The result data that is returned.'),
  message?: string(name='Message', description='The message that is returned for the request.

> If the request is successful, Successful is returned. If the request fails, an error message such as an error code is returned.', example='Successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2F83D131-1C18-4599-889D-729A9D******'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid value:

*   **true**
*   **false**', example='true'),
}

model DescribeMaskingRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMaskingRulesResponseBody(name='body'),
}

async function describeMaskingRulesWithOptions(request: DescribeMaskingRulesRequest, runtime: Util.RuntimeOptions): DescribeMaskingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ruleNameList)) {
    query['RuleNameList'] = request.ruleNameList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMaskingRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMaskingRules(request: DescribeMaskingRulesRequest): DescribeMaskingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMaskingRulesWithOptions(request, runtime);
}

model DescribeMetaListRequest {
  backupId?: string(name='BackupId', description='The ID of the data backup file.

>*   When you run a query, you must specify the `BackId` or `RestoreTime` parameter.
>*   You can call the [DescribeBackups](~~98102~~) operation to query the ID of the backup set.', example='111111'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

>  You can call the [DescribeDBClusters](~~98094~~) operation to query the details of all clusters under your account.', example='pc-**************'),
  getDbName?: string(name='GetDbName', description='Specify the specific database name (such as `test_db`) to query the names of all data tables that can be restored in the desired database.

>*   You can specify only one database name each time.
>*   If you do not specify this parameter, you can query the names of all databases that can be restored in the current backup set. However, you cannot query the names of data tables in each database.', example='test_db'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. The value must be an integer that is greater than 0. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values:

*   **30**

*   **50**

*   **100**

    Default value: **30**.', example='30'),
  regionCode?: string(name='RegionCode'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime', description='The point in time for the restoration. Specify the time in the YYYY-MM-DDThh:mmZ format. The time must be in UTC.

>  When you run a query, you must specify the `BackId` or `RestoreTime` parameter. You can call the [DescribeBackups](~~98102~~) operation to query the point in time for the restoration.', example='2020-10-04T01:40:00Z'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeMetaListResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-bp1s826a1up******'),
  items?: [ 
    {
      database?: string(name='Database', description='The name of the database that can be restored.', example='test_db'),
      tables?: [ string ](name='Tables', description='The name of the table that can be restored.'),
    }
  ](name='Items', description='The details of databases and tables that can be restored.'),
  pageNumber?: string(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='AA815DE7-B576-4B22-B33C-3FB31A******'),
  totalPageCount?: string(name='TotalPageCount', description='The total number of returned pages.', example='1'),
  totalRecordCount?: string(name='TotalRecordCount', description='The total number of entries.', example='2'),
}

model DescribeMetaListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMetaListResponseBody(name='body'),
}

async function describeMetaListWithOptions(request: DescribeMetaListRequest, runtime: Util.RuntimeOptions): DescribeMetaListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.getDbName)) {
    query['GetDbName'] = request.getDbName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionCode)) {
    query['RegionCode'] = request.regionCode;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetaList',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMetaList(request: DescribeMetaListRequest): DescribeMetaListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetaListWithOptions(request, runtime);
}

model DescribeParameterGroupRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template.

> You can call the [DescribeParameterGroups](~~207178~~) operation to query the details of all parameter templates of a specified region, such as the ID of a parameter template.', example='pcpg-**************'),
  regionId?: string(name='RegionId', description='The region ID.

>You can call the [DescribeRegions](~~98041~~) operation to query all regions that are available within your account, such as the region ID.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeParameterGroupResponseBody = {
  parameterGroup?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the parameter template was created. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2023-03-10T08:40:39Z'),
      DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='8.0'),
      forceRestart?: string(name='ForceRestart', description='Indicates whether to restart the cluster when this parameter template is applied. Valid values:

*   **0**: A restart is not required.
*   **1**: A restart is required.', example='1'),
      parameterCounts?: int32(name='ParameterCounts', description='The number of parameters in the parameter template.', example='2'),
      parameterDetail?: [ 
        {
          paramName?: string(name='ParamName', description='The name of the parameter.', example='back_log'),
          paramValue?: string(name='ParamValue', description='The value of the parameter.', example='3000'),
        }
      ](name='ParameterDetail', description='Details about the parameters.'),
      parameterGroupDesc?: string(name='ParameterGroupDesc', description='The description of the parameter template.', example='testgroup'),
      parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template.', example='pcpg-**************'),
      parameterGroupName?: string(name='ParameterGroupName', description='The name of the parameter template.', example='test'),
      parameterGroupType?: string(name='ParameterGroupType', description='The type of the parameter template. Valid values:

*   **0**: the default parameter template.
*   **1**: a custom parameter template.
*   **2**: an automatic backup parameter template. After you apply this type of template, the system automatically backs up the original parameter settings and saves the backup as a template.', example='1'),
    }
  ](name='ParameterGroup', description='Details about the parameter templates.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F1F16757-D31B-49CA-9BF4-305BAF******'),
}

model DescribeParameterGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeParameterGroupResponseBody(name='body'),
}

/**
  * You can use parameter templates to manage multiple parameters at a time and apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](~~207009~~).
  * > This parameter is valid only for a PolarDB for MySQL cluster.
  *
  * @param request DescribeParameterGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeParameterGroupResponse
 */
async function describeParameterGroupWithOptions(request: DescribeParameterGroupRequest, runtime: Util.RuntimeOptions): DescribeParameterGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupId)) {
    query['ParameterGroupId'] = request.parameterGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeParameterGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can use parameter templates to manage multiple parameters at a time and apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](~~207009~~).
  * > This parameter is valid only for a PolarDB for MySQL cluster.
  *
  * @param request DescribeParameterGroupRequest
  * @return DescribeParameterGroupResponse
 */
async function describeParameterGroup(request: DescribeParameterGroupRequest): DescribeParameterGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParameterGroupWithOptions(request, runtime);
}

model DescribeParameterGroupsRequest {
  DBType?: string(name='DBType', description='The type of the database engine. Only **MySQL** is supported.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine. Valid values:

*   **5.6**
*   **5.7**
*   **8.0**', example='8.0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

> You can call the [DescribeRegions](~~98041~~) operation to query all regions that are available for your account, such as the region ID.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the virtual node belongs.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeParameterGroupsResponseBody = {
  parameterGroups?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the parameter template was created. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2023-03-10T08:40:39Z'),
      DBType?: string(name='DBType', description='The type of the engine.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine', example='8.0'),
      forceRestart?: string(name='ForceRestart', description='Indicates whether to restart the cluster when this parameter template is applied. Valid values:

*   **0**: A restart is not required.
*   **1**: A restart is required.', example='1'),
      parameterCounts?: long(name='ParameterCounts', description='The number of parameters in the parameter template.', example='2'),
      parameterGroupDesc?: string(name='ParameterGroupDesc', description='The description of the parameter template.', example='testgroup'),
      parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template.', example='pcpg-**************'),
      parameterGroupName?: string(name='ParameterGroupName', description='The name of the parameter template.', example='test'),
      parameterGroupType?: string(name='ParameterGroupType', description='The type of the parameter template. Valid values:

*   **0**: the default parameter template.
*   **1**: a custom parameter template.
*   **2**: an automatic backup parameter template. After you apply this type of template, the system automatically backs up the original parameter settings and saves the backup as a template.', example='1'),
    }
  ](name='ParameterGroups', description='The details of parameter templates.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='944CED46-A6F7-40C6-B6DC-C6E5CC******'),
}

model DescribeParameterGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeParameterGroupsResponseBody(name='body'),
}

/**
  * You can use parameter templates to manage multiple parameters at a time and apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](~~207009~~).
  * > This operation is applicable only to PolarDB for MySQL clusters.
  *
  * @param request DescribeParameterGroupsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeParameterGroupsResponse
 */
async function describeParameterGroupsWithOptions(request: DescribeParameterGroupsRequest, runtime: Util.RuntimeOptions): DescribeParameterGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeParameterGroups',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can use parameter templates to manage multiple parameters at a time and apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](~~207009~~).
  * > This operation is applicable only to PolarDB for MySQL clusters.
  *
  * @param request DescribeParameterGroupsRequest
  * @return DescribeParameterGroupsResponse
 */
async function describeParameterGroups(request: DescribeParameterGroupsRequest): DescribeParameterGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParameterGroupsWithOptions(request, runtime);
}

model DescribeParameterTemplatesRequest {
  DBType?: string(name='DBType', description='The type of the database engine. Only **MySQL** is supported.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database. Valid values:

*   **5.6**
*   **5.7**
*   **8.0**', example='5.7'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.

>  You can call the [DescribeRegions](~~98041~~) operation to query all regions that are available within your account, such as the region IDs.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeParameterTemplatesResponseBody = {
  DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='5.7'),
  engine?: string(name='Engine', description='The database engine of the cluster.', example='POLARDB'),
  parameterCount?: string(name='ParameterCount', description='The number of parameters.', example='183'),
  parameters?: {
    templateRecord?: [ 
    {
      checkingCode?: string(name='CheckingCode', description='The valid values of the parameter.', example='[ROW|STATEMENT|MIXED]'),
      forceModify?: string(name='ForceModify', description='Indicates whether the parameter setting can be modified. Valid values:

*   **true**
*   **false**', example='true'),
      forceRestart?: string(name='ForceRestart', description='Indicates whether a cluster restart is required to make the parameter modification take effect. Valid values:

*   **true**
*   **false**', example='false'),
      isNodeAvailable?: string(name='IsNodeAvailable', description='Indicates whether the parameter is a global parameter. Valid values:

*   **0**: yes. The modified parameter value is synchronized to other nodes by default.
*   **1**: no. You can customize the nodes to which the modified parameter value can be synchronized.', example='1'),
      paramRelyRule?: string(name='ParamRelyRule', description='The parameter dependencies.', example='utf8'),
      parameterDescription?: string(name='ParameterDescription', description='The description of the parameter.', example='What form of binary logging the master will use.'),
      parameterName?: string(name='ParameterName', description='The name of the parameter.', example='binlog_format'),
      parameterValue?: string(name='ParameterValue', description='The default value of the parameter.', example='ROW'),
    }
  ](name='TemplateRecord')
  }(name='Parameters', description='The details of the parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D963934D-8605-4473-8EAC-54C719******'),
}

model DescribeParameterTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeParameterTemplatesResponseBody(name='body'),
}

async function describeParameterTemplatesWithOptions(request: DescribeParameterTemplatesRequest, runtime: Util.RuntimeOptions): DescribeParameterTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeParameterTemplates',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeParameterTemplates(request: DescribeParameterTemplatesRequest): DescribeParameterTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParameterTemplatesWithOptions(request, runtime);
}

model DescribePendingMaintenanceActionRequest {
  isHistory?: int32(name='IsHistory', description='Specifies whether to return the historical tasks. Valid values:

*   **0**: returns the current task.
*   **1**: returns the historical tasks.

Default value: **0**.', example='0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value of this parameter must be an integer that is greater than 0. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **30**, **50**, or **100**.

Default value: **30**.', example='30'),
  region?: string(name='Region', description='The region ID of the pending event. You can call the [DescribeRegions](~~98041~~) operation to query the regions and zones that are supported by PolarDB.
>- You can set this parameter to **all** to view all pending events within your account.
>- If you set `Region` to **all**, you must set `TaskType` to **all**.', example='all'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  taskType?: string(name='TaskType', description='The task type of pending events. Valid values:

*   **DatabaseSoftwareUpgrading**: database software upgrades
*   **DatabaseHardwareMaintenance**: hardware maintenance and upgrades
*   **DatabaseStorageUpgrading**: database storage upgrades
*   **DatabaseProxyUpgrading**: minor version upgrades of the proxy
*   **all**: queries the details of the pending events of all preceding types.

> If the `Region` parameter is set to **all**, the `TaskType` parameter must be set to **all**.', example='all'),
}

model DescribePendingMaintenanceActionResponseBody = {
  items?: [ 
    {
      createdTime?: string(name='CreatedTime', description='The time when the task was created. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-06-09T22:00:42Z'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-************'),
      DBType?: string(name='DBType', description='The type of the database engine. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine.

*   Valid values for the MySQL database engine:

    *   **5.6**
    *   **5.7**
    *   **8.0**

*   Valid values for the PostgreSQL database engine:

    *   **11**
    *   **14**

*   Valid value for the Oracle database engine: **11**', example='8.0'),
      deadline?: string(name='Deadline', description='The deadline before which the task can be executed. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-06-11T15:59:59Z'),
      id?: int32(name='Id', description='The ID of the task.', example='111111'),
      modifiedTime?: string(name='ModifiedTime', description='The time when the parameter was modified. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-06-09T22:00:42Z'),
      prepareInterval?: string(name='PrepareInterval', description='The preparation time that is required before the pending event is switched. The time follows the `HH:mm:ss` format.', example='04:00:00'),
      region?: string(name='Region', description='The region ID of the pending event.', example='cn-hangzhou'),
      resultInfo?: string(name='ResultInfo', description='The execution result of the task. Valid values:

*   **manualCancel**: The task is manually canceled.
*   **paramCheckNotPass**: The task fails to pass the parameter check.

> This parameter is returned only when the value of the `Status` parameter is **6** or **7**. The value 6 indicates that the task is completed but fails to be executed. The value 7 indicates that the task is canceled.', example='manualCancel'),
      startTime?: string(name='StartTime', description='The time when the task was executed in the background. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-06-09T18:00:00Z'),
      status?: int32(name='Status', description='The status of the pending task.

*   If you set the `IsHistory` parameter to **0**, the status of the pending task is returned. Valid values:

    *   **2**: The start time of the task is to be specified.
    *   **3**: The task is pending.
    *   **4**: The task is running. In this case, you cannot modify the execution time.

*   If you set the `IsHistory` parameter to **1**, the details of the historical tasks are returned. Valid values:

    *   **5**: The task is completed and executed.
    *   **6**: The task is completed but fails to be executed.
    *   **7**: The task is canceled.', example='3'),
      switchTime?: string(name='SwitchTime', description='The time when the pending event was switched. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-06-09T22:00:00Z'),
      taskType?: string(name='TaskType', description='The type of the pending event.', example='DatabaseSoftwareUpgrading'),
    }
  ](name='Items', description='Details about tasks.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2F029645-FED9-4FE8-A6D3-488954******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of returned entries.', example='1'),
}

model DescribePendingMaintenanceActionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePendingMaintenanceActionResponseBody(name='body'),
}

async function describePendingMaintenanceActionWithOptions(request: DescribePendingMaintenanceActionRequest, runtime: Util.RuntimeOptions): DescribePendingMaintenanceActionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.isHistory)) {
    query['IsHistory'] = request.isHistory;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePendingMaintenanceAction',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePendingMaintenanceAction(request: DescribePendingMaintenanceActionRequest): DescribePendingMaintenanceActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePendingMaintenanceActionWithOptions(request, runtime);
}

model DescribePendingMaintenanceActionsRequest {
  isHistory?: int32(name='IsHistory', description='Specifies whether to return the historical tasks. Valid values:

*   **0**: returns the current task.
*   **1**: returns the historical tasks.

Default value: **0**.', example='1'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribePendingMaintenanceActionsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='314127C2-B6C1-4F58-B1F6-E6B645******'),
  typeList?: [ 
    {
      count?: int32(name='Count', description='The number of pending events.', example='1'),
      taskType?: string(name='TaskType', description='The task type of pending events. Valid values:

*   **DatabaseSoftwareUpgrading**: database software upgrades
*   **DatabaseHardwareMaintenance**: hardware maintenance and upgrades
*   **DatabaseStorageUpgrading**: database storage upgrades
*   **DatabaseProxyUpgrading**: minor version upgrades of the proxy', example='DatabaseSoftwareUpgrading'),
    }
  ](name='TypeList', description='The details of pending events.'),
}

model DescribePendingMaintenanceActionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePendingMaintenanceActionsResponseBody(name='body'),
}

async function describePendingMaintenanceActionsWithOptions(request: DescribePendingMaintenanceActionsRequest, runtime: Util.RuntimeOptions): DescribePendingMaintenanceActionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.isHistory)) {
    query['IsHistory'] = request.isHistory;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePendingMaintenanceActions',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePendingMaintenanceActions(request: DescribePendingMaintenanceActionsRequest): DescribePendingMaintenanceActionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePendingMaintenanceActionsWithOptions(request, runtime);
}

model DescribePolarSQLCollectorPolicyRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query the details of all the clusters for your account, such as the cluster ID.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribePolarSQLCollectorPolicyResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The IDs of the clusters.', example='pc-bp1s826a1up******'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3655211B-4D74-4E13-91E6-FF2AFE******'),
  SQLCollectorStatus?: string(name='SQLCollectorStatus', description='Indicates whether the SQL Explorer feature is enabled. Valid values:

*   **Enable**
*   **Disabled**', example='Enable'),
}

model DescribePolarSQLCollectorPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePolarSQLCollectorPolicyResponseBody(name='body'),
}

async function describePolarSQLCollectorPolicyWithOptions(request: DescribePolarSQLCollectorPolicyRequest, runtime: Util.RuntimeOptions): DescribePolarSQLCollectorPolicyResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePolarSQLCollectorPolicy',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePolarSQLCollectorPolicy(request: DescribePolarSQLCollectorPolicyRequest): DescribePolarSQLCollectorPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePolarSQLCollectorPolicyWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      zones?: {
        zone?: [ 
        {
          vpcEnabled?: boolean(name='VpcEnabled', description='Indicates whether virtual private clouds (VPCs) are supported.', example='true'),
          zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-g'),
        }
      ](name='Zone')
      }(name='Zones', description='The list of zones.'),
    }
  ](name='Region')
  }(name='Regions', description='The list of regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3F9E6A3B-C13E-4064-A010-18582A******'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeScheduleTasksRequest {
  DBClusterDescription?: string(name='DBClusterDescription', description='The description of the cluster.', example='testdb'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

> 

*   You can call the [DescribeDBClusters](~~98094~~) operation to query the information of all PolarDB clusters that are deployed in a specific region, such as the cluster IDs.

*   If you do not specify this parameter, all scheduled tasks on your clusters are queried.', example='pc-**************'),
  orderId?: string(name='OrderId', description='The ID of the order.

>  The order ID can contain only digits.', example='20951253014****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. Set this parameter to an integer that is greater than 0. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: **30**, **50**, and **100**. Default value: 30.', example='30'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time of the task that you specified when you created the scheduled task. The time is displayed in UTC.', example='2021-01-28T12:30Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time of the task that you specified when you created the scheduled task. The time is displayed in UTC.', example='2021-01-28T12:00Z'),
  regionId?: string(name='RegionId', description='The ID of the region.

> 

*   You can call the [DescribeRegions](~~98041~~) operation to query the region information of all clusters in a specific account.

*   If you do not specify this parameter, scheduled tasks on your clusters that are deployed in all regions are queried.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: string(name='Status', description='The state of the tasks that you want to query. Valid values:

*   **pending**: The tasks are pending execution.
*   **executing**: The tasks are being executed.
*   **failure**: The tasks failed and need to be run again.
*   **finish**: The tasks are complete.
*   **cancel**: The tasks are canceled.
*   **expired**: The tasks are expired. The tasks are not started within the time periods that are specified to start the tasks.
*   **rollback**: The tasks are being rolled back.

>  If you do not specify this parameter, all scheduled tasks in all states are queried.', example='finish'),
  taskAction?: string(name='TaskAction', description='The type of scheduled tasks that you want to query. Valid values:

*   **CreateDBNodes**
*   **ModifyDBNodeClass**
*   **UpgradeDBClusterVersion**
*   **ModifyDBClusterPrimaryZone**

> 

*   If you specify the `PlannedStartTime` parameter when you call the four preceding operations, the details of each task are returned. Otherwise, an empty string is returned for the `TimerInfos` parameter.

*   If you do not specify this parameter, all types of scheduled tasks on you clusters are queried.', example='CreateDBNodes'),
}

model DescribeScheduleTasksResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber', description='The page number of the page returned.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
    timerInfos?: [ 
      {
        action?: string(name='Action', description='The type of the scheduled tasks.', example='CreateDBNodes'),
        DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-**************'),
        dbClusterDescription?: string(name='DbClusterDescription', description='The description of the cluster.', example='test_cluster'),
        dbClusterStatus?: string(name='DbClusterStatus', description='The state of the cluster.', example='Running'),
        orderId?: string(name='OrderId', description='The ID of the order.

>  This parameter is returned only when you set the `Action` parameter to **CreateDBNodes** or **ModifyDBNodeClass**.', example='208161753******'),
        plannedEndTime?: string(name='PlannedEndTime', description='The latest start time of the task that you specified when you created the scheduled task. The time is displayed in UTC.', example='2021-01-28T12:30Z'),
        plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time of the task that you specified when you created the scheduled task. The time is displayed in UTC.', example='2021-01-28T12:00Z'),
        plannedTime?: string(name='PlannedTime', description='The expected start time of the task. The time is displayed in UTC.', example='2021-01-28T12:16Z'),
        region?: string(name='Region', description='The ID of the region in which the scheduled task runs.', example='cn-hangzhou'),
        status?: string(name='Status', description='The state of the scheduled task.', example='finish'),
        taskCancel?: boolean(name='TaskCancel', description='Indicates whether the scheduled task can be canceled. Valid values:

*   **true**
*   **false**', example='true'),
        taskId?: string(name='TaskId', description='The ID of the task.', example='53879cdb-9a00-428e-acaf-ff4cff******'),
      }
    ](name='TimerInfos', description='The details of the scheduled task.'),
    totalRecordCount?: int32(name='TotalRecordCount', description='The total number of entries returned.', example='1'),
  }(name='Data', description='The result data that is returned.'),
  message?: string(name='Message', description='The message that is returned for the request.

>  If the request is successful, **Successful** is returned. If the request fails, an error message such as an error code is returned.', example='Successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='936C7025-27A5-4CB1-BB31-540E1F0CCA12'),
  success?: boolean(name='Success', description='Indicates whether the request is successful.', example='true'),
}

model DescribeScheduleTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeScheduleTasksResponseBody(name='body'),
}

async function describeScheduleTasksWithOptions(request: DescribeScheduleTasksRequest, runtime: Util.RuntimeOptions): DescribeScheduleTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterDescription)) {
    query['DBClusterDescription'] = request.DBClusterDescription;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskAction)) {
    query['TaskAction'] = request.taskAction;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScheduleTasks',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeScheduleTasks(request: DescribeScheduleTasksRequest): DescribeScheduleTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScheduleTasksWithOptions(request, runtime);
}

model DescribeSlowLogRecordsRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.', example='pc-************'),
  DBName?: string(name='DBName', description='The name of the database.', example='testdb'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. The interval between the start time and end time must be within 24 hours. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

> This parameter must be set to a time value in UTC (UTC+0 time zone). If your service resides in another time zone, convert the time value. For example, if the local time in the time zone where your service resides is 12:00 (UTC +8) and you want to query slow query logs at 08:00 (UTC +8) to 12:00, set this parameter to a time value that ranges from 00:00, set this parameter to 04:00.', example='2022-11-16T04:00Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. The value must be an integer that is larger than 0.

Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

> You can call the [DescribeRegions](~~98041~~) operation to query all regions that are available for your account, such as the region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  SQLHASH?: string(name='SQLHASH', description='The unique ID of the SQL statement. The ID is used to obtain the slow query logs of the SQL statement.', example='U2FsdGVk****'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

> 

*   You can specify a time range of up to 30 days.

*   This parameter must be set to a time value in UTC (UTC+0 time zone). If your service resides in another time zone, convert the time value. For example, if the local time in the time zone where your service resides is 12:00 (UTC +8) and you want to query slow query logs at 08:00 (UTC +8) to 12:00, set this parameter to a time value that ranges from 00:00, set this parameter to 04:00.', example='2022-11-15T16:00Z'),
}

model DescribeSlowLogRecordsResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-*****************'),
  engine?: string(name='Engine', description='The type of the database engine.', example='polardb_mysql'),
  items?: {
    SQLSlowRecord?: [ 
    {
      DBName?: string(name='DBName', description='The name of the database.', example='testdb'),
      DBNodeId?: string(name='DBNodeId', description='The ID of the node.', example='pi-*****************'),
      executionStartTime?: string(name='ExecutionStartTime', description='The time when the SQL statement was executed. The time is in the `yyyy-MM-ddTHH:mmZ` format. The time is displayed in UTC.', example='2021-04-07T03:47Z'),
      hostAddress?: string(name='HostAddress', description='The IP address of the client that is used to connect to the database.', example='testdb[testdb] @  [100.**.**.242]'),
      lockTimes?: long(name='LockTimes', description='The period of time during which the SQL statement was locked. Unit: seconds.', example='0'),
      parseRowCounts?: long(name='ParseRowCounts', description='The number of rows parsed by the SQL statement.', example='0'),
      queryTimeMS?: long(name='QueryTimeMS', description='The time range for the query. Unit: milliseconds.', example='100'),
      queryTimes?: long(name='QueryTimes', description='The amount of time that was consumed to execute the SQL statement. Unit: seconds.', example='20'),
      returnRowCounts?: long(name='ReturnRowCounts', description='The number of rows returned by the SQL statement.', example='0'),
      SQLText?: string(name='SQLText', description='The SQL statement that is executed in the query.', example='/* Query from *** by user 111 */ SELECT sleep(20)'),
    }
  ](name='SQLSlowRecord')
  }(name='Items', description='Details about slow query logs.'),
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A7E6A8FD-C50B-46B2-BA85-D8B8D3******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of SQL statements.', example='1'),
}

model DescribeSlowLogRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSlowLogRecordsResponseBody(name='body'),
}

/**
  * > This operation is applicable only to PolarDB for MySQL clusters.
  *
  * @param request DescribeSlowLogRecordsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeSlowLogRecordsResponse
 */
async function describeSlowLogRecordsWithOptions(request: DescribeSlowLogRecordsRequest, runtime: Util.RuntimeOptions): DescribeSlowLogRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.SQLHASH)) {
    query['SQLHASH'] = request.SQLHASH;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSlowLogRecords',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > This operation is applicable only to PolarDB for MySQL clusters.
  *
  * @param request DescribeSlowLogRecordsRequest
  * @return DescribeSlowLogRecordsResponse
 */
async function describeSlowLogRecords(request: DescribeSlowLogRecordsRequest): DescribeSlowLogRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSlowLogRecordsWithOptions(request, runtime);
}

model DescribeSlowLogsRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-****************'),
  DBName?: string(name='DBName', description='The name of the database.', example='PolarDB_MySQL'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. The time span between the start time and the end time cannot exceed 31 days. Specify the time in the yyyy-MM-ddZ format. The time must be in UTC.', example='2021-05-30Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Valid values: any non-zero positive integer.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 30 to 100. Default value: 30.', example='30'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the yyyy-MM-ddZ format. The time must be in UTC.', example='2021-05-01Z'),
}

model DescribeSlowLogsResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-****************'),
  endTime?: string(name='EndTime', description='The end date of the query.', example='2021-05-30Z'),
  engine?: string(name='Engine', description='The type of the database engine.', example='polardb_mysql'),
  items?: {
    SQLSlowLog?: [ 
    {
      createTime?: string(name='CreateTime', description='The date when the data was generated.', example='2021-05-30Z'),
      DBName?: string(name='DBName', description='The name of the database.', example='PolarDB_MySQL'),
      DBNodeId?: string(name='DBNodeId', description='The ID of the node.', example='pi-***************'),
      maxExecutionTime?: long(name='MaxExecutionTime', description='The longest execution duration of a specific SQL statement in the query. Unit: seconds.', example='60'),
      maxLockTime?: long(name='MaxLockTime', description='The longest lock duration that was caused by a specific SQL statement in the query. Unit: seconds.', example='1'),
      parseMaxRowCount?: long(name='ParseMaxRowCount', description='The largest number of rows that were parsed by a specific SQL statement in the query.', example='1'),
      parseTotalRowCounts?: long(name='ParseTotalRowCounts', description='The total number of rows that were parsed by all SQL statements in the query.', example='2'),
      returnMaxRowCount?: long(name='ReturnMaxRowCount', description='The largest number of rows that were returned by a specific SQL statement in the query.', example='3'),
      returnTotalRowCounts?: long(name='ReturnTotalRowCounts', description='The total number of rows that were returned by all SQL statements in the query.', example='1'),
      SQLHASH?: string(name='SQLHASH', description='The unique ID of the SQL statement. The ID is used to obtain the slow query logs of the SQL statement.', example='U2FsdGVkxxxx'),
      SQLText?: string(name='SQLText', description='The SQL statement that is executed in the query.', example='select id,name from tb_table'),
      totalExecutionCounts?: long(name='TotalExecutionCounts', description='The total number of executions of the SQL statements.', example='2'),
      totalExecutionTimes?: long(name='TotalExecutionTimes', description='The total duration that was caused by all SQL statements in the query. Unit: seconds.', example='2'),
      totalLockTimes?: long(name='TotalLockTimes', description='The total lock duration that was caused by all SQL statements in the query. Unit: seconds.', example='1'),
    }
  ](name='SQLSlowLog')
  }(name='Items', description='Details about slow query logs.'),
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='3'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of SQL statements that are returned on the current page.', example='6'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2553A660-E4EB-4AF4-A402-8AFF70A49143'),
  startTime?: string(name='StartTime', description='The start date of the query.', example='2021-05-01Z'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of returned entries.', example='5'),
}

model DescribeSlowLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSlowLogsResponseBody(name='body'),
}

/**
  * > This operation is applicable only to PolarDB for MySQL clusters.
  *
  * @param request DescribeSlowLogsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeSlowLogsResponse
 */
async function describeSlowLogsWithOptions(request: DescribeSlowLogsRequest, runtime: Util.RuntimeOptions): DescribeSlowLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSlowLogs',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > This operation is applicable only to PolarDB for MySQL clusters.
  *
  * @param request DescribeSlowLogsRequest
  * @return DescribeSlowLogsResponse
 */
async function describeSlowLogs(request: DescribeSlowLogsRequest): DescribeSlowLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSlowLogsWithOptions(request, runtime);
}

model DescribeTasksRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

>  You must specify `DBNodeId` or `DBClusterId`. You can call the [DescribeDBClusters](~~98094~~) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.', example='pc-***************'),
  DBNodeId?: string(name='DBNodeId', description='The node ID.

>  You must specify `DBNodeId` or `DBClusterId`. You can call the [DescribeDBClusters](~~98094~~) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as node IDs.', example='pi-***************'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mmZ` format. The time must be in UTC. The end time must be later than the start time.', example='2020-12-02T03:00Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. The value is an integer that is greater than 0.

Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page. Valid values: **30**, **50**, and **100**.

Default value: **30**.', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.', example='2020-11-30T00:00Z'),
  status?: string(name='Status', description='The state of the tasks that you want to query. Valid values:

*   **Waiting**: The task is pending.
*   **Running**: The task is running.
*   **Finished**: The task is completed.
*   **Closed**: The task is closed.
*   **Pause**: The task is suspended.
*   **Stop**: The task is interrupted.

> 

*   If you do not specify this parameter, the operation returns the details of only the tasks that are in the **Waiting** or **Running** state for the cluster or node.

*   You can enter multiple task states. Separate multiple task states with commas (,).', example='Running'),
}

model DescribeTasksResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster for which the task was created.', example='pc-***************'),
  endTime?: string(name='EndTime', description='The end time of the query.', example='2020-12-02T03:00Z'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page returned.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The request ID.', example='4352AD99-9FF5-41A6-A319-068089******'),
  startTime?: string(name='StartTime', description='The start time of the query.', example='2020-11-30T00:00Z'),
  tasks?: {
    task?: [ 
    {
      beginTime?: string(name='BeginTime', description='The time when the task was started. The time follows the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.', example='2020-12-02T02:39:15Z'),
      currentStepName?: string(name='CurrentStepName', description='The name of the current step.', example='create_instance'),
      DBName?: string(name='DBName', description='The database name.

>  This parameter is returned for only the tasks that involve database operations.', example='test'),
      expectedFinishTime?: string(name='ExpectedFinishTime', description='The estimated end time of the task. In most cases, this parameter is empty.', example='null'),
      finishTime?: string(name='FinishTime', description='The time when the task was completed. The time follows the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.', example='2020-12-02T02:40:15Z'),
      progress?: int32(name='Progress', description='The progress of the task in percentage.', example='100'),
      progressInfo?: string(name='ProgressInfo', description='The description of the task progress. If no progress description is provided for the task, this parameter is empty.', example='null'),
      remain?: int32(name='Remain', description='The estimated remaining duration of the task. Unit: seconds.', example='1767'),
      stepProgressInfo?: string(name='StepProgressInfo', description='The progress of the subtasks. For example, the value `1/4` indicates that the task consists of four subtasks and the first subtask is in progress.', example='1/4'),
      stepsInfo?: string(name='StepsInfo', description='The details of the subtasks.', example='[{\\"remain\\":0,\\"name\\":\\"init_task\\",\\"progress\\":100},{\\"remain\\":1764,\\"name\\":\\"create_instance\\",\\"progress\\":0},{\\"remain\\":1,\\"name\\":\\"init_cluster\\",\\"progress\\":0},{\\"remain\\":2,\\"name\\":\\"create_backup\\",\\"progress\\":0}]'),
      taskAction?: string(name='TaskAction', description='The API operation that is used by the task. Example: `CreateDBInstance`.', example='CreateDBInstance'),
      taskErrorCode?: string(name='TaskErrorCode', description='The error code that is returned when an error occurs.

>  This parameter is returned only when the task is in the **Stop** state.', example='null'),
      taskErrorMessage?: string(name='TaskErrorMessage', description='The error message that is returned when an error occurs.

>  This parameter is returned only when the task is in the **Stop** state.', example='null'),
      taskId?: string(name='TaskId', description='The ID of the task.', example='111111111'),
    }
  ](name='Task')
  }(name='Tasks', description='The details of the task.'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of entries returned.', example='1'),
}

model DescribeTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTasksResponseBody(name='body'),
}

/**
  * *   You can call this operation to view the details of a task that is generated by a specific API operation or in the console. The system calls the specific API operation when you perform an operation in the console. For example, you can view the details of the task when you call the [CreateDBCluster](~~98169~~) operation or [create a cluster](~~58769~~) in the console.
  * *   You can view the details of tasks that are generated only when you call the [CreateDBCluster](~~98169~~) operation to create a cluster and `CreationOption` is not set to `CreateGdnStandby`.
  *
  * @param request DescribeTasksRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeTasksResponse
 */
async function describeTasksWithOptions(request: DescribeTasksRequest, runtime: Util.RuntimeOptions): DescribeTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeId)) {
    query['DBNodeId'] = request.DBNodeId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTasks',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   You can call this operation to view the details of a task that is generated by a specific API operation or in the console. The system calls the specific API operation when you perform an operation in the console. For example, you can view the details of the task when you call the [CreateDBCluster](~~98169~~) operation or [create a cluster](~~58769~~) in the console.
  * *   You can view the details of tasks that are generated only when you call the [CreateDBCluster](~~98169~~) operation to create a cluster and `CreationOption` is not set to `CreateGdnStandby`.
  *
  * @param request DescribeTasksRequest
  * @return DescribeTasksResponse
 */
async function describeTasks(request: DescribeTasksRequest): DescribeTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTasksWithOptions(request, runtime);
}

model DescribeUserEncryptionKeyListRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.', example='pc-************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region.

> You can call the [DescribeRegions](~~98041~~) operation to query all regions that are available for your account, such as the region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  TDERegion?: string(name='TDERegion', description='The region where the TDE key resides.', example='cn-beijing'),
}

model DescribeUserEncryptionKeyListResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-************'),
  keyList?: [ string ](name='KeyList'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A7E6A8FD-C50B-46B2-BA85-D8B8D3******'),
}

model DescribeUserEncryptionKeyListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUserEncryptionKeyListResponseBody(name='body'),
}

async function describeUserEncryptionKeyListWithOptions(request: DescribeUserEncryptionKeyListRequest, runtime: Util.RuntimeOptions): DescribeUserEncryptionKeyListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.TDERegion)) {
    query['TDERegion'] = request.TDERegion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserEncryptionKeyList',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUserEncryptionKeyList(request: DescribeUserEncryptionKeyListRequest): DescribeUserEncryptionKeyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserEncryptionKeyListWithOptions(request, runtime);
}

model DescribeVSwitchesRequest {
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId', example='dhg-4n****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='50'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-bp67acfmxazb4ph****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  vpcId?: string(name='VpcId', example='vpc-25cdvfeq58pl****'),
  zoneId?: string(name='ZoneId', example='cn-hangzhou-d'),
}

model DescribeVSwitchesResponseBody = {
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
  requestId?: string(name='RequestId', example='9A572171-4E27-40D1-BD36-D26C9E71E29E'),
  totalCount?: int32(name='TotalCount', example='1'),
  vSwitchs?: [ 
    {
      availableIpAddressCount?: long(name='AvailableIpAddressCount', example='1'),
      cidrBlock?: string(name='CidrBlock', example='172.16.0.0/24'),
      description?: string(name='Description', example='VSwitchDescription'),
      isDefault?: boolean(name='IsDefault', example='true'),
      izNo?: string(name='IzNo', example='cn-hangzhou-b'),
      status?: string(name='Status', example='Available'),
      vSwitchId?: string(name='VSwitchId', example='vsw-25bcdxs7pv1****'),
      vSwitchName?: string(name='VSwitchName', example='vSwitch'),
    }
  ](name='VSwitchs'),
}

model DescribeVSwitchesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVSwitchesResponseBody(name='body'),
}

async function describeVSwitchesWithOptions(request: DescribeVSwitchesRequest, runtime: Util.RuntimeOptions): DescribeVSwitchesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVSwitches',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVSwitchesWithOptions(request, runtime);
}

model DisableDBClusterServerlessRequest {
  DBClusterId?: string(name='DBClusterId', example='pc-***************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DisableDBClusterServerlessResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-****************'),
  requestId?: string(name='RequestId', example='CD3FA5F3-FAF3-44CA-AFFF-BAF869******'),
}

model DisableDBClusterServerlessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableDBClusterServerlessResponseBody(name='body'),
}

async function disableDBClusterServerlessWithOptions(request: DisableDBClusterServerlessRequest, runtime: Util.RuntimeOptions): DisableDBClusterServerlessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableDBClusterServerless',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableDBClusterServerless(request: DisableDBClusterServerlessRequest): DisableDBClusterServerlessResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableDBClusterServerlessWithOptions(request, runtime);
}

model EnableDBClusterServerlessRequest {
  DBClusterId?: string(name='DBClusterId', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scaleApRoNumMax?: string(name='ScaleApRoNumMax', example='1'),
  scaleApRoNumMin?: string(name='ScaleApRoNumMin', example='1'),
  scaleMax?: string(name='ScaleMax', example='2'),
  scaleMin?: string(name='ScaleMin', example='1'),
  scaleRoNumMax?: string(name='ScaleRoNumMax', example='2'),
  scaleRoNumMin?: string(name='ScaleRoNumMin', example='1'),
}

model EnableDBClusterServerlessResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-bp10gr51qasnl****'),
  requestId?: string(name='RequestId', example='5E71541A-6007-4DCC-A38A-F872C31FEB45'),
}

model EnableDBClusterServerlessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableDBClusterServerlessResponseBody(name='body'),
}

async function enableDBClusterServerlessWithOptions(request: EnableDBClusterServerlessRequest, runtime: Util.RuntimeOptions): EnableDBClusterServerlessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scaleApRoNumMax)) {
    query['ScaleApRoNumMax'] = request.scaleApRoNumMax;
  }
  if (!Util.isUnset(request.scaleApRoNumMin)) {
    query['ScaleApRoNumMin'] = request.scaleApRoNumMin;
  }
  if (!Util.isUnset(request.scaleMax)) {
    query['ScaleMax'] = request.scaleMax;
  }
  if (!Util.isUnset(request.scaleMin)) {
    query['ScaleMin'] = request.scaleMin;
  }
  if (!Util.isUnset(request.scaleRoNumMax)) {
    query['ScaleRoNumMax'] = request.scaleRoNumMax;
  }
  if (!Util.isUnset(request.scaleRoNumMin)) {
    query['ScaleRoNumMin'] = request.scaleRoNumMin;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableDBClusterServerless',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableDBClusterServerless(request: EnableDBClusterServerlessRequest): EnableDBClusterServerlessResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableDBClusterServerlessWithOptions(request, runtime);
}

model EnableFirewallRulesRequest {
  DBClusterId?: string(name='DBClusterId', example='pc-************'),
  enable?: boolean(name='Enable', example='true'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleNameList?: string(name='RuleNameList', example='test111'),
}

model EnableFirewallRulesResponseBody = {
  message?: string(name='Message', example='Message'),
  requestId?: string(name='RequestId', description='Id of the request', example='99B355CE-526C-478B-B730-AD9D7C******'),
  success?: boolean(name='Success', example='true'),
}

model EnableFirewallRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableFirewallRulesResponseBody(name='body'),
}

async function enableFirewallRulesWithOptions(request: EnableFirewallRulesRequest, runtime: Util.RuntimeOptions): EnableFirewallRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleNameList)) {
    query['RuleNameList'] = request.ruleNameList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableFirewallRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableFirewallRules(request: EnableFirewallRulesRequest): EnableFirewallRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableFirewallRulesWithOptions(request, runtime);
}

model EvaluateRegionResourceRequest {
  DBInstanceConnType?: string(name='DBInstanceConnType', description='The cluster link type. The backend randomly selects the default value. Valid values:

*   **lvs** :Linux virtual server
*   **proxy**: proxy server
*   **dns**: domain name system', example='lvs'),
  DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node. For information about node specifications, see the following topics:

*   PolarDB for MySQL: [Specifications of compute nodes](~~102542~~)
*   PolarDB for Oracle: [Specifications of compute nodes](~~207921~~)
*   PolarDB for PostgreSQL: [Specifications of compute nodes](~~209380~~)', example='polar.mysql.x4.large'),
  DBType?: string(name='DBType', description='The type of the database engine. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine

*   Valid values for the MySQL database engine:

    *   **5.6**
    *   **5.7**
    *   **8.0**

*   Valid values for the PostgreSQL database engine:

    *   **11**
    *   **14**

*   Valid value for the Oracle database engine: **11**', example='8.0'),
  dispenseMode?: string(name='DispenseMode', description='Specifies whether to return the zones in which the single-zone deployment method is supported. Default value: 0. Valid values:

*   **0**: no value returned
*   **1**: returns the zones.', example='1'),
  needMaxScaleLink?: string(name='NeedMaxScaleLink', description='Specifies whether Maxscale is created. Default value: true. Valid values:

*   **true**
*   **false**', example='true'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.

> You can call the [DescribeRegions](~~98041~~) operation to query available regions.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  subDomain?: string(name='SubDomain', description='The subdomain. It is the child domain of the top-level domain name or parent domain. For example, if the parent domain name is cn-beijing, its child domain can be cn-beijing-i-aliyun.', example='cn-beijing-i-aliyun'),
  zoneId?: string(name='ZoneId', description='The zone ID.

> You can call the [DescribeRegions](~~98041~~) operation to query available zones.', example='cn-hangzhou-g'),
}

model EvaluateRegionResourceResponseBody = {
  DBInstanceAvailable?: string(name='DBInstanceAvailable', description='Indicates whether sufficient resources are available. Valid values:

*   **true**
*   **false**', example='true'),
  DBType?: string(name='DBType', description='The type of the database engine. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine

*   Valid values for the MySQL database engine:

    *   **5.6**
    *   **5.7**
    *   **8.0**

*   Valid values for the PostgreSQL database engine:

    *   **11**
    *   **14**

*   Valid value for the Oracle database engine: **11**', example='8.0'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='69A85BAF-1089-4CDF-A82F-0A140F******'),
}

model EvaluateRegionResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EvaluateRegionResourceResponseBody(name='body'),
}

async function evaluateRegionResourceWithOptions(request: EvaluateRegionResourceRequest, runtime: Util.RuntimeOptions): EvaluateRegionResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceConnType)) {
    query['DBInstanceConnType'] = request.DBInstanceConnType;
  }
  if (!Util.isUnset(request.DBNodeClass)) {
    query['DBNodeClass'] = request.DBNodeClass;
  }
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.dispenseMode)) {
    query['DispenseMode'] = request.dispenseMode;
  }
  if (!Util.isUnset(request.needMaxScaleLink)) {
    query['NeedMaxScaleLink'] = request.needMaxScaleLink;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EvaluateRegionResource',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function evaluateRegionResource(request: EvaluateRegionResourceRequest): EvaluateRegionResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return evaluateRegionResourceWithOptions(request, runtime);
}

model FailoverDBClusterRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5******'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  rollBackForDisaster?: boolean(name='RollBackForDisaster'),
  targetDBNodeId?: string(name='TargetDBNodeId', description='The ID of the read-only node that you want to promote to the primary node. You can call the [DescribeDBClusters](~~98094~~) operation to query node information, such as node IDs.

> *   If you leave this parameter empty, the system selects one or more available read-only nodes that have the highest failover priority as candidate primary nodes. If the failover to the first read-only node fails due to network issues, abnormal replication status, or other reasons, the system attempts to fail over your applications to the next read-only node until the failover is successful.
>*  This parameter is required for PolarDB for Oracle and PolarDB for PostgreSQL clusters. This parameter is optional for PolarDB for MySQL clusters.', example='pi-***********'),
}

model FailoverDBClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model FailoverDBClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FailoverDBClusterResponseBody(name='body'),
}

async function failoverDBClusterWithOptions(request: FailoverDBClusterRequest, runtime: Util.RuntimeOptions): FailoverDBClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.rollBackForDisaster)) {
    query['RollBackForDisaster'] = request.rollBackForDisaster;
  }
  if (!Util.isUnset(request.targetDBNodeId)) {
    query['TargetDBNodeId'] = request.targetDBNodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FailoverDBCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function failoverDBCluster(request: FailoverDBClusterRequest): FailoverDBClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return failoverDBClusterWithOptions(request, runtime);
}

model GrantAccountPrivilegeRequest {
  accountName?: string(name='AccountName', description='The username of the account.', example='testacc'),
  accountPrivilege?: string(name='AccountPrivilege', description='The permissions that are granted to the account. Valid values:

*   **ReadWrite**: read and write permissions
*   **ReadOnly**: read-only permissions
*   **DMLOnly**: The account is granted the permissions to execute only DML statements on the database.
*   **DDLOnly**: The account is granted the permissions to execute only DDL statements on the database.
*   **ReadIndex**: The account has the read and index permissions on the database.

> The number of **AccountPrivilege** values must be the consistent with the number of **DBName** values. Each account permission must correspond to a database name in sequence. For example, you can set **DBName** to `testdb_1,testdb_2` and set **AccountPrivilege** to `ReadWrite,ReadOnly`. In this case, the specified standard account is granted the **read and write** permissions on the **testdb\\_1** database and the **read** permission on the **testdb\\_2** database.', example='ReadWrite,ReadOnly'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-****************'),
  DBName?: string(name='DBName', description='The names of the databases that the account can access. You can grant the access permissions on one or more databases to the specified standard account. If you need to specify multiple database names, separate the database names with commas (,).', example='testdb_1,testdb_2'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GrantAccountPrivilegeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627*****'),
}

model GrantAccountPrivilegeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GrantAccountPrivilegeResponseBody(name='body'),
}

/**
  * > *   An account can be authorized to access one or more databases.
  * > *   If the specified account already has the access permissions on the specified databases, the operation returns a successful response.
  * > *   Before you call this operation, make sure that the cluster is in the Running state. Otherwise, the operation fails.
  * > *   You can call this operation only on a PolarDB for MySQL cluster.
  * > *   By default, a privileged account for a cluster has all the permissions on the databases in the cluster.
  *
  * @param request GrantAccountPrivilegeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GrantAccountPrivilegeResponse
 */
async function grantAccountPrivilegeWithOptions(request: GrantAccountPrivilegeRequest, runtime: Util.RuntimeOptions): GrantAccountPrivilegeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPrivilege)) {
    query['AccountPrivilege'] = request.accountPrivilege;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GrantAccountPrivilege',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > *   An account can be authorized to access one or more databases.
  * > *   If the specified account already has the access permissions on the specified databases, the operation returns a successful response.
  * > *   Before you call this operation, make sure that the cluster is in the Running state. Otherwise, the operation fails.
  * > *   You can call this operation only on a PolarDB for MySQL cluster.
  * > *   By default, a privileged account for a cluster has all the permissions on the databases in the cluster.
  *
  * @param request GrantAccountPrivilegeRequest
  * @return GrantAccountPrivilegeResponse
 */
async function grantAccountPrivilege(request: GrantAccountPrivilegeRequest): GrantAccountPrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  return grantAccountPrivilegeWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', description='The token required to obtain more results. This parameter is not required in the first query. If the first query does not return all results, you can use the token that is returned from the first query in the next query to obtain more results.', example='212db86sca4384811e0b5e8707e******'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call the [DescribeRegions](~~98041~~) operation to query available region IDs.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The cluster ID. To query the tags of multiple clusters, click **Add** to add cluster IDs.

> 

*   You must specify at least one of the `ResourceId.N` and `Tag.N.Key` parameters.

*   If you specify the `ResourceId.N` parameter, you can add a maximum of 50 cluster IDs at a time.', example='pc-****************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Set the value to **cluster**.', example='cluster'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag. To query the details of clusters to which multiple tags are bound, click **Add** to add tags.

> 

*   You must specify at least one of the `ResourceId.N` and `Tag.N.Key` parameters.

*   If you specify the `Tag.N.Key` parameter, you can create up to 20 tags at a time.', example='type'),
      value?: string(name='Value', description='The tag value that is paired with the tag key. This parameter can be set to an empty string.', example='test'),
    }
  ](name='Tag', description='The tags.'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='The token required to obtain more results. If not all results are returned in this query, the token is returned. You can use this token in the next query to obtain more results.', example='212db86sca4384811e0b5e8707e******'),
  requestId?: string(name='RequestId', description='The request ID.', example='688C04E4-23F8-409F-8A38-B954D5******'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId', description='The cluster ID.', example='pc-****************'),
      resourceType?: string(name='ResourceType', description='The type of the resource. This parameter is set to **cluster**.', example='cluster'),
      tagKey?: string(name='TagKey', description='The key of the tag.', example='type'),
      tagValue?: string(name='TagValue', description='The value of the tag.', example='test'),
    }
  ](name='TagResource')
  }(name='TagResources', description='The details of the queried clusters and tags.'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ManuallyStartDBClusterRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-xxxxxxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

> You can call the [DescribeRegions](~~98041~~) operation to query available regions.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ManuallyStartDBClusterResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='73A85BAF-1039-4CDE-A83F-1A140F******'),
}

model ManuallyStartDBClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ManuallyStartDBClusterResponseBody(name='body'),
}

async function manuallyStartDBClusterWithOptions(request: ManuallyStartDBClusterRequest, runtime: Util.RuntimeOptions): ManuallyStartDBClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ManuallyStartDBCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function manuallyStartDBCluster(request: ManuallyStartDBClusterRequest): ManuallyStartDBClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return manuallyStartDBClusterWithOptions(request, runtime);
}

model ModifyAccountDescriptionRequest {
  accountDescription?: string(name='AccountDescription', description='The description of the account. The description must meet the following requirements:

*   The description cannot start with `http://` or `https://`.
*   The description must be 2 to 256 characters in length.', example='test'),
  accountName?: string(name='AccountName', description='The name of the account.', example='testacc'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyAccountDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model ModifyAccountDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAccountDescriptionResponseBody(name='body'),
}

async function modifyAccountDescriptionWithOptions(request: ModifyAccountDescriptionRequest, runtime: Util.RuntimeOptions): ModifyAccountDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDescription)) {
    query['AccountDescription'] = request.accountDescription;
  }
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAccountDescription',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyAccountDescription(request: ModifyAccountDescriptionRequest): ModifyAccountDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAccountDescriptionWithOptions(request, runtime);
}

model ModifyAccountPasswordRequest {
  accountName?: string(name='AccountName', description='The username of the account.', example='testacc'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-************'),
  newAccountPassword?: string(name='NewAccountPassword', description='The new password of the account. The new password must meet the following requirements:

*   It must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.
*   It must be 8 to 32 characters in length.
*   Special characters include `! @ # $ % ^ & * ( ) _ + - =`', example='Pw123456'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyAccountPasswordResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model ModifyAccountPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAccountPasswordResponseBody(name='body'),
}

async function modifyAccountPasswordWithOptions(request: ModifyAccountPasswordRequest, runtime: Util.RuntimeOptions): ModifyAccountPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.newAccountPassword)) {
    query['NewAccountPassword'] = request.newAccountPassword;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAccountPassword',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyAccountPassword(request: ModifyAccountPasswordRequest): ModifyAccountPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAccountPasswordWithOptions(request, runtime);
}

model ModifyAutoRenewAttributeRequest {
  DBClusterIds?: string(name='DBClusterIds', description='The cluster ID. If you need to specify multiple cluster IDs, separate the cluster IDs with commas (,).', example='pc-***************'),
  duration?: string(name='Duration', description='The automatic renewal period.

 
*   Valid values when **PeriodUnit** is set to **Month**: `1, 2, 3, 6, and 12`.
*   Valid values when **PeriodUnit** is set to **Year**: `1, 2, and 3`.
 
Default value: **1**.', example='1'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the renewal period. Valid values:
 
*   **Year**
*   **Month**
 
Default value: **Month**.', example='Month'),
  regionId?: string(name='RegionId', description='The ID of the region. The region ID can be up to 50 characters in length.
cn-hangzhou
 
>  You can call the [DescribeRegions](~~98041~~) operation to query the available regions.', example='cn-hangzhou'),
  renewalStatus?: string(name='RenewalStatus', description='The auto-renewal state of the cluster. Valid values:
 
*   **AutoRenewal:** The cluster are automatically renewed.
*   **Normal**: The cluster is manually renewed.
*   **NotRenewal:** The cluster is not renewed after expiration.
 
Default value: **AutoRenewal**.
 
>  If this parameter is set to **NotRenewal**, the system does not send a text message for the cluster expiration, but only sends a message three days before the cluster expires to remind you that the cluster is not renewed.', example='AutoRenewal'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyAutoRenewAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='4CE6DF97-AEA4-484F-906F-C407EE******'),
}

model ModifyAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAutoRenewAttributeResponseBody(name='body'),
}

async function modifyAutoRenewAttributeWithOptions(request: ModifyAutoRenewAttributeRequest, runtime: Util.RuntimeOptions): ModifyAutoRenewAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterIds)) {
    query['DBClusterIds'] = request.DBClusterIds;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.renewalStatus)) {
    query['RenewalStatus'] = request.renewalStatus;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAutoRenewAttribute',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyAutoRenewAttribute(request: ModifyAutoRenewAttributeRequest): ModifyAutoRenewAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAutoRenewAttributeWithOptions(request, runtime);
}

model ModifyBackupPolicyRequest {
  backupFrequency?: string(name='BackupFrequency', description='The backup frequency. Default value: Normal. Valid values:

*   **Normal**: standard backup. The system backs up data once a day.
*   **2/24H**: enhanced backup. The system backs up data every 2 hours.
*   **3/24H**: enhanced backup. The system backs up data every 3 hours.
*   **4/24H**: enhanced backup. The system backs up data every 4 hours.

>- If you enable enhanced backup, all backups are retained for 24 hours. For backup files that are created earlier than the previous 24 hours, the system permanently retains only the first backup that is created after 00:00 every day and deletes the rest.
>- If you enable enhanced backup, **PreferredBackupPeriod** is automatically set to all days in a week (from Monday to Sunday).
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed supports the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](~~72672~~).', example='Normal'),
  backupRetentionPolicyOnClusterDeletion?: string(name='BackupRetentionPolicyOnClusterDeletion', description='Specifies whether to retain backups when you delete a cluster. Valid values:

*   **ALL**: permanently retains all backups.
*   **LATEST**: permanently retains only the last backup.
*   **NONE**: does not retain backups.

> The default value is NONE.', example='NONE'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.', example='pc-bp13wz9586voc****'),
  dataLevel1BackupFrequency?: string(name='DataLevel1BackupFrequency', description='The frequency of level-1 backups. Default value: Normal. Valid values:

*   **Normal**: standard backup. The system backs up data once a day.
*   **2/24H**: enhanced backup. The system backs up data every 2 hours.
*   **3/24H**: enhanced backup. The system backs up data every 3 hours.
*   **4/24H**: enhanced backup. The system backs up data every 4 hours.

>- This parameter is invalid for PolarDB for Oracle clusters or PolarDB for PostgreSQL clusters.
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](~~72672~~).', example='Normal'),
  dataLevel1BackupPeriod?: string(name='DataLevel1BackupPeriod', description='The backup cycle of level-1 backups. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is invalid for PolarDB for Oracle clusters or PolarDB for PostgreSQL clusters.
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](~~72672~~).', example='Monday,Tuesday'),
  dataLevel1BackupRetentionPeriod?: string(name='DataLevel1BackupRetentionPeriod', description='The retention period of level-1 backups. Valid values: 3 to 14. Unit: days.', example='3'),
  dataLevel1BackupTime?: string(name='DataLevel1BackupTime', description='The time period during which automatic backup for level-1 backup is performed. The time period is in the `hh:mmZ-hh:mmZ` format and is displayed in UTC. The start time and end time are on the hour and have an interval of 1 hour. Example: `14:00Z-15:00Z`.
>- This parameter is invalid for PolarDB for Oracle clusters or PolarDB for PostgreSQL clusters.
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](~~72672~~).', example='15:00Z-16:00Z'),
  dataLevel2BackupAnotherRegionRegion?: string(name='DataLevel2BackupAnotherRegionRegion', description='The region where the cross-region level-2 backup is stored. For information about regions that support the cross-region backup feature, see [Overview](~~72672~~).', example='cn-hangzhou'),
  dataLevel2BackupAnotherRegionRetentionPeriod?: string(name='DataLevel2BackupAnotherRegionRetentionPeriod', description='The retention period of cross-region level-2 backups. Valid values:

*   **0**: The cross-region level-2 backup feature is disabled.
*   **30 to 7300**: Cross-region level-2 backups are retained for 30 to 7,300 days.
*   **1**: Cross-region level-2 backups are permanently retained.

> The default value is **0**. By default, the cross-region level-2 backup feature is disabled when you create a cluster.', example='30'),
  dataLevel2BackupPeriod?: string(name='DataLevel2BackupPeriod', description='The backup cycle of level-2 backups. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is invalid for PolarDB for Oracle clusters or PolarDB for PostgreSQL clusters.
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](~~72672~~).', example='Monday,Tuesday'),
  dataLevel2BackupRetentionPeriod?: string(name='DataLevel2BackupRetentionPeriod', description='The retention period of level-2 backups. Valid values:

*   **0**: The level-2 backup feature is disabled.
*   **30 to 7300**: Cross-region level-2 backups are retained for 30 to 7,300 days.
*   **1**: Cross-region level-2 backups are permanently retained.

> The default value is **0**. By default, the level-2 backup feature is disabled when you create a cluster.', example='0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod', description='The backup cycle. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed supports the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](~~72672~~).', example='Monday,Tuesday'),
  preferredBackupTime?: string(name='PreferredBackupTime', description='The time period during which automatic backup for level-1 backup is performed. The format is `hh:mmZ-hh:mmZ` format. The time is displayed in UTC. The start time and end time are on the hour and with an interval of one hour. Example: `14:00Z-15:00Z`.', example='15:00Z-16:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyBackupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C5A5DF0E-5968-4DC1-882E-AC2FE7******'),
}

model ModifyBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyBackupPolicyResponseBody(name='body'),
}

/**
  * > You can also modify the automatic backup policy of a PolarDB cluster in the console. For more information, see [Backup settings](~~280422~~).
  *
  * @param request ModifyBackupPolicyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyBackupPolicyResponse
 */
async function modifyBackupPolicyWithOptions(request: ModifyBackupPolicyRequest, runtime: Util.RuntimeOptions): ModifyBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupFrequency)) {
    query['BackupFrequency'] = request.backupFrequency;
  }
  if (!Util.isUnset(request.backupRetentionPolicyOnClusterDeletion)) {
    query['BackupRetentionPolicyOnClusterDeletion'] = request.backupRetentionPolicyOnClusterDeletion;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.dataLevel1BackupFrequency)) {
    query['DataLevel1BackupFrequency'] = request.dataLevel1BackupFrequency;
  }
  if (!Util.isUnset(request.dataLevel1BackupPeriod)) {
    query['DataLevel1BackupPeriod'] = request.dataLevel1BackupPeriod;
  }
  if (!Util.isUnset(request.dataLevel1BackupRetentionPeriod)) {
    query['DataLevel1BackupRetentionPeriod'] = request.dataLevel1BackupRetentionPeriod;
  }
  if (!Util.isUnset(request.dataLevel1BackupTime)) {
    query['DataLevel1BackupTime'] = request.dataLevel1BackupTime;
  }
  if (!Util.isUnset(request.dataLevel2BackupAnotherRegionRegion)) {
    query['DataLevel2BackupAnotherRegionRegion'] = request.dataLevel2BackupAnotherRegionRegion;
  }
  if (!Util.isUnset(request.dataLevel2BackupAnotherRegionRetentionPeriod)) {
    query['DataLevel2BackupAnotherRegionRetentionPeriod'] = request.dataLevel2BackupAnotherRegionRetentionPeriod;
  }
  if (!Util.isUnset(request.dataLevel2BackupPeriod)) {
    query['DataLevel2BackupPeriod'] = request.dataLevel2BackupPeriod;
  }
  if (!Util.isUnset(request.dataLevel2BackupRetentionPeriod)) {
    query['DataLevel2BackupRetentionPeriod'] = request.dataLevel2BackupRetentionPeriod;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.preferredBackupPeriod)) {
    query['PreferredBackupPeriod'] = request.preferredBackupPeriod;
  }
  if (!Util.isUnset(request.preferredBackupTime)) {
    query['PreferredBackupTime'] = request.preferredBackupTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBackupPolicy',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > You can also modify the automatic backup policy of a PolarDB cluster in the console. For more information, see [Backup settings](~~280422~~).
  *
  * @param request ModifyBackupPolicyRequest
  * @return ModifyBackupPolicyResponse
 */
async function modifyBackupPolicy(request: ModifyBackupPolicyRequest): ModifyBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBackupPolicyWithOptions(request, runtime);
}

model ModifyDBClusterRequest {
  DBClusterId?: string(name='DBClusterId', example='pc-*************'),
  dataSyncMode?: string(name='DataSyncMode', example='AsynSync'),
  faultSimulateMode?: string(name='FaultSimulateMode', example='0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  standbyHAMode?: string(name='StandbyHAMode', example='ON'),
  storageAutoScale?: string(name='StorageAutoScale'),
  storageUpperBound?: long(name='StorageUpperBound'),
}

model ModifyDBClusterResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-*************'),
  orderId?: string(name='OrderId', example='2148126708*****'),
  requestId?: string(name='RequestId', example='CD3FA5F3-FAF3-44CA-AFFF-BAF869******'),
}

model ModifyDBClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBClusterResponseBody(name='body'),
}

async function modifyDBClusterWithOptions(request: ModifyDBClusterRequest, runtime: Util.RuntimeOptions): ModifyDBClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.dataSyncMode)) {
    query['DataSyncMode'] = request.dataSyncMode;
  }
  if (!Util.isUnset(request.faultSimulateMode)) {
    query['FaultSimulateMode'] = request.faultSimulateMode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.standbyHAMode)) {
    query['StandbyHAMode'] = request.standbyHAMode;
  }
  if (!Util.isUnset(request.storageAutoScale)) {
    query['StorageAutoScale'] = request.storageAutoScale;
  }
  if (!Util.isUnset(request.storageUpperBound)) {
    query['StorageUpperBound'] = request.storageUpperBound;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBCluster(request: ModifyDBClusterRequest): ModifyDBClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterWithOptions(request, runtime);
}

model ModifyDBClusterAccessWhitelistRequest {
  DBClusterIPArrayAttribute?: string(name='DBClusterIPArrayAttribute', description='The attributes of the IP whitelist group. Set this parameter to **hidden** to hide the IP whitelist group in the console.

> *   The IP whitelist group that has appeared in the console cannot be hidden.
> *   This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='hidden'),
  DBClusterIPArrayName?: string(name='DBClusterIPArrayName', description='The name of the IP whitelist group. The group name must be 2 to 120 characters in length and consists of lowercase letters and digits. It must start with a letter, and end with a letter or a digit.

*   If the specified whitelist group name does not exist, the whitelist group is created.
*   If the specified whitelist group name exists, the whitelist group is modified.
*   If you do not specify this parameter, the default group is modified.

> 

*   You can create a maximum of 50 IP whitelist groups for a cluster.

*   This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='default'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*************'),
  modifyMode?: string(name='ModifyMode', description='The method used to modify the IP whitelist. Valid values:

*   **Cover** (default): overwrites the original IP whitelist.
*   **Append**: appends IP addresses to the original whitelist.
*   **Delete**: deletes IP addresses.

>  This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='Cover'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityGroupIds?: string(name='SecurityGroupIds', description='The ID of the security group. Separate multiple security groups with commas (,).

> *   You can add a maximum of three security groups to a cluster.
> *   This parameter can be specified only when the **WhiteListType** parameter is set to **SecurityGroup**.', example='sg-*********'),
  securityIps?: string(name='SecurityIps', description='The IP addresses or Classless Inter-Domain Routing (CIDR) blocks in the IP whitelist group. You can add 1,000 IP addresses or CIDR blocks to all the IP whitelist groups. Separate multiple IP addresses with commas (,). The following two formats are supported:

*   IP addresses. Example: 10.23.12.24.
*   CIDR blocks. Example: 10.23.12.24/24. 24 indicates the length of the prefix of the CIDR block. The length is the range of 1 to 32.

>  This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='10.23.12.24'),
  whiteListType?: string(name='WhiteListType', description='The type of the whitelist. Valid values:

*   **IP**: IP whitelist group.
*   **SecurityGroup**: security group.

Default value: **IP**.', example='IP'),
}

model ModifyDBClusterAccessWhitelistResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model ModifyDBClusterAccessWhitelistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBClusterAccessWhitelistResponseBody(name='body'),
}

async function modifyDBClusterAccessWhitelistWithOptions(request: ModifyDBClusterAccessWhitelistRequest, runtime: Util.RuntimeOptions): ModifyDBClusterAccessWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterIPArrayAttribute)) {
    query['DBClusterIPArrayAttribute'] = request.DBClusterIPArrayAttribute;
  }
  if (!Util.isUnset(request.DBClusterIPArrayName)) {
    query['DBClusterIPArrayName'] = request.DBClusterIPArrayName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['ModifyMode'] = request.modifyMode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityGroupIds)) {
    query['SecurityGroupIds'] = request.securityGroupIds;
  }
  if (!Util.isUnset(request.securityIps)) {
    query['SecurityIps'] = request.securityIps;
  }
  if (!Util.isUnset(request.whiteListType)) {
    query['WhiteListType'] = request.whiteListType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterAccessWhitelist',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBClusterAccessWhitelist(request: ModifyDBClusterAccessWhitelistRequest): ModifyDBClusterAccessWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterAccessWhitelistWithOptions(request, runtime);
}

model ModifyDBClusterAndNodesParametersRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-****************'),
  DBNodeIds?: string(name='DBNodeIds', description='The node ID. You can set this parameter to modify the parameters of a specified node or of the cluster. Separate multiple node IDs with commas (,).

> If you do not specify this parameter, only the cluster parameters are modified.', example='pi-****************,pi-**********,'),
  fromTimeService?: boolean(name='FromTimeService', description='Specifies an immediate or scheduled task to modify parameters and restart the cluster. Default value: false. Valid values:

*   **false**: runs the kernel upgrade task in a scheduled manner.
*   **true**: immediately runs the kernel upgrade task.', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template that is used for the instance.', example='pcpg-**************'),
  parameters?: string(name='Parameters', description='The JSON string for the parameter and its value.', example='{"wait_timeout":"86","innodb_old_blocks_time":"10"}'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to run the task. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The value of this parameter must be at least 30 minutes later than the value of the PlannedStartTime parameter.

*   By default, if you specify the `PlannedStartTime` parameter but do not specify the PlannedEndTime parameter, the latest start time of the task is set to a value that is calculated by using the following formula: `Value of the PlannedEndTime parameter + 30 minutes`. For example, if you set the `PlannedStartTime` parameter to `2021-01-14T09:00:00Z` and you do not specify the PlannedEndTime parameter, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest time to upgrade the specifications within the scheduled time period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in the time range from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.

*   If this parameter is empty, the upgrade task is immediately performed.', example='2021-01-14T09:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterAndNodesParametersResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model ModifyDBClusterAndNodesParametersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBClusterAndNodesParametersResponseBody(name='body'),
}

async function modifyDBClusterAndNodesParametersWithOptions(request: ModifyDBClusterAndNodesParametersRequest, runtime: Util.RuntimeOptions): ModifyDBClusterAndNodesParametersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeIds)) {
    query['DBNodeIds'] = request.DBNodeIds;
  }
  if (!Util.isUnset(request.fromTimeService)) {
    query['FromTimeService'] = request.fromTimeService;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupId)) {
    query['ParameterGroupId'] = request.parameterGroupId;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterAndNodesParameters',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBClusterAndNodesParameters(request: ModifyDBClusterAndNodesParametersRequest): ModifyDBClusterAndNodesParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterAndNodesParametersWithOptions(request, runtime);
}

model ModifyDBClusterAuditLogCollectorRequest {
  collectorStatus?: string(name='CollectorStatus', description='Specifies whether to enable or disable SQL collector. Valid values:

*   Enable
*   Disable', example='Enable'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-***************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterAuditLogCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='22C0ACF0-DD29-4B67-9190-B7A48C******'),
}

model ModifyDBClusterAuditLogCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBClusterAuditLogCollectorResponseBody(name='body'),
}

async function modifyDBClusterAuditLogCollectorWithOptions(request: ModifyDBClusterAuditLogCollectorRequest, runtime: Util.RuntimeOptions): ModifyDBClusterAuditLogCollectorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.collectorStatus)) {
    query['CollectorStatus'] = request.collectorStatus;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterAuditLogCollector',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBClusterAuditLogCollector(request: ModifyDBClusterAuditLogCollectorRequest): ModifyDBClusterAuditLogCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterAuditLogCollectorWithOptions(request, runtime);
}

model ModifyDBClusterDeletionRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](~~98094~~) operation to.obtain the cluster ID.', example='pc-bp1313h70cd5m****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  protection?: boolean(name='Protection', description='Specifies whether to enable the cluster lock feature. Default value: false. Valid values:

*   **true**: enables the cluster lock feature. If you enable the cluster lock feature, you cannot directly release the cluster. You must disable the cluster lock feature before you can release the cluster.
*   **false**: disables the cluster lock feature.', example='true'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterDeletionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='24C80BD8-C710-4138-893A-D2AFED4FC13D'),
}

model ModifyDBClusterDeletionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBClusterDeletionResponseBody(name='body'),
}

async function modifyDBClusterDeletionWithOptions(request: ModifyDBClusterDeletionRequest, runtime: Util.RuntimeOptions): ModifyDBClusterDeletionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.protection)) {
    query['Protection'] = request.protection;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterDeletion',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBClusterDeletion(request: ModifyDBClusterDeletionRequest): ModifyDBClusterDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterDeletionWithOptions(request, runtime);
}

model ModifyDBClusterDescriptionRequest {
  DBClusterDescription?: string(name='DBClusterDescription', description='The name of the cluster. The name must meet the following requirements:

*   The name cannot start with `http://` or `https://`.
*   The name must be 2 to 256 characters in length.', example='ClusterDescriptionTest'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the PolarDB cluster.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model ModifyDBClusterDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBClusterDescriptionResponseBody(name='body'),
}

async function modifyDBClusterDescriptionWithOptions(request: ModifyDBClusterDescriptionRequest, runtime: Util.RuntimeOptions): ModifyDBClusterDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterDescription)) {
    query['DBClusterDescription'] = request.DBClusterDescription;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterDescription',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBClusterDescription(request: ModifyDBClusterDescriptionRequest): ModifyDBClusterDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterDescriptionWithOptions(request, runtime);
}

model ModifyDBClusterEndpointRequest {
  autoAddNewNodes?: string(name='AutoAddNewNodes', description='Specifies whether to automatically associate newly added nodes with the cluster endpoint. Default value: Disable. Valid values:

*   **Enable**
*   **Disable**', example='Enable'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-*************'),
  DBEndpointDescription?: string(name='DBEndpointDescription', description='The name of the custom cluster endpoint.', example='test'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.', example='pe-**************'),
  endpointConfig?: string(name='EndpointConfig', description='The advanced configurations of the cluster endpoint, which are in the JSON format. You can specify the configurations of the following attributes: consistency level, transaction splitting, connection pool, and primary node accepts read requests.

*   Specifies the load balancing policy in the format of `{\\"LoadBalancePolicy\\":\\"Selected value\\"}`. Default value: 0. Valid values:

    *   **0**: connections-based load balancing
    *   **1**: active requests-based load balancing

*   Specifies whether to enable the primary node accepts read requests feature in the format of `{\\"MasterAcceptReads\\":\\"Selected value\\"}`. Default value: on. Valid values:

    *   **on**
    *   **off**

*   Specifies whether to enable the transaction splitting feature in the format of `{\\"DistributedTransaction\\":\\"Selected value\\"}`. Default value: on. Valid values:

    *   **on**
    *   **off**

*   Specifies the consistency level in the format of `{\\"ConsistLevel\\":\\"Selected value\\"}`. Default value: 1. Valid values:

    *   **0**: eventual consistency (weak)
    *   **1**: session consistency (medium)
    *   **2**: global consistency (strong)

*   Specifies the connection pool in the format of `{\\"ConnectionPersist\\":\\"Selected value\\"}`. Default value: off. Valid values:

    *   **off**: disables the connection pool.
    *   **Session**: enables the session-level connection pool.
    *   **Transaction**: enables the transaction-level connection pool.

*   Specifies whether to enable the parallel query feature in the format of `{\\"MaxParallelDegree\\":\\"Selected value\\"}`. Default value: off. Valid values:

    *   **on**
    *   **off**

*   Specifies whether to enable the automatic request distribution between row store and column store nodes feature in the format of `{\\"EnableHtapImci\\":\\"Selected value\\"}`. Default value: off. Valid values:

    *   **on**
    *   **off**

*   Specifies whether to enable the overload protection feature in the format of `{\\"EnableOverloadThrottle\\":\\"Selected value\\"}`. Default value: off. Valid values:

    *   **on**
    *   **off**

> 

*   You can specify the transaction splitting, primary node accepts read requests, connection pool, and overload protection features for a PolarDB for MySQL cluster only if ReadWriteMode is set to ReadWrite for the cluster endpoint.

*   If the read /write mode of a PolarDB for MySQL cluster is set to **Read-only**, the **Connection-based SLB** and **Active Request-based SLB** SLB policies are supported. The **Read-write (Automatic read /write splitting) **mode of the cluster supports** Active Request-based SLB** policy.
*   If ReadWriteMode is set to **ReadWrite** for the cluster endpoint of a PolarDB for MySQL cluster or if ReadWriteMode is set to **ReadOnly** and the load balancing policy is set to **active requests-based load balancing**, the automatic request distribution between row store and column store nodes feature is supported.
*   Only PolarDB for MySQL supports global consistency.
*   If the **ReadWriteMode** parameter is set to **ReadOnly**, the consistency level must be **0**.
*   You can specify the consistency level, transaction splitting, connection pool, and primary node accepts read requests features at a time, such as `{\\"ConsistLevel\\":\\"1\\",\\"DistributedTransaction\\":\\"on\\",\\"ConnectionPersist\\":\\"Session\\",\\"MasterAcceptReads\\":\\"on\\"}`.
*   The transaction splitting settings are restricted by the consistency level settings. For example, if you set the consistency level to **0**, transaction splitting cannot be enabled. If you set the consistency level to **1** or **2**, transaction splitting can be enabled.', example='{"ConsistLevel":"1","DistributedTransaction":"on","MasterAcceptReads":"off","ConnectionPersist": "on"}'),
  nodes?: string(name='Nodes', description='The reader nodes to be associated with the endpoint. If you need to specify multiple reader nodes, separate the reader nodes with commas (,). If you do not specify this parameter, the predefined nodes are used by default.

> 

*   You must specify the node ID for each PolarDB for MySQL cluster.

*   You must specify the role name of each node for each PolarDB for PostgreSQL or PolarDB for Oracle cluster. Example: `Writer,Reader1,Reader2`.

*   If you set **ReadWriteMode** to **ReadOnly**, only one node can be associated with the cluster endpoint. If the only node becomes faulty, the cluster endpoint may be unavailable for up to an hour. We recommend that you do not associate only one node with the cluster endpoint in production environments. We recommend that you associate at least two nodes with the cluster endpoint to improve service availability.

*   If you set **ReadWriteMode** to **ReadWrite**, you must associate at least two nodes with the cluster endpoint.

    *   No limits are imposed on the two nodes that you select for each PolarDB for MySQL cluster. If the two nodes are read-only nodes, write requests are forwarded to the primary node.
    *   The following limit applies to PolarDB for PostgreSQL and PolarDB for Oracle clusters: One of the selected nodes must be the primary node.', example='pi-**************,pi-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  readWriteMode?: string(name='ReadWriteMode', description='The read/write mode. Valid values:

*   **ReadWrite**: The cluster endpoint handles read and write requests. Automatic read/write splitting is enabled.
*   **ReadOnly**: The cluster endpoint handles read-only requests.', example='ReadWrite'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterEndpointResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CD3FA5F3-FAF3-44CA-AFFF-BAF869******'),
}

model ModifyDBClusterEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBClusterEndpointResponseBody(name='body'),
}

async function modifyDBClusterEndpointWithOptions(request: ModifyDBClusterEndpointRequest, runtime: Util.RuntimeOptions): ModifyDBClusterEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoAddNewNodes)) {
    query['AutoAddNewNodes'] = request.autoAddNewNodes;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointDescription)) {
    query['DBEndpointDescription'] = request.DBEndpointDescription;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.endpointConfig)) {
    query['EndpointConfig'] = request.endpointConfig;
  }
  if (!Util.isUnset(request.nodes)) {
    query['Nodes'] = request.nodes;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.readWriteMode)) {
    query['ReadWriteMode'] = request.readWriteMode;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterEndpoint',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBClusterEndpoint(request: ModifyDBClusterEndpointRequest): ModifyDBClusterEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterEndpointWithOptions(request, runtime);
}

model ModifyDBClusterMaintainTimeRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-***************'),
  maintainTime?: string(name='MaintainTime', description='The maintenance window of the cluster. Specify the maintenance window in the `HH:mmZ-HH:mmZ` format. For example, the value `16:00Z-17:00Z` indicates that the cluster can be maintained from 00:00 to 01:00 (UTC+8).
 
>  The maintenance window must start on the hour and last for an hour.', example='02:00Z-03:00Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterMaintainTimeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='70656639-1416-479F-AF13-D08197******'),
}

model ModifyDBClusterMaintainTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBClusterMaintainTimeResponseBody(name='body'),
}

/**
  * >  We recommend that you set the routine maintenance window to off-peak hours. Alibaba Cloud maintains your cluster within the specified maintenance window to minimize the negative impacts on your business.
  *
  * @param request ModifyDBClusterMaintainTimeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyDBClusterMaintainTimeResponse
 */
async function modifyDBClusterMaintainTimeWithOptions(request: ModifyDBClusterMaintainTimeRequest, runtime: Util.RuntimeOptions): ModifyDBClusterMaintainTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.maintainTime)) {
    query['MaintainTime'] = request.maintainTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterMaintainTime',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  We recommend that you set the routine maintenance window to off-peak hours. Alibaba Cloud maintains your cluster within the specified maintenance window to minimize the negative impacts on your business.
  *
  * @param request ModifyDBClusterMaintainTimeRequest
  * @return ModifyDBClusterMaintainTimeResponse
 */
async function modifyDBClusterMaintainTime(request: ModifyDBClusterMaintainTimeRequest): ModifyDBClusterMaintainTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterMaintainTimeWithOptions(request, runtime);
}

model ModifyDBClusterMigrationRequest {
  connectionStrings?: string(name='ConnectionStrings', description='The endpoints to be switched. The endpoints are in the JSON format.

> This parameter is valid when the SwapConnectionString parameter is set to true.', example='{"rm-2ze73el581cs*****.mysql.pre.rds.aliyuncs.com":"pc-2ze8200s298e*****.mysql.polardb.pre.rds.aliyuncs.com","rm-2ze73el581cs86*****.mysql.pre.rds.aliyuncs.com":"test-p*****.mysql.polardb.pre.rds.aliyuncs.com"}'),
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-**************'),
  newMasterInstanceId?: string(name='NewMasterInstanceId', description='The ID of the new instance or new cluster. Valid values:

*   To perform a data migration, enter the ID of the PolarDB cluster.
*   To perform a migration rollback, enter the ID of the ApsaraDB for RDS instance.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  sourceRDSDBInstanceId?: string(name='SourceRDSDBInstanceId', description='The ID of the source ApsaraDB RDS instance.', example='rm-************'),
  swapConnectionString?: string(name='SwapConnectionString', description='Specifies whether to switch the endpoints. Valid values:

*   **true**: switches the endpoints. If you select this option, you do not need the change the endpoint in your applications.
*   **false**: does not switch the endpoints. If you select this option, you must specify the endpoint of the PolarDB cluster in your applications.

Default value: **false**.', example='false'),
}

model ModifyDBClusterMigrationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='A1B303A5-653F-4AEE-A598-023FF9******'),
}

model ModifyDBClusterMigrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBClusterMigrationResponseBody(name='body'),
}

/**
  * *   You can call this operation to switch the task that migrates data from ApsaraDB for RDS to PolarDB.
  * *   You can call this operation to roll back the task that migrates data from ApsaraDB for RDS to PolarDB.
  * > Before you call this operation, ensure that a one-click upgrade task has been created for the cluster. You can call the [CreateDBCluster](~~98169~~) operation to create an upgrade task. Set the **CreationOption** parameter to **MigrationFromRDS**. For more information, see [Create a PolarDB for MySQL cluster by using the Migration from RDS method](~~121582~~).
  *
  * @param request ModifyDBClusterMigrationRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyDBClusterMigrationResponse
 */
async function modifyDBClusterMigrationWithOptions(request: ModifyDBClusterMigrationRequest, runtime: Util.RuntimeOptions): ModifyDBClusterMigrationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionStrings)) {
    query['ConnectionStrings'] = request.connectionStrings;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.newMasterInstanceId)) {
    query['NewMasterInstanceId'] = request.newMasterInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.sourceRDSDBInstanceId)) {
    query['SourceRDSDBInstanceId'] = request.sourceRDSDBInstanceId;
  }
  if (!Util.isUnset(request.swapConnectionString)) {
    query['SwapConnectionString'] = request.swapConnectionString;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterMigration',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   You can call this operation to switch the task that migrates data from ApsaraDB for RDS to PolarDB.
  * *   You can call this operation to roll back the task that migrates data from ApsaraDB for RDS to PolarDB.
  * > Before you call this operation, ensure that a one-click upgrade task has been created for the cluster. You can call the [CreateDBCluster](~~98169~~) operation to create an upgrade task. Set the **CreationOption** parameter to **MigrationFromRDS**. For more information, see [Create a PolarDB for MySQL cluster by using the Migration from RDS method](~~121582~~).
  *
  * @param request ModifyDBClusterMigrationRequest
  * @return ModifyDBClusterMigrationResponse
 */
async function modifyDBClusterMigration(request: ModifyDBClusterMigrationRequest): ModifyDBClusterMigrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterMigrationWithOptions(request, runtime);
}

model ModifyDBClusterMonitorRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: string(name='Period', description='The interval at which monitoring data is collected. Valid values: **5** and **60**. Unit: seconds.', example='5'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterMonitorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='75B92353-73B4-447B-8477-C85F3C******'),
}

model ModifyDBClusterMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBClusterMonitorResponseBody(name='body'),
}

/**
  * *   When the monitoring data is collected every 5 seconds:
  *     *   If the query time range is less than or equal to 1 hour, the data is displayed at intervals of 5 seconds.
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  * *   When the monitoring data is collected every 60 seconds:
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  *
  * @param request ModifyDBClusterMonitorRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyDBClusterMonitorResponse
 */
async function modifyDBClusterMonitorWithOptions(request: ModifyDBClusterMonitorRequest, runtime: Util.RuntimeOptions): ModifyDBClusterMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterMonitor',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   When the monitoring data is collected every 5 seconds:
  *     *   If the query time range is less than or equal to 1 hour, the data is displayed at intervals of 5 seconds.
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  * *   When the monitoring data is collected every 60 seconds:
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  *
  * @param request ModifyDBClusterMonitorRequest
  * @return ModifyDBClusterMonitorResponse
 */
async function modifyDBClusterMonitor(request: ModifyDBClusterMonitorRequest): ModifyDBClusterMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterMonitorWithOptions(request, runtime);
}

model ModifyDBClusterParametersRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.', example='pc-**************'),
  fromTimeService?: boolean(name='FromTimeService', description='Specifies an immediate or scheduled task to modify parameters and restart the cluster. Valid values:

*   false: scheduled task
*   true: immediate task', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template.

> 

*   You can call the [DescribeParameterGroups](~~207178~~) operation to query the parameter template ID.

*   You must specify this parameter or the `Parameters` parameter.
*   This parameter is valid only for a PolarDB for MySQL cluster.', example='pcpg-**************'),
  parameters?: string(name='Parameters', description='The JSON string that consists of parameters and values. The parameter values are strings, for example, `{"wait_timeout":"86","innodb_old_blocks_time":"10"}`.

> 

*   You can call the [DescribeDBClusterParameters](~~98122~~) operation to query the parameters of the PolarDB cluster.

*   This parameter is required for a PolarDB for Oracle or PolarDB for PostgreSQL cluster.
*   For PolarDB for MySQL clusters, you must specify this parameter or the `ParameterGroupId` parameter.', example='{"wait_timeout":"86","innodb_old_blocks_time":"10"}'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to run the task. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The value of this parameter must be at least 30 minutes later than the value of the PlannedStartTime parameter.

*   By default, if you specify the `PlannedStartTime` parameter but do not specify the PlannedEndTime parameter, the latest start time of the task is set to a value that is calculated by using the following formula: `Value of the PlannedEndTime parameter + 30 minutes`. For example, if you set the `PlannedStartTime` parameter to `2021-01-14T09:00:00Z` and you do not specify the PlannedEndTime parameter, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2022-04-28T14:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest time to upgrade the specifications within the scheduled time period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in the time range from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.

*   If this parameter is empty, the upgrade task is immediately performed.', example='2022-04-28T14:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterParametersResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C5D526E5-91B5-48B8-B980-FE07FF******'),
}

model ModifyDBClusterParametersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBClusterParametersResponseBody(name='body'),
}

/**
  * PolarDB supports the parameter template feature to centrally manage clusters. You can configure a number of parameters at a time by using a parameter template and apply the template to a PolarDB cluster. For more information, see [Use a parameter template](~~207009~~).
  * **
  * **Only PolarDB for MySQL clusters support parameter templates.
  *
  * @param request ModifyDBClusterParametersRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyDBClusterParametersResponse
 */
async function modifyDBClusterParametersWithOptions(request: ModifyDBClusterParametersRequest, runtime: Util.RuntimeOptions): ModifyDBClusterParametersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.fromTimeService)) {
    query['FromTimeService'] = request.fromTimeService;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupId)) {
    query['ParameterGroupId'] = request.parameterGroupId;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterParameters',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * PolarDB supports the parameter template feature to centrally manage clusters. You can configure a number of parameters at a time by using a parameter template and apply the template to a PolarDB cluster. For more information, see [Use a parameter template](~~207009~~).
  * **
  * **Only PolarDB for MySQL clusters support parameter templates.
  *
  * @param request ModifyDBClusterParametersRequest
  * @return ModifyDBClusterParametersResponse
 */
async function modifyDBClusterParameters(request: ModifyDBClusterParametersRequest): ModifyDBClusterParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterParametersWithOptions(request, runtime);
}

model ModifyDBClusterPrimaryZoneRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](~~173433~~) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.', example='pc-**************'),
  fromTimeService?: boolean(name='FromTimeService', description='Specifies an immediate or scheduled task to switch the primary zone. Valid values:

*   false: scheduled task
*   true: immediate task', example='false'),
  isSwitchOverForDisaster?: string(name='IsSwitchOverForDisaster', description='Specifies whether to switch back over to the original primary zone. Valid values: true: Switch over back to the original primary zone. false: Do not switch back over to the original primary zone. If this parameter is set to false, the primary zone of the cluster is changed to the specified destination zone.', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to switch the primary zone within the scheduled time period. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The latest start time must be at least 30 minutes later than the earliest start time.

*   If you specify the `PlannedStartTime` parameter but do not specify the PlannedEndTime parameter, the latest start time of the task is set to a value that is calculated by `the value of the PlannedEndTime parameter + 30 minutes` by default. For example, if you set the `PlannedStartTime` parameter to `2021-01-14T09:00:00Z` and you do not specify the PlannedEndTime parameter, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time to switch the primary zone within the scheduled time period. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in time that ranges from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.

*   If you left this parameter empty, the primary zone is immediately switched.', example='2021-01-14T09:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VPCId?: string(name='VPCId', description='The virtual private cloud (VPC) ID of the destination primary zone.', example='vpc-**********'),
  vSwitchId?: string(name='VSwitchId', description='The ID of vSwitch in the destination primary zone.

> 

*   For a PolarDB for Oracle or PolarDB for PostgreSQL cluster, this parameter is required.

*   For a PolarDB for MySQL cluster: - This parameter is optional if no vSwitches have been created in the destination zone. The default vSwitch is used. - This parameter is required if a vSwitch has been created in the destination zone.', example='vsw-**************'),
  zoneId?: string(name='ZoneId', description='The ID of the destination primary zone.

> You can call the [DescribeRegions](~~98041~~) operation to query available zones.', example='cn-hangzhou-g'),
}

model ModifyDBClusterPrimaryZoneResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='ED12C6FF-3261-4571-AB57-3570F6******'),
}

model ModifyDBClusterPrimaryZoneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBClusterPrimaryZoneResponseBody(name='body'),
}

async function modifyDBClusterPrimaryZoneWithOptions(request: ModifyDBClusterPrimaryZoneRequest, runtime: Util.RuntimeOptions): ModifyDBClusterPrimaryZoneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.fromTimeService)) {
    query['FromTimeService'] = request.fromTimeService;
  }
  if (!Util.isUnset(request.isSwitchOverForDisaster)) {
    query['IsSwitchOverForDisaster'] = request.isSwitchOverForDisaster;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterPrimaryZone',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBClusterPrimaryZone(request: ModifyDBClusterPrimaryZoneRequest): ModifyDBClusterPrimaryZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterPrimaryZoneWithOptions(request, runtime);
}

model ModifyDBClusterResourceGroupRequest {
  DBClusterId?: string(name='DBClusterId', example='pc-*************'),
  newResourceGroupId?: string(name='NewResourceGroupId', example='rg-**********'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-**********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterResourceGroupResponseBody = {
  requestId?: string(name='RequestId', example='70656639-1416-479F-AF13-D08197******'),
}

model ModifyDBClusterResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBClusterResourceGroupResponseBody(name='body'),
}

async function modifyDBClusterResourceGroupWithOptions(request: ModifyDBClusterResourceGroupRequest, runtime: Util.RuntimeOptions): ModifyDBClusterResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterResourceGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBClusterResourceGroup(request: ModifyDBClusterResourceGroupRequest): ModifyDBClusterResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterResourceGroupWithOptions(request, runtime);
}

model ModifyDBClusterSSLRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-************'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.

> 

*   This parameter is required for a PolarDB for MySQL cluster.

*   This parameter is not required for a PolarDB for Oracle or PolarDB for PostgreSQL cluster. By default, SSL encryption is enabled for all endpoints.
*   You can call the [DescribeDBClusterSSL](~~153414~~) operation to view the details of the endpoint.', example='pe-******************'),
  netType?: string(name='NetType', description='The network type supported by the endpoint that is specified by **DBEndpointId**. Valid values:

*   **Public**
*   **Private**
*   **Inner**

> 

*   This parameter is required for a PolarDB for MySQL cluster.

*   This parameter is not required for a PolarDB for Oracle or PolarDB for PostgreSQL cluster. By default, SSL encryption is enabled for all endpoints.', example='Public'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  SSLAutoRotate?: string(name='SSLAutoRotate', description='Specifies whether automatic rotation of SSL certificates is enabled.

*   **Enable**: The feature is enabled.
*   **Disable**: The feature is disabled.', example='Enable'),
  SSLEnabled?: string(name='SSLEnabled', description='The SSL encryption status. Valid values:

*   **Disable**: SSL encryption is disabled.
*   **Enable**: SSL encryption is enabled.
*   **Update**: The SSL certificate is updated.

> After you enable SSL encryption or update the SSL certificate, you must download and configure the certificate. For more information, see [Configure SSL encryption](~~153182~~).', example='Enable'),
}

model ModifyDBClusterSSLResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='A94B1755-6D8B-4E27-BF3C-8562BC******'),
}

model ModifyDBClusterSSLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBClusterSSLResponseBody(name='body'),
}

async function modifyDBClusterSSLWithOptions(request: ModifyDBClusterSSLRequest, runtime: Util.RuntimeOptions): ModifyDBClusterSSLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.SSLAutoRotate)) {
    query['SSLAutoRotate'] = request.SSLAutoRotate;
  }
  if (!Util.isUnset(request.SSLEnabled)) {
    query['SSLEnabled'] = request.SSLEnabled;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterSSL',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBClusterSSL(request: ModifyDBClusterSSLRequest): ModifyDBClusterSSLResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterSSLWithOptions(request, runtime);
}

model ModifyDBClusterServerlessConfRequest {
  allowShutDown?: string(name='AllowShutDown', description='Specifies whether to enable No-activity Suspension. Default value: false. Valid values:

*   **true**
*   **false**', example='true'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the serverless cluster.', example='pc-bp10gr51qasnl****'),
  fromTimeService?: boolean(name='FromTimeService'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime'),
  plannedStartTime?: string(name='PlannedStartTime'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scaleApRoNumMax?: string(name='ScaleApRoNumMax'),
  scaleApRoNumMin?: string(name='ScaleApRoNumMin'),
  scaleMax?: string(name='ScaleMax', description='The maximum number of PCUs per node for scaling. Valid values: 1 PCU to 32 PCUs.', example='10'),
  scaleMin?: string(name='ScaleMin', description='The minimum number of PCUs per node for scaling. Valid values: 1 PCU to 31 PCUs.', example='1'),
  scaleRoNumMax?: string(name='ScaleRoNumMax', description='The maximum number of read-only nodes for scaling. Valid values: 0 to 15.', example='2'),
  scaleRoNumMin?: string(name='ScaleRoNumMin', description='The minimum number of read-only nodes for scaling. Valid values: 0 to 15.', example='1'),
  secondsUntilAutoPause?: string(name='SecondsUntilAutoPause', description='The detection period for No-activity Suspension. Valid values: 5 to 1440. Unit: minutes. The detection duration must be a multiple of 5 minutes.', example='10'),
}

model ModifyDBClusterServerlessConfResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the serverless cluster.', example='pc-bp10gr51qasnl****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5E71541A-6007-4DCC-A38A-F872C31FEB45'),
}

model ModifyDBClusterServerlessConfResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBClusterServerlessConfResponseBody(name='body'),
}

async function modifyDBClusterServerlessConfWithOptions(request: ModifyDBClusterServerlessConfRequest, runtime: Util.RuntimeOptions): ModifyDBClusterServerlessConfResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allowShutDown)) {
    query['AllowShutDown'] = request.allowShutDown;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.fromTimeService)) {
    query['FromTimeService'] = request.fromTimeService;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scaleApRoNumMax)) {
    query['ScaleApRoNumMax'] = request.scaleApRoNumMax;
  }
  if (!Util.isUnset(request.scaleApRoNumMin)) {
    query['ScaleApRoNumMin'] = request.scaleApRoNumMin;
  }
  if (!Util.isUnset(request.scaleMax)) {
    query['ScaleMax'] = request.scaleMax;
  }
  if (!Util.isUnset(request.scaleMin)) {
    query['ScaleMin'] = request.scaleMin;
  }
  if (!Util.isUnset(request.scaleRoNumMax)) {
    query['ScaleRoNumMax'] = request.scaleRoNumMax;
  }
  if (!Util.isUnset(request.scaleRoNumMin)) {
    query['ScaleRoNumMin'] = request.scaleRoNumMin;
  }
  if (!Util.isUnset(request.secondsUntilAutoPause)) {
    query['SecondsUntilAutoPause'] = request.secondsUntilAutoPause;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterServerlessConf',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBClusterServerlessConf(request: ModifyDBClusterServerlessConfRequest): ModifyDBClusterServerlessConfResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterServerlessConfWithOptions(request, runtime);
}

model ModifyDBClusterStorageSpaceRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest time to upgrade the specifications within the scheduled time period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.
>- The value of this parameter must be at least 30 minutes later than PlannedStartTime.
>- By default, if you specify `PlannedStartTime` but do not specify PlannedEndTime, the latest start time of the task is set to `PlannedEndTime + 30 minutes`. For example, if you set `PlannedStartTime` to `2021-01-14T09:00:00Z` and you do not specify PlannedEndTime, the latest start time of the task is `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest time to upgrade the specifications within the scheduled time period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.
>- This parameter takes effect only when `ModifyType` is set to `Upgrade`.
>- The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in the time that ranges from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.
>- If this parameter is left empty, the upgrade task is immediately performed.', example='2021-01-14T09:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  storageSpace?: long(name='StorageSpace', description='The new storage capacity. Unit: GB.

> Valid values for PolarDB for MySQL Standard Edition are 20 to 32000.', example='50'),
  subCategory?: string(name='SubCategory', description='The category of the cluster. Default value: ON. Valid values:

*   **normal_exclusive**: dedicated
*   **normal_general**: genera-purpose', example='normal_general'),
}

model ModifyDBClusterStorageSpaceResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*************'),
  orderId?: string(name='OrderId', description='The order ID.', example='2035629******'),
  requestId?: string(name='RequestId', description='The request ID.', example='685F028C-4FCD-407D-A559-072D63******'),
}

model ModifyDBClusterStorageSpaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBClusterStorageSpaceResponseBody(name='body'),
}

async function modifyDBClusterStorageSpaceWithOptions(request: ModifyDBClusterStorageSpaceRequest, runtime: Util.RuntimeOptions): ModifyDBClusterStorageSpaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.storageSpace)) {
    query['StorageSpace'] = request.storageSpace;
  }
  if (!Util.isUnset(request.subCategory)) {
    query['SubCategory'] = request.subCategory;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterStorageSpace',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBClusterStorageSpace(request: ModifyDBClusterStorageSpaceRequest): ModifyDBClusterStorageSpaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterStorageSpaceWithOptions(request, runtime);
}

model ModifyDBClusterTDERequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-************'),
  encryptNewTables?: string(name='EncryptNewTables', description='Specifies whether to enable automatic encryption for new tables. Valid values:

*   **ON**
*   **OFF**', example='ON'),
  encryptionKey?: string(name='EncryptionKey', description='The ID of the custom key.', example='749c1df7-****-****-****-*********'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleArn?: string(name='RoleArn', description='The Alibaba Cloud Resource Name (ARN) of the RAM role. A RAM role is a virtual identity that you can create within your Alibaba Cloud account. For more information, see [RAM role overview](~~93689~~).', example='acs:ram::1406926*****:role/aliyunrdsinstanceencryptiondefaultrole'),
  TDEStatus?: string(name='TDEStatus', description='Modifies the TDE status. Set the value to **Enable**.', example='Enable'),
}

model ModifyDBClusterTDEResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5F859238-2A36-4A8D-BD0F-732112******'),
}

model ModifyDBClusterTDEResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBClusterTDEResponseBody(name='body'),
}

/**
  * > *   To perform this operation, you must activate KMS first. For more information, see [Purchase a dedicated KMS instance](~~153781~~).
  * > *   After TDE is enabled, you cannot disable TDE.
  *
  * @param request ModifyDBClusterTDERequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyDBClusterTDEResponse
 */
async function modifyDBClusterTDEWithOptions(request: ModifyDBClusterTDERequest, runtime: Util.RuntimeOptions): ModifyDBClusterTDEResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.encryptNewTables)) {
    query['EncryptNewTables'] = request.encryptNewTables;
  }
  if (!Util.isUnset(request.encryptionKey)) {
    query['EncryptionKey'] = request.encryptionKey;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.roleArn)) {
    query['RoleArn'] = request.roleArn;
  }
  if (!Util.isUnset(request.TDEStatus)) {
    query['TDEStatus'] = request.TDEStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterTDE',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > *   To perform this operation, you must activate KMS first. For more information, see [Purchase a dedicated KMS instance](~~153781~~).
  * > *   After TDE is enabled, you cannot disable TDE.
  *
  * @param request ModifyDBClusterTDERequest
  * @return ModifyDBClusterTDEResponse
 */
async function modifyDBClusterTDE(request: ModifyDBClusterTDERequest): ModifyDBClusterTDEResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterTDEWithOptions(request, runtime);
}

model ModifyDBDescriptionRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-***************'),
  DBDescription?: string(name='DBDescription', description='The description of the database. The description must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must be 2 to 256 characters in length.', example='DBDesc'),
  DBName?: string(name='DBName', description='The name of the database.', example='testDB'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5F295AAB-B599-4F0E-96D0-DBFAB3******'),
}

model ModifyDBDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBDescriptionResponseBody(name='body'),
}

async function modifyDBDescriptionWithOptions(request: ModifyDBDescriptionRequest, runtime: Util.RuntimeOptions): ModifyDBDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBDescription)) {
    query['DBDescription'] = request.DBDescription;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBDescription',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBDescription(request: ModifyDBDescriptionRequest): ModifyDBDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBDescriptionWithOptions(request, runtime);
}

model ModifyDBEndpointAddressRequest {
  connectionStringPrefix?: string(name='ConnectionStringPrefix', description='The prefix of the new endpoint. The prefix must meet the following requirements:

*   It can contain lowercase letters, digits, and hyphens (-).
*   It must start with a letter and end with a digit or a letter.
*   It must be 6 to 30 characters in length.', example='example'),
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.', example='pc-***************'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.

> You can call the [DescribeDBClusterEndpoints](~~98205~~) operation to query endpoint IDs.', example='pe-****************'),
  netType?: string(name='NetType', description='The network type of the endpoint. Valid values:

*   **Public**
*   **Private**', example='Public'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  port?: string(name='Port', description='The port number. Valid values: 3000 to 5999.

> This parameter is valid only for PolarDB for MySQL clusters. If you leave this parameter empty, the default port 3306 is used.', example='3306'),
  privateZoneAddressPrefix?: string(name='PrivateZoneAddressPrefix', description='The prefix of the private domain name. The prefix must meet the following requirements:

*   The prefix can contain lowercase letters, digits, and hyphens (-).
*   The prefix must start with a letter and end with a digit or a letter.
*   The prefix must be 6 to 30 characters in length.

>- You can bind each internal endpoint of PolarDB to a private domain name. The private domain name takes effect only in the specified virtual private clouds (VPCs) in the current region. Private domain names are managed by using PrivateZone. You can use the CNAME record of PrivateZone to map domain names to PolarDB. You are charged a small fee for this feature. For more information, see [Pricing](~~71338~~).
>- This parameter takes effect only if you set **NetType** to Private.', example='aliyundoc'),
  privateZoneName?: string(name='PrivateZoneName', description='The name of the private zone.

> This parameter takes effect only when **NetType** is set to Private.', example='aliyundoc.com'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBEndpointAddressResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model ModifyDBEndpointAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBEndpointAddressResponseBody(name='body'),
}

async function modifyDBEndpointAddressWithOptions(request: ModifyDBEndpointAddressRequest, runtime: Util.RuntimeOptions): ModifyDBEndpointAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionStringPrefix)) {
    query['ConnectionStringPrefix'] = request.connectionStringPrefix;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.privateZoneAddressPrefix)) {
    query['PrivateZoneAddressPrefix'] = request.privateZoneAddressPrefix;
  }
  if (!Util.isUnset(request.privateZoneName)) {
    query['PrivateZoneName'] = request.privateZoneName;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBEndpointAddress',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBEndpointAddress(request: ModifyDBEndpointAddressRequest): ModifyDBEndpointAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBEndpointAddressWithOptions(request, runtime);
}

model ModifyDBNodeClassRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-*************'),
  DBNodeTargetClass?: string(name='DBNodeTargetClass', description='The specifications of all nodes. For more information, see [Specifications of computing nodes](~~102542~~).', example='polar.mysql.x4.large'),
  DBNodeType?: string(name='DBNodeType'),
  modifyType?: string(name='ModifyType', description='The type of the configuration change. Valid values:

*   **Upgrade**
*   **Downgrade**', example='Upgrade'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to run the task. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> *   The value of this parameter must be at least 30 minutes later than the value of the PlannedStartTime parameter.
> *   If you specify the `PlannedStartTime` parameter but do not specify a value for the PlannedEndTime parameter, the latest start time of the task is set to a value that is calculated by `the value of the PlannedEndTime parameter + 30 minutes` by default. For example, if you set the `PlannedStartTime` parameter to `2021-01-14T09:00:00Z` and you do not specify the PlannedEndTime parameter, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest time to upgrade the specifications within the scheduled time period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> *   This parameter takes effect only when `ModifyType` is set to `Upgrade`.
> *   The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in the time range from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.
> *   If this parameter is empty, the upgrade task is immediately performed.', example='2021-01-14T09:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  subCategory?: string(name='SubCategory', description='The category of the cluster. Valid values:

*   **normal_exclusive**: dedicated
*   **normal_general**: genera-purpose', example='normal_general'),
}

model ModifyDBNodeClassResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the PolarDB cluster.', example='pc-*************'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2035629******'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='685F028C-4FCD-407D-A559-072D63******'),
}

model ModifyDBNodeClassResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBNodeClassResponseBody(name='body'),
}

async function modifyDBNodeClassWithOptions(request: ModifyDBNodeClassRequest, runtime: Util.RuntimeOptions): ModifyDBNodeClassResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeTargetClass)) {
    query['DBNodeTargetClass'] = request.DBNodeTargetClass;
  }
  if (!Util.isUnset(request.DBNodeType)) {
    query['DBNodeType'] = request.DBNodeType;
  }
  if (!Util.isUnset(request.modifyType)) {
    query['ModifyType'] = request.modifyType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.subCategory)) {
    query['SubCategory'] = request.subCategory;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBNodeClass',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBNodeClass(request: ModifyDBNodeClassRequest): ModifyDBNodeClassResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBNodeClassWithOptions(request, runtime);
}

model ModifyDBNodeHotReplicaModeRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.', example='pc-2vc327c2a14a3u858'),
  DBNodeId?: string(name='DBNodeId', description='The ID of the node in the cluster.', example='pi-2ze28275h9x5r4wt1'),
  hotReplicaMode?: string(name='HotReplicaMode', description='Specifies whether to enable the hot standby feature. Valid values:

*   **ON**
*   **OFF**', example='ON'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBNodeHotReplicaModeResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.', example='pc-2vc327c2a14a3u858'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2148126708*****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9F4DDFBF-205C-5A3E-8DC2-C60F3E3FDC38'),
}

model ModifyDBNodeHotReplicaModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBNodeHotReplicaModeResponseBody(name='body'),
}

async function modifyDBNodeHotReplicaModeWithOptions(request: ModifyDBNodeHotReplicaModeRequest, runtime: Util.RuntimeOptions): ModifyDBNodeHotReplicaModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeId)) {
    query['DBNodeId'] = request.DBNodeId;
  }
  if (!Util.isUnset(request.hotReplicaMode)) {
    query['HotReplicaMode'] = request.hotReplicaMode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBNodeHotReplicaMode',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBNodeHotReplicaMode(request: ModifyDBNodeHotReplicaModeRequest): ModifyDBNodeHotReplicaModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBNodeHotReplicaModeWithOptions(request, runtime);
}

model ModifyDBNodesClassRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*************'),
  DBNode?: [ 
    {
      DBNodeId?: string(name='DBNodeId', description='The ID of the node.

>  If you specify this parameter, DBNode.N.TargetClass is required. N is an integer that starts from 1. The maximum value of N is calculated by using the following formula:16 - The number of current nodes.', example='pi-*************'),
      targetClass?: string(name='TargetClass', description='The specifications of the node that you want to change. For more information, see [Specifications of compute nodes](~~102542~~).

>  If you specify this parameter, DBNode.N.DBNodeId is required. N is an integer that starts from 1. The maximum value of N is calculated by using the following formula:16 - The number of current nodes.', example='polar.mysql.x4.medium'),
    }
  ](name='DBNode', description='The details of the nodes.'),
  modifyType?: string(name='ModifyType', description='The type of the configuration change. Valid values:

*   **Upgrade**
*   **Downgrade**', example='Upgrade'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to upgrade the specifications within the scheduled time period. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> *   The value of this parameter must be at least 30 minutes later than the value of PlannedStartTime.
>*   By default, if you specify `PlannedStartTime` but do not specify PlannedEndTime, the latest start time of the task is set to a value that is calculated by using the following formula: `Value of PlannedEndTime + 30 minutes`. For example, if you set `PlannedStartTime` to `2021-01-14T09:00:00Z` and you do not specify PlannedEndTime, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time to upgrade the specifications within the scheduled time period. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> *   This parameter takes effect only when `ModifyType` is set to `Upgrade`.
>*   The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in the time range from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.
>*   If this parameter is empty, the upgrade task is immediately performed.', example='2021-01-14T09:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  subCategory?: string(name='SubCategory', description='The category of the cluster. Valid values:

*   **normal_exclusive**: dedicated
*   **normal_general**: genera-purpose', example='normal_general'),
}

model ModifyDBNodesClassResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*************'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2035629******'),
  requestId?: string(name='RequestId', description='The request ID.', example='685F028C-4FCD-407D-A559-072D63******'),
}

model ModifyDBNodesClassResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBNodesClassResponseBody(name='body'),
}

async function modifyDBNodesClassWithOptions(request: ModifyDBNodesClassRequest, runtime: Util.RuntimeOptions): ModifyDBNodesClassResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNode)) {
    query['DBNode'] = request.DBNode;
  }
  if (!Util.isUnset(request.modifyType)) {
    query['ModifyType'] = request.modifyType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.subCategory)) {
    query['SubCategory'] = request.subCategory;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBNodesClass',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBNodesClass(request: ModifyDBNodesClassRequest): ModifyDBNodesClassResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBNodesClassWithOptions(request, runtime);
}

model ModifyDBNodesParametersRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-**************'),
  DBNodeIds?: string(name='DBNodeIds', description='The ID of the node. You can specify multiple node IDs. Separate multiple node IDs with commas (,).', example='pi-****************， pi-****************'),
  fromTimeService?: boolean(name='FromTimeService', description='Specifies whether to immediately run the task to modify parameters and restart the cluster. Valid values: false: runs the task on schedule. true: runs the task immediately. Default value: false.', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template that is used for the cluster.', example='pcpg-**************'),
  parameters?: string(name='Parameters', description='The JSON string that specifies the parameter and its value.', example='{"wait_timeout":"86","innodb_old_blocks_time":"10"}'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to run the task. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.', example='2022-04-28T14:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time to run the task to upgrade the kernel version of the cluster. The task runs within a specified period of time. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.', example='2022-04-28T14:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBNodesParametersResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EBEAA83D-1734-42E3-85E3-E25F6E******'),
}

model ModifyDBNodesParametersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBNodesParametersResponseBody(name='body'),
}

async function modifyDBNodesParametersWithOptions(request: ModifyDBNodesParametersRequest, runtime: Util.RuntimeOptions): ModifyDBNodesParametersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeIds)) {
    query['DBNodeIds'] = request.DBNodeIds;
  }
  if (!Util.isUnset(request.fromTimeService)) {
    query['FromTimeService'] = request.fromTimeService;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupId)) {
    query['ParameterGroupId'] = request.parameterGroupId;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBNodesParameters',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBNodesParameters(request: ModifyDBNodesParametersRequest): ModifyDBNodesParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBNodesParametersWithOptions(request, runtime);
}

model ModifyGlobalDatabaseNetworkRequest {
  GDNDescription?: string(name='GDNDescription', description='The description of the GDN. The description must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must start with a letter.
*   It can contain letters, digits, underscores (\\_), and hyphens (-).
*   It must be 2 to 126 characters in length.', example='GDN-fortest'),
  GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gdn-bp1fttxsrmv*****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyGlobalDatabaseNetworkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C61892A4-0850-4516-9E26-44D96C1782DE'),
}

model ModifyGlobalDatabaseNetworkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyGlobalDatabaseNetworkResponseBody(name='body'),
}

async function modifyGlobalDatabaseNetworkWithOptions(request: ModifyGlobalDatabaseNetworkRequest, runtime: Util.RuntimeOptions): ModifyGlobalDatabaseNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.GDNDescription)) {
    query['GDNDescription'] = request.GDNDescription;
  }
  if (!Util.isUnset(request.GDNId)) {
    query['GDNId'] = request.GDNId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGlobalDatabaseNetwork',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyGlobalDatabaseNetwork(request: ModifyGlobalDatabaseNetworkRequest): ModifyGlobalDatabaseNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalDatabaseNetworkWithOptions(request, runtime);
}

model ModifyGlobalSecurityIPGroupRequest {
  GIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Multiple IP addresses are separated by commas (,). You can create up to 1,000 IP addresses or CIDR blocks for all IP whitelists.', example='192.168.0.1'),
  globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (\\_).
*   The name must start with a letter and end with a letter or digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
  globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyGlobalSecurityIPGroupResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      DBInstances?: [ string ](name='DBInstances', description='The clusters that are associated with the IP address whitelist template.'),
      GIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (\\_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroup', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model ModifyGlobalSecurityIPGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyGlobalSecurityIPGroupResponseBody(name='body'),
}

async function modifyGlobalSecurityIPGroupWithOptions(request: ModifyGlobalSecurityIPGroupRequest, runtime: Util.RuntimeOptions): ModifyGlobalSecurityIPGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.GIpList)) {
    query['GIpList'] = request.GIpList;
  }
  if (!Util.isUnset(request.globalIgName)) {
    query['GlobalIgName'] = request.globalIgName;
  }
  if (!Util.isUnset(request.globalSecurityGroupId)) {
    query['GlobalSecurityGroupId'] = request.globalSecurityGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGlobalSecurityIPGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyGlobalSecurityIPGroup(request: ModifyGlobalSecurityIPGroupRequest): ModifyGlobalSecurityIPGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalSecurityIPGroupWithOptions(request, runtime);
}

model ModifyGlobalSecurityIPGroupNameRequest {
  globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (\\_).
*   The name must start with a letter and end with a letter or digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
  globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyGlobalSecurityIPGroupNameResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      GIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (\\_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroup', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model ModifyGlobalSecurityIPGroupNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyGlobalSecurityIPGroupNameResponseBody(name='body'),
}

async function modifyGlobalSecurityIPGroupNameWithOptions(request: ModifyGlobalSecurityIPGroupNameRequest, runtime: Util.RuntimeOptions): ModifyGlobalSecurityIPGroupNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalIgName)) {
    query['GlobalIgName'] = request.globalIgName;
  }
  if (!Util.isUnset(request.globalSecurityGroupId)) {
    query['GlobalSecurityGroupId'] = request.globalSecurityGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGlobalSecurityIPGroupName',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyGlobalSecurityIPGroupName(request: ModifyGlobalSecurityIPGroupNameRequest): ModifyGlobalSecurityIPGroupNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalSecurityIPGroupNameWithOptions(request, runtime);
}

model ModifyGlobalSecurityIPGroupRelationRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-*****************'),
  globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyGlobalSecurityIPGroupRelationResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-*****************'),
  globalSecurityIPGroupRel?: [ 
    {
      GIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (\\_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroupRel', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model ModifyGlobalSecurityIPGroupRelationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyGlobalSecurityIPGroupRelationResponseBody(name='body'),
}

async function modifyGlobalSecurityIPGroupRelationWithOptions(request: ModifyGlobalSecurityIPGroupRelationRequest, runtime: Util.RuntimeOptions): ModifyGlobalSecurityIPGroupRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.globalSecurityGroupId)) {
    query['GlobalSecurityGroupId'] = request.globalSecurityGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGlobalSecurityIPGroupRelation',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyGlobalSecurityIPGroupRelation(request: ModifyGlobalSecurityIPGroupRelationRequest): ModifyGlobalSecurityIPGroupRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalSecurityIPGroupRelationWithOptions(request, runtime);
}

model ModifyLogBackupPolicyRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](~~98094~~) operation to query the information of all clusters that are deployed in a specific region, such as the cluster IDs.', example='pc-****************'),
  logBackupAnotherRegionRegion?: string(name='LogBackupAnotherRegionRegion', description='The region in which you want to store cross-region log backups. For information about regions that support the cross-region backup feature, see [Overview](~~72672~~).', example='cn-hangzhou'),
  logBackupAnotherRegionRetentionPeriod?: string(name='LogBackupAnotherRegionRetentionPeriod', description='The retention period of cross-region log backups. Valid values:

*   **0**: The cross-region backup feature is disabled.
*   **30 to 7300**: Cross-region log backups are retained for 30 to 7,300 days.
*   **-1**: The log backups are permanently retained.

>  When you create a cluster, the default value of this parameter is **0**.', example='30'),
  logBackupRetentionPeriod?: string(name='LogBackupRetentionPeriod', description='The retention period of the log backups. Valid values:

*   3 to 7300: The log backups are retained for 3 to 7,300 days.
*   \\-1: The log backups are permanently retained.', example='3'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyLogBackupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='345174B4-FAB3-412E-A326-BEDDA9******'),
}

model ModifyLogBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyLogBackupPolicyResponseBody(name='body'),
}

async function modifyLogBackupPolicyWithOptions(request: ModifyLogBackupPolicyRequest, runtime: Util.RuntimeOptions): ModifyLogBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.logBackupAnotherRegionRegion)) {
    query['LogBackupAnotherRegionRegion'] = request.logBackupAnotherRegionRegion;
  }
  if (!Util.isUnset(request.logBackupAnotherRegionRetentionPeriod)) {
    query['LogBackupAnotherRegionRetentionPeriod'] = request.logBackupAnotherRegionRetentionPeriod;
  }
  if (!Util.isUnset(request.logBackupRetentionPeriod)) {
    query['LogBackupRetentionPeriod'] = request.logBackupRetentionPeriod;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyLogBackupPolicy',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyLogBackupPolicy(request: ModifyLogBackupPolicyRequest): ModifyLogBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLogBackupPolicyWithOptions(request, runtime);
}

model ModifyMaskingRulesRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.', example='pc-*****************'),
  enable?: string(name='Enable', description='Specifies whether to enable the specified masking rule. Valid values:

*   **true**
*   **false**

> This parameter is valid only when the `RuleNameList` parameter is specfied.', example='true'),
  ruleConfig?: string(name='RuleConfig', description='The parameter that is used to specify the masking rule that you want to modify and the value in the JSON format. All parameter values are of the string type. Example: `{"auto": {"databases": ["db1"], "tables": ["tb1"], "columns": ["c1,c2"] }, "description": "This rule will be applied to the columns c1 and c2 in table t1", "enabled": true, "applies_to": ["user"]}`. Parameters in the function:

*   `"auto"`: specifies that the dynamic masking algorithm is supported. This parameter is required.
*   `"databases"`: Optional. The names of databases to which the masking rule is applied. Separate the names with commas (,). If you leave this parameter empty, the masking rule applies to all databases in the cluster.
*   `"tables"`: Optional. The names of tables to which the masking rule is applied. Separate the names with commas (,). If you leave this parameter empty, the rule applies to all tables in the cluster.
*   `"columns"`: Required. The names of fields to which the masking rule is applied. Separate the names with commas (,).
*   `"description"`: Optional. The description of the masking rule. The description can be up to 64 characters in length.
*   `"enabled"`: Required. Specifies whether to enable the masking rule. Valid values: **true** and **false**.
*   `"applies_to"`: The names of database accounts to which the masking rule is applied. Separate the names with commas (,).
*   `"exempted"`: The names of database accounts to which the masking rule is not applied. Separate the names with commas (,).

>- If you specify `RuleName`, `RuleConfig` parameter is required. 
>- You need to select either `"applies_to"` or `"exempted"`.', example='{"auto": {"databases": ["db1"], "tables": ["tb1"], "columns": ["c1,c2"] }, "description": "This rule will be applied to the columns c1 and c2 in table t1", "enabled": true, "applies_to": ["user"]}'),
  ruleName?: string(name='RuleName', description='The name of the data masking rule. You can specify only one rule name at a time.

>- You can call the [DescribeMaskingRules](~~212573~~) operation to query the details of all masking rules for a specified cluster, such as the names of the masking rules.
>- If the rule name does not exist in the cluster, the system automatically creates a masking rule based on the name and the value of `RuleConfig`.', example='testrule'),
  ruleNameList?: string(name='RuleNameList', description='The list of masking rule names. You can specify one or more masking rules at a time. Separate the masking rule names with commas (,).

> You must specify either the `RuleName` or `RuleNameList` parameter.', example='testrule'),
}

model ModifyMaskingRulesResponseBody = {
  message?: string(name='Message', description='The message that is returned for the request.

> If the request is successful, Successful is returned. If the request fails, an error message such as an error code is returned.', example='Message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='99B355CE-526C-478B-B730-AD9D7C******'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid value:

*   **true**:
*   **false**', example='true'),
}

model ModifyMaskingRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyMaskingRulesResponseBody(name='body'),
}

async function modifyMaskingRulesWithOptions(request: ModifyMaskingRulesRequest, runtime: Util.RuntimeOptions): ModifyMaskingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.ruleConfig)) {
    query['RuleConfig'] = request.ruleConfig;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleNameList)) {
    query['RuleNameList'] = request.ruleNameList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyMaskingRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyMaskingRules(request: ModifyMaskingRulesRequest): ModifyMaskingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMaskingRulesWithOptions(request, runtime);
}

model ModifyPendingMaintenanceActionRequest {
  ids?: string(name='Ids', description='The ID of the task. You can specify multiple task IDs at a time to modify the switching time of the tasks in a unified manner. The task IDs must be separated with commas (,).', example='111111'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

>  You can call the [DescribeRegions](~~98041~~) operation to query the region ID details.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  switchTime?: string(name='SwitchTime', description='The time that you specify for the background to perform the action that corresponds to the pending event. Specify the time in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in UTC.', example='2020-06-09T22:00:00Z'),
}

model ModifyPendingMaintenanceActionResponseBody = {
  ids?: string(name='Ids', description='The ID of the task.', example='111111'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='93061E17-B56A-4324-BC95-D0FFD2******'),
}

model ModifyPendingMaintenanceActionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyPendingMaintenanceActionResponseBody(name='body'),
}

async function modifyPendingMaintenanceActionWithOptions(request: ModifyPendingMaintenanceActionRequest, runtime: Util.RuntimeOptions): ModifyPendingMaintenanceActionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.switchTime)) {
    query['SwitchTime'] = request.switchTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPendingMaintenanceAction',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyPendingMaintenanceAction(request: ModifyPendingMaintenanceActionRequest): ModifyPendingMaintenanceActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPendingMaintenanceActionWithOptions(request, runtime);
}

model OpenAITaskRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-****************'),
  nodeType?: string(name='NodeType', example='DLNode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  password?: string(name='Password', description='The password used to access the database for which you want to enable the PolarDB for AI feature.', example='testPassword'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  username?: string(name='Username', description='The username used to access the database for which you want to enable the PolarDB for AI feature.', example='testAccountName'),
}

model OpenAITaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
  taskId?: string(name='TaskId', description='The task ID.', example='53879cdb-9a00-428e-acaf-ff4cff******'),
}

model OpenAITaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenAITaskResponseBody(name='body'),
}

async function openAITaskWithOptions(request: OpenAITaskRequest, runtime: Util.RuntimeOptions): OpenAITaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['NodeType'] = request.nodeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenAITask',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openAITask(request: OpenAITaskRequest): OpenAITaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return openAITaskWithOptions(request, runtime);
}

model RefreshDBClusterStorageUsageRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  syncRealTime?: boolean(name='SyncRealTime', description='Specifies whether to enable real-time synchronization. Valid values:

*   **true**
*   **false**: T + 1', example='true'),
}

model RefreshDBClusterStorageUsageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='E56531A4-E552-40BA-9C58-137B80******'),
}

model RefreshDBClusterStorageUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefreshDBClusterStorageUsageResponseBody(name='body'),
}

async function refreshDBClusterStorageUsageWithOptions(request: RefreshDBClusterStorageUsageRequest, runtime: Util.RuntimeOptions): RefreshDBClusterStorageUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.syncRealTime)) {
    query['SyncRealTime'] = request.syncRealTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshDBClusterStorageUsage',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshDBClusterStorageUsage(request: RefreshDBClusterStorageUsageRequest): RefreshDBClusterStorageUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshDBClusterStorageUsageWithOptions(request, runtime);
}

model RemoveDBClusterFromGDNRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster in the GDN.

>  You can call the [DescribeGlobalDatabaseNetwork](~~264580~~) operation to view the ID of the cluster in the GDN.', example='pc-wz9fb5nn44u1d****'),
  GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gdn-bp1fttxsrmv*****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model RemoveDBClusterFromGDNResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='67F2E75F-AE67-4FB2-821F-A81237EACD15'),
}

model RemoveDBClusterFromGDNResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveDBClusterFromGDNResponseBody(name='body'),
}

/**
  * >  You cannot remove the primary cluster from a GDN.
  *
  * @param request RemoveDBClusterFromGDNRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return RemoveDBClusterFromGDNResponse
 */
async function removeDBClusterFromGDNWithOptions(request: RemoveDBClusterFromGDNRequest, runtime: Util.RuntimeOptions): RemoveDBClusterFromGDNResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.GDNId)) {
    query['GDNId'] = request.GDNId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveDBClusterFromGDN',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You cannot remove the primary cluster from a GDN.
  *
  * @param request RemoveDBClusterFromGDNRequest
  * @return RemoveDBClusterFromGDNResponse
 */
async function removeDBClusterFromGDN(request: RemoveDBClusterFromGDNRequest): RemoveDBClusterFromGDNResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeDBClusterFromGDNWithOptions(request, runtime);
}

model ResetAccountRequest {
  accountName?: string(name='AccountName', description='The username of the account.

> You can reset only the permissions of a privileged account.', example='testacc'),
  accountPassword?: string(name='AccountPassword', description='The password of the account. The password must meet the following requirements:

*   It must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.
*   The password must be 8 to 32 characters in length.
*   Special characters include `! @ # $ % ^ & * ( ) _ + - =`', example='Pw123456'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ResetAccountResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model ResetAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetAccountResponseBody(name='body'),
}

/**
  * >- Only PolarDB for MySQL clusters support this operation.
  * >- If the privileged account of your cluster encounters exceptions, you can call this operation to reset the permissions. For example, the permissions are accidentally revoked.
  *
  * @param request ResetAccountRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ResetAccountResponse
 */
async function resetAccountWithOptions(request: ResetAccountRequest, runtime: Util.RuntimeOptions): ResetAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetAccount',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >- Only PolarDB for MySQL clusters support this operation.
  * >- If the privileged account of your cluster encounters exceptions, you can call this operation to reset the permissions. For example, the permissions are accidentally revoked.
  *
  * @param request ResetAccountRequest
  * @return ResetAccountResponse
 */
async function resetAccount(request: ResetAccountRequest): ResetAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetAccountWithOptions(request, runtime);
}

model ResetGlobalDatabaseNetworkRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster in the GDN.

>  You can call the [DescribeGlobalDatabaseNetwork](~~264580~~) operation to view the ID of the cluster in the GDN.', example='pc-wz9fb5nn44u1d****'),
  GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gdn-bp1fttxsrmv*****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ResetGlobalDatabaseNetworkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='67F2E75F-AE67-4FB2-821F-A81237EACD15'),
}

model ResetGlobalDatabaseNetworkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetGlobalDatabaseNetworkResponseBody(name='body'),
}

async function resetGlobalDatabaseNetworkWithOptions(request: ResetGlobalDatabaseNetworkRequest, runtime: Util.RuntimeOptions): ResetGlobalDatabaseNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.GDNId)) {
    query['GDNId'] = request.GDNId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetGlobalDatabaseNetwork',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetGlobalDatabaseNetwork(request: ResetGlobalDatabaseNetworkRequest): ResetGlobalDatabaseNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetGlobalDatabaseNetworkWithOptions(request, runtime);
}

model RestartDBNodeRequest {
  DBNodeId?: string(name='DBNodeId', description='The ID of the node.

>  You can call the [DescribeDBClusters](~~185342~~) operation to query the details of all clusters that belong to your Alibaba Cloud account, such as cluster IDs.', example='pi-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RestartDBNodeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model RestartDBNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartDBNodeResponseBody(name='body'),
}

async function restartDBNodeWithOptions(request: RestartDBNodeRequest, runtime: Util.RuntimeOptions): RestartDBNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBNodeId)) {
    query['DBNodeId'] = request.DBNodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartDBNode',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restartDBNode(request: RestartDBNodeRequest): RestartDBNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartDBNodeWithOptions(request, runtime);
}

model RestoreTableRequest {
  backupId?: string(name='BackupId', description='The ID of the backup set.

>  You must specify this parameter if you need to restore a database or a table by using a backup set. You can call the [DescribeBackups](~~98102~~) operation to query the ID of the backup set.', example='111111'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](~~98094~~) operation to query the details of all clusters within your account.', example='pc-bp***************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime', description='The point in time for the restoration. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mmZ format. The time must be in UTC.

> 

*   You must specify this parameter if you need to restore the database or the table to a point in time.

*   You can restore your cluster to a particular time only over the past seven days.', example='2020-10-04T01:40:00Z'),
  securityToken?: string(name='SecurityToken'),
  tableMeta?: string(name='TableMeta', description='The JSON string that contains the information of the database and the table that you want to restore. All values of the database and table information are of the string type. Example: `[ { "tables":[ { "name":"testtb", "type":"table", "newname":"testtb_restore" } ], "name":"testdb", "type":"db", "newname":"testdb_restore" } ]`.

>  You can call the [DescribeMetaList](~~194770~~) operation to query the names and details of databases and tables that can be restored and enter their information into the corresponding locations in the preceding example.', example='[ { "tables":[ { "name":"testtb", "type":"table", "newname":"testtb_restore" } ], "name":"testdb", "type":"db", "newname":"testdb_restore" } ]'),
}

model RestoreTableResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0C47508C-9DC8-455B-985E-2F2FA8******'),
}

model RestoreTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestoreTableResponseBody(name='body'),
}

async function restoreTableWithOptions(request: RestoreTableRequest, runtime: Util.RuntimeOptions): RestoreTableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.tableMeta)) {
    query['TableMeta'] = request.tableMeta;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestoreTable',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restoreTable(request: RestoreTableRequest): RestoreTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return restoreTableWithOptions(request, runtime);
}

model RevokeAccountPrivilegeRequest {
  accountName?: string(name='AccountName', description='The name of the account.

>  You can specify only a standard account.', example='testacc'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the PolarDB cluster.', example='pc-****************'),
  DBName?: string(name='DBName', description='The names of the databases. If you need to specify multiple database names, separate the names with commas (,).', example='testdb'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RevokeAccountPrivilegeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model RevokeAccountPrivilegeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokeAccountPrivilegeResponseBody(name='body'),
}

async function revokeAccountPrivilegeWithOptions(request: RevokeAccountPrivilegeRequest, runtime: Util.RuntimeOptions): RevokeAccountPrivilegeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RevokeAccountPrivilege',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokeAccountPrivilege(request: RevokeAccountPrivilegeRequest): RevokeAccountPrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeAccountPrivilegeWithOptions(request, runtime);
}

model SwitchOverGlobalDatabaseNetworkRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster that will become the primary cluster in the GDN.

You can call the [DescribeGlobalDatabaseNetwork](~~264580~~) operation to query the ID of the cluster in the GDN.', example='pc-wz9fb5nn44u1d****'),
  forced?: boolean(name='Forced', description='Specifies whether to forcibly switch over the primary and secondary clusters in the GDN. Valid values:

*   **true**
*   **false**', example='false'),
  GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gdn-bp1fttxsrmv*****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-qingdao'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model SwitchOverGlobalDatabaseNetworkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='67F2E75F-AE67-4FB2-821F-A81237EACD15'),
}

model SwitchOverGlobalDatabaseNetworkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SwitchOverGlobalDatabaseNetworkResponseBody(name='body'),
}

async function switchOverGlobalDatabaseNetworkWithOptions(request: SwitchOverGlobalDatabaseNetworkRequest, runtime: Util.RuntimeOptions): SwitchOverGlobalDatabaseNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.forced)) {
    query['Forced'] = request.forced;
  }
  if (!Util.isUnset(request.GDNId)) {
    query['GDNId'] = request.GDNId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SwitchOverGlobalDatabaseNetwork',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function switchOverGlobalDatabaseNetwork(request: SwitchOverGlobalDatabaseNetworkRequest): SwitchOverGlobalDatabaseNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchOverGlobalDatabaseNetworkWithOptions(request, runtime);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', example='pc-*****************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Set the value to **cluster**.', example='cluster'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag. To create multiple tags for a cluster at a time, click **Add** to add tag keys.

>  You can create up to 20 tags at a time. A tag consists of a key and a value. Each value of `Tag.N.Key` is paired with a value of `Tag.N.Value`.', example='type'),
      value?: string(name='Value', description='The value of the tag. To create multiple tags for a cluster at a time, click **Add** to add tag values.

>  You can create up to 20 tags at a time. A tag consists of a key and a value. Each value of `Tag.N.Value` is paired with a value of `Tag.N.Key`.', example='test'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='1CB5286F-AF5A-4E09-BFE9-588D4C******'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model TempModifyDBNodeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value. Make sure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='6000170000591aed949d0f5********************'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-xxxxxxxxxx'),
  DBNode?: [ 
    {
      targetClass?: string(name='TargetClass', description='The instance type of the added node. The instance type of the added node must be the same as the instance type of the original node.

>  You can call the [DescribeDBClusters](~~98094~~) operation to view the instance types of original nodes.', example='polar.mysql.x4.medium'),
      zoneId?: string(name='ZoneId', description='The ID of the zone in which the added node is deployed. The instance type of the added node must be the same as the instance type of the original node.', example='cn-hangzhou-i'),
    }
  ](name='DBNode', description='The information of the added node.'),
  modifyType?: string(name='ModifyType', description='The type of configuration change. Set the value to **TempUpgrade**.', example='TempUpgrade'),
  operationType?: string(name='OperationType', description='The type of operation performed on the cluster. Valid values:

*   **Modify**: temporarily upgrade the configuration of the cluster.', example='Modify'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime', description='The rollback time of the configuration for the temporary upgrade. Specify the time in the ISO 8601 standard in the YYYY-MM-DD hh:mm:ss format.

>  The rollback time cannot be 1 hour earlier than the current time and cannot be later than one day before the time when the cluster expires.', example='2021-09-23 18:16:00'),
}

model TempModifyDBNodeResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-xxxxxxxxxxxxxxxxx'),
  DBNodeIds?: [ string ](name='DBNodeIds', description='The details of the nodes.'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2035638*******'),
  requestId?: string(name='RequestId', description='The request ID.', example='69A85BAF-1089-4CDF-A82F-0A140F******'),
}

model TempModifyDBNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TempModifyDBNodeResponseBody(name='body'),
}

async function tempModifyDBNodeWithOptions(request: TempModifyDBNodeRequest, runtime: Util.RuntimeOptions): TempModifyDBNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNode)) {
    query['DBNode'] = request.DBNode;
  }
  if (!Util.isUnset(request.modifyType)) {
    query['ModifyType'] = request.modifyType;
  }
  if (!Util.isUnset(request.operationType)) {
    query['OperationType'] = request.operationType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TempModifyDBNode',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tempModifyDBNode(request: TempModifyDBNodeRequest): TempModifyDBNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return tempModifyDBNodeWithOptions(request, runtime);
}

model TransformDBClusterPayTypeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value. Make sure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='6000170000591aed949d0f5********************'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-bp10gr51qasnl****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go.
*   **Prepaid**: subscription.', example='Prepaid'),
  period?: string(name='Period', description='The renewal cycle of the cluster. Valid values:

*   **Year**
*   **Month**

>  This parameter is required if you set the **PayType** parameter to **Prepaid**.', example='Month'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfm3f4un32****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  usedTime?: string(name='UsedTime', description='The subscription duration of the cluster. Valid values:

*   If the **Period** parameter is set to **Year**, the **UsedTime** parameter can be set to 1, 2, or 3.
*   If the **Period** parameter is set to **Month**, the **UsedTime** parameter can be set to 1, 2, 3, 4, 5, 6, 7, 8, or 9.

>  This parameter is required if you set the **PayType** parameter to **Prepaid**.', example='1'),
}

model TransformDBClusterPayTypeResponseBody = {
  chargeType?: string(name='ChargeType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go.
*   **Prepaid**: subscription.', example='Prepaid'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-bp10gr51qasnl****'),
  expiredTime?: string(name='ExpiredTime', description='The time when the cluster expires.

>  This parameter is returned if you set the **PayType** parameter to **Prepaid**.', example='2020-04-20T10:00:00Z'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='20515760028****'),
  requestId?: string(name='RequestId', description='The request ID.', example='5E71541A-6007-4DCC-A38A-F872C31FEB45'),
}

model TransformDBClusterPayTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransformDBClusterPayTypeResponseBody(name='body'),
}

/**
  * > *   PolarDB clusters support the subscription and pay-as-you-go billing methods. You can change the billing method from subscription to pay-as-you-go or from pay-as-you-go to subscription based on your business requirements. For more information, see [Change the billing method from subscription to pay-as-you-go](~~172886~~) and [Change the billing method from pay-as-you-go to subscription](~~84076~~).
  * >*   You cannot change the billing method from pay-as-you-go to subscription if your account balance is insufficient.
  * >*   If you change the billing method from subscription to pay-as-you-go, the system automatically refunds the balance of the prepaid subscription fees.
  *
  * @param request TransformDBClusterPayTypeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return TransformDBClusterPayTypeResponse
 */
async function transformDBClusterPayTypeWithOptions(request: TransformDBClusterPayTypeRequest, runtime: Util.RuntimeOptions): TransformDBClusterPayTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TransformDBClusterPayType',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > *   PolarDB clusters support the subscription and pay-as-you-go billing methods. You can change the billing method from subscription to pay-as-you-go or from pay-as-you-go to subscription based on your business requirements. For more information, see [Change the billing method from subscription to pay-as-you-go](~~172886~~) and [Change the billing method from pay-as-you-go to subscription](~~84076~~).
  * >*   You cannot change the billing method from pay-as-you-go to subscription if your account balance is insufficient.
  * >*   If you change the billing method from subscription to pay-as-you-go, the system automatically refunds the balance of the prepaid subscription fees.
  *
  * @param request TransformDBClusterPayTypeRequest
  * @return TransformDBClusterPayTypeResponse
 */
async function transformDBClusterPayType(request: TransformDBClusterPayTypeRequest): TransformDBClusterPayTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return transformDBClusterPayTypeWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to unbinds all tags from the cluster. Valid values: **true** and **false**. Default value: **false**.

>  This parameter takes effect only when the value of the `TagKey.n` parameter is empty.', example='true'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region.

>  You can call the [DescribeRegions](~~98041~~) operation to query the available regions.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The IDs of the clusters.', example='pc-***************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Set the value to **cluster**.', example='cluster'),
  tagKey?: [ string ](name='TagKey', description='The keys of the tags.', example='type'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF5189******'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpgradeDBClusterMinorVersionRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](~~98094~~) operation to query the details of all the clusters for your account, such as the cluster ID.', example='pc-****************'),
  fromTimeService?: boolean(name='FromTimeService', description='This parameter is not required when you call the operation.', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to run the task that updates the kernel version of the cluster. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The value of this parameter must be at least 30 minutes later than the value of PlannedStartTime.

*   If you specify `PlannedStartTime` but do not specify PlannedEndTime, the latest start time of the task is `PlannedEndTime + 30 minutes`. For example, if you set `PlannedStartTime` to `2021-01-14T09:00:00Z` and do not specify PlannedEndTime, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time to run the task that updates the kernel version of the cluster. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in time between `2021-01-14T09:00:00Z` and `2021-01-15T09:00:00Z`.

*   If you do not specify this parameter, the kernel update task runs immediately after you submit the request.', example='2021-01-14T09:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpgradeDBClusterMinorVersionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='69FFDDF1-44C3-4ECA-A99E-445B493******'),
}

model UpgradeDBClusterMinorVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeDBClusterMinorVersionResponseBody(name='body'),
}

/**
  * > You can upgrade only the revision version of a PolarDB for MySQL cluster. For example, you can upgrade the version 8.0.1.1.3 of a PolarDB for MySQL cluster to the version 8.0.1.1.4.
  *
  * @param request UpgradeDBClusterMinorVersionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpgradeDBClusterMinorVersionResponse
 */
async function upgradeDBClusterMinorVersionWithOptions(request: UpgradeDBClusterMinorVersionRequest, runtime: Util.RuntimeOptions): UpgradeDBClusterMinorVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.fromTimeService)) {
    query['FromTimeService'] = request.fromTimeService;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeDBClusterMinorVersion',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > You can upgrade only the revision version of a PolarDB for MySQL cluster. For example, you can upgrade the version 8.0.1.1.3 of a PolarDB for MySQL cluster to the version 8.0.1.1.4.
  *
  * @param request UpgradeDBClusterMinorVersionRequest
  * @return UpgradeDBClusterMinorVersionResponse
 */
async function upgradeDBClusterMinorVersion(request: UpgradeDBClusterMinorVersionRequest): UpgradeDBClusterMinorVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeDBClusterMinorVersionWithOptions(request, runtime);
}

model UpgradeDBClusterVersionRequest {
  DBClusterId?: string(name='DBClusterId', example='pc-****************'),
  fromTimeService?: boolean(name='FromTimeService', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to run the task that updates the kernel version of the cluster. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The value of this parameter must be at least 30 minutes later than the value of PlannedStartTime.

*   If you specify `PlannedStartTime` but do not specify PlannedEndTime, the latest start time of the task is `PlannedEndTime + 30 minutes`. For example, if you set `PlannedStartTime` to `2021-01-14T09:00:00Z` and do not specify PlannedEndTime, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time to run the task that updates the kernel version of the cluster. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in time between `2021-01-14T09:00:00Z` and `2021-01-15T09:00:00Z`.

*   If you do not specify this parameter, the kernel update task runs immediately after you submit the request.', example='2021-01-14T09:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  targetDBRevisionVersionCode?: string(name='TargetDBRevisionVersionCode', description='目标版本的VersionCode，参数取值可从[DescribeDBClusterVersion](~~2319145~~)接口获取。', example='20230707'),
  upgradeLabel?: string(name='UpgradeLabel', example='INNOVATE'),
  upgradePolicy?: string(name='UpgradePolicy', example='HOT'),
  upgradeType?: string(name='UpgradeType', example='PROXY'),
}

model UpgradeDBClusterVersionResponseBody = {
  requestId?: string(name='RequestId', example='CAE6755F-B79A-4861-B227-801FE8******'),
}

model UpgradeDBClusterVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeDBClusterVersionResponseBody(name='body'),
}

/**
  * > 
  * *   You can update only the revision version of a PolarDB for MySQL cluster, for example, from 8.0.1.1.3 to 8.0.1.1.4.
  * *   You can use only your Alibaba Cloud account to create scheduled tasks that update the kernel version of a PolarDB for MySQL cluster. RAM users are not authorized to update the kernel version of a PolarDB for MySQL cluster.
  *
  * @param request UpgradeDBClusterVersionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpgradeDBClusterVersionResponse
 */
async function upgradeDBClusterVersionWithOptions(request: UpgradeDBClusterVersionRequest, runtime: Util.RuntimeOptions): UpgradeDBClusterVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.fromTimeService)) {
    query['FromTimeService'] = request.fromTimeService;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.targetDBRevisionVersionCode)) {
    query['TargetDBRevisionVersionCode'] = request.targetDBRevisionVersionCode;
  }
  if (!Util.isUnset(request.upgradeLabel)) {
    query['UpgradeLabel'] = request.upgradeLabel;
  }
  if (!Util.isUnset(request.upgradePolicy)) {
    query['UpgradePolicy'] = request.upgradePolicy;
  }
  if (!Util.isUnset(request.upgradeType)) {
    query['UpgradeType'] = request.upgradeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeDBClusterVersion',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   You can update only the revision version of a PolarDB for MySQL cluster, for example, from 8.0.1.1.3 to 8.0.1.1.4.
  * *   You can use only your Alibaba Cloud account to create scheduled tasks that update the kernel version of a PolarDB for MySQL cluster. RAM users are not authorized to update the kernel version of a PolarDB for MySQL cluster.
  *
  * @param request UpgradeDBClusterVersionRequest
  * @return UpgradeDBClusterVersionResponse
 */
async function upgradeDBClusterVersion(request: UpgradeDBClusterVersionRequest): UpgradeDBClusterVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeDBClusterVersionWithOptions(request, runtime);
}

