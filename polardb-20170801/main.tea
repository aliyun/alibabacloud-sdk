/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    'cn-qingdao' = 'polardb.aliyuncs.com',
    'cn-beijing' = 'polardb.aliyuncs.com',
    'cn-wulanchabu' = 'polardb.aliyuncs.com',
    'cn-hangzhou' = 'polardb.aliyuncs.com',
    'cn-shanghai' = 'polardb.aliyuncs.com',
    'cn-shenzhen' = 'polardb.aliyuncs.com',
    'cn-guangzhou' = 'polardb.aliyuncs.com',
    'cn-hongkong' = 'polardb.aliyuncs.com',
    'cn-hangzhou-finance' = 'polardb.aliyuncs.com',
    'cn-shanghai-finance-1' = 'polardb.aliyuncs.com',
    'cn-shenzhen-finance-1' = 'polardb.aliyuncs.com',
    'cn-north-2-gov-1' = 'polardb.aliyuncs.com',
    'ap-northeast-2-pop' = 'polardb.aliyuncs.com',
    'cn-beijing-finance-1' = 'polardb.aliyuncs.com',
    'cn-beijing-finance-pop' = 'polardb.aliyuncs.com',
    'cn-beijing-gov-1' = 'polardb.aliyuncs.com',
    'cn-beijing-nu16-b01' = 'polardb.aliyuncs.com',
    'cn-edge-1' = 'polardb.aliyuncs.com',
    'cn-fujian' = 'polardb.aliyuncs.com',
    'cn-haidian-cm12-c01' = 'polardb.aliyuncs.com',
    'cn-hangzhou-bj-b01' = 'polardb.aliyuncs.com',
    'cn-hangzhou-internal-prod-1' = 'polardb.aliyuncs.com',
    'cn-hangzhou-internal-test-1' = 'polardb.aliyuncs.com',
    'cn-hangzhou-internal-test-2' = 'polardb.aliyuncs.com',
    'cn-hangzhou-internal-test-3' = 'polardb.aliyuncs.com',
    'cn-hangzhou-test-306' = 'polardb.aliyuncs.com',
    'cn-hongkong-finance-pop' = 'polardb.aliyuncs.com',
    'cn-huhehaote-nebula-1' = 'polardb.aliyuncs.com',
    'cn-qingdao-nebula' = 'polardb.aliyuncs.com',
    'cn-shanghai-et15-b01' = 'polardb.aliyuncs.com',
    'cn-shanghai-et2-b01' = 'polardb.aliyuncs.com',
    'cn-shanghai-inner' = 'polardb.aliyuncs.com',
    'cn-shanghai-internal-test-1' = 'polardb.aliyuncs.com',
    'cn-shenzhen-inner' = 'polardb.aliyuncs.com',
    'cn-shenzhen-st4-d01' = 'polardb.aliyuncs.com',
    'cn-shenzhen-su18-b01' = 'polardb.aliyuncs.com',
    'cn-wuhan' = 'polardb.aliyuncs.com',
    'cn-yushanfang' = 'polardb.aliyuncs.com',
    'cn-zhangbei' = 'polardb.aliyuncs.com',
    'cn-zhangbei-na61-b01' = 'polardb.aliyuncs.com',
    'cn-zhangjiakou-na62-a01' = 'polardb.aliyuncs.com',
    'cn-zhengzhou-nebula-1' = 'polardb.aliyuncs.com',
    'eu-west-1-oxs' = 'polardb.aliyuncs.com',
    'rus-west-1-pop' = 'polardb.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('polardb', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AbortDBClusterMigrationRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-bp150t3l1td9863q9'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model AbortDBClusterMigrationResponseBody = {
  requestId?: string(name='RequestId', example='925B84D9-CA72-432C-95CF-738C22******'),
}

model AbortDBClusterMigrationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AbortDBClusterMigrationResponseBody(name='body'),
}

/**
 * @param request AbortDBClusterMigrationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AbortDBClusterMigrationResponse
 */
async function abortDBClusterMigrationWithOptions(request: AbortDBClusterMigrationRequest, runtime: Util.RuntimeOptions): AbortDBClusterMigrationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AbortDBClusterMigration',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AbortDBClusterMigrationRequest
 * @return AbortDBClusterMigrationResponse
 */
async function abortDBClusterMigration(request: AbortDBClusterMigrationRequest): AbortDBClusterMigrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return abortDBClusterMigrationWithOptions(request, runtime);
}

model AddEncryptionDBRolePrivilegeRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-******************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  rolePrivilegeConfig?: string(name='RolePrivilegeConfig', example='{"notEncryption":["alton"],"encryption":["alton01"]}'),
  rolePrivilegeName?: string(name='RolePrivilegeName', example='test'),
}

model AddEncryptionDBRolePrivilegeResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-bp10gr51qasnl****'),
  requestId?: string(name='RequestId', description='Id of the request', example='6A2EE5B4-CC9F-46E1-A747-E43BC9******'),
}

model AddEncryptionDBRolePrivilegeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddEncryptionDBRolePrivilegeResponseBody(name='body'),
}

/**
 * @summary 添加角色权限
 *
 * @param request AddEncryptionDBRolePrivilegeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddEncryptionDBRolePrivilegeResponse
 */
async function addEncryptionDBRolePrivilegeWithOptions(request: AddEncryptionDBRolePrivilegeRequest, runtime: Util.RuntimeOptions): AddEncryptionDBRolePrivilegeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.rolePrivilegeConfig)) {
    query['RolePrivilegeConfig'] = request.rolePrivilegeConfig;
  }
  if (!Util.isUnset(request.rolePrivilegeName)) {
    query['RolePrivilegeName'] = request.rolePrivilegeName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddEncryptionDBRolePrivilege',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 添加角色权限
 *
 * @param request AddEncryptionDBRolePrivilegeRequest
 * @return AddEncryptionDBRolePrivilegeResponse
 */
async function addEncryptionDBRolePrivilege(request: AddEncryptionDBRolePrivilegeRequest): AddEncryptionDBRolePrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  return addEncryptionDBRolePrivilegeWithOptions(request, runtime);
}

model AddFirewallRulesRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-*****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleConfig?: string(name='RuleConfig', example='{"id":"test","enabled":"true","mode":"Collecting","users":{"applies_to":[]},"endpoint":"[{"EndpointName":"pe-************","EndpointType":"Cluster","DBEndpointDescription":"Cluster Address"},{"EndpointName":"pe-************","EndpointType":"Custom","DBEndpointDescription":"pc-************"},{"EndpointName":"pe-************","EndpointType":"Custom","DBEndpointDescription":"pc-************K"}]","type":"WhiteList"}'),
  ruleName?: string(name='RuleName', example='testrule'),
}

model AddFirewallRulesResponseBody = {
  message?: string(name='Message', example='Successful'),
  requestId?: string(name='RequestId', description='Id of the request', example='2921D843-433A-5FB3-A03B-4EC093B219F8'),
  success?: boolean(name='Success', example='True'),
}

model AddFirewallRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddFirewallRulesResponseBody(name='body'),
}

/**
 * @summary 添加sql防火墙配置
 *
 * @param request AddFirewallRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddFirewallRulesResponse
 */
async function addFirewallRulesWithOptions(request: AddFirewallRulesRequest, runtime: Util.RuntimeOptions): AddFirewallRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleConfig)) {
    query['RuleConfig'] = request.ruleConfig;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddFirewallRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 添加sql防火墙配置
 *
 * @param request AddFirewallRulesRequest
 * @return AddFirewallRulesResponse
 */
async function addFirewallRules(request: AddFirewallRulesRequest): AddFirewallRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return addFirewallRulesWithOptions(request, runtime);
}

model AddSQLRateLimitingRulesRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleConfig?: string(name='RuleConfig', description='This parameter is required.', example='{"id":"test","enabled":"true","match_mode":"0","template":"dXBkYXRlIHQgc2V0IGEgPSAxIHdoZXJlIGlkID0gMQ==","user":"","database":"","waiting":1024,"endpoint":"[{"EndpointName":"pe-***********","EndpointType":"Cluster","DBEndpointDescription":"Cluster Address"}]","throttle_mode":0,"concurrency":1}'),
  ruleName?: string(name='RuleName', description='This parameter is required.', example='testrule'),
}

model AddSQLRateLimitingRulesResponseBody = {
  message?: string(name='Message', example='Message'),
  requestId?: string(name='RequestId', description='Id of the request', example='69A85BAF-1089-4CDF-A82F-0A140F******'),
  success?: boolean(name='Success', example='true'),
}

model AddSQLRateLimitingRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddSQLRateLimitingRulesResponseBody(name='body'),
}

/**
 * @summary 添加SQL限流规则
 *
 * @param request AddSQLRateLimitingRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddSQLRateLimitingRulesResponse
 */
async function addSQLRateLimitingRulesWithOptions(request: AddSQLRateLimitingRulesRequest, runtime: Util.RuntimeOptions): AddSQLRateLimitingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleConfig)) {
    query['RuleConfig'] = request.ruleConfig;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddSQLRateLimitingRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 添加SQL限流规则
 *
 * @param request AddSQLRateLimitingRulesRequest
 * @return AddSQLRateLimitingRulesResponse
 */
async function addSQLRateLimitingRules(request: AddSQLRateLimitingRulesRequest): AddSQLRateLimitingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSQLRateLimitingRulesWithOptions(request, runtime);
}

model AttachApplicationPolarFSRequest {
  applicationId?: string(name='ApplicationId', description='This parameter is required.', example='pa-**************'),
  polarFSAccessKeyId?: string(name='PolarFSAccessKeyId', example='LT**********************'),
  polarFSAccessKeySecret?: string(name='PolarFSAccessKeySecret', example='H3****************************'),
  polarFSInstanceId?: string(name='PolarFSInstanceId', description='This parameter is required.', example='pcs-**************'),
}

model AttachApplicationPolarFSResponseBody = {
  applicationId?: string(name='ApplicationId', example='pa-**************'),
  polarFSInstanceId?: string(name='PolarFSInstanceId', description='PolarFS ID', example='pcs-**************'),
  requestId?: string(name='RequestId', example='3E5CD764-FCCA-5C9C-838E-20E0DE84B2AF'),
}

model AttachApplicationPolarFSResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AttachApplicationPolarFSResponseBody(name='body'),
}

/**
 * @summary 挂载PolarFS到PolarDB应用
 *
 * @param request AttachApplicationPolarFSRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachApplicationPolarFSResponse
 */
async function attachApplicationPolarFSWithOptions(request: AttachApplicationPolarFSRequest, runtime: Util.RuntimeOptions): AttachApplicationPolarFSResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationId)) {
    query['ApplicationId'] = request.applicationId;
  }
  if (!Util.isUnset(request.polarFSAccessKeyId)) {
    query['PolarFSAccessKeyId'] = request.polarFSAccessKeyId;
  }
  if (!Util.isUnset(request.polarFSAccessKeySecret)) {
    query['PolarFSAccessKeySecret'] = request.polarFSAccessKeySecret;
  }
  if (!Util.isUnset(request.polarFSInstanceId)) {
    query['PolarFSInstanceId'] = request.polarFSInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachApplicationPolarFS',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 挂载PolarFS到PolarDB应用
 *
 * @param request AttachApplicationPolarFSRequest
 * @return AttachApplicationPolarFSResponse
 */
async function attachApplicationPolarFS(request: AttachApplicationPolarFSRequest): AttachApplicationPolarFSResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachApplicationPolarFSWithOptions(request, runtime);
}

model CancelActiveOperationTasksRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.

> 

*   You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the region information about all clusters within a specified account.

*   If you do not specify this parameter, scheduled tasks on your clusters that are deployed in all regions are queried.

This parameter is required.', example='cn-beijing'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  taskIds?: string(name='TaskIds', description='The IDs of O\\\\&M events that are canceled at a time. Separate multiple IDs with commas (,).

This parameter is required.', example='2355,2352'),
}

model CancelActiveOperationTasksResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='25C70FF3-D49B-594D-BECE-0DE2BA1D8BBB'),
  taskIds?: string(name='TaskIds', description='The IDs of O\\\\&M events that are canceled at a time. Separate multiple IDs with commas (,).', example='2355,2352'),
}

model CancelActiveOperationTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelActiveOperationTasksResponseBody(name='body'),
}

/**
 * @summary Cancels O\\&M events at a time.
 *
 * @param request CancelActiveOperationTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelActiveOperationTasksResponse
 */
async function cancelActiveOperationTasksWithOptions(request: CancelActiveOperationTasksRequest, runtime: Util.RuntimeOptions): CancelActiveOperationTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.taskIds)) {
    query['TaskIds'] = request.taskIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelActiveOperationTasks',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Cancels O\\&M events at a time.
 *
 * @param request CancelActiveOperationTasksRequest
 * @return CancelActiveOperationTasksResponse
 */
async function cancelActiveOperationTasks(request: CancelActiveOperationTasksRequest): CancelActiveOperationTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelActiveOperationTasksWithOptions(request, runtime);
}

model CancelCronJobPolicyServerlessRequest {
  DBClusterId?: string(name='DBClusterId', example='pc-*************'),
  jobId?: string(name='JobId', example='b3e7b3d3-027d-4fcc-9f92-5c5f2363e141'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-beijing'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CancelCronJobPolicyServerlessResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='7E2FE3BB-C677-5FF9-9FC5-9CF364BD6BE5'),
}

model CancelCronJobPolicyServerlessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelCronJobPolicyServerlessResponseBody(name='body'),
}

/**
 * @summary 取消周期任务策略
 *
 * @param request CancelCronJobPolicyServerlessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelCronJobPolicyServerlessResponse
 */
async function cancelCronJobPolicyServerlessWithOptions(request: CancelCronJobPolicyServerlessRequest, runtime: Util.RuntimeOptions): CancelCronJobPolicyServerlessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelCronJobPolicyServerless',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 取消周期任务策略
 *
 * @param request CancelCronJobPolicyServerlessRequest
 * @return CancelCronJobPolicyServerlessResponse
 */
async function cancelCronJobPolicyServerless(request: CancelCronJobPolicyServerlessRequest): CancelCronJobPolicyServerlessResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelCronJobPolicyServerlessWithOptions(request, runtime);
}

model CancelScheduleTasksRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the information of all clusters that are deployed in a specified region, such as the cluster IDs.

This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  taskId?: string(name='TaskId', description='The ID of the scheduled task that you want to cancel.

> *   You can call the [DescribeScheduleTasks](https://help.aliyun.com/document_detail/199648.html) operation to query the details of all scheduled tasks that belong to the current account, such as the task IDs.
>*   You can cancel only the tasks whose status is `pending`.``

This parameter is required.', example='ec8c4723-eac5-4f12-becb-01ac08******'),
}

model CancelScheduleTasksResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7F2007D3-7E74-4ECB-89A8-BF130D******'),
  success?: boolean(name='Success', description='Indicates whether the request is successful.', example='true'),
}

model CancelScheduleTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelScheduleTasksResponseBody(name='body'),
}

/**
 * @summary Cancels scheduled tasks that are not yet started.
 *
 * @param request CancelScheduleTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelScheduleTasksResponse
 */
async function cancelScheduleTasksWithOptions(request: CancelScheduleTasksRequest, runtime: Util.RuntimeOptions): CancelScheduleTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelScheduleTasks',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Cancels scheduled tasks that are not yet started.
 *
 * @param request CancelScheduleTasksRequest
 * @return CancelScheduleTasksResponse
 */
async function cancelScheduleTasks(request: CancelScheduleTasksRequest): CancelScheduleTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelScheduleTasksWithOptions(request, runtime);
}

model CheckAccountNameRequest {
  accountName?: string(name='AccountName', description='The name of the account.

This parameter is required.', example='test_acc'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.

This parameter is required.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckAccountNameResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='925B84D9-CA72-432C-95CF-738C22******'),
}

model CheckAccountNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckAccountNameResponseBody(name='body'),
}

/**
 * @summary Checks whether an account name is valid or unique in a cluster.
 *
 * @param request CheckAccountNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckAccountNameResponse
 */
async function checkAccountNameWithOptions(request: CheckAccountNameRequest, runtime: Util.RuntimeOptions): CheckAccountNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckAccountName',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Checks whether an account name is valid or unique in a cluster.
 *
 * @param request CheckAccountNameRequest
 * @return CheckAccountNameResponse
 */
async function checkAccountName(request: CheckAccountNameRequest): CheckAccountNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkAccountNameWithOptions(request, runtime);
}

model CheckAccountNameZonalRequest {
  accountName?: string(name='AccountName', description='This parameter is required.', example='test_acc'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckAccountNameZonalResponseBody = {
  requestId?: string(name='RequestId', example='925B84D9-CA72-432C-95CF-738C22******'),
}

model CheckAccountNameZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckAccountNameZonalResponseBody(name='body'),
}

/**
 * @summary 检查PolarDB账号名称
 *
 * @param request CheckAccountNameZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckAccountNameZonalResponse
 */
async function checkAccountNameZonalWithOptions(request: CheckAccountNameZonalRequest, runtime: Util.RuntimeOptions): CheckAccountNameZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckAccountNameZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 检查PolarDB账号名称
 *
 * @param request CheckAccountNameZonalRequest
 * @return CheckAccountNameZonalResponse
 */
async function checkAccountNameZonal(request: CheckAccountNameZonalRequest): CheckAccountNameZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkAccountNameZonalWithOptions(request, runtime);
}

model CheckConnectionStringRequest {
  connectionStringPrefix?: string(name='ConnectionStringPrefix', description='This parameter is required.', example='pc-****************.pg.polardb.pre.rds.aliyuncs.com:5432'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckConnectionStringResponseBody = {
  requestId?: string(name='RequestId', example='CD3FA5F3-FAF3-44CA-AFFF-BAF869******'),
}

model CheckConnectionStringResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckConnectionStringResponseBody(name='body'),
}

/**
 * @summary 检查连接串
 *
 * @param request CheckConnectionStringRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckConnectionStringResponse
 */
async function checkConnectionStringWithOptions(request: CheckConnectionStringRequest, runtime: Util.RuntimeOptions): CheckConnectionStringResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionStringPrefix)) {
    query['ConnectionStringPrefix'] = request.connectionStringPrefix;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckConnectionString',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 检查连接串
 *
 * @param request CheckConnectionStringRequest
 * @return CheckConnectionStringResponse
 */
async function checkConnectionString(request: CheckConnectionStringRequest): CheckConnectionStringResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkConnectionStringWithOptions(request, runtime);
}

model CheckDBNameRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query information about all clusters that are deployed in a region, such as the cluster IDs.

This parameter is required.', example='pc-****************'),
  DBName?: string(name='DBName', description='The name of the database.

This parameter is required.', example='test_db'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckDBNameResponseBody = {
  DBName?: string(name='DBName', description='The name of the database.', example='test_db'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CDB3258F-B5DE-43C4-8935-CBA0CA******'),
}

model CheckDBNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckDBNameResponseBody(name='body'),
}

/**
 * @summary Checks whether a database name is valid or whether the name is already used by another database in the current cluster.
 *
 * @param request CheckDBNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckDBNameResponse
 */
async function checkDBNameWithOptions(request: CheckDBNameRequest, runtime: Util.RuntimeOptions): CheckDBNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckDBName',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Checks whether a database name is valid or whether the name is already used by another database in the current cluster.
 *
 * @param request CheckDBNameRequest
 * @return CheckDBNameResponse
 */
async function checkDBName(request: CheckDBNameRequest): CheckDBNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkDBNameWithOptions(request, runtime);
}

model CheckDBNameZonalRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-****************'),
  DBName?: string(name='DBName', description='This parameter is required.', example='test_db'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckDBNameZonalResponseBody = {
  DBName?: string(name='DBName', example='test_db'),
  requestId?: string(name='RequestId', example='CDB3258F-B5DE-43C4-8935-CBA0CA******'),
}

model CheckDBNameZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckDBNameZonalResponseBody(name='body'),
}

/**
 * @summary 检查PolarDB边缘云数据库名
 *
 * @param request CheckDBNameZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckDBNameZonalResponse
 */
async function checkDBNameZonalWithOptions(request: CheckDBNameZonalRequest, runtime: Util.RuntimeOptions): CheckDBNameZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckDBNameZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 检查PolarDB边缘云数据库名
 *
 * @param request CheckDBNameZonalRequest
 * @return CheckDBNameZonalResponse
 */
async function checkDBNameZonal(request: CheckDBNameZonalRequest): CheckDBNameZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkDBNameZonalWithOptions(request, runtime);
}

model CheckKMSAuthorizedRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the information of all clusters that are deployed in a specific region, such as the cluster IDs.

This parameter is required.', example='pc-************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region.

>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query all regions that are available for your account, such as the region IDs.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  TDERegion?: string(name='TDERegion', description='The region in which the TDE key resides.', example='cn-beijing'),
}

model CheckKMSAuthorizedResponseBody = {
  authorizationState?: int32(name='AuthorizationState', description='Indicates whether the cluster is authorized to use KMS. Valid values:

*   **0**: no.
*   **1**: yes.', example='0'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-************'),
  requestId?: string(name='RequestId', description='The request ID.', example='A7E6A8FD-C50B-46B2-BA85-D8B8D3******'),
  roleArn?: string(name='RoleArn', description='The Alibaba Cloud Resource Name (ARN) of the RAM role. A RAM role is a virtual identity that you can create within your Alibaba Cloud account. For more information, see [RAM role overview](https://help.aliyun.com/document_detail/93689.html).', example='acs:ram::1406926*****:role/aliyunrdsinstanceencryptiondefaultrole'),
}

model CheckKMSAuthorizedResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckKMSAuthorizedResponseBody(name='body'),
}

/**
 * @summary Queries whether the cluster is authorized to use Key Management Service (KMS).
 *
 * @param request CheckKMSAuthorizedRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckKMSAuthorizedResponse
 */
async function checkKMSAuthorizedWithOptions(request: CheckKMSAuthorizedRequest, runtime: Util.RuntimeOptions): CheckKMSAuthorizedResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.TDERegion)) {
    query['TDERegion'] = request.TDERegion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckKMSAuthorized',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries whether the cluster is authorized to use Key Management Service (KMS).
 *
 * @param request CheckKMSAuthorizedRequest
 * @return CheckKMSAuthorizedResponse
 */
async function checkKMSAuthorized(request: CheckKMSAuthorizedRequest): CheckKMSAuthorizedResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkKMSAuthorizedWithOptions(request, runtime);
}

model CheckServiceLinkedRoleRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckServiceLinkedRoleResponseBody = {
  hasServiceLinkedRole?: boolean(name='HasServiceLinkedRole', description='Indicates whether the SLR is created.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3F9E6A3B-C13E-4064-A010-18582A******'),
}

model CheckServiceLinkedRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckServiceLinkedRoleResponseBody(name='body'),
}

/**
 * @summary Checks whether a service-linked role (SLR) is created.
 *
 * @param request CheckServiceLinkedRoleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckServiceLinkedRoleResponse
 */
async function checkServiceLinkedRoleWithOptions(request: CheckServiceLinkedRoleRequest, runtime: Util.RuntimeOptions): CheckServiceLinkedRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckServiceLinkedRole',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Checks whether a service-linked role (SLR) is created.
 *
 * @param request CheckServiceLinkedRoleRequest
 * @return CheckServiceLinkedRoleResponse
 */
async function checkServiceLinkedRole(request: CheckServiceLinkedRoleRequest): CheckServiceLinkedRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkServiceLinkedRoleWithOptions(request, runtime);
}

model CloseAITaskRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

This parameter is required.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CloseAITaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='936C7025-27A5-4CB1-BB31-540E1F0CCA12'),
  taskId?: string(name='TaskId', description='The ID of the task for disabling the PolarDB for AI feature.', example='53879cdb-9a00-428e-acaf-ff4cff******'),
}

model CloseAITaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloseAITaskResponseBody(name='body'),
}

/**
 * @summary 关闭DB4AI
 *
 * @param request CloseAITaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CloseAITaskResponse
 */
async function closeAITaskWithOptions(request: CloseAITaskRequest, runtime: Util.RuntimeOptions): CloseAITaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloseAITask',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 关闭DB4AI
 *
 * @param request CloseAITaskRequest
 * @return CloseAITaskResponse
 */
async function closeAITask(request: CloseAITaskRequest): CloseAITaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return closeAITaskWithOptions(request, runtime);
}

model CloseDBClusterMigrationRequest {
  continueEnableBinlog?: boolean(name='ContinueEnableBinlog', description='Specifies whether to continue to enable binary logging. Valid values:

*   **true**: continues to enable binary logging.
*   **false**: disables binary logging.

Default value: **true**.

> If binary logging is disabled, your PolarDB cluster is restarted.', example='true'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CloseDBClusterMigrationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='3AA69096-757C-4647-B36C-29EBC2******'),
}

model CloseDBClusterMigrationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloseDBClusterMigrationResponseBody(name='body'),
}

/**
 * @summary Cancels or completes the migration task that upgrades an RDS cluster to a PolarDB cluster.
 *
 * @description *   You can call this operation to cancel the migration task before data migration.
 * *   You can call this operation to perform the migration task after data migration.
 * > Before you call this operation, ensure that a one-click upgrade task has been created for the cluster. You can call the [CreateDBCluster](https://help.aliyun.com/document_detail/98169.html) operation to create an upgrade task. Set the **CreationOption** parameter to **MigrationFromRDS**. For more information, see [Create a PolarDB for MySQL cluster by using the Migration from RDS method](https://help.aliyun.com/document_detail/121582.html).
 *
 * @param request CloseDBClusterMigrationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CloseDBClusterMigrationResponse
 */
async function closeDBClusterMigrationWithOptions(request: CloseDBClusterMigrationRequest, runtime: Util.RuntimeOptions): CloseDBClusterMigrationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.continueEnableBinlog)) {
    query['ContinueEnableBinlog'] = request.continueEnableBinlog;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloseDBClusterMigration',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Cancels or completes the migration task that upgrades an RDS cluster to a PolarDB cluster.
 *
 * @description *   You can call this operation to cancel the migration task before data migration.
 * *   You can call this operation to perform the migration task after data migration.
 * > Before you call this operation, ensure that a one-click upgrade task has been created for the cluster. You can call the [CreateDBCluster](https://help.aliyun.com/document_detail/98169.html) operation to create an upgrade task. Set the **CreationOption** parameter to **MigrationFromRDS**. For more information, see [Create a PolarDB for MySQL cluster by using the Migration from RDS method](https://help.aliyun.com/document_detail/121582.html).
 *
 * @param request CloseDBClusterMigrationRequest
 * @return CloseDBClusterMigrationResponse
 */
async function closeDBClusterMigration(request: CloseDBClusterMigrationRequest): CloseDBClusterMigrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return closeDBClusterMigrationWithOptions(request, runtime);
}

model ContinueDBClusterMigrationRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-k2ju1lnl5i4ohv501'),
  forceSwitch?: string(name='ForceSwitch', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ContinueDBClusterMigrationResponseBody = {
  requestId?: string(name='RequestId', example='D2056BBE-FF76-5825-AB63-5CB1ABB46218'),
}

model ContinueDBClusterMigrationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ContinueDBClusterMigrationResponseBody(name='body'),
}

/**
 * @param request ContinueDBClusterMigrationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ContinueDBClusterMigrationResponse
 */
async function continueDBClusterMigrationWithOptions(request: ContinueDBClusterMigrationRequest, runtime: Util.RuntimeOptions): ContinueDBClusterMigrationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.forceSwitch)) {
    query['ForceSwitch'] = request.forceSwitch;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ContinueDBClusterMigration',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ContinueDBClusterMigrationRequest
 * @return ContinueDBClusterMigrationResponse
 */
async function continueDBClusterMigration(request: ContinueDBClusterMigrationRequest): ContinueDBClusterMigrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return continueDBClusterMigrationWithOptions(request, runtime);
}

model CreateAccountRequest {
  accountDescription?: string(name='AccountDescription', description='The description of the account. The description must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must be 2 to 256 characters in length.', example='testdes'),
  accountName?: string(name='AccountName', description='The name of the account. The name must meet the following requirements:

*   It must start with a lowercase letter and end with a letter or a digit.
*   It can contain lowercase letters, digits, and underscores (_).
*   It must be 2 to 16 characters in length.
*   It cannot be root, admin, or another username that is reserved by the system.

This parameter is required.', example='testacc'),
  accountPassword?: string(name='AccountPassword', description='The password of the account. The password must meet the following requirements:

*   The password must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.
*   The password must be 8 to 32 characters in length.
*   Special characters include `! @ # $ % ^ & * ( ) _ + - =`

This parameter is required.', example='Test1111'),
  accountPrivilege?: string(name='AccountPrivilege', description='The permissions that are granted to the account. Valid values:

*   **ReadWrite**: read and write permissions.
*   **ReadOnly**: read-only permissions.
*   **DMLOnly**: the permissions to execute only DML statements.
*   **DDLOnly**: the permissions to execute only DDL statements.
*   **ReadIndex**: the read-only and index permissions.

> 

*   `AccountPrivilege` is valid only after you specify `DBName`.

*   If multiple database names are specified by the `DBName` parameter, you must grant permissions on the databases. Separate multiple permissions with commas (,), and make sure that the length of the value of `AccountPrivilege` does not exceed 900. For example, if you want to grant the account the read and write permissions on DB1 and the read-only permissions on DB2, set `DBName` to `DB1,DB2` and set `AccountPrivilege` to `ReadWrite,ReadOnly`.

*   This parameter is valid only for standard accounts of PolarDB for MySQL clusters.', example='ReadWrite'),
  accountType?: string(name='AccountType', description='The type of the account. Valid values:

*   **Normal**: standard account
*   **Super**: privileged account.

> 

*   If you leave this parameter empty, the default value **Super** is used.

*   You can create multiple privileged accounts for a PolarDB for PostgreSQL (Compatible with Oracle) cluster or a PolarDB for PostgreSQL cluster. A privileged account has more permissions than a standard account. For more information, see [Create a database account](https://help.aliyun.com/document_detail/68508.html).

*   You can create only one privileged account for a PolarDB for MySQL cluster. A privileged account has more permissions than a standard account. For more information, see [Create a database account](https://help.aliyun.com/document_detail/68508.html).', example='Normal'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-**************'),
  DBName?: string(name='DBName', description='The name of the database that can be accessed by the account. To enter multiple database names, separate the names with commas (,).

>  This parameter is valid only for standard accounts of PolarDB for MySQL clusters.', example='testdb'),
  nodeType?: string(name='NodeType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  privForAllDB?: string(name='PrivForAllDB'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateAccountResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CED079B7-A408-41A1-BFF1-EC608E******'),
}

model CreateAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAccountResponseBody(name='body'),
}

/**
 * @summary Creates a database account for a PolarDB cluster.
 *
 * @param request CreateAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAccountResponse
 */
async function createAccountWithOptions(request: CreateAccountRequest, runtime: Util.RuntimeOptions): CreateAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDescription)) {
    query['AccountDescription'] = request.accountDescription;
  }
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.accountPrivilege)) {
    query['AccountPrivilege'] = request.accountPrivilege;
  }
  if (!Util.isUnset(request.accountType)) {
    query['AccountType'] = request.accountType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['NodeType'] = request.nodeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.privForAllDB)) {
    query['PrivForAllDB'] = request.privForAllDB;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccount',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a database account for a PolarDB cluster.
 *
 * @param request CreateAccountRequest
 * @return CreateAccountResponse
 */
async function createAccount(request: CreateAccountRequest): CreateAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccountWithOptions(request, runtime);
}

model CreateAccountZonalRequest {
  accountDescription?: string(name='AccountDescription', example='testdes'),
  accountName?: string(name='AccountName', description='This parameter is required.', example='testacc'),
  accountPassword?: string(name='AccountPassword', description='This parameter is required.', example='Test1111'),
  accountPrivilege?: string(name='AccountPrivilege', example='ReadWrite'),
  accountType?: string(name='AccountType', example='Normal'),
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  DBName?: string(name='DBName', example='testdb'),
  nodeType?: string(name='NodeType', example='Normal'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  privForAllDB?: string(name='PrivForAllDB', example='0'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateAccountZonalResponseBody = {
  requestId?: string(name='RequestId', example='CED079B7-A408-41A1-BFF1-EC608E******'),
}

model CreateAccountZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAccountZonalResponseBody(name='body'),
}

/**
 * @summary 创建边缘云账号
 *
 * @param request CreateAccountZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAccountZonalResponse
 */
async function createAccountZonalWithOptions(request: CreateAccountZonalRequest, runtime: Util.RuntimeOptions): CreateAccountZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDescription)) {
    query['AccountDescription'] = request.accountDescription;
  }
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.accountPrivilege)) {
    query['AccountPrivilege'] = request.accountPrivilege;
  }
  if (!Util.isUnset(request.accountType)) {
    query['AccountType'] = request.accountType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['NodeType'] = request.nodeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.privForAllDB)) {
    query['PrivForAllDB'] = request.privForAllDB;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccountZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建边缘云账号
 *
 * @param request CreateAccountZonalRequest
 * @return CreateAccountZonalResponse
 */
async function createAccountZonal(request: CreateAccountZonalRequest): CreateAccountZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccountZonalWithOptions(request, runtime);
}

model CreateActivationCodeRequest {
  aliyunOrderId?: string(name='AliyunOrderId', description='The Alibaba Cloud order ID (including the virtual order ID).

This parameter is required.', example='2233****445566'),
  description?: string(name='Description', description='The description of the activation code.', example='testCode'),
  macAddress?: string(name='MacAddress', description='The MAC address.

This parameter is required.', example='12:34:56:78:98:00'),
  name?: string(name='Name', description='The name of the activation code. The name can contain only letters, digits, underscores (_), and hyphens (-). The activation code file downloaded from the console is named based on this name.

This parameter is required.', example='testName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  systemIdentifier?: string(name='SystemIdentifier', description='The system identifier of the database. This parameter is required if you set AllowEmptySystemIdentifier to false.', example='1234567890123456'),
}

model CreateActivationCodeResponseBody = {
  activateAt?: string(name='ActivateAt', description='The time when the activation code takes effect.', example='2024-10-16 16:46:20'),
  certContentB64?: string(name='CertContentB64', description='The activation code in the base64 format. The activation code is decoded and stored into a file named license.lic. PolarDB can access and read the license.lic file upon startup to validate the license or perform related operations.', example='AAEAA******AAA='),
  description?: string(name='Description', description='The description of the activation code.', example='testCode'),
  expireAt?: string(name='ExpireAt', description='The time when the activation code expires.', example='2054-10-09 16:46:20'),
  gmtCreated?: string(name='GmtCreated', description='The time when the activation code was created.', example='2024-10-16 16:46:20'),
  gmtModified?: string(name='GmtModified', description='The time when the activation code was last updated.', example='2024-10-16 16:46:20'),
  id?: int32(name='Id', description='The activation code ID.', example='123'),
  macAddress?: string(name='MacAddress', description='The MAC address.', example='12:34:56:78:98:00'),
  name?: string(name='Name', description='The name of the activation code.', example='testName'),
  requestId?: string(name='RequestId', description='The request ID.', example='4CE6DF97-AEA4-484F-906F-C407EE******'),
  systemIdentifier?: string(name='SystemIdentifier', description='The system identifier of the database.', example='1234567890123456'),
}

model CreateActivationCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateActivationCodeResponseBody(name='body'),
}

/**
 * @summary Generates a lightweight license activation code.
 *
 * @param request CreateActivationCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateActivationCodeResponse
 */
async function createActivationCodeWithOptions(request: CreateActivationCodeRequest, runtime: Util.RuntimeOptions): CreateActivationCodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunOrderId)) {
    query['AliyunOrderId'] = request.aliyunOrderId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.macAddress)) {
    query['MacAddress'] = request.macAddress;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.systemIdentifier)) {
    query['SystemIdentifier'] = request.systemIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateActivationCode',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Generates a lightweight license activation code.
 *
 * @param request CreateActivationCodeRequest
 * @return CreateActivationCodeResponse
 */
async function createActivationCode(request: CreateActivationCodeRequest): CreateActivationCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createActivationCodeWithOptions(request, runtime);
}

model CreateApplicationRequest {
  applicationType?: string(name='ApplicationType', description='This parameter is required.', example='supabase'),
  architecture?: string(name='Architecture', description='This parameter is required.', example='x86'),
  autoRenew?: boolean(name='AutoRenew', example='true'),
  components?: [ 
    {
      componentClass?: string(name='ComponentClass', example='polar.app.g2.medium'),
      componentMaxReplica?: long(name='ComponentMaxReplica', example='1'),
      componentReplica?: long(name='ComponentReplica', example='1'),
      componentType?: string(name='ComponentType', example='gateway'),
      scaleMax?: string(name='ScaleMax'),
      scaleMin?: string(name='ScaleMin'),
      securityGroups?: string(name='SecurityGroups', example='sg-********************'),
      securityIPArrayName?: string(name='SecurityIPArrayName', example='default'),
      securityIPList?: string(name='SecurityIPList', example='127.0.0.1'),
      securityIPType?: string(name='SecurityIPType', example='ipv4'),
    }
  ](name='Components'),
  DBClusterId?: string(name='DBClusterId', example='pc-**************'),
  description?: string(name='Description', example='myapp'),
  dryRun?: boolean(name='DryRun', example='false'),
  endpoints?: [ 
    {
      description?: string(name='Description', example='my_endpoint'),
      endpointType?: string(name='EndpointType', example='Primary'),
    }
  ](name='Endpoints'),
  payType?: string(name='PayType', example='Postpaid'),
  period?: string(name='Period', example='Year'),
  polarFSInstanceId?: string(name='PolarFSInstanceId', example='pcs-********************'),
  regionId?: string(name='RegionId', example='cn-beijing'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-********************'),
  usedTime?: string(name='UsedTime', example='1'),
  vSwitchId?: string(name='VSwitchId', example='vsw-*********************'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId', example='cn-beijing-k'),
}

model CreateApplicationShrinkRequest {
  applicationType?: string(name='ApplicationType', description='This parameter is required.', example='supabase'),
  architecture?: string(name='Architecture', description='This parameter is required.', example='x86'),
  autoRenew?: boolean(name='AutoRenew', example='true'),
  componentsShrink?: string(name='Components'),
  DBClusterId?: string(name='DBClusterId', example='pc-**************'),
  description?: string(name='Description', example='myapp'),
  dryRun?: boolean(name='DryRun', example='false'),
  endpointsShrink?: string(name='Endpoints'),
  payType?: string(name='PayType', example='Postpaid'),
  period?: string(name='Period', example='Year'),
  polarFSInstanceId?: string(name='PolarFSInstanceId', example='pcs-********************'),
  regionId?: string(name='RegionId', example='cn-beijing'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-********************'),
  usedTime?: string(name='UsedTime', example='1'),
  vSwitchId?: string(name='VSwitchId', example='vsw-*********************'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId', example='cn-beijing-k'),
}

model CreateApplicationResponseBody = {
  applicationId?: string(name='ApplicationId', example='pa-********************'),
  components?: [ 
    {
      componentId?: string(name='ComponentId', example='pac-********************'),
    }
  ](name='Components'),
  description?: string(name='Description', example='myapp'),
  orderId?: string(name='OrderId', example='2148126708*****'),
  requestId?: string(name='RequestId', example='3E5CD764-FCCA-5C9C-838E-20E0DE84B2AF'),
  resourceAvailable?: boolean(name='ResourceAvailable', example='true'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-********************'),
}

model CreateApplicationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateApplicationResponseBody(name='body'),
}

/**
 * @summary 创建PolarDB应用
 *
 * @param tmpReq CreateApplicationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateApplicationResponse
 */
async function createApplicationWithOptions(tmpReq: CreateApplicationRequest, runtime: Util.RuntimeOptions): CreateApplicationResponse {
  Util.validateModel(tmpReq);
  var request = new CreateApplicationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.components)) {
    request.componentsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.components, 'Components', 'json');
  }
  if (!Util.isUnset(tmpReq.endpoints)) {
    request.endpointsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.endpoints, 'Endpoints', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.applicationType)) {
    query['ApplicationType'] = request.applicationType;
  }
  if (!Util.isUnset(request.architecture)) {
    query['Architecture'] = request.architecture;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.componentsShrink)) {
    query['Components'] = request.componentsShrink;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.endpointsShrink)) {
    query['Endpoints'] = request.endpointsShrink;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.polarFSInstanceId)) {
    query['PolarFSInstanceId'] = request.polarFSInstanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建PolarDB应用
 *
 * @param request CreateApplicationRequest
 * @return CreateApplicationResponse
 */
async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApplicationWithOptions(request, runtime);
}

model CreateApplicationEndpointAddressRequest {
  applicationId?: string(name='ApplicationId', description='This parameter is required.', example='pa-**************'),
  endpointId?: string(name='EndpointId', description='This parameter is required.', example='pa-**************'),
  netType?: string(name='NetType', description='This parameter is required.', example='Public'),
}

model CreateApplicationEndpointAddressResponseBody = {
  applicationId?: string(name='ApplicationId', example='pa-**************'),
  endpointId?: string(name='EndpointId', example='pa-**************'),
  requestId?: string(name='RequestId', example='3E5CD764-FCCA-5C9C-838E-20E0DE84B2AF'),
}

model CreateApplicationEndpointAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateApplicationEndpointAddressResponseBody(name='body'),
}

/**
 * @summary 创建PolarDB应用终端节点地址
 *
 * @param request CreateApplicationEndpointAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateApplicationEndpointAddressResponse
 */
async function createApplicationEndpointAddressWithOptions(request: CreateApplicationEndpointAddressRequest, runtime: Util.RuntimeOptions): CreateApplicationEndpointAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationId)) {
    query['ApplicationId'] = request.applicationId;
  }
  if (!Util.isUnset(request.endpointId)) {
    query['EndpointId'] = request.endpointId;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateApplicationEndpointAddress',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建PolarDB应用终端节点地址
 *
 * @param request CreateApplicationEndpointAddressRequest
 * @return CreateApplicationEndpointAddressResponse
 */
async function createApplicationEndpointAddress(request: CreateApplicationEndpointAddressRequest): CreateApplicationEndpointAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApplicationEndpointAddressWithOptions(request, runtime);
}

model CreateBackupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateBackupResponseBody = {
  backupJobId?: string(name='BackupJobId', description='The ID of the backup set.', example='11111111'),
  requestId?: string(name='RequestId', description='The request ID.', example='F3322AFE-083E-4D77-A074-421301******'),
}

model CreateBackupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateBackupResponseBody(name='body'),
}

/**
 * @summary Creates a full snapshot backup for a PolarDB cluster.
 *
 * @description > 
 * *   You can manually create up to three backups for each cluster.
 * *   The `Exceeding the daily backup times of this DB cluster` error message indicates that three manual backups already exist in your cluster. You must delete existing backups before you call this operation to manually create backups. For more information about how to delete backups, see [Delete backups](https://help.aliyun.com/document_detail/98101.html).
 * *   After you call this operation, a backup task is created in the backend. The task may be time-consuming if you want to back up large amounts of data.
 *
 * @param request CreateBackupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBackupResponse
 */
async function createBackupWithOptions(request: CreateBackupRequest, runtime: Util.RuntimeOptions): CreateBackupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBackup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a full snapshot backup for a PolarDB cluster.
 *
 * @description > 
 * *   You can manually create up to three backups for each cluster.
 * *   The `Exceeding the daily backup times of this DB cluster` error message indicates that three manual backups already exist in your cluster. You must delete existing backups before you call this operation to manually create backups. For more information about how to delete backups, see [Delete backups](https://help.aliyun.com/document_detail/98101.html).
 * *   After you call this operation, a backup task is created in the backend. The task may be time-consuming if you want to back up large amounts of data.
 *
 * @param request CreateBackupRequest
 * @return CreateBackupResponse
 */
async function createBackup(request: CreateBackupRequest): CreateBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBackupWithOptions(request, runtime);
}

model CreateColdStorageInstanceRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='6000170000591aed949d0f5********************'),
  coldStorageInstanceDescription?: string(name='ColdStorageInstanceDescription', description='The description of the cluster. The description cannot exceed 256 characters in length.', example='xxxxxxxxx'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID. > You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of all clusters within your account, such as cluster IDs.

This parameter is required.', example='pc-wz9ye3xrtj60ua6d1'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateColdStorageInstanceResponseBody = {
  coldStorageInstanceId?: string(name='ColdStorageInstanceId', description='The cluster ID.', example='pcs_2zeth2gf4i83e578t'),
  requestId?: string(name='RequestId', description='The request ID.', example='F6EBB4ED-D12F-5F49-824C-9DD9C0EC4CF2'),
}

model CreateColdStorageInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateColdStorageInstanceResponseBody(name='body'),
}

/**
 * @summary Creates a cluster that is used to store cold data.
 *
 * @param request CreateColdStorageInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateColdStorageInstanceResponse
 */
async function createColdStorageInstanceWithOptions(request: CreateColdStorageInstanceRequest, runtime: Util.RuntimeOptions): CreateColdStorageInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.coldStorageInstanceDescription)) {
    query['ColdStorageInstanceDescription'] = request.coldStorageInstanceDescription;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateColdStorageInstance',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a cluster that is used to store cold data.
 *
 * @param request CreateColdStorageInstanceRequest
 * @return CreateColdStorageInstanceResponse
 */
async function createColdStorageInstance(request: CreateColdStorageInstanceRequest): CreateColdStorageInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createColdStorageInstanceWithOptions(request, runtime);
}

model CreateCronJobPolicyServerlessRequest {
  allowShutDown?: string(name='AllowShutDown', example='true'),
  cronExpression?: string(name='CronExpression', description='This parameter is required.', example='0 0 13 * * ?'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-xxxxxxxxxx'),
  endTime?: string(name='EndTime', description='This parameter is required.', example='2021-09-23T01:01:00Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='This parameter is required.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scaleApRoNumMax?: string(name='ScaleApRoNumMax', example='1'),
  scaleApRoNumMin?: string(name='ScaleApRoNumMin', example='1'),
  scaleMax?: string(name='ScaleMax', example='3'),
  scaleMin?: string(name='ScaleMin', example='1'),
  scaleRoNumMax?: string(name='ScaleRoNumMax', example='4'),
  scaleRoNumMin?: string(name='ScaleRoNumMin', example='2'),
  secondsUntilAutoPause?: string(name='SecondsUntilAutoPause', example='10'),
  serverlessRuleCpuEnlargeThreshold?: string(name='ServerlessRuleCpuEnlargeThreshold', example='60'),
  serverlessRuleCpuShrinkThreshold?: string(name='ServerlessRuleCpuShrinkThreshold', example='30'),
  serverlessRuleMode?: string(name='ServerlessRuleMode', example='normal'),
  startTime?: string(name='StartTime', example='2020-11-14T00:00Z'),
}

model CreateCronJobPolicyServerlessResponseBody = {
  action?: string(name='Action', example='ModifyDBClusterServerlessConf'),
  cronExpression?: string(name='CronExpression', example='0 0 8 * * ?'),
  DBClusterId?: string(name='DBClusterId', example='pc-****************'),
  endTime?: string(name='EndTime', example='2021-04-07T04:00Z'),
  jobId?: string(name='JobId', example='1fa3c0e7-b568-4f41-b703-463c96a91bd8'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='Id of the request', example='45D24263-7E3A-4140-9472-************'),
  startTime?: string(name='StartTime', example='2020-05-01T00:00Z'),
  status?: string(name='Status', example='working'),
}

model CreateCronJobPolicyServerlessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCronJobPolicyServerlessResponseBody(name='body'),
}

/**
 * @summary serverless创建周期任务策略
 *
 * @param request CreateCronJobPolicyServerlessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCronJobPolicyServerlessResponse
 */
async function createCronJobPolicyServerlessWithOptions(request: CreateCronJobPolicyServerlessRequest, runtime: Util.RuntimeOptions): CreateCronJobPolicyServerlessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allowShutDown)) {
    query['AllowShutDown'] = request.allowShutDown;
  }
  if (!Util.isUnset(request.cronExpression)) {
    query['CronExpression'] = request.cronExpression;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scaleApRoNumMax)) {
    query['ScaleApRoNumMax'] = request.scaleApRoNumMax;
  }
  if (!Util.isUnset(request.scaleApRoNumMin)) {
    query['ScaleApRoNumMin'] = request.scaleApRoNumMin;
  }
  if (!Util.isUnset(request.scaleMax)) {
    query['ScaleMax'] = request.scaleMax;
  }
  if (!Util.isUnset(request.scaleMin)) {
    query['ScaleMin'] = request.scaleMin;
  }
  if (!Util.isUnset(request.scaleRoNumMax)) {
    query['ScaleRoNumMax'] = request.scaleRoNumMax;
  }
  if (!Util.isUnset(request.scaleRoNumMin)) {
    query['ScaleRoNumMin'] = request.scaleRoNumMin;
  }
  if (!Util.isUnset(request.secondsUntilAutoPause)) {
    query['SecondsUntilAutoPause'] = request.secondsUntilAutoPause;
  }
  if (!Util.isUnset(request.serverlessRuleCpuEnlargeThreshold)) {
    query['ServerlessRuleCpuEnlargeThreshold'] = request.serverlessRuleCpuEnlargeThreshold;
  }
  if (!Util.isUnset(request.serverlessRuleCpuShrinkThreshold)) {
    query['ServerlessRuleCpuShrinkThreshold'] = request.serverlessRuleCpuShrinkThreshold;
  }
  if (!Util.isUnset(request.serverlessRuleMode)) {
    query['ServerlessRuleMode'] = request.serverlessRuleMode;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCronJobPolicyServerless',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary serverless创建周期任务策略
 *
 * @param request CreateCronJobPolicyServerlessRequest
 * @return CreateCronJobPolicyServerlessResponse
 */
async function createCronJobPolicyServerless(request: CreateCronJobPolicyServerlessRequest): CreateCronJobPolicyServerlessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCronJobPolicyServerlessWithOptions(request, runtime);
}

model CreateDBClusterRequest {
  allowShutDown?: string(name='AllowShutDown', description='Whether to enable idle pause. Values:

- **true**: Enabled

- **false**: Disabled (default)

> Only supported by Serverless clusters.', example='true'),
  architecture?: string(name='Architecture', description='CPU architecture. Available values include:
- X86
- ARM', example='X86'),
  autoRenew?: boolean(name='AutoRenew', description='Whether to enable auto-renewal, with available values as follows:

- **true**: Auto-renew.
- **false**: Do not auto-renew.

The default is **false**.

> This parameter takes effect only when **PayType** is set to **Prepaid**.', example='true'),
  backupRetentionPolicyOnClusterDeletion?: string(name='BackupRetentionPolicyOnClusterDeletion', description='Backup retention policy upon cluster deletion, with valid values as follows:
* **ALL**: Permanently retain all backups.
* **LATEST**: Permanently retain the latest backup (automatically backed up before deletion).
* **NONE**: Do not retain backup sets upon cluster deletion.

By default, the value is set to **NONE**, indicating no backup sets are retained upon cluster deletion.
> This parameter applies only when **DBType** is **MySQL**.
> Serverless clusters do not support this parameter.', example='NONE'),
  burstingEnabled?: string(name='BurstingEnabled', example='false'),
  clientToken?: string(name='ClientToken', description='Used to ensure idempotency of the request. Generated by the client, ensuring uniqueness across different requests, case-sensitive, and not exceeding 64 ASCII characters.', example='6000170000591aed949d0f5********************'),
  cloneDataPoint?: string(name='CloneDataPoint', description='The point in time to clone data, with the following options:

- **LATEST**: Data from the latest time point.
- **BackupID**: Historical backup set ID, please enter the specific backup set ID.
- **Timestamp**: Historical time point, please enter the specific time in the format `YYYY-MM-DDThh:mm:ssZ` (UTC time).

The default value is **LATEST**.

> If **CreationOption** is **CloneFromRDS**, this parameter can only be set to **LATEST**.', example='LATEST'),
  cloudProvider?: string(name='CloudProvider', example='ENS'),
  clusterNetworkType?: string(name='ClusterNetworkType', description='Cluster network type, currently only VPC is supported, with a fixed value of **VPC**.', example='VPC'),
  creationCategory?: string(name='CreationCategory', description='Product series, with valid values as follows:
* **Normal**: Cluster Edition (default)
* **Basic**: Single-node
* **ArchiveNormal**: High Compression Engine (X-Engine)
* **NormalMultimaster**: Multi-master Cluster Edition
* **SENormal**: Standard Edition

> * **MySQL** **5.6**, **5.7**, **8.0**, **PostgreSQL** **14**, and **Oracle Syntax Compatible 2.0** support **Basic**.
> * **MySQL** **8.0** supports **ArchiveNormal** and **NormalMultimaster**.
> * **MySQL** **5.6**, **5.7**, **8.0**, and **PostgreSQL** **14** support **SENormal**.

For more information about product series, see [Product Series](https://help.aliyun.com/document_detail/183258.html).', example='Normal'),
  creationOption?: string(name='CreationOption', description='Creation method, with the following values supported:

* **Normal**: Creates a brand new PolarDB cluster. For console operations, refer to the following documents:
    * [Create a PolarDB MySQL Edition Database Cluster](https://help.aliyun.com/document_detail/58769.html)
    * [Create a PolarDB PostgreSQL Edition Database Cluster](https://help.aliyun.com/document_detail/118063.html)
    * [Create a PolarDB PostgreSQL Edition (Oracle Compatible) Database Cluster](https://help.aliyun.com/document_detail/118182.html)

* **CloneFromPolarDB**: Clones data from an existing PolarDB cluster to a new PolarDB cluster. For console operations, refer to the following documents:
    * [Clone a PolarDB MySQL Edition Cluster](https://help.aliyun.com/document_detail/87966.html)
    * [Clone a PolarDB PostgreSQL Edition Cluster](https://help.aliyun.com/document_detail/118108.html)
    * [Clone a PolarDB PostgreSQL Edition (Oracle Compatible) Cluster](https://help.aliyun.com/document_detail/118221.html)

* **RecoverFromRecyclebin**: Recovers data from a released PolarDB cluster to a new PolarDB cluster. For console operations, refer to the following documents:
    * [Restore a Released PolarDB MySQL Edition Cluster](https://help.aliyun.com/document_detail/164880.html)
    * [Restore a Released PolarDB PostgreSQL Edition Cluster](https://help.aliyun.com/document_detail/432844.html)
    * [Restore a Released PolarDB PostgreSQL Edition (Oracle Compatible) Cluster](https://help.aliyun.com/document_detail/424632.html)

* **CloneFromRDS**: Clones data from an existing RDS instance to a new PolarDB cluster. Console operation guide is available at [One-click Clone from RDS MySQL to PolarDB MySQL Edition](https://help.aliyun.com/document_detail/121812.html).

* **MigrationFromRDS**: Migrates data from an existing RDS instance to a new PolarDB cluster. The created PolarDB cluster operates in read-only mode with Binlog enabled by default. Console operation guide is at [One-click Upgrade from RDS MySQL to PolarDB MySQL Edition](https://help.aliyun.com/document_detail/121582.html).

* **CreateGdnStandby**: Creates a standby cluster. Console operation guide can be found at [Add Standby Cluster](https://help.aliyun.com/document_detail/160381.html).

* **UpgradeFromPolarDB**: Upgrades and migrates from PolarDB. Console operation guide is detailed in [Major Version Upgrade](https://help.aliyun.com/document_detail/459712.html).

The default value is **Normal**.

> When **DBType** is **MySQL** and **DBVersion** is **8.0**, this parameter can also take the value **CreateGdnStandby**.', example='Normal'),
  DBClusterDescription?: string(name='DBClusterDescription', description='Cluster name, which must meet the following requirements:
* Cannot start with `http://` or `https://`.
* Length should be between 2 and 256 characters.', example='test'),
  DBMinorVersion?: string(name='DBMinorVersion', description='Database engine minor version number. Valid values include:

- **8.0.2**
- **8.0.1**

> This parameter takes effect only when **DBType** is **MySQL** and **DBVersion** is **8.0**.', example='8.0.1'),
  DBNodeClass?: string(name='DBNodeClass', description='Node specifications. For details, refer to the following documents:

- PolarDB MySQL Edition: [Compute Node Specifications](https://help.aliyun.com/document_detail/102542.html).
- PolarDB PostgreSQL Edition (Oracle Compatible): [Compute Node Specifications](https://help.aliyun.com/document_detail/207921.html).
- PolarDB PostgreSQL Edition: [Compute Node Specifications](https://help.aliyun.com/document_detail/209380.html).

> - For a Serverless cluster in PolarDB MySQL, enter **polar.mysql.sl.small**.
<props="china">> - For a Serverless cluster in both PolarDB PostgreSQL (Oracle Compatible) and PolarDB PostgreSQL, enter **polar.pg.sl.small.c**.', example='polar.mysql.x4.medium'),
  DBNodeNum?: int32(name='DBNodeNum', description='The number of nodes. This parameter is supported for Standard Edition clusters. Valid values:

*   **1** (default): only one primary node.
*   **2**: one read-only node and one primary node.

> 

*   By default, an Enterprise Edition cluster has two nodes and a Standard Edition cluster has one node.

*   This parameter is supported only for PolarDB for MySQL clusters.', example='1'),
  DBType?: string(name='DBType', description='Database engine type, with available values as follows:

- **MySQL**
- **PostgreSQL**
- **Oracle**

This parameter is required.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='Database engine version number.
* For MySQL, the version numbers are as follows:
    * **5.6**
    * **5.7**
    * **8.0**
* For PostgreSQL, the version numbers are as follows:
    * **11**
    * **14**
    * **15**
    <props="china">
      
      > When creating a Serverless cluster in PolarDB PostgreSQL, only version **14** is supported.
    
    
* For Oracle, the version numbers are as follows:
    * **11**
    * **14**

This parameter is required.', example='5.6'),
  defaultTimeZone?: string(name='DefaultTimeZone', description='Cluster timezone (UTC), with selectable values ranging from **-12:00** to **+13:00** at whole-hour intervals, e.g., **00:00**. The default value is **SYSTEM**, which matches the Region\\\\"s timezone.
> This parameter applies only when **DBType** is **MySQL**.', example='SYSTEM'),
  ensRegionId?: string(name='EnsRegionId', example='vn-hanoi-3'),
  GDNId?: string(name='GDNId', description='Global Database Network (GDN) ID.

> This parameter is required when **CreationOption** is **CreateGdnStandby**.', example='gdn-***********'),
  hotStandbyCluster?: string(name='HotStandbyCluster', description='Specifies whether to enable the hot standby storage cluster feature. Valid values:

*   **ON** (default): enables the hot standby storage cluster feature.
*   **OFF**: disables the hot standby storage cluster feature.
*   **STANDBY**: enables the hot standby storage cluster feature for Standard Edition clusters.

>  The default value for Standard Edition clusters is **STANDBY**.', example='ON'),
  loosePolarLogBin?: string(name='LoosePolarLogBin', description='Enable Binlog feature, valid values are as follows:
- **ON**: Cluster enables the Binlog feature. - **OFF**: Cluster disables the Binlog feature. > This parameter takes effect only when the **DBType** parameter is set to **MySQL**.', example='ON'),
  looseXEngine?: string(name='LooseXEngine', description='Enable the X-Engine storage engine feature, with valid values as follows:

- **ON**: The cluster enables the X-Engine engine.
- **OFF**: The cluster disables the X-Engine engine.
> This parameter is effective only when **CreationOption** is not **CreateGdnStandby**, **DBType** is **MySQL**, and **DBVersion** is **8.0**. The memory specification of nodes that enable the X-Engine engine must be at least 8 GB.', example='ON'),
  looseXEngineUseMemoryPct?: string(name='LooseXEngineUseMemoryPct', description='Set the ratio for enabling the X-Engine storage engine, with a range of integers from 10 to 90.
> This parameter takes effect only when **LooseXEngine** is **ON**.', example='50'),
  lowerCaseTableNames?: string(name='LowerCaseTableNames', description='Whether table names are case-sensitive, with valid values as follows:
* **1**: Case-insensitive
* **0**: Case-sensitive

The default value is **1**.
> This parameter applies only when **DBType** is **MySQL**.', example='1'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parameterGroupId?: string(name='ParameterGroupId', description='Parameter template ID.

> You can view the list of parameter templates in the target region, including the parameter template ID, by calling the [DescribeParameterGroups](https://help.aliyun.com/document_detail/207178.html) interface.', example='pcpg-**************'),
  payType?: string(name='PayType', description='Payment type, with available values as follows:

- **Postpaid**: Pay-as-you-go.
- **Prepaid**: Subscription (monthly or yearly).

This parameter is required.', example='Postpaid'),
  period?: string(name='Period', description='If the payment type is **Prepaid**, this parameter is required. It specifies whether the prepaid cluster is on a monthly or yearly basis.

- **Year**: Yearly subscription.
- **Month**: Monthly subscription.', example='Month'),
  provisionedIops?: long(name='ProvisionedIops', description='<p id="p_wyg_t4a_glm">The provisioned read and write IOPS for ESSD AutoPL cloud disks. Possible values: 0 to min{50,000, 1000*capacity-Baseline Performance}.</p>
<p id="p_6de_jxy_k2g">Baseline Performance = min{1,800+50*capacity, 50000}.</p>
<note id="note_7kj_j0o_rgs">This parameter is supported only when StorageType is ESSDAUTOPL.</note>', example='1000'),
  proxyClass?: string(name='ProxyClass', description='Standard edition database proxy specifications. Values are as follows:

- **polar.maxscale.g2.medium.c**: 2 cores.
- **polar.maxscale.g2.large.c**: 4 cores.
- **polar.maxscale.g2.xlarge.c**: 8 cores.
- **polar.maxscale.g2.2xlarge.c**: 16 cores.
- **polar.maxscale.g2.3xlarge.c**: 24 cores.
- **polar.maxscale.g2.4xlarge.c**: 32 cores.
- **polar.maxscale.g2.8xlarge.c**: 64 cores.', example='polar.maxscale.g2.medium.c'),
  proxyType?: string(name='ProxyType', description='Database proxy type, with values including:
- **EXCLUSIVE**: Enterprise Exclusive Edition
- **GENERAL**: Enterprise General Purpose Edition
> The proxy type must match the type of the cluster\\\\"s node specifications, i.e.,
>- If the node specification is general, the proxy type should be Enterprise General Purpose Edition;
>- If the node specification is dedicated, the proxy type should be Enterprise Exclusive Edition.', example='Exclusive'),
  regionId?: string(name='RegionId', description='Region ID.

> You can view available regions through the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) interface.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='Resource group ID.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scaleMax?: string(name='ScaleMax', description='Maximum scaling limit for a single node. The value range is: 1 PCU~32 PCU.

> Only supported by Serverless clusters.', example='3'),
  scaleMin?: string(name='ScaleMin', description='Minimum scaling limit for a single node. The value range is: 1 PCU~31 PCU.

> Only supported by Serverless clusters.', example='1'),
  scaleRoNumMax?: string(name='ScaleRoNumMax', description='Maximum scaling limit for the number of read-only nodes. The value range is: 0~15.

> Only supported by Serverless clusters.', example='4'),
  scaleRoNumMin?: string(name='ScaleRoNumMin', description='Minimum scaling limit for the number of read-only nodes. The value range is: 0~15.

> Only supported by Serverless clusters.', example='2'),
  securityIPList?: string(name='SecurityIPList', description='PolarDB cluster whitelist IP address.
> Supports configuring multiple whitelist IP addresses, with English commas separating multiple IP addresses.', example='10.***.***.***'),
  serverlessType?: string(name='ServerlessType', description='Serverless type. The current value is fixed to **AgileServerless** (sensitive mode).
> This parameter is only supported by Serverless clusters.', example='AgileServerless'),
  sourceResourceId?: string(name='SourceResourceId', description='Source RDS instance ID or source PolarDB cluster ID. This parameter is mandatory only when **CreationOption** is set to **MigrationFromRDS**, **CloneFromRDS**, **CloneFromPolarDB**, or **RecoverFromRecyclebin**.
* If **CreationOption** is **MigrationFromRDS** or **CloneFromRDS**, you need to input the source RDS instance ID. The source RDS instance version must be RDS MySQL 5.6, 5.7, or 8.0 High Availability edition.

* If **CreationOption** is **CloneFromPolarDB**, you need to input the source PolarDB cluster ID. The DBType of the cloned cluster will default to match the source cluster. For example, if the source cluster is MySQL 8.0, the cloned cluster must also have **DBType** set to **MySQL** and **DBVersion** to **8.0**.

* If **CreationOption** is **RecoverFromRecyclebin**, you need to input the released source PolarDB cluster ID. The DBType of the cluster being recovered from the recycle bin must match the source cluster. For example, if the source cluster was MySQL 8.0, the recovered cluster must also have **DBType** set to **MySQL** and **DBVersion** to **8.0**.', example='rm-*************'),
  sourceUid?: long(name='SourceUid', example='1022xxxxxxxx'),
  standbyAZ?: string(name='StandbyAZ', description='The availability zone where the hot standby cluster is stored. Applicable to the standard edition 3AZ scenario.

> This parameter takes effect only when multi-zone data strong consistency is enabled.', example='cn-hangzhou-g'),
  storageAutoScale?: string(name='StorageAutoScale', description='Whether to enable automatic storage expansion for standard edition clusters, with valid values as follows:

- Enable: Enables automatic storage expansion.
- Disable: Disables automatic storage expansion.', example='Enable'),
  storageEncryption?: boolean(name='StorageEncryption', description='Specifies whether to enable disk encryption. Valid values:

*   **true**
*   **false** (default)

>  This parameter takes effect only when **DBType** is set to **MySQL**.

>  This parameter takes effect only when **StorageType** is set to one of the Standard Edition storage types.'),
  storageEncryptionKey?: string(name='StorageEncryptionKey', description='The ID of the custom key that is used for disk encryption in the region in which the instance resides. If this parameter is specified, disk encryption is automatically enabled and cannot be disabled afterwards. If you want to use the default service key for disk encryption, leave this parameter empty.

You can obtain the ID of the key in the KMS console or create a key.

>  This parameter takes effect only when **DBType** is set to **MySQL**.

>  This parameter takes effect only when **StorageType** is set to one of the Standard Edition storage types.'),
  storagePayType?: string(name='StoragePayType', description='The storage billing type, with valid values as follows:

- Postpaid: Pay-as-you-go (hourly).
- Prepaid: Pay-per-use based on space (subscription).', example='Prepaid'),
  storageSpace?: long(name='StorageSpace', description='The storage that is billed based on the subscription billing method. Unit: GB.

> 

*   Valid values for the subscription storage capacity of a PolarDB for MySQL Standard Edition cluster: 20 to 32000.

*   Valid values for the subscription storage capacity of a Standard Edition cluster that uses the ESSD AUTOPL storage type: 40 to 64000, in increments of 10.', example='50'),
  storageType?: string(name='StorageType', description='Enterprise edition storage types include:
- **PSL5**
- **PSL4**

Standard edition storage types include:
- **ESSDPL0**
- **ESSDPL1**
- **ESSDPL2**
- **ESSDPL3**
- **ESSDAUTOPL**', example='PSL4'),
  storageUpperBound?: long(name='StorageUpperBound', description='Set the upper limit for automatic storage expansion of standard edition clusters, in GB.

> The maximum value is 32000.', example='800'),
  strictConsistency?: string(name='StrictConsistency', description='Whether the cluster has enabled strong data consistency across multiple zones. Values are as follows:

- **ON**: Indicates strong data consistency across multiple zones is enabled, applicable to the standard edition 3AZ scenario.

- **OFF**: Indicates strong data consistency across multiple zones is not enabled.', example='ON'),
  TDEStatus?: boolean(name='TDEStatus', description='Enables TDE encryption. Valid values are as follows:

- **true**: Enabled.
- **false**: Disabled (default).

> * This parameter takes effect only when **DBType** is **PostgreSQL** or **Oracle**.
> * You can call the [ModifyDBClusterTDE](https://help.aliyun.com/document_detail/167982.html) interface to enable TDE encryption for a PolarDB MySQL cluster.
> * Once the TDE feature is enabled, it cannot be disabled.', example='true'),
  tag?: [ 
    {
      key?: string(name='Key', description='Tag key. If you need to add multiple tags to the target cluster at once, click **Add** to add a tag key.

> Up to 20 pairs of tags can be added each time, where `Tag.N.Key` corresponds to `Tag.N.Value`.', example='type'),
      value?: string(name='Value', description='Tag value. If you need to add multiple tags to the target cluster at once, click **Add** to add tag values.

> Up to 20 pairs of tags can be added each time, where `Tag.N.Value` corresponds to `Tag.N.Key`.', example='test'),
    }
  ](name='Tag', description='List of tags.'),
  targetMinorVersion?: string(name='TargetMinorVersion'),
  usedTime?: string(name='UsedTime', description='If the payment type is **Prepaid**, this parameter is required.
- When **Period** is **Month**, **UsedTime** should be an integer within `[1-9]`.
- When **Period** is **Year**, **UsedTime** should be an integer within `[1-3]`.', example='1'),
  VPCId?: string(name='VPCId', description='VPC ID.', example='vpc-**********'),
  vSwitchId?: string(name='VSwitchId', description='Virtual switch ID.

> If VPCId has been selected, VSwitchId is mandatory.', example='vsw-**********'),
  zoneId?: string(name='ZoneId', description='Availability Zone ID.

> You can view the available zones through the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) interface.', example='cn-hangzhou-j'),
}

model CreateDBClusterResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='Cluster ID.', example='pc-bp1s826a1up******'),
  orderId?: string(name='OrderId', description='Order ID.', example='211454967******'),
  requestId?: string(name='RequestId', description='Request ID.', example='E56531A4-E552-40BA-9C58-137B80******'),
  resourceGroupId?: string(name='ResourceGroupId', description='Resource group ID.', example='rg-***************'),
}

model CreateDBClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDBClusterResponseBody(name='body'),
}

/**
 * @summary CreateDBCluster.
 *
 * @param request CreateDBClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDBClusterResponse
 */
async function createDBClusterWithOptions(request: CreateDBClusterRequest, runtime: Util.RuntimeOptions): CreateDBClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allowShutDown)) {
    query['AllowShutDown'] = request.allowShutDown;
  }
  if (!Util.isUnset(request.architecture)) {
    query['Architecture'] = request.architecture;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.backupRetentionPolicyOnClusterDeletion)) {
    query['BackupRetentionPolicyOnClusterDeletion'] = request.backupRetentionPolicyOnClusterDeletion;
  }
  if (!Util.isUnset(request.burstingEnabled)) {
    query['BurstingEnabled'] = request.burstingEnabled;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.cloneDataPoint)) {
    query['CloneDataPoint'] = request.cloneDataPoint;
  }
  if (!Util.isUnset(request.cloudProvider)) {
    query['CloudProvider'] = request.cloudProvider;
  }
  if (!Util.isUnset(request.clusterNetworkType)) {
    query['ClusterNetworkType'] = request.clusterNetworkType;
  }
  if (!Util.isUnset(request.creationCategory)) {
    query['CreationCategory'] = request.creationCategory;
  }
  if (!Util.isUnset(request.creationOption)) {
    query['CreationOption'] = request.creationOption;
  }
  if (!Util.isUnset(request.DBClusterDescription)) {
    query['DBClusterDescription'] = request.DBClusterDescription;
  }
  if (!Util.isUnset(request.DBMinorVersion)) {
    query['DBMinorVersion'] = request.DBMinorVersion;
  }
  if (!Util.isUnset(request.DBNodeClass)) {
    query['DBNodeClass'] = request.DBNodeClass;
  }
  if (!Util.isUnset(request.DBNodeNum)) {
    query['DBNodeNum'] = request.DBNodeNum;
  }
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.defaultTimeZone)) {
    query['DefaultTimeZone'] = request.defaultTimeZone;
  }
  if (!Util.isUnset(request.ensRegionId)) {
    query['EnsRegionId'] = request.ensRegionId;
  }
  if (!Util.isUnset(request.GDNId)) {
    query['GDNId'] = request.GDNId;
  }
  if (!Util.isUnset(request.hotStandbyCluster)) {
    query['HotStandbyCluster'] = request.hotStandbyCluster;
  }
  if (!Util.isUnset(request.loosePolarLogBin)) {
    query['LoosePolarLogBin'] = request.loosePolarLogBin;
  }
  if (!Util.isUnset(request.looseXEngine)) {
    query['LooseXEngine'] = request.looseXEngine;
  }
  if (!Util.isUnset(request.looseXEngineUseMemoryPct)) {
    query['LooseXEngineUseMemoryPct'] = request.looseXEngineUseMemoryPct;
  }
  if (!Util.isUnset(request.lowerCaseTableNames)) {
    query['LowerCaseTableNames'] = request.lowerCaseTableNames;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupId)) {
    query['ParameterGroupId'] = request.parameterGroupId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.provisionedIops)) {
    query['ProvisionedIops'] = request.provisionedIops;
  }
  if (!Util.isUnset(request.proxyClass)) {
    query['ProxyClass'] = request.proxyClass;
  }
  if (!Util.isUnset(request.proxyType)) {
    query['ProxyType'] = request.proxyType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scaleMax)) {
    query['ScaleMax'] = request.scaleMax;
  }
  if (!Util.isUnset(request.scaleMin)) {
    query['ScaleMin'] = request.scaleMin;
  }
  if (!Util.isUnset(request.scaleRoNumMax)) {
    query['ScaleRoNumMax'] = request.scaleRoNumMax;
  }
  if (!Util.isUnset(request.scaleRoNumMin)) {
    query['ScaleRoNumMin'] = request.scaleRoNumMin;
  }
  if (!Util.isUnset(request.securityIPList)) {
    query['SecurityIPList'] = request.securityIPList;
  }
  if (!Util.isUnset(request.serverlessType)) {
    query['ServerlessType'] = request.serverlessType;
  }
  if (!Util.isUnset(request.sourceResourceId)) {
    query['SourceResourceId'] = request.sourceResourceId;
  }
  if (!Util.isUnset(request.sourceUid)) {
    query['SourceUid'] = request.sourceUid;
  }
  if (!Util.isUnset(request.standbyAZ)) {
    query['StandbyAZ'] = request.standbyAZ;
  }
  if (!Util.isUnset(request.storageAutoScale)) {
    query['StorageAutoScale'] = request.storageAutoScale;
  }
  if (!Util.isUnset(request.storageEncryption)) {
    query['StorageEncryption'] = request.storageEncryption;
  }
  if (!Util.isUnset(request.storageEncryptionKey)) {
    query['StorageEncryptionKey'] = request.storageEncryptionKey;
  }
  if (!Util.isUnset(request.storagePayType)) {
    query['StoragePayType'] = request.storagePayType;
  }
  if (!Util.isUnset(request.storageSpace)) {
    query['StorageSpace'] = request.storageSpace;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  if (!Util.isUnset(request.storageUpperBound)) {
    query['StorageUpperBound'] = request.storageUpperBound;
  }
  if (!Util.isUnset(request.strictConsistency)) {
    query['StrictConsistency'] = request.strictConsistency;
  }
  if (!Util.isUnset(request.TDEStatus)) {
    query['TDEStatus'] = request.TDEStatus;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.targetMinorVersion)) {
    query['TargetMinorVersion'] = request.targetMinorVersion;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary CreateDBCluster.
 *
 * @param request CreateDBClusterRequest
 * @return CreateDBClusterResponse
 */
async function createDBCluster(request: CreateDBClusterRequest): CreateDBClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBClusterWithOptions(request, runtime);
}

model CreateDBClusterEndpointRequest {
  autoAddNewNodes?: string(name='AutoAddNewNodes', description='Specifies whether to enable automatic association of newly added nodes with the cluster endpoint. Valid values:

*   **Enable**
*   **Disable** (default)', example='Disable'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f******************'),
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-**************'),
  DBEndpointDescription?: string(name='DBEndpointDescription', description='The name of the custom cluster endpoint.', example='test'),
  endpointConfig?: string(name='EndpointConfig', description='The advanced configurations of the cluster endpoint. You must specify the configurations in the JSON format. You can specify the configurations of the following attributes: consistency level, transaction splitting, connection pool, and offload reads from the primary node.

*   Specify the consistency level in the format of `{"ConsistLevel":"Consistency level"}`. Default value: 1. Valid values:

    *   **0**: eventual consistency.
    *   **1**: session consistency.
    *   **2**: global consistency.

*   Specify the transaction splitting feature in the format of `{"DistributedTransaction":"Transaction splitting"}`. Valid values:

    *   **on**: enables the transaction splitting feature. By default, the feature is enabled.
    *   **off**: disables the transaction splitting feature.

*   Specify the offload reads from the primary node feature in the format of `{"MasterAcceptReads":"Offload reads from the primary node"}`. Default value: off. Valid values:

    *   **on**: The primary node accepts read requests.
    *   **off**: The primary node does not accept read requests.

*   Specify the connection pool in the format of `{"ConnectionPersist":"Connection pool"}`. Default value: off. Valid values:

    *   **off**: disables the connection pool.
    *   **Session**: enables the session-level connection pool.
    *   **Transaction**: enables the transaction-level connection pool.

>- You can specify the transaction splitting, connection pool, and offload reads from the primary node features for a PolarDB for MySQL cluster only if ReadWriteMode is set to ReadWrite for the cluster endpoint.
>- Only PolarDB for MySQL supports global consistency.
>- If the **ReadWriteMode** parameter is set to **ReadOnly**, the consistency level must be **0**.
>- You can use one record to specify the consistency level, transaction splitting, connection pool, and offload reads from the primary node features, such as `{"ConsistLevel":"1","DistributedTransaction":"on","ConnectionPersist":"Session","MasterAcceptReads":"on"}`.
>- The transaction splitting settings are restricted by the consistency level settings. For example, if you set the consistency level to **0**, transaction splitting cannot be enabled. If you set the consistency level to **1** or **2**, transaction splitting can be enabled.', example='{"ConsistLevel": "1","DistributedTransaction": "on"}'),
  endpointType?: string(name='EndpointType', description='The type of the cluster endpoint. Set the value to **Custom**.

This parameter is required.', example='Custom'),
  nodes?: string(name='Nodes', description='The reader nodes that you want to associate with the endpoint. If you want to specify multiple reader nodes, separate the reader nodes with commas (,). If you do not specify this parameter, all nodes are used.

>- You need to specify the node IDs for a PolarDB for MySQL cluster.
>- You need to specify the role name of each node for a PolarDB for PostgreSQL cluster or a PolarDB for PostgreSQL (Compatible with Oracle) cluster. Example: `Writer, Reader1, Reader2`.
>- If you set **ReadWriteMode** to **ReadOnly**, you can associate only one node with the endpoint. If the only node becomes faulty, the cluster endpoint may be unavailable for up to 1 hour. We recommend that you associate more than one node with the cluster endpoint in production environments. We recommend that you associate at least two nodes with the cluster endpoint to improve service availability.
>- If you set **ReadWriteMode** to **ReadWrite**, you need to associate at least two nodes with the cluster endpoint.
>- PolarDB for MySQL does not impose a limit on the types of the two nodes. If the nodes are read-only nodes, write requests are forwarded to the primary node. 
>- PolarDB for PostgreSQL and PolarDB for PostgreSQL (compatible with Oracle) require a primary node.', example='pi-**********,pi-*********'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  polarFsInstanceId?: string(name='PolarFsInstanceId', example='pfs-test****'),
  polarSccTimeoutAction?: string(name='PolarSccTimeoutAction', description='Global consistency timeout strategy. The value range is as follows:
- **0**: Send the request to the primary node
- **2**: Timeout degradation, when a global consistency read times out, the query operation will automatically degrade to an inconsistent read, and the client will not receive an error message', example='0'),
  polarSccWaitTimeout?: string(name='PolarSccWaitTimeout', description='Global consistency timeout', example='100'),
  readWriteMode?: string(name='ReadWriteMode', description='The read/write mode. Valid values:

*   **ReadWrite**: receives and forwards read and write requests. Automatic read/write splitting is enabled.
*   **ReadOnly**: The account has the read-only permissions on the database.

Default value: **ReadOnly**.', example='ReadOnly'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sccMode?: string(name='SccMode', description='Specifies whether to enable the global consistency (high-performance mode) feature for the nodes. Valid values:

*   **ON**
*   **OFF**', example='on'),
}

model CreateDBClusterEndpointResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CD35F3-F3-44CA-AFFF-BAF869******'),
}

model CreateDBClusterEndpointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDBClusterEndpointResponseBody(name='body'),
}

/**
 * @summary Creates a custom cluster endpoint for a PolarDB cluster.
 *
 * @param request CreateDBClusterEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDBClusterEndpointResponse
 */
async function createDBClusterEndpointWithOptions(request: CreateDBClusterEndpointRequest, runtime: Util.RuntimeOptions): CreateDBClusterEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoAddNewNodes)) {
    query['AutoAddNewNodes'] = request.autoAddNewNodes;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointDescription)) {
    query['DBEndpointDescription'] = request.DBEndpointDescription;
  }
  if (!Util.isUnset(request.endpointConfig)) {
    query['EndpointConfig'] = request.endpointConfig;
  }
  if (!Util.isUnset(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!Util.isUnset(request.nodes)) {
    query['Nodes'] = request.nodes;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.polarFsInstanceId)) {
    query['PolarFsInstanceId'] = request.polarFsInstanceId;
  }
  if (!Util.isUnset(request.polarSccTimeoutAction)) {
    query['PolarSccTimeoutAction'] = request.polarSccTimeoutAction;
  }
  if (!Util.isUnset(request.polarSccWaitTimeout)) {
    query['PolarSccWaitTimeout'] = request.polarSccWaitTimeout;
  }
  if (!Util.isUnset(request.readWriteMode)) {
    query['ReadWriteMode'] = request.readWriteMode;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sccMode)) {
    query['SccMode'] = request.sccMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBClusterEndpoint',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a custom cluster endpoint for a PolarDB cluster.
 *
 * @param request CreateDBClusterEndpointRequest
 * @return CreateDBClusterEndpointResponse
 */
async function createDBClusterEndpoint(request: CreateDBClusterEndpointRequest): CreateDBClusterEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBClusterEndpointWithOptions(request, runtime);
}

model CreateDBClusterEndpointZonalRequest {
  autoAddNewNodes?: string(name='AutoAddNewNodes', example='Disable'),
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f******************'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-***************'),
  DBEndpointDescription?: string(name='DBEndpointDescription', example='test'),
  endpointConfig?: string(name='EndpointConfig', example='{"ConsistLevel": "1","DistributedTransaction": "on"}'),
  endpointType?: string(name='EndpointType', description='This parameter is required.', example='Custom'),
  nodes?: string(name='Nodes', example='pi-**************,pi-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  polarSccTimeoutAction?: string(name='PolarSccTimeoutAction', example='0'),
  polarSccWaitTimeout?: string(name='PolarSccWaitTimeout', example='100'),
  readWriteMode?: string(name='ReadWriteMode', example='ReadOnly'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sccMode?: string(name='SccMode', example='on'),
}

model CreateDBClusterEndpointZonalResponseBody = {
  requestId?: string(name='RequestId', example='CD35F3-F3-44CA-AFFF-BAF869******'),
}

model CreateDBClusterEndpointZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDBClusterEndpointZonalResponseBody(name='body'),
}

/**
 * @summary 边缘云创建链接地址接口
 *
 * @param request CreateDBClusterEndpointZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDBClusterEndpointZonalResponse
 */
async function createDBClusterEndpointZonalWithOptions(request: CreateDBClusterEndpointZonalRequest, runtime: Util.RuntimeOptions): CreateDBClusterEndpointZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoAddNewNodes)) {
    query['AutoAddNewNodes'] = request.autoAddNewNodes;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointDescription)) {
    query['DBEndpointDescription'] = request.DBEndpointDescription;
  }
  if (!Util.isUnset(request.endpointConfig)) {
    query['EndpointConfig'] = request.endpointConfig;
  }
  if (!Util.isUnset(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!Util.isUnset(request.nodes)) {
    query['Nodes'] = request.nodes;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.polarSccTimeoutAction)) {
    query['PolarSccTimeoutAction'] = request.polarSccTimeoutAction;
  }
  if (!Util.isUnset(request.polarSccWaitTimeout)) {
    query['PolarSccWaitTimeout'] = request.polarSccWaitTimeout;
  }
  if (!Util.isUnset(request.readWriteMode)) {
    query['ReadWriteMode'] = request.readWriteMode;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sccMode)) {
    query['SccMode'] = request.sccMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBClusterEndpointZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 边缘云创建链接地址接口
 *
 * @param request CreateDBClusterEndpointZonalRequest
 * @return CreateDBClusterEndpointZonalResponse
 */
async function createDBClusterEndpointZonal(request: CreateDBClusterEndpointZonalRequest): CreateDBClusterEndpointZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBClusterEndpointZonalWithOptions(request, runtime);
}

model CreateDBEndpointAddressRequest {
  connectionStringPrefix?: string(name='ConnectionStringPrefix', description='The prefix of the new endpoint. The prefix of the endpoint must meet the following requirements:

*   The prefix can contain lowercase letters, digits, and hyphens (-).
*   The prefix must start with a letter and end with a digit or a letter.
*   The prefix must be 6 to 40 characters in length.', example='test-1'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-**************'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.

>  You can call the [DescribeDBClusterEndpoints](https://help.aliyun.com/document_detail/98205.html) operation to query endpoint details.

This parameter is required.', example='pe-**************'),
  netType?: string(name='NetType', description='The network type of the endpoint. Set the value to **Public**.

This parameter is required.', example='Public'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the ECS security group.', example='sg-bp**************'),
  VPCId?: string(name='VPCId', description='The ID of the virtual private cloud (VPC).', example='vpc-**********'),
  zoneInfo?: [ 
    {
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-**********'),
      zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-b'),
    }
  ](name='ZoneInfo', description='The details of the zones.'),
}

model CreateDBEndpointAddressResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6BD9CDE4-5E7B-4BF3-9BB8-83C73E******'),
}

model CreateDBEndpointAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDBEndpointAddressResponseBody(name='body'),
}

/**
 * @summary Creates a public endpoint for the primary endpoint, the default cluster endpoint, or a custom cluster endpoint.
 *
 * @description > You can create a public endpoint for the primary endpoint, the default cluster endpoint, or a custom cluster endpoint.
 *
 * @param request CreateDBEndpointAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDBEndpointAddressResponse
 */
async function createDBEndpointAddressWithOptions(request: CreateDBEndpointAddressRequest, runtime: Util.RuntimeOptions): CreateDBEndpointAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionStringPrefix)) {
    query['ConnectionStringPrefix'] = request.connectionStringPrefix;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.zoneInfo)) {
    query['ZoneInfo'] = request.zoneInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBEndpointAddress',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a public endpoint for the primary endpoint, the default cluster endpoint, or a custom cluster endpoint.
 *
 * @description > You can create a public endpoint for the primary endpoint, the default cluster endpoint, or a custom cluster endpoint.
 *
 * @param request CreateDBEndpointAddressRequest
 * @return CreateDBEndpointAddressResponse
 */
async function createDBEndpointAddress(request: CreateDBEndpointAddressRequest): CreateDBEndpointAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBEndpointAddressWithOptions(request, runtime);
}

model CreateDBLinkRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the source cluster that the database link connects.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/173433.html) operation to query PolarDB clusters.

This parameter is required.', example='pc-a************'),
  DBLinkName?: string(name='DBLinkName', description='The name of the database link.

*   The name must contain lowercase letters and can also contain digits and underscores (_).
*   The name must start with a letter and end with a letter or digit.
*   The name must be 1 to 64 characters in length.

This parameter is required.', example='dblink_test'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region.

>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query information about regions.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceDBName?: string(name='SourceDBName', description='The name of the source database.

>  You can call the [DescribeDatabases](https://help.aliyun.com/document_detail/173558.html) operation to query information about databases in a PolarDB cluster.

This parameter is required.', example='testdb1'),
  targetDBAccount?: string(name='TargetDBAccount', description='The account of the destination database.

>  You can call the [DescribeAccounts](https://help.aliyun.com/document_detail/173549.html) operation to query the account of a PolarDB cluster.

This parameter is required.', example='testacc'),
  targetDBInstanceName?: string(name='TargetDBInstanceName', description='The ID of the destination cluster that the database link connects.

> *   If the destination cluster is a user-created Oracle database on an ECS instance, set the value to `null`.
> *   You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/173433.html) operation to query PolarDB clusters.', example='pc-b************'),
  targetDBName?: string(name='TargetDBName', description='The name of the destination database.

>  You can call the [DescribeDatabases](https://help.aliyun.com/document_detail/173558.html) operation to query information about databases in a PolarDB cluster.

This parameter is required.', example='testdb2'),
  targetDBPasswd?: string(name='TargetDBPasswd', description='The account password of the destination database.

This parameter is required.', example='Test1111'),
  targetIp?: string(name='TargetIp', description='The IP address of the user-created Oracle database on an ECS instance.', example='192.**.**.46'),
  targetPort?: string(name='TargetPort', description='The port number of the user-created Oracle database on an ECS instance.', example='1521'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).

>  You can call the [DescribeVpcs](https://help.aliyun.com/document_detail/35739.html) operation to query information about VPCs.', example='vpc-bp1qpo0kug3a20qqe****'),
}

model CreateDBLinkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F9F1CB1A-B1D5-4EF5-A53A-************'),
}

model CreateDBLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDBLinkResponseBody(name='body'),
}

/**
 * @summary Creates a database link.
 *
 * @description A database link can be used to connect two PolarDB for PostgreSQL(Compatible with Oracle) clusters, or connect a PolarDB for PostgreSQL(Compatible with Oracle) cluster to a user-created PostgreSQL database that is hosted on an Elastic Compute Service (ECS) instance. You can use database links to query data across clusters.
 * > *   You can create up to 10 database links for a cluster.
 * > *   Each database link connects a source cluster and a destination cluster.
 * > *   The source cluster and the destination cluster or the destination ECS instance must be located in the same region.
 *
 * @param request CreateDBLinkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDBLinkResponse
 */
async function createDBLinkWithOptions(request: CreateDBLinkRequest, runtime: Util.RuntimeOptions): CreateDBLinkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBLinkName)) {
    query['DBLinkName'] = request.DBLinkName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceDBName)) {
    query['SourceDBName'] = request.sourceDBName;
  }
  if (!Util.isUnset(request.targetDBAccount)) {
    query['TargetDBAccount'] = request.targetDBAccount;
  }
  if (!Util.isUnset(request.targetDBInstanceName)) {
    query['TargetDBInstanceName'] = request.targetDBInstanceName;
  }
  if (!Util.isUnset(request.targetDBName)) {
    query['TargetDBName'] = request.targetDBName;
  }
  if (!Util.isUnset(request.targetDBPasswd)) {
    query['TargetDBPasswd'] = request.targetDBPasswd;
  }
  if (!Util.isUnset(request.targetIp)) {
    query['TargetIp'] = request.targetIp;
  }
  if (!Util.isUnset(request.targetPort)) {
    query['TargetPort'] = request.targetPort;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBLink',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a database link.
 *
 * @description A database link can be used to connect two PolarDB for PostgreSQL(Compatible with Oracle) clusters, or connect a PolarDB for PostgreSQL(Compatible with Oracle) cluster to a user-created PostgreSQL database that is hosted on an Elastic Compute Service (ECS) instance. You can use database links to query data across clusters.
 * > *   You can create up to 10 database links for a cluster.
 * > *   Each database link connects a source cluster and a destination cluster.
 * > *   The source cluster and the destination cluster or the destination ECS instance must be located in the same region.
 *
 * @param request CreateDBLinkRequest
 * @return CreateDBLinkResponse
 */
async function createDBLink(request: CreateDBLinkRequest): CreateDBLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBLinkWithOptions(request, runtime);
}

model CreateDBNodesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  cloudProvider?: string(name='CloudProvider', example='ENS'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-*************'),
  DBNode?: [ 
    {
      targetClass?: string(name='TargetClass', description='The specifications of the read-only node that you want to add, which must be the same as the specifications of the existing nodes. For more information, see the following topics:

*   PolarDB for MySQL: [Specifications of compute nodes](https://help.aliyun.com/document_detail/102542.html)
*   PolarDB for PostgreSQL (Compatible with Oracle): [Specifications of compute nodes](https://help.aliyun.com/document_detail/207921.html)
*   PolarDB for PostgreSQL: [Specifications of compute nodes](https://help.aliyun.com/document_detail/209380.html)

>- You need to specify either DBNode.N.ZoneId or DBNode.N.TargetClass. N is an integer that starts from 1. The maximum value of N is equal to 16 minus the number of existing nodes.
>- You can add multiple read-only nodes at the same time only to PolarDB for MySQL clusters, which can contain up to of 15 read-only nodes.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters. This parameter is optional for PolarDB for MySQL clusters.', example='polar.mysql.x4.medium'),
      zoneId?: string(name='ZoneId', description='The zone ID of the node that you want to add, which must be the same as the zone ID of existing nodes. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the IDs of zones.

>- You need to specify either DBNode.N.ZoneId or DBNode.N.TargetClass. N is an integer that starts from 1. The maximum value of N is equal to 16 minus the number of existing nodes.
>- You can add multiple read-only nodes at the same time only to PolarDB for MySQL clusters, which can contain up to of 15 read-only nodes.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters. This parameter is optional for PolarDB for MySQL clusters.', example='cn-qingdao-c'),
    }
  ](name='DBNode', description='The details of the read-only node.

This parameter is required.'),
  DBNodeType?: string(name='DBNodeType', description='The node type. Valid values:

*   RO
*   STANDBY
*   DLNode

Enumerated values:

*   DLNode: AI node
*   STANDBY: standby node
*   RO: read-only node', example='RO'),
  endpointBindList?: string(name='EndpointBindList', description='The ID of the cluster endpoint to which the read-only node is added. If you want to add the read-only node to multiple endpoints at the same time, separate the endpoint IDs with commas (,).
> - You can call the [DescribeDBClusterEndpoints](https://help.aliyun.com/document_detail/98205.html) operation to query the details of cluster endpoints, including endpoint IDs.
>- You can enter the ID of the default cluster endpoint or a custom cluster endpoint.
>- If you leave this parameter empty, the read-only node is added to all cluster endpoints for which the **Automatically Associate New Nodes** feature is enabled. If you set `AutoAddNewNodes` to `Enable`, the Automatically Associate New Nodes feature is enabled.', example='pe-****************,pe-****************'),
  imciSwitch?: string(name='ImciSwitch', description='Specifies whether to enable the In-Memory Column Index (IMCI) feature. Default value: OFF. Valid values:

*   **ON**
*   **OFF**

> This parameter is invalid for a PolarDB for Oracle or PolarDB for PostgreSQL cluster.', example='ON'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time for upgrading the specifications within the scheduled time period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

>- The value of this parameter must be at least 30 minutes later than the value of PlannedStartTime.
>- If you specify `PlannedStartTime` but do not specify PlannedEndTime, the latest start time of the task is set to a value that is calculated by using the following formula: `PlannedEndTime value + 30 minutes`. For example, if you set `PlannedStartTime` to `2021-01-14T09:00:00Z` and you do not specify PlannedEndTime, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time of the scheduled task for adding the read-only node. The scheduled task specifies that the task is run in the required period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

>- The earliest start time of the scheduled task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in time between `2021-01-14T09:00:00Z` and `2021-01-15T09:00:00Z`.
>- If you leave this parameter empty, the task for adding the read-only node is immediately run by default.', example='2021-01-14T09:00:00Z'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateDBNodesResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-***************'),
  DBNodeIds?: {
    DBNodeId?: [ string ](name='DBNodeId')
  }(name='DBNodeIds', description='Details about the nodes.'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2148126708*****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E053E730-5755-4AA9-AA9D-A47867******'),
}

model CreateDBNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDBNodesResponseBody(name='body'),
}

/**
 * @summary Adds a read-only node to a PolarDB cluster.
 *
 * @param request CreateDBNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDBNodesResponse
 */
async function createDBNodesWithOptions(request: CreateDBNodesRequest, runtime: Util.RuntimeOptions): CreateDBNodesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.cloudProvider)) {
    query['CloudProvider'] = request.cloudProvider;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNode)) {
    query['DBNode'] = request.DBNode;
  }
  if (!Util.isUnset(request.DBNodeType)) {
    query['DBNodeType'] = request.DBNodeType;
  }
  if (!Util.isUnset(request.endpointBindList)) {
    query['EndpointBindList'] = request.endpointBindList;
  }
  if (!Util.isUnset(request.imciSwitch)) {
    query['ImciSwitch'] = request.imciSwitch;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBNodes',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds a read-only node to a PolarDB cluster.
 *
 * @param request CreateDBNodesRequest
 * @return CreateDBNodesResponse
 */
async function createDBNodes(request: CreateDBNodesRequest): CreateDBNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBNodesWithOptions(request, runtime);
}

model CreateDatabaseRequest {
  accountName?: string(name='AccountName', description='The name of the account that is authorized to access the database. You can call the [DescribeAccounts](https://help.aliyun.com/document_detail/98107.html) operation to query account information.
>- You can specify only a standard account. By default, privileged accounts have all permissions on all databases. You do not need to grant privileged accounts the permissions to access the database.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters. This parameter is optional for PolarDB for MySQL clusters.', example='testacc'),
  accountPrivilege?: string(name='AccountPrivilege', description='The permissions that are granted to the account. Valid values:

*   **ReadWrite**: read and write permissions.
*   **ReadOnly**: read-only permissions.
*   **DMLOnly**: permissions only to execute DML statements on the database.
*   **DDLOnly**: permissions only to execute DDL statements on the database.
*   **ReadIndex**: read-only and index permissions.

The default value is **ReadWrite**.

> 

*   This parameter is valid only when the **AccountName** parameter is specified.

*   For a PolarDB for PostgreSQL (Compatible with Oracle) or PolarDB for PostgreSQL cluster, this parameter is optional. If **AccountName** is specified, it is the account of the database owner.

*   For a PolarDB for MySQL cluster, this parameter is optional.', example='ReadWrite'),
  characterSetName?: string(name='CharacterSetName', description='The character set that is used by the cluster. For more information, see [Character set tables](https://help.aliyun.com/document_detail/99716.html).

This parameter is required.', example='utf8'),
  collate?: string(name='Collate', description='The language that defines the collation rules in the database.

> 

*   The language must be compatible with the character set that is specified by **CharacterSetName**.

*   This parameter is required for a PolarDB for PostgreSQL (Compatible with Oracle) or PolarDB for PostgreSQL cluster. This parameter is optional for a PolarDB for MySQL cluster. To view the valid values of this parameter, perform the following steps: Log on to the PolarDB console and click the ID of the cluster. In the left-side navigation pane, choose **Settings and Management** > **Databases**. Then, click **Create Database**.', example='C'),
  ctype?: string(name='Ctype', description='The language that indicates the character type of the database.

>- The language must be compatible with the character set that is specified by **CharacterSetName**.
>- The value that you specify must be the same as the value of **Collate**.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters. This parameter is optional for PolarDB for MySQL clusters.

To view the valid values for this parameter, perform the following steps: Log on to the PolarDB console and click the ID of a cluster. In the left-side navigation pane, choose **Settings and Management** > **Databases**. Then, click **Create Database**.', example='C'),
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-**************'),
  DBDescription?: string(name='DBDescription', description='The description of the database. The description must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must be 2 to 256 characters in length.

> This parameter is required for a PolarDB for Oracle or PolarDB for PostgreSQL cluster. This parameter is optional for a PolarDB for MySQL cluster.', example='testdesc'),
  DBName?: string(name='DBName', description='The name of the database. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, hyphens (-), and underscores (_).
*   The name must start with a lowercase letter and end with a lowercase letter or a digit. The name must be 1 to 64 characters in length.

> Do not use reserved words as database names, such as `test` or `mysql`.

This parameter is required.', example='testDB'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateDatabaseResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='93E98F25-BE02-40DA-83E3-F77F8D******'),
}

model CreateDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDatabaseResponseBody(name='body'),
}

/**
 * @summary Creates a database for a PolarDB cluster.
 *
 * @description Before you call this operation, make sure that the following requirements are met:
 * *   The cluster is in the Running state.
 * *   The cluster is unlocked.
 *
 * @param request CreateDatabaseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDatabaseResponse
 */
async function createDatabaseWithOptions(request: CreateDatabaseRequest, runtime: Util.RuntimeOptions): CreateDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPrivilege)) {
    query['AccountPrivilege'] = request.accountPrivilege;
  }
  if (!Util.isUnset(request.characterSetName)) {
    query['CharacterSetName'] = request.characterSetName;
  }
  if (!Util.isUnset(request.collate)) {
    query['Collate'] = request.collate;
  }
  if (!Util.isUnset(request.ctype)) {
    query['Ctype'] = request.ctype;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBDescription)) {
    query['DBDescription'] = request.DBDescription;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDatabase',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a database for a PolarDB cluster.
 *
 * @description Before you call this operation, make sure that the following requirements are met:
 * *   The cluster is in the Running state.
 * *   The cluster is unlocked.
 *
 * @param request CreateDatabaseRequest
 * @return CreateDatabaseResponse
 */
async function createDatabase(request: CreateDatabaseRequest): CreateDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDatabaseWithOptions(request, runtime);
}

model CreateDatabaseZonalRequest {
  accountName?: string(name='AccountName', example='testacc'),
  accountPrivilege?: string(name='AccountPrivilege', example='ReadWrite'),
  characterSetName?: string(name='CharacterSetName', description='This parameter is required.', example='utf8'),
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  collate?: string(name='Collate', example='C'),
  ctype?: string(name='Ctype', example='C'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  DBDescription?: string(name='DBDescription', example='testdesc'),
  DBName?: string(name='DBName', description='This parameter is required.', example='testDB'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateDatabaseZonalResponseBody = {
  requestId?: string(name='RequestId', example='93E98F25-BE02-40DA-83E3-F77F8D******'),
}

model CreateDatabaseZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDatabaseZonalResponseBody(name='body'),
}

/**
 * @summary 创建PolarDB边缘云数据库
 *
 * @param request CreateDatabaseZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDatabaseZonalResponse
 */
async function createDatabaseZonalWithOptions(request: CreateDatabaseZonalRequest, runtime: Util.RuntimeOptions): CreateDatabaseZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPrivilege)) {
    query['AccountPrivilege'] = request.accountPrivilege;
  }
  if (!Util.isUnset(request.characterSetName)) {
    query['CharacterSetName'] = request.characterSetName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.collate)) {
    query['Collate'] = request.collate;
  }
  if (!Util.isUnset(request.ctype)) {
    query['Ctype'] = request.ctype;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBDescription)) {
    query['DBDescription'] = request.DBDescription;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDatabaseZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建PolarDB边缘云数据库
 *
 * @param request CreateDatabaseZonalRequest
 * @return CreateDatabaseZonalResponse
 */
async function createDatabaseZonal(request: CreateDatabaseZonalRequest): CreateDatabaseZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDatabaseZonalWithOptions(request, runtime);
}

model CreateExtensionsRequest {
  accountName?: string(name='AccountName', description='This parameter is required.'),
  clientToken?: string(name='ClientToken'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.'),
  DBNames?: string(name='DBNames', description='This parameter is required.'),
  extensions?: string(name='Extensions'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceDBName?: string(name='SourceDBName'),
  version?: string(name='Version', example='7.7'),
  vpcId?: string(name='VpcId'),
}

model CreateExtensionsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateExtensionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateExtensionsResponseBody(name='body'),
}

/**
 * @summary 创建插件
 *
 * @param request CreateExtensionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateExtensionsResponse
 */
async function createExtensionsWithOptions(request: CreateExtensionsRequest, runtime: Util.RuntimeOptions): CreateExtensionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNames)) {
    query['DBNames'] = request.DBNames;
  }
  if (!Util.isUnset(request.extensions)) {
    query['Extensions'] = request.extensions;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceDBName)) {
    query['SourceDBName'] = request.sourceDBName;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateExtensions',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建插件
 *
 * @param request CreateExtensionsRequest
 * @return CreateExtensionsResponse
 */
async function createExtensions(request: CreateExtensionsRequest): CreateExtensionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createExtensionsWithOptions(request, runtime);
}

model CreateGlobalDataNetworkRequest {
  description?: string(name='Description', example='mygdn'),
  destinationFileSystemPath?: string(name='DestinationFileSystemPath', example='/'),
  destinationId?: string(name='DestinationId', example='pfs-xxx'),
  destinationRegion?: string(name='DestinationRegion', example='cn-beijing'),
  destinationType?: string(name='DestinationType', example='pfs'),
  freezeSourceDuringSync?: string(name='FreezeSourceDuringSync', example='true'),
  sourceFileSystemPath?: string(name='SourceFileSystemPath', example='/'),
  sourceId?: string(name='SourceId', example='oss-xxx'),
  sourceRegion?: string(name='SourceRegion', example='cn-wulanchabu'),
  sourceType?: string(name='SourceType', example='oss'),
}

model CreateGlobalDataNetworkResponseBody = {
  channelId?: string(name='ChannelId', example='gdc-xxx'),
  networkId?: string(name='NetworkId', description='GDN ID', example='gdn-xxx'),
  requestId?: string(name='RequestId', example='6BD9CDE4-5E7B-4BF3-9BB8-83C73E******'),
}

model CreateGlobalDataNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateGlobalDataNetworkResponseBody(name='body'),
}

/**
 * @summary 创建全球数据网络
 *
 * @param request CreateGlobalDataNetworkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateGlobalDataNetworkResponse
 */
async function createGlobalDataNetworkWithOptions(request: CreateGlobalDataNetworkRequest, runtime: Util.RuntimeOptions): CreateGlobalDataNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.destinationFileSystemPath)) {
    query['DestinationFileSystemPath'] = request.destinationFileSystemPath;
  }
  if (!Util.isUnset(request.destinationId)) {
    query['DestinationId'] = request.destinationId;
  }
  if (!Util.isUnset(request.destinationRegion)) {
    query['DestinationRegion'] = request.destinationRegion;
  }
  if (!Util.isUnset(request.destinationType)) {
    query['DestinationType'] = request.destinationType;
  }
  if (!Util.isUnset(request.freezeSourceDuringSync)) {
    query['FreezeSourceDuringSync'] = request.freezeSourceDuringSync;
  }
  if (!Util.isUnset(request.sourceFileSystemPath)) {
    query['SourceFileSystemPath'] = request.sourceFileSystemPath;
  }
  if (!Util.isUnset(request.sourceId)) {
    query['SourceId'] = request.sourceId;
  }
  if (!Util.isUnset(request.sourceRegion)) {
    query['SourceRegion'] = request.sourceRegion;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGlobalDataNetwork',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建全球数据网络
 *
 * @param request CreateGlobalDataNetworkRequest
 * @return CreateGlobalDataNetworkResponse
 */
async function createGlobalDataNetwork(request: CreateGlobalDataNetworkRequest): CreateGlobalDataNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGlobalDataNetworkWithOptions(request, runtime);
}

model CreateGlobalDatabaseNetworkRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the primary cluster.

This parameter is required.', example='pc-bp1q76364ird*****'),
  enableGlobalDomainName?: boolean(name='EnableGlobalDomainName', description='Specifies whether to create a global domain name.', example='false'),
  GDNDescription?: string(name='GDNDescription', description='The description of the GDN. The description must meet the following requirements:

*   It cannot start with [http:// or https://.](http://https://。)
*   It must start with a letter.
*   It can contain letters, digits, underscores (_), and hyphens (-).
*   It must be 2 to 126 characters in length.', example='GDN-fortest'),
  GDNVersion?: string(name='GDNVersion'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model CreateGlobalDatabaseNetworkResponseBody = {
  GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gd-m5ex5wqfqbou*****'),
  requestId?: string(name='RequestId', description='The request ID.', example='C61892A4-0850-4516-9E26-44D96C1782DE'),
}

model CreateGlobalDatabaseNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateGlobalDatabaseNetworkResponseBody(name='body'),
}

/**
 * @summary Creates a global database network (GDN).
 *
 * @description >  A cluster belongs to only one GDN.
 *
 * @param request CreateGlobalDatabaseNetworkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateGlobalDatabaseNetworkResponse
 */
async function createGlobalDatabaseNetworkWithOptions(request: CreateGlobalDatabaseNetworkRequest, runtime: Util.RuntimeOptions): CreateGlobalDatabaseNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.enableGlobalDomainName)) {
    query['EnableGlobalDomainName'] = request.enableGlobalDomainName;
  }
  if (!Util.isUnset(request.GDNDescription)) {
    query['GDNDescription'] = request.GDNDescription;
  }
  if (!Util.isUnset(request.GDNVersion)) {
    query['GDNVersion'] = request.GDNVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGlobalDatabaseNetwork',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a global database network (GDN).
 *
 * @description >  A cluster belongs to only one GDN.
 *
 * @param request CreateGlobalDatabaseNetworkRequest
 * @return CreateGlobalDatabaseNetworkResponse
 */
async function createGlobalDatabaseNetwork(request: CreateGlobalDatabaseNetworkRequest): CreateGlobalDatabaseNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGlobalDatabaseNetworkWithOptions(request, runtime);
}

model CreateGlobalSecurityIPGroupRequest {
  GIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Multiple IP addresses are separated by commas (,). You can create up to 1,000 IP addresses or CIDR blocks for all IP whitelists.

This parameter is required.', example='192.168.0.1'),
  globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or digit.
*   The name must be 2 to 120 characters in length.

This parameter is required.', example='test_123'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model CreateGlobalSecurityIPGroupResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      GIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroup', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model CreateGlobalSecurityIPGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateGlobalSecurityIPGroupResponseBody(name='body'),
}

/**
 * @summary Creates a global IP whitelist template.
 *
 * @param request CreateGlobalSecurityIPGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateGlobalSecurityIPGroupResponse
 */
async function createGlobalSecurityIPGroupWithOptions(request: CreateGlobalSecurityIPGroupRequest, runtime: Util.RuntimeOptions): CreateGlobalSecurityIPGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.GIpList)) {
    query['GIpList'] = request.GIpList;
  }
  if (!Util.isUnset(request.globalIgName)) {
    query['GlobalIgName'] = request.globalIgName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGlobalSecurityIPGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a global IP whitelist template.
 *
 * @param request CreateGlobalSecurityIPGroupRequest
 * @return CreateGlobalSecurityIPGroupResponse
 */
async function createGlobalSecurityIPGroup(request: CreateGlobalSecurityIPGroupRequest): CreateGlobalSecurityIPGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGlobalSecurityIPGroupWithOptions(request, runtime);
}

model CreateNetworkChannelRequest {
  channelName?: string(name='ChannelName', description='This parameter is required.', example='ch4'),
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f5********************'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-*****************'),
  notes?: string(name='Notes', example='test'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-beijing'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-re*********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  targetDBClusterId?: string(name='TargetDBClusterId', example='pc-*****************'),
  targetIp?: string(name='TargetIp', example='192.**.**.46'),
  targetPort?: string(name='TargetPort', example='9032'),
  vpcId?: string(name='VpcId', example='vpc-25cdvfeq58pl****'),
}

model CreateNetworkChannelResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='F9F1CB1A-B1D5-4EF5-A53A-************'),
}

model CreateNetworkChannelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateNetworkChannelResponseBody(name='body'),
}

/**
 * @summary 创建网络通道
 *
 * @param request CreateNetworkChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNetworkChannelResponse
 */
async function createNetworkChannelWithOptions(request: CreateNetworkChannelRequest, runtime: Util.RuntimeOptions): CreateNetworkChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelName)) {
    query['ChannelName'] = request.channelName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.notes)) {
    query['Notes'] = request.notes;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.targetDBClusterId)) {
    query['TargetDBClusterId'] = request.targetDBClusterId;
  }
  if (!Util.isUnset(request.targetIp)) {
    query['TargetIp'] = request.targetIp;
  }
  if (!Util.isUnset(request.targetPort)) {
    query['TargetPort'] = request.targetPort;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNetworkChannel',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建网络通道
 *
 * @param request CreateNetworkChannelRequest
 * @return CreateNetworkChannelResponse
 */
async function createNetworkChannel(request: CreateNetworkChannelRequest): CreateNetworkChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNetworkChannelWithOptions(request, runtime);
}

model CreateOrGetVirtualLicenseOrderRequest {
  engine?: string(name='Engine', description='The type of the engine. Valid values: PG, Oracle, and MySQL.

This parameter is required.', example='PG'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateOrGetVirtualLicenseOrderResponseBody = {
  activatedCodeCount?: int32(name='ActivatedCodeCount', description='The number of generated activation codes.', example='1'),
  activationCodeQuota?: int32(name='ActivationCodeQuota', description='The maximum number of activation codes that you can apply for.', example='10'),
  aliyunOrderId?: string(name='AliyunOrderId', description='The Alibaba Cloud order ID (including the virtual order ID).', example='2233****445566'),
  allowEmptySystemIdentifier?: boolean(name='AllowEmptySystemIdentifier', description='Indicates whether activation codes can be generated without the system identifier.', example='false'),
  gmtCreated?: string(name='GmtCreated', description='The time when the order was created.', example='2024-10-16 16:46:20'),
  gmtModified?: string(name='GmtModified', description='The time when the order was last updated.', example='2024-10-16 16:46:20'),
  isVirtualOrder?: boolean(name='IsVirtualOrder', description='Indicates whether the order is a virtual order (virtual orders allow pre-generation of activation codes).', example='true'),
  isVirtualOrderFrozen?: boolean(name='IsVirtualOrderFrozen', description='Indicates whether the virtual order is frozen (activation codes cannot be generated for a frozen virtual order).', example='false'),
  packageType?: string(name='PackageType', description='The plan type.', example='pre_generation_long_term'),
  packageValidity?: string(name='PackageValidity', description='The validity period of the plan, which is one year (common) or thirty years (long-term).', example='30 years'),
  purchaseChannel?: string(name='PurchaseChannel', description='The purchase channel.', example='aliyun_market'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='45D24263-7E3A-4140-9472-************'),
  virtualOrderId?: string(name='VirtualOrderId', description='The ID of the virtual order.', example='2024********483'),
}

model CreateOrGetVirtualLicenseOrderResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOrGetVirtualLicenseOrderResponseBody(name='body'),
}

/**
 * @summary Creates or obtains a virtual license order.
 *
 * @param request CreateOrGetVirtualLicenseOrderRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOrGetVirtualLicenseOrderResponse
 */
async function createOrGetVirtualLicenseOrderWithOptions(request: CreateOrGetVirtualLicenseOrderRequest, runtime: Util.RuntimeOptions): CreateOrGetVirtualLicenseOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrGetVirtualLicenseOrder',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates or obtains a virtual license order.
 *
 * @param request CreateOrGetVirtualLicenseOrderRequest
 * @return CreateOrGetVirtualLicenseOrderResponse
 */
async function createOrGetVirtualLicenseOrder(request: CreateOrGetVirtualLicenseOrderRequest): CreateOrGetVirtualLicenseOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrGetVirtualLicenseOrderWithOptions(request, runtime);
}

model CreateParameterGroupRequest {
  DBType?: string(name='DBType', description='The type of the database engine. Only **MySQL** is supported.

This parameter is required.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine. Valid values:

*   **5.6**
*   **5.7**
*   **8.0**

This parameter is required.', example='8.0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parameterGroupDesc?: string(name='ParameterGroupDesc', description='The description of the parameter template. It must be 0 to 199 characters in length.', example='test_group'),
  parameterGroupName?: string(name='ParameterGroupName', description='The name of the parameter template. The name must meet the following requirements:

*   It can contain letters, digits, and underscores (_). It must start with a letter and cannot end with an underscore.**
*   It must be 8 to 64 characters in length.

This parameter is required.', example='test_group'),
  parameters?: string(name='Parameters', description='The JSON string that consists of parameters and values. The parameter values are strings. Example: `{"wait_timeout":"86400","innodb_old_blocks_time":"1000"}`.

> You can call the [DescribeParameterTemplates](https://help.aliyun.com/document_detail/207428.html) operation to query the details of all parameters in the cluster of a specified engine version, such as the parameter name and valid values.

This parameter is required.', example='{"wait_timeout":"86400","innodb_old_blocks_time":"1000"}'),
  regionId?: string(name='RegionId', description='The region ID.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query available regions.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateParameterGroupResponseBody = {
  parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template.

> You can call the [DescribeParameterGroups](https://help.aliyun.com/document_detail/207178.html) operation to query the details of all parameter templates of a specified region, such as the ID of a parameter template.', example='pcpg-**************'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='514D1D87-E243-4A5F-A87D-2785C3******'),
}

model CreateParameterGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateParameterGroupResponseBody(name='body'),
}

/**
 * @summary Creates a parameter template.
 *
 * @description You can use parameter templates to manage multiple parameters at a time and apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](https://help.aliyun.com/document_detail/207009.html).
 * > You can call this operation only on a PolarDB for MySQL cluster.
 *
 * @param request CreateParameterGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateParameterGroupResponse
 */
async function createParameterGroupWithOptions(request: CreateParameterGroupRequest, runtime: Util.RuntimeOptions): CreateParameterGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupDesc)) {
    query['ParameterGroupDesc'] = request.parameterGroupDesc;
  }
  if (!Util.isUnset(request.parameterGroupName)) {
    query['ParameterGroupName'] = request.parameterGroupName;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateParameterGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a parameter template.
 *
 * @description You can use parameter templates to manage multiple parameters at a time and apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](https://help.aliyun.com/document_detail/207009.html).
 * > You can call this operation only on a PolarDB for MySQL cluster.
 *
 * @param request CreateParameterGroupRequest
 * @return CreateParameterGroupResponse
 */
async function createParameterGroup(request: CreateParameterGroupRequest): CreateParameterGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createParameterGroupWithOptions(request, runtime);
}

model CreateServiceLinkedRoleRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateServiceLinkedRoleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='3F9E6A3B-C13E-4064-A010-18582A******'),
}

model CreateServiceLinkedRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateServiceLinkedRoleResponseBody(name='body'),
}

/**
 * @summary Creates a service-linked role (SLR).
 *
 * @param request CreateServiceLinkedRoleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateServiceLinkedRoleResponse
 */
async function createServiceLinkedRoleWithOptions(request: CreateServiceLinkedRoleRequest, runtime: Util.RuntimeOptions): CreateServiceLinkedRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceLinkedRole',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a service-linked role (SLR).
 *
 * @param request CreateServiceLinkedRoleRequest
 * @return CreateServiceLinkedRoleResponse
 */
async function createServiceLinkedRole(request: CreateServiceLinkedRoleRequest): CreateServiceLinkedRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceLinkedRoleWithOptions(request, runtime);
}

model CreateStoragePlanRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value. Make sure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='6000170000591aed949d0f5********************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: string(name='Period', description='The unit of the subscription duration for the storage plan. Valid values:

*   **Month**
*   **Year**

This parameter is required.', example='Month'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  storageClass?: string(name='StorageClass', description='The capacity of the storage plan. Unit: GB. Valid values: 50, 100, 200, 300, 500, 1000, 2000, 3000, 5000, 10000, 15000, 20000, 25000, 30000, 50000, 100000, and 200000

This parameter is required.', example='500'),
  storageType?: string(name='StorageType', description='The type of the storage plan. Valid values:

*   **Mainland**: The storage plan is used inside the Chinese mainland.
*   **Overseas**: The storage plan is used outside the Chinese mainland.

This parameter is required.', example='Mainland'),
  usedTime?: string(name='UsedTime', description='The subscription duration of the storage plan.

*   If **Period** is set to **Month**, the value ranges from 1 to 9.
*   If **Period** is set to **Year**, the value can be 1, 2, 3, or 5.

This parameter is required.', example='3'),
}

model CreateStoragePlanResponseBody = {
  DBInstanceId?: string(name='DBInstanceId', description='The instance ID.', example='POLARDB-cn-**************'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2035638*******'),
  requestId?: string(name='RequestId', description='The request ID.', example='69A85BAF-1089-4CDF-A82F-0A140F******'),
}

model CreateStoragePlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateStoragePlanResponseBody(name='body'),
}

/**
 * @summary Purchases a storage plan.
 *
 * @param request CreateStoragePlanRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateStoragePlanResponse
 */
async function createStoragePlanWithOptions(request: CreateStoragePlanRequest, runtime: Util.RuntimeOptions): CreateStoragePlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.storageClass)) {
    query['StorageClass'] = request.storageClass;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateStoragePlan',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Purchases a storage plan.
 *
 * @param request CreateStoragePlanRequest
 * @return CreateStoragePlanResponse
 */
async function createStoragePlan(request: CreateStoragePlanRequest): CreateStoragePlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return createStoragePlanWithOptions(request, runtime);
}

model DeleteAIDBClusterRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
}

model DeleteAIDBClusterResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-*****************'),
  requestId?: string(name='RequestId', description='Id of the request', example='3F9E6A3B-C13E-4064-A010-18582A******'),
}

model DeleteAIDBClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAIDBClusterResponseBody(name='body'),
}

/**
 * @summary 删除AI集群实例
 *
 * @param request DeleteAIDBClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAIDBClusterResponse
 */
async function deleteAIDBClusterWithOptions(request: DeleteAIDBClusterRequest, runtime: Util.RuntimeOptions): DeleteAIDBClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAIDBCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除AI集群实例
 *
 * @param request DeleteAIDBClusterRequest
 * @return DeleteAIDBClusterResponse
 */
async function deleteAIDBCluster(request: DeleteAIDBClusterRequest): DeleteAIDBClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAIDBClusterWithOptions(request, runtime);
}

model DeleteAccountRequest {
  accountName?: string(name='AccountName', description='The username of the account.

This parameter is required.', example='testacc'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteAccountResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model DeleteAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAccountResponseBody(name='body'),
}

/**
 * @summary Deletes a database account for a PolarDB cluster.
 *
 * @description > Before you call this operation, make sure that the cluster is in the Running state. Otherwise, the operation fails.
 *
 * @param request DeleteAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAccountResponse
 */
async function deleteAccountWithOptions(request: DeleteAccountRequest, runtime: Util.RuntimeOptions): DeleteAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAccount',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a database account for a PolarDB cluster.
 *
 * @description > Before you call this operation, make sure that the cluster is in the Running state. Otherwise, the operation fails.
 *
 * @param request DeleteAccountRequest
 * @return DeleteAccountResponse
 */
async function deleteAccount(request: DeleteAccountRequest): DeleteAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccountWithOptions(request, runtime);
}

model DeleteAccountZonalRequest {
  accountName?: string(name='AccountName', description='This parameter is required.', example='test_acc'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteAccountZonalResponseBody = {
  requestId?: string(name='RequestId', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model DeleteAccountZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAccountZonalResponseBody(name='body'),
}

/**
 * @summary 删除PolarDB边缘云集群账号
 *
 * @param request DeleteAccountZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAccountZonalResponse
 */
async function deleteAccountZonalWithOptions(request: DeleteAccountZonalRequest, runtime: Util.RuntimeOptions): DeleteAccountZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAccountZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除PolarDB边缘云集群账号
 *
 * @param request DeleteAccountZonalRequest
 * @return DeleteAccountZonalResponse
 */
async function deleteAccountZonal(request: DeleteAccountZonalRequest): DeleteAccountZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccountZonalWithOptions(request, runtime);
}

model DeleteApplicationRequest {
  applicationId?: string(name='ApplicationId', description='This parameter is required.', example='pa-**************'),
}

model DeleteApplicationResponseBody = {
  requestId?: string(name='RequestId', example='3E5CD764-FCCA-5C9C-838E-20E0DE84B2AF'),
}

model DeleteApplicationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteApplicationResponseBody(name='body'),
}

/**
 * @summary 删除PolarDB应用
 *
 * @param request DeleteApplicationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteApplicationResponse
 */
async function deleteApplicationWithOptions(request: DeleteApplicationRequest, runtime: Util.RuntimeOptions): DeleteApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationId)) {
    query['ApplicationId'] = request.applicationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除PolarDB应用
 *
 * @param request DeleteApplicationRequest
 * @return DeleteApplicationResponse
 */
async function deleteApplication(request: DeleteApplicationRequest): DeleteApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteApplicationWithOptions(request, runtime);
}

model DeleteApplicationEndpointAddressRequest {
  applicationId?: string(name='ApplicationId', description='This parameter is required.', example='pa-**************'),
  endpointId?: string(name='EndpointId', description='This parameter is required.', example='pa-**************'),
  netType?: string(name='NetType', description='This parameter is required.', example='Public'),
}

model DeleteApplicationEndpointAddressResponseBody = {
  applicationId?: string(name='ApplicationId', example='pa-**************'),
  endpointId?: string(name='EndpointId', example='pa-**************'),
  requestId?: string(name='RequestId', example='3E5CD764-FCCA-5C9C-838E-20E0DE84B2AF'),
}

model DeleteApplicationEndpointAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteApplicationEndpointAddressResponseBody(name='body'),
}

/**
 * @summary 删除PolarDB应用终端地址
 *
 * @param request DeleteApplicationEndpointAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteApplicationEndpointAddressResponse
 */
async function deleteApplicationEndpointAddressWithOptions(request: DeleteApplicationEndpointAddressRequest, runtime: Util.RuntimeOptions): DeleteApplicationEndpointAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationId)) {
    query['ApplicationId'] = request.applicationId;
  }
  if (!Util.isUnset(request.endpointId)) {
    query['EndpointId'] = request.endpointId;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteApplicationEndpointAddress',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除PolarDB应用终端地址
 *
 * @param request DeleteApplicationEndpointAddressRequest
 * @return DeleteApplicationEndpointAddressResponse
 */
async function deleteApplicationEndpointAddress(request: DeleteApplicationEndpointAddressRequest): DeleteApplicationEndpointAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteApplicationEndpointAddressWithOptions(request, runtime);
}

model DeleteBackupRequest {
  backupId?: string(name='BackupId', description='The backup ID. If you need to specify multiple backup IDs, separate the backup IDs with commas (,).

>  You can call the [DescribeBackups](https://help.aliyun.com/document_detail/98102.html) operation to query the backup IDs.

This parameter is required.', example='11111111'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteBackupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='3CF4F9FE-BF77-4739-8D68-B8DF5D******'),
}

model DeleteBackupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteBackupResponseBody(name='body'),
}

/**
 * @summary Deletes the backup sets of a PolarDB cluster.
 *
 * @description Before you call this operation, make sure that the cluster meets the following requirements:
 * *   The cluster is in the Running state.
 * *   The backup sets are in the Success state.
 * > *   You can call the [DescribeBackups](https://help.aliyun.com/document_detail/98102.html) operation to query the status of backup sets.
 * >*   After you delete the backup set file, the storage space that is occupied by the file is released. The released storage space is smaller than the size of the file because your snapshots share some data blocks
 *
 * @param request DeleteBackupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBackupResponse
 */
async function deleteBackupWithOptions(request: DeleteBackupRequest, runtime: Util.RuntimeOptions): DeleteBackupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBackup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes the backup sets of a PolarDB cluster.
 *
 * @description Before you call this operation, make sure that the cluster meets the following requirements:
 * *   The cluster is in the Running state.
 * *   The backup sets are in the Success state.
 * > *   You can call the [DescribeBackups](https://help.aliyun.com/document_detail/98102.html) operation to query the status of backup sets.
 * >*   After you delete the backup set file, the storage space that is occupied by the file is released. The released storage space is smaller than the size of the file because your snapshots share some data blocks
 *
 * @param request DeleteBackupRequest
 * @return DeleteBackupResponse
 */
async function deleteBackup(request: DeleteBackupRequest): DeleteBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBackupWithOptions(request, runtime);
}

model DeleteDBClusterRequest {
  backupRetentionPolicyOnClusterDeletion?: string(name='BackupRetentionPolicyOnClusterDeletion', description='The retention policy applied to the backup sets when the cluster is released. Valid values:

*   **ALL**: permanently retains all backup sets.
*   **LATEST**: permanently retains the most recent backup set that is automatically created before the cluster is released.
*   **NONE**: does not retain backup sets.', example='NONE'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDBClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model DeleteDBClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDBClusterResponseBody(name='body'),
}

/**
 * @summary Releases a pay-as-you-go PolarDB cluster.
 *
 * @param request DeleteDBClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDBClusterResponse
 */
async function deleteDBClusterWithOptions(request: DeleteDBClusterRequest, runtime: Util.RuntimeOptions): DeleteDBClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupRetentionPolicyOnClusterDeletion)) {
    query['BackupRetentionPolicyOnClusterDeletion'] = request.backupRetentionPolicyOnClusterDeletion;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDBCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Releases a pay-as-you-go PolarDB cluster.
 *
 * @param request DeleteDBClusterRequest
 * @return DeleteDBClusterResponse
 */
async function deleteDBCluster(request: DeleteDBClusterRequest): DeleteDBClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBClusterWithOptions(request, runtime);
}

model DeleteDBClusterEndpointRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-******************'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the custom cluster endpoint.

This parameter is required.', example='pe-******************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  polarFsInstanceId?: string(name='PolarFsInstanceId', example='pfs-test*****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDBClusterEndpointResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CD3FA5F3-FAF3-44CA-AFFF-BAF869******'),
}

model DeleteDBClusterEndpointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDBClusterEndpointResponseBody(name='body'),
}

/**
 * @summary Releases a custom cluster endpoint of a PolarDB cluster.
 *
 * @param request DeleteDBClusterEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDBClusterEndpointResponse
 */
async function deleteDBClusterEndpointWithOptions(request: DeleteDBClusterEndpointRequest, runtime: Util.RuntimeOptions): DeleteDBClusterEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.polarFsInstanceId)) {
    query['PolarFsInstanceId'] = request.polarFsInstanceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDBClusterEndpoint',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Releases a custom cluster endpoint of a PolarDB cluster.
 *
 * @param request DeleteDBClusterEndpointRequest
 * @return DeleteDBClusterEndpointResponse
 */
async function deleteDBClusterEndpoint(request: DeleteDBClusterEndpointRequest): DeleteDBClusterEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBClusterEndpointWithOptions(request, runtime);
}

model DeleteDBClusterEndpointZonalRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  DBEndpointId?: string(name='DBEndpointId', description='This parameter is required.', example='pe-******************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDBClusterEndpointZonalResponseBody = {
  requestId?: string(name='RequestId', example='CD3FA5F3-FAF3-44CA-AFFF-BAF869******'),
}

model DeleteDBClusterEndpointZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDBClusterEndpointZonalResponseBody(name='body'),
}

/**
 * @summary 删除PolarDB 边缘云集群的链接地址
 *
 * @param request DeleteDBClusterEndpointZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDBClusterEndpointZonalResponse
 */
async function deleteDBClusterEndpointZonalWithOptions(request: DeleteDBClusterEndpointZonalRequest, runtime: Util.RuntimeOptions): DeleteDBClusterEndpointZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDBClusterEndpointZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除PolarDB 边缘云集群的链接地址
 *
 * @param request DeleteDBClusterEndpointZonalRequest
 * @return DeleteDBClusterEndpointZonalResponse
 */
async function deleteDBClusterEndpointZonal(request: DeleteDBClusterEndpointZonalRequest): DeleteDBClusterEndpointZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBClusterEndpointZonalWithOptions(request, runtime);
}

model DeleteDBEndpointAddressRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of all clusters that belong to your account, such as the cluster ID.

This parameter is required.', example='pc-************'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.

>  You can call the [DescribeDBClusterEndpoints](https://help.aliyun.com/document_detail/98205.html) operation to query the endpoints of a specified PolarDB cluster.

This parameter is required.', example='pe-***************'),
  netType?: string(name='NetType', description='The network type of the endpoint. Set the value to **Public** (public network).

This parameter is required.', example='Public'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDBEndpointAddressResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model DeleteDBEndpointAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDBEndpointAddressResponseBody(name='body'),
}

/**
 * @summary Releases the public endpoints of a PolarDB cluster, including the primary endpoint, default cluster endpoint, and custom cluster endpoint.
 *
 * @description > *   You can delete a public-facing or classic network endpoint of the primary endpoint, the default cluster endpoint, or a custom cluster endpoint.
 * > *   Classic network endpoints are supported only on the China site (aliyun.com). Therefore, you do not need to delete classic network endpoints on the International site (alibabacloud.com).
 *
 * @param request DeleteDBEndpointAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDBEndpointAddressResponse
 */
async function deleteDBEndpointAddressWithOptions(request: DeleteDBEndpointAddressRequest, runtime: Util.RuntimeOptions): DeleteDBEndpointAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDBEndpointAddress',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Releases the public endpoints of a PolarDB cluster, including the primary endpoint, default cluster endpoint, and custom cluster endpoint.
 *
 * @description > *   You can delete a public-facing or classic network endpoint of the primary endpoint, the default cluster endpoint, or a custom cluster endpoint.
 * > *   Classic network endpoints are supported only on the China site (aliyun.com). Therefore, you do not need to delete classic network endpoints on the International site (alibabacloud.com).
 *
 * @param request DeleteDBEndpointAddressRequest
 * @return DeleteDBEndpointAddressResponse
 */
async function deleteDBEndpointAddress(request: DeleteDBEndpointAddressRequest): DeleteDBEndpointAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBEndpointAddressWithOptions(request, runtime);
}

model DeleteDBLinkRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the source cluster where a database link is to be deleted.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/173433.html) operation to query PolarDB clusters.

This parameter is required.', example='pc-**************'),
  DBLinkName?: string(name='DBLinkName', description='The name of the database link to be deleted.

This parameter is required.', example='dblink_test'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDBLinkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F9F1CB1A-B1D5-4EF5-A53A-************'),
}

model DeleteDBLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDBLinkResponseBody(name='body'),
}

/**
 * @summary Deletes a database link from a PolarDB for PostgreSQL (Compatible with Oracle) cluster.
 *
 * @param request DeleteDBLinkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDBLinkResponse
 */
async function deleteDBLinkWithOptions(request: DeleteDBLinkRequest, runtime: Util.RuntimeOptions): DeleteDBLinkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBLinkName)) {
    query['DBLinkName'] = request.DBLinkName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDBLink',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a database link from a PolarDB for PostgreSQL (Compatible with Oracle) cluster.
 *
 * @param request DeleteDBLinkRequest
 * @return DeleteDBLinkResponse
 */
async function deleteDBLink(request: DeleteDBLinkRequest): DeleteDBLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBLinkWithOptions(request, runtime);
}

model DeleteDBNodesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a42***********'),
  cloudProvider?: string(name='CloudProvider', example='ENS'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-**************'),
  DBNodeId?: [ string ](name='DBNodeId', description='The IDs of the nodes.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/185342.html) operation to query the details of all clusters that belong to your Alibaba Cloud account, such as the cluster ID.

This parameter is required.', example='pi-************'),
  DBNodeType?: string(name='DBNodeType', description='The node type. Valid values:

*   RO
*   STANDBY
*   DLNode

Enumerated values:

*   DLNode: AI node
*   STANDBY: standby node
*   RO: read-only node', example='RO'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDBNodesResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-**************'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2035638*******'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6566B2E6-3157-4B57-A693-AFB751******'),
}

model DeleteDBNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDBNodesResponseBody(name='body'),
}

/**
 * @summary Deletes a read-only node from a PolarDB cluster.
 *
 * @param request DeleteDBNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDBNodesResponse
 */
async function deleteDBNodesWithOptions(request: DeleteDBNodesRequest, runtime: Util.RuntimeOptions): DeleteDBNodesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.cloudProvider)) {
    query['CloudProvider'] = request.cloudProvider;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeId)) {
    query['DBNodeId'] = request.DBNodeId;
  }
  if (!Util.isUnset(request.DBNodeType)) {
    query['DBNodeType'] = request.DBNodeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDBNodes',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a read-only node from a PolarDB cluster.
 *
 * @param request DeleteDBNodesRequest
 * @return DeleteDBNodesResponse
 */
async function deleteDBNodes(request: DeleteDBNodesRequest): DeleteDBNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBNodesWithOptions(request, runtime);
}

model DeleteDatabaseRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-*************'),
  DBName?: string(name='DBName', description='The name of the database.

This parameter is required.', example='testdb'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDatabaseResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model DeleteDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDatabaseResponseBody(name='body'),
}

/**
 * @summary Deletes a database from a PolarDB cluster.
 *
 * @description >- The cluster must be in the Running state and unlocked. Otherwise, the specified database cannot be deleted.
 * >- The delete operation is performed in an asynchronous manner. A long period of time may be required to delete a large database. A success response for this operation only indicates that the request to delete the database is sent. You must query the database to check whether the database is deleted.
 *
 * @param request DeleteDatabaseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDatabaseResponse
 */
async function deleteDatabaseWithOptions(request: DeleteDatabaseRequest, runtime: Util.RuntimeOptions): DeleteDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDatabase',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a database from a PolarDB cluster.
 *
 * @description >- The cluster must be in the Running state and unlocked. Otherwise, the specified database cannot be deleted.
 * >- The delete operation is performed in an asynchronous manner. A long period of time may be required to delete a large database. A success response for this operation only indicates that the request to delete the database is sent. You must query the database to check whether the database is deleted.
 *
 * @param request DeleteDatabaseRequest
 * @return DeleteDatabaseResponse
 */
async function deleteDatabase(request: DeleteDatabaseRequest): DeleteDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDatabaseWithOptions(request, runtime);
}

model DeleteDatabaseZonalRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-*************'),
  DBName?: string(name='DBName', description='This parameter is required.', example='testdb'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDatabaseZonalResponseBody = {
  requestId?: string(name='RequestId', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model DeleteDatabaseZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDatabaseZonalResponseBody(name='body'),
}

/**
 * @summary 删除PolarDB边缘云集群数据库
 *
 * @param request DeleteDatabaseZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDatabaseZonalResponse
 */
async function deleteDatabaseZonalWithOptions(request: DeleteDatabaseZonalRequest, runtime: Util.RuntimeOptions): DeleteDatabaseZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDatabaseZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除PolarDB边缘云集群数据库
 *
 * @param request DeleteDatabaseZonalRequest
 * @return DeleteDatabaseZonalResponse
 */
async function deleteDatabaseZonal(request: DeleteDatabaseZonalRequest): DeleteDatabaseZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDatabaseZonalWithOptions(request, runtime);
}

model DeleteEncryptionDBRolePrivilegeRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  rolePrivilegeNameList?: string(name='RolePrivilegeNameList', example='test'),
}

model DeleteEncryptionDBRolePrivilegeResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-**************'),
  message?: string(name='Message', example='Successful'),
  requestId?: string(name='RequestId', description='Id of the request', example='24A1990B-4F6E-482B-B8CB-75C612******'),
  success?: boolean(name='Success', example='true'),
}

model DeleteEncryptionDBRolePrivilegeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteEncryptionDBRolePrivilegeResponseBody(name='body'),
}

/**
 * @summary 删除角色
 *
 * @param request DeleteEncryptionDBRolePrivilegeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEncryptionDBRolePrivilegeResponse
 */
async function deleteEncryptionDBRolePrivilegeWithOptions(request: DeleteEncryptionDBRolePrivilegeRequest, runtime: Util.RuntimeOptions): DeleteEncryptionDBRolePrivilegeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.rolePrivilegeNameList)) {
    query['RolePrivilegeNameList'] = request.rolePrivilegeNameList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEncryptionDBRolePrivilege',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除角色
 *
 * @param request DeleteEncryptionDBRolePrivilegeRequest
 * @return DeleteEncryptionDBRolePrivilegeResponse
 */
async function deleteEncryptionDBRolePrivilege(request: DeleteEncryptionDBRolePrivilegeRequest): DeleteEncryptionDBRolePrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEncryptionDBRolePrivilegeWithOptions(request, runtime);
}

model DeleteExtensionsRequest {
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  DBNames?: string(name='DBNames', description='This parameter is required.', example='auto_test_db'),
  extensions?: string(name='Extensions', description='This parameter is required.', example='pase,hstore'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-beijing'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId', example='vpc-25cdvfeq58pl****'),
}

model DeleteExtensionsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='11EB8492-C17F-5FC2-9E27-1440A5C2F583'),
}

model DeleteExtensionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteExtensionsResponseBody(name='body'),
}

/**
 * @summary 删除插件
 *
 * @param request DeleteExtensionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteExtensionsResponse
 */
async function deleteExtensionsWithOptions(request: DeleteExtensionsRequest, runtime: Util.RuntimeOptions): DeleteExtensionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNames)) {
    query['DBNames'] = request.DBNames;
  }
  if (!Util.isUnset(request.extensions)) {
    query['Extensions'] = request.extensions;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteExtensions',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除插件
 *
 * @param request DeleteExtensionsRequest
 * @return DeleteExtensionsResponse
 */
async function deleteExtensions(request: DeleteExtensionsRequest): DeleteExtensionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExtensionsWithOptions(request, runtime);
}

model DeleteFirewallRulesRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleNameList?: string(name='RuleNameList', description='This parameter is required.', example='testrule'),
}

model DeleteFirewallRulesResponseBody = {
  message?: string(name='Message', example='Successful'),
  requestId?: string(name='RequestId', description='Id of the request', example='049A1520-6BD7-5572-8923-79215D2B4A94'),
  success?: boolean(name='Success', example='true'),
}

model DeleteFirewallRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFirewallRulesResponseBody(name='body'),
}

/**
 * @summary 删除sql防火墙
 *
 * @param request DeleteFirewallRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFirewallRulesResponse
 */
async function deleteFirewallRulesWithOptions(request: DeleteFirewallRulesRequest, runtime: Util.RuntimeOptions): DeleteFirewallRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleNameList)) {
    query['RuleNameList'] = request.ruleNameList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFirewallRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除sql防火墙
 *
 * @param request DeleteFirewallRulesRequest
 * @return DeleteFirewallRulesResponse
 */
async function deleteFirewallRules(request: DeleteFirewallRulesRequest): DeleteFirewallRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFirewallRulesWithOptions(request, runtime);
}

model DeleteGlobalDataNetworkRequest {
  networkId?: string(name='NetworkId', description='GDN ID', example='gdn-xxx'),
}

model DeleteGlobalDataNetworkResponseBody = {
  requestId?: string(name='RequestId', example='EBEAA83D-1734-42E3-85E3-E25F6E******'),
}

model DeleteGlobalDataNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGlobalDataNetworkResponseBody(name='body'),
}

/**
 * @summary DeleteGlobalDataNetwork
 *
 * @param request DeleteGlobalDataNetworkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGlobalDataNetworkResponse
 */
async function deleteGlobalDataNetworkWithOptions(request: DeleteGlobalDataNetworkRequest, runtime: Util.RuntimeOptions): DeleteGlobalDataNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.networkId)) {
    query['NetworkId'] = request.networkId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGlobalDataNetwork',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DeleteGlobalDataNetwork
 *
 * @param request DeleteGlobalDataNetworkRequest
 * @return DeleteGlobalDataNetworkResponse
 */
async function deleteGlobalDataNetwork(request: DeleteGlobalDataNetworkRequest): DeleteGlobalDataNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGlobalDataNetworkWithOptions(request, runtime);
}

model DeleteGlobalDatabaseNetworkRequest {
  GDNId?: string(name='GDNId', description='The ID of the GDN.

This parameter is required.', example='gdn-bp1fttxsrmv*****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DeleteGlobalDatabaseNetworkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C61892A4-0850-4516-9E26-44D96C1782DE'),
}

model DeleteGlobalDatabaseNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGlobalDatabaseNetworkResponseBody(name='body'),
}

/**
 * @summary Deletes a global database network (GDN).
 *
 * @description >  You can delete a GDN only when the GDN includes only a primary cluster.
 *
 * @param request DeleteGlobalDatabaseNetworkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGlobalDatabaseNetworkResponse
 */
async function deleteGlobalDatabaseNetworkWithOptions(request: DeleteGlobalDatabaseNetworkRequest, runtime: Util.RuntimeOptions): DeleteGlobalDatabaseNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.GDNId)) {
    query['GDNId'] = request.GDNId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGlobalDatabaseNetwork',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a global database network (GDN).
 *
 * @description >  You can delete a GDN only when the GDN includes only a primary cluster.
 *
 * @param request DeleteGlobalDatabaseNetworkRequest
 * @return DeleteGlobalDatabaseNetworkResponse
 */
async function deleteGlobalDatabaseNetwork(request: DeleteGlobalDatabaseNetworkRequest): DeleteGlobalDatabaseNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGlobalDatabaseNetworkWithOptions(request, runtime);
}

model DeleteGlobalSecurityIPGroupRequest {
  globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name of the IP whitelist template must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
  globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.

This parameter is required.', example='g-zsldxfiwjmti0kcm****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DeleteGlobalSecurityIPGroupResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      DBInstances?: [ string ](name='DBInstances', description='The clusters that are associated with the IP address whitelist template.'),
      GIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Multiple IP addresses are separated by commas (,). You can create up to 1,000 IP addresses or CIDR blocks for all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the global IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the global IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroup', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model DeleteGlobalSecurityIPGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGlobalSecurityIPGroupResponseBody(name='body'),
}

/**
 * @summary Deletes a global IP whitelist template.
 *
 * @param request DeleteGlobalSecurityIPGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGlobalSecurityIPGroupResponse
 */
async function deleteGlobalSecurityIPGroupWithOptions(request: DeleteGlobalSecurityIPGroupRequest, runtime: Util.RuntimeOptions): DeleteGlobalSecurityIPGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalIgName)) {
    query['GlobalIgName'] = request.globalIgName;
  }
  if (!Util.isUnset(request.globalSecurityGroupId)) {
    query['GlobalSecurityGroupId'] = request.globalSecurityGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGlobalSecurityIPGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a global IP whitelist template.
 *
 * @param request DeleteGlobalSecurityIPGroupRequest
 * @return DeleteGlobalSecurityIPGroupResponse
 */
async function deleteGlobalSecurityIPGroup(request: DeleteGlobalSecurityIPGroupRequest): DeleteGlobalSecurityIPGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGlobalSecurityIPGroupWithOptions(request, runtime);
}

model DeleteMaskingRulesRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pc-*****************'),
  interfaceVersion?: string(name='InterfaceVersion', description='Deletes data masking or encryption rules. Valid values:

v1: deletes data masking rules. v2: deletes data encryption rules.', example='v1'),
  ruleNameList?: string(name='RuleNameList', description='The name of the masking rule. You can specify multiple masking rules at a time. Separate the masking rules with commas (,).

> You can call the [DescribeMaskingRules](https://help.aliyun.com/document_detail/212573.html) operation to query details of all the masking rules for a specified cluster, such as the names of the masking rules.

This parameter is required.', example='testrule'),
}

model DeleteMaskingRulesResponseBody = {
  message?: string(name='Message', description='The message that is returned for the request.

> If the request is successful, `Successful` is returned. If the request fails, an error message such as an error code is returned.', example='Successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2BCEE25B-797C-426B-BA7B-D28CCF******'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid value:

*   **true**
*   **false**', example='true'),
}

model DeleteMaskingRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMaskingRulesResponseBody(name='body'),
}

/**
 * @summary Deletes a data masking rule.
 *
 * @param request DeleteMaskingRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMaskingRulesResponse
 */
async function deleteMaskingRulesWithOptions(request: DeleteMaskingRulesRequest, runtime: Util.RuntimeOptions): DeleteMaskingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.interfaceVersion)) {
    query['InterfaceVersion'] = request.interfaceVersion;
  }
  if (!Util.isUnset(request.ruleNameList)) {
    query['RuleNameList'] = request.ruleNameList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMaskingRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a data masking rule.
 *
 * @param request DeleteMaskingRulesRequest
 * @return DeleteMaskingRulesResponse
 */
async function deleteMaskingRules(request: DeleteMaskingRulesRequest): DeleteMaskingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMaskingRulesWithOptions(request, runtime);
}

model DeleteNetworkChannelRequest {
  channelName?: string(name='ChannelName', description='This parameter is required.', example='ch4'),
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId', example='vpc-bp1qpo0kug3a20qqe****'),
}

model DeleteNetworkChannelResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='3AA69096-757C-4647-B36C-29EBC2******'),
}

model DeleteNetworkChannelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteNetworkChannelResponseBody(name='body'),
}

/**
 * @summary 删除网络通道
 *
 * @param request DeleteNetworkChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNetworkChannelResponse
 */
async function deleteNetworkChannelWithOptions(request: DeleteNetworkChannelRequest, runtime: Util.RuntimeOptions): DeleteNetworkChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelName)) {
    query['ChannelName'] = request.channelName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNetworkChannel',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除网络通道
 *
 * @param request DeleteNetworkChannelRequest
 * @return DeleteNetworkChannelResponse
 */
async function deleteNetworkChannel(request: DeleteNetworkChannelRequest): DeleteNetworkChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNetworkChannelWithOptions(request, runtime);
}

model DeleteParameterGroupRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parameterGroupId?: string(name='ParameterGroupId', description='The parameter template ID.

 
>  You can call the [DescribeParameterGroups](https://help.aliyun.com/document_detail/207178.html) operation to query the parameter template ID.

This parameter is required.', example='pcpg-**************'),
  regionId?: string(name='RegionId', description='The region ID.
 
>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query available regions.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteParameterGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F7195E7-5F74-479D-AF59-1B4BF9******'),
}

model DeleteParameterGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteParameterGroupResponseBody(name='body'),
}

/**
 * @summary Deletes a parameter template of a PolarDB cluster.
 *
 * @description You can use parameter templates to manage multiple parameters at a time and quickly apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](https://help.aliyun.com/document_detail/207009.html).
 * >  When you delete a parameter template, the parameter settings that are applied to PolarDB clusters are not affected.
 *
 * @param request DeleteParameterGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteParameterGroupResponse
 */
async function deleteParameterGroupWithOptions(request: DeleteParameterGroupRequest, runtime: Util.RuntimeOptions): DeleteParameterGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupId)) {
    query['ParameterGroupId'] = request.parameterGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteParameterGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a parameter template of a PolarDB cluster.
 *
 * @description You can use parameter templates to manage multiple parameters at a time and quickly apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](https://help.aliyun.com/document_detail/207009.html).
 * >  When you delete a parameter template, the parameter settings that are applied to PolarDB clusters are not affected.
 *
 * @param request DeleteParameterGroupRequest
 * @return DeleteParameterGroupResponse
 */
async function deleteParameterGroup(request: DeleteParameterGroupRequest): DeleteParameterGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteParameterGroupWithOptions(request, runtime);
}

model DeleteSQLRateLimitingRulesRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleNameList?: string(name='RuleNameList', description='This parameter is required.', example='testrule'),
}

model DeleteSQLRateLimitingRulesResponseBody = {
  message?: string(name='Message', example='Message'),
  requestId?: string(name='RequestId', description='Id of the request', example='5E71541A-6007-4DCC-A38A-F872C31FEB45'),
  success?: boolean(name='Success', example='true'),
}

model DeleteSQLRateLimitingRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSQLRateLimitingRulesResponseBody(name='body'),
}

/**
 * @summary 删除SQL限流规则
 *
 * @param request DeleteSQLRateLimitingRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSQLRateLimitingRulesResponse
 */
async function deleteSQLRateLimitingRulesWithOptions(request: DeleteSQLRateLimitingRulesRequest, runtime: Util.RuntimeOptions): DeleteSQLRateLimitingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleNameList)) {
    query['RuleNameList'] = request.ruleNameList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSQLRateLimitingRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除SQL限流规则
 *
 * @param request DeleteSQLRateLimitingRulesRequest
 * @return DeleteSQLRateLimitingRulesResponse
 */
async function deleteSQLRateLimitingRules(request: DeleteSQLRateLimitingRulesRequest): DeleteSQLRateLimitingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSQLRateLimitingRulesWithOptions(request, runtime);
}

model DescribeAIDBClusterAttributeRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAIDBClusterAttributeResponseBody = {
  aiNodeType?: string(name='AiNodeType', example='vnode'),
  creationTime?: string(name='CreationTime', example='2020-08-14T05:58:42Z'),
  DBClusterDescription?: string(name='DBClusterDescription', example='test'),
  DBClusterId?: string(name='DBClusterId', example='pc-**************'),
  DBClusterStatus?: string(name='DBClusterStatus', example='Running'),
  DBNodes?: [ 
    {
      childVolumes?: [ 
        {
          mountPath?: string(name='MountPath', example='/tmp/CrowdStrike'),
          name?: string(name='Name', example='jueming'),
          sizeGB?: string(name='SizeGB', example='8192'),
          storageCategory?: string(name='StorageCategory', example='PolarFs'),
          storageType?: string(name='StorageType', example='PL1'),
        }
      ](name='ChildVolumes'),
      cpuCores?: string(name='CpuCores', example='2'),
      DBNodeClass?: string(name='DBNodeClass', example='polar.pg.g8.8xlarge.gu30'),
      DBNodeDescription?: string(name='DBNodeDescription', example='test'),
      DBNodeId?: string(name='DBNodeId', example='pi-****************'),
      DBNodeStatus?: string(name='DBNodeStatus', example='Running'),
      GPU?: string(name='GPU', example='2'),
      linkIP?: string(name='LinkIP', example='10.*.*12'),
      memorySize?: string(name='MemorySize', example='8192'),
      VNodeId?: string(name='VNodeId', example='vn-***************'),
      VPCId?: string(name='VPCId', example='vpc-*******************'),
      vSwitchId?: string(name='VSwitchId', example='vsw-*********************'),
      zoneId?: string(name='ZoneId', example='cn-hangzhou-d'),
    }
  ](name='DBNodes'),
  DBVersion?: string(name='DBVersion', example='1.0'),
  endpointList?: [ 
    {
      netInfoItems?: [ 
        {
          connectionString?: string(name='ConnectionString', example='pc-**********.rwlb.rds.aliyuncs.com'),
          netType?: string(name='NetType', example='Public'),
          port?: string(name='Port', example='3306'),
        }
      ](name='NetInfoItems'),
    }
  ](name='EndpointList'),
  expireTime?: string(name='ExpireTime', example='2020-11-14T16:00:00Z'),
  expired?: boolean(name='Expired', example='false'),
  internalIp?: string(name='InternalIp', example='10.*.*.72'),
  kubeClusterId?: string(name='KubeClusterId', example='xxxxxxxxxxxxxxxxxxxxxxx'),
  lockMode?: string(name='LockMode', example='Unlock'),
  maxQPM?: string(name='MaxQPM', example='20'),
  modelName?: string(name='ModelName', example='Qwen3-Embedding-8B'),
  payType?: string(name='PayType', example='Postpaid'),
  publicIp?: string(name='PublicIp'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='Id of the request', example='EBEAA83D-1734-42E3-85E3-E25F6E******'),
  runType?: string(name='RunType', example='container'),
  storageType?: string(name='StorageType', example='essdpl1'),
  VPCId?: string(name='VPCId', example='vpc-*******************'),
  vSwitchId?: string(name='VSwitchId', example='vsw-*********************'),
  volumes?: [ 
    {
      mountPath?: string(name='MountPath', example='/var/run/secrets/kubernetes.io/serviceaccount'),
      name?: string(name='Name', example='jueming'),
      sizeGB?: string(name='SizeGB', example='8192'),
      storageCategory?: string(name='StorageCategory', example='PL1'),
      storageType?: string(name='StorageType', example='PolarFs'),
    }
  ](name='Volumes'),
  zoneId?: string(name='ZoneId', example='cn-hangzhou-d'),
  zoneIds?: string(name='ZoneIds', example='cn-hangzhou-i,cn-hangzhou-g'),
}

model DescribeAIDBClusterAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAIDBClusterAttributeResponseBody(name='body'),
}

/**
 * @summary 查看custom实例详情
 *
 * @param request DescribeAIDBClusterAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAIDBClusterAttributeResponse
 */
async function describeAIDBClusterAttributeWithOptions(request: DescribeAIDBClusterAttributeRequest, runtime: Util.RuntimeOptions): DescribeAIDBClusterAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAIDBClusterAttribute',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查看custom实例详情
 *
 * @param request DescribeAIDBClusterAttributeRequest
 * @return DescribeAIDBClusterAttributeResponse
 */
async function describeAIDBClusterAttribute(request: DescribeAIDBClusterAttributeRequest): DescribeAIDBClusterAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAIDBClusterAttributeWithOptions(request, runtime);
}

model DescribeAIDBClusterPerformanceRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-****************'),
  endTime?: string(name='EndTime', description='This parameter is required.', example='2025-09-23T01:01:00Z'),
  interval?: string(name='Interval', example='60'),
  key?: string(name='Key', description='This parameter is required.', example='PolarDBAIModelCall'),
  startTime?: string(name='StartTime', description='This parameter is required.', example='2025-09-17T02:18:00Z'),
}

model DescribeAIDBClusterPerformanceResponseBody = {
  apiKey?: string(name='ApiKey', example='xxx'),
  DBClusterId?: string(name='DBClusterId', example='pc-a************'),
  DBType?: string(name='DBType', example='polardb_ai'),
  DBVersion?: string(name='DBVersion', example='3.0'),
  endTime?: string(name='EndTime', example='2022-11-16T16:00Z'),
  interval?: string(name='Interval', example='60'),
  performanceKeys?: [ 
    {
      DBNodeId?: string(name='DBNodeId', example='pi-*************'),
      measurement?: string(name='Measurement', example='PolarDBAIModelCall'),
      metricName?: string(name='MetricName', example='model_input_amount'),
      points?: [ 
        {
          timestamp?: long(name='Timestamp', example='1724206183'),
          value?: string(name='Value', example='42.38'),
        }
      ](name='Points'),
    }
  ](name='PerformanceKeys'),
  requestId?: string(name='RequestId', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
  startTime?: string(name='StartTime', example='2022-11-15T16:00Z'),
}

model DescribeAIDBClusterPerformanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAIDBClusterPerformanceResponseBody(name='body'),
}

/**
 * @summary 获取ai容器性能指标
 *
 * @param request DescribeAIDBClusterPerformanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAIDBClusterPerformanceResponse
 */
async function describeAIDBClusterPerformanceWithOptions(request: DescribeAIDBClusterPerformanceRequest, runtime: Util.RuntimeOptions): DescribeAIDBClusterPerformanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAIDBClusterPerformance',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取ai容器性能指标
 *
 * @param request DescribeAIDBClusterPerformanceRequest
 * @return DescribeAIDBClusterPerformanceResponse
 */
async function describeAIDBClusterPerformance(request: DescribeAIDBClusterPerformanceRequest): DescribeAIDBClusterPerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAIDBClusterPerformanceWithOptions(request, runtime);
}

model DescribeAIDBClustersRequest {
  aiNodeType?: string(name='AiNodeType', example='vnode,container'),
  DBClusterDescription?: string(name='DBClusterDescription', example='pc-****************'),
  DBClusterIds?: string(name='DBClusterIds', example='pc-***************'),
  DBClusterStatus?: string(name='DBClusterStatus', example='Running'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  payType?: string(name='PayType', example='Prepaid'),
  regionId?: string(name='RegionId', description='This parameter is required.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model DescribeAIDBClustersResponseBody = {
  items?: {
    DBCluster?: [ 
    {
      aiNodeType?: string(name='AiNodeType', example='vnode'),
      createTime?: string(name='CreateTime', example='2021-09-13T15:45:27Z'),
      DBClusterDescription?: string(name='DBClusterDescription', example='ocpx'),
      DBClusterId?: string(name='DBClusterId', example='pc-**************'),
      DBClusterStatus?: string(name='DBClusterStatus', example='Creating'),
      DBNodeClass?: string(name='DBNodeClass', example='polar.pg.g8.8xlarge.gu30'),
      DBType?: string(name='DBType', example='polardb_ai'),
      expireTime?: string(name='ExpireTime', example='2028-09-01T16:00:00Z'),
      expired?: boolean(name='Expired', example='False'),
      kubeClusterId?: string(name='KubeClusterId', example='xxxxxxxxxxxx'),
      lockMode?: string(name='LockMode', example='Unlock'),
      payType?: string(name='PayType', example='Postpaid'),
      regionId?: string(name='RegionId', example='cn-hangzhou'),
      relativeDBClusterId?: string(name='RelativeDBClusterId', example='pc-**************'),
      runType?: string(name='RunType', example='container'),
      storageSpace?: int32(name='StorageSpace', example='10'),
      storageType?: string(name='StorageType', example='essdpl0'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vpcId?: string(name='VpcId', example='vpc-***************'),
      vswitchId?: string(name='VswitchId'),
      zoneId?: string(name='ZoneId', example='cn-hangzhou-j'),
    }
  ](name='DBCluster')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', example='7'),
  requestId?: string(name='RequestId', description='Id of the request', example='9D6CE7C6-1C52-5BF6-B3D7-10977D44542C'),
  totalRecordCount?: int32(name='TotalRecordCount', example='5'),
}

model DescribeAIDBClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAIDBClustersResponseBody(name='body'),
}

/**
 * @summary 查看custom集群列表
 *
 * @param request DescribeAIDBClustersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAIDBClustersResponse
 */
async function describeAIDBClustersWithOptions(request: DescribeAIDBClustersRequest, runtime: Util.RuntimeOptions): DescribeAIDBClustersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aiNodeType)) {
    query['AiNodeType'] = request.aiNodeType;
  }
  if (!Util.isUnset(request.DBClusterDescription)) {
    query['DBClusterDescription'] = request.DBClusterDescription;
  }
  if (!Util.isUnset(request.DBClusterIds)) {
    query['DBClusterIds'] = request.DBClusterIds;
  }
  if (!Util.isUnset(request.DBClusterStatus)) {
    query['DBClusterStatus'] = request.DBClusterStatus;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAIDBClusters',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查看custom集群列表
 *
 * @param request DescribeAIDBClustersRequest
 * @return DescribeAIDBClustersResponse
 */
async function describeAIDBClusters(request: DescribeAIDBClustersRequest): DescribeAIDBClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAIDBClustersWithOptions(request, runtime);
}

model DescribeAITaskStatusRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-xxxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAITaskStatusResponseBody = {
  accountName?: string(name='AccountName', description='The name of the database account that is used to connect to the AI nodes in the cluster.', example='testacc'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-xxxxxxxxxx'),
  requestId?: string(name='RequestId', description='The request ID.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
  status?: string(name='Status', description='The status of the PolarDB for AI feature. Valid values:

*   **1**: enabled.
*   **2**: disabled.', example='1'),
  statusName?: string(name='StatusName', description='The description of the status of the PolarDB for AI feature.', example='Closed State'),
}

model DescribeAITaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAITaskStatusResponseBody(name='body'),
}

/**
 * @summary Queries the status of the PolarDB for AI feature.
 *
 * @param request DescribeAITaskStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAITaskStatusResponse
 */
async function describeAITaskStatusWithOptions(request: DescribeAITaskStatusRequest, runtime: Util.RuntimeOptions): DescribeAITaskStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAITaskStatus',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the status of the PolarDB for AI feature.
 *
 * @param request DescribeAITaskStatusRequest
 * @return DescribeAITaskStatusResponse
 */
async function describeAITaskStatus(request: DescribeAITaskStatusRequest): DescribeAITaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAITaskStatusWithOptions(request, runtime);
}

model DescribeAccountsRequest {
  accountName?: string(name='AccountName', description='The name of the account.', example='test_acc'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-***************'),
  nodeType?: string(name='NodeType', description='The node type. This parameter is required when you query the PolarDB search node account.

*   Search', example='Search'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. Set this parameter to an integer that is larger than 0. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAccountsResponseBody = {
  accounts?: [ 
    {
      accountDescription?: string(name='AccountDescription', description='The description of the account.', example='test'),
      accountLockState?: string(name='AccountLockState', description='The locking state of the account. Valid values:

*   **UnLock**
*   **Lock**', example='UnLock'),
      accountName?: string(name='AccountName', description='The name of the account.', example='test_acc'),
      accountPasswordValidTime?: string(name='AccountPasswordValidTime', description='The validity period of the password.', example='undefined'),
      accountStatus?: string(name='AccountStatus', description='The state of the account. Valid values:

*   **Creating**: The account is being created.
*   **Available**: The account is available.
*   **Deleting**: The account is being deleted', example='Available'),
      accountType?: string(name='AccountType', description='The type of the account. Valid values:

*   **Normal**: standard account.
*   **Super**: privileged account.
*   **ReadOnly**: global read-only account.', example='Normal'),
      databasePrivileges?: [ 
        {
          accountPrivilege?: string(name='AccountPrivilege', description='The permissions that the account is granted on the database. Valid values:', example='ReadOnly'),
          DBName?: string(name='DBName', description='The name of the database.', example='DBtest'),
        }
      ](name='DatabasePrivileges', description='The list of database permissions that are granted to the account.'),
    }
  ](name='Accounts', description='The details of the account.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page returned.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='155462B9-205F-4FFC-BB43-4855FE******'),
}

model DescribeAccountsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAccountsResponseBody(name='body'),
}

/**
 * @summary Queries information about a database account of a PolarDB cluster.
 *
 * @param request DescribeAccountsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAccountsResponse
 */
async function describeAccountsWithOptions(request: DescribeAccountsRequest, runtime: Util.RuntimeOptions): DescribeAccountsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['NodeType'] = request.nodeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAccounts',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries information about a database account of a PolarDB cluster.
 *
 * @param request DescribeAccountsRequest
 * @return DescribeAccountsResponse
 */
async function describeAccounts(request: DescribeAccountsRequest): DescribeAccountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccountsWithOptions(request, runtime);
}

model DescribeAccountsZonalRequest {
  accountName?: string(name='AccountName', example='test_acc'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-***************'),
  maxResults?: int32(name='MaxResults', example='10'),
  nextToken?: string(name='NextToken', example='212db86sca4384811e0b5e8707e******'),
  nodeType?: string(name='NodeType', example='Search'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAccountsZonalResponseBody = {
  accounts?: [ 
    {
      accountDescription?: string(name='AccountDescription', example='test'),
      accountLockState?: string(name='AccountLockState', example='UnLock'),
      accountName?: string(name='AccountName', example='test_acc'),
      accountPasswordValidTime?: string(name='AccountPasswordValidTime', example='undefined'),
      accountStatus?: string(name='AccountStatus', example='Available'),
      accountType?: string(name='AccountType', example='Normal'),
      databasePrivileges?: [ 
        {
          accountPrivilege?: string(name='AccountPrivilege', example='ReadOnly'),
          DBName?: string(name='DBName', example='DBtest'),
        }
      ](name='DatabasePrivileges'),
    }
  ](name='Accounts'),
  maxResults?: int32(name='MaxResults', example='10'),
  nextToken?: string(name='NextToken', example='212db86sca4384811e0b5e8707e******'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', example='1'),
  requestId?: string(name='RequestId', example='155462B9-205F-4FFC-BB43-4855FE******'),
}

model DescribeAccountsZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAccountsZonalResponseBody(name='body'),
}

/**
 * @summary 查询PolarDB边缘云集群列表
 *
 * @param request DescribeAccountsZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAccountsZonalResponse
 */
async function describeAccountsZonalWithOptions(request: DescribeAccountsZonalRequest, runtime: Util.RuntimeOptions): DescribeAccountsZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['NodeType'] = request.nodeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAccountsZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询PolarDB边缘云集群列表
 *
 * @param request DescribeAccountsZonalRequest
 * @return DescribeAccountsZonalResponse
 */
async function describeAccountsZonal(request: DescribeAccountsZonalRequest): DescribeAccountsZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccountsZonalWithOptions(request, runtime);
}

model DescribeActivationCodeDetailsRequest {
  activationCodeId?: int32(name='ActivationCodeId', description='The ID of the activation code.', example='123'),
  aliyunOrderId?: string(name='AliyunOrderId', description='The Alibaba Cloud order ID (including the virtual order ID).

This parameter is required.', example='2233****445566'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeActivationCodeDetailsResponseBody = {
  activateAt?: string(name='ActivateAt', description='The time when the activation code takes effect.', example='2024-10-16 16:46:20'),
  certContentB64?: string(name='CertContentB64', description='The activation code in the base64 format. The activation code is decoded and stored into a file named license.lic. PolarDB can access and read the license.lic file upon startup to validate the license or perform related operations.', example='AAEAA******AAA='),
  description?: string(name='Description', description='The description of the activation code.', example='testCode'),
  expireAt?: string(name='ExpireAt', description='The time when the activation code expires.', example='2054-10-09 16:46:20'),
  gmtCreated?: string(name='GmtCreated', description='The time when the activation code was created.', example='2024-10-16 16:46:20'),
  gmtModified?: string(name='GmtModified', description='The time when the activation code was last updated.', example='2024-10-16 16:46:20'),
  id?: int32(name='Id', description='The ID of the activation code.', example='123'),
  macAddress?: string(name='MacAddress', description='The MAC address.', example='12:34:56:78:98:00'),
  name?: string(name='Name', description='The name of the activation code.', example='testName'),
  requestId?: string(name='RequestId', description='The request ID.', example='F2A9EFA7-915F-4572-8299-85A307******'),
  systemIdentifier?: string(name='SystemIdentifier', description='The system identifier of the database.', example='1234567890123456'),
}

model DescribeActivationCodeDetailsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeActivationCodeDetailsResponseBody(name='body'),
}

/**
 * @summary Queries the details of an activation code.
 *
 * @param request DescribeActivationCodeDetailsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeActivationCodeDetailsResponse
 */
async function describeActivationCodeDetailsWithOptions(request: DescribeActivationCodeDetailsRequest, runtime: Util.RuntimeOptions): DescribeActivationCodeDetailsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.activationCodeId)) {
    query['ActivationCodeId'] = request.activationCodeId;
  }
  if (!Util.isUnset(request.aliyunOrderId)) {
    query['AliyunOrderId'] = request.aliyunOrderId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeActivationCodeDetails',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of an activation code.
 *
 * @param request DescribeActivationCodeDetailsRequest
 * @return DescribeActivationCodeDetailsResponse
 */
async function describeActivationCodeDetails(request: DescribeActivationCodeDetailsRequest): DescribeActivationCodeDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeActivationCodeDetailsWithOptions(request, runtime);
}

model DescribeActivationCodesRequest {
  aliyunOrderId?: string(name='AliyunOrderId', description='The ID of the Alibaba Cloud order. The value can be the ID of a virtual order.

This parameter is required.', example='2233****445566'),
  macAddress?: string(name='MacAddress', example='aa:bb:cc:dd:ee:ff'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  systemIdentifier?: string(name='SystemIdentifier', example='3312548696141831911'),
}

model DescribeActivationCodesResponseBody = {
  items?: [ 
    {
      activateAt?: string(name='ActivateAt', description='The time when the activation code takes effect.', example='2024-10-16 16:46:20'),
      description?: string(name='Description', description='The description of the activation code.', example='testCode'),
      expireAt?: string(name='ExpireAt', description='The time when the activation code expires.', example='2054-10-16 16:46:20'),
      gmtCreated?: string(name='GmtCreated', description='The time when the activation code was generated.', example='2024-10-16 16:46:20'),
      gmtModified?: string(name='GmtModified', description='The time when the activation code was updated.', example='2024-10-16 16:46:20'),
      id?: int32(name='Id', description='The activation code ID.', example='123'),
      macAddress?: string(name='MacAddress', description='The media access control (MAC) address used in the generation of the activation code.', example='12:34:56:78:98:00'),
      name?: string(name='Name', description='The name of the activation code.', example='testName'),
      systemIdentifier?: string(name='SystemIdentifier', description='The unique identifier of the database.', example='1234567890123456'),
    }
  ](name='Items', description='The queried activation codes.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of entries returned on the current page.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='65D7ACE6-4A61-4B6E-B357-8CB24A******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of entries returned.', example='1'),
}

model DescribeActivationCodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeActivationCodesResponseBody(name='body'),
}

/**
 * @summary Queries a list of activation codes.
 *
 * @param request DescribeActivationCodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeActivationCodesResponse
 */
async function describeActivationCodesWithOptions(request: DescribeActivationCodesRequest, runtime: Util.RuntimeOptions): DescribeActivationCodesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunOrderId)) {
    query['AliyunOrderId'] = request.aliyunOrderId;
  }
  if (!Util.isUnset(request.macAddress)) {
    query['MacAddress'] = request.macAddress;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.systemIdentifier)) {
    query['SystemIdentifier'] = request.systemIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeActivationCodes',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of activation codes.
 *
 * @param request DescribeActivationCodesRequest
 * @return DescribeActivationCodesResponse
 */
async function describeActivationCodes(request: DescribeActivationCodesRequest): DescribeActivationCodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeActivationCodesWithOptions(request, runtime);
}

model DescribeActiveOperationMaintainConfRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-re*********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeActiveOperationMaintainConfResponseBody = {
  config?: {
    createdTime?: string(name='CreatedTime', example='2023-07-04T19:28:46'),
    cycleTime?: string(name='CycleTime', example='1'),
    cycleType?: int32(name='CycleType', example='Week'),
    maintainEndTime?: string(name='MaintainEndTime', example='09:00Z'),
    maintainStartTime?: string(name='MaintainStartTime', example='8:00Z'),
    modifiedTime?: string(name='ModifiedTime', example='2025-04-02T02:10:08Z'),
    status?: long(name='Status', example='1'),
  }(name='Config'),
  hasConfig?: long(name='HasConfig', example='0'),
  requestId?: string(name='RequestId', example='14109129-EF13-5C83-AD86-7581D9552603'),
}

model DescribeActiveOperationMaintainConfResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeActiveOperationMaintainConfResponseBody(name='body'),
}

/**
 * @summary 获取用户的运维配置信息，目前包括主动运维窗口信息
 *
 * @param request DescribeActiveOperationMaintainConfRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeActiveOperationMaintainConfResponse
 */
async function describeActiveOperationMaintainConfWithOptions(request: DescribeActiveOperationMaintainConfRequest, runtime: Util.RuntimeOptions): DescribeActiveOperationMaintainConfResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeActiveOperationMaintainConf',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取用户的运维配置信息，目前包括主动运维窗口信息
 *
 * @param request DescribeActiveOperationMaintainConfRequest
 * @return DescribeActiveOperationMaintainConfResponse
 */
async function describeActiveOperationMaintainConf(request: DescribeActiveOperationMaintainConfRequest): DescribeActiveOperationMaintainConfResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeActiveOperationMaintainConfWithOptions(request, runtime);
}

model DescribeActiveOperationTasksRequest {
  allowCancel?: long(name='AllowCancel', example='-1'),
  allowChange?: long(name='AllowChange', example='-1'),
  changeLevel?: string(name='ChangeLevel', example='all'),
  DBClusterId?: string(name='DBClusterId', example='pc-3ns***********d5d'),
  DBType?: string(name='DBType', example='MySQL'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. The value must be an integer that is greater than 0. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values:

*   **30** (default)
*   **50**
*   **100**', example='30'),
  regionId?: string(name='RegionId', description='This parameter is required.', example='cn-beijing'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  status?: long(name='Status', example='-1'),
  taskType?: string(name='TaskType', example='DatabaseProxyUpgrading'),
}

model DescribeActiveOperationTasksResponseBody = {
  items?: [ 
    {
      allowCancel?: long(name='AllowCancel', example='0'),
      allowChange?: long(name='AllowChange', example='0'),
      changeLevel?: string(name='ChangeLevel', example='S0'),
      changeLevelEn?: string(name='ChangeLevelEn', example='System maintenance'),
      changeLevelZh?: string(name='ChangeLevelZh'),
      createdTime?: string(name='CreatedTime', example='2020-06-09T22:00:42Z'),
      currentAVZ?: string(name='CurrentAVZ', example='cn-beijing-h'),
      DBClusterId?: string(name='DBClusterId', example='pc-*****************'),
      DBNodeIds?: [ string ](name='DBNodeIds'),
      DBType?: string(name='DBType', example='MySQL'),
      DBVersion?: string(name='DBVersion', example='8.0'),
      deadline?: string(name='Deadline', example='2020-06-11T15:59:59Z'),
      impact?: string(name='Impact', example='TransientDisconnection'),
      impactEn?: string(name='ImpactEn', example='Transient instance disconnection'),
      impactZh?: string(name='ImpactZh'),
      insComment?: string(name='InsComment', example='test'),
      modifiedTime?: string(name='ModifiedTime', example='2020-06-09T22:00:42Z'),
      prepareInterval?: string(name='PrepareInterval', example='04:00:00'),
      region?: string(name='Region', example='cn-hangzhou'),
      resultInfo?: string(name='ResultInfo', example='userCancel'),
      startTime?: string(name='StartTime', example='2023-05-19T02:48:17Z'),
      status?: int32(name='Status', example='3'),
      switchTime?: string(name='SwitchTime', example='2020-06-09T22:00:00Z'),
      taskId?: int32(name='TaskId', example='107202351'),
      taskParams?: string(name='TaskParams', example='{
      "Action": "UpgradeDBInstance"
}'),
      taskType?: string(name='TaskType', example='DatabaseSoftwareUpgrading'),
      taskTypeEn?: string(name='TaskTypeEn', example='Minor version update'),
      taskTypeZh?: string(name='TaskTypeZh'),
    }
  ](name='Items'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  requestId?: string(name='RequestId', example='FAF88508-D5F8-52B1-8824-262601769E31'),
  totalRecordCount?: int32(name='TotalRecordCount', example='1'),
}

model DescribeActiveOperationTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeActiveOperationTasksResponseBody(name='body'),
}

/**
 * @summary 用户侧查询运维任务
 *
 * @param request DescribeActiveOperationTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeActiveOperationTasksResponse
 */
async function describeActiveOperationTasksWithOptions(request: DescribeActiveOperationTasksRequest, runtime: Util.RuntimeOptions): DescribeActiveOperationTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allowCancel)) {
    query['AllowCancel'] = request.allowCancel;
  }
  if (!Util.isUnset(request.allowChange)) {
    query['AllowChange'] = request.allowChange;
  }
  if (!Util.isUnset(request.changeLevel)) {
    query['ChangeLevel'] = request.changeLevel;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeActiveOperationTasks',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 用户侧查询运维任务
 *
 * @param request DescribeActiveOperationTasksRequest
 * @return DescribeActiveOperationTasksResponse
 */
async function describeActiveOperationTasks(request: DescribeActiveOperationTasksRequest): DescribeActiveOperationTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeActiveOperationTasksWithOptions(request, runtime);
}

model DescribeApplicationAttributeRequest {
  applicationId?: string(name='ApplicationId', description='This parameter is required.', example='pa-**************'),
}

model DescribeApplicationAttributeResponseBody = {
  applicationId?: string(name='ApplicationId', example='pa-**************'),
  applicationType?: string(name='ApplicationType', example='supabase'),
  architecture?: string(name='Architecture', example='x86'),
  components?: [ 
    {
      componentClass?: string(name='ComponentClass', example='polar.app.g2.medium'),
      componentClassDescription?: string(name='ComponentClassDescription', example='2C4GB'),
      componentId?: string(name='ComponentId', example='pac-*******************'),
      componentMaxReplica?: long(name='ComponentMaxReplica', example='1'),
      componentReplica?: long(name='ComponentReplica', example='1'),
      componentReplicaGroupName?: string(name='ComponentReplicaGroupName', example='default'),
      componentType?: string(name='ComponentType', example='gateway'),
      securityGroups?: [ 
        {
          netType?: string(name='NetType', example='vpc'),
          regionId?: string(name='RegionId', example='cn-beijing'),
          securityGroupId?: string(name='SecurityGroupId', example='sg-*******************'),
          securityGroupName?: string(name='SecurityGroupName', example='MyGroupName'),
        }
      ](name='SecurityGroups'),
      securityIPArrays?: [ 
        {
          securityIPArrayName?: string(name='SecurityIPArrayName', example='default'),
          securityIPArrayTag?: string(name='SecurityIPArrayTag', example='mytag'),
          securityIPList?: string(name='SecurityIPList', example='127.0.0.1'),
          securityIPNetType?: string(name='SecurityIPNetType', example='mix'),
          securityIPType?: string(name='SecurityIPType', example='ipv4'),
        }
      ](name='SecurityIPArrays'),
      status?: string(name='Status', example='Activated'),
      topology?: {
        children?: [ string ](name='Children'),
        layer?: string(name='Layer', example='0'),
        parents?: [ string ](name='Parents'),
      }(name='Topology'),
    }
  ](name='Components'),
  creationTime?: string(name='CreationTime', example='2025-03-25T09:37:10Z'),
  DBClusterId?: string(name='DBClusterId', example='pc-**************'),
  description?: string(name='Description', example='myapp'),
  endpoints?: [ 
    {
      description?: string(name='Description', example='myendpoint'),
      endpointId?: string(name='EndpointId', example='pa-**************'),
      IP?: string(name='IP', example='172.31.95.252'),
      netType?: string(name='NetType', example='Private'),
      port?: string(name='Port', example='8080'),
    }
  ](name='Endpoints'),
  expireTime?: string(name='ExpireTime', example='2025-06-25T09:37:10Z'),
  expired?: boolean(name='Expired', example='false'),
  lockMode?: string(name='LockMode', example='Unlock'),
  maintainEndTime?: string(name='MaintainEndTime', example='19:00Z'),
  maintainStartTime?: string(name='MaintainStartTime', example='18:00Z'),
  payType?: string(name='PayType', example='Postpaid'),
  polarFSInstanceId?: string(name='PolarFSInstanceId', example='pfs-**************'),
  regionId?: string(name='RegionId', example='cn-beijing'),
  requestId?: string(name='RequestId', example='3E5CD764-FCCA-5C9C-838E-20E0DE84B2AF'),
  securityGroups?: [ 
    {
      netType?: string(name='NetType', example='vpc'),
      regionId?: string(name='RegionId', example='cn-beijing'),
      securityGroupId?: string(name='SecurityGroupId', example='sg-**************'),
      securityGroupName?: string(name='SecurityGroupName', example='MyGroupName'),
    }
  ](name='SecurityGroups'),
  securityIPArrays?: [ 
    {
      securityIPArrayName?: string(name='SecurityIPArrayName', example='default'),
      securityIPArrayTag?: string(name='SecurityIPArrayTag', example='mytag'),
      securityIPList?: string(name='SecurityIPList', example='127.0.0.1'),
      securityIPNetType?: string(name='SecurityIPNetType', example='mix'),
      securityIPType?: string(name='SecurityIPType', example='ipv4'),
    }
  ](name='SecurityIPArrays'),
  serverlessType?: string(name='ServerlessType'),
  status?: string(name='Status', example='Activated'),
  upgradeAvailable?: string(name='UpgradeAvailable', example='false'),
  VPCId?: string(name='VPCId', description='VPC ID', example='vpc-*******************'),
  vSwitchId?: string(name='VSwitchId', description='VSwitch ID', example='vsw-*******************'),
  version?: string(name='Version', example='1.0.0'),
  zoneId?: string(name='ZoneId', example='cn-beijing-l'),
}

model DescribeApplicationAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeApplicationAttributeResponseBody(name='body'),
}

/**
 * @summary 获取应用详情
 *
 * @param request DescribeApplicationAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeApplicationAttributeResponse
 */
async function describeApplicationAttributeWithOptions(request: DescribeApplicationAttributeRequest, runtime: Util.RuntimeOptions): DescribeApplicationAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationId)) {
    query['ApplicationId'] = request.applicationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApplicationAttribute',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取应用详情
 *
 * @param request DescribeApplicationAttributeRequest
 * @return DescribeApplicationAttributeResponse
 */
async function describeApplicationAttribute(request: DescribeApplicationAttributeRequest): DescribeApplicationAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeApplicationAttributeWithOptions(request, runtime);
}

model DescribeApplicationParametersRequest {
  applicationId?: string(name='ApplicationId', description='This parameter is required.', example='pa-**************'),
  componentIdList?: [ string ](name='ComponentIdList'),
}

model DescribeApplicationParametersShrinkRequest {
  applicationId?: string(name='ApplicationId', description='This parameter is required.', example='pa-**************'),
  componentIdListShrink?: string(name='ComponentIdList'),
}

model DescribeApplicationParametersResponseBody = {
  parameterTemplates?: {
    componentParameterTemplates?: [ 
      {
        componentId?: string(name='ComponentId', example='pac-**************'),
        componentType?: string(name='ComponentType', example='supabase'),
        parameters?: [ 
          {
            default?: string(name='Default', example='default'),
            description?: string(name='Description', example='The name of the parameter'),
            name?: string(name='Name', example='name'),
            needRestart?: boolean(name='NeedRestart', example='false'),
            pattern?: string(name='Pattern', example='^[a-zA-Z0-9]{1,20}$'),
            readOnly?: boolean(name='ReadOnly', example='false'),
            type?: string(name='Type', example='string'),
          }
        ](name='Parameters'),
      }
    ](name='ComponentParameterTemplates'),
  }(name='ParameterTemplates'),
  parameters?: {
    componentParameters?: [ 
      {
        componentId?: string(name='ComponentId', example='pac-**************'),
        componentType?: string(name='ComponentType', example='supabase'),
        parameters?: [ 
          {
            default?: string(name='Default', example='default value'),
            description?: string(name='Description', example='The name of the parameter'),
            name?: string(name='Name', example='name'),
            needRestart?: boolean(name='NeedRestart', example='false'),
            pattern?: string(name='Pattern', example='^[a-zA-Z0-9]{1,20}$'),
            readOnly?: boolean(name='ReadOnly', example='false'),
            status?: string(name='Status', example='Applied'),
            type?: string(name='Type', example='string'),
            value?: string(name='Value', example='value'),
          }
        ](name='Parameters'),
      }
    ](name='ComponentParameters'),
  }(name='Parameters'),
  requestId?: string(name='RequestId', example='3E5CD764-FCCA-5C9C-838E-20E0DE84B2AF'),
}

model DescribeApplicationParametersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeApplicationParametersResponseBody(name='body'),
}

/**
 * @summary 获取应用组件参数
 *
 * @param tmpReq DescribeApplicationParametersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeApplicationParametersResponse
 */
async function describeApplicationParametersWithOptions(tmpReq: DescribeApplicationParametersRequest, runtime: Util.RuntimeOptions): DescribeApplicationParametersResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeApplicationParametersShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.componentIdList)) {
    request.componentIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.componentIdList, 'ComponentIdList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.applicationId)) {
    query['ApplicationId'] = request.applicationId;
  }
  if (!Util.isUnset(request.componentIdListShrink)) {
    query['ComponentIdList'] = request.componentIdListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApplicationParameters',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取应用组件参数
 *
 * @param request DescribeApplicationParametersRequest
 * @return DescribeApplicationParametersResponse
 */
async function describeApplicationParameters(request: DescribeApplicationParametersRequest): DescribeApplicationParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeApplicationParametersWithOptions(request, runtime);
}

model DescribeApplicationServerlessConfRequest {
  applicationId?: string(name='ApplicationId', description='This parameter is required.', example='pa-**************'),
}

model DescribeApplicationServerlessConfResponseBody = {
  applicationId?: string(name='ApplicationId', example='pa-**************'),
  requestId?: string(name='RequestId', example='CDB3258F-B5DE-43C4-8935-CBA0CA******'),
  serverlessConfItems?: [ 
    {
      componentType?: string(name='ComponentType', example='gateway'),
      scaleMax?: string(name='ScaleMax', example='16'),
      scaleMin?: string(name='ScaleMin', example='1'),
    }
  ](name='ServerlessConfItems'),
}

model DescribeApplicationServerlessConfResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeApplicationServerlessConfResponseBody(name='body'),
}

/**
 * @summary 获取应用serverless配置
 *
 * @param request DescribeApplicationServerlessConfRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeApplicationServerlessConfResponse
 */
async function describeApplicationServerlessConfWithOptions(request: DescribeApplicationServerlessConfRequest, runtime: Util.RuntimeOptions): DescribeApplicationServerlessConfResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationId)) {
    query['ApplicationId'] = request.applicationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApplicationServerlessConf',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取应用serverless配置
 *
 * @param request DescribeApplicationServerlessConfRequest
 * @return DescribeApplicationServerlessConfResponse
 */
async function describeApplicationServerlessConf(request: DescribeApplicationServerlessConfRequest): DescribeApplicationServerlessConfResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeApplicationServerlessConfWithOptions(request, runtime);
}

model DescribeApplicationsRequest {
  applicationIds?: string(name='ApplicationIds', example='pa-**************'),
  DBClusterId?: string(name='DBClusterId', example='pc-**************'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  regionId?: string(name='RegionId', description='This parameter is required.', example='cn-beijing'),
}

model DescribeApplicationsResponseBody = {
  items?: {
    applications?: [ 
    {
      applicationId?: string(name='ApplicationId', example='pa-**************'),
      applicationType?: string(name='ApplicationType', example='supabase'),
      creationTime?: string(name='CreationTime', example='2025-03-25T09:37:10Z'),
      description?: string(name='Description', example='myapp'),
      endpoints?: {
        endpoint?: [ 
        {
          IP?: string(name='IP', example='192.168.0.3'),
          netType?: string(name='NetType', example='Public'),
          port?: string(name='Port', example='8080'),
        }
      ](name='endpoint')
      }(name='Endpoints'),
      engineVersion?: string(name='EngineVersion', example='1.0.0'),
      expireTime?: string(name='ExpireTime', example='2025-06-25T09:37:10Z'),
      expired?: string(name='Expired', example='false'),
      payType?: string(name='PayType', example='Postpaid'),
      polarFSInstanceId?: string(name='PolarFSInstanceId', example='pcs-**************'),
      regionId?: string(name='RegionId', example='cn-hangzhou'),
      status?: string(name='Status', example='Activated'),
      zoneId?: string(name='ZoneId', example='cn-hangzhou-b'),
    }
  ](name='Applications')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', example='1'),
  requestId?: string(name='RequestId', example='3E5CD764-FCCA-5C9C-838E-20E0DE84B2AF'),
  totalRecordCount?: int32(name='TotalRecordCount', example='1'),
}

model DescribeApplicationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeApplicationsResponseBody(name='body'),
}

/**
 * @summary 获取当前地域所有PolarDB实例的应用列表
 *
 * @param request DescribeApplicationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeApplicationsResponse
 */
async function describeApplicationsWithOptions(request: DescribeApplicationsRequest, runtime: Util.RuntimeOptions): DescribeApplicationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationIds)) {
    query['ApplicationIds'] = request.applicationIds;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApplications',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取当前地域所有PolarDB实例的应用列表
 *
 * @param request DescribeApplicationsRequest
 * @return DescribeApplicationsResponse
 */
async function describeApplications(request: DescribeApplicationsRequest): DescribeApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeApplicationsWithOptions(request, runtime);
}

model DescribeAutoRenewAttributeRequest {
  cloudProvider?: string(name='CloudProvider', example='ENS'),
  DBClusterIds?: string(name='DBClusterIds', description='The ID of the cluster. If you need to specify multiple cluster IDs, separate the cluster IDs with commas (,).', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value must be an integer that is greater than 0. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 30, 50, and 100. Default value: 30.', example='30'),
  regionId?: string(name='RegionId', description='The ID of the region.

>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the region ID details.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-re*********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAutoRenewAttributeResponseBody = {
  items?: {
    autoRenewAttribute?: [ 
    {
      autoRenewEnabled?: boolean(name='AutoRenewEnabled', description='Indicates whether the auto-renewal feature is enabled. Valid values:

*   true: enabled
*   false: disabled', example='true'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-*****************'),
      duration?: int32(name='Duration', description='The renewal duration.', example='4'),
      periodUnit?: string(name='PeriodUnit', description='The unit of the duration. Valid values:

*   Year
*   Month', example='Month'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      renewalStatus?: string(name='RenewalStatus', description='The renewal status. Valid values:

*   AutoRenewal: The cluster is automatically renewed.
*   Normal: The cluster is manually renewed. The system sends a text message to remind you before the cluster expires.
*   NotRenewal: The cluster is not renewed. The system does not send a reminder for expiration but only sends a text message three days before the cluster expires to remind you that the cluster is not renewed.', example='AutoRenewal'),
    }
  ](name='AutoRenewAttribute')
  }(name='Items', description='The renewal information about the clusters.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page returned.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The total number of pages returned.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='65D7ACE6-4A61-4B6E-B357-8CB24A******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of entries.', example='1'),
}

model DescribeAutoRenewAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAutoRenewAttributeResponseBody(name='body'),
}

/**
 * @summary Queries the auto-renewal attributes of a subscription PolarDB cluster.
 *
 * @param request DescribeAutoRenewAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAutoRenewAttributeResponse
 */
async function describeAutoRenewAttributeWithOptions(request: DescribeAutoRenewAttributeRequest, runtime: Util.RuntimeOptions): DescribeAutoRenewAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cloudProvider)) {
    query['CloudProvider'] = request.cloudProvider;
  }
  if (!Util.isUnset(request.DBClusterIds)) {
    query['DBClusterIds'] = request.DBClusterIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAutoRenewAttribute',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the auto-renewal attributes of a subscription PolarDB cluster.
 *
 * @param request DescribeAutoRenewAttributeRequest
 * @return DescribeAutoRenewAttributeResponse
 */
async function describeAutoRenewAttribute(request: DescribeAutoRenewAttributeRequest): DescribeAutoRenewAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAutoRenewAttributeWithOptions(request, runtime);
}

model DescribeAvailableCrossRegionsRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-xxxxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAvailableCrossRegionsResponseBody = {
  regions?: [ string ](name='Regions', example='[\\\\"cn-beijing\\\\", \\\\"cn-shanghai\\\\", \\\\"cn-qingdao\\\\", \\\\"cn-shenzhen\\\\", \\\\"cn-hongkong\\\\"]'),
  requestId?: string(name='RequestId', example='D685D479-B36E-52B9-98FF-8402EA01F***'),
}

model DescribeAvailableCrossRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAvailableCrossRegionsResponseBody(name='body'),
}

/**
 * @summary 查询可用跨地域备份地域列表
 *
 * @param request DescribeAvailableCrossRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAvailableCrossRegionsResponse
 */
async function describeAvailableCrossRegionsWithOptions(request: DescribeAvailableCrossRegionsRequest, runtime: Util.RuntimeOptions): DescribeAvailableCrossRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAvailableCrossRegions',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询可用跨地域备份地域列表
 *
 * @param request DescribeAvailableCrossRegionsRequest
 * @return DescribeAvailableCrossRegionsResponse
 */
async function describeAvailableCrossRegions(request: DescribeAvailableCrossRegionsRequest): DescribeAvailableCrossRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableCrossRegionsWithOptions(request, runtime);
}

model DescribeBackupLogsRequest {
  backupRegion?: string(name='BackupRegion', description='The region for the backup data.', example='cn-hangzhou'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-**************'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-02-12T15:00Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. The value must be an integer that is larger than 0. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-02-01T15:00Z'),
}

model DescribeBackupLogsResponseBody = {
  items?: {
    backupLog?: [ 
    {
      backupLogEndTime?: string(name='BackupLogEndTime', description='The time when the backup task ended. The time follows the ISO 8601 standard in the `YYYY-MM-DD\\\\"T\\\\"HH:mm:ssZ` format. The time is displayed in UTC.', example='2020-02-12T03:55:31Z'),
      backupLogId?: string(name='BackupLogId', description='The ID of the backup log.', example='1111111111'),
      backupLogName?: string(name='BackupLogName', description='The name of the backup log.', example='ib_logfile1'),
      backupLogSize?: string(name='BackupLogSize', description='The size of the backup log. Unit: bytes.', example='1073741824'),
      backupLogStartTime?: string(name='BackupLogStartTime', description='The time when the backup task started. The time follows the ISO 8601 standard in the `YYYY-MM-DD\\\\"T\\\\"HH:mm:ssZ` format. The time is displayed in UTC.', example='2020-02-12T03:54:43Z'),
      downloadLink?: string(name='DownloadLink', description='The public URL used to download the backup log.', example='http://***********.oss-cn-hangzhou.aliyuncs.com'),
      intranetDownloadLink?: string(name='IntranetDownloadLink', description='The internal URL used to download the backup log.', example='http://***********.oss-cn-hangzhou-internal.aliyuncs.com'),
      linkExpiredTime?: string(name='LinkExpiredTime', description='The time when the download URL expires.', example='2020-02-14T08:40:50Z'),
    }
  ](name='BackupLog')
  }(name='Items', description='The details of the backup logs.'),
  pageNumber?: string(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageRecordCount?: string(name='PageRecordCount', description='The number of entries returned per page.', example='2'),
  requestId?: string(name='RequestId', description='The request ID.', example='ADAC63DB-0691-4ECE-949A-FAEA68******'),
  totalRecordCount?: string(name='TotalRecordCount', description='The total number of returned entries.', example='2'),
}

model DescribeBackupLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupLogsResponseBody(name='body'),
}

/**
 * @summary Queries backup logs and the URLs to download the backup logs.
 *
 * @param request DescribeBackupLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupLogsResponse
 */
async function describeBackupLogsWithOptions(request: DescribeBackupLogsRequest, runtime: Util.RuntimeOptions): DescribeBackupLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupRegion)) {
    query['BackupRegion'] = request.backupRegion;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupLogs',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries backup logs and the URLs to download the backup logs.
 *
 * @param request DescribeBackupLogsRequest
 * @return DescribeBackupLogsResponse
 */
async function describeBackupLogs(request: DescribeBackupLogsRequest): DescribeBackupLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupLogsWithOptions(request, runtime);
}

model DescribeBackupPolicyRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/2319131.html) operation to query the information about all AnalyticDB for MySQL clusters within a region, including cluster IDs.

This parameter is required.', example='pc-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeBackupPolicyResponseBody = {
  advancedDataPolicies?: {
    advancedDataPolicy?: [ 
    {
      autoCreated?: boolean(name='AutoCreated'),
      bakType?: string(name='BakType'),
      destRegion?: string(name='DestRegion'),
      destType?: string(name='DestType'),
      dumpAction?: string(name='DumpAction'),
      filterKey?: string(name='FilterKey'),
      filterType?: string(name='FilterType'),
      filterValue?: string(name='FilterValue'),
      onlyPreserveOneEachDay?: boolean(name='OnlyPreserveOneEachDay'),
      onlyPreserveOneEachHour?: boolean(name='OnlyPreserveOneEachHour'),
      policyId?: string(name='PolicyId'),
      retentionType?: string(name='RetentionType'),
      retentionValue?: string(name='RetentionValue'),
      srcRegion?: string(name='SrcRegion'),
      srcType?: string(name='SrcType'),
    }
  ](name='AdvancedDataPolicy')
  }(name='AdvancedDataPolicies'),
  advancedPolicyOption?: string(name='AdvancedPolicyOption'),
  backupFrequency?: string(name='BackupFrequency', description='The backup frequency. Default value: Normal. Valid values:

*   **Normal**: standard backup. The system backs up data once a day.
*   **2/24H**: enhanced backup. The system backs up data every 2 hours.
*   **3/24H**: enhanced backup. The system backs up data every 3 hours.
*   **4/24H**: enhanced backup. The system backs up data every 4 hours.

> - If enhanced backup is enabled, all backups are retained for 24 hours. Backups are automatically deleted when the retention period ends. However, the system permanently retains the first backup that is created after 00:00 every day.
>-  If enhanced backup is enabled, **PreferredBackupPeriod** is automatically set to all days in a week (from Monday to Sunday).', example='Normal'),
  backupPolicyLevel?: string(name='BackupPolicyLevel'),
  backupRetentionPolicyOnClusterDeletion?: string(name='BackupRetentionPolicyOnClusterDeletion', description='Indicates whether backups are retained when you delete a cluster. Valid values:

*   **ALL**: permanently retains all backups.
*   **LATEST**: permanently retains the most recent backup.
*   **NONE**: does not retain backups.', example='NONE'),
  dataLevel1BackupFrequency?: string(name='DataLevel1BackupFrequency', description='The backup frequency of level-1 backups. Default value: Normal. Valid values:

*   **Normal**: standard backup. The system backs up data once a day.
*   **2/24H**: frequent backup. The system backs up data every 2 hours.
*   **3/24H**: frequent backup. The system backs up data every 3 hours.
*   **4/24H**: frequent backup. The system backs up data every 4 hours.

>- This parameter is not supported for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is unavailable if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Normal'),
  dataLevel1BackupPeriod?: string(name='DataLevel1BackupPeriod', description='The backup cycle of level-1 backups. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is not supported for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is unavailable if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Monday,Tuesday'),
  dataLevel1BackupRetentionPeriod?: string(name='DataLevel1BackupRetentionPeriod', description='The retention period of level-1 backups. Valid values: 3 to 14. Unit: day.', example='7'),
  dataLevel1BackupTime?: string(name='DataLevel1BackupTime', description='The period of time during which automatic backup is performed. The value must be in the `hh:mmZ-hh:mmZ` format. The time must be in UTC. The start time and the end time must be on the hour and must have an interval of 1 hour. Example: `14:00Z-15:00Z`.

>- This parameter is not supported for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is unavailable if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='15:00Z-16:00Z'),
  dataLevel2BackupAnotherRegionRegion?: string(name='DataLevel2BackupAnotherRegionRegion', description='The region where the cross-region level-2 backup is stored. For information about regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='cn-hangzhou'),
  dataLevel2BackupAnotherRegionRetentionPeriod?: string(name='DataLevel2BackupAnotherRegionRetentionPeriod', description='The retention period of cross-region level-2 backups. Valid values:

*   **0**: The cross-region level-2 backup feature is disabled.
*   **30 to 7300**: Cross-region level-2 backups are retained for 30 to 7,300 days.
*   **1**: Cross-region level-2 backups are retained for a long period of time.

>  The default value of the parameter is **0**.', example='30'),
  dataLevel2BackupPeriod?: string(name='DataLevel2BackupPeriod', description='The backup cycle of level-2 backups. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is not supported for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is unavailable if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Monday,Tuesday'),
  dataLevel2BackupRetentionPeriod?: string(name='DataLevel2BackupRetentionPeriod', description='The retention period of level-2 backups. Valid values:

*   0: The level-2 backup feature is disabled.
*   30 to 7300: Level-2 backups are retained for 30 to 7,300 days.
*   \\\\-1: Level-2 backups are retained for a long period of time.

>  The default value of this parameter is **0**.', example='0'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod', description='The backup cycle. Valid values:

*   Monday
*   Tuesday
*   Wednesday
*   Thursday
*   Friday
*   Saturday
*   Sunday', example='Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday'),
  preferredBackupTime?: string(name='PreferredBackupTime', description='The time period when automatic backups are performed. The format is `HH:mmZ-HH:mmZ`. The time is displayed in UTC.', example='07:00Z-08:00Z'),
  preferredNextBackupTime?: string(name='PreferredNextBackupTime', description='The time when the next automatic backup will be performed. The format is `YYYY-MM-DDThh:mmZ`. The time is displayed in UTC.', example='2020-11-16T07:30Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EADFCE0F-9FB5-4685-B395-1440B******'),
}

model DescribeBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupPolicyResponseBody(name='body'),
}

/**
 * @summary Queries the automatic backup policy of a PolarDB cluster.
 *
 * @param request DescribeBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupPolicyResponse
 */
async function describeBackupPolicyWithOptions(request: DescribeBackupPolicyRequest, runtime: Util.RuntimeOptions): DescribeBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupPolicy',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the automatic backup policy of a PolarDB cluster.
 *
 * @param request DescribeBackupPolicyRequest
 * @return DescribeBackupPolicyResponse
 */
async function describeBackupPolicy(request: DescribeBackupPolicyRequest): DescribeBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupPolicyWithOptions(request, runtime);
}

model DescribeBackupRegionsRequest {
  DBClusterId?: string(name='DBClusterId', example='pc-uf64u64fln9039***'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeBackupRegionsResponseBody = {
  regions?: [ string ](name='Regions'),
  requestId?: string(name='RequestId', example='EB07CFF0-D8A4-5C76-AED7-D00E26FC2***'),
}

model DescribeBackupRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupRegionsResponseBody(name='body'),
}

/**
 * @summary 查询备份集所在地域信息
 *
 * @param request DescribeBackupRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupRegionsResponse
 */
async function describeBackupRegionsWithOptions(request: DescribeBackupRegionsRequest, runtime: Util.RuntimeOptions): DescribeBackupRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupRegions',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询备份集所在地域信息
 *
 * @param request DescribeBackupRegionsRequest
 * @return DescribeBackupRegionsResponse
 */
async function describeBackupRegions(request: DescribeBackupRegionsRequest): DescribeBackupRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupRegionsWithOptions(request, runtime);
}

model DescribeBackupTasksRequest {
  backupJobId?: string(name='BackupJobId', description='The ID of the backup task.', example='11111111'),
  backupMode?: string(name='BackupMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Manual'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-***************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeBackupTasksResponseBody = {
  items?: {
    backupJob?: [ 
    {
      backupJobId?: string(name='BackupJobId', description='The ID of the backup task.', example='11111111'),
      backupProgressStatus?: string(name='BackupProgressStatus', description='The state of the backup task. Valid values:

*   **NoStart**
*   **Preparing**
*   **Waiting**
*   **Uploading**
*   **Checking**
*   **Finished**', example='NoStart'),
      jobMode?: string(name='JobMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Automated'),
      process?: string(name='Process', description='The progress of the backup task in percentage.', example='0'),
      startTime?: string(name='StartTime', description='The time when the backup task started. The time follows the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.', example='2020-08-08T07:24:01Z'),
      taskAction?: string(name='TaskAction', description='The type of the backup task. Valid values:

*   **TempBackupTask**: The backup task is an adhoc backup task.
*   **NormalBackupTask**: The backup task is a common backup task.', example='NormalBackupTask'),
    }
  ](name='BackupJob')
  }(name='Items', description='The details of the backup task.'),
  requestId?: string(name='RequestId', description='The request ID.', example='FA8C1EF1-E3D4-44D7-B809-823187******'),
}

model DescribeBackupTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupTasksResponseBody(name='body'),
}

/**
 * @summary Queries the backup tasks of a PolarDB cluster.
 *
 * @param request DescribeBackupTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupTasksResponse
 */
async function describeBackupTasksWithOptions(request: DescribeBackupTasksRequest, runtime: Util.RuntimeOptions): DescribeBackupTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupJobId)) {
    query['BackupJobId'] = request.backupJobId;
  }
  if (!Util.isUnset(request.backupMode)) {
    query['BackupMode'] = request.backupMode;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupTasks',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the backup tasks of a PolarDB cluster.
 *
 * @param request DescribeBackupTasksRequest
 * @return DescribeBackupTasksResponse
 */
async function describeBackupTasks(request: DescribeBackupTasksRequest): DescribeBackupTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupTasksWithOptions(request, runtime);
}

model DescribeBackupsRequest {
  backupId?: string(name='BackupId', description='The ID of the backup set.', example='11111111'),
  backupMode?: string(name='BackupMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Automated'),
  backupRegion?: string(name='BackupRegion', description='The region where the cross-region data backup file of the instance is stored.

> This parameter is valid only for PolarDB for MySQL clusters.', example='cn-hangzhou'),
  backupStatus?: string(name='BackupStatus', description='The status of the backup set. Valid values:

*   **Success**
*   **Failed**', example='Success'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-****************'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the `YYYY-MM-DDThh:mmZ` format. The time must be in UTC. The end time must be later than the start time.

This parameter is required.', example='2020-11-16T00:00Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value must be a positive integer that does not exceed the maximum value of the INTEGER data type. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-11-14T00:00Z'),
}

model DescribeBackupsResponseBody = {
  items?: {
    backup?: [ 
    {
      backupEndTime?: string(name='BackupEndTime', description='The end time of the backup task. The time is displayed in UTC.', example='2020-11-15T07:30:20Z'),
      backupId?: string(name='BackupId', description='The ID of the backup set.', example='61*******'),
      backupMethod?: string(name='BackupMethod', description='The backup method. Only **Snapshot** may be returned.', example='Snapshot'),
      backupMode?: string(name='BackupMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Automated'),
      backupSetSize?: string(name='BackupSetSize', description='The size of the backup set. Unit: bytes.

> After you delete the target snapshot backups, the storage space that is consumed by the backups is released. The released storage space is smaller than the size of the backup file, because the snapshots share specific data blocks. For more information, see [FAQ about backup](https://help.aliyun.com/document_detail/164881.html).', example='4639948800'),
      backupStartTime?: string(name='BackupStartTime', description='The start time of the backup task. The time is displayed in UTC. Unit: seconds.', example='2020-11-15T07:30:05Z'),
      backupStatus?: string(name='BackupStatus', description='The status of the backup set. Valid values:

*   **Success**
*   **Failed**', example='Success'),
      backupType?: string(name='BackupType', description='The type of the backup. Only **FullBackup** may be returned.', example='FullBackup'),
      backupsLevel?: string(name='BackupsLevel', description='The level of the backup set. Valid values:

*   **Level-1**
*   **Level-2**', example='Level-1'),
      consistentTime?: string(name='ConsistentTime', description='The snapshot checkpoint time. The value follows the Unix time format. Unit: seconds.', example='1605425407'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-****************'),
      expectExpireTime?: string(name='ExpectExpireTime', description='The expected expiration time of the backup set (This parameter is supported only for clusters for which sparse backup is enabled).', example='2022-10-24T08:13:23Z'),
      expectExpireType?: string(name='ExpectExpireType', description='The expected expiration type of the backup set (This parameter is supported only for instances that are enabled with sparse backup).

Valid values:

*   NEVER

    <!-- -->

    <!-- -->

    <!-- -->

*   EXPIRED

    <!-- -->

    <!-- -->

    <!-- -->

*   DELAY

    <!-- -->

    <!-- -->

    <!-- -->', example='EXPIRED'),
      isAvail?: string(name='IsAvail', description='Indicates whether the backup set is available. Valid values:

*   **0**: The backup set is unavailable.
*   **1**: The backup set is available.', example='0'),
    }
  ](name='Backup')
  }(name='Items', description='The queried backup sets.'),
  pageNumber?: string(name='PageNumber', description='The page number.', example='1'),
  pageRecordCount?: string(name='PageRecordCount', description='The number of entries per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='24A1990B-4F6E-482B-B8CB-75C612******'),
  totalLevel2BackupSize?: string(name='TotalLevel2BackupSize', example='4639948800'),
  totalRecordCount?: string(name='TotalRecordCount', description='The total number of returned entries.', example='1'),
}

model DescribeBackupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupsResponseBody(name='body'),
}

/**
 * @summary Queries the backup details of a PolarDB cluster.
 *
 * @param request DescribeBackupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupsResponse
 */
async function describeBackupsWithOptions(request: DescribeBackupsRequest, runtime: Util.RuntimeOptions): DescribeBackupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.backupMode)) {
    query['BackupMode'] = request.backupMode;
  }
  if (!Util.isUnset(request.backupRegion)) {
    query['BackupRegion'] = request.backupRegion;
  }
  if (!Util.isUnset(request.backupStatus)) {
    query['BackupStatus'] = request.backupStatus;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackups',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the backup details of a PolarDB cluster.
 *
 * @param request DescribeBackupsRequest
 * @return DescribeBackupsResponse
 */
async function describeBackups(request: DescribeBackupsRequest): DescribeBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupsWithOptions(request, runtime);
}

model DescribeCharacterSetNameRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can only query character sets that PolarDB for MySQL clusters support. If you enter the ID of a PolarDB for PostgreSQL or PolarDB for Oracle cluster, the returned value of the `CharacterSetNameItems` parameter is an empty string.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query available regions.

This parameter is required.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeCharacterSetNameResponseBody = {
  characterSetNameItems?: {
    characterSetName?: [ string ](name='CharacterSetName')
  }(name='CharacterSetNameItems', description='The character sets that are supported.'),
  engine?: string(name='Engine', description='The type of the database engine.', example='POLARDB'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='34458CD3-33E0-4624-BFEF-840C15******'),
}

model DescribeCharacterSetNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCharacterSetNameResponseBody(name='body'),
}

/**
 * @summary Queries character sets that are supported by a PolarDB for MySQL cluster.
 *
 * @param request DescribeCharacterSetNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCharacterSetNameResponse
 */
async function describeCharacterSetNameWithOptions(request: DescribeCharacterSetNameRequest, runtime: Util.RuntimeOptions): DescribeCharacterSetNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCharacterSetName',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries character sets that are supported by a PolarDB for MySQL cluster.
 *
 * @param request DescribeCharacterSetNameRequest
 * @return DescribeCharacterSetNameResponse
 */
async function describeCharacterSetName(request: DescribeCharacterSetNameRequest): DescribeCharacterSetNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCharacterSetNameWithOptions(request, runtime);
}

model DescribeClassListRequest {
  commodityCode?: string(name='CommodityCode', description='The code of the commodity. Valid values:

*   polardb_sub: the subscription cluster in regions in the Chinese mainland
*   polardb_sub _intl: the subscription cluster in regions outside the Chinese mainland
*   polardb_payg: the pay-as-you-go cluster in regions in the Chinese mainland
*   polardb_payg_intl: the pay-as-you-go cluster in regions outside the Chinese mainland
*   polardb_sub_jushita: the subscription cluster for CloudTmall
*   polardb_payg_jushita: the pay-as-you-go cluster for CloudTmall
*   polardb_sub_cainiao: the subscription cluster for Cainiao
*   polardb_payg_cainiao: the pay-as-you-go cluster for Cainiao

> *   If you use an Alibaba Cloud account on the China site, you can view only the codes of the commodities that are available in the Chinese mainland.
>*   If you are using an Alibaba Cloud international account, you can view only the codes of the commodities that are available outside the Chinese mainland.
>*   If you use a CloudTmall account, you can view only the codes of the commodities that are available in CloudTmall.
>*   If you use a Cainiao account, you can view only the codes of the commodities that are available in Cainiao.

This parameter is required.', example='polardb_sub'),
  masterHa?: string(name='MasterHa', description='The number of nodes. Valid values:

*   single: Standalone Edition.
*   cluster: Cluster Edition.
*   all: both Standalone Edition and Cluster Edition.', example='cluster'),
  orderType?: string(name='OrderType', description='The type of the order. Valid values:

*   BUY: The order is used to purchase a cluster.
*   UPGRADE: The order is used to change the specifications of a cluster.
*   RENEW: The order is used to renew a cluster.
*   CONVERT: The order is used to change the billing method of a cluster.', example='BUY'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeClassListResponseBody = {
  items?: [ 
    {
      classCode?: string(name='ClassCode', description='The specifications of the cluster.', example='polar.mysql.x4.medium'),
      classGroup?: string(name='ClassGroup', description='The instance family of the cluster. Valid values:

*   Exclusive package: dedicated
*   Exclusive physical machine: dedicated host
*   Beginner: starter
*   Historical specifications: historical', example='Exclusive package'),
      classTypeLevel?: string(name='ClassTypeLevel', description='The specification type of the cluster.', example='enterprise'),
      cpu?: string(name='Cpu', description='The number of vCPU cores. Unit: cores.', example='8'),
      essdMaxStorageCapacity?: string(name='EssdMaxStorageCapacity', description='The maximum ESSD storage capacity. Unit: TB.', example='64'),
      maxConnections?: string(name='MaxConnections', description='The maximum number of concurrent connections in the cluster.', example='8000'),
      maxIOPS?: string(name='MaxIOPS', description='The maximum IOPS. Unit: operations per second.', example='32000'),
      maxStorageCapacity?: string(name='MaxStorageCapacity', description='The maximum storage capacity. Unit: TB.', example='20'),
      memoryClass?: string(name='MemoryClass', description='The memory size. Unit: GB.', example='32'),
      pl1MaxIOPS?: string(name='Pl1MaxIOPS', description='The maximum IOPS of an enhanced SSD (ESSD) of performance level 1 (PL1). Unit: operations per second.', example='50000'),
      pl2MaxIOPS?: string(name='Pl2MaxIOPS', description='The maximum IOPS of an ESSD of performance level 2 (PL2). Unit: operations per second.', example='100000'),
      pl3MaxIOPS?: string(name='Pl3MaxIOPS', description='The maximum IOPS of an ESSD of performance level 3 (PL3). Unit: operations per second.', example='1000000'),
      polarStoreMaxStorageCapacity?: string(name='PolarStoreMaxStorageCapacity', description='The maximum PSL4/PSL5 storage capacity. Unit: TB.', example='500'),
      psl4MaxIOPS?: string(name='Psl4MaxIOPS', description='The maximum Input/output operations per second (IOPS) for PolarStore Level 4 (PSL4). Unit: operations per second.', example='48000'),
      psl5MaxIOPS?: string(name='Psl5MaxIOPS', description='The maximum IOPS for PolarStore Level 5 (PSL5). Unit: operations per second.', example='96000'),
      referenceExtPrice?: string(name='ReferenceExtPrice', description='The additional price.

Unit: cents (USD).

>- If you set MasterHa to cluster or single, the value of ReferenceExtPrice is the same as the value of ReferencePrice.
>- If you set MasterHa to cluster or single, the value of ReferenceExtPrice is the price of the single-node cluster.', example='200000'),
      referencePrice?: string(name='ReferencePrice', description='The price.

Unit: cents (USD).

>- If you set CommodityCode to a commodity that uses the pay-as-you-go billing method, ReferencePrice indicates the hourly fee that you need to pay.
>- If you set CommodityCode to a commodity that uses the subscription billing method, ReferencePrice indicates the monthly fee that you need to pay.', example='200000'),
    }
  ](name='Items', description='The cluster specifications.'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='69A85BAF-1089-4CDF-A82F-0A140F******'),
}

model DescribeClassListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClassListResponseBody(name='body'),
}

/**
 * @summary Queries the specifications of a cluster.
 *
 * @param request DescribeClassListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClassListResponse
 */
async function describeClassListWithOptions(request: DescribeClassListRequest, runtime: Util.RuntimeOptions): DescribeClassListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.commodityCode)) {
    query['CommodityCode'] = request.commodityCode;
  }
  if (!Util.isUnset(request.masterHa)) {
    query['MasterHa'] = request.masterHa;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClassList',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the specifications of a cluster.
 *
 * @param request DescribeClassListRequest
 * @return DescribeClassListResponse
 */
async function describeClassList(request: DescribeClassListRequest): DescribeClassListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClassListWithOptions(request, runtime);
}

model DescribeColdStorageInstanceRequest {
  DBClusterId?: string(name='DBClusterId', example='pc-wz9062015ly7526jc'),
  DBName?: string(name='DBName', example='test_db'),
  engineType?: string(name='EngineType', example='2'),
  expireTime?: int32(name='ExpireTime', example='2020-11-14T16:00:00Z'),
  maxResults?: int32(name='MaxResults', example='50'),
  nextToken?: string(name='NextToken', example='c2FpXzIwMjIwNjI5X2Jhay9zYWlfc3VtbWVyX3RyZWFzdXJlX3Bvb2xfbG9nLkNTVg=='),
  objectType?: string(name='ObjectType', example='TABLE'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: string(name='PageNumber', example='1'),
  pageSize?: string(name='PageSize', example='1'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tableName?: string(name='TableName', example='account_log'),
}

model DescribeColdStorageInstanceResponseBody = {
  maxResults?: int32(name='MaxResults', example='1000'),
  nextToken?: string(name='NextToken', example='c2FpXzIwMjIwNjI5X2Jhay9zYWlfc3VtbWVyX3RyZWFzdXJlX3Bvb2xfbG9nLkNTVg=='),
  objectType?: string(name='ObjectType', example='TABLE'),
  ossClusterEnabled?: string(name='OssClusterEnabled', example='true'),
  ossClusterInfoList?: [ 
    {
      createdTime?: string(name='CreatedTime', example='2023-05-10T17:01:16Z'),
      ossClusterId?: string(name='OssClusterId', example='pc-*****************'),
      region?: string(name='Region', example='cn-hangzhou'),
      size?: string(name='Size', example='50'),
    }
  ](name='OssClusterInfoList'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  requestId?: string(name='RequestId', example='C7A8EA8E-A140-5226-90D7-5BCB304D3DB6'),
  supportOssCluster?: string(name='SupportOssCluster', example='true'),
  tables?: [ 
    {
      childObjects?: [ 
        {
          objectName?: string(name='ObjectName', example='img/1728554006462.png'),
          objectType?: string(name='ObjectType', example='File'),
          size?: string(name='Size', example='10'),
          status?: string(name='Status', example='Running'),
        }
      ](name='ChildObjects'),
      DB?: string(name='DB', example='test_db'),
      DBName?: string(name='DBName', example='test_db'),
      fieldName?: string(name='FieldName', example='user'),
      ossClusterId?: string(name='OssClusterId', example='pc-*****************'),
      partion?: string(name='Partion', example='202509'),
      size?: string(name='Size', example='30'),
      status?: string(name='Status', example='Running'),
      table?: string(name='Table', example='user'),
      tableName?: string(name='TableName', example='test_table'),
    }
  ](name='Tables'),
  totalRecord?: int32(name='TotalRecord', example='1'),
}

model DescribeColdStorageInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeColdStorageInstanceResponseBody(name='body'),
}

/**
 * @summary 查询冷存储实例信息
 *
 * @param request DescribeColdStorageInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeColdStorageInstanceResponse
 */
async function describeColdStorageInstanceWithOptions(request: DescribeColdStorageInstanceRequest, runtime: Util.RuntimeOptions): DescribeColdStorageInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.engineType)) {
    query['EngineType'] = request.engineType;
  }
  if (!Util.isUnset(request.expireTime)) {
    query['ExpireTime'] = request.expireTime;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.objectType)) {
    query['ObjectType'] = request.objectType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeColdStorageInstance',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询冷存储实例信息
 *
 * @param request DescribeColdStorageInstanceRequest
 * @return DescribeColdStorageInstanceResponse
 */
async function describeColdStorageInstance(request: DescribeColdStorageInstanceRequest): DescribeColdStorageInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeColdStorageInstanceWithOptions(request, runtime);
}

model DescribeCronJobPolicyServerlessRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-****************'),
  jobId?: string(name='JobId', example='8006e51c-dab3-4602-bc69-4f728002c6ce'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  regionId?: string(name='RegionId', description='This parameter is required.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeCronJobPolicyServerlessResponseBody = {
  items?: [ 
    {
      action?: string(name='Action', example='ModifyDBClusterServerlessConf'),
      allowShutDown?: string(name='AllowShutDown', example='true'),
      cronExpression?: string(name='CronExpression', example='0 0 8 * * ?'),
      DBClusterId?: string(name='DBClusterId', example='pc-*****************'),
      endTime?: string(name='EndTime', example='2024-12-04T02:25:00Z'),
      jobId?: string(name='JobId', example='12eee3eb-60bd-40ac-a403-218e02eb99c7'),
      orderId?: string(name='OrderId', example='254752088000354'),
      regionId?: string(name='RegionId', example='cn-hangzhou'),
      scaleApRoNumMax?: string(name='ScaleApRoNumMax', example='2'),
      scaleApRoNumMin?: string(name='ScaleApRoNumMin', example='1'),
      scaleMax?: string(name='ScaleMax', example='9'),
      scaleMin?: string(name='ScaleMin', example='1'),
      scaleRoNumMax?: string(name='ScaleRoNumMax', example='3'),
      scaleRoNumMin?: string(name='ScaleRoNumMin', example='2'),
      secondsUntilAutoPause?: string(name='SecondsUntilAutoPause', example='1200'),
      serverlessRuleCpuEnlargeThreshold?: string(name='ServerlessRuleCpuEnlargeThreshold', example='70'),
      serverlessRuleCpuShrinkThreshold?: string(name='ServerlessRuleCpuShrinkThreshold', example='40'),
      serverlessRuleMode?: string(name='ServerlessRuleMode', example='normal'),
      startTime?: string(name='StartTime', example='2020-06-09T18:00:00Z'),
      status?: string(name='Status', example='3'),
    }
  ](name='Items'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  requestId?: string(name='RequestId', description='Id of the request', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
  totalRecordCount?: int32(name='TotalRecordCount', example='5'),
}

model DescribeCronJobPolicyServerlessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCronJobPolicyServerlessResponseBody(name='body'),
}

/**
 * @summary 查询周期任务策略
 *
 * @param request DescribeCronJobPolicyServerlessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCronJobPolicyServerlessResponse
 */
async function describeCronJobPolicyServerlessWithOptions(request: DescribeCronJobPolicyServerlessRequest, runtime: Util.RuntimeOptions): DescribeCronJobPolicyServerlessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCronJobPolicyServerless',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询周期任务策略
 *
 * @param request DescribeCronJobPolicyServerlessRequest
 * @return DescribeCronJobPolicyServerlessResponse
 */
async function describeCronJobPolicyServerless(request: DescribeCronJobPolicyServerlessRequest): DescribeCronJobPolicyServerlessResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCronJobPolicyServerlessWithOptions(request, runtime);
}

model DescribeCrossCloudLevelsRequest {
  DBType?: string(name='DBType', description='This parameter is required.', example='MySQL'),
  DBVersion?: string(name='DBVersion', example='5.6'),
  projectId?: string(name='ProjectId', description='This parameter is required.', example='pj-87681rbcef6******'),
  storageType?: string(name='StorageType', description='This parameter is required.', example='SharedStorage'),
}

model DescribeCrossCloudLevelsResponseBody = {
  crossCloudLevelList?: [ 
    {
      DBType?: string(name='DBType', example='MySQL'),
      levelCode?: string(name='LevelCode', example='polar.mysql.g4.medium.c'),
      levelName?: string(name='LevelName'),
    }
  ](name='CrossCloudLevelList'),
  requestId?: string(name='RequestId', example='E56531A4-E552-40BA-9C58-137B80******'),
}

model DescribeCrossCloudLevelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCrossCloudLevelsResponseBody(name='body'),
}

/**
 * @summary 查询跨云支持的规格列表
 *
 * @param request DescribeCrossCloudLevelsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCrossCloudLevelsResponse
 */
async function describeCrossCloudLevelsWithOptions(request: DescribeCrossCloudLevelsRequest, runtime: Util.RuntimeOptions): DescribeCrossCloudLevelsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCrossCloudLevels',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询跨云支持的规格列表
 *
 * @param request DescribeCrossCloudLevelsRequest
 * @return DescribeCrossCloudLevelsResponse
 */
async function describeCrossCloudLevels(request: DescribeCrossCloudLevelsRequest): DescribeCrossCloudLevelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCrossCloudLevelsWithOptions(request, runtime);
}

model DescribeCrossCloudRegionRequest {
  cloudProvider?: string(name='CloudProvider', example='HuaweiCloud'),
  crossCloudRegionId?: string(name='CrossCloudRegionId', example='cn-east-3'),
  DBType?: string(name='DBType', example='MySQL'),
}

model DescribeCrossCloudRegionResponseBody = {
  crossCloudRegionList?: [ 
    {
      crossCloudRegionId?: string(name='CrossCloudRegionId', example='cn-east-3'),
      crossCloudRegionName?: string(name='CrossCloudRegionName', example='cn-east-3'),
      crossCloudZoneList?: [ 
        {
          crossCloudZoneId?: string(name='CrossCloudZoneId', example='cn-east-3-1'),
          crossCloudZoneName?: string(name='CrossCloudZoneName', example='cn-east-3-1'),
        }
      ](name='CrossCloudZoneList'),
      projectId?: string(name='ProjectId', example='pj-87681rbcef6******'),
    }
  ](name='CrossCloudRegionList'),
  requestId?: string(name='RequestId', example='E56531A4-E552-40BA-9C58-137B80******'),
}

model DescribeCrossCloudRegionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCrossCloudRegionResponseBody(name='body'),
}

/**
 * @summary 查看跨云开区信息
 *
 * @param request DescribeCrossCloudRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCrossCloudRegionResponse
 */
async function describeCrossCloudRegionWithOptions(request: DescribeCrossCloudRegionRequest, runtime: Util.RuntimeOptions): DescribeCrossCloudRegionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cloudProvider)) {
    query['CloudProvider'] = request.cloudProvider;
  }
  if (!Util.isUnset(request.crossCloudRegionId)) {
    query['CrossCloudRegionId'] = request.crossCloudRegionId;
  }
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCrossCloudRegion',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查看跨云开区信息
 *
 * @param request DescribeCrossCloudRegionRequest
 * @return DescribeCrossCloudRegionResponse
 */
async function describeCrossCloudRegion(request: DescribeCrossCloudRegionRequest): DescribeCrossCloudRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCrossCloudRegionWithOptions(request, runtime);
}

model DescribeCrossCloudRegionMappingToAliyunRequest {
  aliyunRegionId?: string(name='AliyunRegionId', example='cn-beijing'),
  cloudProvider?: string(name='CloudProvider', example='HuaweiCloud'),
  crossCloudRegionId?: string(name='CrossCloudRegionId', example='cn-east-3'),
}

model DescribeCrossCloudRegionMappingToAliyunResponseBody = {
  crossCloudRegionMappingList?: [ 
    {
      aliyunRegionId?: string(name='AliyunRegionId', example='cn-beijing'),
      cloudProvider?: string(name='CloudProvider', example='HuaweiCloud'),
      crossCloudRegionId?: string(name='CrossCloudRegionId', example='cn-east-3'),
    }
  ](name='CrossCloudRegionMappingList'),
  requestId?: string(name='RequestId', example='E56531A4-E552-40BA-9C58-137B80******'),
}

model DescribeCrossCloudRegionMappingToAliyunResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCrossCloudRegionMappingToAliyunResponseBody(name='body'),
}

/**
 * @summary 查询跨云地域映射
 *
 * @param request DescribeCrossCloudRegionMappingToAliyunRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCrossCloudRegionMappingToAliyunResponse
 */
async function describeCrossCloudRegionMappingToAliyunWithOptions(request: DescribeCrossCloudRegionMappingToAliyunRequest, runtime: Util.RuntimeOptions): DescribeCrossCloudRegionMappingToAliyunResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunRegionId)) {
    query['AliyunRegionId'] = request.aliyunRegionId;
  }
  if (!Util.isUnset(request.cloudProvider)) {
    query['CloudProvider'] = request.cloudProvider;
  }
  if (!Util.isUnset(request.crossCloudRegionId)) {
    query['CrossCloudRegionId'] = request.crossCloudRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCrossCloudRegionMappingToAliyun',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询跨云地域映射
 *
 * @param request DescribeCrossCloudRegionMappingToAliyunRequest
 * @return DescribeCrossCloudRegionMappingToAliyunResponse
 */
async function describeCrossCloudRegionMappingToAliyun(request: DescribeCrossCloudRegionMappingToAliyunRequest): DescribeCrossCloudRegionMappingToAliyunResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCrossCloudRegionMappingToAliyunWithOptions(request, runtime);
}

model DescribeDBClusterAccessWhitelistRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the PolarDB cluster.

This parameter is required.', example='pc-***************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterAccessWhitelistResponseBody = {
  DBClusterSecurityGroups?: {
    DBClusterSecurityGroup?: [ 
    {
      securityGroupId?: string(name='SecurityGroupId', description='The ID of the ECS security group.', example='sg-bp**************'),
      securityGroupName?: string(name='SecurityGroupName', description='The name of the ECS security group.', example='vpc-********************'),
    }
  ](name='DBClusterSecurityGroup')
  }(name='DBClusterSecurityGroups', description='The Elastic Compute Service (ECS) security groups that are associated with the cluster.'),
  items?: {
    DBClusterIPArray?: [ 
    {
      DBClusterIPArrayAttribute?: string(name='DBClusterIPArrayAttribute', description='The attributes of the IP whitelist group. Set this parameter to **hidden** to hide the IP whitelist group in the console.

> *   The IP whitelist group that has appeared in the console cannot be hidden.
> *   This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='hidden'),
      DBClusterIPArrayName?: string(name='DBClusterIPArrayName', description='The name of the IP whitelist group. The group name must be 2 to 120 characters in length and consists of lowercase letters and digits. It must start with a letter, and end with a letter or a digit.

*   If the specified whitelist group name does not exist, the whitelist group is created.
*   If the specified whitelist group name exists, the whitelist group is modified.
*   If you do not specify this parameter, the default group is modified.

> *   You can create a maximum of 50 IP whitelist groups for a cluster.
>*   This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='default'),
      securityIps?: string(name='SecurityIps', description='The IP addresses or Classless Inter-Domain Routing (CIDR) blocks in the IP whitelist group. You can add 1,000 IP addresses or CIDR blocks to all the IP whitelist groups. Separate multiple IP addresses with commas (,). The following two formats are supported:

*   IP addresses. Example: 10.23.12.24.
*   CIDR blocks. Example: 10.23.12.24/24. 24 indicates the length of the prefix of the CIDR block. The length is the range of 1 to 32.

>  This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='11.***.***.***,11.***.***.***'),
    }
  ](name='DBClusterIPArray')
  }(name='Items', description='The details about the cluster.'),
  requestId?: string(name='RequestId', description='The request ID.', example='559E91A2-CDA3-4E9F-808B-29D738******'),
}

model DescribeDBClusterAccessWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterAccessWhitelistResponseBody(name='body'),
}

/**
 * @summary Queries the IP address whitelists and security groups of a PolarDB cluster.
 *
 * @param request DescribeDBClusterAccessWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterAccessWhitelistResponse
 */
async function describeDBClusterAccessWhitelistWithOptions(request: DescribeDBClusterAccessWhitelistRequest, runtime: Util.RuntimeOptions): DescribeDBClusterAccessWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterAccessWhitelist',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the IP address whitelists and security groups of a PolarDB cluster.
 *
 * @param request DescribeDBClusterAccessWhitelistRequest
 * @return DescribeDBClusterAccessWhitelistResponse
 */
async function describeDBClusterAccessWhitelist(request: DescribeDBClusterAccessWhitelistRequest): DescribeDBClusterAccessWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterAccessWhitelistWithOptions(request, runtime);
}

model DescribeDBClusterAttributeRequest {
  DBClusterId?: string(name='DBClusterId', description='Cluster ID.
> You can view detailed information about all clusters under your account, including the cluster ID, through the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) interface.

This parameter is required.', example='pc-*****************'),
  describeType?: string(name='DescribeType', description='Whether to obtain information about AI-related nodes.', example='AI'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterAttributeResponseBody = {
  aiCreatingTime?: string(name='AiCreatingTime', description='Start time for free AI activation', example='2024-03-13T01:20:28Z'),
  aiType?: string(name='AiType', description='Types of AI nodes. Values include:

- **SearchNode**: Search node.
- **DLNode**: AI node.', example='DLNode'),
  architecture?: string(name='Architecture', description='CPU architecture. Available options are:
- **X86**
- **ARM**', example='X86'),
  autoUpgradeMinorVersion?: string(name='AutoUpgradeMinorVersion', description='The minor version upgrade method.

*   Auto
*   Manual', example='Manual'),
  blktagTotal?: long(name='BlktagTotal', description='Maximum number of blktags in the file system.', example='7,864,320'),
  blktagUsed?: long(name='BlktagUsed', description='Current blktag usage.', example='5,242,880'),
  burstingEnabled?: string(name='BurstingEnabled', example='false'),
  category?: string(name='Category', description='[Product Series](https://help.aliyun.com/document_detail/183258.html), with values as follows:
* **Normal**: Cluster Edition
* **Basic**: Single Node
* **Archive**: High Compression Engine (X-Engine)
* **NormalMultimaster**: Multi-Master Cluster Edition
* **SENormal**: Standard Edition

> * PolarDB PostgreSQL version 11 does not support single-node.
>* PolarDB MySQL versions 8.0 and 5.7, and PolarDB PostgreSQL version 14 support the Standard Edition.
>* PolarDB MySQL version 8.0 supports High Compression Engine (X-Engine) and Multi-Master Cluster Edition.', example='Normal'),
  compressStorageMode?: string(name='CompressStorageMode', description='Whether storage compression is enabled. Values are as follows:
- ON: Enabled
- OFF: Disabled', example='ON'),
  compressStorageUsed?: long(name='CompressStorageUsed', description='Compressed storage data size.
> This parameter is supported only when the cluster\\\\"s storage compression feature is enabled.', example='15529410560'),
  creationTime?: string(name='CreationTime', description='Cluster creation time.', example='2020-08-14T05:58:42Z'),
  DBClusterDescription?: string(name='DBClusterDescription', description='Cluster description.', example='test'),
  DBClusterId?: string(name='DBClusterId', description='Cluster ID.', example='pc-*****************'),
  DBClusterNetworkType?: string(name='DBClusterNetworkType', description='Network type of the cluster.', example='VPC'),
  DBClusterStatus?: string(name='DBClusterStatus', description='Cluster status. For the full list of values, refer to [Cluster Status Table](https://help.aliyun.com/document_detail/99286.html).', example='Running'),
  DBNodes?: [ 
    {
      addedCpuCores?: string(name='AddedCpuCores', description='Number of CPU cores for second-level elastic scaling.', example='6'),
      cpuCores?: string(name='CpuCores', description='Number of CPU cores for the node.', example='2'),
      creationTime?: string(name='CreationTime', description='Node creation time.', example='2020-03-23T21:35:43Z'),
      DBNodeCXLRemoteMemory?: string(name='DBNodeCXLRemoteMemory'),
      DBNodeClass?: string(name='DBNodeClass', description='Node specification.', example='polar.mysql.x4.large'),
      DBNodeDescription?: string(name='DBNodeDescription', example='test'),
      DBNodeId?: string(name='DBNodeId', description='Node ID.', example='pi-****************'),
      DBNodeRole?: string(name='DBNodeRole', description='Node role, with possible values as follows:

- **Writer**: Primary node.
- **Reader**: Read-only node.', example='Reader'),
      DBNodeStatus?: string(name='DBNodeStatus', description='Node status, with possible values as follows:
* **Creating**: Creating
* **Running**: Running
* **Deleting**: Deleting
* **Rebooting**: Rebooting
* **DBNodeCreating**: Adding node
* **DBNodeDeleting**: Removing node
* **ClassChanging**: Modifying node specification
* **NetAddressCreating**: Creating network connection
* **NetAddressDeleting**: Deleting network connection
* **NetAddressModifying**: Modifying network connection
* **MinorVersionUpgrading**: Upgrading minor version
* **Maintaining**: Instance maintenance
* **Switching**: Switching', example='Running'),
      failoverPriority?: int32(name='FailoverPriority', description='Failover priority. Each node has a failover priority, determining the likelihood of being elected as the primary node during a failover. A higher value indicates a higher priority.
Range: 1 to 15.', example='1'),
      hotReplicaMode?: string(name='HotReplicaMode', description='Whether hot standby is enabled. Possible values are:

- **ON**: Enabled
- **OFF**: Disabled', example='ON'),
      imciSwitch?: string(name='ImciSwitch', description='Whether columnar index is enabled. Possible values are:

- **ON**: Enabled
- **OFF**: Disabled', example='ON'),
      masterId?: string(name='MasterId', description='Primary node ID of the multi-master architecture cluster edition.', example='pi-bp18z52akld3*****'),
      maxConnections?: int32(name='MaxConnections', description='Maximum concurrent connections of the cluster.', example='8000'),
      maxIOPS?: int32(name='MaxIOPS', description='Maximum number of I/O requests, that is, IOPS.', example='32000'),
      memorySize?: string(name='MemorySize', description='Node memory size, in MB.', example='8192'),
      mirrorInsName?: string(name='MirrorInsName', description='The name of the hot standby compute node corresponding to the node when the hot standby storage and compute clusters feature is enabled.', example='pi-bp18z52mirror*****'),
      multiMasterLocalStandby?: string(name='MultiMasterLocalStandby'),
      multiMasterPrimaryNode?: string(name='MultiMasterPrimaryNode'),
      orca?: string(name='Orca', description='Orca feature, valid values are:
- on: enabled
- off: disabled', example='off'),
      remoteMemorySize?: string(name='RemoteMemorySize', description='Remote memory size, in MB.', example='3072'),
      sccMode?: string(name='SccMode', description='Whether the node has the global consistency (high-performance mode) feature enabled. Possible values are:

- **ON**: Enabled

- **OFF**: Disabled

This parameter is required.', example='ON'),
      serverWeight?: string(name='ServerWeight', description='Routing weight.
Range: 1~100. Default is 1.', example='1'),
      serverlessType?: string(name='ServerlessType', description='Serverless type. Possible values include:

- **AgileServerless**: Agile
- **SteadyServerless**: Steady

> This parameter is only supported by Serverless clusters.', example='AgileServerless'),
      subCluster?: string(name='SubCluster', description='Identifies whether the node is in the primary or standby availability zone, primarily used in resource mirroring scenarios.
Values include:
- **Primary**: Primary Availability Zone
- **Standby**: Standby Availability Zone', example='Primary'),
      subGroupDescription?: string(name='SubGroupDescription'),
      zoneId?: string(name='ZoneId', description='Availability zone ID.', example='cn-hangzhou-i'),
    }
  ](name='DBNodes', description='The information about the nodes.'),
  DBType?: string(name='DBType', description='Database engine type.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='Database engine version.', example='8.0'),
  DBVersionStatus?: string(name='DBVersionStatus', description='The status of the minor version. Valid values:

*   **Stable**: The minor version is stable.
*   **Old**: The minor version is outdated. We recommend that you update it to the latest version.
*   **HighRisk**: The minor version has critical defects. We recommend that you immediately update it to the latest version.
*   **Beta**: The minor version is a Beta version.

>  For information about how to update the minor version, see [Minor version update](https://help.aliyun.com/document_detail/158572.html).', example='Stable'),
  dataLevel1BackupChainSize?: long(name='DataLevel1BackupChainSize', description='Total size of Level 1 backups (snapshots), in bytes.', example='74448896'),
  dataSyncMode?: string(name='DataSyncMode', description='Data replication relationship mode. Values are as follows:
- **AsyncSync**: Asynchronous
- **SemiSync**: Semi-synchronous', example='AsyncSync'),
  deletionLock?: int32(name='DeletionLock', description='Lock status for cluster deletion, with values as follows:
* **0**: Unlocked, cluster can be deleted.
* **1**: Locked, cluster cannot be deleted.', example='0'),
  engine?: string(name='Engine', description='Cluster engine.', example='POLARDB'),
  expireTime?: string(name='ExpireTime', description='Cluster expiration time.

> Only clusters with **Prepaid** (subscription) payment methods return specific parameter values; **Postpaid** (pay-as-you-go) clusters return empty values.', example='2020-11-14T16:00:00Z'),
  expired?: string(name='Expired', description='Whether the cluster has expired.
> This parameter is only supported for clusters with **Prepaid** (Subscription) payment methods.', example='false'),
  hasCompleteStandbyRes?: boolean(name='HasCompleteStandbyRes', description='Whether to replenish resources for the new primary after cross-AZ switch. Values are as follows:
- **true**: Yes
- **false**: No', example='false'),
  hotStandbyCluster?: string(name='HotStandbyCluster', description='Whether to enable storage hot backup cluster (and Standby compute nodes). Values are as follows:
- **StandbyClusterON**: Enable storage hot backup/Enable storage hot backup and Standby compute nodes.
- **StandbyClusterOFF**: Disable storage hot backup/Disable storage hot backup and Standby compute nodes.', example='StandbyClusterON'),
  imciAutoIndex?: string(name='ImciAutoIndex', description='Indicates whether the automatic IMCI-based query acceleration feature is enabled. Valid values:

*   `ON`: enabled
*   `OFF`: disabled', example='OFF'),
  imperceptibleSwitch?: string(name='ImperceptibleSwitch', description='Indicates whether failover with hot replica is enabled. Valid values:

*   `true`
*   `false` (default)'),
  inodeTotal?: long(name='InodeTotal', description='Maximum number of inodes in the file system.', example='6,291,456'),
  inodeUsed?: long(name='InodeUsed', description='Current inode usage.', example='4,194,304'),
  isLatestVersion?: boolean(name='IsLatestVersion', description='Indicates whether it is the latest kernel version. Values are as follows:

- **true**: Yes

- **false**: No', example='false'),
  isProxyLatestVersion?: boolean(name='IsProxyLatestVersion', description='Indicates whether it is the latest version of the database proxy, with possible values as follows:

- **true**: Yes
- **false**: No', example='false'),
  lockMode?: string(name='LockMode', description='Lock mode. Possible values are as follows:

- **Unlock**: Unlocked.
- **ManualLock**: Manually triggered lock.
- **LockByExpiration**: Automatic cluster lock upon expiration.', example='Unlock'),
  maintainTime?: string(name='MaintainTime', description='The maintenance window for the cluster, formatted as `HH:mmZ-HH:mmZ` (UTC time). For example, `16:00Z-17:00Z` indicates that routine maintenance can be performed from 0:00 to 1:00 (UTC+08:00).', example='18:00Z-19:00Z'),
  orca?: string(name='Orca', description='Orca function with possible values as follows:

- **on**: Enabled

- **off**: Disabled', example='ON'),
  payType?: string(name='PayType', description='Payment type. Possible values are:

- **Postpaid**: Pay-As-You-Go
- **Prepaid**: Prepaid (Subscription).', example='Prepaid'),
  provisionedIops?: string(name='ProvisionedIops', description='Describes the preconfigured read and write IOPS for ESSD AutoPL cloud disks. Possible values: 0 to min{50,000, 1000*capacity - baseline performance}.<br>Baseline performance = min{1,800 + 50*capacity, 50000}.<br>Note: This parameter is supported only when StorageType is ESSDAUTOPL.', example='2500'),
  proxyCpuCores?: string(name='ProxyCpuCores', description='Number of CPU cores for the database proxy.', example='4'),
  proxyServerlessType?: string(name='ProxyServerlessType', description='Serverless type for the database proxy. Currently, the value is fixed to AgileServerless.', example='AgileServerless'),
  proxyStandardCpuCores?: string(name='ProxyStandardCpuCores', description='Standard configuration CPU cores for the database proxy.', example='2'),
  proxyStatus?: string(name='ProxyStatus', description='Status of the database proxy. Possible values include:

- **Creating**: Creating
- **Running**: Running
- **Deleting**: Releasing
- **Rebooting**: Restarting
- **DBNodeCreating**: Adding nodes
- **DBNodeDeleting**: Deleting nodes
- **ClassChanging**: Changing node specifications
- **NetAddressCreating**: Creating network connections
- **NetAddressDeleting**: Deleting network connections
- **NetAddressModifying**: Modifying network connections
- **Deleted**: Released', example='Running'),
  proxyType?: string(name='ProxyType', description='Database proxy types, with the following values:

- **Exclusive**: Enterprise Exclusive Edition
- **General**: Enterprise General Purpose Edition', example='Exclusive'),
  regionId?: string(name='RegionId', description='Region ID.', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='Request ID.', example='074467EF-86B9-4C23-ACBF-E9B81A******'),
  resourceGroupId?: string(name='ResourceGroupId', description='Resource group ID.', example='rg-***************'),
  restoreDataPoint?: string(name='RestoreDataPoint', description='If RestoreType is **RestoreByTime** or **RestoreByTimeOss**, this value represents the recovery time point. If RestoreType is **RestoreByBackupSet** or **RestoreByBackupSetOss**, this value indicates the ID of the backup set on which the recovery is based.
<note>Only clusters restored from a backup set or time point after June 1, 2024, support this parameter.</note>', example='2179639137'),
  restoreType?: string(name='RestoreType', description='Cluster recovery method, with possible values:
* **RestoreByTime**: Restore from a time point based on primary backup. * **RestoreByBackupSet**: Restore from a backup set based on primary backup. * **RestoreByTimeOss**: Restore from a time point based on secondary backup. * **RestoreByBackupSetOss**: Restore from a backup set based on secondary backup. * **CloneFromSourceCluster**: Clone from the source cluster.
<note>This parameter is only supported for clusters restored from a backup set or time point after June 1, 2024.</note>', example='RestoreByTime'),
  rowCompression?: string(name='RowCompression'),
  SQLSize?: long(name='SQLSize', description='Storage amount of SQL, in bytes. If the value is -1, it indicates no data.', example='0'),
  searchCompressStorageUsed?: long(name='SearchCompressStorageUsed'),
  searchStorageUsed?: long(name='SearchStorageUsed'),
  serverlessType?: string(name='ServerlessType', description='Serverless type. Valid values are as follows:
- AgileServerless: Agile - SteadyServerless: Stable', example='AgileServerless'),
  sourceDBCluster?: string(name='SourceDBCluster', description='Source cluster ID. <note>Clusters restored from backup sets or specific points in time after June 1, 2024, support this parameter.</note>', example='pc-pz51ziv48317b2880'),
  sourceRegionId?: string(name='SourceRegionId', description='The region ID of the source cluster.

>  This parameter is returned only if the source cluster ID exists.', example='cn-beijing'),
  standbyHAMode?: string(name='StandbyHAMode', description='Cross-AZ disaster recovery mode. Values are as follows:
- **ON**: Enable cross-AZ disaster recovery mode.
- **OFF**: Disable cross-AZ disaster recovery mode.
- **0**: Customer drill mode.', example='OFF'),
  storageMax?: long(name='StorageMax', description='The maximum storage capacity of the current cluster specification, in bytes.', example='10995116277760'),
  storagePayType?: string(name='StoragePayType', description='Storage billing type. Valid values are as follows:
- **Postpaid**: Pay-as-you-go (by capacity).
- **Prepaid**: Subscription (by space).', example='Prepaid'),
  storageSpace?: long(name='StorageSpace', description='Storage space for pay-by-space (subscription) billing. Unit: Byte.', example='50'),
  storageType?: string(name='StorageType', description='Storage type, with a fixed value of **HighPerformance**.', example='HighPerformance'),
  storageUsed?: long(name='StorageUsed', description='Amount of used storage space, in bytes.', example='3012558848'),
  strictConsistency?: string(name='StrictConsistency', description='Indicates whether multi-AZ data strong consistency is enabled for the cluster. The value ranges are as follows:
- **ON**: Indicates that multi-AZ data strong consistency is enabled, applicable to the Standard 3AZ scenario.
- **OFF**: Indicates that multi-AZ data strong consistency is not enabled.', example='ON'),
  subCategory?: string(name='SubCategory', description='Specification type of compute nodes, with possible values as follows:
* **Exclusive**: Dedicated specification
* **General**: General-purpose specification

> This parameter is supported only for PolarDB MySQL Edition with the product series set to Cluster Edition.', example='Exclusive'),
  supportInstantSwitchWithImci?: string(name='SupportInstantSwitchWithImci', description='Indicates whether queries based on In-Memory Column Indexes (IMCIs) are supported during and after a failover with hot replica.', example='ON'),
  tags?: [ 
    {
      key?: string(name='Key', description='Tag key.', example='test'),
      value?: string(name='Value', description='Tag value.', example='MySQL'),
    }
  ](name='Tags', description='Details of tags.'),
  VPCId?: string(name='VPCId', description='VPC ID.', example='vpc-*******************'),
  vSwitchId?: string(name='VSwitchId', description='VSwitch ID.', example='vsw-*********************'),
  zoneIds?: string(name='ZoneIds', description='Availability Zone IDs.', example='cn-hangzhou-i,cn-hangzhou-g'),
}

model DescribeDBClusterAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterAttributeResponseBody(name='body'),
}

/**
 * @summary Queries information about a PolarDB cluster.
 *
 * @param request DescribeDBClusterAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterAttributeResponse
 */
async function describeDBClusterAttributeWithOptions(request: DescribeDBClusterAttributeRequest, runtime: Util.RuntimeOptions): DescribeDBClusterAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.describeType)) {
    query['DescribeType'] = request.describeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterAttribute',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries information about a PolarDB cluster.
 *
 * @param request DescribeDBClusterAttributeRequest
 * @return DescribeDBClusterAttributeResponse
 */
async function describeDBClusterAttribute(request: DescribeDBClusterAttributeRequest): DescribeDBClusterAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterAttributeWithOptions(request, runtime);
}

model DescribeDBClusterAuditLogCollectorRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-***************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterAuditLogCollectorResponseBody = {
  collectorStatus?: string(name='CollectorStatus', description='The status of SQL collector. Valid values:

*   Enable
*   Disabled', example='Disabled'),
  requestId?: string(name='RequestId', description='The request ID.', example='59011D2B-2A38-4207-A86C-72BC1F882D19'),
}

model DescribeDBClusterAuditLogCollectorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterAuditLogCollectorResponseBody(name='body'),
}

/**
 * @summary Describe SQL collector for a PolarDB cluster. Features related to SQL collector include audit log and SQL Explorer.
 *
 * @param request DescribeDBClusterAuditLogCollectorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterAuditLogCollectorResponse
 */
async function describeDBClusterAuditLogCollectorWithOptions(request: DescribeDBClusterAuditLogCollectorRequest, runtime: Util.RuntimeOptions): DescribeDBClusterAuditLogCollectorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterAuditLogCollector',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Describe SQL collector for a PolarDB cluster. Features related to SQL collector include audit log and SQL Explorer.
 *
 * @param request DescribeDBClusterAuditLogCollectorRequest
 * @return DescribeDBClusterAuditLogCollectorResponse
 */
async function describeDBClusterAuditLogCollector(request: DescribeDBClusterAuditLogCollectorRequest): DescribeDBClusterAuditLogCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterAuditLogCollectorWithOptions(request, runtime);
}

model DescribeDBClusterAvailableResourcesRequest {
  DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node. For more information, see [Specifications of compute nodes](https://help.aliyun.com/document_detail/102542.html).', example='polar.mysql.x4.large'),
  DBType?: string(name='DBType', description='The type of the database engine. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine. Valid values for the MySQL database engine:

*   **5.6**
*   **5.7**
*   **8.0**

Valid values for the PostgreSQL database engine:

*   **11**
*   **14**

Valid value for the Oracle database engine: **11**

> This parameter is required when you specify the **DBType** parameter.', example='5.6'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go
*   **Prepaid**: subscription

This parameter is required.', example='Postpaid'),
  regionId?: string(name='RegionId', description='The region ID of the cluster. Default value: **cn-hangzhou**.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the available regions.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId', description='The zone ID of the cluster.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the available zones.', example='cn-hangzhou-i'),
}

model DescribeDBClusterAvailableResourcesResponseBody = {
  availableZones?: [ 
    {
      regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
      supportedEngines?: [ 
        {
          availableResources?: [ 
            {
              category?: string(name='Category', description='The edition of the cluster. Valid values:

*   **Normal**: Cluster Edition.
*   **Basic**: Single Node Edition.
*   **ArchiveNormal**: X-Engine.
*   **NormalMultimaster**: Multi-master Cluster (Database/Table) Edition.
*   **SENormal**: Standard Edition.

>- Only PolarDB for MySQL supports Single Node Edition.
>- Only PolarDB for MySQL 8.0 supports X-Engine Edition and Multi-master Cluster (Database/Table) Edition.', example='Normal'),
              DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node.', example='polar.mysql.x4.large'),
            }
          ](name='AvailableResources', description='The available resources.'),
          engine?: string(name='Engine', description='The version of the database engine.', example='mysql57'),
        }
      ](name='SupportedEngines', description='The database engines that the available resources support.'),
      zoneId?: string(name='ZoneId', description='The zone ID of the cluster.', example='cn-hangzhou-i'),
    }
  ](name='AvailableZones', description='The available zones of the cluster.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2B19F698-8FFC-4918-B9E2-58D878******'),
}

model DescribeDBClusterAvailableResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterAvailableResourcesResponseBody(name='body'),
}

/**
 * @summary Queries available resources in a PolarDB cluster.
 *
 * @param request DescribeDBClusterAvailableResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterAvailableResourcesResponse
 */
async function describeDBClusterAvailableResourcesWithOptions(request: DescribeDBClusterAvailableResourcesRequest, runtime: Util.RuntimeOptions): DescribeDBClusterAvailableResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBNodeClass)) {
    query['DBNodeClass'] = request.DBNodeClass;
  }
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterAvailableResources',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries available resources in a PolarDB cluster.
 *
 * @param request DescribeDBClusterAvailableResourcesRequest
 * @return DescribeDBClusterAvailableResourcesResponse
 */
async function describeDBClusterAvailableResources(request: DescribeDBClusterAvailableResourcesRequest): DescribeDBClusterAvailableResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterAvailableResourcesWithOptions(request, runtime);
}

model DescribeDBClusterConnectivityRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-xxxxxxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  sourceIpAddress?: string(name='SourceIpAddress', description='The source IP address.

This parameter is required.', example='192.***.***.1'),
}

model DescribeDBClusterConnectivityResponseBody = {
  connCheckErrorCode?: string(name='ConnCheckErrorCode', description='The error code for connection diagnosis. Valid values:

*   **SRC_IP_NOT_IN_USER_WHITELIST**: The source IP address is not added to the whitelist.
*   **CONNECTION_ABNORMAL**: The connection to the cluster is normal.', example='SRC_IP_NOT_IN_USER_WHITELIST'),
  connCheckErrorMessage?: string(name='ConnCheckErrorMessage', description='The error message for connection diagnosis.', example='Src ip:192.***.***.1 not in user whitelist'),
  connCheckResult?: string(name='ConnCheckResult', description='The connection diagnosis result. Valid values:

*   **Success**
*   **Failed**', example='Failed'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-xxxxxxxxxxxxx'),
  requestId?: string(name='RequestId', description='The request ID.', example='73A85BAF-1039-4CDE-A83F-1A140F******'),
}

model DescribeDBClusterConnectivityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterConnectivityResponseBody(name='body'),
}

/**
 * @summary Queries whether the source IP address can access a cluster.
 *
 * @param request DescribeDBClusterConnectivityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterConnectivityResponse
 */
async function describeDBClusterConnectivityWithOptions(request: DescribeDBClusterConnectivityRequest, runtime: Util.RuntimeOptions): DescribeDBClusterConnectivityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.sourceIpAddress)) {
    query['SourceIpAddress'] = request.sourceIpAddress;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterConnectivity',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries whether the source IP address can access a cluster.
 *
 * @param request DescribeDBClusterConnectivityRequest
 * @return DescribeDBClusterConnectivityResponse
 */
async function describeDBClusterConnectivity(request: DescribeDBClusterConnectivityRequest): DescribeDBClusterConnectivityResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterConnectivityWithOptions(request, runtime);
}

model DescribeDBClusterEncryptionKeyRequest {
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f******************'),
  DBClusterId?: string(name='DBClusterId', example='pc-***'),
}

model DescribeDBClusterEncryptionKeyResponseBody = {
  encryptionKeyList?: [ 
    {
      aliasName?: string(name='AliasName', example='alias/your_default_key'),
      creator?: string(name='Creator', example='1****1'),
      deleteDate?: string(name='DeleteDate', example='2026-05-08T08:14:16Z'),
      description?: string(name='Description', example='Description of the key'),
      encryptionKey?: string(name='EncryptionKey', example='51858179-afb3-4369-8329-*********'),
      encryptionKeyStatus?: string(name='EncryptionKeyStatus', example='Enabled'),
      keyType?: string(name='KeyType', example='ServiceKey'),
      keyUsage?: string(name='KeyUsage', example='ENCRYPT/DECRYPT'),
      materialExpireTime?: string(name='MaterialExpireTime', example='2025-10-18T08:14:16Z'),
      origin?: string(name='Origin', example='Aliyun_KMS'),
      usedBy?: string(name='UsedBy', example='DiskEncryption'),
    }
  ](name='EncryptionKeyList'),
  requestId?: string(name='RequestId', example='137ECCC0-920E-5B3B-9F8E-B81632108BBE'),
}

model DescribeDBClusterEncryptionKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterEncryptionKeyResponseBody(name='body'),
}

/**
 * @summary DescribeDBClusterEncryptionKey
 *
 * @param request DescribeDBClusterEncryptionKeyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterEncryptionKeyResponse
 */
async function describeDBClusterEncryptionKeyWithOptions(request: DescribeDBClusterEncryptionKeyRequest, runtime: Util.RuntimeOptions): DescribeDBClusterEncryptionKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterEncryptionKey',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DescribeDBClusterEncryptionKey
 *
 * @param request DescribeDBClusterEncryptionKeyRequest
 * @return DescribeDBClusterEncryptionKeyResponse
 */
async function describeDBClusterEncryptionKey(request: DescribeDBClusterEncryptionKeyRequest): DescribeDBClusterEncryptionKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterEncryptionKeyWithOptions(request, runtime);
}

model DescribeDBClusterEndpointsRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pc-*************'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.', example='pe-*************'),
  describeType?: string(name='DescribeType', example='AI'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  polarFsInstanceId?: string(name='PolarFsInstanceId', example='pfs-test*****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterEndpointsResponseBody = {
  items?: [ 
    {
      addressItems?: [ 
        {
          connectionString?: string(name='ConnectionString', description='The endpoint.', example='********.rwlb.polardb-pg-public.rds.aliyuncs.com'),
          dashboardUsed?: boolean(name='DashboardUsed', description='Whether it is the dashboard endpoint of the PolarDB search node.

*   Ture
*   False', example='True'),
          IPAddress?: string(name='IPAddress', description='The IP address.', example='192.***.***.***'),
          netType?: string(name='NetType', description='The network type of the endpoint. Valid values:

*   **Public**
*   **Private**', example='Private'),
          port?: string(name='Port', description='The port.', example='1521'),
          privateZoneConnectionString?: string(name='PrivateZoneConnectionString', description='The private domain name that is bound to the endpoint.', example='***.***.**.com'),
          VPCId?: string(name='VPCId', description='The ID of the VPC.', example='vpc-***************'),
          vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-************'),
          vpcInstanceId?: string(name='VpcInstanceId', description='The ID of the virtual private cloud (VPC) instance.

> This parameter is returned for only PolarDB for MySQL clusters.', example='pe-*************'),
        }
      ](name='AddressItems', description='The details of the endpoint.'),
      autoAddNewNodes?: string(name='AutoAddNewNodes', description='Indicates whether new nodes are automatically associated with the default cluster endpoint. Valid values:

*   **Enable**
*   **Disable**', example='Enable'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-bp1s826a1up******'),
      DBEndpointDescription?: string(name='DBEndpointDescription', description='The name of the endpoint.', example='test'),
      DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.', example='pe-*************'),
      endpointConfig?: string(name='EndpointConfig', description='The advanced configurations of the endpoint.

*   **DistributedTransaction**: indicates whether transaction splitting is enabled. Valid values:

    *   **on**
    *   **off**

*   **ConsistLevel**: the consistency level of sessions. Valid values:

    *   **0**: eventual consistency.
    *   **1**: session consistency.
    *   **2**: global consistency.

*   **LoadBalanceStrategy**: the load balancing policy that automatically schedules loads. Only **load** may be returned.

*   **MasterAcceptReads**: indicates whether the primary node processes read requests. Valid values:

    *   **on**
    *   **off**', example='{\\\\"DistributedTransaction\\\\":\\\\"off\\\\",\\\\"ConsistLevel\\\\":\\\\"0\\\\",\\\\"LoadBalanceStrategy\\\\":\\\\"load\\\\",\\\\"MasterAcceptReads\\\\":\\\\"on\\\\"}'),
      endpointType?: string(name='EndpointType', description='The type of the endpoint. Valid values:

*   **Cluster**: the default endpoint.
*   **Primary**: the primary endpoint.
*   **Custom**: a custom cluster endpoint.', example='Custom'),
      nodeWithRoles?: string(name='NodeWithRoles', description='The role name of each node in the endpoint. The role name of the primary node is **Writer**. Multiple read-only nodes can be associated with an endpoint. Therefore, the role name of each read-only node is suffixed with a number. For example, you can use **Reader1** and **Reader2** as the role names.

>  This parameter is valid only for PolarDB for PostgreSQL clusters and PolarDB for PostgreSQL (Compatible with Oracle)) clusters.', example='Reader1'),
      nodes?: string(name='Nodes', description='The nodes in the endpoint.', example='pi-***************,pi-***************'),
      polarSccTimeoutAction?: string(name='PolarSccTimeoutAction', description='The global consistency timeout policy. Valid values:

*   **0**: sends the request to the primary node.
*   **2**: downgrades the consistency level of a query to inconsistent read when a global consistent read in the query times out. No error message is returned to the client.', example='0'),
      polarSccWaitTimeout?: string(name='PolarSccWaitTimeout', description='Global consistency timeout.', example='100'),
      readWriteMode?: string(name='ReadWriteMode', description='The read/write mode. Valid values:

*   **ReadWrite**: handles read and write requests. Automatic read/write splitting is enabled.
*   **ReadOnly**: handles read-only requests.', example='ReadOnly'),
      sccMode?: string(name='SccMode', description='Indicates whether the global consistency (high-performance mode) feature is enabled for the node. Valid values:

*   **on**: enabled.
*   **off**: disabled', example='on'),
    }
  ](name='Items', description='The information about the endpoints.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2DC120BF-6EBA-4C63-BE99-B09F9E******'),
}

model DescribeDBClusterEndpointsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterEndpointsResponseBody(name='body'),
}

/**
 * @summary Queries the endpoints of a PolarDB cluster.
 *
 * @param request DescribeDBClusterEndpointsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterEndpointsResponse
 */
async function describeDBClusterEndpointsWithOptions(request: DescribeDBClusterEndpointsRequest, runtime: Util.RuntimeOptions): DescribeDBClusterEndpointsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.describeType)) {
    query['DescribeType'] = request.describeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.polarFsInstanceId)) {
    query['PolarFsInstanceId'] = request.polarFsInstanceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterEndpoints',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the endpoints of a PolarDB cluster.
 *
 * @param request DescribeDBClusterEndpointsRequest
 * @return DescribeDBClusterEndpointsResponse
 */
async function describeDBClusterEndpoints(request: DescribeDBClusterEndpointsRequest): DescribeDBClusterEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterEndpointsWithOptions(request, runtime);
}

model DescribeDBClusterEndpointsZonalRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-*************'),
  DBEndpointId?: string(name='DBEndpointId', example='pe-*************'),
  describeType?: string(name='DescribeType', example='AI'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterEndpointsZonalResponseBody = {
  items?: [ 
    {
      addressItems?: [ 
        {
          connectionString?: string(name='ConnectionString', example='********.rwlb.polardb-pg-public.rds.aliyuncs.com'),
          dashboardUsed?: boolean(name='DashboardUsed', example='True'),
          IPAddress?: string(name='IPAddress', example='192.***.***.***'),
          netType?: string(name='NetType', example='Private'),
          port?: string(name='Port', example='1521'),
          privateZoneConnectionString?: string(name='PrivateZoneConnectionString', example='***.***.**.com'),
          VPCId?: string(name='VPCId', example='vpc-***************'),
          vSwitchId?: string(name='VSwitchId', example='vsw-************'),
          vpcInstanceId?: string(name='VpcInstanceId', example='pe-*************'),
        }
      ](name='AddressItems'),
      autoAddNewNodes?: string(name='AutoAddNewNodes', example='Enable'),
      DBClusterId?: string(name='DBClusterId', example='pc-bp1s826a1up******'),
      DBEndpointDescription?: string(name='DBEndpointDescription', example='test'),
      DBEndpointId?: string(name='DBEndpointId', example='pe-*************'),
      endpointConfig?: string(name='EndpointConfig', example='{\\\\"DistributedTransaction\\\\":\\\\"off\\\\",\\\\"ConsistLevel\\\\":\\\\"0\\\\",\\\\"LoadBalanceStrategy\\\\":\\\\"load\\\\",\\\\"MasterAcceptReads\\\\":\\\\"on\\\\"}'),
      endpointType?: string(name='EndpointType', example='Custom'),
      nodeWithRoles?: string(name='NodeWithRoles', example='Reader1'),
      nodes?: string(name='Nodes', example='pi-***************,pi-***************'),
      polarSccTimeoutAction?: string(name='PolarSccTimeoutAction', example='0'),
      polarSccWaitTimeout?: string(name='PolarSccWaitTimeout', example='100'),
      readWriteMode?: string(name='ReadWriteMode', example='ReadOnly'),
      sccMode?: string(name='SccMode', example='on'),
    }
  ](name='Items'),
  requestId?: string(name='RequestId', example='2DC120BF-6EBA-4C63-BE99-B09F9E******'),
}

model DescribeDBClusterEndpointsZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterEndpointsZonalResponseBody(name='body'),
}

/**
 * @summary 查询PolarDB边缘集群的链接地址
 *
 * @param request DescribeDBClusterEndpointsZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterEndpointsZonalResponse
 */
async function describeDBClusterEndpointsZonalWithOptions(request: DescribeDBClusterEndpointsZonalRequest, runtime: Util.RuntimeOptions): DescribeDBClusterEndpointsZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.describeType)) {
    query['DescribeType'] = request.describeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterEndpointsZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询PolarDB边缘集群的链接地址
 *
 * @param request DescribeDBClusterEndpointsZonalRequest
 * @return DescribeDBClusterEndpointsZonalResponse
 */
async function describeDBClusterEndpointsZonal(request: DescribeDBClusterEndpointsZonalRequest): DescribeDBClusterEndpointsZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterEndpointsZonalWithOptions(request, runtime);
}

model DescribeDBClusterMigrationRequest {
  DBClusterId?: string(name='DBClusterId', description='The network type of the endpoint. Valid values:

*   **Public**: the public endpoint
*   **Private**: the internal endpoint (VPC)
*   **Inner**: the internal endpoint (classic network)

This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterMigrationResponseBody = {
  comment?: string(name='Comment', description='The mode of the source ApsaraDB RDS instance. Valid values:

*   **rw**: read and write mode
*   **ro**: read-only mode', example='test'),
  DBClusterEndpointList?: [ 
    {
      addressItems?: [ 
        {
          connectionString?: string(name='ConnectionString', description='Indicates whether SSL encryption is enabled. Valid values:

*   **Enabled**
*   **Disabled**', example='pc-**************.rwlb.rds.aliyuncs.com'),
          IPAddress?: string(name='IPAddress', description='The description of a migration exception. If no exception occurs during the migration, an empty string is returned.', example='192.***.***.10'),
          netType?: string(name='NetType', description='The ID of the endpoint.', example='Private'),
          port?: string(name='Port', description='The type of the endpoint. Valid values:

*   **Cluster**: the default cluster endpoint
*   **Primary**: the primary endpoint
*   **Custom**: the custom endpoint', example='3306'),
          SSLEnabled?: string(name='SSLEnabled', description='The ID of the request.', example='Enabled'),
          VPCId?: string(name='VPCId', description='The read/write mode. Valid values:

*   ReadWrite: receives and forwards read and write requests (automatic read-write splitting).
*   ReadOnly (default): receives and forwards read requests only.', example='vpc-**********'),
          vSwitchId?: string(name='VSwitchId', description='The IP address of the endpoint.', example='vsw-**********'),
        }
      ](name='AddressItems', description='The VPC ID.'),
      DBEndpointId?: string(name='DBEndpointId', description='The expiration time of the replication between ApsaraDB RDS and PolarDB. The time is in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.', example='pe-***********'),
      endpointType?: string(name='EndpointType', description='The ID of the cluster.', example='Cluster'),
      readWriteMode?: string(name='ReadWriteMode', description='The synchronization direction. Valid values:

*   **RDS2POLARDB**: Data is replicated from an ApsaraDB RDS instance to a PolarDB cluster.
*   **POLARDB2RDS**: Data is replicated from a PolarDB cluster to an ApsaraDB RDS instance.', example='ReadOnly'),
    }
  ](name='DBClusterEndpointList', description='The port number.'),
  DBClusterId?: string(name='DBClusterId', description='The replication latency between the ApsaraDB RDS instance and the PolarDB cluster. Unit: seconds.', example='pc-****************'),
  DBClusterReadWriteMode?: string(name='DBClusterReadWriteMode', description='Details about the endpoints.', example='ro'),
  delayedSeconds?: int32(name='DelayedSeconds', description='The vSwitch ID.', example='0'),
  dtsInstanceId?: string(name='DtsInstanceId', description='The network type of the endpoint. Valid values:

*   **Public**: the public endpoint
*   **Private**: the internal endpoint (VPC)
*   **Inner**: the internal endpoint (classic network)', example='dts**********618bs'),
  expiredTime?: string(name='ExpiredTime', description='The mode of the PolarDB cluster. Valid values:

*   **rw**: read and write mode
*   **ro**: read-only mode', example='2020-06-17T01:56:36Z'),
  migrationStatus?: string(name='MigrationStatus', description='The endpoint.', example='RDS2POLARDB_SYNCING'),
  rdsEndpointList?: [ 
    {
      addressItems?: [ 
        {
          connectionString?: string(name='ConnectionString', description='Indicates whether SSL encryption is enabled. Valid values:

*   **Enabled**
*   **Disabled**', example='rm-***********.mysql.rds.aliyuncs.com'),
          IPAddress?: string(name='IPAddress', description='The type of the source database. Valid values:

*   **PolarDBMySQL**: The source database is a PolarDB for MySQL database when the major version of your PolarDB cluster is upgraded.
*   **RDS**: The source database is an ApsaraDB RDS database when data is migrated from ApsaraDB RDS to PolarDB for MySQL.', example='172.***.***.173'),
          netType?: string(name='NetType', description='The ID of the endpoint.', example='Private'),
          port?: string(name='Port', description='The type of the endpoint. Valid values:

*   **Normal**: the standard endpoint
*   **ReadWriteSplitting**: the read/write splitting endpoint', example='3306'),
          SSLEnabled?: string(name='SSLEnabled', description='Indicates whether SSL encryption is enabled. Valid values:

- **Enabled**
- **Disabled**', example='Enabled'),
          VPCId?: string(name='VPCId', description='The instance type.', example='vpc-************'),
          vSwitchId?: string(name='VSwitchId', description='The IP address of the endpoint.', example='vsw-**************'),
        }
      ](name='AddressItems', description='The VPC ID.'),
      custinsType?: string(name='CustinsType', description='The instance type.', example='ReadOnly
Maxscale
Primary'),
      DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.', example='rm-************-normal'),
      endpointType?: string(name='EndpointType', description='The type of the endpoint. Valid values:

- **Normal**: the standard endpoint
- **ReadWriteSplitting**: the read/write splitting endpoint', example='Normal'),
    }
  ](name='RdsEndpointList', description='The endpoints of the ApsaraDB RDS instance.'),
  rdsReadWriteMode?: string(name='RdsReadWriteMode', description='The ID of the synchronous task.', example='rw'),
  requestId?: string(name='RequestId', description='The ID of the source ApsaraDB RDS instance.', example='F2A9EFA7-915F-4572-8299-85A307******'),
  sourceRDSDBInstanceId?: string(name='SourceRDSDBInstanceId', description='The endpoints of the ApsaraDB RDS instance.', example='rm-************'),
  srcDbType?: string(name='SrcDbType', description='The type of the source database. Valid values:

- **PolarDBMySQL**: The source database is a PolarDB for MySQL database when the major version of your PolarDB cluster is upgraded.
- **RDS**: The source database is an ApsaraDB RDS database when data is migrated from ApsaraDB RDS to PolarDB for MySQL.', example='PolarDBMySQL'),
  topologies?: string(name='Topologies', description='The migration state of the PolarDB cluster. Valid values:

*   **NO_MIGRATION**: No migration task is running.
*   **RDS2POLARDB_CLONING**: Data is being replicated.
*   **RDS2POLARDB_SYNCING**: Data is being replicated. During the replication, the PolarDB cluster is running in read-only mode and the source ApsaraDB RDS instance is running in read and write mode.
*   **SWITCHING**: Databases are being switched.
*   **POLARDB2RDS_SYNCING**: Databases are switched. The PolarDB cluster is running in read and write mode and the source ApsaraDB RDS instance is running in read-only mode. In this state, you can modify the endpoints for your applications.
*   **ROLLBACK**: The migration is being rolled back. After the rollback is complete, the value **RDS2POLARDB_SYNCING** is returned.
*   **CLOSING_MIGRATION**: The migration task is being terminated.', example='RDS2POLARDB'),
}

model DescribeDBClusterMigrationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterMigrationResponseBody(name='body'),
}

/**
 * @summary The ID of the synchronous task.
 *
 * @description The ID of the request.
 *
 * @param request DescribeDBClusterMigrationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterMigrationResponse
 */
async function describeDBClusterMigrationWithOptions(request: DescribeDBClusterMigrationRequest, runtime: Util.RuntimeOptions): DescribeDBClusterMigrationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterMigration',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary The ID of the synchronous task.
 *
 * @description The ID of the request.
 *
 * @param request DescribeDBClusterMigrationRequest
 * @return DescribeDBClusterMigrationResponse
 */
async function describeDBClusterMigration(request: DescribeDBClusterMigrationRequest): DescribeDBClusterMigrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterMigrationWithOptions(request, runtime);
}

model DescribeDBClusterMonitorRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterMonitorResponseBody = {
  period?: string(name='Period', description='The interval at which monitoring data is collected. Unit: seconds.', example='60'),
  requestId?: string(name='RequestId', description='The request ID.', example='593AE1C5-B70C-463F-9207-074639******'),
}

model DescribeDBClusterMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterMonitorResponseBody(name='body'),
}

/**
 * @summary Queries the interval at which the monitoring data of a PolarDB cluster is collected.
 *
 * @param request DescribeDBClusterMonitorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterMonitorResponse
 */
async function describeDBClusterMonitorWithOptions(request: DescribeDBClusterMonitorRequest, runtime: Util.RuntimeOptions): DescribeDBClusterMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterMonitor',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the interval at which the monitoring data of a PolarDB cluster is collected.
 *
 * @param request DescribeDBClusterMonitorRequest
 * @return DescribeDBClusterMonitorResponse
 */
async function describeDBClusterMonitor(request: DescribeDBClusterMonitorRequest): DescribeDBClusterMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterMonitorWithOptions(request, runtime);
}

model DescribeDBClusterNetInfoRequest {
  connectionStringType?: string(name='ConnectionStringType', example='Normal'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterNetInfoResponseBody = {
  clusterNetworkType?: string(name='ClusterNetworkType', example='VPC'),
  DBClusterNetInfos?: {
    DBClusterNetInfo?: [ 
    {
      connectionString?: string(name='ConnectionString', example='pc-****************.pg.polardb.pre.rds.aliyuncs.com'),
      connectionStringType?: string(name='ConnectionStringType', example='MPP'),
      IPAddress?: string(name='IPAddress', example='121.*.*.173'),
      IPType?: string(name='IPType', example='Public'),
      port?: string(name='Port', example='1521'),
      VPCId?: string(name='VPCId', example='vpc-***************'),
      vSwitchId?: string(name='VSwitchId', example='vsw-bp1li3eavsz8oaexq15dw'),
    }
  ](name='DBClusterNetInfo')
  }(name='DBClusterNetInfos'),
  DBNodeNetInfos?: {
    DBNodeNetInfo?: [ 
    {
      DBInstanceId?: string(name='DBInstanceId', example='pc-*************'),
      DBNodeRole?: string(name='DBNodeRole', example='Writer'),
      netInfos?: {
        netInfo?: [ 
        {
          connectionString?: string(name='ConnectionString', example='pc-****************.pg.polardb.pre.rds.aliyuncs.com'),
          IPAddress?: string(name='IPAddress', example='47.*.*.203'),
          IPType?: string(name='IPType', example='Public'),
          port?: string(name='Port', example='5432'),
          VPCId?: string(name='VPCId', example='vpc-****************'),
          vSwitchId?: string(name='VSwitchId', example='vsw-*************'),
        }
      ](name='NetInfo')
      }(name='NetInfos'),
    }
  ](name='DBNodeNetInfo')
  }(name='DBNodeNetInfos'),
  requestId?: string(name='RequestId', example='72D99256-ACF1-5F86-831F-8CB53E9C23ED'),
}

model DescribeDBClusterNetInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterNetInfoResponseBody(name='body'),
}

/**
 * @param request DescribeDBClusterNetInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterNetInfoResponse
 */
async function describeDBClusterNetInfoWithOptions(request: DescribeDBClusterNetInfoRequest, runtime: Util.RuntimeOptions): DescribeDBClusterNetInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionStringType)) {
    query['ConnectionStringType'] = request.connectionStringType;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterNetInfo',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeDBClusterNetInfoRequest
 * @return DescribeDBClusterNetInfoResponse
 */
async function describeDBClusterNetInfo(request: DescribeDBClusterNetInfoRequest): DescribeDBClusterNetInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterNetInfoWithOptions(request, runtime);
}

model DescribeDBClusterParametersRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-**********'),
  describeType?: string(name='DescribeType', description='The type of the parameter information to query. Valid values:

*   **Normal**: the information about the cluster parameters
*   **MigrationFromRDS**: a comparison of parameters between the source RDS instance and the destination PolarDB cluster', example='Normal'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterParametersResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-bp1s826a1up******'),
  DBType?: string(name='DBType', description='The database engine that the clusters runs. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine. 

- Valid values for the MySQL database engine:   
  - **5.6**
  - **5.7**
  - **8.0**
- Valid value for the PostgreSQL database engine:    
  - **11**
  - **14**
- Valid value for the Oracle database engine:  **11**', example='5.6'),
  engine?: string(name='Engine', description='The cluster engine.', example='POLARDB'),
  parameterNumbers?: string(name='ParameterNumbers', description='The number of parameters.', example='1'),
  parameters?: {
    parameters?: [ 
    {
      isEqual?: string(name='IsEqual', description='Indicates whether the source and current parameters have the same value.', example='true'),
      isInstancePolarDBKey?: string(name='IsInstancePolarDBKey', description='Indicate whether the parameter is a primary parameter of the destination cluster. Valid values:

*   **1**: The parameter is a primary parameter of the destination cluster.
*   **0**: The parameter is not a primary parameter of the destination cluster.', example='1'),
      isInstanceRdsKey?: string(name='IsInstanceRdsKey', description='Indicate whether the parameter is a primary parameter of the source instance. Valid values:

*   **1**: The parameter is a primary parameter of the source instance.
*   **0**: The parameter is not a primary parameter of the source instance.', example='0'),
      isPolarDBKey?: string(name='IsPolarDBKey', description='Indicate whether the parameter is a primary parameter of the destination cluster. Valid values:

*   **1**: The parameter is a primary parameter of the destination cluster.
*   **0**: The parameter is not a primary parameter of the destination cluster.', example='0'),
      isRdsKey?: string(name='IsRdsKey', description='Indicate whether the parameter is a primary parameter of the source instance. Valid values:

*   **1**: The parameter is a primary parameter of the source instance.
*   **0**: The parameter is not a primary parameter of the source instance.', example='1'),
      distParameterDescription?: string(name='distParameterDescription', description='The description of the parameter of the destination cluster.', example='The server\\\\"s default character set.'),
      distParameterName?: string(name='distParameterName', description='The name of the parameter of the destination cluster.', example='character_set_server'),
      distParameterOptional?: string(name='distParameterOptional', description='The valid values of the parameter of the destination cluster.', example='- utf8
- gbk'),
      distParameterValue?: string(name='distParameterValue', description='The value of the parameter of the destination cluster.', example='utf8'),
      rdsParameterDescription?: string(name='rdsParameterDescription', description='The description of the parameter of the source instance.', example='The server\\\\"s default character set.'),
      rdsParameterName?: string(name='rdsParameterName', description='The name of the parameter of the source instance.', example='character_set_server'),
      rdsParameterOptional?: string(name='rdsParameterOptional', description='The valid values of the parameter of the source instance.', example='- utf8
- gbk'),
      rdsParameterValue?: string(name='rdsParameterValue', description='The value of the parameter of the source instance.', example='utf8'),
    }
  ](name='Parameters')
  }(name='Parameters', description='A comparison of parameters between the source RDS instance and the destination PolarDB cluster.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EBEAA83D-1734-42E3-85E3-E25F6E******'),
  runningParameters?: {
    parameter?: [ 
    {
      checkingCode?: string(name='CheckingCode', description='The valid values of the parameter.', example='[utf8|latin1|gbk|utf8mb4]'),
      dataType?: string(name='DataType', description='The data type of the parameter value. Valid values:

*   **INT**
*   **STRING**
*   **B**', example='INT'),
      defaultParameterValue?: string(name='DefaultParameterValue', description='The default value of the parameter.', example='utf8'),
      factor?: string(name='Factor', description='A divisor of the parameter. For a parameter of the integer or byte type, the valid values must be a multiple of Factor unless you set Factor to 0.', example='20'),
      forceRestart?: boolean(name='ForceRestart', description='Indicates whether a cluster restart is required for the parameter modification to take effect. Valid values:

*   **false**
*   **true**', example='true'),
      isModifiable?: boolean(name='IsModifiable', description='Indicates whether the parameter can be modified. Valid values:

*   **false**
*   **true**', example='true'),
      isNodeAvailable?: string(name='IsNodeAvailable', description='Indicates whether the parameter is a global parameter. Valid values:

*   **0**: The parameter is a global parameter. The modified parameter value is synchronized to other nodes.
*   **1**: The parameter is not a global parameter. You can specify the nodes to which the modified parameter value can be synchronized.', example='0'),
      paramRelyRule?: string(name='ParamRelyRule', description='The dependencies of the parameter.', example='utf8'),
      parameterDescription?: string(name='ParameterDescription', description='The description of the parameter.', example='The server\\\\"s default character set.'),
      parameterName?: string(name='ParameterName', description='The name of the parameter.', example='character_set_server'),
      parameterStatus?: string(name='ParameterStatus', description='The status of the parameter. Valid values:

*   **Normal**
*   **Modifying**', example='Normal'),
      parameterValue?: string(name='ParameterValue', description='The value of the parameter.', example='utf8'),
    }
  ](name='Parameter')
  }(name='RunningParameters', description='The parameters of the PolarDB cluster.'),
}

model DescribeDBClusterParametersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterParametersResponseBody(name='body'),
}

/**
 * @summary Queries the parameters of a PolarDB cluster.
 *
 * @param request DescribeDBClusterParametersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterParametersResponse
 */
async function describeDBClusterParametersWithOptions(request: DescribeDBClusterParametersRequest, runtime: Util.RuntimeOptions): DescribeDBClusterParametersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.describeType)) {
    query['DescribeType'] = request.describeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterParameters',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the parameters of a PolarDB cluster.
 *
 * @param request DescribeDBClusterParametersRequest
 * @return DescribeDBClusterParametersResponse
 */
async function describeDBClusterParameters(request: DescribeDBClusterParametersRequest): DescribeDBClusterParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterParametersWithOptions(request, runtime);
}

model DescribeDBClusterPerformanceRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-****************'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-09-23T01:00Z'),
  interval?: string(name='Interval', description='The interval at which performance data is collected. Valid values: 5, 30, 60, 600, 1800, 3600, 86400, in seconds.', example='60'),
  key?: string(name='Key', description='The performance metrics that you want to query. Separate multiple metrics with commas (,). For more information, see [Performance parameters](https://help.aliyun.com/document_detail/141787.html).

>  You can specify a maximum of five performance metrics.

This parameter is required.', example='PolarDBDiskUsage'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-09-23T01:01Z'),
  subGroupName?: string(name='SubGroupName'),
  type?: string(name='Type', description='The query type.', example='orca'),
}

model DescribeDBClusterPerformanceResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*****************'),
  DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='8.0'),
  endTime?: string(name='EndTime', description='The end time of the query. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:01:00Z'),
  performanceKeys?: {
    performanceItem?: [ 
    {
      DBNodeId?: string(name='DBNodeId', description='The ID of the cluster node.

>  The value of this parameter is not returned if the `Key` parameter is set to `PolarDBDiskUsage`.', example='pi-*************'),
      measurement?: string(name='Measurement', description='The performance metrics that are returned.', example='PolarDBDiskUsage'),
      metricName?: string(name='MetricName', description='The name of the performance metric.', example='mean_data_size'),
      points?: {
        performanceItemValue?: [ 
        {
          timestamp?: long(name='Timestamp', description='The timestamp of the metric. This value is a UNIX timestamp. Unit: millisecond.', example='1600822800000'),
          value?: string(name='Value', description='The value of the metric.', example='42.38'),
        }
      ](name='PerformanceItemValue')
      }(name='Points', description='The performance metrics.'),
    }
  ](name='PerformanceItem')
  }(name='PerformanceKeys', description='The cluster performance metrics.'),
  requestId?: string(name='RequestId', description='The request ID.', example='35D3E3DA-4650-407A-BFF5-59BFF1******'),
  startTime?: string(name='StartTime', description='The start time of the query. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:00:00Z'),
}

model DescribeDBClusterPerformanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterPerformanceResponseBody(name='body'),
}

/**
 * @summary Queries the performance data of a PolarDB cluster.
 *
 * @description *   When the monitoring data is collected every 5 seconds:
 *     *   If the query time range is less than or equal to 1 hour, the data is displayed at intervals of 5 seconds.
 *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
 *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
 *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
 *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
 * *   When the monitoring data is collected every 60 seconds:
 *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
 *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
 *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
 *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
 * >  By default, the monitoring data is collected once every 60 seconds. You can call the [ModifyDBClusterMonitor](https://help.aliyun.com/document_detail/159557.html) operation to set the data collection interval to every 5 seconds.
 *
 * @param request DescribeDBClusterPerformanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterPerformanceResponse
 */
async function describeDBClusterPerformanceWithOptions(request: DescribeDBClusterPerformanceRequest, runtime: Util.RuntimeOptions): DescribeDBClusterPerformanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.subGroupName)) {
    query['SubGroupName'] = request.subGroupName;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterPerformance',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the performance data of a PolarDB cluster.
 *
 * @description *   When the monitoring data is collected every 5 seconds:
 *     *   If the query time range is less than or equal to 1 hour, the data is displayed at intervals of 5 seconds.
 *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
 *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
 *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
 *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
 * *   When the monitoring data is collected every 60 seconds:
 *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
 *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
 *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
 *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
 * >  By default, the monitoring data is collected once every 60 seconds. You can call the [ModifyDBClusterMonitor](https://help.aliyun.com/document_detail/159557.html) operation to set the data collection interval to every 5 seconds.
 *
 * @param request DescribeDBClusterPerformanceRequest
 * @return DescribeDBClusterPerformanceResponse
 */
async function describeDBClusterPerformance(request: DescribeDBClusterPerformanceRequest): DescribeDBClusterPerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterPerformanceWithOptions(request, runtime);
}

model DescribeDBClusterProxyRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-2zek76tdi709m6mf4'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-acfm4ifnqnun3zq'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterProxyResponseBody = {
  childInstances?: [ 
    {
      DBNodeClass?: string(name='DBNodeClass', example='polar.mysql.g4.medium'),
      DBNodeIP?: string(name='DBNodeIP', example='10.*.*10'),
      DBNodeId?: string(name='DBNodeId', example='pi-wz97h479y364g9du7'),
      DBNodePort?: string(name='DBNodePort', example='2450'),
      DBNodeStatus?: string(name='DBNodeStatus', example='Running'),
      hostName?: string(name='HostName', example='sh-lsf01-144-37'),
    }
  ](name='ChildInstances'),
  DBProxyClusterId?: string(name='DBProxyClusterId', example='pe-xxxxxxxxx'),
  DBProxyClusterNum?: long(name='DBProxyClusterNum', example='2'),
  DBProxyClusterStatus?: string(name='DBProxyClusterStatus', example='ClassChanging'),
  requestId?: string(name='RequestId', example='30E11ED2-C922-5B96-BCC6-11EE8C484AC6'),
}

model DescribeDBClusterProxyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterProxyResponseBody(name='body'),
}

/**
 * @summary 查询代理详情
 *
 * @param request DescribeDBClusterProxyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterProxyResponse
 */
async function describeDBClusterProxyWithOptions(request: DescribeDBClusterProxyRequest, runtime: Util.RuntimeOptions): DescribeDBClusterProxyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterProxy',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询代理详情
 *
 * @param request DescribeDBClusterProxyRequest
 * @return DescribeDBClusterProxyResponse
 */
async function describeDBClusterProxy(request: DescribeDBClusterProxyRequest): DescribeDBClusterProxyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterProxyWithOptions(request, runtime);
}

model DescribeDBClusterSSLRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pc-************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterSSLResponseBody = {
  items?: [ 
    {
      DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.', example='pe-************'),
      SSLAutoRotate?: string(name='SSLAutoRotate', example='Enable'),
      SSLConnectionString?: string(name='SSLConnectionString', description='The SSL connection string.', example='pc-************.mysql.polardb.rds.aliyuncs.com'),
      SSLEnabled?: string(name='SSLEnabled', description='Indicates whether SSL encryption is enabled. Valid values:

*   **Enabled**: SSL is enabled.
*   **Disable**: SSL is disabled.', example='Enabled'),
      SSLExpireTime?: string(name='SSLExpireTime', description='The time when the server certificate expires. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2021-11-13T07:14:22Z'),
    }
  ](name='Items', description='The list of SSL connections.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C890995A-CF06-4F4D-8DB8-DD26C2******'),
  SSLAutoRotate?: string(name='SSLAutoRotate', description='Indicates whether automatic rotation of SSL certificates is enabled. Valid values:

*   **Enable**: The feature is enabled.
*   **Disable**: The feature is disabled.

> This parameter is valid only for a PolarDB for MySQL cluster.', example='Enable'),
}

model DescribeDBClusterSSLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterSSLResponseBody(name='body'),
}

/**
 * @summary Queries the Secure Sockets Layer (SSL) settings of a PolarDB cluster.
 *
 * @param request DescribeDBClusterSSLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterSSLResponse
 */
async function describeDBClusterSSLWithOptions(request: DescribeDBClusterSSLRequest, runtime: Util.RuntimeOptions): DescribeDBClusterSSLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterSSL',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the Secure Sockets Layer (SSL) settings of a PolarDB cluster.
 *
 * @param request DescribeDBClusterSSLRequest
 * @return DescribeDBClusterSSLResponse
 */
async function describeDBClusterSSL(request: DescribeDBClusterSSLRequest): DescribeDBClusterSSLResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterSSLWithOptions(request, runtime);
}

model DescribeDBClusterServerlessConfRequest {
  DBClusterId?: string(name='DBClusterId', description='Serverless cluster ID.

This parameter is required.', example='pc-bp10gr51qasnl****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterServerlessConfResponseBody = {
  agileScaleMax?: string(name='AgileScaleMax'),
  allowShutDown?: string(name='AllowShutDown', description='Whether to enable idle shutdown. Values:

- **true**: Enable

- **false**: Disable (default)', example='true'),
  DBClusterId?: string(name='DBClusterId', description='Serverless cluster ID.', example='pc-bp10gr51qasnl****'),
  requestId?: string(name='RequestId', description='Request ID.', example='5E71541A-6007-4DCC-A38A-F872C31FEB45'),
  scaleApRoNumMax?: string(name='ScaleApRoNumMax', description='The maximum number of read-only column store nodes. Valid values: 0 to 15.', example='1'),
  scaleApRoNumMin?: string(name='ScaleApRoNumMin', description='The minimum number of read-only column store nodes. Valid values: 0 to 15.', example='1'),
  scaleMax?: string(name='ScaleMax', description='Maximum scaling limit for a single node. Range: 1 PCU~32 PCU.', example='3'),
  scaleMin?: string(name='ScaleMin', description='Minimum scaling limit for a single node. Range: 1 PCU~31 PCU.', example='1'),
  scaleRoNumMax?: string(name='ScaleRoNumMax', description='Maximum scaling limit for the number of read-only nodes. Range: 0~15.', example='4'),
  scaleRoNumMin?: string(name='ScaleRoNumMin', description='Minimum scaling limit for the number of read-only nodes. Range: 0~15.', example='2'),
  secondsUntilAutoPause?: string(name='SecondsUntilAutoPause', description='Detection duration for idle shutdown. Range: 300~86,400. Unit: seconds. The detection duration must be a multiple of 300 seconds.', example='10'),
  serverlessRuleCpuEnlargeThreshold?: string(name='ServerlessRuleCpuEnlargeThreshold', description='CPU upscale threshold.', example='60'),
  serverlessRuleCpuShrinkThreshold?: string(name='ServerlessRuleCpuShrinkThreshold', description='CPU downscale threshold.', example='30'),
  serverlessRuleMode?: string(name='ServerlessRuleMode', description='Elasticity sensitivity. Values:

- normal: Standard

- flexible: Sensitive', example='normal'),
  switchs?: string(name='Switchs', description='Whether steady state is enabled. Values:

1: Enabled

0: Disabled', example='1'),
  traditionalScaleMaxThreshold?: string(name='TraditionalScaleMaxThreshold'),
}

model DescribeDBClusterServerlessConfResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterServerlessConfResponseBody(name='body'),
}

/**
 * @summary Queries the serverless configurations of a serverless cluster.
 *
 * @param request DescribeDBClusterServerlessConfRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterServerlessConfResponse
 */
async function describeDBClusterServerlessConfWithOptions(request: DescribeDBClusterServerlessConfRequest, runtime: Util.RuntimeOptions): DescribeDBClusterServerlessConfResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterServerlessConf',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the serverless configurations of a serverless cluster.
 *
 * @param request DescribeDBClusterServerlessConfRequest
 * @return DescribeDBClusterServerlessConfResponse
 */
async function describeDBClusterServerlessConf(request: DescribeDBClusterServerlessConfRequest): DescribeDBClusterServerlessConfResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterServerlessConfWithOptions(request, runtime);
}

model DescribeDBClusterTDERequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-***************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterTDEResponseBody = {
  automaticRotation?: string(name='AutomaticRotation', description='Indicates whether automatic key rotation is allowed. Valid values:

*   **Enabled**: Automatic key rotation is allowed.
*   **Disabled**: Automatic key rotation is not allowed.

>  This parameter is returned only for a PolarDB for PostgreSQL or PolarDB for PostgreSQL (Compatible with Oracle) cluster.', example='Enabled'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-***************'),
  encryptNewTables?: string(name='EncryptNewTables', description='Indicates whether automatic encryption is enabled for new tables. Valid values:

*   **ON**
*   **OFF**

>  This parameter is returned only for a PolarDB for MySQL cluster.', example='ON'),
  encryptionKey?: string(name='EncryptionKey', description='The ID of the custom key.', example='2a4f4ac2-****-****-****-************'),
  encryptionKeyStatus?: string(name='EncryptionKeyStatus', example='Enabled'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E37D1508-EC3B-4E06-A24A-C7AC31******'),
  rotationInterval?: string(name='RotationInterval', description='The automatic key rotation period configured in Key Management Service (KMS). If no automatic key rotation period is configured, 0s is returned. Unit: seconds.

For example, if the rotation period is set to 7 days, 604800s is returned.

>  This parameter is returned only for a PolarDB for PostgreSQL or PolarDB for PostgreSQL (Compatible with Oracle) cluster whose AutomaticRotation parameter is set to Enabled.', example='604800s'),
  TDERegion?: string(name='TDERegion', description='The region where the TDE key resides.', example='cn-beijing'),
  TDEStatus?: string(name='TDEStatus', description='Indicates whether TDE encryption is enabled. Valid values:

*   **Enabled**
*   **Disabled**', example='Enabled'),
}

model DescribeDBClusterTDEResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterTDEResponseBody(name='body'),
}

/**
 * @summary Queries the transparent data encryption (TDE) settings of a PolarDB cluster.
 *
 * @param request DescribeDBClusterTDERequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterTDEResponse
 */
async function describeDBClusterTDEWithOptions(request: DescribeDBClusterTDERequest, runtime: Util.RuntimeOptions): DescribeDBClusterTDEResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterTDE',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the transparent data encryption (TDE) settings of a PolarDB cluster.
 *
 * @param request DescribeDBClusterTDERequest
 * @return DescribeDBClusterTDEResponse
 */
async function describeDBClusterTDE(request: DescribeDBClusterTDERequest): DescribeDBClusterTDEResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterTDEWithOptions(request, runtime);
}

model DescribeDBClusterVersionRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-****************'),
  describeType?: string(name='DescribeType', description='Specifies whether to query the information about the latest versions or the versions to which the cluster can be updated. Valid values:

*   LATEST_VERSION: the information about the latest versions.
*   AVAILABLE_VERSION: the information about the versions to which the cluster can be updated.', example='LATEST_VERSION'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterVersionResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-****************'),
  DBLatestVersion?: string(name='DBLatestVersion', description='The latest version of the database engine.', example='8.0.1.1.16'),
  DBMinorVersion?: string(name='DBMinorVersion', description='The minor version of the database engine.

- If DBVersion is 8.0, the valid values of this parameter are:
  - 8.0.2
  - 8.0.1
- If DBVersion is 5.7, set the value of this parameter to 5.7.28.
- If DBVersion is 5.6, the value of this parameter is 5.6.16.', example='8.0.1'),
  DBRevisionVersion?: string(name='DBRevisionVersion', description='The revision version of the database engine.
>For a cluster of the PolarDB for MySQL 5.6, the DBRevisionVersion parameter returns the revision version information only if the Revision Version is released later than August 31, 2020. Otherwise, this parameter returns an empty value.', example='8.0.1.1.7'),
  DBRevisionVersionList?: [ 
    {
      releaseNote?: string(name='ReleaseNote', description='The release notes for the database engine revision version.', example='ReleaseNote'),
      releaseType?: string(name='ReleaseType', description='The release status of the database engine revision version. Valid values:

*   **Stable**: The database engine revision version is stable.
*   **Old**: The database engine revision version is outdated. We recommend that you do not update the database engine to this revision version.
*   **HighRisk**: The database engine revision version has critical defects. We recommend that you do not update the database engine to this revision version.
*   **Beta**: The database engine revision version is a Beta version.', example='Stable'),
      revisionVersionCode?: string(name='RevisionVersionCode', description='The code of the database engine revision version. You can use the code to specify the database engine revision version.', example='20230707'),
      revisionVersionName?: string(name='RevisionVersionName', description='The database engine revision version number.', example='8.0.1.1.35.1'),
    }
  ](name='DBRevisionVersionList', description='The versions to which the cluster can be upgraded.'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine. Valid values:

- 5.6
- 5.7
- 8.0', example='8.0'),
  DBVersionStatus?: string(name='DBVersionStatus', description='The status of the minor version. Valid values:

*   **Stable**: The minor version is stable.
*   **Old**: The minor version is outdated. We recommend that you upgrade the cluster to the latest version.
*   **HighRisk**: The minor version has critical defects. We recommend that you immediately update the cluster to the latest minor version.

>  For more information about how to update the minor version, see [Minor version update](https://help.aliyun.com/document_detail/158572.html).', example='Stable'),
  isLatestVersion?: string(name='IsLatestVersion', description='Indicates whether the kernel is of the latest version. Valid values:

- true
- false', example='true'),
  isProxyLatestVersion?: string(name='IsProxyLatestVersion', description='Indicates whether PolarProxy uses the latest version. Valid values:

- true
- false', example='true'),
  proxyLatestVersion?: string(name='ProxyLatestVersion', description='The latest version of PolarProxy.', example='2.4.17'),
  proxyRevisionVersion?: string(name='ProxyRevisionVersion', description='The revision version of the database engine.', example='2.4.15'),
  proxyRevisionVersionList?: [ 
    {
      releaseNote?: string(name='ReleaseNote', description='The release notes for the PolarProxy revision version.', example='ReleaseNote'),
      releaseType?: string(name='ReleaseType', description='The release type. Valid values:

*   **LTS**: a long-term version
*   **BETA**: a preview version', example='LTS'),
      revisionVersionCode?: string(name='RevisionVersionCode', description='The PolarProxy revision version code. You can use this code to specify the PolarProxy revision version.', example='20230707'),
      revisionVersionName?: string(name='RevisionVersionName', description='The PolarProxy revision version number.', example='2.8.24'),
    }
  ](name='ProxyRevisionVersionList', description='The release status of the PolarProxy version. Valid values:

*   **Stable**: The PolarProxy revision version is stable.
*   **Old**: The PolarProxy revision version is outdated. We recommend that you do not update the PolarProxy to this revision version.
*   **HighRisk**: The PolarProxy revision version has critical defects. We recommend that you do not update the PolarProxy to this revision version.
*   **Beta**: The PolarProxy revision version is a Beta version.'),
  proxyVersionStatus?: string(name='ProxyVersionStatus', description='The status of PolarProxy. Valid values:

- Stable: The minor version is stable.
- Old: The minor version is outdated. We recommend that you upgrade the cluster to the latest version.
- HighRisk: The minor version has critical defects. We recommend that you immediately upgrade the cluster to the latest version.
- Beta: The minor version is a beta version.', example='Stable'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='47921222-0D37-4133-8C0D-017DC3******'),
}

model DescribeDBClusterVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterVersionResponseBody(name='body'),
}

/**
 * @summary Queries the information about the database engine version of a PolarDB for MySQL cluster.
 *
 * @param request DescribeDBClusterVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterVersionResponse
 */
async function describeDBClusterVersionWithOptions(request: DescribeDBClusterVersionRequest, runtime: Util.RuntimeOptions): DescribeDBClusterVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.describeType)) {
    query['DescribeType'] = request.describeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterVersion',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about the database engine version of a PolarDB for MySQL cluster.
 *
 * @param request DescribeDBClusterVersionRequest
 * @return DescribeDBClusterVersionResponse
 */
async function describeDBClusterVersion(request: DescribeDBClusterVersionRequest): DescribeDBClusterVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterVersionWithOptions(request, runtime);
}

model DescribeDBClusterVersionZonalRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-****************'),
  describeType?: string(name='DescribeType', example='LATEST_VERSION'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterVersionZonalResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-****************'),
  DBLatestVersion?: string(name='DBLatestVersion', example='8.0.1.1.16'),
  DBMinorVersion?: string(name='DBMinorVersion', example='8.0.1'),
  DBRevisionVersion?: string(name='DBRevisionVersion', example='8.0.1.1.7'),
  DBRevisionVersionList?: [ 
    {
      releaseNote?: string(name='ReleaseNote', example='ReleaseNote'),
      releaseType?: string(name='ReleaseType', example='Stable'),
      revisionVersionCode?: string(name='RevisionVersionCode', example='20230707'),
      revisionVersionName?: string(name='RevisionVersionName', example='8.0.1.1.35.1'),
    }
  ](name='DBRevisionVersionList'),
  DBVersion?: string(name='DBVersion', example='5.6'),
  DBVersionStatus?: string(name='DBVersionStatus', example='Stable'),
  isLatestVersion?: string(name='IsLatestVersion', example='true'),
  isProxyLatestVersion?: string(name='IsProxyLatestVersion', example='true'),
  proxyLatestVersion?: string(name='ProxyLatestVersion', example='2.4.17'),
  proxyRevisionVersion?: string(name='ProxyRevisionVersion', example='2.4.15'),
  proxyRevisionVersionList?: [ 
    {
      releaseNote?: string(name='ReleaseNote', example='ReleaseNote'),
      releaseType?: string(name='ReleaseType', example='LTS'),
      revisionVersionCode?: string(name='RevisionVersionCode', example='20230707'),
      revisionVersionName?: string(name='RevisionVersionName', example='2.8.24'),
    }
  ](name='ProxyRevisionVersionList'),
  proxyVersionStatus?: string(name='ProxyVersionStatus', example='Stable'),
  requestId?: string(name='RequestId', example='47921222-0D37-4133-8C0D-017DC3******'),
}

model DescribeDBClusterVersionZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterVersionZonalResponseBody(name='body'),
}

/**
 * @summary PolarDB边缘集群查询版本
 *
 * @param request DescribeDBClusterVersionZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterVersionZonalResponse
 */
async function describeDBClusterVersionZonalWithOptions(request: DescribeDBClusterVersionZonalRequest, runtime: Util.RuntimeOptions): DescribeDBClusterVersionZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.describeType)) {
    query['DescribeType'] = request.describeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterVersionZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary PolarDB边缘集群查询版本
 *
 * @param request DescribeDBClusterVersionZonalRequest
 * @return DescribeDBClusterVersionZonalResponse
 */
async function describeDBClusterVersionZonal(request: DescribeDBClusterVersionZonalRequest): DescribeDBClusterVersionZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterVersionZonalWithOptions(request, runtime);
}

model DescribeDBClustersRequest {
  connectionString?: string(name='ConnectionString', description='The endpoint of the cluster.', example='********.rwlb.polardb-pg-public.rds.aliyuncs.com'),
  DBClusterDescription?: string(name='DBClusterDescription', description='The description of the cluster. Fuzzy match is supported.', example='pc-****************'),
  DBClusterIds?: string(name='DBClusterIds', description='The ID of the cluster. Separate multiple cluster IDs with commas (,).', example='pc-****************'),
  DBClusterStatus?: string(name='DBClusterStatus', description='The state of the cluster that you want to query. For information about valid values, see [Cluster states](https://help.aliyun.com/document_detail/99286.html).', example='Running'),
  DBNodeIds?: string(name='DBNodeIds', description='The ID of the node. You can specify multiple node IDs. Separate multiple node IDs with commas (,).', example='pi-***************'),
  DBType?: string(name='DBType', description='The database engine that the cluster runs. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The database engine version of the cluster.', example='5.6'),
  describeType?: string(name='DescribeType', description='The query mode of the list. The value Simple indicates that the simple mode is used. In this mode, only the basic metadata information of the cluster is returned.

> If you do not specify this parameter, the detailed mode is used by default. Detailed information about the cluster is returned.', example='Simple'),
  expired?: boolean(name='Expired', description='Specifies whether the cluster has expired. Valid values:

*   **true**
*   **false**', example='true'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value must be a positive integer that does not exceed the maximum value of the INTEGER data type. Default value: **1**.', example='10'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **30**, **50**, and **100**.

Default value: **30**.', example='30'),
  payType?: string(name='PayType', description='The billing method. Valid values:

*   **Postpaid**: pay-as-you-go
*   **Prepaid**: subscription', example='Postpaid'),
  recentCreationInterval?: int32(name='RecentCreationInterval', description='Filters clusters created in the last N days. Valid values: 0 to 15.', example='7'),
  recentExpirationInterval?: int32(name='RecentExpirationInterval', description='Filters clusters that expire after N days. Valid values: 0 to 15.', example='6'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the available regions.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag. You can use tags to filter clusters. You can specify up to 20 tags. N specifies the serial number of each tag. The values that you specify for N must be unique and consecutive integers that start from 1. The value of Tag.N.Key is Tag.N.Value.

> The tag key can be up to 64 characters in length and cannot start with `aliyun`, `acs:`, `http://`, or `https://`.', example='MySQL'),
      value?: string(name='Value', description='The value of the tag.

> The tag value can be up to 64 characters in length and cannot start with `aliyun`, `acs:`, `http://`, or `https://`.', example='5.6'),
    }
  ](name='Tag', description='The tags of the cluster.'),
}

model DescribeDBClustersResponseBody = {
  items?: {
    DBCluster?: [ 
    {
      aiType?: string(name='AiType', description='The type of the AI node. Valid values:

*   SearchNode: search node
*   DLNode: AI node

Enumeration values:

*   SearchNode | DLNode: both
*   DLNode: AI node
*   SearchNode: search node', example='SearchNode'),
      category?: string(name='Category', description='The edition of the cluster. Valid values:

*   **Normal**: Cluster Edition
*   **Basic**: Single Node Edition
*   **Archive**: X-Engine Edition
*   **NormalMultimaster**: Multi-master Cluster (Database/Table) Edition', example='Normal'),
      cpuCores?: string(name='CpuCores', description='The number of CPU cores.', example='1'),
      createTime?: string(name='CreateTime', description='The time when the cluster was created.', example='2020-08-14T05:58:42Z'),
      DBClusterDescription?: string(name='DBClusterDescription', description='The description of the cluster.', example='GDN-1'),
      DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-****************'),
      DBClusterNetworkType?: string(name='DBClusterNetworkType', description='The network type of the cluster.', example='VPC'),
      DBClusterStatus?: string(name='DBClusterStatus', description='The state of the cluster.', example='Running'),
      DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node.', example='polar.mysql.x4.large'),
      DBNodeNumber?: int32(name='DBNodeNumber', description='The number of nodes.', example='2'),
      DBNodes?: {
        DBNode?: [ 
        {
          DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node.', example='polar.mysql.x4.large'),
          DBNodeId?: string(name='DBNodeId', description='The ID of the node.', example='pi-****************'),
          DBNodeRole?: string(name='DBNodeRole', description='The role of the node. Valid values:

*   **Writer**: primary node
*   **Reader**: read-only node
*   **ColumnReader**: column store read-only node
*   **AI**: AI node', example='Reader'),
          hotReplicaMode?: string(name='HotReplicaMode', description='Indicates whether the hot standby feature is enabled. Valid values:

*   **ON**
*   **OFF**', example='OFF'),
          imciSwitch?: string(name='ImciSwitch', description='Indicates whether the In-Memory Column Index (IMCI) feature is enabled. Valid values:

*   **ON**
*   **OFF**', example='OFF'),
          regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
          serverless?: string(name='Serverless', description='Indicates whether the serverless feature is enabled for the node.

*   **ON** indicates that the serverless feature is enabled.
*   No value is returned if the serverless feature is disabled.', example='ON'),
          zoneId?: string(name='ZoneId', description='The zone ID of the cluster.', example='cn-hangzhou-i'),
        }
      ](name='DBNode')
      }(name='DBNodes', description='The information about the nodes.'),
      DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='5.6'),
      deletionLock?: int32(name='DeletionLock', description='Indicates whether the cluster is protected from deletion. Valid values:

*   **0**: The cluster is not protected from deletion.
*   **1**: The cluster is protected from deletion.

>  You cannot delete clusters that are protected from deletion.', example='0'),
      engine?: string(name='Engine', description='The database engine of the cluster.', example='POLARDB'),
      expireTime?: string(name='ExpireTime', description='The expiration time of the cluster.

>  A specific value is returned only for subscription (**Prepaid**) clusters. For pay-as-you-go (**Postpaid**) clusters, no value is returned.', example='2020-11-14T16:00:00Z'),
      expired?: string(name='Expired', description='Indicates whether the cluster has expired. Valid values:

*   **true**
*   **false**

>  A specific value is returned only for subscription (**Prepaid**) clusters.', example='false'),
      hotStandbyCluster?: string(name='HotStandbyCluster', description='Indicates whether the hot standby storage cluster feature is enabled. Valid values:

*   ON
*   OFF', example='OFF'),
      lockMode?: string(name='LockMode', description='The lock state of the cluster. Valid values:

*   **Unlock**: The cluster is unlocked.
*   **ManualLock**: The cluster is manually locked.
*   **LockByExpiration**: The cluster is locked due to cluster expiration.', example='Unlock'),
      memorySize?: string(name='MemorySize', description='The memory size for local operations. Unit: MB.', example='2048'),
      payType?: string(name='PayType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go
*   **Prepaid**: subscription', example='Prepaid'),
      regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
      remoteMemorySize?: string(name='RemoteMemorySize', description='The memory size for distributed operations. Unit: MB.', example='3612'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
      searchStorageUsed?: long(name='SearchStorageUsed'),
      serverlessType?: string(name='ServerlessType', description='Indicates whether the cluster is a serverless cluster. **AgileServerless** indicates the cluster is a serverless cluster. No value is returned for a common cluster.', example='AgileServerless'),
      storagePayType?: string(name='StoragePayType', description='The storage billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go
*   **Prepaid**: subscription', example='Prepaid'),
      storageSpace?: long(name='StorageSpace', description='The storage that is billed based on the subscription billing method. Unit: bytes.', example='50'),
      storageType?: string(name='StorageType', description='The storage type.', example='essdautopl'),
      storageUsed?: long(name='StorageUsed', description='The used storage. Unit: bytes.', example='3009413120'),
      strictConsistency?: string(name='StrictConsistency', description='Indicates whether multi-zone data consistency is enabled for the cluster. Valid values:

*   **ON**: Multi-zone data consistency is enabled. For Standard Edition clusters of Multi-zone Edition, this value is returned.
*   **OFF**: Multi-zone data consistency is disabled.', example='ON'),
      subCategory?: string(name='SubCategory', description='The specification type of the compute node. Valid values:

*   **Exclusive**: dedicated.
*   **General**: general-purpose.', example='Exclusive'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key', description='The key of the tag.', example='MySQL'),
          value?: string(name='Value', description='The value of the tag.', example='5.6'),
        }
      ](name='Tag')
      }(name='Tags', description='The information about the tags.'),
      vpcId?: string(name='VpcId', description='The virtual private cloud (VPC) ID of the cluster.', example='vpc-****************'),
      vswitchId?: string(name='VswitchId', description='The vSwitch ID of the cluster.', example='vsw-***************'),
      zoneId?: string(name='ZoneId', description='The zone ID of the cluster.', example='cn-hangzhou-i'),
    }
  ](name='DBCluster')
  }(name='Items', description='The information about the clusters.'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='12'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of clusters returned per page.', example='5'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of returned entries.', example='16'),
}

model DescribeDBClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClustersResponseBody(name='body'),
}

/**
 * @summary Queries PolarDB clusters or the clusters that can be accessed by an authorized RAM user.
 *
 * @param request DescribeDBClustersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClustersResponse
 */
async function describeDBClustersWithOptions(request: DescribeDBClustersRequest, runtime: Util.RuntimeOptions): DescribeDBClustersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionString)) {
    query['ConnectionString'] = request.connectionString;
  }
  if (!Util.isUnset(request.DBClusterDescription)) {
    query['DBClusterDescription'] = request.DBClusterDescription;
  }
  if (!Util.isUnset(request.DBClusterIds)) {
    query['DBClusterIds'] = request.DBClusterIds;
  }
  if (!Util.isUnset(request.DBClusterStatus)) {
    query['DBClusterStatus'] = request.DBClusterStatus;
  }
  if (!Util.isUnset(request.DBNodeIds)) {
    query['DBNodeIds'] = request.DBNodeIds;
  }
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.describeType)) {
    query['DescribeType'] = request.describeType;
  }
  if (!Util.isUnset(request.expired)) {
    query['Expired'] = request.expired;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.recentCreationInterval)) {
    query['RecentCreationInterval'] = request.recentCreationInterval;
  }
  if (!Util.isUnset(request.recentExpirationInterval)) {
    query['RecentExpirationInterval'] = request.recentExpirationInterval;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusters',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries PolarDB clusters or the clusters that can be accessed by an authorized RAM user.
 *
 * @param request DescribeDBClustersRequest
 * @return DescribeDBClustersResponse
 */
async function describeDBClusters(request: DescribeDBClustersRequest): DescribeDBClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClustersWithOptions(request, runtime);
}

model DescribeDBClustersWithBackupsRequest {
  DBClusterDescription?: string(name='DBClusterDescription', description='The name of the cluster. The name must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must be 2 to 256 characters in length.', example='test'),
  DBClusterIds?: string(name='DBClusterIds', description='The ID of the cluster. If you need to specify multiple cluster IDs, separate the cluster IDs with commas (,).', example='pc-**************'),
  DBType?: string(name='DBType', description='The type of the database engine. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.

*   Valid values for the MySQL database engine:

    *   **5.6**
    *   **5.7**
    *   **8.0**

*   Valid values for the PostgreSQL database engine:

    *   **11**
    *   **14**

*   Valid value for the Oracle database engine: **11**', example='8.0'),
  isDeleted?: int32(name='IsDeleted', description='Specifies whether the cluster is deleted. Valid values:

*   **0**: not deleted
*   **1**: deleted', example='0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. The value must be a positive integer that does not exceed the maximum value of the INTEGER data type. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: 30.', example='30'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query information about regions.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClustersWithBackupsResponseBody = {
  items?: {
    DBCluster?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the cluster was created.', example='2022-05-09T09:33:51Z'),
      DBClusterDescription?: string(name='DBClusterDescription', description='The name of the cluster.', example='test'),
      DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-****************'),
      DBClusterNetworkType?: string(name='DBClusterNetworkType', description='The network type of the cluster.', example='VPC'),
      DBClusterStatus?: string(name='DBClusterStatus', description='The status of the cluster. Valid values:

*   Creating: The cluster is being created.
*   Running: The cluster is running.
*   Deleting: The cluster is being released.
*   Rebooting: The cluster is restarting.
*   DBNodeCreating: The node is being added.
*   DBNodeDeleting: The node is being deleted.
*   ClassChanging: The specifications of the node are being changed.
*   NetAddressCreating: The network connection is being created.
*   NetAddressDeleting: The network connection is being deleted.
*   NetAddressModifying: The network connection is being modified.
*   Deleted: The cluster has been released.', example='Running'),
      DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node.', example='polar.mysql.x4.medium'),
      DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='8.0'),
      deletedTime?: string(name='DeletedTime', description='The time when the cluster was deleted.', example='2022-05-12T03:25:37Z'),
      deletionLock?: int32(name='DeletionLock', description='Indicates whether the cluster is locked and can be deleted. Valid values:

*   **0**: The cluster is not locked and can be deleted.
*   **1**: The cluster is locked and cannot be deleted.', example='0'),
      engine?: string(name='Engine', description='The type of the database engine.', example='POLARDB'),
      expireTime?: string(name='ExpireTime', description='The time when the cluster expires.

> A specific value will be returned only for subscription clusters. For pay-as-you-go clusters, an empty string will be returned.', example='2022-09-14T16:00:00Z'),
      expired?: string(name='Expired', description='Indicates whether the cluster has expired.

> A specific value will be returned only for subscription clusters.', example='false'),
      isDeleted?: int32(name='IsDeleted', description='Indicates whether the cluster was released. Valid values:

*   1: released
*   0: not released', example='1'),
      lockMode?: string(name='LockMode', description='The state of the cluster lock. Valid values:

*   **Unlock**: The cluster is not locked.
*   **ManualLock**: The cluster is manually locked.
*   **LockByExpiration**: The cluster is automatically locked after the cluster expires.', example='Unlock'),
      payType?: string(name='PayType', description='The billing method. Valid values:

*   **Postpaid**: pay-as-you-go.
*   **Prepaid**: subscription', example='Postpaid'),
      regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
      vpcId?: string(name='VpcId', description='The VPC ID of the cluster.', example='vpc-******************'),
      zoneId?: string(name='ZoneId', description='The ID of the zone in which the instance is located.', example='cn-hangzhou-h'),
    }
  ](name='DBCluster')
  }(name='Items', description='The details about the cluster.'),
  pageNumber?: int32(name='PageNumber', description='The total number of returned pages.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of clusters returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F8529AA2-522F-4B30-B80B-8F7D39******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of returned entries.', example='1'),
}

model DescribeDBClustersWithBackupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClustersWithBackupsResponseBody(name='body'),
}

/**
 * @summary Queries the information about PolarDB clusters that contain backup sets in a region.
 *
 * @param request DescribeDBClustersWithBackupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClustersWithBackupsResponse
 */
async function describeDBClustersWithBackupsWithOptions(request: DescribeDBClustersWithBackupsRequest, runtime: Util.RuntimeOptions): DescribeDBClustersWithBackupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterDescription)) {
    query['DBClusterDescription'] = request.DBClusterDescription;
  }
  if (!Util.isUnset(request.DBClusterIds)) {
    query['DBClusterIds'] = request.DBClusterIds;
  }
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.isDeleted)) {
    query['IsDeleted'] = request.isDeleted;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClustersWithBackups',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about PolarDB clusters that contain backup sets in a region.
 *
 * @param request DescribeDBClustersWithBackupsRequest
 * @return DescribeDBClustersWithBackupsResponse
 */
async function describeDBClustersWithBackups(request: DescribeDBClustersWithBackupsRequest): DescribeDBClustersWithBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClustersWithBackupsWithOptions(request, runtime);
}

model DescribeDBClustersZonalRequest {
  cloudProvider?: string(name='CloudProvider', example='AlibabaCloud'),
  connectionString?: string(name='ConnectionString', example='********.rwlb.polardb-pg-public.rds.aliyuncs.com'),
  DBClusterDescription?: string(name='DBClusterDescription', example='pc-****************'),
  DBClusterIds?: string(name='DBClusterIds', example='pc-****************'),
  DBClusterStatus?: string(name='DBClusterStatus', example='Running'),
  DBNodeIds?: string(name='DBNodeIds', example='pi-***************'),
  DBType?: string(name='DBType', example='MySQL'),
  DBVersion?: string(name='DBVersion', example='5.6'),
  describeType?: string(name='DescribeType', example='Simple'),
  expired?: string(name='Expired', example='true'),
  maxResults?: int32(name='MaxResults', example='10'),
  nextToken?: string(name='NextToken', example='212db86sca4384811e0b5e8707e******'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', example='10'),
  pageSize?: int32(name='PageSize', example='30'),
  payType?: string(name='PayType', example='Postpaid'),
  recentCreationInterval?: int32(name='RecentCreationInterval', example='7'),
  recentExpirationInterval?: int32(name='RecentExpirationInterval', example='6'),
  regionId?: string(name='RegionId', description='This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-**********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tag?: [ 
    {
      key?: string(name='Key', example='MySQL'),
      value?: string(name='Value', example='5.6'),
    }
  ](name='Tag'),
}

model DescribeDBClustersZonalResponseBody = {
  items?: [ 
    {
      aiType?: string(name='AiType', example='SearchNode'),
      category?: string(name='Category', example='Normal'),
      centralControlRegionId?: string(name='CentralControlRegionId', example='cn-beijing'),
      cloudProvider?: string(name='CloudProvider', example='ENS'),
      cpuCores?: string(name='CpuCores', example='1'),
      createTime?: string(name='CreateTime', example='2020-08-14T05:58:42Z'),
      DBClusterDescription?: string(name='DBClusterDescription', example='GDN-1'),
      DBClusterId?: string(name='DBClusterId', example='pc-****************'),
      DBClusterStatus?: string(name='DBClusterStatus', example='Running'),
      DBNodeClass?: string(name='DBNodeClass', example='polar.mysql.g1.tiny.c'),
      DBNodeNumber?: int32(name='DBNodeNumber', example='2'),
      DBType?: string(name='DBType', example='MySQL'),
      DBVersion?: string(name='DBVersion', example='5.6'),
      ENSRegionId?: string(name='ENSRegionId', example='sg-singapore-9'),
      expireTime?: string(name='ExpireTime', example='2022-09-14T16:00:00Z'),
      expired?: string(name='Expired', example='false'),
      lockMode?: string(name='LockMode', example='Unlock'),
      payType?: string(name='PayType', example='Prepaid'),
      serverlessType?: string(name='ServerlessType', example='AgileServerless'),
      storageSpace?: long(name='StorageSpace', example='10'),
      storageType?: string(name='StorageType', example='essdautopl'),
      storageUsed?: long(name='StorageUsed', example='3009413120'),
      strictConsistency?: string(name='StrictConsistency', example='ON'),
      subCategory?: string(name='SubCategory', example='Exclusive'),
      tags?: [ 
        {
          key?: string(name='Key', example='MySQL'),
          value?: string(name='Value', example='5.6'),
        }
      ](name='Tags'),
      vpcId?: string(name='VpcId', example='vpc-****************'),
      vswitchId?: string(name='VswitchId', example='vsw-***************'),
      zoneId?: string(name='ZoneId', example='cn-hangzhou-i'),
    }
  ](name='Items'),
  maxResults?: int32(name='MaxResults', example='10'),
  nextToken?: string(name='NextToken', example='212db86sca4384811e0b5e8707e******'),
  pageNumber?: int32(name='PageNumber', example='12'),
  pageRecordCount?: int32(name='PageRecordCount', example='5'),
  requestId?: string(name='RequestId', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
  totalRecordCount?: int32(name='TotalRecordCount', example='16'),
}

model DescribeDBClustersZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClustersZonalResponseBody(name='body'),
}

/**
 * @summary MyBase中的PolarDB列表
 *
 * @param request DescribeDBClustersZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClustersZonalResponse
 */
async function describeDBClustersZonalWithOptions(request: DescribeDBClustersZonalRequest, runtime: Util.RuntimeOptions): DescribeDBClustersZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cloudProvider)) {
    query['CloudProvider'] = request.cloudProvider;
  }
  if (!Util.isUnset(request.connectionString)) {
    query['ConnectionString'] = request.connectionString;
  }
  if (!Util.isUnset(request.DBClusterDescription)) {
    query['DBClusterDescription'] = request.DBClusterDescription;
  }
  if (!Util.isUnset(request.DBClusterIds)) {
    query['DBClusterIds'] = request.DBClusterIds;
  }
  if (!Util.isUnset(request.DBClusterStatus)) {
    query['DBClusterStatus'] = request.DBClusterStatus;
  }
  if (!Util.isUnset(request.DBNodeIds)) {
    query['DBNodeIds'] = request.DBNodeIds;
  }
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.describeType)) {
    query['DescribeType'] = request.describeType;
  }
  if (!Util.isUnset(request.expired)) {
    query['Expired'] = request.expired;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.recentCreationInterval)) {
    query['RecentCreationInterval'] = request.recentCreationInterval;
  }
  if (!Util.isUnset(request.recentExpirationInterval)) {
    query['RecentExpirationInterval'] = request.recentExpirationInterval;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClustersZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary MyBase中的PolarDB列表
 *
 * @param request DescribeDBClustersZonalRequest
 * @return DescribeDBClustersZonalResponse
 */
async function describeDBClustersZonal(request: DescribeDBClustersZonalRequest): DescribeDBClustersZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClustersZonalWithOptions(request, runtime);
}

model DescribeDBInitializeVariableRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.

This parameter is required.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBInitializeVariableResponseBody = {
  DBType?: string(name='DBType', description='The database type. Valid values:

*   Oracle
*   PostgreSQL
*   MySQL', example='PostgreSQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='11'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='475F58B7-F394-4394-AA6E-4F1CBA******'),
  variables?: {
    variable?: [ 
    {
      charset?: string(name='Charset', description='The character set that is supported.', example='EUC_CN'),
      collate?: string(name='Collate', description='The language that indicates the collation of the databases that are created.

>- The language must be compatible with the character set that is specified by **CharacterSetName**.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is optional for PolarDB for MySQL clusters.

To view the valid values for this parameter, perform the following steps: Log on to the PolarDB console and click the ID of a cluster. In the left-side navigation pane, choose **Settings and Management** > **Databases**. Then, click **Create Database**.', example='C'),
      ctype?: string(name='Ctype', description='The language that indicates the character type of the database.

> 

*   The language must be compatible with the character set that is specified by **CharacterSetName**.

*   The specified parameter value must be the same as the value of **Collate**.

*   If the PolarDB cluster runs PolarDB for PostgreSQL (Compatible with Oracle) or PolarDB for PostgreSQL, this parameter is required. If the cluster runs PolarDB for MySQL, this parameter is not supported.

To view the valid values of this parameter, perform the following steps: First, log on to the PolarDB console and click the ID of a cluster. Then, in the left-side navigation pane, choose **Settings and Management** > **Databases**. Finally, click **Create Database**.', example='C'),
    }
  ](name='Variable')
  }(name='Variables', description='The attributes that are returned.'),
}

model DescribeDBInitializeVariableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBInitializeVariableResponseBody(name='body'),
}

/**
 * @summary Queries attributes such as character sets and collations supported by a database in a PolarDB cluster.
 *
 * @param request DescribeDBInitializeVariableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInitializeVariableResponse
 */
async function describeDBInitializeVariableWithOptions(request: DescribeDBInitializeVariableRequest, runtime: Util.RuntimeOptions): DescribeDBInitializeVariableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInitializeVariable',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries attributes such as character sets and collations supported by a database in a PolarDB cluster.
 *
 * @param request DescribeDBInitializeVariableRequest
 * @return DescribeDBInitializeVariableResponse
 */
async function describeDBInitializeVariable(request: DescribeDBInitializeVariableRequest): DescribeDBInitializeVariableResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInitializeVariableWithOptions(request, runtime);
}

model DescribeDBInstancePerformanceRequest {
  DBInstanceId?: string(name='DBInstanceId', description='This parameter is required.', example='pi-*************'),
  endTime?: string(name='EndTime', description='This parameter is required.', example='2020-01-15T17:00Z'),
  key?: string(name='Key', example='PolarDBCPUForPCU,PolarDBPCU,PolarDBMemoryForPCU,PolarDBQPSTPS,PolarDBConnections'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='This parameter is required.', example='2022-11-15T16:00Z'),
}

model DescribeDBInstancePerformanceResponseBody = {
  DBInstanceId?: string(name='DBInstanceId', example='pi-*************'),
  DBType?: string(name='DBType', example='MySQL'),
  DBVersion?: string(name='DBVersion', example='5.6'),
  endTime?: string(name='EndTime', example='2020-09-23T01:01Z'),
  engine?: string(name='Engine', example='POLARDB'),
  performanceKeys?: {
    performanceItem?: [ 
    {
      measurement?: string(name='Measurement', example='PolarDBDiskUsage'),
      metricName?: string(name='MetricName', example='mean_data_size'),
      points?: {
        performanceItemValue?: [ 
        {
          timestamp?: long(name='Timestamp', example='1737424822'),
          value?: string(name='Value', example='12.33'),
        }
      ](name='PerformanceItemValue')
      }(name='Points'),
    }
  ](name='PerformanceItem')
  }(name='PerformanceKeys'),
  requestId?: string(name='RequestId', example='F2A9EFA7-915F-4572-8299-85A307******'),
  startTime?: string(name='StartTime', example='2020-09-23T01:01Z'),
}

model DescribeDBInstancePerformanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBInstancePerformanceResponseBody(name='body'),
}

/**
 * @param request DescribeDBInstancePerformanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBInstancePerformanceResponse
 */
async function describeDBInstancePerformanceWithOptions(request: DescribeDBInstancePerformanceRequest, runtime: Util.RuntimeOptions): DescribeDBInstancePerformanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstancePerformance',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeDBInstancePerformanceRequest
 * @return DescribeDBInstancePerformanceResponse
 */
async function describeDBInstancePerformance(request: DescribeDBInstancePerformanceRequest): DescribeDBInstancePerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancePerformanceWithOptions(request, runtime);
}

model DescribeDBLinksRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster for which you want to query the database links.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/173433.html) operation to query PolarDB clusters.

This parameter is required.', example='pc-a*************'),
  DBLinkName?: string(name='DBLinkName', description='The name of the database link. If you leave this parameter empty, the system returns all the database links.', example='dblink_test'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBLinksResponseBody = {
  DBInstanceName?: string(name='DBInstanceName', description='The ID of the cluster.', example='pc-a*************'),
  DBLinkInfos?: [ 
    {
      DBInstanceName?: string(name='DBInstanceName', description='The ID of the source cluster that the database link connects.', example='pc-a*************'),
      DBLinkName?: string(name='DBLinkName', description='The name of the database link.', example='dblink_test'),
      sourceDBName?: string(name='SourceDBName', description='The name of the source database of the database link.', example='testdb1'),
      targetAccount?: string(name='TargetAccount', description='The account of the destination database of the database link.', example='testacc'),
      targetDBInstanceName?: string(name='TargetDBInstanceName', description='The ID of the destination cluster that the database link connects.

> If the destination cluster is not a PolarDB for Oracle cluster, the returned value is empty.', example='pc-b************'),
      targetDBName?: string(name='TargetDBName', description='The name of the destination database of the database link.', example='testdb2'),
    }
  ](name='DBLinkInfos', description='Details about the database links.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='45D24263-7E3A-4140-9472-************'),
}

model DescribeDBLinksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBLinksResponseBody(name='body'),
}

/**
 * @summary Queries the database links of a PolarDB for PostgreSQL (Compatible with Oracle) cluster.
 *
 * @description > You can query only the database links that use a PolarDB for Oracle cluster as the source.
 *
 * @param request DescribeDBLinksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBLinksResponse
 */
async function describeDBLinksWithOptions(request: DescribeDBLinksRequest, runtime: Util.RuntimeOptions): DescribeDBLinksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBLinkName)) {
    query['DBLinkName'] = request.DBLinkName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBLinks',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the database links of a PolarDB for PostgreSQL (Compatible with Oracle) cluster.
 *
 * @description > You can query only the database links that use a PolarDB for Oracle cluster as the source.
 *
 * @param request DescribeDBLinksRequest
 * @return DescribeDBLinksResponse
 */
async function describeDBLinks(request: DescribeDBLinksRequest): DescribeDBLinksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBLinksWithOptions(request, runtime);
}

model DescribeDBLogFilesRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-*************'),
  DBNodeId?: string(name='DBNodeId', example='pi-*************'),
  describeSimulateSwitchMode?: string(name='DescribeSimulateSwitchMode'),
  endTime?: string(name='EndTime', example='2023-09-20T16:00:00Z'),
  logType?: string(name='LogType', description='The log type. Valid values:

*   **HaSwitchLogList**: failover logs.

This parameter is required.', example='HaSwitchLogList'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  simulateListId?: string(name='SimulateListId'),
  simulateModeList?: string(name='SimulateModeList'),
  simulateStatusList?: string(name='SimulateStatusList'),
  startTime?: string(name='StartTime', example='2023-08-20T16:00:00Z'),
}

model DescribeDBLogFilesResponseBody = {
  DBInstanceName?: string(name='DBInstanceName', example='pi-****************'),
  DBInstanceType?: string(name='DBInstanceType', example='polardb_mysql_rw'),
  haLogItems?: [ 
    {
      affectedSessions?: long(name='AffectedSessions'),
      fromDBType?: string(name='FromDBType'),
      switchCauseCode?: string(name='SwitchCauseCode'),
      switchCauseDetail?: string(name='SwitchCauseDetail'),
      switchFinishTime?: string(name='SwitchFinishTime'),
      switchId?: string(name='SwitchId', example='e571f897-9b3c-4012-9470-88333832dec4'),
      switchStartTime?: string(name='SwitchStartTime'),
      switchType?: long(name='SwitchType', example='0'),
      totalSessions?: long(name='TotalSessions'),
    }
  ](name='HaLogItems'),
  haStatus?: int32(name='HaStatus', example='1'),
  itemsNumbers?: int32(name='ItemsNumbers', example='10'),
  pageNumber?: int32(name='PageNumber', example='6'),
  pageSize?: int32(name='PageSize', example='10'),
  requestId?: string(name='RequestId', example='24A1990B-4F6E-482B-B8CB-75C612******'),
  switchListItems?: [ 
    {
      DBNodeCrashList?: [ string ](name='DBNodeCrashList'),
      endTime?: string(name='EndTime'),
      eventFinishTime?: string(name='EventFinishTime'),
      eventStartTime?: string(name='EventStartTime'),
      faultInjectionType?: string(name='FaultInjectionType'),
      simulateListId?: string(name='SimulateListId'),
      simulateMode?: string(name='SimulateMode'),
      simulateStatus?: string(name='SimulateStatus'),
      simulateTaskId?: string(name='SimulateTaskId'),
      startTime?: string(name='StartTime'),
      switchLogItems?: [ 
        {
          DBInstanceId?: string(name='DBInstanceId'),
          dstDbType?: string(name='DstDbType'),
          eventFinishTime?: string(name='EventFinishTime'),
          eventStartTime?: string(name='EventStartTime'),
          simulateListId?: string(name='SimulateListId'),
          simulateLogId?: string(name='SimulateLogId'),
          simulateStatus?: string(name='SimulateStatus'),
          srcDbType?: string(name='SrcDbType'),
          switchStepItems?: [ 
            {
              endTime?: string(name='EndTime'),
              isSuccess?: string(name='IsSuccess'),
              simulatePhase?: string(name='SimulatePhase'),
              startTime?: string(name='StartTime'),
              stepName?: string(name='StepName'),
              timeCost?: string(name='TimeCost'),
            }
          ](name='SwitchStepItems'),
        }
      ](name='SwitchLogItems'),
      switchStepItems?: [ 
        {
          DBNodeId?: string(name='DBNodeId'),
          endTime?: string(name='EndTime'),
          isSuccess?: string(name='IsSuccess'),
          simulatePhase?: string(name='SimulatePhase'),
          startTime?: string(name='StartTime'),
          stepName?: string(name='StepName'),
          timeCost?: string(name='TimeCost'),
        }
      ](name='SwitchStepItems'),
    }
  ](name='SwitchListItems'),
  switchLogItems?: [ 
    {
      DBInstanceId?: string(name='DBInstanceId'),
      dstDbType?: string(name='DstDbType'),
      eventFinishTime?: string(name='EventFinishTime'),
      eventStartTime?: string(name='EventStartTime'),
      simulateListId?: string(name='SimulateListId'),
      simulateStatus?: string(name='SimulateStatus'),
      simulatecode?: string(name='Simulatecode'),
      srcDbType?: string(name='SrcDbType'),
      switchStepItems?: [ 
        {
          DBNodeId?: string(name='DBNodeId'),
          endTime?: string(name='EndTime'),
          isSuccess?: string(name='IsSuccess'),
          simulatePhase?: string(name='SimulatePhase'),
          startTime?: string(name='StartTime'),
          stepMsg?: string(name='StepMsg'),
          stepName?: string(name='StepName'),
          timeCost?: string(name='TimeCost'),
        }
      ](name='SwitchStepItems'),
    }
  ](name='SwitchLogItems'),
  totalRecords?: int32(name='TotalRecords', example='160'),
}

model DescribeDBLogFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBLogFilesResponseBody(name='body'),
}

/**
 * @summary 查询实例日志
 *
 * @param request DescribeDBLogFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBLogFilesResponse
 */
async function describeDBLogFilesWithOptions(request: DescribeDBLogFilesRequest, runtime: Util.RuntimeOptions): DescribeDBLogFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeId)) {
    query['DBNodeId'] = request.DBNodeId;
  }
  if (!Util.isUnset(request.describeSimulateSwitchMode)) {
    query['DescribeSimulateSwitchMode'] = request.describeSimulateSwitchMode;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.logType)) {
    query['LogType'] = request.logType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.simulateListId)) {
    query['SimulateListId'] = request.simulateListId;
  }
  if (!Util.isUnset(request.simulateModeList)) {
    query['SimulateModeList'] = request.simulateModeList;
  }
  if (!Util.isUnset(request.simulateStatusList)) {
    query['SimulateStatusList'] = request.simulateStatusList;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBLogFiles',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询实例日志
 *
 * @param request DescribeDBLogFilesRequest
 * @return DescribeDBLogFilesResponse
 */
async function describeDBLogFiles(request: DescribeDBLogFilesRequest): DescribeDBLogFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBLogFilesWithOptions(request, runtime);
}

model DescribeDBMiniEngineVersionsRequest {
  architecture?: string(name='Architecture', example='X86'),
  creationCategory?: string(name='CreationCategory', example='Normal'),
  DBMinorVersion?: string(name='DBMinorVersion', example='8.0.1'),
  DBType?: string(name='DBType', description='This parameter is required.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='This parameter is required.', example='5.6'),
  regionId?: string(name='RegionId', description='This parameter is required.', example='cn-hangzhou'),
  zoneId?: string(name='ZoneId', example='cn-hangzhou-g'),
}

model DescribeDBMiniEngineVersionsResponseBody = {
  DBRevisionVersionList?: [ 
    {
      releaseNote?: string(name='ReleaseNote', example='ReleaseNote'),
      releaseType?: string(name='ReleaseType', example='Stable'),
      revisionVersionCode?: string(name='RevisionVersionCode', example='20230707'),
      revisionVersionName?: string(name='RevisionVersionName', example='8.0.1.1.35.1'),
    }
  ](name='DBRevisionVersionList'),
  requestId?: string(name='RequestId', description='Id of the request', example='2921D843-433A-5FB3-A03B-4EC093B219F8'),
}

model DescribeDBMiniEngineVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBMiniEngineVersionsResponseBody(name='body'),
}

/**
 * @summary 查询可用内核小版本列表
 *
 * @param request DescribeDBMiniEngineVersionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBMiniEngineVersionsResponse
 */
async function describeDBMiniEngineVersionsWithOptions(request: DescribeDBMiniEngineVersionsRequest, runtime: Util.RuntimeOptions): DescribeDBMiniEngineVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.architecture)) {
    query['Architecture'] = request.architecture;
  }
  if (!Util.isUnset(request.creationCategory)) {
    query['CreationCategory'] = request.creationCategory;
  }
  if (!Util.isUnset(request.DBMinorVersion)) {
    query['DBMinorVersion'] = request.DBMinorVersion;
  }
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBMiniEngineVersions',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询可用内核小版本列表
 *
 * @param request DescribeDBMiniEngineVersionsRequest
 * @return DescribeDBMiniEngineVersionsResponse
 */
async function describeDBMiniEngineVersions(request: DescribeDBMiniEngineVersionsRequest): DescribeDBMiniEngineVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBMiniEngineVersionsWithOptions(request, runtime);
}

model DescribeDBNodePerformanceRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-****************'),
  DBNodeId?: string(name='DBNodeId', description='The ID of the cluster node.

This parameter is required.', example='pi-*************'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-09-23T01:01Z'),
  interval?: string(name='Interval', description='The interval at which performance data is collected. Valid values:

*   5
*   30
*   60
*   600
*   1800
*   3600
*   86400', example='60'),
  key?: string(name='Key', description='The performance metrics that you want to query. Separate multiple metrics with commas (,). For more information, see [Performance parameters](https://help.aliyun.com/document_detail/141787.html).

>  You can specify a maximum of five performance metrics.

This parameter is required.', example='PolarDBDiskUsage'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-09-23T01:00Z'),
  type?: string(name='Type', description='The special metric. Set the value to tair, which indicates the PolarTair architecture.', example='tair'),
}

model DescribeDBNodePerformanceResponseBody = {
  DBNodeId?: string(name='DBNodeId', description='The ID of the cluster node.', example='pi-*****************'),
  DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='8.0'),
  endTime?: string(name='EndTime', description='The end time of the query. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:01:00Z'),
  performanceKeys?: {
    performanceItem?: [ 
    {
      measurement?: string(name='Measurement', description='The performance metrics that you want to query.', example='PolarDBDiskUsage'),
      metricName?: string(name='MetricName', description='The name of the performance metric.', example='mean_sys_dir_size'),
      points?: {
        performanceItemValue?: [ 
        {
          timestamp?: long(name='Timestamp', description='The timestamp of the metric. This value is a UNIX timestamp. Unit: millisecond.', example='1600822800000'),
          value?: string(name='Value', description='The value of the metric.', example='9.33'),
        }
      ](name='PerformanceItemValue')
      }(name='Points', description='The performance metrics.'),
    }
  ](name='PerformanceItem')
  }(name='PerformanceKeys', description='The cluster performance metrics.'),
  requestId?: string(name='RequestId', description='The request ID.', example='E2FDB684-751D-424D-98B9-704BEA******'),
  startTime?: string(name='StartTime', description='The start time of the query. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:00:00Z'),
}

model DescribeDBNodePerformanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBNodePerformanceResponseBody(name='body'),
}

/**
 * @summary Queries the performance data of a node in a PolarDB cluster.
 *
 * @description *   When the monitoring data is collected every 5 seconds:
 *     *   If the query time range is less than or equal to 1 hour, the data is displayed at intervals of 5 seconds.
 *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
 *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
 *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
 *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
 * *   When the monitoring data is collected every 60 seconds:
 *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
 *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
 *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
 *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
 * >  By default, the monitoring data is collected once every 60 seconds. You can call the [ModifyDBClusterMonitor](https://help.aliyun.com/document_detail/159557.html) operation to set the data collection interval to every 5 seconds.
 *
 * @param request DescribeDBNodePerformanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBNodePerformanceResponse
 */
async function describeDBNodePerformanceWithOptions(request: DescribeDBNodePerformanceRequest, runtime: Util.RuntimeOptions): DescribeDBNodePerformanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeId)) {
    query['DBNodeId'] = request.DBNodeId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBNodePerformance',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the performance data of a node in a PolarDB cluster.
 *
 * @description *   When the monitoring data is collected every 5 seconds:
 *     *   If the query time range is less than or equal to 1 hour, the data is displayed at intervals of 5 seconds.
 *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
 *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
 *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
 *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
 * *   When the monitoring data is collected every 60 seconds:
 *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
 *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
 *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
 *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
 * >  By default, the monitoring data is collected once every 60 seconds. You can call the [ModifyDBClusterMonitor](https://help.aliyun.com/document_detail/159557.html) operation to set the data collection interval to every 5 seconds.
 *
 * @param request DescribeDBNodePerformanceRequest
 * @return DescribeDBNodePerformanceResponse
 */
async function describeDBNodePerformance(request: DescribeDBNodePerformanceRequest): DescribeDBNodePerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBNodePerformanceWithOptions(request, runtime);
}

model DescribeDBNodesParametersRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-****************'),
  DBNodeIds?: string(name='DBNodeIds', description='The node ID. You can specify multiple node IDs. Separate multiple node IDs with commas (,).

This parameter is required.', example='pi-****************,pi-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBNodesParametersResponseBody = {
  DBNodeIds?: [ 
    {
      DBNodeId?: string(name='DBNodeId', description='The ID of the node.', example='pi-bp1r4qe3s534*****'),
      runningParameters?: [ 
        {
          checkingCode?: string(name='CheckingCode', description='The valid values of the parameter.', example='[utf8|latin1|gbk|utf8mb4]'),
          dataType?: string(name='DataType', description='The data type of the parameter value. Valid values:

*   **INT**
*   **STRING**
*   **B**', example='INT'),
          defaultParameterValue?: string(name='DefaultParameterValue', description='The default value of the parameter.', example='utf8'),
          factor?: string(name='Factor', description='A divisor of the parameter. For a parameter of the integer or byte type, the valid values must be a multiple of Factor unless you set Factor to 0.', example='20'),
          forceRestart?: boolean(name='ForceRestart', description='Indicates whether a cluster restart is required to allow the parameter modification to take effect. Valid values:

*   **false**
*   **true**', example='true'),
          isModifiable?: boolean(name='IsModifiable', description='Indicates whether the parameter can be modified. Valid values:

*   **false**
*   **true**', example='true'),
          isNodeAvailable?: string(name='IsNodeAvailable', description='Indicates whether the parameter is a global parameter. Valid values:

*   **0**: yes. The modified parameter value is synchronized to other nodes.
*   **1**: no. You can customize the nodes to which the modified parameter value can be synchronized to.', example='1'),
          paramRelyRule?: string(name='ParamRelyRule', description='The dependencies of the parameter.', example='utf8'),
          parameterDescription?: string(name='ParameterDescription', description='The description of the parameter.', example='The server\\\\"s default character set.'),
          parameterName?: string(name='ParameterName', description='The name of the parameter.', example='character_set_server'),
          parameterStatus?: string(name='ParameterStatus', description='The status of the parameter. Valid values:

*   **normal**
*   **modifying**', example='normal'),
          parameterValue?: string(name='ParameterValue', description='The value of the parameter.', example='utf8'),
        }
      ](name='RunningParameters', description='The parameters of the current node.'),
    }
  ](name='DBNodeIds', description='The IDs of the nodes.'),
  DBType?: string(name='DBType', description='The type of the database engine. Set the value to **MySQL**.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the MySQL database engine. Valid values:

*   **5.6**
*   **5.7**
*   **8.0**', example='5.6'),
  engine?: string(name='Engine', description='The cluster engine.', example='POLARDB'),
  requestId?: string(name='RequestId', description='The request ID.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model DescribeDBNodesParametersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBNodesParametersResponseBody(name='body'),
}

/**
 * @summary Queries the parameters of a specified node in a cluster.
 *
 * @param request DescribeDBNodesParametersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBNodesParametersResponse
 */
async function describeDBNodesParametersWithOptions(request: DescribeDBNodesParametersRequest, runtime: Util.RuntimeOptions): DescribeDBNodesParametersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeIds)) {
    query['DBNodeIds'] = request.DBNodeIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBNodesParameters',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the parameters of a specified node in a cluster.
 *
 * @param request DescribeDBNodesParametersRequest
 * @return DescribeDBNodesParametersResponse
 */
async function describeDBNodesParameters(request: DescribeDBNodesParametersRequest): DescribeDBNodesParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBNodesParametersWithOptions(request, runtime);
}

model DescribeDBProxyPerformanceRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-****************'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.', example='pe-****************'),
  DBNodeId?: string(name='DBNodeId', description='The ID of the node in the cluster. This parameter can be used to query the performance metrics of PolarProxy on different nodes. The following metrics are supported: PolarProxy_DBConns, PolarProxy_DBQps, and PolarProxy_DBActionOps.', example='pi-******************'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-09-24T02:08Z'),
  interval?: string(name='Interval', description='The interval at which performance data is collected. Valid values: 5, 30, 60, 600, 1800, 3600, 86400, in seconds.', example='60'),
  key?: string(name='Key', description='The performance metrics that you want to query. Separate multiple indicators with commas (,). For more information, see [Performance parameters](https://help.aliyun.com/document_detail/141787.html).

This parameter is required.', example='PolarProxy_CpuUsage'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-09-23T01:01Z'),
  type?: string(name='Type', description='Special metric. Set the value to tair, which indicates the PolarTair architecture.', example='tair'),
}

model DescribeDBProxyPerformanceResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-*****************'),
  DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='8.0'),
  endTime?: string(name='EndTime', description='The end time of the query. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:01:00Z'),
  performanceKeys?: {
    performanceItem?: [ 
    {
      DBNodeId?: string(name='DBNodeId', description='The ID of the node.', example='pi-*************'),
      measurement?: string(name='Measurement', description='The performance metric.', example='PolarProxy_CpuUsage'),
      metricName?: string(name='MetricName', description='The name of the performance metric.', example='service_connections_ps'),
      points?: {
        performanceItemValue?: [ 
        {
          timestamp?: long(name='Timestamp', description='The time when the metric value was collected. This value is a timestamp in milliseconds.', example='1600822800000'),
          value?: string(name='Value', description='The value of the metric.', example='10'),
        }
      ](name='PerformanceItemValue')
      }(name='Points', description='The list of the performance metrics.'),
    }
  ](name='PerformanceItem')
  }(name='PerformanceKeys', description='Details about the performance metrics.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='35D3E3DA-4650-407A-BFF5-59BFF1******'),
  startTime?: string(name='StartTime', description='The start time of the query. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:00:00Z'),
}

model DescribeDBProxyPerformanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBProxyPerformanceResponseBody(name='body'),
}

/**
 * @summary Queries the performance data of PolarProxy.
 *
 * @description > This operation is applicable only to PolarDB for MySQL clusters.
 *
 * @param request DescribeDBProxyPerformanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBProxyPerformanceResponse
 */
async function describeDBProxyPerformanceWithOptions(request: DescribeDBProxyPerformanceRequest, runtime: Util.RuntimeOptions): DescribeDBProxyPerformanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.DBNodeId)) {
    query['DBNodeId'] = request.DBNodeId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBProxyPerformance',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the performance data of PolarProxy.
 *
 * @description > This operation is applicable only to PolarDB for MySQL clusters.
 *
 * @param request DescribeDBProxyPerformanceRequest
 * @return DescribeDBProxyPerformanceResponse
 */
async function describeDBProxyPerformance(request: DescribeDBProxyPerformanceRequest): DescribeDBProxyPerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBProxyPerformanceWithOptions(request, runtime);
}

model DescribeDasConfigRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDasConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='593AE1C5-B70C-463F-9207-074639******'),
  storageAutoScale?: string(name='StorageAutoScale', description='Specifies whether to enable automatic storage scaling for the Standard Edition cluster. Valid values:

*   Enable
*   Disable', example='Enable'),
  storageUpperBound?: long(name='StorageUpperBound', description='The maximum storage capacity that is allowed for storage automatic scaling of the Standard Edition cluster. Unit: GB.

>  This parameter is valid only when the StorageAutoScale parameter is set to Enable.', example='800'),
}

model DescribeDasConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDasConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of a cluster in Database Autonomy Service (DAS).
 *
 * @param request DescribeDasConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDasConfigResponse
 */
async function describeDasConfigWithOptions(request: DescribeDasConfigRequest, runtime: Util.RuntimeOptions): DescribeDasConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDasConfig',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the configurations of a cluster in Database Autonomy Service (DAS).
 *
 * @param request DescribeDasConfigRequest
 * @return DescribeDasConfigResponse
 */
async function describeDasConfig(request: DescribeDasConfigRequest): DescribeDasConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDasConfigWithOptions(request, runtime);
}

model DescribeDatabasesRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-**************'),
  DBName?: string(name='DBName', description='The name of the database.

> You cannot specify multiple database names.', example='test_db'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value must be a positive integer that does not exceed the maximum value of the INTEGER data type. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDatabasesResponseBody = {
  databases?: {
    database?: [ 
    {
      accounts?: {
        account?: [ 
        {
          accountName?: string(name='AccountName', description='The username of the account.

> A PolarDB for MySQL cluster does not support privileged accounts.', example='test_acc'),
          accountPrivilege?: string(name='AccountPrivilege', description='The permissions that are granted to the account. Valid values:

*   **ReadWrite**: read and write permissions
*   **ReadOnly**: read-only permissions
*   **DMLOnly**: The account is granted the permissions to execute only DML statements on the database.
*   **DDLOnly**: The account is granted the permissions to execute only DDL statements on the database.
*   **ReadIndex**: The account has the read and index permissions on the database.', example='ReadOnly'),
          accountStatus?: string(name='AccountStatus', description='The state of the account. Valid values:

*   **Creating**
*   **Available**
*   **Deleting**', example='Available'),
          privilegeStatus?: string(name='PrivilegeStatus', description='The authorization state of the account. Valid values:

*   **Empowering**: The system is granting permissions to the account.
*   **Empowered**: Permissions are granted to the account.
*   **Removing**: The system is revoking permissions from the account.', example='Empowered'),
        }
      ](name='Account')
      }(name='Accounts', description='Details about the accounts.

> A PolarDB for MySQL cluster does not support privileged accounts.'),
      characterSetName?: string(name='CharacterSetName', description='The character set that the database uses. For more information, see [Character set tables](https://help.aliyun.com/document_detail/99716.html).', example='utf8mb4'),
      DBDescription?: string(name='DBDescription', description='The description of the database.', example='test_des'),
      DBName?: string(name='DBName', description='The name of the database.', example='test_db'),
      DBStatus?: string(name='DBStatus', description='The state of the database. Valid values:

*   **Creating**
*   **Running**
*   **Deleting**', example='Running'),
      engine?: string(name='Engine', description='The type of the database engine. Valid values:

*   **MySQL**
*   **Oracle**
*   **PostgreSQL**', example='MySQL'),
      masterID?: string(name='MasterID', description='The ID of the primary node in the cluster of Multi-master Cluster (Database/Table) Edition.', example='2'),
    }
  ](name='Database')
  }(name='Databases', description='Details about databases.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of entries per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E1DF8CA6-2300-448B-9ABF-760C4B******'),
}

model DescribeDatabasesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDatabasesResponseBody(name='body'),
}

/**
 * @summary Queries the information about databases in a PolarDB cluster.
 *
 * @param request DescribeDatabasesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDatabasesResponse
 */
async function describeDatabasesWithOptions(request: DescribeDatabasesRequest, runtime: Util.RuntimeOptions): DescribeDatabasesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDatabases',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about databases in a PolarDB cluster.
 *
 * @param request DescribeDatabasesRequest
 * @return DescribeDatabasesResponse
 */
async function describeDatabases(request: DescribeDatabasesRequest): DescribeDatabasesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDatabasesWithOptions(request, runtime);
}

model DescribeDatabasesZonalRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  DBName?: string(name='DBName', example='test_db'),
  maxResults?: int32(name='MaxResults', example='10'),
  nextToken?: string(name='NextToken', example='212db86sca4384811e0b5e8707e******'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDatabasesZonalResponseBody = {
  databases?: [ 
    {
      accounts?: [ 
        {
          accountName?: string(name='AccountName', example='test_acc'),
          accountPrivilege?: string(name='AccountPrivilege', example='ReadOnly'),
          accountStatus?: string(name='AccountStatus', example='Available'),
          privilegeStatus?: string(name='PrivilegeStatus', example='Empowered'),
        }
      ](name='Accounts'),
      characterSetName?: string(name='CharacterSetName', example='utf8mb4'),
      DBDescription?: string(name='DBDescription', example='test_des'),
      DBName?: string(name='DBName', example='test_db'),
      DBStatus?: string(name='DBStatus', example='Running'),
      engine?: string(name='Engine', example='MySQL'),
      masterID?: string(name='MasterID', example='2'),
    }
  ](name='Databases'),
  maxResults?: int32(name='MaxResults', example='10'),
  nextToken?: string(name='NextToken', example='212db86sca4384811e0b5e8707e******'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', example='7'),
  requestId?: string(name='RequestId', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model DescribeDatabasesZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDatabasesZonalResponseBody(name='body'),
}

/**
 * @summary 查询PolarDB边缘云数据库
 *
 * @param request DescribeDatabasesZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDatabasesZonalResponse
 */
async function describeDatabasesZonalWithOptions(request: DescribeDatabasesZonalRequest, runtime: Util.RuntimeOptions): DescribeDatabasesZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDatabasesZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询PolarDB边缘云数据库
 *
 * @param request DescribeDatabasesZonalRequest
 * @return DescribeDatabasesZonalResponse
 */
async function describeDatabasesZonal(request: DescribeDatabasesZonalRequest): DescribeDatabasesZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDatabasesZonalWithOptions(request, runtime);
}

model DescribeDbClusterAttributeZonalRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  describeType?: string(name='DescribeType', example='AI'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDbClusterAttributeZonalResponseBody = {
  aiCreatingTime?: string(name='AiCreatingTime', example='2024-03-13T01:20:28Z'),
  aiType?: string(name='AiType', example='DLNode'),
  architecture?: string(name='Architecture', example='x86'),
  autoUpgradeMinorVersion?: string(name='AutoUpgradeMinorVersion', example='Auto'),
  blktagTotal?: long(name='BlktagTotal', example='7,864,320'),
  blktagUsed?: long(name='BlktagUsed', example='5,242,880'),
  burstingEnabled?: string(name='BurstingEnabled', example='false'),
  category?: string(name='Category', example='Normal'),
  compressStorageMode?: string(name='CompressStorageMode', example='ON'),
  compressStorageUsed?: long(name='CompressStorageUsed', example='15529410560'),
  creationTime?: string(name='CreationTime', example='2020-08-14T05:58:42Z'),
  DBClusterClass?: string(name='DBClusterClass', example='polar.mysql.x8.medium.c'),
  DBClusterDescription?: string(name='DBClusterDescription', example='test'),
  DBClusterId?: string(name='DBClusterId', example='pc-**************'),
  DBClusterNetworkType?: string(name='DBClusterNetworkType', example='VPC'),
  DBClusterStatus?: string(name='DBClusterStatus', example='Running'),
  DBNodes?: [ 
    {
      addedCpuCores?: string(name='AddedCpuCores', example='6'),
      cpuCores?: string(name='CpuCores', example='2'),
      creationTime?: string(name='CreationTime', example='2020-08-14T05:58:42Z'),
      DBNodeClass?: string(name='DBNodeClass', example='polar.mysql.x4.large'),
      DBNodeDescription?: string(name='DBNodeDescription', example='test'),
      DBNodeId?: string(name='DBNodeId', example='pi-****************'),
      DBNodeRole?: string(name='DBNodeRole', example='Reader'),
      DBNodeStatus?: string(name='DBNodeStatus', example='Running'),
      failoverPriority?: int32(name='FailoverPriority', example='1'),
      hotReplicaMode?: string(name='HotReplicaMode', example='ON'),
      imciSwitch?: string(name='ImciSwitch', example='ON'),
      masterId?: string(name='MasterId', example='pi-bp18z52akld3*****'),
      maxConnections?: int32(name='MaxConnections', example='8000'),
      maxIOPS?: int32(name='MaxIOPS', example='32000'),
      memorySize?: string(name='MemorySize', example='8192'),
      mirrorInsName?: string(name='MirrorInsName', example='pi-bp18z52mirror*****'),
      multiMasterLocalStandby?: string(name='MultiMasterLocalStandby', description='MultiMasterLocalStandby', example='MultiMasterLocalStandby'),
      multiMasterPrimaryNode?: string(name='MultiMasterPrimaryNode', description='MultiMasterPrimaryNode', example='MultiMasterPrimaryNode'),
      orca?: string(name='Orca', example='off'),
      remoteMemorySize?: string(name='RemoteMemorySize', example='3072'),
      sccMode?: string(name='SccMode', description='This parameter is required.', example='ON'),
      serverWeight?: string(name='ServerWeight', example='1'),
      serverlessType?: string(name='ServerlessType', example='AgileServerless'),
      subCluster?: string(name='SubCluster', example='Primary'),
      subGroupDescription?: string(name='SubGroupDescription', description='SubGroupDescription', example='SubGroupDescription'),
      zoneId?: string(name='ZoneId', example='cn-hangzhou-d'),
    }
  ](name='DBNodes'),
  DBType?: string(name='DBType', example='MySQL'),
  DBVersion?: string(name='DBVersion', example='8.0'),
  DBVersionStatus?: string(name='DBVersionStatus', example='Stable'),
  dataLevel1BackupChainSize?: long(name='DataLevel1BackupChainSize', example='74448896'),
  dataSyncMode?: string(name='DataSyncMode', example='AsyncSync'),
  deletionLock?: int32(name='DeletionLock', example='0'),
  engine?: string(name='Engine', example='POLARDB'),
  expireTime?: string(name='ExpireTime', example='2020-11-14T16:00:00Z'),
  expired?: string(name='Expired', example='false'),
  hasCompleteStandbyRes?: boolean(name='HasCompleteStandbyRes', example='false'),
  hotStandbyCluster?: string(name='HotStandbyCluster', example='StandbyClusterON'),
  imciAutoIndex?: string(name='ImciAutoIndex', example='OFF'),
  imperceptibleSwitch?: string(name='ImperceptibleSwitch', example='False'),
  inodeTotal?: long(name='InodeTotal', example='6,291,456'),
  inodeUsed?: long(name='InodeUsed', example='4,194,304'),
  isLatestVersion?: boolean(name='IsLatestVersion', example='false'),
  isProxyLatestVersion?: boolean(name='IsProxyLatestVersion', example='false'),
  lockMode?: string(name='LockMode', example='Unlock'),
  maintainTime?: string(name='MaintainTime', example='18:00Z-19:00Z'),
  orca?: string(name='Orca', example='ON'),
  payType?: string(name='PayType', example='Prepaid'),
  provisionedIops?: string(name='ProvisionedIops', example='1000'),
  proxyCpuCores?: string(name='ProxyCpuCores', example='4'),
  proxyServerlessType?: string(name='ProxyServerlessType', example='SteadyServerless'),
  proxyStandardCpuCores?: string(name='ProxyStandardCpuCores', example='2'),
  proxyStatus?: string(name='ProxyStatus', example='Running'),
  proxyType?: string(name='ProxyType', example='Exclusive'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  requestId?: string(name='RequestId', example='074467EF-86B9-4C23-ACBF-E9B81A******'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-************'),
  restoreDataPoint?: string(name='RestoreDataPoint', example='2179639137'),
  restoreType?: string(name='RestoreType', example='RestoreByTime'),
  rowCompression?: string(name='RowCompression', description='RowCompression', example='OFF'),
  SQLSize?: long(name='SQLSize', example='0'),
  serverlessType?: string(name='ServerlessType', example='AgileServerless'),
  sourceDBCluster?: string(name='SourceDBCluster', example='pc-pz51ziv48317b2880'),
  sourceRegionId?: string(name='SourceRegionId', example='cn-beijing'),
  standbyHAMode?: string(name='StandbyHAMode', example='OFF'),
  storageMax?: long(name='StorageMax', example='10995116277760'),
  storagePayType?: string(name='StoragePayType', example='Prepaid'),
  storageSpace?: long(name='StorageSpace', example='50'),
  storageType?: string(name='StorageType', example='ESSDPL0'),
  storageUsed?: long(name='StorageUsed', example='3012558848'),
  strictConsistency?: string(name='StrictConsistency', example='ON'),
  subCategory?: string(name='SubCategory', example='Exclusive'),
  supportInstantSwitchWithImci?: string(name='SupportInstantSwitchWithImci', example='ON'),
  tags?: [ 
    {
      key?: string(name='Key', example='test'),
      value?: string(name='Value', example='MySQL'),
    }
  ](name='Tags'),
  VPCId?: string(name='VPCId', example='vpc-**********'),
  vSwitchId?: string(name='VSwitchId', example='vsw-**********'),
  zoneIds?: string(name='ZoneIds', example='cn-hangzhou-i,cn-hangzhou-g'),
}

model DescribeDbClusterAttributeZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDbClusterAttributeZonalResponseBody(name='body'),
}

/**
 * @summary PolarDB的MyBase集群
 *
 * @param request DescribeDbClusterAttributeZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDbClusterAttributeZonalResponse
 */
async function describeDbClusterAttributeZonalWithOptions(request: DescribeDbClusterAttributeZonalRequest, runtime: Util.RuntimeOptions): DescribeDbClusterAttributeZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.describeType)) {
    query['DescribeType'] = request.describeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDbClusterAttributeZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary PolarDB的MyBase集群
 *
 * @param request DescribeDbClusterAttributeZonalRequest
 * @return DescribeDbClusterAttributeZonalResponse
 */
async function describeDbClusterAttributeZonal(request: DescribeDbClusterAttributeZonalRequest): DescribeDbClusterAttributeZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDbClusterAttributeZonalWithOptions(request, runtime);
}

model DescribeDetachedBackupsRequest {
  backupId?: string(name='BackupId', description='The ID of the backup set.', example='111111111'),
  backupMode?: string(name='BackupMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Manual'),
  backupRegion?: string(name='BackupRegion', description='The region where the cross-region data backup file of the instance is stored.

> This parameter is valid only for PolarDB for MySQL clusters.', example='cn-hangzhou'),
  backupStatus?: string(name='BackupStatus', description='The status of the backup set. Valid values:

*   **Success**
*   **Failed**', example='Success'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-****************'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the `YYYY-MM-DDThh:mmZ` format. The time must be in UTC. The end time must be later than the start time.

This parameter is required.', example='2020-05-14T00:00Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value must be a positive integer that does not exceed the maximum value of the INTEGER data type. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-05-01T00:00Z'),
}

model DescribeDetachedBackupsResponseBody = {
  items?: {
    backup?: [ 
    {
      backupEndTime?: string(name='BackupEndTime', description='The end time of the backup task. The time is displayed in UTC.', example='2020-05-12T03:25:55Z'),
      backupId?: string(name='BackupId', description='The ID of the backup set.', example='111111111'),
      backupMethod?: string(name='BackupMethod', description='The backup method. Only snapshot backups are supported. The value is set to **Snapshot**.', example='Snapshot'),
      backupMode?: string(name='BackupMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Manual'),
      backupSetSize?: string(name='BackupSetSize', description='The size of the backup set. Unit: bytes.

> After you delete the target snapshot backups, the storage space consumed by the backups is released. The released storage space is smaller than the size of the backup file, because the snapshots share certain data blocks.', example='7251056'),
      backupStartTime?: string(name='BackupStartTime', description='The start time of the backup task. The time is displayed in UTC.', example='2020-05-12T03:25:44Z'),
      backupStatus?: string(name='BackupStatus', description='The status of the backup set. Valid values:

*   **Success**
*   **Failed**', example='Success'),
      backupType?: string(name='BackupType', description='The type of the backup. Only full backups are supported. The value is set to **FullBackup**.', example='FullBackup'),
      backupsLevel?: string(name='BackupsLevel', description='The level of the backup set. Valid values:

*   **Level-1**: level-1 backup set
*   **Level-2**: level-2 backup set', example='Level-2'),
      consistentTime?: string(name='ConsistentTime', description='The snapshot checkpoint time. The value is a Unix timestamp.', example='1589253947'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-**************'),
      isAvail?: string(name='IsAvail', description='Indicates whether the backup set is available. Valid values:

*   **0**: The data backup set is unavailable.
*   **1**: The data backup set is available.', example='1'),
      storeStatus?: string(name='StoreStatus', description='Indicates whether the backup set can be deleted. Valid values:

*   **Enabled**: The backup set can be deleted.
*   **Disabled**: The backup set cannot be deleted.', example='Disabled'),
    }
  ](name='Backup')
  }(name='Items', description='Details about the backup sets.'),
  pageNumber?: string(name='PageNumber', description='The page number.', example='1'),
  pageRecordCount?: string(name='PageRecordCount', description='The number of entries per page.', example='15'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='717B2382-BB14-4DCB-BBC2-32DBE0******'),
  totalRecordCount?: string(name='TotalRecordCount', description='The total number of returned entries.', example='50'),
}

model DescribeDetachedBackupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDetachedBackupsResponseBody(name='body'),
}

/**
 * @summary Queries the information about the backup sets in a released PolarDB cluster.
 *
 * @description Before you call this operation, make sure that the PolarDB cluster is in the **Released** state. You must also confirm that the **Retain All Backups Permanently** or **Retain Last Automatic Backup Permanently** backup retention policy takes effect after you release the cluster. If you delete all backup sets after the cluster is released, you cannot use this API operation to query the cluster.
 * >  You can call the [DescribeDBClusterAttribute](https://help.aliyun.com/document_detail/98181.html) operation to query the cluster status.
 *
 * @param request DescribeDetachedBackupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDetachedBackupsResponse
 */
async function describeDetachedBackupsWithOptions(request: DescribeDetachedBackupsRequest, runtime: Util.RuntimeOptions): DescribeDetachedBackupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.backupMode)) {
    query['BackupMode'] = request.backupMode;
  }
  if (!Util.isUnset(request.backupRegion)) {
    query['BackupRegion'] = request.backupRegion;
  }
  if (!Util.isUnset(request.backupStatus)) {
    query['BackupStatus'] = request.backupStatus;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDetachedBackups',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about the backup sets in a released PolarDB cluster.
 *
 * @description Before you call this operation, make sure that the PolarDB cluster is in the **Released** state. You must also confirm that the **Retain All Backups Permanently** or **Retain Last Automatic Backup Permanently** backup retention policy takes effect after you release the cluster. If you delete all backup sets after the cluster is released, you cannot use this API operation to query the cluster.
 * >  You can call the [DescribeDBClusterAttribute](https://help.aliyun.com/document_detail/98181.html) operation to query the cluster status.
 *
 * @param request DescribeDetachedBackupsRequest
 * @return DescribeDetachedBackupsResponse
 */
async function describeDetachedBackups(request: DescribeDetachedBackupsRequest): DescribeDetachedBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDetachedBackupsWithOptions(request, runtime);
}

model DescribeEncryptionDBRolePrivilegeRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-wz9fb5nn44u1d****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  rolePrivilegeNameList?: string(name='RolePrivilegeNameList', example='test'),
}

model DescribeEncryptionDBRolePrivilegeResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-****************'),
  data?: {
    rolePrivilegeList?: [ 
      {
        encryption?: string(name='Encryption', example='[alton01]'),
        negation?: string(name='Negation', example='test'),
        notEncryption?: string(name='NotEncryption', example='[alton]'),
        rolePrivilegeName?: string(name='RolePrivilegeName', example='test'),
      }
    ](name='RolePrivilegeList'),
  }(name='Data'),
  message?: string(name='Message', example='Successful'),
  requestId?: string(name='RequestId', description='Id of the request', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
  success?: boolean(name='Success', example='true'),
}

model DescribeEncryptionDBRolePrivilegeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEncryptionDBRolePrivilegeResponseBody(name='body'),
}

/**
 * @summary 获取角色权限列表
 *
 * @param request DescribeEncryptionDBRolePrivilegeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEncryptionDBRolePrivilegeResponse
 */
async function describeEncryptionDBRolePrivilegeWithOptions(request: DescribeEncryptionDBRolePrivilegeRequest, runtime: Util.RuntimeOptions): DescribeEncryptionDBRolePrivilegeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.rolePrivilegeNameList)) {
    query['RolePrivilegeNameList'] = request.rolePrivilegeNameList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEncryptionDBRolePrivilege',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取角色权限列表
 *
 * @param request DescribeEncryptionDBRolePrivilegeRequest
 * @return DescribeEncryptionDBRolePrivilegeResponse
 */
async function describeEncryptionDBRolePrivilege(request: DescribeEncryptionDBRolePrivilegeRequest): DescribeEncryptionDBRolePrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEncryptionDBRolePrivilegeWithOptions(request, runtime);
}

model DescribeEncryptionDBSecretRequest {
  DBClusterId?: string(name='DBClusterId', example='pc-wz9fb5nn44u1d****'),
}

model DescribeEncryptionDBSecretResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-*************'),
  encryptionDBRegion?: string(name='EncryptionDBRegion', example='Enabled'),
  encryptionDBStatus?: string(name='EncryptionDBStatus', example='cn-beijing'),
  encryptionKey?: string(name='EncryptionKey', example='2a4f4ac2-****-****-****-************'),
  encryptionKeyStatus?: string(name='EncryptionKeyStatus', example='Disabled'),
  requestId?: string(name='RequestId', description='Id of the request', example='944CED46-A6F7-40C6-B6DC-C6E5CC******'),
}

model DescribeEncryptionDBSecretResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEncryptionDBSecretResponseBody(name='body'),
}

/**
 * @summary 获取加密信息
 *
 * @param request DescribeEncryptionDBSecretRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEncryptionDBSecretResponse
 */
async function describeEncryptionDBSecretWithOptions(request: DescribeEncryptionDBSecretRequest, runtime: Util.RuntimeOptions): DescribeEncryptionDBSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEncryptionDBSecret',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取加密信息
 *
 * @param request DescribeEncryptionDBSecretRequest
 * @return DescribeEncryptionDBSecretResponse
 */
async function describeEncryptionDBSecret(request: DescribeEncryptionDBSecretRequest): DescribeEncryptionDBSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEncryptionDBSecretWithOptions(request, runtime);
}

model DescribeExtensionsRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  DBName?: string(name='DBName', description='This parameter is required.', example='song'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeExtensionsResponseBody = {
  installedExtensions?: [ 
    {
      category?: string(name='Category', example='geography_space, self_develop'),
      comment?: string(name='Comment', example='OK'),
      defaultVersion?: string(name='DefaultVersion', example='7.7'),
      installedVersion?: string(name='InstalledVersion', example='7.7'),
      name?: string(name='Name', example='jueming'),
      owner?: string(name='Owner', example='alton'),
      priority?: string(name='Priority', example='1'),
      requires?: string(name='Requires', example='ganos_networking'),
      restart?: string(name='Restart', example='true'),
    }
  ](name='InstalledExtensions'),
  overview?: string(name='Overview'),
  requestId?: string(name='RequestId', description='Id of the request'),
  uninstalledExtensions?: [ 
    {
      category?: string(name='Category', example='geography_space, self_develop'),
      comment?: string(name='Comment', example='OK'),
      defaultVersion?: string(name='DefaultVersion', example='7.7'),
      installedVersion?: string(name='InstalledVersion', example='7.7'),
      name?: string(name='Name', example='jueming'),
      owner?: string(name='Owner', example='alton'),
      priority?: string(name='Priority', example='1'),
      requires?: string(name='Requires', example='ganos_networking'),
      restart?: string(name='Restart', example='true'),
    }
  ](name='UninstalledExtensions'),
}

model DescribeExtensionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeExtensionsResponseBody(name='body'),
}

/**
 * @summary 查询插件详情
 *
 * @param request DescribeExtensionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExtensionsResponse
 */
async function describeExtensionsWithOptions(request: DescribeExtensionsRequest, runtime: Util.RuntimeOptions): DescribeExtensionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExtensions',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询插件详情
 *
 * @param request DescribeExtensionsRequest
 * @return DescribeExtensionsResponse
 */
async function describeExtensions(request: DescribeExtensionsRequest): DescribeExtensionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExtensionsWithOptions(request, runtime);
}

model DescribeFirewallRulesRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-*****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleNameList?: string(name='RuleNameList', example='testrule'),
}

model DescribeFirewallRulesResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-*****************'),
  data?: {
    ruleList?: [ string ](name='RuleList'),
  }(name='Data'),
  message?: string(name='Message', example='Message'),
  requestId?: string(name='RequestId', description='Id of the request', example='84D7DCD2-54F7-5BD2-B055-F5DE9D2B5264'),
  success?: boolean(name='Success', example='true'),
}

model DescribeFirewallRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFirewallRulesResponseBody(name='body'),
}

/**
 * @summary 查询sql防火墙信息
 *
 * @param request DescribeFirewallRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFirewallRulesResponse
 */
async function describeFirewallRulesWithOptions(request: DescribeFirewallRulesRequest, runtime: Util.RuntimeOptions): DescribeFirewallRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleNameList)) {
    query['RuleNameList'] = request.ruleNameList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFirewallRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询sql防火墙信息
 *
 * @param request DescribeFirewallRulesRequest
 * @return DescribeFirewallRulesResponse
 */
async function describeFirewallRules(request: DescribeFirewallRulesRequest): DescribeFirewallRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFirewallRulesWithOptions(request, runtime);
}

model DescribeGlobalDataNetworkListRequest {
  pageNumber?: long(name='PageNumber', example='1'),
  pageSize?: long(name='PageSize', example='30'),
}

model DescribeGlobalDataNetworkListResponseBody = {
  items?: {
    networks?: [ 
      {
        channels?: [ 
          {
            channelId?: string(name='ChannelId', example='gdc-xxx'),
            channelStatus?: string(name='ChannelStatus', example='Syncing'),
            freezeSourceDuringSync?: boolean(name='FreezeSourceDuringSync', example='true'),
            progress?: string(name='Progress', example='11.45%'),
          }
        ](name='Channels'),
        createTime?: string(name='CreateTime', example='2025-03-25T09:37:10Z'),
        networkDescription?: string(name='NetworkDescription', example='mygdn'),
        networkId?: string(name='NetworkId', description='GDN ID', example='gdn-xxx'),
        networkStatus?: string(name='NetworkStatus', example='Running'),
        networkTopology?: {
          destinations?: [ 
            {
              destinationFileSystemPath?: string(name='DestinationFileSystemPath', example='/'),
              destinationId?: string(name='DestinationId', example='pfs-xxx'),
              destinationRegion?: string(name='DestinationRegion', example='cn-beijing'),
              destinationType?: string(name='DestinationType', example='pfs'),
            }
          ](name='Destinations'),
          sources?: [ 
            {
              sourceFileSystemPath?: string(name='SourceFileSystemPath', example='/'),
              sourceId?: string(name='SourceId', example='oss-xxx'),
              sourceRegion?: string(name='SourceRegion', example='cn-wulanchabu'),
              sourceType?: string(name='SourceType', example='oss'),
            }
          ](name='Sources'),
        }(name='NetworkTopology'),
      }
    ](name='Networks'),
  }(name='Items'),
  pageNumber?: string(name='PageNumber', example='1'),
  pageRecordCount?: string(name='PageRecordCount', example='1'),
  requestId?: string(name='RequestId', example='CD35F3-F3-44CA-AFFF-BAF869******'),
  totalRecordCount?: string(name='TotalRecordCount', example='1'),
}

model DescribeGlobalDataNetworkListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGlobalDataNetworkListResponseBody(name='body'),
}

/**
 * @summary DescribeGlobalDataNetworkList
 *
 * @param request DescribeGlobalDataNetworkListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGlobalDataNetworkListResponse
 */
async function describeGlobalDataNetworkListWithOptions(request: DescribeGlobalDataNetworkListRequest, runtime: Util.RuntimeOptions): DescribeGlobalDataNetworkListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGlobalDataNetworkList',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DescribeGlobalDataNetworkList
 *
 * @param request DescribeGlobalDataNetworkListRequest
 * @return DescribeGlobalDataNetworkListResponse
 */
async function describeGlobalDataNetworkList(request: DescribeGlobalDataNetworkListRequest): DescribeGlobalDataNetworkListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGlobalDataNetworkListWithOptions(request, runtime);
}

model DescribeGlobalDatabaseNetworkRequest {
  GDNId?: string(name='GDNId', description='The ID of the GDN.

This parameter is required.', example='gdn-bp1fttxsrmv*****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeGlobalDatabaseNetworkResponseBody = {
  connections?: [ 
    {
      connectionString?: string(name='ConnectionString', description='The endpoint URL of the database service.', example='abc.polardb.rds.aliyuncs.com'),
      netType?: string(name='NetType', description='The network type for the database connection.', example='Private'),
      port?: string(name='Port', description='The port number for the database connection.', example='3306'),
    }
  ](name='Connections', description='The information about the connection to the cluster.'),
  createTime?: string(name='CreateTime', description='The time at which the GDN was created.', example='2020-02-24T11:57:54Z'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-bp1s826a1up******'),
  DBClusters?: [ 
    {
      category?: string(name='Category', description='The edition of the cluster. Valid values:

Normal: Cluster Edition Basic: Single Node Edition Archive: X-Engine Edition NormalMultimaster: Multi-master Cluster Edition SENormal: Standard Edition

> 

*   PolarDB for PostgreSQL clusters that run the PostgreSQL 11 database engine do not support Single Node Edition.

*   PolarDB for MySQL 8.0 and 5.7 clusters, and PolarDB for PostgreSQL clusters that run the PostgreSQL 14 database engine support Standard Edition.

*   PolarDB for MySQL 8.0 clusters support X-Engine Edition and Multi-master Cluster Edition.', example='Normal'),
      DBClusterDescription?: string(name='DBClusterDescription', description='The description of the cluster.', example='test'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-wz9fb5nn44u1d****'),
      DBClusterStatus?: string(name='DBClusterStatus', description='The status of the cluster. For more information, see [Cluster status table](https://help.aliyun.com/document_detail/99286.html).', example='Running'),
      DBNodeClass?: string(name='DBNodeClass', description='The node specifications of the cluster.', example='polar.mysql.x4.large'),
      DBNodes?: [ 
        {
          creationTime?: string(name='CreationTime', description='The time when the node was created.', example='2020-03-23T21:35:43Z'),
          DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node.', example='polar.mysql.x4.large'),
          DBNodeId?: string(name='DBNodeId', description='The node ID.', example='pi-****************'),
          DBNodeRole?: string(name='DBNodeRole', description='The role of the node. Valid values:

*   **Writer**: the primary node
*   **Reader**: a read-only node', example='Reader'),
          DBNodeStatus?: string(name='DBNodeStatus', description='The status of the node. Valid values:

*   **Creating**: The node is being created.
*   **Running**: The node is running.
*   **Deleting**: The node is being deleted.
*   **Rebooting**: The node is restarting.
*   **ClassChanging**: The specifications of the node are being changed.
*   **NetAddressCreating**: The network connection is being created.
*   **NetAddressDeleting**: The network connection is being deleted.
*   **NetAddressModifying**: The network connection is being modified.
*   **MinorVersionUpgrading**: The minor version of the node is being updated.
*   **Maintaining**: The node is being maintained.
*   **Switching**: A failover is being performed.', example='Running'),
          failoverPriority?: int32(name='FailoverPriority', description='The failover priority. Each node is assigned a failover priority. The failover priority determines which node is selected as the primary node when a failover occurs. A larger value indicates a higher priority. Valid values: 1 to 15.', example='1'),
          maxConnections?: int32(name='MaxConnections', description='The maximum number of concurrent connections.', example='8000'),
          maxIOPS?: int32(name='MaxIOPS', description='The maximum input/output operations per second (IOPS).', example='32000'),
          zoneId?: string(name='ZoneId', description='The zone ID of the node.', example='cn-hangzhou-i'),
        }
      ](name='DBNodes', description='The nodes of the cluster.'),
      DBType?: string(name='DBType', description='The database engine type of the cluster. Only MySQL is supported.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine. Only version 8.0 is supported.', example='8.0'),
      expireTime?: string(name='ExpireTime', description='The expiration time of the cluster.

>  A specific value is returned only for subscription (**Prepaid**) clusters. No value is returned for pay-as-you-go (**Postpaid**) clusters.', example='2020-11-14T16:00:00Z'),
      expired?: string(name='Expired', description='Indicates whether the cluster has expired. Valid values:

*   **true** (default)
*   **false**

>  This parameter is returned only for subscription (**Prepaid**) clusters.', example='false'),
      payType?: string(name='PayType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go
*   **Prepaid**: subscription', example='Prepaid'),
      regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
      replicaLag?: string(name='ReplicaLag', description='The cross-region data replication latency between the primary cluster and secondary clusters. Unit: seconds.', example='1'),
      role?: string(name='Role', description='The role of the cluster. Valid values:

*   **Primary**: the primary cluster
*   **standby**: a secondary cluster

>  A GDN consists of one primary cluster and up to four secondary clusters.', example='primary'),
      serverlessType?: string(name='ServerlessType', description='Indicates whether the cluster is a serverless cluster. The value is fixed at AgileServerless.

>  This parameter is returned only for serverless clusters.', example='AgileServerless'),
      storageUsed?: string(name='StorageUsed', description='The storage usage of the cluster. Unit: bytes.', example='3012558848'),
    }
  ](name='DBClusters', description='The clusters in the GDN.'),
  DBType?: string(name='DBType', description='The type of the database engine. Only MySQL is supported.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine. Only version 8.0 is supported.', example='8.0'),
  GDNDescription?: string(name='GDNDescription', description='The description of the GDN. The description must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must start with a letter.
*   It can contain letters, digits, underscores (_), and hyphens (-).
*   It must be 2 to 126 characters in length.', example='GDN-fortest'),
  GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gdn-bp1fttxsrmv*****'),
  GDNStatus?: string(name='GDNStatus', description='The status of the GDN. Valid values:

*   **Creating**: The GDN is being created.
*   **active**: The GDN is running.
*   **deleting**: The GDN is being deleted.
*   **locked**: The GDN is locked. If the GDN is locked, you cannot perform operations on clusters in the GDN.
*   **removing_member**: The secondary cluster is being removed from the GDN.', example='active'),
  globalDomainName?: string(name='GlobalDomainName', description='The global domain name.', example='[gdnid].gdn.rds.aliyuncs.com'),
  labels?: {
    GDNVersion?: string(name='GDNVersion'),
  }(name='Labels'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='67F2E75F-AE67-4FB2-821F-A81237EACD15'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
}

model DescribeGlobalDatabaseNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGlobalDatabaseNetworkResponseBody(name='body'),
}

/**
 * @summary Queries the information about a Global Database Network (GDN).
 *
 * @param request DescribeGlobalDatabaseNetworkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGlobalDatabaseNetworkResponse
 */
async function describeGlobalDatabaseNetworkWithOptions(request: DescribeGlobalDatabaseNetworkRequest, runtime: Util.RuntimeOptions): DescribeGlobalDatabaseNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.GDNId)) {
    query['GDNId'] = request.GDNId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGlobalDatabaseNetwork',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about a Global Database Network (GDN).
 *
 * @param request DescribeGlobalDatabaseNetworkRequest
 * @return DescribeGlobalDatabaseNetworkResponse
 */
async function describeGlobalDatabaseNetwork(request: DescribeGlobalDatabaseNetworkRequest): DescribeGlobalDatabaseNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGlobalDatabaseNetworkWithOptions(request, runtime);
}

model DescribeGlobalDatabaseNetworksRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.', example='pc-**************'),
  filterRegion?: string(name='FilterRegion', description='Specify the region in which you want to query GDNs. You can create secondary clusters for the GDNs.', example='cn-beijing'),
  GDNDescription?: string(name='GDNDescription', description='The description of the GDN. The description must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must start with a letter.
*   It can contain letters, digits, underscores (_), and hyphens (-).
*   It must be 2 to 126 characters in length.', example='test'),
  GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gdn-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Default value: 1. The value must be an integer that is greater than 0.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 30. Valid values:

*   30
*   50
*   100', example='30'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeGlobalDatabaseNetworksResponseBody = {
  items?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the GDN was created. The time is in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.', example='2020-03-23T05:46:54Z'),
      DBClusters?: [ 
        {
          DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-****************'),
          regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
          role?: string(name='Role', description='The role of the cluster. Valid values:

*   **Primary**: the primary cluster
*   **standby**: the secondary cluster

> A GDN consists of one primary cluster and up to four secondary clusters. For more information, see [GDN](https://help.aliyun.com/document_detail/160381.html).', example='primary'),
        }
      ](name='DBClusters', description='Details about clusters in the GDN.'),
      DBType?: string(name='DBType', description='The type of the database engine. Only **MySQL** is supported.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine. Only the **8.0** version is supported.', example='8.0'),
      GDNDescription?: string(name='GDNDescription', description='The description of the GDN. The description must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must start with a letter.
*   It can contain letters, digits, underscores (_), and hyphens (-).
*   It must be 2 to 126 characters in length.', example='test'),
      GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gdn-****************'),
      GDNStatus?: string(name='GDNStatus', description='The status of the GDN. Valid values:

*   **Creating**: The GDN is being created.
*   **active**: The GDN is running.
*   **deleting**: The GDN is being deleted.
*   **locked**: The GDN is locked. If the GDN is locked, you cannot perform operations on clusters in the GDN.
*   **removing_member**: The secondary cluster is being removed from the GDN.', example='active'),
      labels?: {
        GDNVersion?: string(name='GDNVersion'),
      }(name='Labels'),
    }
  ](name='Items', description='Details about the GDNs.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of records on the current page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='69A85BAF-1089-4CDF-A82F-0A140F******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of returned entries.', example='1'),
}

model DescribeGlobalDatabaseNetworksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGlobalDatabaseNetworksResponseBody(name='body'),
}

/**
 * @summary Queries the information about all Global Database Networks (GDNs) that belong to an account.
 *
 * @param request DescribeGlobalDatabaseNetworksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGlobalDatabaseNetworksResponse
 */
async function describeGlobalDatabaseNetworksWithOptions(request: DescribeGlobalDatabaseNetworksRequest, runtime: Util.RuntimeOptions): DescribeGlobalDatabaseNetworksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.filterRegion)) {
    query['FilterRegion'] = request.filterRegion;
  }
  if (!Util.isUnset(request.GDNDescription)) {
    query['GDNDescription'] = request.GDNDescription;
  }
  if (!Util.isUnset(request.GDNId)) {
    query['GDNId'] = request.GDNId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGlobalDatabaseNetworks',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about all Global Database Networks (GDNs) that belong to an account.
 *
 * @param request DescribeGlobalDatabaseNetworksRequest
 * @return DescribeGlobalDatabaseNetworksResponse
 */
async function describeGlobalDatabaseNetworks(request: DescribeGlobalDatabaseNetworksRequest): DescribeGlobalDatabaseNetworksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGlobalDatabaseNetworksWithOptions(request, runtime);
}

model DescribeGlobalSecurityIPGroupRequest {
  globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the IP whitelist template.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeGlobalSecurityIPGroupResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      DBInstances?: [ string ](name='DBInstances', description='The details of the clusters that are associated with the global IP address whitelist template.'),
      GIpList?: string(name='GIpList', description='The IP address in the global IP whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the global IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the global IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroup', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model DescribeGlobalSecurityIPGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGlobalSecurityIPGroupResponseBody(name='body'),
}

/**
 * @summary Queries global IP whitelist templates.
 *
 * @param request DescribeGlobalSecurityIPGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGlobalSecurityIPGroupResponse
 */
async function describeGlobalSecurityIPGroupWithOptions(request: DescribeGlobalSecurityIPGroupRequest, runtime: Util.RuntimeOptions): DescribeGlobalSecurityIPGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalSecurityGroupId)) {
    query['GlobalSecurityGroupId'] = request.globalSecurityGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGlobalSecurityIPGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries global IP whitelist templates.
 *
 * @param request DescribeGlobalSecurityIPGroupRequest
 * @return DescribeGlobalSecurityIPGroupResponse
 */
async function describeGlobalSecurityIPGroup(request: DescribeGlobalSecurityIPGroupRequest): DescribeGlobalSecurityIPGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGlobalSecurityIPGroupWithOptions(request, runtime);
}

model DescribeGlobalSecurityIPGroupRelationRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-*****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the IP whitelist template.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeGlobalSecurityIPGroupRelationResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-*****************'),
  globalSecurityIPGroupRel?: [ 
    {
      GIpList?: string(name='GIpList', description='The IP address in the global IP whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the global IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the global IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroupRel', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model DescribeGlobalSecurityIPGroupRelationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGlobalSecurityIPGroupRelationResponseBody(name='body'),
}

/**
 * @summary Queries the relationship between a cluster and a global IP whitelist template.
 *
 * @param request DescribeGlobalSecurityIPGroupRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGlobalSecurityIPGroupRelationResponse
 */
async function describeGlobalSecurityIPGroupRelationWithOptions(request: DescribeGlobalSecurityIPGroupRelationRequest, runtime: Util.RuntimeOptions): DescribeGlobalSecurityIPGroupRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGlobalSecurityIPGroupRelation',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the relationship between a cluster and a global IP whitelist template.
 *
 * @param request DescribeGlobalSecurityIPGroupRelationRequest
 * @return DescribeGlobalSecurityIPGroupRelationResponse
 */
async function describeGlobalSecurityIPGroupRelation(request: DescribeGlobalSecurityIPGroupRelationRequest): DescribeGlobalSecurityIPGroupRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGlobalSecurityIPGroupRelationWithOptions(request, runtime);
}

model DescribeHALogsRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-****************'),
  DBNodeId?: string(name='DBNodeId', description='The node ID.

>  Queries the HA failover records of the Node `DBNodeId` . You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as node IDs.', example='pi-****************'),
  endTime?: string(name='EndTime', example='2020-09-23T01:01:00Z'),
  logType?: string(name='LogType', description='The log type.

This parameter is required.', example='HaSwitchLogList'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  startTime?: string(name='StartTime', example='2020-05-01T00:00Z'),
}

model DescribeHALogsResponseBody = {
  DBInstanceName?: string(name='DBInstanceName', example='pc-a*************'),
  DBInstanceType?: string(name='DBInstanceType', example='polardb_mysql_rw'),
  haLogItems?: [ 
    {
      switchCauseCode?: string(name='SwitchCauseCode', description='The reason code of the failover.', example='Platform.Ha.AuroraService.ManualOperations'),
      switchCauseDetail?: string(name='SwitchCauseDetail', description='The reason of the failover.', example='Platform.Ha.ManuallyTriggered'),
      switchFinishTime?: string(name='SwitchFinishTime', description='The time when the failover ended.', example='2025-05-20T03:09:56Z'),
      switchId?: string(name='SwitchId', example='e571f897-9b3c-4012-9470-88333832dec4'),
      switchStartTime?: string(name='SwitchStartTime', description='The time when the failover started.', example='2025-05-20T03:09:45Z'),
    }
  ](name='HaLogItems', description='The failover logs.'),
  haStatus?: int32(name='HaStatus', example='1'),
  itemsNumbers?: int32(name='ItemsNumbers', example='10'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  requestId?: string(name='RequestId', example='6BD9CDE4-5E7B-4BF3-9BB8-83C73E******'),
  totalRecords?: int32(name='TotalRecords', example='160'),
}

model DescribeHALogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHALogsResponseBody(name='body'),
}

/**
 * @summary 查询实例高可用相关日志
 *
 * @param request DescribeHALogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHALogsResponse
 */
async function describeHALogsWithOptions(request: DescribeHALogsRequest, runtime: Util.RuntimeOptions): DescribeHALogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeId)) {
    query['DBNodeId'] = request.DBNodeId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.logType)) {
    query['LogType'] = request.logType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHALogs',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询实例高可用相关日志
 *
 * @param request DescribeHALogsRequest
 * @return DescribeHALogsResponse
 */
async function describeHALogs(request: DescribeHALogsRequest): DescribeHALogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHALogsWithOptions(request, runtime);
}

model DescribeHistoryTasksRequest {
  fromExecTime?: int32(name='FromExecTime', example='0'),
  fromStartTime?: string(name='FromStartTime', description='This parameter is required.', example='2025-01-02T11:31:03Z'),
  instanceId?: string(name='InstanceId', example='pc-2zed3m89cw***'),
  instanceType?: string(name='InstanceType', example='Instance'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
  regionId?: string(name='RegionId', example='cn-beijing'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-************'),
  resourceOwnerAccount?: long(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  status?: string(name='Status', example='Running'),
  taskId?: string(name='TaskId', example='t-0mqi38ho0cgjv***'),
  taskType?: string(name='TaskType', example='ChangeVariable'),
  toExecTime?: int32(name='ToExecTime', example='0'),
  toStartTime?: string(name='ToStartTime', description='This parameter is required.', example='2025-01-03T11:31:03Z'),
}

model DescribeHistoryTasksResponseBody = {
  items?: [ 
    {
      actionInfo?: string(name='ActionInfo', example='{}'),
      callerSource?: string(name='CallerSource', example='User'),
      callerUid?: string(name='CallerUid', example='1816563541899***'),
      currentStepName?: string(name='CurrentStepName', example='finish_task'),
      dbType?: string(name='DbType', example='polardb_mysql'),
      endTime?: string(name='EndTime', example='2025-03-03T07:30:57Z'),
      instanceId?: string(name='InstanceId', example='pc-2zed3m89cw***'),
      instanceName?: string(name='InstanceName', example='pc-2zed3m89cw***'),
      instanceType?: string(name='InstanceType', example='Instance'),
      product?: string(name='Product', example='polardb'),
      progress?: float(name='Progress', example='100.0'),
      reasonCode?: string(name='ReasonCode', example='""'),
      regionId?: string(name='RegionId', example='cn-beijing'),
      remainTime?: int32(name='RemainTime', example='0'),
      startTime?: string(name='StartTime', example='2025-03-03T07:25:16Z'),
      status?: string(name='Status', example='Succeed'),
      taskDetail?: string(name='TaskDetail', example='{\\\\"steps\\\\":[{\\\\"step_name\\\\":\\\\"init_task\\\\"},{\\\\"step_name\\\\":\\\\"exec_task\\\\"},{\\\\"step_name\\\\":\\\\"finish_task\\\\"}]}'),
      taskId?: string(name='TaskId', example='t-0mqt8qhnw04ipz0***'),
      taskType?: string(name='TaskType', example='ChangeVariable'),
      uid?: string(name='Uid', example='1816563541899***'),
    }
  ](name='Items'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
  requestId?: string(name='RequestId', example='F90D7C14-2D1C-5B88-9CD1-23AB2CF89***'),
  totalCount?: string(name='TotalCount', example='2'),
}

model DescribeHistoryTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHistoryTasksResponseBody(name='body'),
}

/**
 * @summary 任务中心任务列表
 *
 * @param request DescribeHistoryTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHistoryTasksResponse
 */
async function describeHistoryTasksWithOptions(request: DescribeHistoryTasksRequest, runtime: Util.RuntimeOptions): DescribeHistoryTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fromExecTime)) {
    query['FromExecTime'] = request.fromExecTime;
  }
  if (!Util.isUnset(request.fromStartTime)) {
    query['FromStartTime'] = request.fromStartTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  if (!Util.isUnset(request.toExecTime)) {
    query['ToExecTime'] = request.toExecTime;
  }
  if (!Util.isUnset(request.toStartTime)) {
    query['ToStartTime'] = request.toStartTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHistoryTasks',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 任务中心任务列表
 *
 * @param request DescribeHistoryTasksRequest
 * @return DescribeHistoryTasksResponse
 */
async function describeHistoryTasks(request: DescribeHistoryTasksRequest): DescribeHistoryTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHistoryTasksWithOptions(request, runtime);
}

model DescribeHistoryTasksStatRequest {
  fromExecTime?: int32(name='FromExecTime', example='0'),
  fromStartTime?: string(name='FromStartTime', description='This parameter is required.', example='2025-01-02T11:31:03Z'),
  instanceId?: string(name='InstanceId', example='pc-2zed3m89cw***'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='This parameter is required.', example='cn-beijing'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-************'),
  resourceOwnerAccount?: long(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  status?: string(name='Status', example='Running'),
  taskId?: string(name='TaskId', example='ec8c4723-eac5-4f12-becb-01ac08******'),
  taskType?: string(name='TaskType', example='DatabaseProxyUpgrading'),
  toExecTime?: int32(name='ToExecTime', example='10'),
  toStartTime?: string(name='ToStartTime', description='This parameter is required.', example='2025-01-03T12:31:03Z'),
}

model DescribeHistoryTasksStatResponseBody = {
  items?: [ 
    {
      status?: string(name='Status', example='Running'),
      totalCount?: int32(name='TotalCount', example='13'),
    }
  ](name='Items'),
  requestId?: string(name='RequestId', description='Id of the request', example='45D24263-7E3A-4140-9472-************'),
}

model DescribeHistoryTasksStatResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHistoryTasksStatResponseBody(name='body'),
}

/**
 * @summary 任务中心任务统计
 *
 * @param request DescribeHistoryTasksStatRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHistoryTasksStatResponse
 */
async function describeHistoryTasksStatWithOptions(request: DescribeHistoryTasksStatRequest, runtime: Util.RuntimeOptions): DescribeHistoryTasksStatResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fromExecTime)) {
    query['FromExecTime'] = request.fromExecTime;
  }
  if (!Util.isUnset(request.fromStartTime)) {
    query['FromStartTime'] = request.fromStartTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  if (!Util.isUnset(request.toExecTime)) {
    query['ToExecTime'] = request.toExecTime;
  }
  if (!Util.isUnset(request.toStartTime)) {
    query['ToStartTime'] = request.toStartTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHistoryTasksStat',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 任务中心任务统计
 *
 * @param request DescribeHistoryTasksStatRequest
 * @return DescribeHistoryTasksStatResponse
 */
async function describeHistoryTasksStat(request: DescribeHistoryTasksStatRequest): DescribeHistoryTasksStatResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHistoryTasksStatWithOptions(request, runtime);
}

model DescribeLicenseOrderDetailsRequest {
  aliyunOrderId?: string(name='AliyunOrderId', description='The Alibaba Cloud order ID (or virtual order ID).

This parameter is required.', example='239618016570503'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeLicenseOrderDetailsResponseBody = {
  activatedCodeCount?: int32(name='ActivatedCodeCount', description='The number of generated activation codes.', example='2'),
  activationCodeQuota?: int32(name='ActivationCodeQuota', description='The maximum number of activation codes that you can apply for.', example='8'),
  aliyunOrderId?: string(name='AliyunOrderId', description='The Alibaba Cloud order ID (including the virtual order ID).', example='239618016570503'),
  allowEmptySystemIdentifier?: boolean(name='AllowEmptySystemIdentifier', description='Indicates whether activation codes can be generated without the system identifier.', example='false'),
  engine?: string(name='Engine', description='The type of the engine. Valid values: PG, Oracle, and MySQL.', example='PG'),
  gmtCreated?: string(name='GmtCreated', description='The time when the order was created.', example='2021-10-19 01:13:45'),
  gmtModified?: string(name='GmtModified', description='The time when the order was last updated.', example='2024-10-16 16:46:20'),
  isVirtualOrder?: boolean(name='IsVirtualOrder', description='Indicates whether the order is a virtual order (virtual orders allow pre-generation of activation codes).', example='false'),
  isVirtualOrderFrozen?: boolean(name='IsVirtualOrderFrozen', description='Indicates whether the virtual order is frozen (activation codes cannot be generated for a frozen virtual order).', example='false'),
  packageType?: string(name='PackageType', description='The plan type. Valid values:

*   single_node_subscribe
*   single_node_long_term
*   primary_backup_subscribe
*   primary_backup_long_term
*   pre_generation_long_term', example='pre_generation_long_term'),
  packageValidity?: string(name='PackageValidity', description='The validity period of the plan, which is one year (common) or thirty years (long-term).', example='1 year'),
  purchaseChannel?: string(name='PurchaseChannel', description='The plan validity period, one year (common) or thirty years (long-term).', example='aliyun_market'),
  requestId?: string(name='RequestId', description='The request ID.', example='22C0ACF0-DD29-4B67-9190-B7A48C******'),
  virtualOrderId?: string(name='VirtualOrderId', description='The virtual order ID.', example='239618016570503'),
}

model DescribeLicenseOrderDetailsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLicenseOrderDetailsResponseBody(name='body'),
}

/**
 * @summary Queries the information of a license order.
 *
 * @param request DescribeLicenseOrderDetailsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLicenseOrderDetailsResponse
 */
async function describeLicenseOrderDetailsWithOptions(request: DescribeLicenseOrderDetailsRequest, runtime: Util.RuntimeOptions): DescribeLicenseOrderDetailsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunOrderId)) {
    query['AliyunOrderId'] = request.aliyunOrderId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLicenseOrderDetails',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information of a license order.
 *
 * @param request DescribeLicenseOrderDetailsRequest
 * @return DescribeLicenseOrderDetailsResponse
 */
async function describeLicenseOrderDetails(request: DescribeLicenseOrderDetailsRequest): DescribeLicenseOrderDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLicenseOrderDetailsWithOptions(request, runtime);
}

model DescribeLicenseOrdersRequest {
  aliyunOrderId?: string(name='AliyunOrderId', description='The ID of the Alibaba Cloud order. The value can be the ID of a virtual order.', example='239618016570503'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  packageType?: string(name='PackageType', description='The plan type. Valid values:

*   single_node_subscribe: Single-node Edition (Subscription).
*   single_node_long_term: Single-node Edition (Long-term).
*   primary_backup_subscribe: HA Edition (Subscription).
*   primary_backup_long_term: HA Edition (Long-term).
*   pre_generation_long_term: Pre-generated (Long-term).', example='single_node_subscribe'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30'),
  purchaseChannel?: string(name='PurchaseChannel', description='The purchase channel. Valid values: aliyun_market and aliyun_public. aliyun_market specifies Alibaba Cloud Marketplace. aliyun_public specifies the PolarDB buy page.', example='aliyun_market'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  virtualOrder?: boolean(name='VirtualOrder', description='Specifies whether to query only virtual orders.', example='true'),
}

model DescribeLicenseOrdersResponseBody = {
  items?: [ 
    {
      activatedCodeCount?: int32(name='ActivatedCodeCount', description='The number of generated activation codes.', example='10'),
      activationCodeQuota?: int32(name='ActivationCodeQuota', description='The maximum number of activation codes that you can apply for.', example='10'),
      aliyunOrderId?: string(name='AliyunOrderId', description='The ID of the Alibaba Cloud order. The ID of a virtual order may be returned.', example='227638319690519'),
      allowEmptySystemIdentifier?: boolean(name='AllowEmptySystemIdentifier', description='Indicates whether the SystemIdentifier parameter can be left empty when the system generates an activation code.', example='false'),
      engine?: string(name='Engine', description='The engine of the PolarDB cluster. Valid values: PG, Oracle, and MySQL.', example='PG'),
      gmtCreated?: string(name='GmtCreated', description='The time when the order was created.', example='2022-02-11 03:14:15'),
      gmtModified?: string(name='GmtModified', description='The time when the order was updated.', example='2022-02-11 03:14:15'),
      isVirtualOrder?: boolean(name='IsVirtualOrder', description='Indicates whether the order is a virtual order. Pre-generation of activation codes is allowed for virtual orders.', example='false'),
      isVirtualOrderFrozen?: boolean(name='IsVirtualOrderFrozen', description='Indicates whether the virtual order is frozen. Generation of activation codes is not allowed for frozen virtual orders.', example='false'),
      packageType?: string(name='PackageType', description='The type of the package. Valid values:

*   single_node_subscribe: Single-node Edition (Subscription).
*   single_node_long_term: Single-node Edition (Long-term).
*   primary_backup_subscribe: HA Edition (Subscription).
*   primary_backup_long_term: HA Edition (Long-term).
*   pre_generation_long_term: Pre-generated (Long-term).', example='single_node_subscribe'),
      packageValidity?: string(name='PackageValidity', description='The validity period of the package. Valid values: 1 year and 30 years.', example='1 year'),
      purchaseChannel?: string(name='PurchaseChannel', description='The purchase channel. Valid values: aliyun_market and aliyun_public. aliyun_market indicates Alibaba Cloud Marketplace. aliyun_public indicates the PolarDB buy page.', example='aliyun_public'),
      virtualAliyunOrderId?: string(name='VirtualAliyunOrderId', description='The ID of the virtual order.', example='227638319690519'),
    }
  ](name='Items', description='The queried orders.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of entries returned on the current page.', example='12'),
  requestId?: string(name='RequestId', description='The request ID.', example='34458CD3-33E0-4624-BFEF-840C15******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of entries returned.', example='50'),
}

model DescribeLicenseOrdersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLicenseOrdersResponseBody(name='body'),
}

/**
 * @summary Queries a list of license orders.
 *
 * @param request DescribeLicenseOrdersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLicenseOrdersResponse
 */
async function describeLicenseOrdersWithOptions(request: DescribeLicenseOrdersRequest, runtime: Util.RuntimeOptions): DescribeLicenseOrdersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunOrderId)) {
    query['AliyunOrderId'] = request.aliyunOrderId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.packageType)) {
    query['PackageType'] = request.packageType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.purchaseChannel)) {
    query['PurchaseChannel'] = request.purchaseChannel;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.virtualOrder)) {
    query['VirtualOrder'] = request.virtualOrder;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLicenseOrders',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of license orders.
 *
 * @param request DescribeLicenseOrdersRequest
 * @return DescribeLicenseOrdersResponse
 */
async function describeLicenseOrders(request: DescribeLicenseOrdersRequest): DescribeLicenseOrdersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLicenseOrdersWithOptions(request, runtime);
}

model DescribeLocalAvailableRecoveryTimeRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-2ze3ngi149b313***'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeLocalAvailableRecoveryTimeResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-2ze3ngi149b313***'),
  recoveryBeginTime?: string(name='RecoveryBeginTime', example='2025-09-10T14:19:48Z'),
  recoveryEndTime?: string(name='RecoveryEndTime', example='2025-09-17T08:56:45Z'),
  requestId?: string(name='RequestId', example='4EA0E6F8-BDB2-17B2-9567-591F6B3D7***'),
}

model DescribeLocalAvailableRecoveryTimeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLocalAvailableRecoveryTimeResponseBody(name='body'),
}

/**
 * @summary 查询库表恢复可恢复时间范围
 *
 * @param request DescribeLocalAvailableRecoveryTimeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLocalAvailableRecoveryTimeResponse
 */
async function describeLocalAvailableRecoveryTimeWithOptions(request: DescribeLocalAvailableRecoveryTimeRequest, runtime: Util.RuntimeOptions): DescribeLocalAvailableRecoveryTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLocalAvailableRecoveryTime',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询库表恢复可恢复时间范围
 *
 * @param request DescribeLocalAvailableRecoveryTimeRequest
 * @return DescribeLocalAvailableRecoveryTimeResponse
 */
async function describeLocalAvailableRecoveryTime(request: DescribeLocalAvailableRecoveryTimeRequest): DescribeLocalAvailableRecoveryTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLocalAvailableRecoveryTimeWithOptions(request, runtime);
}

model DescribeLogBackupPolicyRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query all the information about the available clusters in the target region, including the cluster ID.

This parameter is required.', example='pc-*****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeLogBackupPolicyResponseBody = {
  advancedLogPolicies?: {
    advancedLogPolicy?: [ 
    {
      destRegion?: string(name='DestRegion'),
      destType?: string(name='DestType'),
      enableLogBackup?: int32(name='EnableLogBackup'),
      logRetentionType?: string(name='LogRetentionType'),
      logRetentionValue?: string(name='LogRetentionValue'),
      policyId?: string(name='PolicyId'),
      srcRegion?: string(name='SrcRegion'),
      srcType?: string(name='SrcType'),
    }
  ](name='AdvancedLogPolicy')
  }(name='AdvancedLogPolicies'),
  enableBackupLog?: int32(name='EnableBackupLog', description='Indicates whether the log backup feature is enabled. Valid values:

*   0: The log backup feature is disabled.
*   1: The log backup feature is enabled. By default, the log backup feature is enabled and cannot be disabled.', example='1'),
  logBackupAnotherRegionRegion?: string(name='LogBackupAnotherRegionRegion', description='The region in which you want to store cross-region log backups. For more information about regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='cn-beijing'),
  logBackupAnotherRegionRetentionPeriod?: string(name='LogBackupAnotherRegionRetentionPeriod', description='The retention period of cross-region log backups. Valid values:

*   **0**: The cross-region backup feature is disabled.
*   **30 to 7300**: Cross-region log backups are retained for 30 to 7,300 days.
*   **-1**: The log backups are permanently retained.

>  When you create a cluster, the default value of this parameter is **0**.', example='0'),
  logBackupRetentionPeriod?: int32(name='LogBackupRetentionPeriod', description='The retention period of the log backups. Valid values:

*   3 to 7300: The log backups are retained for 3 to 7,300 days.
*   \\\\-1: The log backups are permanently retained.', example='7'),
  requestId?: string(name='RequestId', description='The request ID.', example='62EE0051-102B-488D-9C79-D607B8******'),
}

model DescribeLogBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLogBackupPolicyResponseBody(name='body'),
}

/**
 * @summary Queries the retention policy of log backups in a PolarDB cluster.
 *
 * @param request DescribeLogBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLogBackupPolicyResponse
 */
async function describeLogBackupPolicyWithOptions(request: DescribeLogBackupPolicyRequest, runtime: Util.RuntimeOptions): DescribeLogBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLogBackupPolicy',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the retention policy of log backups in a PolarDB cluster.
 *
 * @param request DescribeLogBackupPolicyRequest
 * @return DescribeLogBackupPolicyResponse
 */
async function describeLogBackupPolicy(request: DescribeLogBackupPolicyRequest): DescribeLogBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogBackupPolicyWithOptions(request, runtime);
}

model DescribeMaskingRulesRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pc-*****************'),
  interfaceVersion?: string(name='InterfaceVersion', description='Queries data masking rules or encryption rules. Valid values:

v1: queries data masking rules. v2: queries data encryption rules.', example='v1'),
  ruleNameList?: string(name='RuleNameList', description='The name of the masking rule.', example='testrule'),
}

model DescribeMaskingRulesResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-bp1s826a1up******'),
  data?: {
    ruleList?: [ string ](name='RuleList', description='Details about the masking rules.'),
    ruleVersion?: string(name='RuleVersion', description='The version of the masking rule. Valid values: v1 and v2. Default value: v1', example='v1'),
  }(name='Data', description='The result data that is returned.'),
  message?: string(name='Message', description='The message that is returned for the request.

> If the request is successful, Successful is returned. If the request fails, an error message such as an error code is returned.', example='Successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2F83D131-1C18-4599-889D-729A9D******'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid value:

*   **true**
*   **false**', example='true'),
}

model DescribeMaskingRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMaskingRulesResponseBody(name='body'),
}

/**
 * @summary Queries the data masking rules of a PolarDB cluster or the information about a specified masking rule.
 *
 * @param request DescribeMaskingRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMaskingRulesResponse
 */
async function describeMaskingRulesWithOptions(request: DescribeMaskingRulesRequest, runtime: Util.RuntimeOptions): DescribeMaskingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.interfaceVersion)) {
    query['InterfaceVersion'] = request.interfaceVersion;
  }
  if (!Util.isUnset(request.ruleNameList)) {
    query['RuleNameList'] = request.ruleNameList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMaskingRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the data masking rules of a PolarDB cluster or the information about a specified masking rule.
 *
 * @param request DescribeMaskingRulesRequest
 * @return DescribeMaskingRulesResponse
 */
async function describeMaskingRules(request: DescribeMaskingRulesRequest): DescribeMaskingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMaskingRulesWithOptions(request, runtime);
}

model DescribeMetaListRequest {
  backupId?: string(name='BackupId', description='The ID of the data backup file.

>*   When you run a query, you must specify the `BackId` or `RestoreTime` parameter.
>*   You can call the [DescribeBackups](https://help.aliyun.com/document_detail/98102.html) operation to query the ID of the backup set.', example='111111'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of all clusters under your account.

This parameter is required.', example='pc-**************'),
  getDbName?: string(name='GetDbName', description='Specify the specific database name (such as `test_db`) to query the names of all data tables that can be restored in the desired database.

>*   You can specify only one database name each time.
>*   If you do not specify this parameter, you can query the names of all databases that can be restored in the current backup set. However, you cannot query the names of data tables in each database.', example='test_db'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. The value must be an integer that is greater than 0. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values:

*   **30**

*   **50**

*   **100**

    Default value: **30**.', example='30'),
  regionCode?: string(name='RegionCode', description='The ID of the region in which the instance resides. You can call the [DescribeDBClusterAttribute](https://help.aliyun.com/document_detail/2319132.html) operation to query the region ID of the instance.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime', description='The point in time for the restoration. Specify the time in the YYYY-MM-DDThh:mmZ format. The time must be in UTC.

>  When you run a query, you must specify the `BackId` or `RestoreTime` parameter. You can call the [DescribeBackups](https://help.aliyun.com/document_detail/98102.html) operation to query the point in time for the restoration.', example='2020-10-04T01:40:00Z'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeMetaListResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-bp1s826a1up******'),
  items?: [ 
    {
      database?: string(name='Database', description='The name of the database that can be restored.', example='test_db'),
      tables?: [ string ](name='Tables', description='The name of the table that can be restored.'),
    }
  ](name='Items', description='The details of databases and tables that can be restored.'),
  pageNumber?: string(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='AA815DE7-B576-4B22-B33C-3FB31A******'),
  totalPageCount?: string(name='TotalPageCount', description='The total number of returned pages.', example='1'),
  totalRecordCount?: string(name='TotalRecordCount', description='The total number of entries.', example='2'),
}

model DescribeMetaListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMetaListResponseBody(name='body'),
}

/**
 * @summary Queries the details of the databases or tables that can be restored.
 *
 * @param request DescribeMetaListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMetaListResponse
 */
async function describeMetaListWithOptions(request: DescribeMetaListRequest, runtime: Util.RuntimeOptions): DescribeMetaListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.getDbName)) {
    query['GetDbName'] = request.getDbName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionCode)) {
    query['RegionCode'] = request.regionCode;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetaList',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of the databases or tables that can be restored.
 *
 * @param request DescribeMetaListRequest
 * @return DescribeMetaListResponse
 */
async function describeMetaList(request: DescribeMetaListRequest): DescribeMetaListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetaListWithOptions(request, runtime);
}

model DescribeModifyParameterLogRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  endTime?: string(name='EndTime', description='This parameter is required.', example='2021-04-07T04:00Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='This parameter is required.', example='2020-11-14T00:00Z'),
}

model DescribeModifyParameterLogResponseBody = {
  engine?: string(name='Engine', example='polardb_mysql'),
  engineVersion?: string(name='EngineVersion', example='8.0'),
  items?: [ 
    {
      modifyTime?: string(name='ModifyTime', example='2024-10-29T09:31:37Z'),
      newParameterValue?: string(name='NewParameterValue', example='test01'),
      oldParameterValue?: string(name='OldParameterValue', example='test'),
      parameterName?: string(name='ParameterName', example='hz'),
      status?: string(name='Status', example='True'),
    }
  ](name='Items'),
  requestId?: string(name='RequestId', description='Id of the request', example='CD35F3-F3-44CA-AFFF-BAF869******'),
}

model DescribeModifyParameterLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeModifyParameterLogResponseBody(name='body'),
}

/**
 * @summary 查询参数修改历史
 *
 * @param request DescribeModifyParameterLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeModifyParameterLogResponse
 */
async function describeModifyParameterLogWithOptions(request: DescribeModifyParameterLogRequest, runtime: Util.RuntimeOptions): DescribeModifyParameterLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeModifyParameterLog',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询参数修改历史
 *
 * @param request DescribeModifyParameterLogRequest
 * @return DescribeModifyParameterLogResponse
 */
async function describeModifyParameterLog(request: DescribeModifyParameterLogRequest): DescribeModifyParameterLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeModifyParameterLogWithOptions(request, runtime);
}

model DescribeNetworkChannelRequest {
  channelName?: string(name='ChannelName', example='ch4'),
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5******'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId', example='vpc-bp1qpo0kug3a20qqe****'),
}

model DescribeNetworkChannelResponseBody = {
  channelInfos?: [ 
    {
      channelName?: string(name='ChannelName', example='ch4'),
      DBClusterId?: string(name='DBClusterId', example='pc-*************'),
      notes?: string(name='Notes', example='test update'),
      regionId?: string(name='RegionId', example='cn-hangzhou'),
      targetDBClusterId?: string(name='TargetDBClusterId', example='pc-*************'),
      targetIp?: string(name='TargetIp', example='33.*.*.240'),
      targetPort?: string(name='TargetPort', example='3389'),
      targetType?: string(name='TargetType', example='polardb_for_postgresql'),
      vpcId?: string(name='VpcId', example='vpc-2ze13g2c6j7j2jl*******'),
    }
  ](name='ChannelInfos'),
  requestId?: string(name='RequestId', description='Id of the request', example='925B84D9-CA72-432C-95CF-738C22******'),
}

model DescribeNetworkChannelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeNetworkChannelResponseBody(name='body'),
}

/**
 * @summary 查询网络通道
 *
 * @param request DescribeNetworkChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNetworkChannelResponse
 */
async function describeNetworkChannelWithOptions(request: DescribeNetworkChannelRequest, runtime: Util.RuntimeOptions): DescribeNetworkChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelName)) {
    query['ChannelName'] = request.channelName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNetworkChannel',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询网络通道
 *
 * @param request DescribeNetworkChannelRequest
 * @return DescribeNetworkChannelResponse
 */
async function describeNetworkChannel(request: DescribeNetworkChannelRequest): DescribeNetworkChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNetworkChannelWithOptions(request, runtime);
}

model DescribeParameterGroupRequest {
  DBType?: string(name='DBType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template.

> You can call the [DescribeParameterGroups](https://help.aliyun.com/document_detail/207178.html) operation to query the details of all parameter templates of a specified region, such as the ID of a parameter template.

This parameter is required.', example='pcpg-**************'),
  regionId?: string(name='RegionId', description='The region ID.

>You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query all regions that are available within your account, such as the region ID.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeParameterGroupResponseBody = {
  parameterGroup?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the parameter template was created. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2023-03-10T08:40:39Z'),
      DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='8.0'),
      forceRestart?: string(name='ForceRestart', description='Indicates whether to restart the cluster when this parameter template is applied. Valid values:

*   **0**: A restart is not required.
*   **1**: A restart is required.', example='1'),
      parameterCounts?: int32(name='ParameterCounts', description='The number of parameters in the parameter template.', example='2'),
      parameterDetail?: [ 
        {
          paramName?: string(name='ParamName', description='The name of the parameter.', example='back_log'),
          paramValue?: string(name='ParamValue', description='The value of the parameter.', example='3000'),
        }
      ](name='ParameterDetail', description='Details about the parameters.'),
      parameterGroupDesc?: string(name='ParameterGroupDesc', description='The description of the parameter template.', example='testgroup'),
      parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template.', example='pcpg-**************'),
      parameterGroupName?: string(name='ParameterGroupName', description='The name of the parameter template.', example='test'),
      parameterGroupType?: string(name='ParameterGroupType', description='The type of the parameter template. Valid values:

*   **0**: the default parameter template.
*   **1**: a custom parameter template.
*   **2**: an automatic backup parameter template. After you apply this type of template, the system automatically backs up the original parameter settings and saves the backup as a template.', example='1'),
    }
  ](name='ParameterGroup', description='Details about the parameter templates.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F1F16757-D31B-49CA-9BF4-305BAF******'),
}

model DescribeParameterGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeParameterGroupResponseBody(name='body'),
}

/**
 * @summary Queries the information about a parameter template.
 *
 * @description You can use parameter templates to manage multiple parameters at a time and apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](https://help.aliyun.com/document_detail/207009.html).
 * > This parameter is valid only for a PolarDB for MySQL cluster.
 *
 * @param request DescribeParameterGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeParameterGroupResponse
 */
async function describeParameterGroupWithOptions(request: DescribeParameterGroupRequest, runtime: Util.RuntimeOptions): DescribeParameterGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupId)) {
    query['ParameterGroupId'] = request.parameterGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeParameterGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about a parameter template.
 *
 * @description You can use parameter templates to manage multiple parameters at a time and apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](https://help.aliyun.com/document_detail/207009.html).
 * > This parameter is valid only for a PolarDB for MySQL cluster.
 *
 * @param request DescribeParameterGroupRequest
 * @return DescribeParameterGroupResponse
 */
async function describeParameterGroup(request: DescribeParameterGroupRequest): DescribeParameterGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParameterGroupWithOptions(request, runtime);
}

model DescribeParameterGroupsRequest {
  DBType?: string(name='DBType', description='The type of the database engine. Only **MySQL** is supported.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine. Valid values:

*   **5.6**
*   **5.7**
*   **8.0**', example='8.0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query all regions that are available for your account, such as the region ID.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the virtual node belongs.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeParameterGroupsResponseBody = {
  parameterGroups?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the parameter template was created. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2023-03-10T08:40:39Z'),
      DBType?: string(name='DBType', description='The type of the engine.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine', example='8.0'),
      forceRestart?: string(name='ForceRestart', description='Indicates whether to restart the cluster when this parameter template is applied. Valid values:

*   **0**: A restart is not required.
*   **1**: A restart is required.', example='1'),
      parameterCounts?: long(name='ParameterCounts', description='The number of parameters in the parameter template.', example='2'),
      parameterGroupDesc?: string(name='ParameterGroupDesc', description='The description of the parameter template.', example='testgroup'),
      parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template.', example='pcpg-**************'),
      parameterGroupName?: string(name='ParameterGroupName', description='The name of the parameter template.', example='test'),
      parameterGroupType?: string(name='ParameterGroupType', description='The type of the parameter template. Valid values:

*   **0**: the default parameter template.
*   **1**: a custom parameter template.
*   **2**: an automatic backup parameter template. After you apply this type of template, the system automatically backs up the original parameter settings and saves the backup as a template.', example='1'),
    }
  ](name='ParameterGroups', description='The details of parameter templates.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='944CED46-A6F7-40C6-B6DC-C6E5CC******'),
}

model DescribeParameterGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeParameterGroupsResponseBody(name='body'),
}

/**
 * @summary Queries parameter templates that are available in a specified region.
 *
 * @description You can use parameter templates to manage multiple parameters at a time and apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](https://help.aliyun.com/document_detail/207009.html).
 * > This operation is applicable only to PolarDB for MySQL clusters.
 *
 * @param request DescribeParameterGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeParameterGroupsResponse
 */
async function describeParameterGroupsWithOptions(request: DescribeParameterGroupsRequest, runtime: Util.RuntimeOptions): DescribeParameterGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeParameterGroups',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries parameter templates that are available in a specified region.
 *
 * @description You can use parameter templates to manage multiple parameters at a time and apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](https://help.aliyun.com/document_detail/207009.html).
 * > This operation is applicable only to PolarDB for MySQL clusters.
 *
 * @param request DescribeParameterGroupsRequest
 * @return DescribeParameterGroupsResponse
 */
async function describeParameterGroups(request: DescribeParameterGroupsRequest): DescribeParameterGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParameterGroupsWithOptions(request, runtime);
}

model DescribeParameterTemplatesRequest {
  DBType?: string(name='DBType', description='The type of the database engine. Only **MySQL** is supported.

This parameter is required.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database. Valid values:

*   **5.6**
*   **5.7**
*   **8.0**

This parameter is required.', example='5.7'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.

>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query all regions that are available within your account, such as the region IDs.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeParameterTemplatesResponseBody = {
  DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='5.7'),
  engine?: string(name='Engine', description='The database engine of the cluster.', example='POLARDB'),
  parameterCount?: string(name='ParameterCount', description='The number of parameters.', example='183'),
  parameters?: {
    templateRecord?: [ 
    {
      checkingCode?: string(name='CheckingCode', description='The valid values of the parameter.', example='[ROW|STATEMENT|MIXED]'),
      forceModify?: string(name='ForceModify', description='Indicates whether the parameter setting can be modified. Valid values:

*   **true**
*   **false**', example='true'),
      forceRestart?: string(name='ForceRestart', description='Indicates whether a cluster restart is required to make the parameter modification take effect. Valid values:

*   **true**
*   **false**', example='false'),
      isNodeAvailable?: string(name='IsNodeAvailable', description='Indicates whether the parameter is a global parameter. Valid values:

*   **0**: yes. The modified parameter value is synchronized to other nodes by default.
*   **1**: no. You can customize the nodes to which the modified parameter value can be synchronized.', example='1'),
      paramRelyRule?: string(name='ParamRelyRule', description='The parameter dependencies.', example='utf8'),
      parameterDescription?: string(name='ParameterDescription', description='The description of the parameter.', example='What form of binary logging the master will use.'),
      parameterName?: string(name='ParameterName', description='The name of the parameter.', example='binlog_format'),
      parameterValue?: string(name='ParameterValue', description='The default value of the parameter.', example='ROW'),
    }
  ](name='TemplateRecord')
  }(name='Parameters', description='The details of the parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D963934D-8605-4473-8EAC-54C719******'),
}

model DescribeParameterTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeParameterTemplatesResponseBody(name='body'),
}

/**
 * @summary Queries the default parameters in a cluster.
 *
 * @param request DescribeParameterTemplatesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeParameterTemplatesResponse
 */
async function describeParameterTemplatesWithOptions(request: DescribeParameterTemplatesRequest, runtime: Util.RuntimeOptions): DescribeParameterTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeParameterTemplates',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the default parameters in a cluster.
 *
 * @param request DescribeParameterTemplatesRequest
 * @return DescribeParameterTemplatesResponse
 */
async function describeParameterTemplates(request: DescribeParameterTemplatesRequest): DescribeParameterTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParameterTemplatesWithOptions(request, runtime);
}

model DescribePendingMaintenanceActionRequest {
  isHistory?: int32(name='IsHistory', description='Specifies whether to return the historical tasks. Valid values:

*   **0**: returns the current task.
*   **1**: returns the historical tasks.

Default value: **0**.', example='0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Specify the parameter to a positive integer that does not exceed the maximum value of the INTEGER data type. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **30**, **50**, and **100**.

Default value: **30**.', example='30'),
  region?: string(name='Region', description='The region ID of the pending event. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the regions and zones that are supported by PolarDB.
>- You can set this parameter to **all** to view all pending events within your account.
>- If you set `Region` to **all**, you must set `TaskType` to **all**.

This parameter is required.', example='all'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  taskType?: string(name='TaskType', description='The task type of pending events. Valid values:

*   **DatabaseSoftwareUpgrading**: database software upgrades
*   **DatabaseHardwareMaintenance**: hardware maintenance and upgrades
*   **DatabaseStorageUpgrading**: database storage upgrades
*   **DatabaseProxyUpgrading**: minor version upgrades of the proxy
*   **all**: queries the details of the pending events of all preceding types.

> If the `Region` parameter is set to **all**, the `TaskType` parameter must be set to **all**.

This parameter is required.', example='all'),
}

model DescribePendingMaintenanceActionResponseBody = {
  items?: [ 
    {
      createdTime?: string(name='CreatedTime', description='The time when the task was created. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-06-09T22:00:42Z'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-************'),
      DBType?: string(name='DBType', description='The type of the database engine. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine.

*   Valid values for the MySQL database engine:

    *   **5.6**
    *   **5.7**
    *   **8.0**

*   Valid values for the PostgreSQL database engine:

    *   **11**
    *   **14**

*   Valid value for the Oracle database engine: **11**', example='8.0'),
      deadline?: string(name='Deadline', description='The deadline before which the task can be executed. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-06-11T15:59:59Z'),
      id?: int32(name='Id', description='The ID of the task.', example='111111'),
      modifiedTime?: string(name='ModifiedTime', description='The time when the parameter was modified. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-06-09T22:00:42Z'),
      prepareInterval?: string(name='PrepareInterval', description='The preparation time that is required before the pending event is switched. The time follows the `HH:mm:ss` format.', example='04:00:00'),
      region?: string(name='Region', description='The region ID of the pending event.', example='cn-hangzhou'),
      resultInfo?: string(name='ResultInfo', description='The execution result of the task. Valid values:

*   **manualCancel**: The task is manually canceled.
*   **paramCheckNotPass**: The task fails to pass the parameter check.

> This parameter is returned only when the value of the `Status` parameter is **6** or **7**. The value 6 indicates that the task is completed but fails to be executed. The value 7 indicates that the task is canceled.', example='manualCancel'),
      startTime?: string(name='StartTime', description='The time when the task was executed in the background. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-06-09T18:00:00Z'),
      status?: int32(name='Status', description='The status of the pending task.

*   If you set the `IsHistory` parameter to **0**, the status of the pending task is returned. Valid values:

    *   **2**: The start time of the task is to be specified.
    *   **3**: The task is pending.
    *   **4**: The task is running. In this case, you cannot modify the execution time.

*   If you set the `IsHistory` parameter to **1**, the details of the historical tasks are returned. Valid values:

    *   **5**: The task is completed and executed.
    *   **6**: The task is completed but fails to be executed.
    *   **7**: The task is canceled.', example='3'),
      switchTime?: string(name='SwitchTime', description='The time when the pending event was switched. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-06-09T22:00:00Z'),
      taskType?: string(name='TaskType', description='The type of the pending event.', example='DatabaseSoftwareUpgrading'),
    }
  ](name='Items', description='Details about tasks.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2F029645-FED9-4FE8-A6D3-488954******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of returned entries.', example='1'),
}

model DescribePendingMaintenanceActionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePendingMaintenanceActionResponseBody(name='body'),
}

/**
 * @summary Queries the information about a pending event.
 *
 * @param request DescribePendingMaintenanceActionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePendingMaintenanceActionResponse
 */
async function describePendingMaintenanceActionWithOptions(request: DescribePendingMaintenanceActionRequest, runtime: Util.RuntimeOptions): DescribePendingMaintenanceActionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.isHistory)) {
    query['IsHistory'] = request.isHistory;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePendingMaintenanceAction',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about a pending event.
 *
 * @param request DescribePendingMaintenanceActionRequest
 * @return DescribePendingMaintenanceActionResponse
 */
async function describePendingMaintenanceAction(request: DescribePendingMaintenanceActionRequest): DescribePendingMaintenanceActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePendingMaintenanceActionWithOptions(request, runtime);
}

model DescribePendingMaintenanceActionsRequest {
  isHistory?: int32(name='IsHistory', description='Specifies whether to return the historical tasks. Valid values:

*   **0**: returns the current task.
*   **1**: returns the historical tasks.

Default value: **0**.', example='1'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribePendingMaintenanceActionsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='314127C2-B6C1-4F58-B1F6-E6B645******'),
  typeList?: [ 
    {
      count?: int32(name='Count', description='The number of pending events.', example='1'),
      taskType?: string(name='TaskType', description='The task type of pending events. Valid values:

*   **DatabaseSoftwareUpgrading**: database software upgrades
*   **DatabaseHardwareMaintenance**: hardware maintenance and upgrades
*   **DatabaseStorageUpgrading**: database storage upgrades
*   **DatabaseProxyUpgrading**: minor version upgrades of the proxy', example='DatabaseSoftwareUpgrading'),
    }
  ](name='TypeList', description='The details of pending events.'),
}

model DescribePendingMaintenanceActionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePendingMaintenanceActionsResponseBody(name='body'),
}

/**
 * @summary Queries the numbers of scheduled events for different types of tasks.
 *
 * @param request DescribePendingMaintenanceActionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePendingMaintenanceActionsResponse
 */
async function describePendingMaintenanceActionsWithOptions(request: DescribePendingMaintenanceActionsRequest, runtime: Util.RuntimeOptions): DescribePendingMaintenanceActionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.isHistory)) {
    query['IsHistory'] = request.isHistory;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePendingMaintenanceActions',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the numbers of scheduled events for different types of tasks.
 *
 * @param request DescribePendingMaintenanceActionsRequest
 * @return DescribePendingMaintenanceActionsResponse
 */
async function describePendingMaintenanceActions(request: DescribePendingMaintenanceActionsRequest): DescribePendingMaintenanceActionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePendingMaintenanceActionsWithOptions(request, runtime);
}

model DescribePolarSQLCollectorPolicyRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of all the clusters for your account, such as the cluster ID.

This parameter is required.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribePolarSQLCollectorPolicyResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The IDs of the clusters.', example='pc-bp1s826a1up******'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3655211B-4D74-4E13-91E6-FF2AFE******'),
  SQLCollectorStatus?: string(name='SQLCollectorStatus', description='Indicates whether the SQL Explorer feature is enabled. Valid values:

*   **Enable**
*   **Disabled**', example='Enable'),
}

model DescribePolarSQLCollectorPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePolarSQLCollectorPolicyResponseBody(name='body'),
}

/**
 * @summary Queries whether the SQL Explorer feature is enabled for the cluster.
 *
 * @param request DescribePolarSQLCollectorPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePolarSQLCollectorPolicyResponse
 */
async function describePolarSQLCollectorPolicyWithOptions(request: DescribePolarSQLCollectorPolicyRequest, runtime: Util.RuntimeOptions): DescribePolarSQLCollectorPolicyResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePolarSQLCollectorPolicy',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries whether the SQL Explorer feature is enabled for the cluster.
 *
 * @param request DescribePolarSQLCollectorPolicyRequest
 * @return DescribePolarSQLCollectorPolicyResponse
 */
async function describePolarSQLCollectorPolicy(request: DescribePolarSQLCollectorPolicyRequest): DescribePolarSQLCollectorPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePolarSQLCollectorPolicyWithOptions(request, runtime);
}

model DescribeRdsVSwitchsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='This parameter is required.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  vpcId?: string(name='VpcId', example='vpc-*************'),
  zoneId?: string(name='ZoneId', example='cn-hangzhou-i'),
}

model DescribeRdsVSwitchsResponseBody = {
  requestId?: string(name='RequestId', example='A0450B18-BBD4-5DF9-8E71-610F1A921CDE'),
  vSwitches?: {
    vSwitch?: [ 
      {
        aliUid?: string(name='AliUid', example='175358919****'),
        bid?: string(name='Bid', example='26842'),
        cidrBlock?: string(name='CidrBlock', example='192.168.8.0/24'),
        gmtCreate?: string(name='GmtCreate', example='2024-12-23 10:15:38'),
        gmtModified?: string(name='GmtModified', example='2025-04-30T09:41:14+08:00'),
        isDefault?: boolean(name='IsDefault', example='false'),
        izNo?: string(name='IzNo', example='ch-hangzhou-g'),
        regionNo?: string(name='RegionNo', example='cn-hangzhou'),
        status?: string(name='Status', example='Available'),
        vSwitchId?: string(name='VSwitchId', example='vsw-**************'),
        vSwitchName?: string(name='VSwitchName', example='sw01'),
      }
    ](name='VSwitch'),
  }(name='VSwitches'),
}

model DescribeRdsVSwitchsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRdsVSwitchsResponseBody(name='body'),
}

/**
 * @param request DescribeRdsVSwitchsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRdsVSwitchsResponse
 */
async function describeRdsVSwitchsWithOptions(request: DescribeRdsVSwitchsRequest, runtime: Util.RuntimeOptions): DescribeRdsVSwitchsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRdsVSwitchs',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeRdsVSwitchsRequest
 * @return DescribeRdsVSwitchsResponse
 */
async function describeRdsVSwitchs(request: DescribeRdsVSwitchsRequest): DescribeRdsVSwitchsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRdsVSwitchsWithOptions(request, runtime);
}

model DescribeRdsVpcsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  zoneId?: string(name='ZoneId', example='cn-hangzhou-k'),
}

model DescribeRdsVpcsResponseBody = {
  requestId?: string(name='RequestId', example='B45E8D29-EA17-5141-AE09-F7A399760C9E'),
  vpcs?: {
    vpc?: [ 
      {
        aliUid?: string(name='AliUid', example='1485293698******'),
        bid?: string(name='Bid', example='26842'),
        cidrBlock?: string(name='CidrBlock', example='10.21.0.0/16'),
        gmtCreate?: string(name='GmtCreate', example='2025-08-28T02:25:41Z'),
        gmtModified?: string(name='GmtModified', example='2025-04-30T09:41:14+08:00'),
        isDefault?: boolean(name='IsDefault', example='true'),
        regionNo?: string(name='RegionNo', example='cn-hangzhou'),
        status?: string(name='Status', example='Available'),
        vSwitchs?: [ 
          {
            cidrBlock?: string(name='CidrBlock', example='192.168.7.0/24'),
            gmtCreate?: string(name='GmtCreate', example='2025-05-12 18:17:25'),
            gmtModified?: string(name='GmtModified', example='2025-01-07T15:10:32+08:00'),
            isDefault?: boolean(name='IsDefault', example='true'),
            izNo?: string(name='IzNo', example='cn-hangzhou-k'),
            status?: string(name='Status', example='Available'),
            vSwitchId?: string(name='VSwitchId', example='vsw-**********'),
            vSwitchName?: string(name='VSwitchName', example='test'),
          }
        ](name='VSwitchs'),
        vpcId?: string(name='VpcId', example='vpc-*************'),
        vpcName?: string(name='VpcName', example='fc-webide'),
      }
    ](name='Vpc'),
  }(name='Vpcs'),
}

model DescribeRdsVpcsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRdsVpcsResponseBody(name='body'),
}

/**
 * @param request DescribeRdsVpcsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRdsVpcsResponse
 */
async function describeRdsVpcsWithOptions(request: DescribeRdsVpcsRequest, runtime: Util.RuntimeOptions): DescribeRdsVpcsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRdsVpcs',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeRdsVpcsRequest
 * @return DescribeRdsVpcsResponse
 */
async function describeRdsVpcs(request: DescribeRdsVpcsRequest): DescribeRdsVpcsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRdsVpcsWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      zones?: {
        zone?: [ 
        {
          vpcEnabled?: boolean(name='VpcEnabled', description='Indicates whether virtual private clouds (VPCs) are supported.', example='true'),
          zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-g'),
        }
      ](name='Zone')
      }(name='Zones', description='The list of zones.'),
    }
  ](name='Region')
  }(name='Regions', description='The list of regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3F9E6A3B-C13E-4064-A010-18582A******'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @summary Queries the regions and zones available for PolarDB.
 *
 * @param request DescribeRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the regions and zones available for PolarDB.
 *
 * @param request DescribeRegionsRequest
 * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeResourcePackagesResponseBody = {
  requestId?: string(name='RequestId', example='E56531A4-E552-40BA-9C58-137B80******'),
  resourcePackageList?: [ 
    {
      autoQuota?: boolean(name='AutoQuota', example='true'),
      createTime?: long(name='CreateTime', example='1744621511000'),
      expireTime?: long(name='ExpireTime', example='1747238400000'),
      resourcePackageId?: string(name='ResourcePackageId', example='pm-bp11b0i9389******'),
      resourcePackageQuotaList?: [ 
        {
          allocatedCapacity?: long(name='AllocatedCapacity', example='6'),
          projectId?: string(name='ProjectId', example='pj-87681rbcef6******'),
          usedCapacity?: long(name='UsedCapacity', example='2'),
        }
      ](name='ResourcePackageQuotaList'),
      resourcePackageType?: string(name='ResourcePackageType', example='MySQL'),
      status?: string(name='Status', example='Normal'),
      tags?: [ 
        {
          key?: string(name='Key', example='Key'),
          value?: string(name='Value', example='Value'),
        }
      ](name='Tags'),
      totalCapacity?: long(name='TotalCapacity', example='8'),
      usedCapacity?: long(name='UsedCapacity', example='4'),
    }
  ](name='ResourcePackageList'),
}

model DescribeResourcePackagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeResourcePackagesResponseBody(name='body'),
}

/**
 * @summary 查询资源包列表
 *
 * @param request DescribeResourcePackagesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeResourcePackagesResponse
 */
async function describeResourcePackagesWithOptions(runtime: Util.RuntimeOptions): DescribeResourcePackagesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeResourcePackages',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询资源包列表
 *
 * @return DescribeResourcePackagesResponse
 */
async function describeResourcePackages(): DescribeResourcePackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeResourcePackagesWithOptions(runtime);
}

model DescribeSQLRateLimitingRulesRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-*************'),
  maxResults?: int32(name='MaxResults', example='10'),
  nextToken?: string(name='NextToken', example='AAAAARbaCuN6hiD08qrLdwJ9Fh3QbdIPYBaCDXsvvjLHCQfi'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleNameList?: string(name='RuleNameList', example='testrule'),
}

model DescribeSQLRateLimitingRulesResponseBody = {
  data?: {
    ruleList?: [ string ](name='RuleList'),
  }(name='Data'),
  maxResults?: int32(name='MaxResults', example='10'),
  message?: string(name='Message', example='Successful'),
  nextToken?: string(name='NextToken', description='nextToken', example='AAAAARbaCuN6hiD08qrLdwJ9Fh0vHYf39hc0J5qELgsazkBk'),
  requestId?: string(name='RequestId', description='Id of the request', example='22C0ACF0-DD29-4B67-9190-B7A48C******'),
}

model DescribeSQLRateLimitingRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSQLRateLimitingRulesResponseBody(name='body'),
}

/**
 * @summary 查询SQL限流规则信息
 *
 * @param request DescribeSQLRateLimitingRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSQLRateLimitingRulesResponse
 */
async function describeSQLRateLimitingRulesWithOptions(request: DescribeSQLRateLimitingRulesRequest, runtime: Util.RuntimeOptions): DescribeSQLRateLimitingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleNameList)) {
    query['RuleNameList'] = request.ruleNameList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSQLRateLimitingRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询SQL限流规则信息
 *
 * @param request DescribeSQLRateLimitingRulesRequest
 * @return DescribeSQLRateLimitingRulesResponse
 */
async function describeSQLRateLimitingRules(request: DescribeSQLRateLimitingRulesRequest): DescribeSQLRateLimitingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSQLRateLimitingRulesWithOptions(request, runtime);
}

model DescribeScheduleTasksRequest {
  DBClusterDescription?: string(name='DBClusterDescription', description='The description of the cluster.', example='testdb'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

> 

*   You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the information of all PolarDB clusters that are deployed in a specific region, such as the cluster IDs.

*   If you do not specify this parameter, all scheduled tasks on your clusters are queried.', example='pc-**************'),
  orderId?: string(name='OrderId', description='The ID of the order.

>  The order ID can contain only digits.', example='20951253014****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. Set this parameter to an integer that is greater than 0. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: **30**, **50**, and **100**. Default value: 30.', example='30'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time of the task that you specified when you created the scheduled task. The time is displayed in UTC.', example='2021-01-28T12:30Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time of the task that you specified when you created the scheduled task. The time is displayed in UTC.', example='2021-01-28T12:00Z'),
  regionId?: string(name='RegionId', description='The ID of the region.

> 

*   You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the region information of all clusters in a specific account.

*   If you do not specify this parameter, scheduled tasks on your clusters that are deployed in all regions are queried.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: string(name='Status', description='The state of the tasks that you want to query. Valid values:

*   **pending**: The tasks are pending execution.
*   **executing**: The tasks are being executed.
*   **failure**: The tasks failed and need to be run again.
*   **finish**: The tasks are complete.
*   **cancel**: The tasks are canceled.
*   **expired**: The tasks are expired. The tasks are not started within the time periods that are specified to start the tasks.
*   **rollback**: The tasks are being rolled back.

>  If you do not specify this parameter, all scheduled tasks in all states are queried.', example='finish'),
  taskAction?: string(name='TaskAction', description='The type of scheduled tasks that you want to query. Valid values:

*   **CreateDBNodes**
*   **ModifyDBNodeClass**
*   **UpgradeDBClusterVersion**
*   **ModifyDBClusterPrimaryZone**

> 

*   If you specify the `PlannedStartTime` parameter when you call the four preceding operations, the details of each task are returned. Otherwise, an empty string is returned for the `TimerInfos` parameter.

*   If you do not specify this parameter, all types of scheduled tasks on you clusters are queried.', example='CreateDBNodes'),
}

model DescribeScheduleTasksResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber', description='The page number of the page returned.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
    timerInfos?: [ 
      {
        action?: string(name='Action', description='The type of the scheduled tasks.', example='CreateDBNodes'),
        crontabJobId?: string(name='CrontabJobId', description='The ID of the scheduled task.', example='86293c29-a03d-4872-b625-***********'),
        DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-**************'),
        dbClusterDescription?: string(name='DbClusterDescription', description='The description of the cluster.', example='test_cluster'),
        dbClusterStatus?: string(name='DbClusterStatus', description='The state of the cluster.', example='Running'),
        orderId?: string(name='OrderId', description='The ID of the order.

>  This parameter is returned only when you set the `Action` parameter to **CreateDBNodes** or **ModifyDBNodeClass**.', example='208161753******'),
        plannedEndTime?: string(name='PlannedEndTime', description='The latest start time of the task that you specified when you created the scheduled task. The time is displayed in UTC.', example='2021-01-28T12:30Z'),
        plannedFlashingOffTime?: string(name='PlannedFlashingOffTime'),
        plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time of the task that you specified when you created the scheduled task. The time is displayed in UTC.', example='2021-01-28T12:00Z'),
        plannedTime?: string(name='PlannedTime', description='The expected start time of the task. The time is displayed in UTC.', example='2021-01-28T12:16Z'),
        region?: string(name='Region', description='The ID of the region in which the scheduled task runs.', example='cn-hangzhou'),
        status?: string(name='Status', description='The state of the scheduled task.', example='finish'),
        taskCancel?: boolean(name='TaskCancel', description='Indicates whether the scheduled task can be canceled. Valid values:

*   **true**
*   **false**', example='true'),
        taskId?: string(name='TaskId', description='The ID of the task.', example='53879cdb-9a00-428e-acaf-ff4cff******'),
      }
    ](name='TimerInfos', description='The details of the scheduled tasks.'),
    totalRecordCount?: int32(name='TotalRecordCount', description='The total number of entries returned.', example='1'),
  }(name='Data', description='The result data.'),
  message?: string(name='Message', description='The message that is returned for the request.

>  If the request is successful, **Successful** is returned. If the request fails, an error message such as an error code is returned.', example='Successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='936C7025-27A5-4CB1-BB31-540E1F0CCA12'),
  success?: boolean(name='Success', description='Indicates whether the request is successful.', example='true'),
}

model DescribeScheduleTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeScheduleTasksResponseBody(name='body'),
}

/**
 * @summary Queries the details of all scheduled tasks.
 *
 * @param request DescribeScheduleTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeScheduleTasksResponse
 */
async function describeScheduleTasksWithOptions(request: DescribeScheduleTasksRequest, runtime: Util.RuntimeOptions): DescribeScheduleTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterDescription)) {
    query['DBClusterDescription'] = request.DBClusterDescription;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskAction)) {
    query['TaskAction'] = request.taskAction;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScheduleTasks',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of all scheduled tasks.
 *
 * @param request DescribeScheduleTasksRequest
 * @return DescribeScheduleTasksResponse
 */
async function describeScheduleTasks(request: DescribeScheduleTasksRequest): DescribeScheduleTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScheduleTasksWithOptions(request, runtime);
}

model DescribeSlowLogRecordsRequest {
  DBClusterId?: string(name='DBClusterId', description='Cluster ID.
> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) interface to view all cluster information in the target region, including the Cluster ID.

This parameter is required.', example='pc-************'),
  DBName?: string(name='DBName', description='Database name.', example='testdb'),
  endTime?: string(name='EndTime', description='End time of the query, which must be later than the start time, and the time interval between the start and end times must not exceed 24 hours. The format is `YYYY-MM-DDThh:mmZ` (UTC time).

> The input is UTC time (i.e., 0 timezone). If your service is currently in a different timezone, please perform a time conversion. For example, if the current timezone of your service is Beijing Time (UTC+8) at 12:00, and you need to query the slow logs between 08:00-12:00 Beijing Time, you should input 00:00-04:00.

This parameter is required.', example='2022-11-16T04:00Z'),
  nodeId?: string(name='NodeId', description='Node ID', example='pi-**********'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value must be an integer that is greater than 0.

Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30'),
  regionId?: string(name='RegionId', description='Region ID.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) interface to view the available regions under the target account, including the Region ID.

This parameter is required.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  SQLHASH?: string(name='SQLHASH', description='Unique identifier of the SQL statement in the slow log statistics, which can be used to obtain the detailed slow logs for that SQL statement.', example='U2FsdGVk****'),
  startTime?: string(name='StartTime', description='Start time of the query. The format is `YYYY-MM-DDThh:mmZ` (UTC time).

> * Supports viewing slow log information up to 30 days.
> * The input is UTC time (i.e., 0 timezone). If your service is currently in a different timezone, please perform a time conversion. For example, if the current timezone of your service is Beijing Time (UTC+8) at 12:00, and you need to query the slow logs between 08:00-12:00 Beijing Time, you should input 00:00-04:00.

This parameter is required.', example='2022-11-15T16:00Z'),
}

model DescribeSlowLogRecordsResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='Cluster ID.', example='pc-*****************'),
  engine?: string(name='Engine', description='Database engine.', example='polardb_mysql'),
  items?: {
    SQLSlowRecord?: [ 
    {
      DBName?: string(name='DBName', description='Database name.', example='testdb'),
      DBNodeId?: string(name='DBNodeId', description='Node ID.', example='pi-*****************'),
      executionStartTime?: string(name='ExecutionStartTime', description='Time when the SQL starts execution. The format is `YYYY-MM-DDThh:mmZ` (UTC time).', example='2021-04-07T03:47Z'),
      hostAddress?: string(name='HostAddress', description='Client address connecting to the database.', example='testdb[testdb] @  [100.**.**.242]'),
      lockTimes?: long(name='LockTimes', description='SQL lock duration in seconds.', example='0'),
      parseRowCounts?: long(name='ParseRowCounts', description='Number of rows parsed.', example='0'),
      queryTimeMS?: long(name='QueryTimeMS', description='Query time. Unit: milliseconds.', example='100'),
      queryTimes?: long(name='QueryTimes', description='SQL execution duration, in seconds.', example='20'),
      returnRowCounts?: long(name='ReturnRowCounts', description='Number of rows returned.', example='0'),
      SQLHash?: string(name='SQLHash', description='Unique identifier for the SQL statement in slow log statistics.', example='U2FsdGVk****'),
      SQLText?: string(name='SQLText', description='Query statement.'),
    }
  ](name='SQLSlowRecord')
  }(name='Items', description='List of slow log details.'),
  pageNumber?: int32(name='PageNumber', description='Page number.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='Number of records on this page.', example='1'),
  requestId?: string(name='RequestId', description='Request ID.', example='A7E6A8FD-C50B-46B2-BA85-D8B8D3******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='Total number of SQL statements.', example='1'),
}

model DescribeSlowLogRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSlowLogRecordsResponseBody(name='body'),
}

/**
 * @summary Slow Log Details
 *
 * @description >- Only PolarDB MySQL Edition clusters support calling this interface.
 * >- Starting from September 1, 2024, due to the optimization of the SQL template algorithm, when calling this interface, the value of the SQLHash field will change. For more details, please refer to [Notice] Optimization of Slow SQL Template Algorithm (~~2845725~~).
 *
 * @param request DescribeSlowLogRecordsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSlowLogRecordsResponse
 */
async function describeSlowLogRecordsWithOptions(request: DescribeSlowLogRecordsRequest, runtime: Util.RuntimeOptions): DescribeSlowLogRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.SQLHASH)) {
    query['SQLHASH'] = request.SQLHASH;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSlowLogRecords',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Slow Log Details
 *
 * @description >- Only PolarDB MySQL Edition clusters support calling this interface.
 * >- Starting from September 1, 2024, due to the optimization of the SQL template algorithm, when calling this interface, the value of the SQLHash field will change. For more details, please refer to [Notice] Optimization of Slow SQL Template Algorithm (~~2845725~~).
 *
 * @param request DescribeSlowLogRecordsRequest
 * @return DescribeSlowLogRecordsResponse
 */
async function describeSlowLogRecords(request: DescribeSlowLogRecordsRequest): DescribeSlowLogRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSlowLogRecordsWithOptions(request, runtime);
}

model DescribeSlowLogsRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-****************'),
  DBName?: string(name='DBName', description='The name of the database.', example='PolarDB_MySQL'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. The time span between the start time and the end time cannot exceed 31 days. Specify the time in the yyyy-MM-ddZ format. The time must be in UTC.

This parameter is required.', example='2021-05-30Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 30 to 100. Default value: 30.', example='30'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

This parameter is required.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the yyyy-MM-ddZ format. The time must be in UTC.

This parameter is required.', example='2021-05-01Z'),
}

model DescribeSlowLogsResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-****************'),
  endTime?: string(name='EndTime', description='The end date of the query.', example='2021-05-30Z'),
  engine?: string(name='Engine', description='The type of the database engine.', example='polardb_mysql'),
  items?: {
    SQLSlowLog?: [ 
    {
      createTime?: string(name='CreateTime', description='The date when the data was generated.', example='2021-05-30Z'),
      DBName?: string(name='DBName', description='The name of the database.', example='PolarDB_MySQL'),
      DBNodeId?: string(name='DBNodeId', description='The ID of the node.', example='pi-***************'),
      maxExecutionTime?: long(name='MaxExecutionTime', description='The longest execution duration of a specific SQL statement in the query. Unit: seconds.', example='60'),
      maxLockTime?: long(name='MaxLockTime', description='The longest lock duration that was caused by a specific SQL statement in the query. Unit: seconds.', example='1'),
      parseMaxRowCount?: long(name='ParseMaxRowCount', description='The largest number of rows that were parsed by a specific SQL statement in the query.', example='1'),
      parseTotalRowCounts?: long(name='ParseTotalRowCounts', description='The total number of rows that were parsed by all SQL statements in the query.', example='2'),
      returnMaxRowCount?: long(name='ReturnMaxRowCount', description='The largest number of rows that were returned by a specific SQL statement in the query.', example='3'),
      returnTotalRowCounts?: long(name='ReturnTotalRowCounts', description='The total number of rows that were returned by all SQL statements in the query.', example='1'),
      SQLHASH?: string(name='SQLHASH', description='The unique ID of the SQL statement. The ID is used to obtain the slow query logs of the SQL statement.', example='U2FsdGVkxxxx'),
      SQLText?: string(name='SQLText', description='The SQL statement that is executed in the query.', example='select id,name from tb_table'),
      totalExecutionCounts?: long(name='TotalExecutionCounts', description='The total number of executions of the SQL statements.', example='2'),
      totalExecutionTimes?: long(name='TotalExecutionTimes', description='The total duration that was caused by all SQL statements in the query. Unit: seconds.', example='2'),
      totalLockTimes?: long(name='TotalLockTimes', description='The total lock duration that was caused by all SQL statements in the query. Unit: seconds.', example='1'),
    }
  ](name='SQLSlowLog')
  }(name='Items', description='Details about slow query logs.'),
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='3'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of SQL statements that are returned on the current page.', example='6'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2553A660-E4EB-4AF4-A402-8AFF70A49143'),
  startTime?: string(name='StartTime', description='The start date of the query.', example='2021-05-01Z'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of returned entries.', example='5'),
}

model DescribeSlowLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSlowLogsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics about the slow query logs of a PolarDB cluster.
 *
 * @description > This operation is applicable only to PolarDB for MySQL clusters.
 *
 * @param request DescribeSlowLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSlowLogsResponse
 */
async function describeSlowLogsWithOptions(request: DescribeSlowLogsRequest, runtime: Util.RuntimeOptions): DescribeSlowLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSlowLogs',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the statistics about the slow query logs of a PolarDB cluster.
 *
 * @description > This operation is applicable only to PolarDB for MySQL clusters.
 *
 * @param request DescribeSlowLogsRequest
 * @return DescribeSlowLogsResponse
 */
async function describeSlowLogs(request: DescribeSlowLogsRequest): DescribeSlowLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSlowLogsWithOptions(request, runtime);
}

model DescribeTasksRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

>  You must specify `DBNodeId` or `DBClusterId`. You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.', example='pc-***************'),
  DBNodeId?: string(name='DBNodeId', description='The node ID.

>  You must specify `DBNodeId` or `DBClusterId`. You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as node IDs.', example='pi-***************'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mmZ` format. The time must be in UTC. The end time must be later than the start time.

This parameter is required.', example='2020-12-02T03:00Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1.

Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **30**, **50**, and **100**.

Default value: **30**.', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-11-30T00:00Z'),
  status?: string(name='Status', description='The state of the tasks that you want to query. Valid values:

*   **Waiting**: The task is pending.
*   **Running**: The task is running.
*   **Finished**: The task is completed.
*   **Closed**: The task is closed.
*   **Pause**: The task is paused.
*   **Stop**: The task is interrupted.

> 

*   If you do not specify this parameter, the operation returns the details of only the tasks that are in the **Waiting** or **Running** state for the cluster or node.

*   You can enter multiple task states. Separate multiple task states with commas (,).', example='Running'),
}

model DescribeTasksResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster for which the task was created.', example='pc-***************'),
  endTime?: string(name='EndTime', description='The end time of the query.', example='2020-12-02T03:00Z'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page returned.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The request ID.', example='4352AD99-9FF5-41A6-A319-068089******'),
  startTime?: string(name='StartTime', description='The start time of the query.', example='2020-11-30T00:00Z'),
  tasks?: {
    task?: [ 
    {
      beginTime?: string(name='BeginTime', description='The time when the task was started. The time follows the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.', example='2020-12-02T02:39:15Z'),
      currentStepName?: string(name='CurrentStepName', description='The name of the current step.', example='create_instance'),
      DBName?: string(name='DBName', description='The database name.

>  This parameter is returned for only the tasks that involve database operations.', example='test'),
      expectedFinishTime?: string(name='ExpectedFinishTime', description='The estimated end time of the task. In most cases, this parameter is empty.', example='null'),
      finishTime?: string(name='FinishTime', description='The time when the task was completed. The time follows the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.', example='2020-12-02T02:40:15Z'),
      progress?: int32(name='Progress', description='The progress of the task in percentage.', example='100'),
      progressInfo?: string(name='ProgressInfo', description='The description of the task progress. If no progress description is provided for the task, this parameter is empty.', example='null'),
      remain?: int32(name='Remain', description='The estimated remaining duration of the task. Unit: seconds.', example='1767'),
      stepProgressInfo?: string(name='StepProgressInfo', description='The progress of the subtasks. For example, the value `1/4` indicates that the task consists of four subtasks and the first subtask is in progress.', example='1/4'),
      stepsInfo?: string(name='StepsInfo', description='The details of the subtasks.', example='[{\\\\"remain\\\\":0,\\\\"name\\\\":\\\\"init_task\\\\",\\\\"progress\\\\":100},{\\\\"remain\\\\":1764,\\\\"name\\\\":\\\\"create_instance\\\\",\\\\"progress\\\\":0},{\\\\"remain\\\\":1,\\\\"name\\\\":\\\\"init_cluster\\\\",\\\\"progress\\\\":0},{\\\\"remain\\\\":2,\\\\"name\\\\":\\\\"create_backup\\\\",\\\\"progress\\\\":0}]'),
      taskAction?: string(name='TaskAction', description='The API operation that is used by the task. Example: `CreateDBInstance`.', example='CreateDBInstance'),
      taskErrorCode?: string(name='TaskErrorCode', description='The error code that is returned when an error occurs.

>  This parameter is returned only when the task is in the **Stop** state.', example='null'),
      taskErrorMessage?: string(name='TaskErrorMessage', description='The error message that is returned when an error occurs.

>  This parameter is returned only when the task is in the **Stop** state.', example='null'),
      taskId?: string(name='TaskId', description='The ID of the task.', example='111111111'),
    }
  ](name='Task')
  }(name='Tasks', description='The details of the task.'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of entries returned.', example='1'),
}

model DescribeTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTasksResponseBody(name='body'),
}

/**
 * @summary Queries the status of the tasks that are generated based on API operations, such as the status of instance creation tasks.
 *
 * @description *   You can call this operation to view the details of a task that is generated by a specific API operation or in the PolarDB console. The system calls the specific API operation when you perform an operation in the PolarDB console. For example, you can view the details of the task when you call the [CreateDBCluster](https://help.aliyun.com/document_detail/98169.html) operation or [create a cluster](https://help.aliyun.com/document_detail/58769.html) in the PolarDB console.
 * *   You can view the details of tasks that are generated only when you call the [CreateDBCluster](https://help.aliyun.com/document_detail/98169.html) operation to create a cluster and `CreationOption` is not set to `CreateGdnStandby`.
 *
 * @param request DescribeTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTasksResponse
 */
async function describeTasksWithOptions(request: DescribeTasksRequest, runtime: Util.RuntimeOptions): DescribeTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeId)) {
    query['DBNodeId'] = request.DBNodeId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTasks',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the status of the tasks that are generated based on API operations, such as the status of instance creation tasks.
 *
 * @description *   You can call this operation to view the details of a task that is generated by a specific API operation or in the PolarDB console. The system calls the specific API operation when you perform an operation in the PolarDB console. For example, you can view the details of the task when you call the [CreateDBCluster](https://help.aliyun.com/document_detail/98169.html) operation or [create a cluster](https://help.aliyun.com/document_detail/58769.html) in the PolarDB console.
 * *   You can view the details of tasks that are generated only when you call the [CreateDBCluster](https://help.aliyun.com/document_detail/98169.html) operation to create a cluster and `CreationOption` is not set to `CreateGdnStandby`.
 *
 * @param request DescribeTasksRequest
 * @return DescribeTasksResponse
 */
async function describeTasks(request: DescribeTasksRequest): DescribeTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTasksWithOptions(request, runtime);
}

model DescribeUpgradeReportRequest {
  creationCategory?: string(name='CreationCategory', example='Normal'),
  DBType?: string(name='DBType', example='MySQL'),
  DBVersion?: string(name='DBVersion', example='8.0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceDBClusterId?: string(name='SourceDBClusterId', example='rm-2zen5pe5vi56447d0'),
  status?: string(name='Status', example='Running'),
  taskId?: string(name='TaskId', example='2321321'),
  type?: string(name='Type', example='orca'),
}

model DescribeUpgradeReportResponseBody = {
  details?: string(name='Details', example='[]'),
  dstDBType?: string(name='DstDBType', example='MySQL'),
  items?: [ 
    {
      DDL?: string(name='DDL', example='CREATE XXXX'),
      name?: string(name='Name', example='testName'),
      schema?: string(name='Schema', example='ny_openapi'),
      status?: string(name='Status', example='1'),
      type?: string(name='Type', example='orca'),
    }
  ](name='Items'),
  itemsSize?: long(name='ItemsSize', example='10'),
  requestId?: string(name='RequestId', description='Id of the request', example='2FED790E-FB61-4721-8C1C-07C627******'),
  sourceDBClusterId?: string(name='SourceDBClusterId', example='rm-2zen5pe5vi56447d0'),
  srcDBType?: string(name='SrcDBType', example='MySQL'),
  srcDeleted?: string(name='SrcDeleted', example='1'),
  totalSize?: long(name='TotalSize', example='137'),
  type?: string(name='Type', example='tair'),
  upgradeReportList?: [ 
    {
      checkTime?: string(name='CheckTime', example='2024-03-15T06:48:44Z'),
      dstVersion?: string(name='DstVersion', example='8.0'),
      effectiveTime?: string(name='EffectiveTime', example='2024-03-08T06:48:44Z'),
      endTime?: string(name='EndTime', example='2024-03-08T06:48:44Z'),
      result?: string(name='Result', example='running'),
      srcInsName?: string(name='SrcInsName', example='pc-2ze54671qoz830za9'),
      srcVersion?: string(name='SrcVersion', example='5.7'),
      startTime?: string(name='StartTime', example='2025-07-05T01:56:00Z'),
      taskId?: string(name='TaskId', example='275948'),
      upgradeMode?: string(name='UpgradeMode', example='rds2polar_pengine_with_dts'),
    }
  ](name='UpgradeReportList'),
}

model DescribeUpgradeReportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUpgradeReportResponseBody(name='body'),
}

/**
 * @summary 查询校验报告
 *
 * @param request DescribeUpgradeReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUpgradeReportResponse
 */
async function describeUpgradeReportWithOptions(request: DescribeUpgradeReportRequest, runtime: Util.RuntimeOptions): DescribeUpgradeReportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.creationCategory)) {
    query['CreationCategory'] = request.creationCategory;
  }
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceDBClusterId)) {
    query['SourceDBClusterId'] = request.sourceDBClusterId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUpgradeReport',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询校验报告
 *
 * @param request DescribeUpgradeReportRequest
 * @return DescribeUpgradeReportResponse
 */
async function describeUpgradeReport(request: DescribeUpgradeReportRequest): DescribeUpgradeReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUpgradeReportWithOptions(request, runtime);
}

model DescribeUserEncryptionKeyListRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.', example='pc-************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query all regions that are available for your account, such as the region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  TDERegion?: string(name='TDERegion', description='The region where the TDE key resides.', example='cn-beijing'),
}

model DescribeUserEncryptionKeyListResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-************'),
  keyList?: [ string ](name='KeyList', description='Cluster key list.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A7E6A8FD-C50B-46B2-BA85-D8B8D3******'),
}

model DescribeUserEncryptionKeyListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUserEncryptionKeyListResponseBody(name='body'),
}

/**
 * @summary Queries the Key Management Service (KMS)-managed customer master keys (CMKs) that are used to encrypt data in a PolarDB cluster.
 *
 * @param request DescribeUserEncryptionKeyListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserEncryptionKeyListResponse
 */
async function describeUserEncryptionKeyListWithOptions(request: DescribeUserEncryptionKeyListRequest, runtime: Util.RuntimeOptions): DescribeUserEncryptionKeyListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.TDERegion)) {
    query['TDERegion'] = request.TDERegion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserEncryptionKeyList',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the Key Management Service (KMS)-managed customer master keys (CMKs) that are used to encrypt data in a PolarDB cluster.
 *
 * @param request DescribeUserEncryptionKeyListRequest
 * @return DescribeUserEncryptionKeyListResponse
 */
async function describeUserEncryptionKeyList(request: DescribeUserEncryptionKeyListRequest): DescribeUserEncryptionKeyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserEncryptionKeyListWithOptions(request, runtime);
}

model DescribeVSwitchListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  regionId?: string(name='RegionId', description='This parameter is required.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  vSwitchIds?: [ string ](name='VSwitchIds'),
  vpcId?: string(name='VpcId', example='vpc-25cdvfeq58pl****'),
  zoneId?: string(name='ZoneId', example='cn-hangzhou-g'),
}

model DescribeVSwitchListResponseBody = {
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  requestId?: string(name='RequestId', example='6A2EE5B4-CC9F-46E1-A747-E43BC9******'),
  totalCount?: int32(name='TotalCount', example='1'),
  vSwitchs?: [ 
    {
      availableIpAddressCount?: long(name='AvailableIpAddressCount', example='1'),
      cidrBlock?: string(name='CidrBlock', example='172.16.0.0/24'),
      description?: string(name='Description', example='vSwitchDescription'),
      isDefault?: boolean(name='IsDefault', example='true'),
      izNo?: string(name='IzNo', example='cn-hangzhou-b'),
      ownerId?: string(name='OwnerId', example='177563751276****'),
      resourceGroupId?: string(name='ResourceGroupId', example='rg-************'),
      shareType?: string(name='ShareType', example='Public'),
      status?: string(name='Status', example='Available'),
      vSwitchId?: string(name='VSwitchId', example='vsw-25bcdxs7pv1****'),
      vSwitchName?: string(name='VSwitchName', example='vSwitch'),
      vpcId?: string(name='VpcId', example='vpc-bp1vbkkyt7apvy4j*****'),
    }
  ](name='VSwitchs'),
}

model DescribeVSwitchListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVSwitchListResponseBody(name='body'),
}

/**
 * @summary 查询交换机信息
 *
 * @param request DescribeVSwitchListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVSwitchListResponse
 */
async function describeVSwitchListWithOptions(request: DescribeVSwitchListRequest, runtime: Util.RuntimeOptions): DescribeVSwitchListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.vSwitchIds)) {
    query['VSwitchIds'] = request.vSwitchIds;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVSwitchList',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询交换机信息
 *
 * @param request DescribeVSwitchListRequest
 * @return DescribeVSwitchListResponse
 */
async function describeVSwitchList(request: DescribeVSwitchListRequest): DescribeVSwitchListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVSwitchListWithOptions(request, runtime);
}

model DescribeVSwitchesRequest {
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId', description='The dedicated cluster ID.

>  You must specify at least one of the **VpcId** and **DedicatedHostGroupId** parameters.', example='dhg-4n****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 50. The default value is 50.', example='50'),
  regionId?: string(name='RegionId', description='The ID of the region where the vSwitch is deployed.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the vSwitch belongs.', example='rg-bp67acfmxazb4ph****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private type (VPC) to which the vSwitch belongs.

>  You must specify at least one of the **VpcId** and **DedicatedHostGroupId** parameters.', example='vpc-25cdvfeq58pl****'),
  zoneId?: string(name='ZoneId', description='The ID of the zone to which the vSwitch belongs.', example='cn-hangzhou-d'),
}

model DescribeVSwitchesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='9A572171-4E27-40D1-BD36-D26C9E71E29E'),
  totalCount?: int32(name='TotalCount', description='The number of returned entries.', example='1'),
  vSwitchs?: [ 
    {
      availableIpAddressCount?: long(name='AvailableIpAddressCount', description='The number of available IP addresses in the vSwitch.', example='1'),
      cidrBlock?: string(name='CidrBlock', description='The IPv4 CIDR block of the vSwitch.', example='172.16.0.0/24'),
      description?: string(name='Description', description='The description of the vSwitch.', example='vSwitchDescription'),
      isDefault?: boolean(name='IsDefault', description='Indicates whether the vSwitch is the default vSwitch. Valid values:

*   **true**
*   **false**', example='true'),
      izNo?: string(name='IzNo', description='The zone to which the NAT gateway belongs.', example='cn-hangzhou-b'),
      status?: string(name='Status', description='The status of the vSwitch. Valid values:

*   **Pending**: The vSwitch is being configured.
*   **Available**: The vSwitch is available.', example='Available'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-25bcdxs7pv1****'),
      vSwitchName?: string(name='VSwitchName', description='The name of the vSwitch.', example='vSwitch'),
    }
  ](name='VSwitchs', description='The vSwitches.'),
}

model DescribeVSwitchesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVSwitchesResponseBody(name='body'),
}

/**
 * @summary Queries a vSwitch.
 *
 * @param request DescribeVSwitchesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVSwitchesResponse
 */
async function describeVSwitchesWithOptions(request: DescribeVSwitchesRequest, runtime: Util.RuntimeOptions): DescribeVSwitchesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVSwitches',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a vSwitch.
 *
 * @param request DescribeVSwitchesRequest
 * @return DescribeVSwitchesResponse
 */
async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVSwitchesWithOptions(request, runtime);
}

model DescribeVpcsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', example='3'),
  pageSize?: int32(name='PageSize', example='30'),
  product?: string(name='Product', example='VPN'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-acfmzh544n3j3bi'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  vpcId?: string(name='VpcId', example='vpc-*************'),
  zoneId?: string(name='ZoneId', example='cn-hangzhou-i'),
}

model DescribeVpcsResponseBody = {
  pageNumber?: int32(name='PageNumber', example='2'),
  pageSize?: int32(name='PageSize', example='50'),
  requestId?: string(name='RequestId', example='11FDB5A0-84F5-5361-B729-5770B0AEB9D5'),
  totalCount?: int32(name='TotalCount', example='50'),
  vpcs?: [ 
    {
      aliUid?: string(name='AliUid', example='1868512340232755'),
      bid?: string(name='Bid', example='26842'),
      cidrBlock?: string(name='CidrBlock', example='57.100.6.59/32'),
      gmtCreate?: string(name='GmtCreate', example='2021-04-18T15:02:37Z'),
      gmtModified?: string(name='GmtModified', example='2021-04-18T15:02:37Z'),
      isDefault?: boolean(name='IsDefault', example='true'),
      regionNo?: string(name='RegionNo', example='cn-chengdu-wt97-a01'),
      status?: string(name='Status', example='Pending'),
      vSwitchs?: [ 
        {
          cidrBlock?: string(name='CidrBlock', example='47.118.126.0/25'),
          gmtCreate?: string(name='GmtCreate', example='2021-04-18T15:02:37Z'),
          gmtModified?: string(name='GmtModified', example='2021-04-18T15:02:37Z'),
          isDefault?: boolean(name='IsDefault', example='false'),
          izNo?: string(name='IzNo', example='cn-shenzhen-f'),
          status?: string(name='Status', example='Pending'),
          vSwitchId?: string(name='VSwitchId', example='vsw-uf6fus5py6hbvxqwzwnk8'),
          vSwitchName?: string(name='VSwitchName', example='default-sw'),
        }
      ](name='VSwitchs'),
      vpcId?: string(name='VpcId', example='vpc-bp16efwqjzyumc23c647v'),
      vpcName?: string(name='VpcName', example='vpc-e2e-10341f3'),
    }
  ](name='Vpcs'),
}

model DescribeVpcsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVpcsResponseBody(name='body'),
}

/**
 * @summary 查询vpc
 *
 * @param request DescribeVpcsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpcsResponse
 */
async function describeVpcsWithOptions(request: DescribeVpcsRequest, runtime: Util.RuntimeOptions): DescribeVpcsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVpcs',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询vpc
 *
 * @param request DescribeVpcsRequest
 * @return DescribeVpcsResponse
 */
async function describeVpcs(request: DescribeVpcsRequest): DescribeVpcsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcsWithOptions(request, runtime);
}

model DescribeZonesRequest {
  engine?: string(name='Engine', example='POLARDB'),
  extra?: string(name='Extra', example='local'),
  regionId?: string(name='RegionId', example='cn-zhangjiakou'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId', example='E2FDB684-751D-424D-98B9-704BEA******'),
  zones?: [ 
    {
      modeCode?: string(name='ModeCode', example='UnSet'),
      priority?: string(name='Priority', example='50'),
      status?: string(name='Status', example='ON'),
      zoneId?: string(name='ZoneId', example='cn-beijing-h'),
    }
  ](name='Zones'),
}

model DescribeZonesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeZonesResponseBody(name='body'),
}

/**
 * @summary 获取可用区
 *
 * @param request DescribeZonesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeZonesResponse
 */
async function describeZonesWithOptions(request: DescribeZonesRequest, runtime: Util.RuntimeOptions): DescribeZonesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.extra)) {
    query['Extra'] = request.extra;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeZones',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取可用区
 *
 * @param request DescribeZonesRequest
 * @return DescribeZonesResponse
 */
async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeZonesWithOptions(request, runtime);
}

model DisableDBClusterOrcaRequest {
  cleanData?: string(name='CleanData', example='Enable'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DisableDBClusterOrcaResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-***************'),
  requestId?: string(name='RequestId', description='Id of the request', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model DisableDBClusterOrcaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableDBClusterOrcaResponseBody(name='body'),
}

/**
 * @summary 关闭集群的关系性
 *
 * @param request DisableDBClusterOrcaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableDBClusterOrcaResponse
 */
async function disableDBClusterOrcaWithOptions(request: DisableDBClusterOrcaRequest, runtime: Util.RuntimeOptions): DisableDBClusterOrcaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cleanData)) {
    query['CleanData'] = request.cleanData;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableDBClusterOrca',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 关闭集群的关系性
 *
 * @param request DisableDBClusterOrcaRequest
 * @return DisableDBClusterOrcaResponse
 */
async function disableDBClusterOrca(request: DisableDBClusterOrcaRequest): DisableDBClusterOrcaResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableDBClusterOrcaWithOptions(request, runtime);
}

model DisableDBClusterServerlessRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-***************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DisableDBClusterServerlessResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the serverless cluster.', example='pc-****************'),
  requestId?: string(name='RequestId', description='The request ID.', example='CD3FA5F3-FAF3-44CA-AFFF-BAF869******'),
}

model DisableDBClusterServerlessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableDBClusterServerlessResponseBody(name='body'),
}

/**
 * @summary Disables a stable serverless cluster.
 *
 * @param request DisableDBClusterServerlessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableDBClusterServerlessResponse
 */
async function disableDBClusterServerlessWithOptions(request: DisableDBClusterServerlessRequest, runtime: Util.RuntimeOptions): DisableDBClusterServerlessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableDBClusterServerless',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disables a stable serverless cluster.
 *
 * @param request DisableDBClusterServerlessRequest
 * @return DisableDBClusterServerlessResponse
 */
async function disableDBClusterServerless(request: DisableDBClusterServerlessRequest): DisableDBClusterServerlessResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableDBClusterServerlessWithOptions(request, runtime);
}

model EnableDBClusterOrcaRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model EnableDBClusterOrcaResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-***************'),
  requestId?: string(name='RequestId', description='Id of the request', example='24A1990B-4F6E-482B-B8CB-75C612******'),
}

model EnableDBClusterOrcaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableDBClusterOrcaResponseBody(name='body'),
}

/**
 * @summary 开启集群的关系性
 *
 * @param request EnableDBClusterOrcaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableDBClusterOrcaResponse
 */
async function enableDBClusterOrcaWithOptions(request: EnableDBClusterOrcaRequest, runtime: Util.RuntimeOptions): EnableDBClusterOrcaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableDBClusterOrca',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 开启集群的关系性
 *
 * @param request EnableDBClusterOrcaRequest
 * @return EnableDBClusterOrcaResponse
 */
async function enableDBClusterOrca(request: EnableDBClusterOrcaRequest): EnableDBClusterOrcaResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableDBClusterOrcaWithOptions(request, runtime);
}

model EnableDBClusterServerlessRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scaleApRoNumMax?: string(name='ScaleApRoNumMax', description='The maximum number of stable AP read-only nodes. Valid values: 0 to 7.', example='1'),
  scaleApRoNumMin?: string(name='ScaleApRoNumMin', description='The minimum number of stable AP read-only nodes. Valid values: 0 to 7.', example='1'),
  scaleMax?: string(name='ScaleMax', description='The maximum number of PCUs per node for scaling. Valid values: 1 to 8 PCUs.', example='2'),
  scaleMin?: string(name='ScaleMin', description='The minimum number of PolarDB capacity units (PCUs) per node for scaling. Valid values: 1 to 8 PCUs.', example='1'),
  scaleRoNumMax?: string(name='ScaleRoNumMax', description='The maximum number of read-only nodes for scaling. Valid values: 0 to 7.', example='2'),
  scaleRoNumMin?: string(name='ScaleRoNumMin', description='The minimum number of read-only nodes for scaling. Valid values: 0 to 7.', example='1'),
}

model EnableDBClusterServerlessResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the serverless cluster.', example='pc-bp10gr51qasnl****'),
  requestId?: string(name='RequestId', description='The request ID.', example='5E71541A-6007-4DCC-A38A-F872C31FEB45'),
}

model EnableDBClusterServerlessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableDBClusterServerlessResponseBody(name='body'),
}

/**
 * @summary Enables a stable serverless cluster.
 *
 * @param request EnableDBClusterServerlessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableDBClusterServerlessResponse
 */
async function enableDBClusterServerlessWithOptions(request: EnableDBClusterServerlessRequest, runtime: Util.RuntimeOptions): EnableDBClusterServerlessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scaleApRoNumMax)) {
    query['ScaleApRoNumMax'] = request.scaleApRoNumMax;
  }
  if (!Util.isUnset(request.scaleApRoNumMin)) {
    query['ScaleApRoNumMin'] = request.scaleApRoNumMin;
  }
  if (!Util.isUnset(request.scaleMax)) {
    query['ScaleMax'] = request.scaleMax;
  }
  if (!Util.isUnset(request.scaleMin)) {
    query['ScaleMin'] = request.scaleMin;
  }
  if (!Util.isUnset(request.scaleRoNumMax)) {
    query['ScaleRoNumMax'] = request.scaleRoNumMax;
  }
  if (!Util.isUnset(request.scaleRoNumMin)) {
    query['ScaleRoNumMin'] = request.scaleRoNumMin;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableDBClusterServerless',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables a stable serverless cluster.
 *
 * @param request EnableDBClusterServerlessRequest
 * @return EnableDBClusterServerlessResponse
 */
async function enableDBClusterServerless(request: EnableDBClusterServerlessRequest): EnableDBClusterServerlessResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableDBClusterServerlessWithOptions(request, runtime);
}

model EnableFirewallRulesRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-************'),
  enable?: boolean(name='Enable', description='Specifies whether to enable or disable the specified firewall rules. Valid values:

*   **true**: enables the specified firewall rules.
*   **false**: disables the specified firewall rules.

> This parameter is valid only when you specify the **RuleNameList** parameter.', example='true'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleNameList?: string(name='RuleNameList', description='The name of the firewall rule that you want to enable for the cluster. You can specify multiple firewall rules at a time. Separate multiple rules with commas (,).

> You can call the **DescribeFirewallRules** operation to query the details of all firewall rules that are applicable to a cluster, such as rule names.

This parameter is required.', example='test111'),
}

model EnableFirewallRulesResponseBody = {
  message?: string(name='Message', description='The message that is returned for the request.

> If the request was successful, Successful is returned. If the request failed, an error message that contains information such as an error code is returned.', example='Message'),
  requestId?: string(name='RequestId', description='Id of the request', example='99B355CE-526C-478B-B730-AD9D7C******'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model EnableFirewallRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableFirewallRulesResponseBody(name='body'),
}

/**
 * @summary Modifies the status of SQL firewall rules for a cluster.
 *
 * @param request EnableFirewallRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableFirewallRulesResponse
 */
async function enableFirewallRulesWithOptions(request: EnableFirewallRulesRequest, runtime: Util.RuntimeOptions): EnableFirewallRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleNameList)) {
    query['RuleNameList'] = request.ruleNameList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableFirewallRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the status of SQL firewall rules for a cluster.
 *
 * @param request EnableFirewallRulesRequest
 * @return EnableFirewallRulesResponse
 */
async function enableFirewallRules(request: EnableFirewallRulesRequest): EnableFirewallRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableFirewallRulesWithOptions(request, runtime);
}

model EnableSQLRateLimitingRulesRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-*****************'),
  enable?: boolean(name='Enable', description='This parameter is required.', example='true'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleNameList?: string(name='RuleNameList', description='This parameter is required.', example='testrule'),
}

model EnableSQLRateLimitingRulesResponseBody = {
  message?: string(name='Message', example='Successful'),
  requestId?: string(name='RequestId', description='Id of the request', example='4CE6DF97-AEA4-484F-906F-C407EE******'),
  success?: boolean(name='Success', example='true'),
}

model EnableSQLRateLimitingRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableSQLRateLimitingRulesResponseBody(name='body'),
}

/**
 * @summary 启用/禁用SQL限流规则
 *
 * @param request EnableSQLRateLimitingRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableSQLRateLimitingRulesResponse
 */
async function enableSQLRateLimitingRulesWithOptions(request: EnableSQLRateLimitingRulesRequest, runtime: Util.RuntimeOptions): EnableSQLRateLimitingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleNameList)) {
    query['RuleNameList'] = request.ruleNameList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableSQLRateLimitingRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 启用/禁用SQL限流规则
 *
 * @param request EnableSQLRateLimitingRulesRequest
 * @return EnableSQLRateLimitingRulesResponse
 */
async function enableSQLRateLimitingRules(request: EnableSQLRateLimitingRulesRequest): EnableSQLRateLimitingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableSQLRateLimitingRulesWithOptions(request, runtime);
}

model EvaluateRegionResourceRequest {
  DBInstanceConnType?: string(name='DBInstanceConnType', description='The cluster link type. The backend randomly selects the default value. Valid values:

*   **lvs**: Linux virtual server.
*   **proxy**: proxy server.
*   **dns**: domain name system.', example='lvs'),
  DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node. For information about node specifications, see the following topics:

*   PolarDB for MySQL: [Specifications of compute nodes](https://help.aliyun.com/document_detail/102542.html)
*   PolarDB for Oracle: [Specifications of compute nodes](https://help.aliyun.com/document_detail/207921.html)
*   PolarDB for PostgreSQL: [Specifications of compute nodes](https://help.aliyun.com/document_detail/209380.html)

This parameter is required.', example='polar.mysql.x4.large'),
  DBType?: string(name='DBType', description='The type of the database engine. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**

This parameter is required.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine

*   Valid values for the MySQL database engine:

    *   **5.6**
    *   **5.7**
    *   **8.0**

*   Valid values for the PostgreSQL database engine:

    *   **11**
    *   **14**

*   Valid value for the Oracle database engine: **11**

This parameter is required.', example='8.0'),
  dispenseMode?: string(name='DispenseMode', description='Specifies whether to return the zones in which the single-zone deployment method is supported. Default value: 0. Valid values:

*   **0**: no value returned
*   **1**: returns the zones.', example='1'),
  needMaxScaleLink?: string(name='NeedMaxScaleLink', description='Specifies whether to create Maxscale. Valid values:

*   **true** (default)
*   **false**

This parameter is required.', example='true'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query available regions.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  subDomain?: string(name='SubDomain', description='The subdomain. It is the child domain of the top-level domain name or parent domain. For example, if the parent domain name is cn-beijing, its child domain can be cn-beijing-i-aliyun.', example='cn-beijing-i-aliyun'),
  zoneId?: string(name='ZoneId', description='The zone ID.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query available zones.

This parameter is required.', example='cn-hangzhou-g'),
}

model EvaluateRegionResourceResponseBody = {
  DBInstanceAvailable?: string(name='DBInstanceAvailable', description='Indicates whether sufficient resources are available. Valid values:

*   **true**
*   **false**', example='true'),
  DBType?: string(name='DBType', description='The type of the database engine. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine

*   Valid values for the MySQL database engine:

    *   **5.6**
    *   **5.7**
    *   **8.0**

*   Valid values for the PostgreSQL database engine:

    *   **11**
    *   **14**

*   Valid value for the Oracle database engine: **11**', example='8.0'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='69A85BAF-1089-4CDF-A82F-0A140F******'),
}

model EvaluateRegionResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EvaluateRegionResourceResponseBody(name='body'),
}

/**
 * @summary Evaluates available resources.
 *
 * @param request EvaluateRegionResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EvaluateRegionResourceResponse
 */
async function evaluateRegionResourceWithOptions(request: EvaluateRegionResourceRequest, runtime: Util.RuntimeOptions): EvaluateRegionResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceConnType)) {
    query['DBInstanceConnType'] = request.DBInstanceConnType;
  }
  if (!Util.isUnset(request.DBNodeClass)) {
    query['DBNodeClass'] = request.DBNodeClass;
  }
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.dispenseMode)) {
    query['DispenseMode'] = request.dispenseMode;
  }
  if (!Util.isUnset(request.needMaxScaleLink)) {
    query['NeedMaxScaleLink'] = request.needMaxScaleLink;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.subDomain)) {
    query['SubDomain'] = request.subDomain;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EvaluateRegionResource',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Evaluates available resources.
 *
 * @param request EvaluateRegionResourceRequest
 * @return EvaluateRegionResourceResponse
 */
async function evaluateRegionResource(request: EvaluateRegionResourceRequest): EvaluateRegionResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return evaluateRegionResourceWithOptions(request, runtime);
}

model ExecuteCrossCloudOpenAPIRequest {
  proxyInfo?: string(name='ProxyInfo', example='{"Action":"DescribeDBClusters"}'),
}

model ExecuteCrossCloudOpenAPIResponseBody = {
  proxyData?: string(name='ProxyData', example='{"ProxyData": "{\\\\"DBCluster\\\\":[{\\\\"AliyunRegionId\\\\":\\\\"cn-beijing\\\\",\\\\"CloudProvider\\\\":\\\\"huawei\\\\",\\\\"CreateTime\\\\":\\\\"2024-11-25T14:49:10Z\\\\",\\\\"CrossCloudRegionId\\\\":\\\\"cn-east-3\\\\",\\\\"DBClusterDescription\\\\":\\\\"\\\\",\\\\"DBClusterId\\\\":\\\\"pc-2zej3qvf5fg******\\\\",\\\\"DBClusterStatus\\\\":\\\\"Creating\\\\",\\\\"DBType\\\\":\\\\"polardb_mysql\\\\",\\\\"DBVersion\\\\":\\\\"8.0\\\\",\\\\"ProjectId\\\\":\\\\"pj-bp1m8oh1k68******\\\\"},{\\\\"AliyunRegionId\\\\":\\\\"cn-beijing\\\\",\\\\"CloudProvider\\\\":\\\\"huawei\\\\",\\\\"CreateTime\\\\":\\\\"2024-11-25T14:59:10Z\\\\",\\\\"CrossCloudRegionId\\\\":\\\\"cn-east-3\\\\",\\\\"DBClusterDescription\\\\":\\\\"\\\\",\\\\"DBClusterId\\\\":\\\\"pc-2ze29994l17******\\\\",\\\\"DBClusterStatus\\\\":\\\\"Running\\\\",\\\\"DBType\\\\":\\\\"polardb_mysql\\\\",\\\\"DBVersion\\\\":\\\\"8.0\\\\",\\\\"ProjectId\\\\":\\\\"pj-bp1m8oh1k68******\\\\"}]}","RequestId": "E56531A4-E552-40BA-9C58-137B80******"}'),
  requestId?: string(name='RequestId', example='E56531A4-E552-40BA-9C58-137B80******'),
}

model ExecuteCrossCloudOpenAPIResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExecuteCrossCloudOpenAPIResponseBody(name='body'),
}

/**
 * @summary 调用跨云 OpenAPI
 *
 * @param request ExecuteCrossCloudOpenAPIRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExecuteCrossCloudOpenAPIResponse
 */
async function executeCrossCloudOpenAPIWithOptions(request: ExecuteCrossCloudOpenAPIRequest, runtime: Util.RuntimeOptions): ExecuteCrossCloudOpenAPIResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.proxyInfo)) {
    query['ProxyInfo'] = request.proxyInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteCrossCloudOpenAPI',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 调用跨云 OpenAPI
 *
 * @param request ExecuteCrossCloudOpenAPIRequest
 * @return ExecuteCrossCloudOpenAPIResponse
 */
async function executeCrossCloudOpenAPI(request: ExecuteCrossCloudOpenAPIRequest): ExecuteCrossCloudOpenAPIResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeCrossCloudOpenAPIWithOptions(request, runtime);
}

model FailoverDBClusterRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5******'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  rollBackForDisaster?: boolean(name='RollBackForDisaster', description='Specifies whether to switch back services to the original primary zone when the original primary zone recovers.

*   true
*   false', example='false'),
  targetDBNodeId?: string(name='TargetDBNodeId', description='The ID of the read-only node that you want to promote to the primary node. You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query node information, such as node IDs.

> *   If you leave this parameter empty, the system selects one or more available read-only nodes that have the highest failover priority as candidate primary nodes. If the failover to the first read-only node fails due to network issues, abnormal replication status, or other reasons, the system attempts to fail over your applications to the next read-only node until the failover is successful.
>*  This parameter is required for PolarDB for Oracle and PolarDB for PostgreSQL clusters. This parameter is optional for PolarDB for MySQL clusters.', example='pi-***********'),
  targetZoneType?: string(name='TargetZoneType', description='Whether it is a primary-standby switch within the primary availability zone, with the following values:

Primary: Primary-standby switch within the primary availability zone.
Standby: Switch to the storage hot backup cluster.', example='Primary'),
}

model FailoverDBClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model FailoverDBClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: FailoverDBClusterResponseBody(name='body'),
}

/**
 * @summary Performs a manual failover to promote a read-only node to the primary node in a PolarDB cluster.
 *
 * @param request FailoverDBClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return FailoverDBClusterResponse
 */
async function failoverDBClusterWithOptions(request: FailoverDBClusterRequest, runtime: Util.RuntimeOptions): FailoverDBClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.rollBackForDisaster)) {
    query['RollBackForDisaster'] = request.rollBackForDisaster;
  }
  if (!Util.isUnset(request.targetDBNodeId)) {
    query['TargetDBNodeId'] = request.targetDBNodeId;
  }
  if (!Util.isUnset(request.targetZoneType)) {
    query['TargetZoneType'] = request.targetZoneType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FailoverDBCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Performs a manual failover to promote a read-only node to the primary node in a PolarDB cluster.
 *
 * @param request FailoverDBClusterRequest
 * @return FailoverDBClusterResponse
 */
async function failoverDBCluster(request: FailoverDBClusterRequest): FailoverDBClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return failoverDBClusterWithOptions(request, runtime);
}

model FailoverDBClusterZonalRequest {
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5******'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  rollBackForDisaster?: boolean(name='RollBackForDisaster', example='false'),
  targetDBNodeId?: string(name='TargetDBNodeId', example='pi-***********'),
  targetZoneType?: string(name='TargetZoneType', example='Primary'),
}

model FailoverDBClusterZonalResponseBody = {
  requestId?: string(name='RequestId', example='925B84D9-CA72-432C-95CF-738C22******'),
}

model FailoverDBClusterZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: FailoverDBClusterZonalResponseBody(name='body'),
}

/**
 * @summary 角色切换
 *
 * @param request FailoverDBClusterZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return FailoverDBClusterZonalResponse
 */
async function failoverDBClusterZonalWithOptions(request: FailoverDBClusterZonalRequest, runtime: Util.RuntimeOptions): FailoverDBClusterZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.rollBackForDisaster)) {
    query['RollBackForDisaster'] = request.rollBackForDisaster;
  }
  if (!Util.isUnset(request.targetDBNodeId)) {
    query['TargetDBNodeId'] = request.targetDBNodeId;
  }
  if (!Util.isUnset(request.targetZoneType)) {
    query['TargetZoneType'] = request.targetZoneType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FailoverDBClusterZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 角色切换
 *
 * @param request FailoverDBClusterZonalRequest
 * @return FailoverDBClusterZonalResponse
 */
async function failoverDBClusterZonal(request: FailoverDBClusterZonalRequest): FailoverDBClusterZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return failoverDBClusterZonalWithOptions(request, runtime);
}

model GenerateUpgradeReportForSyncCloneRequest {
  creationCategory?: string(name='CreationCategory', example='Normal'),
  creationOption?: string(name='CreationOption', example='MigrationFromRDS'),
  DBName?: string(name='DBName', example='testDB'),
  DBType?: string(name='DBType', example='PostgreSQL'),
  DBVersion?: string(name='DBVersion', example='5.6'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  reserve?: string(name='Reserve', example='{\\\\"targetTableMode\\\\":2}'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceDBClusterId?: string(name='SourceDBClusterId', example='pc-k2j96w169uhu868l8'),
}

model GenerateUpgradeReportForSyncCloneResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='CDB3258F-B5DE-43C4-8935-CBA0CA******'),
  sourceDBClusterId?: string(name='SourceDBClusterId', example='pc-k2j96w169uhu868l8'),
  taskId?: long(name='TaskId', example='2312111'),
}

model GenerateUpgradeReportForSyncCloneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GenerateUpgradeReportForSyncCloneResponseBody(name='body'),
}

/**
 * @summary 生成校验报告
 *
 * @param request GenerateUpgradeReportForSyncCloneRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateUpgradeReportForSyncCloneResponse
 */
async function generateUpgradeReportForSyncCloneWithOptions(request: GenerateUpgradeReportForSyncCloneRequest, runtime: Util.RuntimeOptions): GenerateUpgradeReportForSyncCloneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.creationCategory)) {
    query['CreationCategory'] = request.creationCategory;
  }
  if (!Util.isUnset(request.creationOption)) {
    query['CreationOption'] = request.creationOption;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.DBType)) {
    query['DBType'] = request.DBType;
  }
  if (!Util.isUnset(request.DBVersion)) {
    query['DBVersion'] = request.DBVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.reserve)) {
    query['Reserve'] = request.reserve;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceDBClusterId)) {
    query['SourceDBClusterId'] = request.sourceDBClusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateUpgradeReportForSyncClone',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 生成校验报告
 *
 * @param request GenerateUpgradeReportForSyncCloneRequest
 * @return GenerateUpgradeReportForSyncCloneResponse
 */
async function generateUpgradeReportForSyncClone(request: GenerateUpgradeReportForSyncCloneRequest): GenerateUpgradeReportForSyncCloneResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateUpgradeReportForSyncCloneWithOptions(request, runtime);
}

model GrantAccountPrivilegeRequest {
  accountName?: string(name='AccountName', description='The username of the account.

This parameter is required.', example='testacc'),
  accountPrivilege?: string(name='AccountPrivilege', description='The permissions that are granted to the account. Valid values:

*   **ReadWrite**: read and write permissions
*   **ReadOnly**: read-only permissions
*   **DMLOnly**: The account is granted the permissions to execute only DML statements on the database.
*   **DDLOnly**: The account is granted the permissions to execute only DDL statements on the database.
*   **ReadIndex**: The account has the read and index permissions on the database.

> The number of **AccountPrivilege** values must be the consistent with the number of **DBName** values. Each account permission must correspond to a database name in sequence. For example, you can set **DBName** to `testdb_1,testdb_2` and set **AccountPrivilege** to `ReadWrite,ReadOnly`. In this case, the specified standard account is granted the **read and write** permissions on the **testdb_1** database and the **read** permission on the **testdb_2** database.

This parameter is required.', example='ReadWrite,ReadOnly'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-****************'),
  DBName?: string(name='DBName', description='The names of the databases that the account can access. You can grant the access permissions on one or more databases to the specified standard account. If you need to specify multiple database names, separate the database names with commas (,).

This parameter is required.', example='testdb_1,testdb_2'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GrantAccountPrivilegeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627*****'),
}

model GrantAccountPrivilegeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GrantAccountPrivilegeResponseBody(name='body'),
}

/**
 * @summary Grants a standard account the permissions to access one or more databases in a specified PolarDB cluster.
 *
 * @description > *   An account can be authorized to access one or more databases.
 * > *   If the specified account already has the access permissions on the specified databases, the operation returns a successful response.
 * > *   Before you call this operation, make sure that the cluster is in the Running state. Otherwise, the operation fails.
 * > *   You can call this operation only on a PolarDB for MySQL cluster.
 * > *   By default, a privileged account for a cluster has all the permissions on the databases in the cluster.
 *
 * @param request GrantAccountPrivilegeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantAccountPrivilegeResponse
 */
async function grantAccountPrivilegeWithOptions(request: GrantAccountPrivilegeRequest, runtime: Util.RuntimeOptions): GrantAccountPrivilegeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPrivilege)) {
    query['AccountPrivilege'] = request.accountPrivilege;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GrantAccountPrivilege',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Grants a standard account the permissions to access one or more databases in a specified PolarDB cluster.
 *
 * @description > *   An account can be authorized to access one or more databases.
 * > *   If the specified account already has the access permissions on the specified databases, the operation returns a successful response.
 * > *   Before you call this operation, make sure that the cluster is in the Running state. Otherwise, the operation fails.
 * > *   You can call this operation only on a PolarDB for MySQL cluster.
 * > *   By default, a privileged account for a cluster has all the permissions on the databases in the cluster.
 *
 * @param request GrantAccountPrivilegeRequest
 * @return GrantAccountPrivilegeResponse
 */
async function grantAccountPrivilege(request: GrantAccountPrivilegeRequest): GrantAccountPrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  return grantAccountPrivilegeWithOptions(request, runtime);
}

model GrantAccountPrivilegeZonalRequest {
  accountName?: string(name='AccountName', description='This parameter is required.', example='testacc'),
  accountPrivilege?: string(name='AccountPrivilege', description='This parameter is required.', example='ReadWrite,ReadOnly'),
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f5********************'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-****************'),
  DBName?: string(name='DBName', description='This parameter is required.', example='testdb_1,testdb_2'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GrantAccountPrivilegeZonalResponseBody = {
  requestId?: string(name='RequestId', example='CD35F3-F3-44CA-AFFF-BAF869******'),
}

model GrantAccountPrivilegeZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GrantAccountPrivilegeZonalResponseBody(name='body'),
}

/**
 * @summary 修改PolarDB边缘集群的账号权限
 *
 * @param request GrantAccountPrivilegeZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantAccountPrivilegeZonalResponse
 */
async function grantAccountPrivilegeZonalWithOptions(request: GrantAccountPrivilegeZonalRequest, runtime: Util.RuntimeOptions): GrantAccountPrivilegeZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPrivilege)) {
    query['AccountPrivilege'] = request.accountPrivilege;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GrantAccountPrivilegeZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改PolarDB边缘集群的账号权限
 *
 * @param request GrantAccountPrivilegeZonalRequest
 * @return GrantAccountPrivilegeZonalResponse
 */
async function grantAccountPrivilegeZonal(request: GrantAccountPrivilegeZonalRequest): GrantAccountPrivilegeZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return grantAccountPrivilegeZonalWithOptions(request, runtime);
}

model ListOrdersRequest {
  category?: string(name='Category', example='Normal'),
  instanceId?: string(name='InstanceId', example='pc-2zed3m89cw***'),
  maxResults?: int32(name='MaxResults', example='10'),
  nextToken?: string(name='NextToken', example='212db86sca4384811e0b5e8707e******'),
  orderStatus?: string(name='OrderStatus', example='completed'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  productCode?: string(name='ProductCode', example='polardb'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-************'),
}

model ListOrdersResponseBody = {
  maxResults?: int32(name='MaxResults', example='10'),
  nextToken?: string(name='NextToken', example='212db86sca4384811e0b5e8707e******'),
  orderList?: [ 
    {
      aliUid?: string(name='AliUid', example='1910740440664****'),
      chargeType?: string(name='ChargeType', example='Prepaid'),
      commodityCode?: string(name='CommodityCode', example='polardb_payg_intl'),
      createdTime?: string(name='CreatedTime', example='2021-03-31T16:09:13'),
      instanceId?: string(name='InstanceId', example='pc-uf6k532gav*******'),
      orderId?: string(name='OrderId', example='25808743077*****'),
      orderStatus?: string(name='OrderStatus', example='completed'),
      orderType?: string(name='OrderType', example='BUY'),
      produceCode?: string(name='ProduceCode', example='polardb'),
      region?: string(name='Region', example='cn-hangzhou'),
    }
  ](name='OrderList', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  requestId?: string(name='RequestId', example='3AA69096-757C-4647-B36C-29EBC2******'),
  totalCount?: int32(name='TotalCount', example='7'),
}

model ListOrdersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOrdersResponseBody(name='body'),
}

/**
 * @summary 查询订单
 *
 * @param request ListOrdersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOrdersResponse
 */
async function listOrdersWithOptions(request: ListOrdersRequest, runtime: Util.RuntimeOptions): ListOrdersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.orderStatus)) {
    query['OrderStatus'] = request.orderStatus;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOrders',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询订单
 *
 * @param request ListOrdersRequest
 * @return ListOrdersResponse
 */
async function listOrders(request: ListOrdersRequest): ListOrdersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOrdersWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', description='The token required to obtain more results. This parameter is not required in the first query. If the first query does not return all results, you can use the token that is returned from the first query in the next query to obtain more results.', example='212db86sca4384811e0b5e8707e******'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query available region IDs.

This parameter is required.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The IDs of the clusters. To query the tags of multiple clusters, click **Add** to add cluster IDs.

> 

*   You must specify at least one of the `ResourceId.N` and `Tag.N.Key` parameters.

*   If you specify the `ResourceId.N` parameter, you can add a maximum of 50 cluster IDs at a time.', example='pc-****************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Set the value to **cluster**.

This parameter is required.', example='cluster'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. To query the details of clusters to which multiple tags are added, click **Add** to add tags.

> 

*   You must specify at least one of the `ResourceId.N` and `Tag.N.Key` parameters.

*   If you specify the `Tag.N.Key` parameter, you can create up to 20 tags at a time.', example='type'),
      value?: string(name='Value', description='The tag value that is paired with the tag key. This parameter can be set to an empty string.', example='test'),
    }
  ](name='Tag', description='The tags.'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='The token required to obtain more results. If not all results are returned in this query, the token is returned. You can use this token in the next query to obtain more results.', example='212db86sca4384811e0b5e8707e******'),
  requestId?: string(name='RequestId', description='The request ID.', example='688C04E4-23F8-409F-8A38-B954D5******'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId', description='The cluster ID.', example='pc-****************'),
      resourceType?: string(name='ResourceType', description='The type of the resource. This parameter is set to **cluster**.', example='cluster'),
      tagKey?: string(name='TagKey', description='The key of the tag.', example='type'),
      tagValue?: string(name='TagValue', description='The value of the tag.', example='test'),
    }
  ](name='TagResource')
  }(name='TagResources', description='The details of the queried clusters and tags.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
 * @summary Queries the tags that are added to one or more PolarDB clusters, or the PolarDB clusters to which one or more tags are added.
 *
 * @param request ListTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the tags that are added to one or more PolarDB clusters, or the PolarDB clusters to which one or more tags are added.
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListTagResourcesForRegionRequest {
  nextToken?: string(name='NextToken', example='212db86sca4384811e0b5e8707e******'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='This parameter is required.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType', example='aicluster'),
}

model ListTagResourcesForRegionResponseBody = {
  nextToken?: string(name='NextToken', example='212db86sca4384811e0b5e8707e******'),
  requestId?: string(name='RequestId', example='688C04E4-23F8-409F-8A38-B954D5******'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId', example='pc-****************'),
      resourceType?: string(name='ResourceType', example='cluster'),
      tagKey?: string(name='TagKey', example='type'),
      tagValue?: string(name='TagValue', example='test'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesForRegionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesForRegionResponseBody(name='body'),
}

/**
 * @param request ListTagResourcesForRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesForRegionResponse
 */
async function listTagResourcesForRegionWithOptions(request: ListTagResourcesForRegionRequest, runtime: Util.RuntimeOptions): ListTagResourcesForRegionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResourcesForRegion',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListTagResourcesForRegionRequest
 * @return ListTagResourcesForRegionResponse
 */
async function listTagResourcesForRegion(request: ListTagResourcesForRegionRequest): ListTagResourcesForRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesForRegionWithOptions(request, runtime);
}

model ManuallyStartDBClusterRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-xxxxxxxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query available regions.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ManuallyStartDBClusterResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='73A85BAF-1039-4CDE-A83F-1A140F******'),
}

model ManuallyStartDBClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ManuallyStartDBClusterResponseBody(name='body'),
}

/**
 * @summary Manually starts a cluster.
 *
 * @param request ManuallyStartDBClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ManuallyStartDBClusterResponse
 */
async function manuallyStartDBClusterWithOptions(request: ManuallyStartDBClusterRequest, runtime: Util.RuntimeOptions): ManuallyStartDBClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ManuallyStartDBCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Manually starts a cluster.
 *
 * @param request ManuallyStartDBClusterRequest
 * @return ManuallyStartDBClusterResponse
 */
async function manuallyStartDBCluster(request: ManuallyStartDBClusterRequest): ManuallyStartDBClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return manuallyStartDBClusterWithOptions(request, runtime);
}

model ModifyAIDBClusterDescriptionRequest {
  DBClusterDescription?: string(name='DBClusterDescription', description='This parameter is required.', example='test'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyAIDBClusterDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='CD3FA5F3-FAF3-44CA-AFFF-BAF869******'),
}

model ModifyAIDBClusterDescriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAIDBClusterDescriptionResponseBody(name='body'),
}

/**
 * @summary 修改AI实例名称
 *
 * @param request ModifyAIDBClusterDescriptionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAIDBClusterDescriptionResponse
 */
async function modifyAIDBClusterDescriptionWithOptions(request: ModifyAIDBClusterDescriptionRequest, runtime: Util.RuntimeOptions): ModifyAIDBClusterDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterDescription)) {
    query['DBClusterDescription'] = request.DBClusterDescription;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAIDBClusterDescription',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改AI实例名称
 *
 * @param request ModifyAIDBClusterDescriptionRequest
 * @return ModifyAIDBClusterDescriptionResponse
 */
async function modifyAIDBClusterDescription(request: ModifyAIDBClusterDescriptionRequest): ModifyAIDBClusterDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAIDBClusterDescriptionWithOptions(request, runtime);
}

model ModifyAccountDescriptionRequest {
  accountDescription?: string(name='AccountDescription', description='The description of the account. The description must meet the following requirements:

*   The description cannot start with `http://` or `https://`.
*   The description must be 2 to 256 characters in length.

This parameter is required.', example='test'),
  accountName?: string(name='AccountName', description='The name of the account.

This parameter is required.', example='testacc'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyAccountDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model ModifyAccountDescriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAccountDescriptionResponseBody(name='body'),
}

/**
 * @summary Modifies the description of a database account of a PolarDB cluster.
 *
 * @param request ModifyAccountDescriptionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAccountDescriptionResponse
 */
async function modifyAccountDescriptionWithOptions(request: ModifyAccountDescriptionRequest, runtime: Util.RuntimeOptions): ModifyAccountDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDescription)) {
    query['AccountDescription'] = request.accountDescription;
  }
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAccountDescription',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the description of a database account of a PolarDB cluster.
 *
 * @param request ModifyAccountDescriptionRequest
 * @return ModifyAccountDescriptionResponse
 */
async function modifyAccountDescription(request: ModifyAccountDescriptionRequest): ModifyAccountDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAccountDescriptionWithOptions(request, runtime);
}

model ModifyAccountDescriptionZonalRequest {
  accountDescription?: string(name='AccountDescription', description='This parameter is required.', example='testdes'),
  accountName?: string(name='AccountName', description='This parameter is required.', example='testacc'),
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f5********************'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyAccountDescriptionZonalResponseBody = {
  requestId?: string(name='RequestId', example='EB07CFF0-D8A4-5C76-AED7-D00E26FC2***'),
}

model ModifyAccountDescriptionZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAccountDescriptionZonalResponseBody(name='body'),
}

/**
 * @summary 修改PolarDB边缘云账号的描述
 *
 * @param request ModifyAccountDescriptionZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAccountDescriptionZonalResponse
 */
async function modifyAccountDescriptionZonalWithOptions(request: ModifyAccountDescriptionZonalRequest, runtime: Util.RuntimeOptions): ModifyAccountDescriptionZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDescription)) {
    query['AccountDescription'] = request.accountDescription;
  }
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAccountDescriptionZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改PolarDB边缘云账号的描述
 *
 * @param request ModifyAccountDescriptionZonalRequest
 * @return ModifyAccountDescriptionZonalResponse
 */
async function modifyAccountDescriptionZonal(request: ModifyAccountDescriptionZonalRequest): ModifyAccountDescriptionZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAccountDescriptionZonalWithOptions(request, runtime);
}

model ModifyAccountLockStateRequest {
  accountLockState?: string(name='AccountLockState', description='This parameter is required.', example='Lock'),
  accountName?: string(name='AccountName', description='This parameter is required.', example='your_account_name'),
  accountPasswordValidTime?: string(name='AccountPasswordValidTime', example='2026-09-17 10:00:00'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-***'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyAccountLockStateResponseBody = {
  requestId?: string(name='RequestId', example='B762E8C5-0129-51DB-80C8-********'),
}

model ModifyAccountLockStateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAccountLockStateResponseBody(name='body'),
}

/**
 * @param request ModifyAccountLockStateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAccountLockStateResponse
 */
async function modifyAccountLockStateWithOptions(request: ModifyAccountLockStateRequest, runtime: Util.RuntimeOptions): ModifyAccountLockStateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountLockState)) {
    query['AccountLockState'] = request.accountLockState;
  }
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPasswordValidTime)) {
    query['AccountPasswordValidTime'] = request.accountPasswordValidTime;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAccountLockState',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ModifyAccountLockStateRequest
 * @return ModifyAccountLockStateResponse
 */
async function modifyAccountLockState(request: ModifyAccountLockStateRequest): ModifyAccountLockStateResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAccountLockStateWithOptions(request, runtime);
}

model ModifyAccountPasswordRequest {
  accountName?: string(name='AccountName', description='The username of the account.

This parameter is required.', example='testacc'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-************'),
  newAccountPassword?: string(name='NewAccountPassword', description='The new password of the account. The new password must meet the following requirements:

*   It must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.
*   It must be 8 to 32 characters in length.
*   Special characters include `! @ # $ % ^ & * ( ) _ + - =`

This parameter is required.', example='Pw123456'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  passwordType?: string(name='PasswordType', description='The password type.', example='Tair'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyAccountPasswordResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model ModifyAccountPasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAccountPasswordResponseBody(name='body'),
}

/**
 * @summary Changes the password of a database account for a specified PolarDB cluster.
 *
 * @param request ModifyAccountPasswordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAccountPasswordResponse
 */
async function modifyAccountPasswordWithOptions(request: ModifyAccountPasswordRequest, runtime: Util.RuntimeOptions): ModifyAccountPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.newAccountPassword)) {
    query['NewAccountPassword'] = request.newAccountPassword;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.passwordType)) {
    query['PasswordType'] = request.passwordType;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAccountPassword',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the password of a database account for a specified PolarDB cluster.
 *
 * @param request ModifyAccountPasswordRequest
 * @return ModifyAccountPasswordResponse
 */
async function modifyAccountPassword(request: ModifyAccountPasswordRequest): ModifyAccountPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAccountPasswordWithOptions(request, runtime);
}

model ModifyAccountPasswordZonalRequest {
  accountName?: string(name='AccountName', description='This parameter is required.', example='testacc'),
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f5********************'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  newAccountPassword?: string(name='NewAccountPassword', description='This parameter is required.', example='Pw123456'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  passwordType?: string(name='PasswordType', example='Tair'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyAccountPasswordZonalResponseBody = {
  requestId?: string(name='RequestId', example='925B84D9-CA72-432C-95CF-738C22******'),
}

model ModifyAccountPasswordZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAccountPasswordZonalResponseBody(name='body'),
}

/**
 * @summary 修改PolarDB边缘的账号密码
 *
 * @param request ModifyAccountPasswordZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAccountPasswordZonalResponse
 */
async function modifyAccountPasswordZonalWithOptions(request: ModifyAccountPasswordZonalRequest, runtime: Util.RuntimeOptions): ModifyAccountPasswordZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.newAccountPassword)) {
    query['NewAccountPassword'] = request.newAccountPassword;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.passwordType)) {
    query['PasswordType'] = request.passwordType;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAccountPasswordZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改PolarDB边缘的账号密码
 *
 * @param request ModifyAccountPasswordZonalRequest
 * @return ModifyAccountPasswordZonalResponse
 */
async function modifyAccountPasswordZonal(request: ModifyAccountPasswordZonalRequest): ModifyAccountPasswordZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAccountPasswordZonalWithOptions(request, runtime);
}

model ModifyActiveOperationMaintainConfRequest {
  comment?: string(name='Comment', example='test'),
  cycleTime?: string(name='CycleTime', description='This parameter is required.', example='1'),
  cycleType?: string(name='CycleType', description='This parameter is required.', example='Week'),
  maintainEndTime?: string(name='MaintainEndTime', description='This parameter is required.', example='12:00Z'),
  maintainStartTime?: string(name='MaintainStartTime', description='This parameter is required.', example='8:00Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='This parameter is required.', example='cn-chengdu'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  status?: long(name='Status', description='This parameter is required.', example='1'),
}

model ModifyActiveOperationMaintainConfResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='1CC9CB4B-BBAF-5963-9545-A8DE9FFC7DFB'),
}

model ModifyActiveOperationMaintainConfResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyActiveOperationMaintainConfResponseBody(name='body'),
}

/**
 * @summary 配置用户的运维信息，目前包括主动运维窗口信息
 *
 * @param request ModifyActiveOperationMaintainConfRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyActiveOperationMaintainConfResponse
 */
async function modifyActiveOperationMaintainConfWithOptions(request: ModifyActiveOperationMaintainConfRequest, runtime: Util.RuntimeOptions): ModifyActiveOperationMaintainConfResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.cycleTime)) {
    query['CycleTime'] = request.cycleTime;
  }
  if (!Util.isUnset(request.cycleType)) {
    query['CycleType'] = request.cycleType;
  }
  if (!Util.isUnset(request.maintainEndTime)) {
    query['MaintainEndTime'] = request.maintainEndTime;
  }
  if (!Util.isUnset(request.maintainStartTime)) {
    query['MaintainStartTime'] = request.maintainStartTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyActiveOperationMaintainConf',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 配置用户的运维信息，目前包括主动运维窗口信息
 *
 * @param request ModifyActiveOperationMaintainConfRequest
 * @return ModifyActiveOperationMaintainConfResponse
 */
async function modifyActiveOperationMaintainConf(request: ModifyActiveOperationMaintainConfRequest): ModifyActiveOperationMaintainConfResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyActiveOperationMaintainConfWithOptions(request, runtime);
}

model ModifyActiveOperationTasksRequest {
  immediateStart?: int32(name='ImmediateStart', description='Specifies whether to immediately start scheduling. Valid values:

*   0: No. This is the default value.
*   1: Yes.

> 

*   If you set this parameter to 0, you must specify the SwitchTime parameter.

*   If you set this parameter to 1, the SwitchTime parameter does not take effect. In this case, the start time of the event is set to the current time, and the system determines the switching time based on the start time. Scheduling is started immediately, which is a prerequisite for the switchover. Then, the switchover is performed. You can call the DescribeActiveOperationTasks operation and check the return value of the PrepareInterval parameter for the preparation time.', example='0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.

>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the region information about all clusters within a specified account.

This parameter is required.', example='cn-beijing'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  switchTime?: string(name='SwitchTime', description='The scheduled switching time that you want to specify. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

> 

*   The time that is specified by this parameter cannot be later than the latest execution time.

*   You can call the DescribeActiveOperationTasks operation and check the return value of the Deadline parameter for the latest execution time.', example='2023-04-25T06:00:00Z'),
  taskIds?: string(name='TaskIds', description='The task IDs.

This parameter is required.', example='11111,22222'),
}

model ModifyActiveOperationTasksResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='42CD2EF5-D77E-5AD4-961B-159330D98286'),
  taskIds?: string(name='TaskIds', description='The task IDs.', example='11111,22222'),
}

model ModifyActiveOperationTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyActiveOperationTasksResponseBody(name='body'),
}

/**
 * @summary Modifies the switching time of scheduled O\\&M events for an instance.
 *
 * @param request ModifyActiveOperationTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyActiveOperationTasksResponse
 */
async function modifyActiveOperationTasksWithOptions(request: ModifyActiveOperationTasksRequest, runtime: Util.RuntimeOptions): ModifyActiveOperationTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.immediateStart)) {
    query['ImmediateStart'] = request.immediateStart;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.switchTime)) {
    query['SwitchTime'] = request.switchTime;
  }
  if (!Util.isUnset(request.taskIds)) {
    query['TaskIds'] = request.taskIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyActiveOperationTasks',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the switching time of scheduled O\\&M events for an instance.
 *
 * @param request ModifyActiveOperationTasksRequest
 * @return ModifyActiveOperationTasksResponse
 */
async function modifyActiveOperationTasks(request: ModifyActiveOperationTasksRequest): ModifyActiveOperationTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyActiveOperationTasksWithOptions(request, runtime);
}

model ModifyApplicationDescriptionRequest {
  applicationId?: string(name='ApplicationId', description='This parameter is required.', example='pa-**************'),
  description?: string(name='Description', description='This parameter is required.', example='my app'),
}

model ModifyApplicationDescriptionResponseBody = {
  applicationId?: string(name='ApplicationId', example='pa-**************'),
  requestId?: string(name='RequestId', example='3E5CD764-FCCA-5C9C-838E-20E0DE84B2AF'),
}

model ModifyApplicationDescriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyApplicationDescriptionResponseBody(name='body'),
}

/**
 * @summary 修改应用描述
 *
 * @param request ModifyApplicationDescriptionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyApplicationDescriptionResponse
 */
async function modifyApplicationDescriptionWithOptions(request: ModifyApplicationDescriptionRequest, runtime: Util.RuntimeOptions): ModifyApplicationDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationId)) {
    query['ApplicationId'] = request.applicationId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyApplicationDescription',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改应用描述
 *
 * @param request ModifyApplicationDescriptionRequest
 * @return ModifyApplicationDescriptionResponse
 */
async function modifyApplicationDescription(request: ModifyApplicationDescriptionRequest): ModifyApplicationDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyApplicationDescriptionWithOptions(request, runtime);
}

model ModifyApplicationParameterRequest {
  applicationId?: string(name='ApplicationId', description='This parameter is required.', example='pa-**************'),
  parameterName?: string(name='ParameterName', example='name'),
  parameterValue?: string(name='ParameterValue', example='value'),
  parameters?: [ 
    {
      parameterName?: string(name='ParameterName', example='name'),
      parameterValue?: string(name='ParameterValue', example='value'),
    }
  ](name='Parameters'),
}

model ModifyApplicationParameterShrinkRequest {
  applicationId?: string(name='ApplicationId', description='This parameter is required.', example='pa-**************'),
  parameterName?: string(name='ParameterName', example='name'),
  parameterValue?: string(name='ParameterValue', example='value'),
  parametersShrink?: string(name='Parameters'),
}

model ModifyApplicationParameterResponseBody = {
  applicationId?: string(name='ApplicationId', example='pa-**************'),
  requestId?: string(name='RequestId', example='3E5CD764-FCCA-5C9C-838E-20E0DE84B2AF'),
}

model ModifyApplicationParameterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyApplicationParameterResponseBody(name='body'),
}

/**
 * @summary 修改PolarDB应用参数
 *
 * @param tmpReq ModifyApplicationParameterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyApplicationParameterResponse
 */
async function modifyApplicationParameterWithOptions(tmpReq: ModifyApplicationParameterRequest, runtime: Util.RuntimeOptions): ModifyApplicationParameterResponse {
  Util.validateModel(tmpReq);
  var request = new ModifyApplicationParameterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.parameters)) {
    request.parametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.parameters, 'Parameters', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.applicationId)) {
    query['ApplicationId'] = request.applicationId;
  }
  if (!Util.isUnset(request.parameterName)) {
    query['ParameterName'] = request.parameterName;
  }
  if (!Util.isUnset(request.parameterValue)) {
    query['ParameterValue'] = request.parameterValue;
  }
  if (!Util.isUnset(request.parametersShrink)) {
    query['Parameters'] = request.parametersShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyApplicationParameter',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改PolarDB应用参数
 *
 * @param request ModifyApplicationParameterRequest
 * @return ModifyApplicationParameterResponse
 */
async function modifyApplicationParameter(request: ModifyApplicationParameterRequest): ModifyApplicationParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyApplicationParameterWithOptions(request, runtime);
}

model ModifyApplicationServerlessConfRequest {
  applicationId?: string(name='ApplicationId', description='This parameter is required.', example='pa-**************'),
  serverlessConfList?: [ 
    {
      componentType?: string(name='ComponentType', example='gateway'),
      scaleMax?: string(name='ScaleMax', example='16'),
      scaleMin?: string(name='ScaleMin', example='1'),
    }
  ](name='ServerlessConfList', description='This parameter is required.'),
}

model ModifyApplicationServerlessConfResponseBody = {
  applicationId?: string(name='ApplicationId', example='pa-**************'),
  requestId?: string(name='RequestId', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model ModifyApplicationServerlessConfResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyApplicationServerlessConfResponseBody(name='body'),
}

/**
 * @summary 修改应用serverless配置
 *
 * @param request ModifyApplicationServerlessConfRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyApplicationServerlessConfResponse
 */
async function modifyApplicationServerlessConfWithOptions(request: ModifyApplicationServerlessConfRequest, runtime: Util.RuntimeOptions): ModifyApplicationServerlessConfResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationId)) {
    query['ApplicationId'] = request.applicationId;
  }
  if (!Util.isUnset(request.serverlessConfList)) {
    query['ServerlessConfList'] = request.serverlessConfList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyApplicationServerlessConf',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改应用serverless配置
 *
 * @param request ModifyApplicationServerlessConfRequest
 * @return ModifyApplicationServerlessConfResponse
 */
async function modifyApplicationServerlessConf(request: ModifyApplicationServerlessConfRequest): ModifyApplicationServerlessConfResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyApplicationServerlessConfWithOptions(request, runtime);
}

model ModifyApplicationWhitelistRequest {
  applicationId?: string(name='ApplicationId', description='This parameter is required.', example='pa-**************'),
  componentId?: string(name='ComponentId', example='pac-*******************'),
  modifyMode?: string(name='ModifyMode', example='Append'),
  securityGroups?: string(name='SecurityGroups', example='sg-**************'),
  securityIPArrayName?: string(name='SecurityIPArrayName', example='default'),
  securityIPList?: string(name='SecurityIPList', example='127.0.0.1,172.17.0.0/24'),
}

model ModifyApplicationWhitelistResponseBody = {
  applicationId?: string(name='ApplicationId', example='pa-**************'),
  componentId?: string(name='ComponentId', example='pac-**************'),
  requestId?: string(name='RequestId', example='3E5CD764-FCCA-5C9C-838E-20E0DE84B2AF'),
}

model ModifyApplicationWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyApplicationWhitelistResponseBody(name='body'),
}

/**
 * @summary 修改应用白名单
 *
 * @param request ModifyApplicationWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyApplicationWhitelistResponse
 */
async function modifyApplicationWhitelistWithOptions(request: ModifyApplicationWhitelistRequest, runtime: Util.RuntimeOptions): ModifyApplicationWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationId)) {
    query['ApplicationId'] = request.applicationId;
  }
  if (!Util.isUnset(request.componentId)) {
    query['ComponentId'] = request.componentId;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['ModifyMode'] = request.modifyMode;
  }
  if (!Util.isUnset(request.securityGroups)) {
    query['SecurityGroups'] = request.securityGroups;
  }
  if (!Util.isUnset(request.securityIPArrayName)) {
    query['SecurityIPArrayName'] = request.securityIPArrayName;
  }
  if (!Util.isUnset(request.securityIPList)) {
    query['SecurityIPList'] = request.securityIPList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyApplicationWhitelist',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改应用白名单
 *
 * @param request ModifyApplicationWhitelistRequest
 * @return ModifyApplicationWhitelistResponse
 */
async function modifyApplicationWhitelist(request: ModifyApplicationWhitelistRequest): ModifyApplicationWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyApplicationWhitelistWithOptions(request, runtime);
}

model ModifyAutoRenewAttributeRequest {
  cloudProvider?: string(name='CloudProvider', example='ENS'),
  DBClusterIds?: string(name='DBClusterIds', description='The cluster ID. If you need to specify multiple cluster IDs, separate the cluster IDs with commas (,).

This parameter is required.', example='pc-***************'),
  duration?: string(name='Duration', description='The automatic renewal period.

*   Valid values when you set the **PeriodUnit** parameter to **Month**: `1, 2, 3, 6, and 12`.
*   Valid values when you set the **PeriodUnit** parameter to **Year**: `1, 2, and 3`.

Default value: **1**.', example='1'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the renewal period. Valid values:

*   **Year**
*   **Month**

Default value: **Month**.', example='Month'),
  regionId?: string(name='RegionId', description='The ID of the region. The region ID can be up to 50 characters in length.
cn-hangzhou
 
>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the available regions.

This parameter is required.', example='cn-hangzhou'),
  renewalStatus?: string(name='RenewalStatus', description='The auto-renewal status of the cluster. Valid values:

*   **AutoRenewal:** The cluster is automatically renewed.
*   **Normal**: The cluster is manually renewed.
*   **NotRenewal:** The cluster is not renewed after expiration.

Default value: **AutoRenewal**.

>  If you set this parameter to **NotRenewal**, the system sends a notification that indicates the cluster is not renewed three days before the cluster expires. After the cluster expires, the system no longer sends a notification.', example='AutoRenewal'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyAutoRenewAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='4CE6DF97-AEA4-484F-906F-C407EE******'),
}

model ModifyAutoRenewAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAutoRenewAttributeResponseBody(name='body'),
}

/**
 * @summary Modifies the auto-renewal attributes of a subscription PolarDB cluster.
 *
 * @param request ModifyAutoRenewAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAutoRenewAttributeResponse
 */
async function modifyAutoRenewAttributeWithOptions(request: ModifyAutoRenewAttributeRequest, runtime: Util.RuntimeOptions): ModifyAutoRenewAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cloudProvider)) {
    query['CloudProvider'] = request.cloudProvider;
  }
  if (!Util.isUnset(request.DBClusterIds)) {
    query['DBClusterIds'] = request.DBClusterIds;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.renewalStatus)) {
    query['RenewalStatus'] = request.renewalStatus;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAutoRenewAttribute',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the auto-renewal attributes of a subscription PolarDB cluster.
 *
 * @param request ModifyAutoRenewAttributeRequest
 * @return ModifyAutoRenewAttributeResponse
 */
async function modifyAutoRenewAttribute(request: ModifyAutoRenewAttributeRequest): ModifyAutoRenewAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAutoRenewAttributeWithOptions(request, runtime);
}

model ModifyBackupPolicyRequest {
  advancedDataPolicies?: [ 
    {
      actionType?: string(name='ActionType'),
      autoCreated?: boolean(name='AutoCreated'),
      bakType?: string(name='BakType'),
      destRegion?: string(name='DestRegion'),
      destType?: string(name='DestType'),
      dumpAction?: string(name='DumpAction'),
      filterKey?: string(name='FilterKey'),
      filterType?: string(name='FilterType'),
      filterValue?: string(name='FilterValue'),
      onlyPreserveOneEachDay?: boolean(name='OnlyPreserveOneEachDay'),
      onlyPreserveOneEachHour?: boolean(name='OnlyPreserveOneEachHour'),
      policyId?: string(name='PolicyId'),
      retentionType?: string(name='RetentionType'),
      retentionValue?: string(name='RetentionValue'),
      srcRegion?: string(name='SrcRegion'),
      srcType?: string(name='SrcType'),
    }
  ](name='AdvancedDataPolicies'),
  backupFrequency?: string(name='BackupFrequency', description='The backup frequency. Default value: Normal. Valid values:

*   **Normal**: standard backup. The system backs up data once a day.
*   **2/24H**: enhanced backup. The system backs up data every 2 hours.
*   **3/24H**: enhanced backup. The system backs up data every 3 hours.
*   **4/24H**: enhanced backup. The system backs up data every 4 hours.

>- If you enable enhanced backup, all backups are retained for 24 hours. For backup files that are created earlier than the previous 24 hours, the system permanently retains only the first backup that is created after 00:00 every day and deletes the rest.
>- If you enable enhanced backup, **PreferredBackupPeriod** is automatically set to all days in a week (from Monday to Sunday).
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed supports the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Normal'),
  backupPolicyLevel?: string(name='BackupPolicyLevel'),
  backupRetentionPolicyOnClusterDeletion?: string(name='BackupRetentionPolicyOnClusterDeletion', description='Specifies whether to retain backups when a cluster is deleted. Valid values:

*   **ALL**: permanently retains all backups.
*   **LATEST**: permanently retains the most recent backup.
*   **NONE**: does not retain backups.

>  The default value of the parameter is NONE.', example='NONE'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.

This parameter is required.', example='pc-bp13wz9586voc****'),
  dataLevel1BackupFrequency?: string(name='DataLevel1BackupFrequency', description='The frequency of level-1 backups. Default value: Normal. Valid values:

*   **Normal**: standard backup. The system backs up data once a day.
*   **2/24H**: enhanced backup. The system backs up data every 2 hours.
*   **3/24H**: enhanced backup. The system backs up data every 3 hours.
*   **4/24H**: enhanced backup. The system backs up data every 4 hours.

>- This parameter is invalid for PolarDB for Oracle clusters or PolarDB for PostgreSQL clusters.
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Normal'),
  dataLevel1BackupPeriod?: string(name='DataLevel1BackupPeriod', description='The backup cycle of level-1 backups. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is invalid for PolarDB for Oracle clusters or PolarDB for PostgreSQL clusters.
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Monday,Tuesday'),
  dataLevel1BackupRetentionPeriod?: string(name='DataLevel1BackupRetentionPeriod', description='The retention period of level-1 backups. Valid values: 3 to 14. Unit: days.', example='3'),
  dataLevel1BackupTime?: string(name='DataLevel1BackupTime', description='The time period during which automatic backup for level-1 backup is performed. The time period is in the `hh:mmZ-hh:mmZ` format and is displayed in UTC. The start time and end time are on the hour and have an interval of 1 hour. Example: `14:00Z-15:00Z`.
>- This parameter is invalid for PolarDB for Oracle clusters or PolarDB for PostgreSQL clusters.
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='15:00Z-16:00Z'),
  dataLevel2BackupAnotherRegionRegion?: string(name='DataLevel2BackupAnotherRegionRegion', description='The region where the cross-region level-2 backup is stored. For information about regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='cn-hangzhou'),
  dataLevel2BackupAnotherRegionRetentionPeriod?: string(name='DataLevel2BackupAnotherRegionRetentionPeriod', description='The retention period of cross-region level-2 backups. Valid values:

*   **0**: The cross-region level-2 backup feature is disabled.
*   **30 to 7300**: Cross-region level-2 backups are retained for 30 to 7,300 days.
*   **1**: Cross-region level-2 backups are permanently retained.

>  The default value of the parameter is **0**.', example='30'),
  dataLevel2BackupPeriod?: string(name='DataLevel2BackupPeriod', description='The backup cycle of level-2 backups. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is invalid for PolarDB for Oracle clusters or PolarDB for PostgreSQL clusters.
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Monday,Tuesday'),
  dataLevel2BackupRetentionPeriod?: string(name='DataLevel2BackupRetentionPeriod', description='The retention period of level-2 backups. Valid values:

*   **0**: The level-2 backup feature is disabled.
*   **30 to 7300**: Level-2 backups are retained for 30 to 7,300 days.
*   **1**: Level-2 backups are permanently retained.

>  The default value of this parameter is **0**.', example='0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod', description='The backup cycle. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed supports the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Monday,Tuesday'),
  preferredBackupTime?: string(name='PreferredBackupTime', description='The time period during which automatic backup for level-1 backup is performed. The format is `hh:mmZ-hh:mmZ` format. The time is displayed in UTC. The start time and end time are on the hour and with an interval of one hour. Example: `14:00Z-15:00Z`.', example='15:00Z-16:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyBackupPolicyShrinkRequest {
  advancedDataPoliciesShrink?: string(name='AdvancedDataPolicies'),
  backupFrequency?: string(name='BackupFrequency', description='The backup frequency. Default value: Normal. Valid values:

*   **Normal**: standard backup. The system backs up data once a day.
*   **2/24H**: enhanced backup. The system backs up data every 2 hours.
*   **3/24H**: enhanced backup. The system backs up data every 3 hours.
*   **4/24H**: enhanced backup. The system backs up data every 4 hours.

>- If you enable enhanced backup, all backups are retained for 24 hours. For backup files that are created earlier than the previous 24 hours, the system permanently retains only the first backup that is created after 00:00 every day and deletes the rest.
>- If you enable enhanced backup, **PreferredBackupPeriod** is automatically set to all days in a week (from Monday to Sunday).
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed supports the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Normal'),
  backupPolicyLevel?: string(name='BackupPolicyLevel'),
  backupRetentionPolicyOnClusterDeletion?: string(name='BackupRetentionPolicyOnClusterDeletion', description='Specifies whether to retain backups when a cluster is deleted. Valid values:

*   **ALL**: permanently retains all backups.
*   **LATEST**: permanently retains the most recent backup.
*   **NONE**: does not retain backups.

>  The default value of the parameter is NONE.', example='NONE'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.

This parameter is required.', example='pc-bp13wz9586voc****'),
  dataLevel1BackupFrequency?: string(name='DataLevel1BackupFrequency', description='The frequency of level-1 backups. Default value: Normal. Valid values:

*   **Normal**: standard backup. The system backs up data once a day.
*   **2/24H**: enhanced backup. The system backs up data every 2 hours.
*   **3/24H**: enhanced backup. The system backs up data every 3 hours.
*   **4/24H**: enhanced backup. The system backs up data every 4 hours.

>- This parameter is invalid for PolarDB for Oracle clusters or PolarDB for PostgreSQL clusters.
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Normal'),
  dataLevel1BackupPeriod?: string(name='DataLevel1BackupPeriod', description='The backup cycle of level-1 backups. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is invalid for PolarDB for Oracle clusters or PolarDB for PostgreSQL clusters.
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Monday,Tuesday'),
  dataLevel1BackupRetentionPeriod?: string(name='DataLevel1BackupRetentionPeriod', description='The retention period of level-1 backups. Valid values: 3 to 14. Unit: days.', example='3'),
  dataLevel1BackupTime?: string(name='DataLevel1BackupTime', description='The time period during which automatic backup for level-1 backup is performed. The time period is in the `hh:mmZ-hh:mmZ` format and is displayed in UTC. The start time and end time are on the hour and have an interval of 1 hour. Example: `14:00Z-15:00Z`.
>- This parameter is invalid for PolarDB for Oracle clusters or PolarDB for PostgreSQL clusters.
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='15:00Z-16:00Z'),
  dataLevel2BackupAnotherRegionRegion?: string(name='DataLevel2BackupAnotherRegionRegion', description='The region where the cross-region level-2 backup is stored. For information about regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='cn-hangzhou'),
  dataLevel2BackupAnotherRegionRetentionPeriod?: string(name='DataLevel2BackupAnotherRegionRetentionPeriod', description='The retention period of cross-region level-2 backups. Valid values:

*   **0**: The cross-region level-2 backup feature is disabled.
*   **30 to 7300**: Cross-region level-2 backups are retained for 30 to 7,300 days.
*   **1**: Cross-region level-2 backups are permanently retained.

>  The default value of the parameter is **0**.', example='30'),
  dataLevel2BackupPeriod?: string(name='DataLevel2BackupPeriod', description='The backup cycle of level-2 backups. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is invalid for PolarDB for Oracle clusters or PolarDB for PostgreSQL clusters.
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Monday,Tuesday'),
  dataLevel2BackupRetentionPeriod?: string(name='DataLevel2BackupRetentionPeriod', description='The retention period of level-2 backups. Valid values:

*   **0**: The level-2 backup feature is disabled.
*   **30 to 7300**: Level-2 backups are retained for 30 to 7,300 days.
*   **1**: Level-2 backups are permanently retained.

>  The default value of this parameter is **0**.', example='0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod', description='The backup cycle. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed supports the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Monday,Tuesday'),
  preferredBackupTime?: string(name='PreferredBackupTime', description='The time period during which automatic backup for level-1 backup is performed. The format is `hh:mmZ-hh:mmZ` format. The time is displayed in UTC. The start time and end time are on the hour and with an interval of one hour. Example: `14:00Z-15:00Z`.', example='15:00Z-16:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyBackupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C5A5DF0E-5968-4DC1-882E-AC2FE7******'),
}

model ModifyBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyBackupPolicyResponseBody(name='body'),
}

/**
 * @summary Modifies the automatic backup policy of a PolarDB cluster.
 *
 * @description > You can also modify the automatic backup policy of a PolarDB cluster in the console. For more information, see [Backup settings](https://help.aliyun.com/document_detail/280422.html).
 *
 * @param tmpReq ModifyBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyBackupPolicyResponse
 */
async function modifyBackupPolicyWithOptions(tmpReq: ModifyBackupPolicyRequest, runtime: Util.RuntimeOptions): ModifyBackupPolicyResponse {
  Util.validateModel(tmpReq);
  var request = new ModifyBackupPolicyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.advancedDataPolicies)) {
    request.advancedDataPoliciesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.advancedDataPolicies, 'AdvancedDataPolicies', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.advancedDataPoliciesShrink)) {
    query['AdvancedDataPolicies'] = request.advancedDataPoliciesShrink;
  }
  if (!Util.isUnset(request.backupFrequency)) {
    query['BackupFrequency'] = request.backupFrequency;
  }
  if (!Util.isUnset(request.backupPolicyLevel)) {
    query['BackupPolicyLevel'] = request.backupPolicyLevel;
  }
  if (!Util.isUnset(request.backupRetentionPolicyOnClusterDeletion)) {
    query['BackupRetentionPolicyOnClusterDeletion'] = request.backupRetentionPolicyOnClusterDeletion;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.dataLevel1BackupFrequency)) {
    query['DataLevel1BackupFrequency'] = request.dataLevel1BackupFrequency;
  }
  if (!Util.isUnset(request.dataLevel1BackupPeriod)) {
    query['DataLevel1BackupPeriod'] = request.dataLevel1BackupPeriod;
  }
  if (!Util.isUnset(request.dataLevel1BackupRetentionPeriod)) {
    query['DataLevel1BackupRetentionPeriod'] = request.dataLevel1BackupRetentionPeriod;
  }
  if (!Util.isUnset(request.dataLevel1BackupTime)) {
    query['DataLevel1BackupTime'] = request.dataLevel1BackupTime;
  }
  if (!Util.isUnset(request.dataLevel2BackupAnotherRegionRegion)) {
    query['DataLevel2BackupAnotherRegionRegion'] = request.dataLevel2BackupAnotherRegionRegion;
  }
  if (!Util.isUnset(request.dataLevel2BackupAnotherRegionRetentionPeriod)) {
    query['DataLevel2BackupAnotherRegionRetentionPeriod'] = request.dataLevel2BackupAnotherRegionRetentionPeriod;
  }
  if (!Util.isUnset(request.dataLevel2BackupPeriod)) {
    query['DataLevel2BackupPeriod'] = request.dataLevel2BackupPeriod;
  }
  if (!Util.isUnset(request.dataLevel2BackupRetentionPeriod)) {
    query['DataLevel2BackupRetentionPeriod'] = request.dataLevel2BackupRetentionPeriod;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.preferredBackupPeriod)) {
    query['PreferredBackupPeriod'] = request.preferredBackupPeriod;
  }
  if (!Util.isUnset(request.preferredBackupTime)) {
    query['PreferredBackupTime'] = request.preferredBackupTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBackupPolicy',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the automatic backup policy of a PolarDB cluster.
 *
 * @description > You can also modify the automatic backup policy of a PolarDB cluster in the console. For more information, see [Backup settings](https://help.aliyun.com/document_detail/280422.html).
 *
 * @param request ModifyBackupPolicyRequest
 * @return ModifyBackupPolicyResponse
 */
async function modifyBackupPolicy(request: ModifyBackupPolicyRequest): ModifyBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBackupPolicyWithOptions(request, runtime);
}

model ModifyCronJobPolicyServerlessRequest {
  allowShutDown?: string(name='AllowShutDown', example='true'),
  cronExpression?: string(name='CronExpression', description='This parameter is required.', example='0 0 13 * * ?'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-************'),
  endTime?: string(name='EndTime', description='This parameter is required.', example='2020-02-12T15:00Z'),
  jobId?: string(name='JobId', example='8006e51c-dab3-4602-bc69-4f728002c6ce'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='This parameter is required.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scaleApRoNumMax?: string(name='ScaleApRoNumMax', example='1'),
  scaleApRoNumMin?: string(name='ScaleApRoNumMin', example='1'),
  scaleMax?: string(name='ScaleMax', example='12'),
  scaleMin?: string(name='ScaleMin', example='1'),
  scaleRoNumMax?: string(name='ScaleRoNumMax', example='4'),
  scaleRoNumMin?: string(name='ScaleRoNumMin', example='2'),
  secondsUntilAutoPause?: string(name='SecondsUntilAutoPause', example='10'),
  serverlessRuleCpuEnlargeThreshold?: string(name='ServerlessRuleCpuEnlargeThreshold', example='80'),
  serverlessRuleCpuShrinkThreshold?: string(name='ServerlessRuleCpuShrinkThreshold', example='25'),
  serverlessRuleMode?: string(name='ServerlessRuleMode', example='normal'),
  startTime?: string(name='StartTime', example='2020-09-23T01:00:00Z'),
}

model ModifyCronJobPolicyServerlessResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyCronJobPolicyServerlessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyCronJobPolicyServerlessResponseBody(name='body'),
}

/**
 * @summary 修改周期任务策略
 *
 * @param request ModifyCronJobPolicyServerlessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCronJobPolicyServerlessResponse
 */
async function modifyCronJobPolicyServerlessWithOptions(request: ModifyCronJobPolicyServerlessRequest, runtime: Util.RuntimeOptions): ModifyCronJobPolicyServerlessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allowShutDown)) {
    query['AllowShutDown'] = request.allowShutDown;
  }
  if (!Util.isUnset(request.cronExpression)) {
    query['CronExpression'] = request.cronExpression;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scaleApRoNumMax)) {
    query['ScaleApRoNumMax'] = request.scaleApRoNumMax;
  }
  if (!Util.isUnset(request.scaleApRoNumMin)) {
    query['ScaleApRoNumMin'] = request.scaleApRoNumMin;
  }
  if (!Util.isUnset(request.scaleMax)) {
    query['ScaleMax'] = request.scaleMax;
  }
  if (!Util.isUnset(request.scaleMin)) {
    query['ScaleMin'] = request.scaleMin;
  }
  if (!Util.isUnset(request.scaleRoNumMax)) {
    query['ScaleRoNumMax'] = request.scaleRoNumMax;
  }
  if (!Util.isUnset(request.scaleRoNumMin)) {
    query['ScaleRoNumMin'] = request.scaleRoNumMin;
  }
  if (!Util.isUnset(request.secondsUntilAutoPause)) {
    query['SecondsUntilAutoPause'] = request.secondsUntilAutoPause;
  }
  if (!Util.isUnset(request.serverlessRuleCpuEnlargeThreshold)) {
    query['ServerlessRuleCpuEnlargeThreshold'] = request.serverlessRuleCpuEnlargeThreshold;
  }
  if (!Util.isUnset(request.serverlessRuleCpuShrinkThreshold)) {
    query['ServerlessRuleCpuShrinkThreshold'] = request.serverlessRuleCpuShrinkThreshold;
  }
  if (!Util.isUnset(request.serverlessRuleMode)) {
    query['ServerlessRuleMode'] = request.serverlessRuleMode;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCronJobPolicyServerless',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改周期任务策略
 *
 * @param request ModifyCronJobPolicyServerlessRequest
 * @return ModifyCronJobPolicyServerlessResponse
 */
async function modifyCronJobPolicyServerless(request: ModifyCronJobPolicyServerlessRequest): ModifyCronJobPolicyServerlessResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCronJobPolicyServerlessWithOptions(request, runtime);
}

model ModifyDBClusterRequest {
  compressStorage?: string(name='CompressStorage', description='Specifies whether to enable storage compression. Set the value to **ON**.', example='ON'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

>  You can call the DescribeDBClusters operation to query information about all PolarDB clusters that are deployed in a specified region, such as cluster IDs.

This parameter is required.', example='pc-*************'),
  DBNodeCrashList?: string(name='DBNodeCrashList', description='The list of nodes for the drill.

>  You can specify only one node for a node-level disaster recovery drill. For a primary zone-level disaster recovery drill, you can either choose not to specify this parameter or specify all nodes.', example='pi-rwxxx'),
  dataSyncMode?: string(name='DataSyncMode', description='The method used to replicate data across zones. Valid values:

*   **AsyncSync**: the asynchronous mode.
*   **SemiSync**: the semi-synchronous mode.', example='AsynSync'),
  faultInjectionType?: string(name='FaultInjectionType', description='The fault injection method. Valid values:

*   0: `Crash SQL`-based fault injection.

Enumerated values:

*   CrashSQLInjection: CrashSQLInjection.', example='0'),
  faultSimulateMode?: string(name='FaultSimulateMode', description='The level of the disaster recovery drill. Valid values:

*   `0` or `FaultInjection`: The primary zone level.
*   `1`: The node level.

> 

*   In **primary zone-level disaster recovery drill** scenarios, all compute nodes in the primary zone are unavailable. Data loss occurs during failovers in the scenarios.

*   In **node-level disaster recovery drill** scenarios, you can specify only one compute node for the disaster recovery drill. You can use the `DBNodeCrashList` parameter to specify the name of the compute node that you want to use for the drill.

Enumerated values:

*   FaultInjectToPrimaryAz
*   FaultInjectToDbNode
*   FaultInjection
*   0
*   1', example='0'),
  imciAutoIndex?: string(name='ImciAutoIndex', description='Specifies whether to enable automatic IMCI-based query acceleration. IMCI is short for In-Memory Column Index. Valid values:

*   `ON`: enables automatic IMCI-based query acceleration.
*   `OFF`: disables automatic IMCI-based query acceleration.

> 

*   This parameter is supported only for PolarDB for MySQL clusters.

*   For information about the cluster version limits, see [Automatic IMCI-based query acceleration](https://help.aliyun.com/document_detail/2854119.html).', example='OFF'),
  modifyRowCompression?: string(name='ModifyRowCompression'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  standbyHAMode?: string(name='StandbyHAMode', description='Specifies whether to enable cross-zone automatic switchover. Valid values:

*   **ON**: enables cross-zone automatic switchover.
*   **OFF**: disables cross-zone automatic switchover.', example='ON'),
  storageAutoScale?: string(name='StorageAutoScale', description='Specifies whether to enable automatic storage scaling for the Standard Edition cluster. Valid values:

*   Enable
*   Disable', example='Enable'),
  storageUpperBound?: long(name='StorageUpperBound', description='The maximum storage capacity of the cluster of Standard Edition in automatic scaling. Unit: GB.

>  The maximum value of this parameter is 32000.', example='800'),
  tableMeta?: string(name='TableMeta'),
}

model ModifyDBClusterResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*************'),
  orderId?: string(name='OrderId', description='The order ID.', example='2148126708*****'),
  requestId?: string(name='RequestId', description='The request ID.', example='CD3FA5F3-FAF3-44CA-AFFF-BAF869******'),
}

model ModifyDBClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterResponseBody(name='body'),
}

/**
 * @summary Modifies the configurations of a PolarDB for MySQL cluster.
 *
 * @param request ModifyDBClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterResponse
 */
async function modifyDBClusterWithOptions(request: ModifyDBClusterRequest, runtime: Util.RuntimeOptions): ModifyDBClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.compressStorage)) {
    query['CompressStorage'] = request.compressStorage;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeCrashList)) {
    query['DBNodeCrashList'] = request.DBNodeCrashList;
  }
  if (!Util.isUnset(request.dataSyncMode)) {
    query['DataSyncMode'] = request.dataSyncMode;
  }
  if (!Util.isUnset(request.faultInjectionType)) {
    query['FaultInjectionType'] = request.faultInjectionType;
  }
  if (!Util.isUnset(request.faultSimulateMode)) {
    query['FaultSimulateMode'] = request.faultSimulateMode;
  }
  if (!Util.isUnset(request.imciAutoIndex)) {
    query['ImciAutoIndex'] = request.imciAutoIndex;
  }
  if (!Util.isUnset(request.modifyRowCompression)) {
    query['ModifyRowCompression'] = request.modifyRowCompression;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.standbyHAMode)) {
    query['StandbyHAMode'] = request.standbyHAMode;
  }
  if (!Util.isUnset(request.storageAutoScale)) {
    query['StorageAutoScale'] = request.storageAutoScale;
  }
  if (!Util.isUnset(request.storageUpperBound)) {
    query['StorageUpperBound'] = request.storageUpperBound;
  }
  if (!Util.isUnset(request.tableMeta)) {
    query['TableMeta'] = request.tableMeta;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the configurations of a PolarDB for MySQL cluster.
 *
 * @param request ModifyDBClusterRequest
 * @return ModifyDBClusterResponse
 */
async function modifyDBCluster(request: ModifyDBClusterRequest): ModifyDBClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterWithOptions(request, runtime);
}

model ModifyDBClusterAccessWhitelistRequest {
  DBClusterIPArrayAttribute?: string(name='DBClusterIPArrayAttribute', description='The attributes of the IP whitelist group. Set this parameter to **hidden** to hide the IP whitelist group in the console.

> *   The IP whitelist group that has appeared in the console cannot be hidden.
> *   This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='hidden'),
  DBClusterIPArrayName?: string(name='DBClusterIPArrayName', description='The name of the IP whitelist group. The group name must be 2 to 120 characters in length and consists of lowercase letters and digits. It must start with a letter, and end with a letter or a digit.

*   If the specified whitelist group name does not exist, the whitelist group is created.
*   If the specified whitelist group name exists, the whitelist group is modified.
*   If you do not specify this parameter, the default group is modified.

> 

*   You can create a maximum of 50 IP whitelist groups for a cluster.

*   This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='default'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-*************'),
  modifyMode?: string(name='ModifyMode', description='The method used to modify the IP whitelist. Valid values:

*   **Cover** (default): overwrites the original IP whitelist.
*   **Append**: appends IP addresses to the original whitelist.
*   **Delete**: deletes IP addresses.

>  This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='Cover'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityGroupIds?: string(name='SecurityGroupIds', description='The ID of the security group. Separate multiple security groups with commas (,).

> *   You can add a maximum of three security groups to a cluster.
> *   This parameter can be specified only when the **WhiteListType** parameter is set to **SecurityGroup**.', example='sg-*********'),
  securityIps?: string(name='SecurityIps', description='The IP addresses or Classless Inter-Domain Routing (CIDR) blocks in the IP whitelist group. You can add 1,000 IP addresses or CIDR blocks to all the IP whitelist groups. Separate multiple IP addresses with commas (,). The following two formats are supported:

*   IP addresses. Example: 10.23.12.24.
*   CIDR blocks. Example: 10.23.12.24/24. 24 indicates the length of the prefix of the CIDR block. The length is the range of 1 to 32.

>  This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='10.23.12.24'),
  whiteListType?: string(name='WhiteListType', description='The type of the whitelist. Valid values:

*   **IP**: IP whitelist group.
*   **SecurityGroup**: security group.

Default value: **IP**.', example='IP'),
}

model ModifyDBClusterAccessWhitelistResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model ModifyDBClusterAccessWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterAccessWhitelistResponseBody(name='body'),
}

/**
 * @summary Creates or modifies the whitelists (IP whitelists and security groups) of a specified cluster.
 *
 * @param request ModifyDBClusterAccessWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterAccessWhitelistResponse
 */
async function modifyDBClusterAccessWhitelistWithOptions(request: ModifyDBClusterAccessWhitelistRequest, runtime: Util.RuntimeOptions): ModifyDBClusterAccessWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterIPArrayAttribute)) {
    query['DBClusterIPArrayAttribute'] = request.DBClusterIPArrayAttribute;
  }
  if (!Util.isUnset(request.DBClusterIPArrayName)) {
    query['DBClusterIPArrayName'] = request.DBClusterIPArrayName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['ModifyMode'] = request.modifyMode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityGroupIds)) {
    query['SecurityGroupIds'] = request.securityGroupIds;
  }
  if (!Util.isUnset(request.securityIps)) {
    query['SecurityIps'] = request.securityIps;
  }
  if (!Util.isUnset(request.whiteListType)) {
    query['WhiteListType'] = request.whiteListType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterAccessWhitelist',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates or modifies the whitelists (IP whitelists and security groups) of a specified cluster.
 *
 * @param request ModifyDBClusterAccessWhitelistRequest
 * @return ModifyDBClusterAccessWhitelistResponse
 */
async function modifyDBClusterAccessWhitelist(request: ModifyDBClusterAccessWhitelistRequest): ModifyDBClusterAccessWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterAccessWhitelistWithOptions(request, runtime);
}

model ModifyDBClusterAndNodesParametersRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-****************'),
  DBNodeIds?: string(name='DBNodeIds', description='The IDs of nodes. You can specify this parameter, or leave this parameter empty. Separate multiple node IDs with commas (,).

>  If you do not specify this parameter, only the cluster parameters are modified.', example='pi-****************,pi-**********,'),
  fromTimeService?: boolean(name='FromTimeService', description='Specifies an immediate or scheduled task to modify parameters and restart the cluster. Default value: false. Valid values:

*   **false**: runs the kernel upgrade task in a scheduled manner.
*   **true**: immediately runs the kernel upgrade task.', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template.', example='pcpg-**************'),
  parameters?: string(name='Parameters', description='The JSON string for the parameter and its value.', example='{"wait_timeout":"86","innodb_old_blocks_time":"10"}'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to run the task. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The value of this parameter must be at least 30 minutes later than the value of the PlannedStartTime parameter.

*   By default, if you specify the `PlannedStartTime` parameter but do not specify the PlannedEndTime parameter, the latest start time of the task is set to a value that is calculated by using the following formula: `Value of the PlannedEndTime parameter + 30 minutes`. For example, if you set the `PlannedStartTime` parameter to `2021-01-14T09:00:00Z` and you do not specify the PlannedEndTime parameter, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest time to upgrade the specifications within the scheduled time period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in the time range from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.

*   If this parameter is empty, the upgrade task is immediately performed.', example='2021-01-14T09:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  standbyClusterIdListNeedToSync?: string(name='StandbyClusterIdListNeedToSync', description='The secondary clusters in the GDN to which the parameter settings are synchronized.', example='gdn-**********,gdn-**********'),
}

model ModifyDBClusterAndNodesParametersResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model ModifyDBClusterAndNodesParametersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterAndNodesParametersResponseBody(name='body'),
}

/**
 * @summary Modifies cluster parameters and applies them to specified nodes.
 *
 * @param request ModifyDBClusterAndNodesParametersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterAndNodesParametersResponse
 */
async function modifyDBClusterAndNodesParametersWithOptions(request: ModifyDBClusterAndNodesParametersRequest, runtime: Util.RuntimeOptions): ModifyDBClusterAndNodesParametersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeIds)) {
    query['DBNodeIds'] = request.DBNodeIds;
  }
  if (!Util.isUnset(request.fromTimeService)) {
    query['FromTimeService'] = request.fromTimeService;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupId)) {
    query['ParameterGroupId'] = request.parameterGroupId;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.standbyClusterIdListNeedToSync)) {
    query['StandbyClusterIdListNeedToSync'] = request.standbyClusterIdListNeedToSync;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterAndNodesParameters',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies cluster parameters and applies them to specified nodes.
 *
 * @param request ModifyDBClusterAndNodesParametersRequest
 * @return ModifyDBClusterAndNodesParametersResponse
 */
async function modifyDBClusterAndNodesParameters(request: ModifyDBClusterAndNodesParametersRequest): ModifyDBClusterAndNodesParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterAndNodesParametersWithOptions(request, runtime);
}

model ModifyDBClusterArchRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-****************'),
  hotStandbyCluster?: string(name='HotStandbyCluster', description='Specifies whether to enable the hot standby storage cluster feature. Valid values:

*   **on**: enables hot standby storage cluster.
*   **equal**: Enable a peer-to-peer cluster.', example='on'),
  regionId?: string(name='RegionId', description='The region ID.

>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query information about regions.', example='cn-beijing'),
  standbyAZ?: string(name='StandbyAZ', description='The zone of the hot standby storage cluster. Valid values:

*   **auto** (default): The zone is automatically selected.

>  You can use the default value when HotStandbyCluster is set to on. If HotStandbyCluster is set to equal, specify the zone of the hot standby storage cluster. You can call the [DescribeZones](https://help.aliyun.com/document_detail/98041.html) operation to query information about zones.', example='cn-beijing-i'),
}

model ModifyDBClusterArchResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-**************'),
  orderId?: string(name='OrderId', description='The order ID.', example='2148126708*****'),
  requestId?: string(name='RequestId', description='The request ID.', example='6A2EE5B4-CC9F-46E1-A747-E43BC9******'),
}

model ModifyDBClusterArchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterArchResponseBody(name='body'),
}

/**
 * @summary Changes the high availability mode of the cluster.
 *
 * @param request ModifyDBClusterArchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterArchResponse
 */
async function modifyDBClusterArchWithOptions(request: ModifyDBClusterArchRequest, runtime: Util.RuntimeOptions): ModifyDBClusterArchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.hotStandbyCluster)) {
    query['HotStandbyCluster'] = request.hotStandbyCluster;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.standbyAZ)) {
    query['StandbyAZ'] = request.standbyAZ;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterArch',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the high availability mode of the cluster.
 *
 * @param request ModifyDBClusterArchRequest
 * @return ModifyDBClusterArchResponse
 */
async function modifyDBClusterArch(request: ModifyDBClusterArchRequest): ModifyDBClusterArchResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterArchWithOptions(request, runtime);
}

model ModifyDBClusterAuditLogCollectorRequest {
  collectorStatus?: string(name='CollectorStatus', description='Specifies whether to enable or disable SQL collector. Valid values:

*   Enable
*   Disable

This parameter is required.', example='Enable'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-***************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterAuditLogCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='22C0ACF0-DD29-4B67-9190-B7A48C******'),
}

model ModifyDBClusterAuditLogCollectorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterAuditLogCollectorResponseBody(name='body'),
}

/**
 * @summary Enables or disables SQL collector for a PolarDB cluster. The features related to SQL collector include Audit Logs and SQL Explorer.
 *
 * @param request ModifyDBClusterAuditLogCollectorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterAuditLogCollectorResponse
 */
async function modifyDBClusterAuditLogCollectorWithOptions(request: ModifyDBClusterAuditLogCollectorRequest, runtime: Util.RuntimeOptions): ModifyDBClusterAuditLogCollectorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.collectorStatus)) {
    query['CollectorStatus'] = request.collectorStatus;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterAuditLogCollector',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables or disables SQL collector for a PolarDB cluster. The features related to SQL collector include Audit Logs and SQL Explorer.
 *
 * @param request ModifyDBClusterAuditLogCollectorRequest
 * @return ModifyDBClusterAuditLogCollectorResponse
 */
async function modifyDBClusterAuditLogCollector(request: ModifyDBClusterAuditLogCollectorRequest): ModifyDBClusterAuditLogCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterAuditLogCollectorWithOptions(request, runtime);
}

model ModifyDBClusterDeletionRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to.obtain the cluster ID.

This parameter is required.', example='pc-bp1313h70cd5m****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  protection?: boolean(name='Protection', description='Specifies whether to enable the cluster lock feature. Default value: false. Valid values:

*   **true**: enables the cluster lock feature. If you enable the cluster lock feature, you cannot directly release the cluster. You must disable the cluster lock feature before you can release the cluster.
*   **false**: disables the cluster lock feature.', example='true'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterDeletionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='24C80BD8-C710-4138-893A-D2AFED4FC13D'),
}

model ModifyDBClusterDeletionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterDeletionResponseBody(name='body'),
}

/**
 * @summary Enables or disables the cluster lock feature for a PolarDB cluster.
 *
 * @param request ModifyDBClusterDeletionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterDeletionResponse
 */
async function modifyDBClusterDeletionWithOptions(request: ModifyDBClusterDeletionRequest, runtime: Util.RuntimeOptions): ModifyDBClusterDeletionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.protection)) {
    query['Protection'] = request.protection;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterDeletion',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables or disables the cluster lock feature for a PolarDB cluster.
 *
 * @param request ModifyDBClusterDeletionRequest
 * @return ModifyDBClusterDeletionResponse
 */
async function modifyDBClusterDeletion(request: ModifyDBClusterDeletionRequest): ModifyDBClusterDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterDeletionWithOptions(request, runtime);
}

model ModifyDBClusterDescriptionRequest {
  DBClusterDescription?: string(name='DBClusterDescription', description='The name of the cluster. The name must meet the following requirements:

*   The name cannot start with `http://` or `https://`.
*   The name must be 2 to 256 characters in length.

This parameter is required.', example='ClusterDescriptionTest'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the PolarDB cluster.

This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model ModifyDBClusterDescriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterDescriptionResponseBody(name='body'),
}

/**
 * @summary Modifies the name of a PolarDB cluster.
 *
 * @param request ModifyDBClusterDescriptionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterDescriptionResponse
 */
async function modifyDBClusterDescriptionWithOptions(request: ModifyDBClusterDescriptionRequest, runtime: Util.RuntimeOptions): ModifyDBClusterDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterDescription)) {
    query['DBClusterDescription'] = request.DBClusterDescription;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterDescription',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the name of a PolarDB cluster.
 *
 * @param request ModifyDBClusterDescriptionRequest
 * @return ModifyDBClusterDescriptionResponse
 */
async function modifyDBClusterDescription(request: ModifyDBClusterDescriptionRequest): ModifyDBClusterDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterDescriptionWithOptions(request, runtime);
}

model ModifyDBClusterDescriptionZonalRequest {
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  DBClusterDescription?: string(name='DBClusterDescription', description='This parameter is required.', example='pc-****************'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterDescriptionZonalResponseBody = {
  requestId?: string(name='RequestId', example='65D7ACE6-4A61-4B6E-B357-8CB24A******'),
}

model ModifyDBClusterDescriptionZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterDescriptionZonalResponseBody(name='body'),
}

/**
 * @summary 修改集群描述
 *
 * @param request ModifyDBClusterDescriptionZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterDescriptionZonalResponse
 */
async function modifyDBClusterDescriptionZonalWithOptions(request: ModifyDBClusterDescriptionZonalRequest, runtime: Util.RuntimeOptions): ModifyDBClusterDescriptionZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterDescription)) {
    query['DBClusterDescription'] = request.DBClusterDescription;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterDescriptionZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改集群描述
 *
 * @param request ModifyDBClusterDescriptionZonalRequest
 * @return ModifyDBClusterDescriptionZonalResponse
 */
async function modifyDBClusterDescriptionZonal(request: ModifyDBClusterDescriptionZonalRequest): ModifyDBClusterDescriptionZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterDescriptionZonalWithOptions(request, runtime);
}

model ModifyDBClusterEndpointRequest {
  autoAddNewNodes?: string(name='AutoAddNewNodes', description='Specifies whether to enable automatic association of newly added nodes with the cluster endpoint. Valid values:

*   **Enable**: enables automatic association of newly added nodes with the cluster endpoint.
*   **Disable** (default): disables automatic association of newly added nodes with the cluster endpoint.', example='Enable'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-*************'),
  DBEndpointDescription?: string(name='DBEndpointDescription', description='The name of the custom cluster endpoint.', example='test'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.

This parameter is required.', example='pe-**************'),
  endpointConfig?: string(name='EndpointConfig', description='The advanced configurations of the cluster endpoint, which are in the JSON format. You can configure the consistency level, transaction splitting, and connection pool settings, and specify whether the primary node accepts read requests.

*   The load balancing policy. Format: `{\\\\"LoadBalancePolicy\\\\":\\\\"Load balancing policy\\\\"}`. Valid values:

    *   **0** (default): connections-based load balancing
    *   **1**: active requests-based load balancing

*   Specifies whether to allow the primary node to accept read requests. Format: `{\\\\"MasterAcceptReads\\\\":\\\\"Specification about whether to allow the primary node to accept read requests\\\\"}`. Valid values:

    *   **on** (default): allows the primary node to accept read requests.
    *   **off**: does not allow the primary node to accept read requests.

*   Specifies whether to enable the transaction splitting feature. Format: `{\\\\"DistributedTransaction\\\\":\\\\"Specification about whether to enable the transaction splitting feature\\\\"}`. Valid values:

    *   **on** (default): enables the transaction splitting feature.
    *   **off**: disables the transaction splitting feature.

*   The consistency level. Format: `{\\\\"ConsistLevel\\\\":\\\\"Consistency level\\\\"}`. Valid values:

    *   **0**: eventual consistency (weak)
    *   **1** (default): session consistency (medium)
    *   **2**: global consistency (strong)

*   The global consistency timeout. Format: `{\\\\"ConsistTimeout\\\\":\\\\"Global consistency timeout\\\\"}`. Valid values: 0 to 60,000. Default value: 20. Unit: ms.

*   The session consistency timeout. Format: `{\\\\"ConsistSessionTimeout\\\\":\\\\"Session consistency timeout\\\\"}`. Valid values: 0 to 60,000. Default value: 0. Unit: ms.

*   The global (or session) consistency timeout policy. Format: `{\\\\"ConsistTimeoutAction\\\\":\\\\"Consistency timeout policy\\\\"}`. Valid values:

    *   **0** (default): PolarProxy sends read requests to the primary node.
    *   **1**: PolarProxy returns the "wait replication complete timeout, please retry" error message to the application.

*   Specifies whether to enable the connection pool feature. Format: `{\\\\"ConnectionPersist\\\\":\\\\"Specification about whether to enable the connection pool feature\\\\"}`. Valid values:

    *   **off** (default): disables the connection pool feature.
    *   **Session**: enables the session-level connection pool.
    *   **Transaction**: enables the transaction-level connection pool.

*   Specifies whether to enable the parallel query feature. Format: `{\\\\"MaxParallelDegree\\\\":\\\\"Specification about whether to enable the parallel query feature\\\\"}`. Valid values:

    *   **on**: enables the parallel query feature.
    *   **off** (default): disables the parallel query feature.

*   Specifies whether to enable the automatic request distribution among row store and column store nodes feature. Format: `{\\\\"EnableHtapImci\\\\":\\\\"Specification about whether to enable automatic request distribution among row store and column store nodes feature\\\\"}`. Valid values:

    *   **on**: enables the automatic request distribution among row store and column store nodes feature.
    *   **off** (default): disables the automatic request distribution among row store and column store nodes feature.

*   Specifies whether to enable the overload protection feature. Format: `{\\\\"EnableOverloadThrottle\\\\":\\\\"Specification about whether to enable the overload protection feature\\\\"}`. Valid values:

    *   **on**: enables the overload protection feature.
    *   **off** (default): disables the overload protection feature.

> 

*   You can configure the transaction splitting, connection pool, and overload protection settings, and specify whether the primary node accepts read requests settings for the cluster endpoint of a PolarDB for MySQL cluster only if ReadWriteMode of the cluster endpoint is set to Read and Write (Automatic Read/Write Splitting).

*   If ReadWriteMode of the cluster endpoint of a PolarDB for MySQL cluster is set to **Read-only**, you can specify the **Connections-based Load Balancing** or **Active Request-based Load Balancing** policy for the cluster endpoint. If ReadWriteMode of the cluster endpoint of a PolarDB for MySQL cluster is set to **Read/Write (Automatic Read/Write Splitting)**, you can specify only the **Active Request-based Load Balancing** policy for the cluster endpoint.

*   You can enable automatic request distribution among column store and row store nodes for the cluster endpoint of a PolarDB for MySQL cluster if ReadWriteMode of the cluster endpoint is set to **Read and Write (Automatic Read/Write Splitting)**, or if the ReadWriteMode of the cluster endpoint is set to **Read-only** and the load balancing policy is set to **Active requests-based load balancing**.

*   Only PolarDB for MySQL supports global consistency.

*   You can set the consistency level of the cluster endpoint of a PolarDB for MySQL cluster only to **0** if **ReadWriteMode** of the cluster endpoint is set to **ReadOnly**.

*   You can configure the settings for the consistency level, transaction splitting, and connection pool features, and specify whether the primary node accepts read requests settings at a time. Example: `{\\\\"ConsistLevel\\\\":\\\\"1\\\\",\\\\"DistributedTransaction\\\\":\\\\"on\\\\",\\\\"ConnectionPersist\\\\":\\\\"Session\\\\",\\\\"MasterAcceptReads\\\\":\\\\"on\\\\"}`.

*   The configuration for transaction splitting is limited by the configuration for the consistency level. For example, if you set the consistency level to **0**, you cannot enable transaction splitting. If you set the consistency level to **1** or **2**, you can enable transaction splitting.', example='{"ConsistLevel":"1","DistributedTransaction":"on","MasterAcceptReads":"off","ConnectionPersist": "on"}'),
  nodes?: string(name='Nodes', description='The reader nodes to be associated with the endpoint. If you need to specify multiple reader nodes, separate the reader nodes with commas (,). If you do not specify this parameter, the predefined nodes are used by default.

> 

*   You must specify the node ID for each PolarDB for MySQL cluster.

*   You must specify the role name of each node for each PolarDB for PostgreSQL or PolarDB for Oracle cluster. Example: `Writer,Reader1,Reader2`.

*   If you set **ReadWriteMode** to **ReadOnly**, only one node can be associated with the cluster endpoint. If the only node becomes faulty, the cluster endpoint may be unavailable for up to an hour. We recommend that you do not associate only one node with the cluster endpoint in production environments. We recommend that you associate at least two nodes with the cluster endpoint to improve service availability.

*   If you set **ReadWriteMode** to **ReadWrite**, you must associate at least two nodes with the cluster endpoint.

    *   No limits are imposed on the two nodes that you select for each PolarDB for MySQL cluster. If the two nodes are read-only nodes, write requests are forwarded to the primary node.
    *   The following limit applies to PolarDB for PostgreSQL and PolarDB for Oracle clusters: One of the selected nodes must be the primary node.', example='pi-**************,pi-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  polarSccTimeoutAction?: string(name='PolarSccTimeoutAction', description='Global consistency timeout policy. Valid values:

*   **0**: sends the request to the primary node.
*   **2**: downgrades the consistency level of a query to inconsistent read when a global consistent read in the query times out. No error message is returned to the client.', example='0'),
  polarSccWaitTimeout?: string(name='PolarSccWaitTimeout', description='Global consistency timeout.', example='100'),
  readWriteMode?: string(name='ReadWriteMode', description='The read/write mode. Valid values:

*   **ReadWrite**: The cluster endpoint handles read and write requests. Automatic read/write splitting is enabled.
*   **ReadOnly**: The cluster endpoint handles read-only requests.', example='ReadWrite'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sccMode?: string(name='SccMode', description='Specifies whether to enable the global consistency (high-performance mode) feature for the nodes. Valid values:

*   **ON**
*   **OFF**', example='on'),
}

model ModifyDBClusterEndpointResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CD3FA5F3-FAF3-44CA-AFFF-BAF869******'),
}

model ModifyDBClusterEndpointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterEndpointResponseBody(name='body'),
}

/**
 * @summary Modifies the attributes of a specified PolarDB cluster endpoint. For example, you can modify the following attributes for the specified cluster endpoint: read/write mode, consistency level, transaction splitting, primary node accepts read requests, and connection pool. You can also call the operation to specify whether newly added nodes are automatically associated with the specified cluster endpoint.
 *
 * @param request ModifyDBClusterEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterEndpointResponse
 */
async function modifyDBClusterEndpointWithOptions(request: ModifyDBClusterEndpointRequest, runtime: Util.RuntimeOptions): ModifyDBClusterEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoAddNewNodes)) {
    query['AutoAddNewNodes'] = request.autoAddNewNodes;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointDescription)) {
    query['DBEndpointDescription'] = request.DBEndpointDescription;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.endpointConfig)) {
    query['EndpointConfig'] = request.endpointConfig;
  }
  if (!Util.isUnset(request.nodes)) {
    query['Nodes'] = request.nodes;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.polarSccTimeoutAction)) {
    query['PolarSccTimeoutAction'] = request.polarSccTimeoutAction;
  }
  if (!Util.isUnset(request.polarSccWaitTimeout)) {
    query['PolarSccWaitTimeout'] = request.polarSccWaitTimeout;
  }
  if (!Util.isUnset(request.readWriteMode)) {
    query['ReadWriteMode'] = request.readWriteMode;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sccMode)) {
    query['SccMode'] = request.sccMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterEndpoint',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the attributes of a specified PolarDB cluster endpoint. For example, you can modify the following attributes for the specified cluster endpoint: read/write mode, consistency level, transaction splitting, primary node accepts read requests, and connection pool. You can also call the operation to specify whether newly added nodes are automatically associated with the specified cluster endpoint.
 *
 * @param request ModifyDBClusterEndpointRequest
 * @return ModifyDBClusterEndpointResponse
 */
async function modifyDBClusterEndpoint(request: ModifyDBClusterEndpointRequest): ModifyDBClusterEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterEndpointWithOptions(request, runtime);
}

model ModifyDBClusterEndpointZonalRequest {
  autoAddNewNodes?: string(name='AutoAddNewNodes', example='Enable'),
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f******************'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  DBEndpointDescription?: string(name='DBEndpointDescription', example='test'),
  DBEndpointId?: string(name='DBEndpointId', description='This parameter is required.', example='pe-****************'),
  endpointConfig?: string(name='EndpointConfig', example='{\\\\"DistributedTransaction\\\\":\\\\"off\\\\",\\\\"ConsistLevel\\\\":\\\\"0\\\\",\\\\"LoadBalanceStrategy\\\\":\\\\"load\\\\",\\\\"MasterAcceptReads\\\\":\\\\"on\\\\"}'),
  nodes?: string(name='Nodes', example='pi-**************,pi-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  polarSccTimeoutAction?: string(name='PolarSccTimeoutAction', example='0'),
  polarSccWaitTimeout?: string(name='PolarSccWaitTimeout', example='100'),
  readWriteMode?: string(name='ReadWriteMode', example='ReadWrite'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sccMode?: string(name='SccMode', example='OFF'),
}

model ModifyDBClusterEndpointZonalResponseBody = {
  requestId?: string(name='RequestId', example='F2A9EFA7-915F-4572-8299-85A307******'),
}

model ModifyDBClusterEndpointZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterEndpointZonalResponseBody(name='body'),
}

/**
 * @summary PolarDB边缘集群修改链接地址
 *
 * @param request ModifyDBClusterEndpointZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterEndpointZonalResponse
 */
async function modifyDBClusterEndpointZonalWithOptions(request: ModifyDBClusterEndpointZonalRequest, runtime: Util.RuntimeOptions): ModifyDBClusterEndpointZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoAddNewNodes)) {
    query['AutoAddNewNodes'] = request.autoAddNewNodes;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointDescription)) {
    query['DBEndpointDescription'] = request.DBEndpointDescription;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.endpointConfig)) {
    query['EndpointConfig'] = request.endpointConfig;
  }
  if (!Util.isUnset(request.nodes)) {
    query['Nodes'] = request.nodes;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.polarSccTimeoutAction)) {
    query['PolarSccTimeoutAction'] = request.polarSccTimeoutAction;
  }
  if (!Util.isUnset(request.polarSccWaitTimeout)) {
    query['PolarSccWaitTimeout'] = request.polarSccWaitTimeout;
  }
  if (!Util.isUnset(request.readWriteMode)) {
    query['ReadWriteMode'] = request.readWriteMode;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sccMode)) {
    query['SccMode'] = request.sccMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterEndpointZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary PolarDB边缘集群修改链接地址
 *
 * @param request ModifyDBClusterEndpointZonalRequest
 * @return ModifyDBClusterEndpointZonalResponse
 */
async function modifyDBClusterEndpointZonal(request: ModifyDBClusterEndpointZonalRequest): ModifyDBClusterEndpointZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterEndpointZonalWithOptions(request, runtime);
}

model ModifyDBClusterMaintainTimeRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-***************'),
  maintainTime?: string(name='MaintainTime', description='The maintenance window of the cluster. Specify the maintenance window in the `HH:mmZ-HH:mmZ` format. For example, the value `16:00Z-17:00Z` indicates that the cluster can be maintained from 00:00 to 01:00 (UTC+8).
 
>  The maintenance window must start on the hour and last for an hour.

This parameter is required.', example='02:00Z-03:00Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterMaintainTimeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='70656639-1416-479F-AF13-D08197******'),
}

model ModifyDBClusterMaintainTimeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterMaintainTimeResponseBody(name='body'),
}

/**
 * @summary Modifies the maintenance window of a PolarDB cluster.
 *
 * @description >  We recommend that you set the routine maintenance window to off-peak hours. Alibaba Cloud maintains your cluster within the specified maintenance window to minimize the negative impacts on your business.
 *
 * @param request ModifyDBClusterMaintainTimeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterMaintainTimeResponse
 */
async function modifyDBClusterMaintainTimeWithOptions(request: ModifyDBClusterMaintainTimeRequest, runtime: Util.RuntimeOptions): ModifyDBClusterMaintainTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.maintainTime)) {
    query['MaintainTime'] = request.maintainTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterMaintainTime',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the maintenance window of a PolarDB cluster.
 *
 * @description >  We recommend that you set the routine maintenance window to off-peak hours. Alibaba Cloud maintains your cluster within the specified maintenance window to minimize the negative impacts on your business.
 *
 * @param request ModifyDBClusterMaintainTimeRequest
 * @return ModifyDBClusterMaintainTimeResponse
 */
async function modifyDBClusterMaintainTime(request: ModifyDBClusterMaintainTimeRequest): ModifyDBClusterMaintainTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterMaintainTimeWithOptions(request, runtime);
}

model ModifyDBClusterMigrationRequest {
  connectionStrings?: string(name='ConnectionStrings', description='The endpoints to be switched. The endpoints are in the JSON format.

> This parameter is valid when the SwapConnectionString parameter is set to true.', example='{"rm-2ze73el581cs*****.mysql.pre.rds.aliyuncs.com":"pc-2ze8200s298e*****.mysql.polardb.pre.rds.aliyuncs.com","rm-2ze73el581cs86*****.mysql.pre.rds.aliyuncs.com":"test-p*****.mysql.polardb.pre.rds.aliyuncs.com"}'),
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-**************'),
  newMasterInstanceId?: string(name='NewMasterInstanceId', description='The ID of the new instance or new cluster. Valid values:

*   To perform a data migration, enter the ID of the PolarDB cluster.
*   To perform a migration rollback, enter the ID of the ApsaraDB for RDS instance.

This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  sourceRDSDBInstanceId?: string(name='SourceRDSDBInstanceId', description='The ID of the source ApsaraDB RDS instance.

This parameter is required.', example='rm-************'),
  swapConnectionString?: string(name='SwapConnectionString', description='Specifies whether to switch the endpoints. Valid values:

*   **true**: switches the endpoints. If you select this option, you do not need the change the endpoint in your applications.
*   **false**: does not switch the endpoints. If you select this option, you must specify the endpoint of the PolarDB cluster in your applications.

Default value: **false**.', example='false'),
}

model ModifyDBClusterMigrationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='A1B303A5-653F-4AEE-A598-023FF9******'),
}

model ModifyDBClusterMigrationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterMigrationResponseBody(name='body'),
}

/**
 * @summary Switches or rolls back the task that migrates data from ApsaraDB for RDS to PolarDB.
 *
 * @description *   You can call this operation to switch the task that migrates data from ApsaraDB for RDS to PolarDB.
 * *   You can call this operation to roll back the task that migrates data from ApsaraDB for RDS to PolarDB.
 * > Before you call this operation, ensure that a one-click upgrade task has been created for the cluster. You can call the [CreateDBCluster](https://help.aliyun.com/document_detail/98169.html) operation to create an upgrade task. Set the **CreationOption** parameter to **MigrationFromRDS**. For more information, see [Create a PolarDB for MySQL cluster by using the Migration from RDS method](https://help.aliyun.com/document_detail/121582.html).
 *
 * @param request ModifyDBClusterMigrationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterMigrationResponse
 */
async function modifyDBClusterMigrationWithOptions(request: ModifyDBClusterMigrationRequest, runtime: Util.RuntimeOptions): ModifyDBClusterMigrationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionStrings)) {
    query['ConnectionStrings'] = request.connectionStrings;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.newMasterInstanceId)) {
    query['NewMasterInstanceId'] = request.newMasterInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.sourceRDSDBInstanceId)) {
    query['SourceRDSDBInstanceId'] = request.sourceRDSDBInstanceId;
  }
  if (!Util.isUnset(request.swapConnectionString)) {
    query['SwapConnectionString'] = request.swapConnectionString;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterMigration',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Switches or rolls back the task that migrates data from ApsaraDB for RDS to PolarDB.
 *
 * @description *   You can call this operation to switch the task that migrates data from ApsaraDB for RDS to PolarDB.
 * *   You can call this operation to roll back the task that migrates data from ApsaraDB for RDS to PolarDB.
 * > Before you call this operation, ensure that a one-click upgrade task has been created for the cluster. You can call the [CreateDBCluster](https://help.aliyun.com/document_detail/98169.html) operation to create an upgrade task. Set the **CreationOption** parameter to **MigrationFromRDS**. For more information, see [Create a PolarDB for MySQL cluster by using the Migration from RDS method](https://help.aliyun.com/document_detail/121582.html).
 *
 * @param request ModifyDBClusterMigrationRequest
 * @return ModifyDBClusterMigrationResponse
 */
async function modifyDBClusterMigration(request: ModifyDBClusterMigrationRequest): ModifyDBClusterMigrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterMigrationWithOptions(request, runtime);
}

model ModifyDBClusterMigrationEndpointRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-bp1w68hcomx235jaz'),
  migrationConfig?: string(name='MigrationConfig', description='This parameter is required.', example='[{\\\\"dtsJobId\\\\":\\\\"di4w4d9r12m38mb\\\\",\\\\"endpoint\\\\":\\\\"src\\\\",\\\\"endpointInstanceId\\\\":\\\\"pc-k2j96w169uhu868l8\\\\"}]'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterMigrationEndpointResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-k2j1qqukj583di7n9'),
  requestId?: string(name='RequestId', description='Id of the request', example='F901FB05-8109-547F-A0B9-9C4FF7F4927A'),
  taskId?: string(name='TaskId', example='21498490'),
}

model ModifyDBClusterMigrationEndpointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterMigrationEndpointResponseBody(name='body'),
}

/**
 * @summary 修改dts源实例、目标实例
 *
 * @param request ModifyDBClusterMigrationEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterMigrationEndpointResponse
 */
async function modifyDBClusterMigrationEndpointWithOptions(request: ModifyDBClusterMigrationEndpointRequest, runtime: Util.RuntimeOptions): ModifyDBClusterMigrationEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.migrationConfig)) {
    query['MigrationConfig'] = request.migrationConfig;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterMigrationEndpoint',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改dts源实例、目标实例
 *
 * @param request ModifyDBClusterMigrationEndpointRequest
 * @return ModifyDBClusterMigrationEndpointResponse
 */
async function modifyDBClusterMigrationEndpoint(request: ModifyDBClusterMigrationEndpointRequest): ModifyDBClusterMigrationEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterMigrationEndpointWithOptions(request, runtime);
}

model ModifyDBClusterMonitorRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: string(name='Period', description='The interval at which monitoring data is collected. Valid values: **5** and **60**. Unit: seconds.

This parameter is required.', example='5'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterMonitorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='75B92353-73B4-447B-8477-C85F3C******'),
}

model ModifyDBClusterMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterMonitorResponseBody(name='body'),
}

/**
 * @summary Modifies the interval at which the monitoring data of a PolarDB cluster is collected.
 *
 * @description *   When the monitoring data is collected every 5 seconds:
 *     *   If the query time range is less than or equal to 1 hour, the data is displayed at intervals of 5 seconds.
 *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
 *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
 *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
 *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
 * *   When the monitoring data is collected every 60 seconds:
 *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
 *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
 *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
 *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
 *
 * @param request ModifyDBClusterMonitorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterMonitorResponse
 */
async function modifyDBClusterMonitorWithOptions(request: ModifyDBClusterMonitorRequest, runtime: Util.RuntimeOptions): ModifyDBClusterMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterMonitor',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the interval at which the monitoring data of a PolarDB cluster is collected.
 *
 * @description *   When the monitoring data is collected every 5 seconds:
 *     *   If the query time range is less than or equal to 1 hour, the data is displayed at intervals of 5 seconds.
 *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
 *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
 *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
 *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
 * *   When the monitoring data is collected every 60 seconds:
 *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
 *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
 *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
 *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
 *
 * @param request ModifyDBClusterMonitorRequest
 * @return ModifyDBClusterMonitorResponse
 */
async function modifyDBClusterMonitor(request: ModifyDBClusterMonitorRequest): ModifyDBClusterMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterMonitorWithOptions(request, runtime);
}

model ModifyDBClusterParametersRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.

This parameter is required.', example='pc-**************'),
  fromTimeService?: boolean(name='FromTimeService', description='Specifies an immediate or scheduled task to modify parameters and restart the cluster. Valid values:

*   false: scheduled task
*   true: immediate task', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template.

> 

*   You can call the [DescribeParameterGroups](https://help.aliyun.com/document_detail/207178.html) operation to query the parameter template ID.

*   You must specify this parameter or the `Parameters` parameter.
*   This parameter is valid only for a PolarDB for MySQL cluster.', example='pcpg-**************'),
  parameters?: string(name='Parameters', description='The JSON string that consists of parameters and values. The parameter values are strings, for example, `{"wait_timeout":"86","innodb_old_blocks_time":"10"}`.

> 

*   You can call the [DescribeDBClusterParameters](https://help.aliyun.com/document_detail/98122.html) operation to query the parameters of the PolarDB cluster.

*   This parameter is required for a PolarDB for Oracle or PolarDB for PostgreSQL cluster.
*   For PolarDB for MySQL clusters, you must specify this parameter or the `ParameterGroupId` parameter.', example='{"wait_timeout":"86","innodb_old_blocks_time":"10"}'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to run the task. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The value of this parameter must be at least 30 minutes later than the value of the PlannedStartTime parameter.

*   By default, if you specify the `PlannedStartTime` parameter but do not specify the PlannedEndTime parameter, the latest start time of the task is set to a value that is calculated by using the following formula: `Value of the PlannedEndTime parameter + 30 minutes`. For example, if you set the `PlannedStartTime` parameter to `2021-01-14T09:00:00Z` and you do not specify the PlannedEndTime parameter, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2022-04-28T14:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest time to upgrade the specifications within the scheduled time period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in the time range from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.

*   If this parameter is empty, the upgrade task is immediately performed.', example='2022-04-28T14:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterParametersResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C5D526E5-91B5-48B8-B980-FE07FF******'),
}

model ModifyDBClusterParametersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterParametersResponseBody(name='body'),
}

/**
 * @summary Modifies the parameters of a specified PolarDB cluster or applies existing parameter templates to a specified cluster.
 *
 * @description PolarDB supports the parameter template feature to centrally manage clusters. You can configure a number of parameters at a time by using a parameter template and apply the template to a PolarDB cluster. For more information, see [Use a parameter template](https://help.aliyun.com/document_detail/207009.html).
 * **
 * **Only PolarDB for MySQL clusters support parameter templates.
 *
 * @param request ModifyDBClusterParametersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterParametersResponse
 */
async function modifyDBClusterParametersWithOptions(request: ModifyDBClusterParametersRequest, runtime: Util.RuntimeOptions): ModifyDBClusterParametersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.fromTimeService)) {
    query['FromTimeService'] = request.fromTimeService;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupId)) {
    query['ParameterGroupId'] = request.parameterGroupId;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterParameters',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the parameters of a specified PolarDB cluster or applies existing parameter templates to a specified cluster.
 *
 * @description PolarDB supports the parameter template feature to centrally manage clusters. You can configure a number of parameters at a time by using a parameter template and apply the template to a PolarDB cluster. For more information, see [Use a parameter template](https://help.aliyun.com/document_detail/207009.html).
 * **
 * **Only PolarDB for MySQL clusters support parameter templates.
 *
 * @param request ModifyDBClusterParametersRequest
 * @return ModifyDBClusterParametersResponse
 */
async function modifyDBClusterParameters(request: ModifyDBClusterParametersRequest): ModifyDBClusterParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterParametersWithOptions(request, runtime);
}

model ModifyDBClusterPrimaryZoneRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/173433.html) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.

This parameter is required.', example='pc-**************'),
  fromTimeService?: boolean(name='FromTimeService', description='Specifies whether to change the primary zone immediately. Valid values:

*   false (default): changes the primary zone as scheduled.
*   true: changes the primary zone immediately.', example='false'),
  isSwitchOverForDisaster?: string(name='IsSwitchOverForDisaster', description='Specifies whether to switch back to the original primary zone.

*   true: switches back to the original primary zone.
*   false: does not switch back to the original primary zone.', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to switch the primary zone within the scheduled time period. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> *   The latest start time must be at least 30 minutes later than the earliest start time.
>*   If you specify the `PlannedStartTime` parameter but do not specify the PlannedEndTime parameter, the latest start time of the task is set to a value that is calculated by `the value of the PlannedEndTime parameter + 30 minutes` by default. For example, if you set the `PlannedStartTime` parameter to `2021-01-14T09:00:00Z` and you do not specify the PlannedEndTime parameter, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The start time to change the primary zone within the scheduled time period. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> *   The start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in time from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.
>*   If you leave this parameter empty, the primary zone is immediately changed.', example='2021-01-14T09:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VPCId?: string(name='VPCId', description='The virtual private cloud (VPC) ID of the destination primary zone.', example='vpc-**********'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch in the destination primary zone.

> *   For a PolarDB for PostgreSQL (Compatible with Oracle) cluster or a PolarDB for PostgreSQL cluster, this parameter is required.
>*   For a PolarDB for MySQL cluster, the default vSwitch is used if no vSwitches are created in the destination zone. If a vSwitch is in the destination zone, this parameter is required.', example='vsw-**************'),
  zoneId?: string(name='ZoneId', description='The ID of the destination primary zone.

>  You can call the DescribeRegions operation to query available zones.[](~~98041~~)

This parameter is required.', example='cn-hangzhou-g'),
  zoneType?: string(name='ZoneType', description='The zone type. Valid values:

*   **Primary**: primary zone
*   **Standby**: secondary zone', example='Primary'),
}

model ModifyDBClusterPrimaryZoneResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='ED12C6FF-3261-4571-AB57-3570F6******'),
}

model ModifyDBClusterPrimaryZoneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterPrimaryZoneResponseBody(name='body'),
}

/**
 * @summary Changes the primary zone of a PolarDB cluster.
 *
 * @param request ModifyDBClusterPrimaryZoneRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterPrimaryZoneResponse
 */
async function modifyDBClusterPrimaryZoneWithOptions(request: ModifyDBClusterPrimaryZoneRequest, runtime: Util.RuntimeOptions): ModifyDBClusterPrimaryZoneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.fromTimeService)) {
    query['FromTimeService'] = request.fromTimeService;
  }
  if (!Util.isUnset(request.isSwitchOverForDisaster)) {
    query['IsSwitchOverForDisaster'] = request.isSwitchOverForDisaster;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  if (!Util.isUnset(request.zoneType)) {
    query['ZoneType'] = request.zoneType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterPrimaryZone',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the primary zone of a PolarDB cluster.
 *
 * @param request ModifyDBClusterPrimaryZoneRequest
 * @return ModifyDBClusterPrimaryZoneResponse
 */
async function modifyDBClusterPrimaryZone(request: ModifyDBClusterPrimaryZoneRequest): ModifyDBClusterPrimaryZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterPrimaryZoneWithOptions(request, runtime);
}

model ModifyDBClusterResourceGroupRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-*************'),
  newResourceGroupId?: string(name='NewResourceGroupId', description='The ID of the new resource group.

This parameter is required.', example='rg-**********'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the original resource group.', example='rg-**********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='70656639-1416-479F-AF13-D08197******'),
}

model ModifyDBClusterResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterResourceGroupResponseBody(name='body'),
}

/**
 * @summary Modifies the configurations of a resource group for a database cluster.
 *
 * @param request ModifyDBClusterResourceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterResourceGroupResponse
 */
async function modifyDBClusterResourceGroupWithOptions(request: ModifyDBClusterResourceGroupRequest, runtime: Util.RuntimeOptions): ModifyDBClusterResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterResourceGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the configurations of a resource group for a database cluster.
 *
 * @param request ModifyDBClusterResourceGroupRequest
 * @return ModifyDBClusterResourceGroupResponse
 */
async function modifyDBClusterResourceGroup(request: ModifyDBClusterResourceGroupRequest): ModifyDBClusterResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterResourceGroupWithOptions(request, runtime);
}

model ModifyDBClusterSSLRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-************'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.

> 

*   This parameter is required for PolarDB for MySQL clusters.

*   This parameter is not required for PolarDB for PostgreSQL or PolarDB for PostgreSQL (Compatible with Oracle) clusters. By default, SSL encryption is enabled for all endpoints of the clusters.

*   You can call the [DescribeDBClusterSSL](https://help.aliyun.com/document_detail/2319159.html) operation to view the details of the endpoint.', example='pe-******************'),
  netType?: string(name='NetType', description='The network type supported by the endpoint that is specified by **DBEndpointId**. Valid values:

*   **Public**
*   **Private**
*   **Inner**

> 

*   This parameter is required for a PolarDB for MySQL cluster.

*   This parameter is not required for a PolarDB for Oracle or PolarDB for PostgreSQL cluster. By default, SSL encryption is enabled for all endpoints.', example='Public'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  SSLAutoRotate?: string(name='SSLAutoRotate', description='Specifies whether automatic rotation of SSL certificates is enabled.

*   **Enable**: The feature is enabled.
*   **Disable**: The feature is disabled.', example='Enable'),
  SSLEnabled?: string(name='SSLEnabled', description='The SSL encryption status. Valid values:

*   **Disable**: SSL encryption is disabled.
*   **Enable**: SSL encryption is enabled.
*   **Update**: The SSL certificate is updated.

> After you enable SSL encryption or update the SSL certificate, you must download and configure the certificate. For more information, see [Configure SSL encryption](https://help.aliyun.com/document_detail/153182.html).', example='Enable'),
}

model ModifyDBClusterSSLResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='A94B1755-6D8B-4E27-BF3C-8562BC******'),
}

model ModifyDBClusterSSLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterSSLResponseBody(name='body'),
}

/**
 * @summary Enables or disables the SSL encryption feature for a PolarDB cluster, or updates the CA certificate of the cluster.
 *
 * @param request ModifyDBClusterSSLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterSSLResponse
 */
async function modifyDBClusterSSLWithOptions(request: ModifyDBClusterSSLRequest, runtime: Util.RuntimeOptions): ModifyDBClusterSSLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.SSLAutoRotate)) {
    query['SSLAutoRotate'] = request.SSLAutoRotate;
  }
  if (!Util.isUnset(request.SSLEnabled)) {
    query['SSLEnabled'] = request.SSLEnabled;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterSSL',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables or disables the SSL encryption feature for a PolarDB cluster, or updates the CA certificate of the cluster.
 *
 * @param request ModifyDBClusterSSLRequest
 * @return ModifyDBClusterSSLResponse
 */
async function modifyDBClusterSSL(request: ModifyDBClusterSSLRequest): ModifyDBClusterSSLResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterSSLWithOptions(request, runtime);
}

model ModifyDBClusterServerlessConfRequest {
  allowShutDown?: string(name='AllowShutDown', description='Specifies whether to enable No-activity Suspension. Default value: false. Valid values:

*   **true**
*   **false**', example='true'),
  crontabJobId?: string(name='CrontabJobId', description='Cycle policy ID.', example='143f8e9f-2566-4dff-be47-bed79f28fc78'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the serverless cluster.

This parameter is required.', example='pc-bp10gr51qasnl****'),
  fromTimeService?: boolean(name='FromTimeService', description='Specifies an immediate or scheduled task to modify parameters and restart the cluster. Valid values:

*   false: scheduled task
*   true: immediate task', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time for upgrading the specifications within the scheduled time period. Specify the time in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
> * The value of this parameter must be at least 30 minutes later than the value of PlannedStartTime.
>*   If you specify PlannedStartTime but do not specify PlannedEndTime, the latest start time of the task is set to a value that is calculated by using the following formula: `PlannedEndTime value + 30 minutes`. For example, if you set PlannedStartTime to `2021-01-14T09:00:00Z` and you do not specify PlannedEndTime, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time of the scheduled task for adding the read-only node. The scheduled task specifies that the task is run in the required period. Specify the time in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.

> *   The earliest start time of the scheduled task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in time between `2021-01-14T09:00:00Z` and `2021-01-15T09:00:00Z`.
>*   If you leave this parameter empty, the task for adding the read-only node is immediately run by default.', example='2021-01-14T09:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scaleApRoNumMax?: string(name='ScaleApRoNumMax', description='The maximum number of stable AP read-only nodes. Valid values: 0 to 7.', example='1'),
  scaleApRoNumMin?: string(name='ScaleApRoNumMin', description='The minimum number of stable AP read-only nodes. Valid values: 0 to 7.', example='1'),
  scaleMax?: string(name='ScaleMax', description='The maximum number of PCUs per node for scaling. Valid values: 1 PCU to 32 PCUs.', example='10'),
  scaleMin?: string(name='ScaleMin', description='The minimum number of PCUs per node for scaling. Valid values: 1 PCU to 31 PCUs.', example='1'),
  scaleRoNumMax?: string(name='ScaleRoNumMax', description='The maximum number of read-only nodes for scaling. Valid values: 0 to 15.', example='2'),
  scaleRoNumMin?: string(name='ScaleRoNumMin', description='The minimum number of read-only nodes for scaling. Valid values: 0 to 15.', example='1'),
  secondsUntilAutoPause?: string(name='SecondsUntilAutoPause', description='The detection period for No-activity Suspension. Valid values: 5 to 1440. Unit: minutes. The detection duration must be a multiple of 5 minutes.', example='10'),
  serverlessRuleCpuEnlargeThreshold?: string(name='ServerlessRuleCpuEnlargeThreshold', description='CPU burst threshold', example='80'),
  serverlessRuleCpuShrinkThreshold?: string(name='ServerlessRuleCpuShrinkThreshold', description='CPU downscale threshold', example='50'),
  serverlessRuleMode?: string(name='ServerlessRuleMode', description='Elastic sensitivity. Values: - normal: standard - flexible: sensitive', example='normal'),
  taskId?: string(name='TaskId', description='Asynchronous task ID.', example='143f8e9f-2566-4dff-be47-bed79f28fc78'),
}

model ModifyDBClusterServerlessConfResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the serverless cluster.', example='pc-bp10gr51qasnl****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5E71541A-6007-4DCC-A38A-F872C31FEB45'),
}

model ModifyDBClusterServerlessConfResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterServerlessConfResponseBody(name='body'),
}

/**
 * @summary Modifies the configurations of a serverless cluster.
 *
 * @param request ModifyDBClusterServerlessConfRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterServerlessConfResponse
 */
async function modifyDBClusterServerlessConfWithOptions(request: ModifyDBClusterServerlessConfRequest, runtime: Util.RuntimeOptions): ModifyDBClusterServerlessConfResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allowShutDown)) {
    query['AllowShutDown'] = request.allowShutDown;
  }
  if (!Util.isUnset(request.crontabJobId)) {
    query['CrontabJobId'] = request.crontabJobId;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.fromTimeService)) {
    query['FromTimeService'] = request.fromTimeService;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scaleApRoNumMax)) {
    query['ScaleApRoNumMax'] = request.scaleApRoNumMax;
  }
  if (!Util.isUnset(request.scaleApRoNumMin)) {
    query['ScaleApRoNumMin'] = request.scaleApRoNumMin;
  }
  if (!Util.isUnset(request.scaleMax)) {
    query['ScaleMax'] = request.scaleMax;
  }
  if (!Util.isUnset(request.scaleMin)) {
    query['ScaleMin'] = request.scaleMin;
  }
  if (!Util.isUnset(request.scaleRoNumMax)) {
    query['ScaleRoNumMax'] = request.scaleRoNumMax;
  }
  if (!Util.isUnset(request.scaleRoNumMin)) {
    query['ScaleRoNumMin'] = request.scaleRoNumMin;
  }
  if (!Util.isUnset(request.secondsUntilAutoPause)) {
    query['SecondsUntilAutoPause'] = request.secondsUntilAutoPause;
  }
  if (!Util.isUnset(request.serverlessRuleCpuEnlargeThreshold)) {
    query['ServerlessRuleCpuEnlargeThreshold'] = request.serverlessRuleCpuEnlargeThreshold;
  }
  if (!Util.isUnset(request.serverlessRuleCpuShrinkThreshold)) {
    query['ServerlessRuleCpuShrinkThreshold'] = request.serverlessRuleCpuShrinkThreshold;
  }
  if (!Util.isUnset(request.serverlessRuleMode)) {
    query['ServerlessRuleMode'] = request.serverlessRuleMode;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterServerlessConf',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the configurations of a serverless cluster.
 *
 * @param request ModifyDBClusterServerlessConfRequest
 * @return ModifyDBClusterServerlessConfResponse
 */
async function modifyDBClusterServerlessConf(request: ModifyDBClusterServerlessConfRequest): ModifyDBClusterServerlessConfResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterServerlessConfWithOptions(request, runtime);
}

model ModifyDBClusterStoragePerformanceRequest {
  burstingEnabled?: string(name='BurstingEnabled', description='Specifies whether to enable the I/O Burst feature for the ESSD AutoPL disk. Valid value:

*   **true**
*   **false** (default)

>  This parameter is available only when the StorageType parameter is set to ESSDAUTOPL.', example='false'),
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f******************'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-*************'),
  modifyType?: string(name='ModifyType', example='Upgrade'),
  provisionedIops?: int32(name='ProvisionedIops', example='2500'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  storageType?: string(name='StorageType', example='ESSDAUTOPL'),
}

model ModifyDBClusterStoragePerformanceResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-************'),
  orderId?: string(name='OrderId', example='2035629******'),
  requestId?: string(name='RequestId', example='E56531A4-E552-40BA-9C58-137B80******'),
}

model ModifyDBClusterStoragePerformanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterStoragePerformanceResponseBody(name='body'),
}

/**
 * @summary 修改存储性能
 *
 * @param request ModifyDBClusterStoragePerformanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterStoragePerformanceResponse
 */
async function modifyDBClusterStoragePerformanceWithOptions(request: ModifyDBClusterStoragePerformanceRequest, runtime: Util.RuntimeOptions): ModifyDBClusterStoragePerformanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.burstingEnabled)) {
    query['BurstingEnabled'] = request.burstingEnabled;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.modifyType)) {
    query['ModifyType'] = request.modifyType;
  }
  if (!Util.isUnset(request.provisionedIops)) {
    query['ProvisionedIops'] = request.provisionedIops;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterStoragePerformance',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改存储性能
 *
 * @param request ModifyDBClusterStoragePerformanceRequest
 * @return ModifyDBClusterStoragePerformanceResponse
 */
async function modifyDBClusterStoragePerformance(request: ModifyDBClusterStoragePerformanceRequest): ModifyDBClusterStoragePerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterStoragePerformanceWithOptions(request, runtime);
}

model ModifyDBClusterStorageSpaceRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  cloudProvider?: string(name='CloudProvider', example='ENS'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest time to upgrade the specifications within the scheduled time period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.
>- The value of this parameter must be at least 30 minutes later than PlannedStartTime.
>- By default, if you specify `PlannedStartTime` but do not specify PlannedEndTime, the latest start time of the task is set to `PlannedEndTime + 30 minutes`. For example, if you set `PlannedStartTime` to `2021-01-14T09:00:00Z` and you do not specify PlannedEndTime, the latest start time of the task is `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest time to upgrade the specifications within the scheduled time period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.
>- This parameter takes effect only when `ModifyType` is set to `Upgrade`.
>- The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in the time that ranges from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.
>- If this parameter is left empty, the upgrade task is immediately performed.', example='2021-01-14T09:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  storageSpace?: long(name='StorageSpace', description='The storage capacity that you can select when you change the cluster. Unit: GB.

>  You can set this parameter for PolarDB for MySQL clusters of Standard Edition to a value that ranges from 20 to 32000.

This parameter is required.', example='50'),
  subCategory?: string(name='SubCategory', description='The category of the cluster. Default value: ON. Valid values:

*   **normal_exclusive**: dedicated
*   **normal_general**: general-purpose', example='normal_general'),
}

model ModifyDBClusterStorageSpaceResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*************'),
  orderId?: string(name='OrderId', description='The order ID.', example='2035629******'),
  requestId?: string(name='RequestId', description='The request ID.', example='685F028C-4FCD-407D-A559-072D63******'),
}

model ModifyDBClusterStorageSpaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterStorageSpaceResponseBody(name='body'),
}

/**
 * @summary Changes the storage capacity of a pay-as-you-go cluster of Enterprise Edition or a cluster of Standard Edition.
 *
 * @param request ModifyDBClusterStorageSpaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterStorageSpaceResponse
 */
async function modifyDBClusterStorageSpaceWithOptions(request: ModifyDBClusterStorageSpaceRequest, runtime: Util.RuntimeOptions): ModifyDBClusterStorageSpaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.cloudProvider)) {
    query['CloudProvider'] = request.cloudProvider;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.storageSpace)) {
    query['StorageSpace'] = request.storageSpace;
  }
  if (!Util.isUnset(request.subCategory)) {
    query['SubCategory'] = request.subCategory;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterStorageSpace',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the storage capacity of a pay-as-you-go cluster of Enterprise Edition or a cluster of Standard Edition.
 *
 * @param request ModifyDBClusterStorageSpaceRequest
 * @return ModifyDBClusterStorageSpaceResponse
 */
async function modifyDBClusterStorageSpace(request: ModifyDBClusterStorageSpaceRequest): ModifyDBClusterStorageSpaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterStorageSpaceWithOptions(request, runtime);
}

model ModifyDBClusterTDERequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-************'),
  enableAutomaticRotation?: string(name='EnableAutomaticRotation', description='Specifies whether to allow the TDE key of the cluster to be automatically rotated within the next maintenance window after a lapse of the rotation period when a change in the KMS key version is detected. This parameter is supported only for custom keys. Valid values:

*   **true**
*   **false**

>  This parameter is supported only for a PolarDB for PostgreSQL or PolarDB for PostgreSQL (Compatible with Oracle) cluster.', example='false'),
  encryptNewTables?: string(name='EncryptNewTables', description='Specifies whether to enable automatic encryption for new tables. Valid values:

*   **ON**
*   **OFF**

>  This parameter takes effect only for a PolarDB for MySQL cluster.', example='ON'),
  encryptionKey?: string(name='EncryptionKey', description='The ID of the custom key.', example='749c1df7-****-****-****-*********'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleArn?: string(name='RoleArn', description='The Alibaba Cloud Resource Name (ARN) of the RAM role. A RAM role is a virtual identity that you can create within your Alibaba Cloud account. For more information, see [RAM role overview](https://help.aliyun.com/document_detail/93689.html).', example='acs:ram::1406926*****:role/aliyunrdsinstanceencryptiondefaultrole'),
  TDEStatus?: string(name='TDEStatus', description='Modifies the TDE status. Set the value to **Enable**.

This parameter is required.', example='Enable'),
}

model ModifyDBClusterTDEResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5F859238-2A36-4A8D-BD0F-732112******'),
}

model ModifyDBClusterTDEResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterTDEResponseBody(name='body'),
}

/**
 * @summary Enables the transparent data encryption (TDE) feature for a PolarDB cluster.
 *
 * @description > *   To perform this operation, you must activate KMS first. For more information, see [Purchase a dedicated KMS instance](https://help.aliyun.com/document_detail/153781.html).
 * > *   After TDE is enabled, you cannot disable TDE.
 *
 * @param request ModifyDBClusterTDERequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterTDEResponse
 */
async function modifyDBClusterTDEWithOptions(request: ModifyDBClusterTDERequest, runtime: Util.RuntimeOptions): ModifyDBClusterTDEResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.enableAutomaticRotation)) {
    query['EnableAutomaticRotation'] = request.enableAutomaticRotation;
  }
  if (!Util.isUnset(request.encryptNewTables)) {
    query['EncryptNewTables'] = request.encryptNewTables;
  }
  if (!Util.isUnset(request.encryptionKey)) {
    query['EncryptionKey'] = request.encryptionKey;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.roleArn)) {
    query['RoleArn'] = request.roleArn;
  }
  if (!Util.isUnset(request.TDEStatus)) {
    query['TDEStatus'] = request.TDEStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterTDE',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables the transparent data encryption (TDE) feature for a PolarDB cluster.
 *
 * @description > *   To perform this operation, you must activate KMS first. For more information, see [Purchase a dedicated KMS instance](https://help.aliyun.com/document_detail/153781.html).
 * > *   After TDE is enabled, you cannot disable TDE.
 *
 * @param request ModifyDBClusterTDERequest
 * @return ModifyDBClusterTDEResponse
 */
async function modifyDBClusterTDE(request: ModifyDBClusterTDERequest): ModifyDBClusterTDEResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterTDEWithOptions(request, runtime);
}

model ModifyDBClusterVpcRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-*************'),
  existedEndpointSwitchType?: string(name='ExistedEndpointSwitchType', description='This parameter is required.', example='NONE'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VPCId?: string(name='VPCId', example='vpc-*******************'),
  vSwitchId?: string(name='VSwitchId', description='This parameter is required.', example='vsw-**********'),
}

model ModifyDBClusterVpcResponseBody = {
  requestId?: string(name='RequestId', example='EBEAA83D-1734-42E3-85E3-E25F6E******'),
}

model ModifyDBClusterVpcResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterVpcResponseBody(name='body'),
}

/**
 * @summary 修改集群VSwitch参数
 *
 * @param request ModifyDBClusterVpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterVpcResponse
 */
async function modifyDBClusterVpcWithOptions(request: ModifyDBClusterVpcRequest, runtime: Util.RuntimeOptions): ModifyDBClusterVpcResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.existedEndpointSwitchType)) {
    query['ExistedEndpointSwitchType'] = request.existedEndpointSwitchType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterVpc',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改集群VSwitch参数
 *
 * @param request ModifyDBClusterVpcRequest
 * @return ModifyDBClusterVpcResponse
 */
async function modifyDBClusterVpc(request: ModifyDBClusterVpcRequest): ModifyDBClusterVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterVpcWithOptions(request, runtime);
}

model ModifyDBDescriptionRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-***************'),
  DBDescription?: string(name='DBDescription', description='The description of the database. The description must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must be 2 to 256 characters in length.

This parameter is required.', example='DBDesc'),
  DBName?: string(name='DBName', description='The name of the database.

This parameter is required.', example='testDB'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5F295AAB-B599-4F0E-96D0-DBFAB3******'),
}

model ModifyDBDescriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBDescriptionResponseBody(name='body'),
}

/**
 * @summary Modifies the description of a database in a PolarDB for MySQL cluster.
 *
 * @param request ModifyDBDescriptionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBDescriptionResponse
 */
async function modifyDBDescriptionWithOptions(request: ModifyDBDescriptionRequest, runtime: Util.RuntimeOptions): ModifyDBDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBDescription)) {
    query['DBDescription'] = request.DBDescription;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBDescription',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the description of a database in a PolarDB for MySQL cluster.
 *
 * @param request ModifyDBDescriptionRequest
 * @return ModifyDBDescriptionResponse
 */
async function modifyDBDescription(request: ModifyDBDescriptionRequest): ModifyDBDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBDescriptionWithOptions(request, runtime);
}

model ModifyDBDescriptionZonalRequest {
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5******'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  DBDescription?: string(name='DBDescription', description='This parameter is required.', example='testdesc'),
  DBName?: string(name='DBName', description='This parameter is required.', example='testDB'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBDescriptionZonalResponseBody = {
  requestId?: string(name='RequestId', example='EB07CFF0-D8A4-5C76-AED7-D00E26FC2***'),
}

model ModifyDBDescriptionZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBDescriptionZonalResponseBody(name='body'),
}

/**
 * @summary 修改PolarDB边缘云集群数据库描述
 *
 * @param request ModifyDBDescriptionZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBDescriptionZonalResponse
 */
async function modifyDBDescriptionZonalWithOptions(request: ModifyDBDescriptionZonalRequest, runtime: Util.RuntimeOptions): ModifyDBDescriptionZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBDescription)) {
    query['DBDescription'] = request.DBDescription;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBDescriptionZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改PolarDB边缘云集群数据库描述
 *
 * @param request ModifyDBDescriptionZonalRequest
 * @return ModifyDBDescriptionZonalResponse
 */
async function modifyDBDescriptionZonal(request: ModifyDBDescriptionZonalRequest): ModifyDBDescriptionZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBDescriptionZonalWithOptions(request, runtime);
}

model ModifyDBEndpointAddressRequest {
  connectionStringPrefix?: string(name='ConnectionStringPrefix', description='The prefix of the new endpoint. The prefix must meet the following requirements:

*   It can contain lowercase letters, digits, and hyphens (-).
*   It must start with a letter and end with a digit or a letter.
*   It must be 6 to 30 characters in length.', example='example'),
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pc-***************'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.

> You can call the [DescribeDBClusterEndpoints](https://help.aliyun.com/document_detail/98205.html) operation to query endpoint IDs.

This parameter is required.', example='pe-****************'),
  netType?: string(name='NetType', description='The network type of the endpoint. Valid values:

*   **Public**
*   **Private**

This parameter is required.', example='Public'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  port?: string(name='Port', description='The port number. Valid values: 3000 to 5999.

> This parameter is valid only for PolarDB for MySQL clusters. If you leave this parameter empty, the default port 3306 is used.', example='3306'),
  privateZoneAddressPrefix?: string(name='PrivateZoneAddressPrefix', description='The prefix of the private domain name. The prefix must meet the following requirements:

*   The prefix can contain lowercase letters, digits, and hyphens (-).
*   The prefix must start with a letter and end with a digit or a letter.
*   The prefix must be 6 to 30 characters in length.

>- You can bind each internal endpoint of PolarDB to a private domain name. The private domain name takes effect only in the specified virtual private clouds (VPCs) in the current region. Private domain names are managed by using PrivateZone. You can use the CNAME record of PrivateZone to map domain names to PolarDB. You are charged a small fee for this feature. For more information, see [Pricing](https://help.aliyun.com/document_detail/71338.html).
>- This parameter takes effect only if you set **NetType** to Private.', example='aliyundoc'),
  privateZoneName?: string(name='PrivateZoneName', description='The name of the private zone.

> This parameter takes effect only when **NetType** is set to Private.', example='aliyundoc.com'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBEndpointAddressResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model ModifyDBEndpointAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBEndpointAddressResponseBody(name='body'),
}

/**
 * @summary Modifies the endpoints of a PolarDB cluster, including the primary endpoint, default cluster endpoint, custom cluster endpoint, and private domain name.
 *
 * @param request ModifyDBEndpointAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBEndpointAddressResponse
 */
async function modifyDBEndpointAddressWithOptions(request: ModifyDBEndpointAddressRequest, runtime: Util.RuntimeOptions): ModifyDBEndpointAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionStringPrefix)) {
    query['ConnectionStringPrefix'] = request.connectionStringPrefix;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBEndpointId)) {
    query['DBEndpointId'] = request.DBEndpointId;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.privateZoneAddressPrefix)) {
    query['PrivateZoneAddressPrefix'] = request.privateZoneAddressPrefix;
  }
  if (!Util.isUnset(request.privateZoneName)) {
    query['PrivateZoneName'] = request.privateZoneName;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBEndpointAddress',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the endpoints of a PolarDB cluster, including the primary endpoint, default cluster endpoint, custom cluster endpoint, and private domain name.
 *
 * @param request ModifyDBEndpointAddressRequest
 * @return ModifyDBEndpointAddressResponse
 */
async function modifyDBEndpointAddress(request: ModifyDBEndpointAddressRequest): ModifyDBEndpointAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBEndpointAddressWithOptions(request, runtime);
}

model ModifyDBNodeClassRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  cloudProvider?: string(name='CloudProvider', example='ENS'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-*************'),
  DBNodeTargetClass?: string(name='DBNodeTargetClass', description='The specifications of all nodes. For more information, see [Specifications of computing nodes](https://help.aliyun.com/document_detail/102542.html).

This parameter is required.', example='polar.mysql.x4.large'),
  DBNodeType?: string(name='DBNodeType', description='The type of the node. Valid values:

*   RO
*   STANDBY
*   DLNode', example='DLNode'),
  modifyType?: string(name='ModifyType', description='The type of the configuration change. Valid values:

*   **Upgrade**
*   **Downgrade**

This parameter is required.', example='Upgrade'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to upgrade the specifications within the scheduled time period. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> *   The value of this parameter must be at least 30 minutes later than the value of PlannedStartTime.
>*   By default, if you specify `PlannedStartTime` but do not specify PlannedEndTime, the latest start time of the task is set to `Value of PlannedEndTime + 30 minutes`. For example, if you set `PlannedStartTime` to `2021-01-14T09:00:00Z` and you do not specify PlannedEndTime, the latest start time of the task is `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z'),
  plannedFlashingOffTime?: string(name='PlannedFlashingOffTime'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time to upgrade the specifications within the scheduled time period. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

>*   This parameter takes effect only when `ModifyType` is set to `Upgrade`.
>*   The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in the time that ranges from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.
>*   If this parameter is left empty, the upgrade task is immediately performed.', example='2021-01-14T09:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  subCategory?: string(name='SubCategory', description='The category of the cluster. Valid values:

*   **normal_exclusive**: dedicated.
*   **normal_general**: genera-purpose.', example='normal_general'),
}

model ModifyDBNodeClassResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*************'),
  orderId?: string(name='OrderId', description='The order ID.', example='2035629******'),
  requestId?: string(name='RequestId', description='The request ID.', example='685F028C-4FCD-407D-A559-072D63******'),
}

model ModifyDBNodeClassResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBNodeClassResponseBody(name='body'),
}

/**
 * @summary Changes the node specifications of a PolarDB cluster.
 *
 * @param request ModifyDBNodeClassRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBNodeClassResponse
 */
async function modifyDBNodeClassWithOptions(request: ModifyDBNodeClassRequest, runtime: Util.RuntimeOptions): ModifyDBNodeClassResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.cloudProvider)) {
    query['CloudProvider'] = request.cloudProvider;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeTargetClass)) {
    query['DBNodeTargetClass'] = request.DBNodeTargetClass;
  }
  if (!Util.isUnset(request.DBNodeType)) {
    query['DBNodeType'] = request.DBNodeType;
  }
  if (!Util.isUnset(request.modifyType)) {
    query['ModifyType'] = request.modifyType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedFlashingOffTime)) {
    query['PlannedFlashingOffTime'] = request.plannedFlashingOffTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.subCategory)) {
    query['SubCategory'] = request.subCategory;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBNodeClass',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the node specifications of a PolarDB cluster.
 *
 * @param request ModifyDBNodeClassRequest
 * @return ModifyDBNodeClassResponse
 */
async function modifyDBNodeClass(request: ModifyDBNodeClassRequest): ModifyDBNodeClassResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBNodeClassWithOptions(request, runtime);
}

model ModifyDBNodeConfigRequest {
  configName?: string(name='ConfigName', description='This parameter is required.', example='FailoverPriority'),
  configValue?: string(name='ConfigValue', description='This parameter is required.', example='perfdb'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  DBNodeId?: string(name='DBNodeId', description='This parameter is required.', example='pi-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyDBNodeConfigResponseBody = {
  requestId?: string(name='RequestId', example='925B84D9-CA72-432C-95CF-738C22******'),
}

model ModifyDBNodeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBNodeConfigResponseBody(name='body'),
}

/**
 * @param request ModifyDBNodeConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBNodeConfigResponse
 */
async function modifyDBNodeConfigWithOptions(request: ModifyDBNodeConfigRequest, runtime: Util.RuntimeOptions): ModifyDBNodeConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configName)) {
    query['ConfigName'] = request.configName;
  }
  if (!Util.isUnset(request.configValue)) {
    query['ConfigValue'] = request.configValue;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeId)) {
    query['DBNodeId'] = request.DBNodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBNodeConfig',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ModifyDBNodeConfigRequest
 * @return ModifyDBNodeConfigResponse
 */
async function modifyDBNodeConfig(request: ModifyDBNodeConfigRequest): ModifyDBNodeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBNodeConfigWithOptions(request, runtime);
}

model ModifyDBNodeDescriptionRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-***************'),
  DBNodeDescription?: string(name='DBNodeDescription', description='This parameter is required.', example='NodeDescriptionTest'),
  DBNodeId?: string(name='DBNodeId', description='This parameter is required.', example='pi-*****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBNodeDescriptionResponseBody = {
  requestId?: string(name='RequestId', example='69A85BAF-1089-4CDF-A82F-0A140F******'),
}

model ModifyDBNodeDescriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBNodeDescriptionResponseBody(name='body'),
}

/**
 * @summary 修改物理节点描述
 *
 * @param request ModifyDBNodeDescriptionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBNodeDescriptionResponse
 */
async function modifyDBNodeDescriptionWithOptions(request: ModifyDBNodeDescriptionRequest, runtime: Util.RuntimeOptions): ModifyDBNodeDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeDescription)) {
    query['DBNodeDescription'] = request.DBNodeDescription;
  }
  if (!Util.isUnset(request.DBNodeId)) {
    query['DBNodeId'] = request.DBNodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBNodeDescription',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改物理节点描述
 *
 * @param request ModifyDBNodeDescriptionRequest
 * @return ModifyDBNodeDescriptionResponse
 */
async function modifyDBNodeDescription(request: ModifyDBNodeDescriptionRequest): ModifyDBNodeDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBNodeDescriptionWithOptions(request, runtime);
}

model ModifyDBNodeHotReplicaModeRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pc-2vc327c2a14a3u858'),
  DBNodeId?: string(name='DBNodeId', description='The ID of the node in the cluster.

This parameter is required.', example='pi-2ze28275h9x5r4wt1'),
  hotReplicaMode?: string(name='HotReplicaMode', description='Specifies whether to enable the hot standby feature. Valid values:

*   **ON**
*   **OFF**

This parameter is required.', example='ON'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBNodeHotReplicaModeResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.', example='pc-2vc327c2a14a3u858'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2148126708*****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9F4DDFBF-205C-5A3E-8DC2-C60F3E3FDC38'),
}

model ModifyDBNodeHotReplicaModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBNodeHotReplicaModeResponseBody(name='body'),
}

/**
 * @summary Enables or disables the failover with hot replica feature for a node in a cluster.
 *
 * @param request ModifyDBNodeHotReplicaModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBNodeHotReplicaModeResponse
 */
async function modifyDBNodeHotReplicaModeWithOptions(request: ModifyDBNodeHotReplicaModeRequest, runtime: Util.RuntimeOptions): ModifyDBNodeHotReplicaModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeId)) {
    query['DBNodeId'] = request.DBNodeId;
  }
  if (!Util.isUnset(request.hotReplicaMode)) {
    query['HotReplicaMode'] = request.hotReplicaMode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBNodeHotReplicaMode',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables or disables the failover with hot replica feature for a node in a cluster.
 *
 * @param request ModifyDBNodeHotReplicaModeRequest
 * @return ModifyDBNodeHotReplicaModeResponse
 */
async function modifyDBNodeHotReplicaMode(request: ModifyDBNodeHotReplicaModeRequest): ModifyDBNodeHotReplicaModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBNodeHotReplicaModeWithOptions(request, runtime);
}

model ModifyDBNodeSccModeRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-****************'),
  DBNodeId?: string(name='DBNodeId', description='This parameter is required.', example='pi-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sccMode?: string(name='SccMode', description='SCC

This parameter is required.', example='OFF'),
}

model ModifyDBNodeSccModeResponseBody = {
  requestId?: string(name='RequestId', example='E2FDB684-751D-424D-98B9-704BEA******'),
}

model ModifyDBNodeSccModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBNodeSccModeResponseBody(name='body'),
}

/**
 * @summary 修改节点的Scc
 *
 * @param request ModifyDBNodeSccModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBNodeSccModeResponse
 */
async function modifyDBNodeSccModeWithOptions(request: ModifyDBNodeSccModeRequest, runtime: Util.RuntimeOptions): ModifyDBNodeSccModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeId)) {
    query['DBNodeId'] = request.DBNodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sccMode)) {
    query['SccMode'] = request.sccMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBNodeSccMode',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改节点的Scc
 *
 * @param request ModifyDBNodeSccModeRequest
 * @return ModifyDBNodeSccModeResponse
 */
async function modifyDBNodeSccMode(request: ModifyDBNodeSccModeRequest): ModifyDBNodeSccModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBNodeSccModeWithOptions(request, runtime);
}

model ModifyDBNodesClassRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  cloudProvider?: string(name='CloudProvider', example='ENS'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-*************'),
  DBNode?: [ 
    {
      DBNodeId?: string(name='DBNodeId', description='The ID of the node.

>  If you specify this parameter, DBNode.N.TargetClass is required. N is an integer that starts from 1. The maximum value of N is calculated by using the following formula:16 - The number of current nodes.', example='pi-*************'),
      targetClass?: string(name='TargetClass', description='The specifications of the node that you want to change. For more information, see [Specifications of compute nodes](https://help.aliyun.com/document_detail/102542.html).

>  If you specify this parameter, DBNode.N.DBNodeId is required. N is an integer that starts from 1. The maximum value of N is calculated by using the following formula:16 - The number of current nodes.', example='polar.mysql.x4.medium'),
    }
  ](name='DBNode', description='The details of the nodes.

This parameter is required.'),
  modifyType?: string(name='ModifyType', description='The type of the configuration change. Valid values:

*   **Upgrade**
*   **Downgrade**

This parameter is required.', example='Upgrade'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to upgrade the specifications within the scheduled time period. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

>*   The value of this parameter must be at least 30 minutes later than the value of PlannedStartTime.
>*   By default, if you specify `PlannedStartTime` but do not specify PlannedEndTime, the latest start time of the task is set to `Value of PlannedEndTime + 30 minutes`. For example, if you set `PlannedStartTime` to `2021-01-14T09:00:00Z` and you do not specify PlannedEndTime, the latest start time of the task is `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z'),
  plannedFlashingOffTime?: string(name='PlannedFlashingOffTime'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time to upgrade the specifications within the scheduled time period. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> *   This parameter takes effect only when `ModifyType` is set to `Upgrade`.
>*   The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in the time that ranges from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.
>*   If this parameter is left empty, the upgrade task is immediately performed.', example='2021-01-14T09:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  subCategory?: string(name='SubCategory', description='The category of the cluster. Valid values:

*   **normal_exclusive**: dedicated
*   **normal_general**: genera-purpose', example='normal_general'),
}

model ModifyDBNodesClassResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*************'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2035629******'),
  requestId?: string(name='RequestId', description='The request ID.', example='685F028C-4FCD-407D-A559-072D63******'),
}

model ModifyDBNodesClassResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBNodesClassResponseBody(name='body'),
}

/**
 * @summary Changes the specifications of a node in a PolarDB cluster.
 *
 * @param request ModifyDBNodesClassRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBNodesClassResponse
 */
async function modifyDBNodesClassWithOptions(request: ModifyDBNodesClassRequest, runtime: Util.RuntimeOptions): ModifyDBNodesClassResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.cloudProvider)) {
    query['CloudProvider'] = request.cloudProvider;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNode)) {
    query['DBNode'] = request.DBNode;
  }
  if (!Util.isUnset(request.modifyType)) {
    query['ModifyType'] = request.modifyType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedFlashingOffTime)) {
    query['PlannedFlashingOffTime'] = request.plannedFlashingOffTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.subCategory)) {
    query['SubCategory'] = request.subCategory;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBNodesClass',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the specifications of a node in a PolarDB cluster.
 *
 * @param request ModifyDBNodesClassRequest
 * @return ModifyDBNodesClassResponse
 */
async function modifyDBNodesClass(request: ModifyDBNodesClassRequest): ModifyDBNodesClassResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBNodesClassWithOptions(request, runtime);
}

model ModifyDBNodesParametersRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-**************'),
  DBNodeIds?: string(name='DBNodeIds', description='The ID of the node. You can specify multiple node IDs. Separate multiple node IDs with commas (,).

This parameter is required.', example='pi-****************， pi-****************'),
  fromTimeService?: boolean(name='FromTimeService', description='Specifies whether to immediately run the task to modify parameters and restart the cluster. Valid values: false: runs the task on schedule. true: runs the task immediately. Default value: false.', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template that is used for the cluster.', example='pcpg-**************'),
  parameters?: string(name='Parameters', description='The JSON string that specifies the parameter and its value.', example='{"wait_timeout":"86","innodb_old_blocks_time":"10"}'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to run the task. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.', example='2022-04-28T14:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time to run the task to upgrade the kernel version of the cluster. The task runs within a specified period of time. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.', example='2022-04-28T14:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBNodesParametersResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EBEAA83D-1734-42E3-85E3-E25F6E******'),
}

model ModifyDBNodesParametersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBNodesParametersResponseBody(name='body'),
}

/**
 * @summary Modifies the parameters of a node and applies them to specified nodes.
 *
 * @param request ModifyDBNodesParametersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBNodesParametersResponse
 */
async function modifyDBNodesParametersWithOptions(request: ModifyDBNodesParametersRequest, runtime: Util.RuntimeOptions): ModifyDBNodesParametersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeIds)) {
    query['DBNodeIds'] = request.DBNodeIds;
  }
  if (!Util.isUnset(request.fromTimeService)) {
    query['FromTimeService'] = request.fromTimeService;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupId)) {
    query['ParameterGroupId'] = request.parameterGroupId;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBNodesParameters',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the parameters of a node and applies them to specified nodes.
 *
 * @param request ModifyDBNodesParametersRequest
 * @return ModifyDBNodesParametersResponse
 */
async function modifyDBNodesParameters(request: ModifyDBNodesParametersRequest): ModifyDBNodesParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBNodesParametersWithOptions(request, runtime);
}

model ModifyEncryptionDBRolePrivilegeRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-***************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  rolePrivilegeConfig?: string(name='RolePrivilegeConfig', example='{"notEncryption":["alton"],"encryption":["alton01"]}'),
  rolePrivilegeName?: string(name='RolePrivilegeName', example='test'),
}

model ModifyEncryptionDBRolePrivilegeResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-******************'),
  requestId?: string(name='RequestId', description='Id of the request', example='925B84D9-CA72-432C-95CF-738C22******'),
}

model ModifyEncryptionDBRolePrivilegeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyEncryptionDBRolePrivilegeResponseBody(name='body'),
}

/**
 * @summary 变更角色权限
 *
 * @param request ModifyEncryptionDBRolePrivilegeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyEncryptionDBRolePrivilegeResponse
 */
async function modifyEncryptionDBRolePrivilegeWithOptions(request: ModifyEncryptionDBRolePrivilegeRequest, runtime: Util.RuntimeOptions): ModifyEncryptionDBRolePrivilegeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.rolePrivilegeConfig)) {
    query['RolePrivilegeConfig'] = request.rolePrivilegeConfig;
  }
  if (!Util.isUnset(request.rolePrivilegeName)) {
    query['RolePrivilegeName'] = request.rolePrivilegeName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyEncryptionDBRolePrivilege',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 变更角色权限
 *
 * @param request ModifyEncryptionDBRolePrivilegeRequest
 * @return ModifyEncryptionDBRolePrivilegeResponse
 */
async function modifyEncryptionDBRolePrivilege(request: ModifyEncryptionDBRolePrivilegeRequest): ModifyEncryptionDBRolePrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyEncryptionDBRolePrivilegeWithOptions(request, runtime);
}

model ModifyEncryptionDBSecretRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-****************'),
  encryptionDBStatus?: string(name='EncryptionDBStatus', example='Enabled'),
  encryptionKey?: string(name='EncryptionKey', example='749c1df7-****-****-****-*********'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleArn?: string(name='RoleArn', example='acs:ram::1406926*****:role/aliyunrdsinstanceencryptiondefaultrole'),
}

model ModifyEncryptionDBSecretResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-***************'),
  message?: string(name='Message', example='Successful'),
  requestId?: string(name='RequestId', description='Id of the request', example='4CE6DF97-AEA4-484F-906F-C407EE******'),
  success?: boolean(name='Success', example='true'),
}

model ModifyEncryptionDBSecretResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyEncryptionDBSecretResponseBody(name='body'),
}

/**
 * @summary 变更加密策略
 *
 * @param request ModifyEncryptionDBSecretRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyEncryptionDBSecretResponse
 */
async function modifyEncryptionDBSecretWithOptions(request: ModifyEncryptionDBSecretRequest, runtime: Util.RuntimeOptions): ModifyEncryptionDBSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.encryptionDBStatus)) {
    query['EncryptionDBStatus'] = request.encryptionDBStatus;
  }
  if (!Util.isUnset(request.encryptionKey)) {
    query['EncryptionKey'] = request.encryptionKey;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.roleArn)) {
    query['RoleArn'] = request.roleArn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyEncryptionDBSecret',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 变更加密策略
 *
 * @param request ModifyEncryptionDBSecretRequest
 * @return ModifyEncryptionDBSecretResponse
 */
async function modifyEncryptionDBSecret(request: ModifyEncryptionDBSecretRequest): ModifyEncryptionDBSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyEncryptionDBSecretWithOptions(request, runtime);
}

model ModifyFirewallRulesRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-*****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleConfig?: string(name='RuleConfig', description='This parameter is required.', example='{"id":"test","enabled":"true","mode":"Collecting","users":{"applies_to":[]},"endpoint":"[{"EndpointName":"pe-************","EndpointType":"Cluster","DBEndpointDescription":"Cluster Address"},{"EndpointName":"pe-************","EndpointType":"Custom","DBEndpointDescription":"pc-************"},{"EndpointName":"pe-************","EndpointType":"Custom","DBEndpointDescription":"pc-************K"}]","type":"WhiteList"}'),
  ruleName?: string(name='RuleName', description='This parameter is required.', example='test'),
}

model ModifyFirewallRulesResponseBody = {
  message?: string(name='Message', example='Successful'),
  requestId?: string(name='RequestId', description='Id of the request', example='A8DBA3A7-82FB-5CBE-A002-8959E47D1D61'),
  success?: boolean(name='Success', example='true'),
}

model ModifyFirewallRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyFirewallRulesResponseBody(name='body'),
}

/**
 * @summary 修改sql防火墙配置
 *
 * @param request ModifyFirewallRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyFirewallRulesResponse
 */
async function modifyFirewallRulesWithOptions(request: ModifyFirewallRulesRequest, runtime: Util.RuntimeOptions): ModifyFirewallRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleConfig)) {
    query['RuleConfig'] = request.ruleConfig;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyFirewallRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改sql防火墙配置
 *
 * @param request ModifyFirewallRulesRequest
 * @return ModifyFirewallRulesResponse
 */
async function modifyFirewallRules(request: ModifyFirewallRulesRequest): ModifyFirewallRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFirewallRulesWithOptions(request, runtime);
}

model ModifyGlobalDatabaseNetworkRequest {
  enableGlobalDomainName?: boolean(name='EnableGlobalDomainName', description='Create a global domain', example='false'),
  GDNDescription?: string(name='GDNDescription', description='The description of the GDN. The description must meet the following requirements:

*   The description cannot start with http:// or https://.
*   The description must start with a letter.
*   The description can contain letters, digits, underscores (_), and hyphens (-).
*   The description must be 2 to 126 characters in length.', example='GDN-fortest'),
  GDNId?: string(name='GDNId', description='The GDN ID.

This parameter is required.', example='gdn-bp1fttxsrmv*****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyGlobalDatabaseNetworkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C61892A4-0850-4516-9E26-44D96C1782DE'),
}

model ModifyGlobalDatabaseNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyGlobalDatabaseNetworkResponseBody(name='body'),
}

/**
 * @summary Modifies a global database network (GDN).
 *
 * @param request ModifyGlobalDatabaseNetworkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyGlobalDatabaseNetworkResponse
 */
async function modifyGlobalDatabaseNetworkWithOptions(request: ModifyGlobalDatabaseNetworkRequest, runtime: Util.RuntimeOptions): ModifyGlobalDatabaseNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.enableGlobalDomainName)) {
    query['EnableGlobalDomainName'] = request.enableGlobalDomainName;
  }
  if (!Util.isUnset(request.GDNDescription)) {
    query['GDNDescription'] = request.GDNDescription;
  }
  if (!Util.isUnset(request.GDNId)) {
    query['GDNId'] = request.GDNId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGlobalDatabaseNetwork',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a global database network (GDN).
 *
 * @param request ModifyGlobalDatabaseNetworkRequest
 * @return ModifyGlobalDatabaseNetworkResponse
 */
async function modifyGlobalDatabaseNetwork(request: ModifyGlobalDatabaseNetworkRequest): ModifyGlobalDatabaseNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalDatabaseNetworkWithOptions(request, runtime);
}

model ModifyGlobalSecurityIPGroupRequest {
  GIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Multiple IP addresses are separated by commas (,). You can create up to 1,000 IP addresses or CIDR blocks for all IP whitelists.

This parameter is required.', example='192.168.0.1'),
  globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or digit.
*   The name must be 2 to 120 characters in length.

This parameter is required.', example='test_123'),
  globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.

This parameter is required.', example='g-zsldxfiwjmti0kcm****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyGlobalSecurityIPGroupResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      DBInstances?: [ string ](name='DBInstances', description='The clusters that are associated with the IP address whitelist template.'),
      GIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroup', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model ModifyGlobalSecurityIPGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyGlobalSecurityIPGroupResponseBody(name='body'),
}

/**
 * @summary Modifies an IP whitelist template.
 *
 * @param request ModifyGlobalSecurityIPGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyGlobalSecurityIPGroupResponse
 */
async function modifyGlobalSecurityIPGroupWithOptions(request: ModifyGlobalSecurityIPGroupRequest, runtime: Util.RuntimeOptions): ModifyGlobalSecurityIPGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.GIpList)) {
    query['GIpList'] = request.GIpList;
  }
  if (!Util.isUnset(request.globalIgName)) {
    query['GlobalIgName'] = request.globalIgName;
  }
  if (!Util.isUnset(request.globalSecurityGroupId)) {
    query['GlobalSecurityGroupId'] = request.globalSecurityGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGlobalSecurityIPGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies an IP whitelist template.
 *
 * @param request ModifyGlobalSecurityIPGroupRequest
 * @return ModifyGlobalSecurityIPGroupResponse
 */
async function modifyGlobalSecurityIPGroup(request: ModifyGlobalSecurityIPGroupRequest): ModifyGlobalSecurityIPGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalSecurityIPGroupWithOptions(request, runtime);
}

model ModifyGlobalSecurityIPGroupNameRequest {
  globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or digit.
*   The name must be 2 to 120 characters in length.

This parameter is required.', example='test_123'),
  globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.

This parameter is required.', example='g-zsldxfiwjmti0kcm****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyGlobalSecurityIPGroupNameResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      GIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroup', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model ModifyGlobalSecurityIPGroupNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyGlobalSecurityIPGroupNameResponseBody(name='body'),
}

/**
 * @summary Modifies the name of a global IP whitelist template.
 *
 * @param request ModifyGlobalSecurityIPGroupNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyGlobalSecurityIPGroupNameResponse
 */
async function modifyGlobalSecurityIPGroupNameWithOptions(request: ModifyGlobalSecurityIPGroupNameRequest, runtime: Util.RuntimeOptions): ModifyGlobalSecurityIPGroupNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalIgName)) {
    query['GlobalIgName'] = request.globalIgName;
  }
  if (!Util.isUnset(request.globalSecurityGroupId)) {
    query['GlobalSecurityGroupId'] = request.globalSecurityGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGlobalSecurityIPGroupName',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the name of a global IP whitelist template.
 *
 * @param request ModifyGlobalSecurityIPGroupNameRequest
 * @return ModifyGlobalSecurityIPGroupNameResponse
 */
async function modifyGlobalSecurityIPGroupName(request: ModifyGlobalSecurityIPGroupNameRequest): ModifyGlobalSecurityIPGroupNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalSecurityIPGroupNameWithOptions(request, runtime);
}

model ModifyGlobalSecurityIPGroupRelationRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-*****************'),
  globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.

This parameter is required.', example='g-zsldxfiwjmti0kcm****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyGlobalSecurityIPGroupRelationResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-*****************'),
  globalSecurityIPGroupRel?: [ 
    {
      GIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroupRel', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model ModifyGlobalSecurityIPGroupRelationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyGlobalSecurityIPGroupRelationResponseBody(name='body'),
}

/**
 * @summary Modifies the relationship between a cluster and a global IP whitelist template.
 *
 * @param request ModifyGlobalSecurityIPGroupRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyGlobalSecurityIPGroupRelationResponse
 */
async function modifyGlobalSecurityIPGroupRelationWithOptions(request: ModifyGlobalSecurityIPGroupRelationRequest, runtime: Util.RuntimeOptions): ModifyGlobalSecurityIPGroupRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.globalSecurityGroupId)) {
    query['GlobalSecurityGroupId'] = request.globalSecurityGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGlobalSecurityIPGroupRelation',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the relationship between a cluster and a global IP whitelist template.
 *
 * @param request ModifyGlobalSecurityIPGroupRelationRequest
 * @return ModifyGlobalSecurityIPGroupRelationResponse
 */
async function modifyGlobalSecurityIPGroupRelation(request: ModifyGlobalSecurityIPGroupRelationRequest): ModifyGlobalSecurityIPGroupRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalSecurityIPGroupRelationWithOptions(request, runtime);
}

model ModifyLogBackupPolicyRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the information of all clusters that are deployed in a specific region, such as the cluster IDs.

This parameter is required.', example='pc-****************'),
  logBackupAnotherRegionRegion?: string(name='LogBackupAnotherRegionRegion', description='The region in which you want to store cross-region log backups. For information about regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='cn-hangzhou'),
  logBackupAnotherRegionRetentionPeriod?: string(name='LogBackupAnotherRegionRetentionPeriod', description='The retention period of cross-region log backups. Valid values:

*   **0**: The cross-region backup feature is disabled.
*   **30 to 7300**: Cross-region log backups are retained for 30 to 7,300 days.
*   **-1**: The log backups are permanently retained.

>  When you create a cluster, the default value of this parameter is **0**.', example='30'),
  logBackupRetentionPeriod?: string(name='LogBackupRetentionPeriod', description='The retention period of the log backups. Valid values:

*   3 to 7300: The log backups are retained for 3 to 7,300 days.
*   \\\\-1: The log backups are permanently retained.', example='3'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyLogBackupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='345174B4-FAB3-412E-A326-BEDDA9******'),
}

model ModifyLogBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLogBackupPolicyResponseBody(name='body'),
}

/**
 * @summary Modifies the retention policy of the log backups in a PolarDB cluster.
 *
 * @param request ModifyLogBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyLogBackupPolicyResponse
 */
async function modifyLogBackupPolicyWithOptions(request: ModifyLogBackupPolicyRequest, runtime: Util.RuntimeOptions): ModifyLogBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.logBackupAnotherRegionRegion)) {
    query['LogBackupAnotherRegionRegion'] = request.logBackupAnotherRegionRegion;
  }
  if (!Util.isUnset(request.logBackupAnotherRegionRetentionPeriod)) {
    query['LogBackupAnotherRegionRetentionPeriod'] = request.logBackupAnotherRegionRetentionPeriod;
  }
  if (!Util.isUnset(request.logBackupRetentionPeriod)) {
    query['LogBackupRetentionPeriod'] = request.logBackupRetentionPeriod;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyLogBackupPolicy',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the retention policy of the log backups in a PolarDB cluster.
 *
 * @param request ModifyLogBackupPolicyRequest
 * @return ModifyLogBackupPolicyResponse
 */
async function modifyLogBackupPolicy(request: ModifyLogBackupPolicyRequest): ModifyLogBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLogBackupPolicyWithOptions(request, runtime);
}

model ModifyMaskingRulesRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pc-*****************'),
  defaultAlgo?: string(name='DefaultAlgo'),
  enable?: string(name='Enable', description='Specifies whether to enable the specified masking rule. Valid values:

*   **true**
*   **false**

> This parameter is valid only when the `RuleNameList` parameter is specfied.', example='true'),
  interfaceVersion?: string(name='InterfaceVersion'),
  maskingAlgo?: string(name='MaskingAlgo'),
  ruleConfig?: string(name='RuleConfig', description='The parameter that is used to specify the masking rule that you want to modify and the value in the JSON format. All parameter values are of the string type. Example: `{"auto": {"databases": ["db1"], "tables": ["tb1"], "columns": ["c1,c2"] }, "description": "This rule will be applied to the columns c1 and c2 in table t1", "enabled": true, "applies_to": ["user"]}`. Where,

*   `"auto"`: specifies that the dynamic masking algorithm is supported. This parameter is required.
*   `"databases"`: Optional. The names of databases to which the masking rule is applied. Separate the names with commas (,). If you leave this parameter empty, the masking rule applies to all databases in the cluster.
*   `"tables"`: Optional. The names of tables to which the masking rule is applied. Separate the names with commas (,). If you leave this parameter empty, the rule applies to all tables in the cluster.
*   `"columns"`: Required. The names of fields to which the masking rule is applied. Separate the names with commas (,).
*   `"description"`: Optional. The description of the masking rule. The description is up to 64 characters in length.
*   `"enabled"`: Required. Specifies whether to enable the masking rule. Valid values: **true** (enable) and **false** (disable).
*   `"applies_to"`: The names of database accounts to which the masking rule is applied. Separate the names with commas (,).
*   `"exempted"`: The names of database accounts to which the masking rule is not applied. Separate the names with commas (,).

> 

*   If you specify `RuleName`, `RuleConfig` parameter is required.

*   You need to select either `"applies_to"` or `"exempted"`.', example='{"auto": {"databases": ["db1"], "tables": ["tb1"], "columns": ["c1,c2"] }, "description": "This rule will be applied to the columns c1 and c2 in table t1", "enabled": true, "applies_to": ["user"]}'),
  ruleName?: string(name='RuleName', description='The name of the data masking rule. You can specify only one rule name at a time.

> 

*   You can call the [DescribeMaskingRules](https://help.aliyun.com/document_detail/212573.html) operation to query the details of all masking rules for a specified cluster, such as the names of the masking rules.

*   If the rule name does not exist in the cluster, the system automatically creates a masking rule based on the name and the value of `RuleConfig`.', example='testrule'),
  ruleNameList?: string(name='RuleNameList', description='The list of masking rule names. You can specify one or more masking rules at a time. Separate the masking rule names with commas (,).

> You must specify either the `RuleName` or `RuleNameList` parameter.', example='testrule'),
  ruleVersion?: string(name='RuleVersion', description='The version of the masking rule. Default value: v1. Valid values:

*   v1
*   v2', example='v2'),
}

model ModifyMaskingRulesResponseBody = {
  message?: string(name='Message', description='The message that is returned for the request.

> If the request is successful, Successful is returned. If the request fails, an error message such as an error code is returned.', example='Message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='99B355CE-526C-478B-B730-AD9D7C******'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid value:

*   **true**:
*   **false**', example='true'),
}

model ModifyMaskingRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyMaskingRulesResponseBody(name='body'),
}

/**
 * @summary Modifies or adds a data masking rule.
 *
 * @param request ModifyMaskingRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyMaskingRulesResponse
 */
async function modifyMaskingRulesWithOptions(request: ModifyMaskingRulesRequest, runtime: Util.RuntimeOptions): ModifyMaskingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.defaultAlgo)) {
    query['DefaultAlgo'] = request.defaultAlgo;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.interfaceVersion)) {
    query['InterfaceVersion'] = request.interfaceVersion;
  }
  if (!Util.isUnset(request.maskingAlgo)) {
    query['MaskingAlgo'] = request.maskingAlgo;
  }
  if (!Util.isUnset(request.ruleConfig)) {
    query['RuleConfig'] = request.ruleConfig;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleNameList)) {
    query['RuleNameList'] = request.ruleNameList;
  }
  if (!Util.isUnset(request.ruleVersion)) {
    query['RuleVersion'] = request.ruleVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyMaskingRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies or adds a data masking rule.
 *
 * @param request ModifyMaskingRulesRequest
 * @return ModifyMaskingRulesResponse
 */
async function modifyMaskingRules(request: ModifyMaskingRulesRequest): ModifyMaskingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMaskingRulesWithOptions(request, runtime);
}

model ModifyPendingMaintenanceActionRequest {
  ids?: string(name='Ids', description='The ID of the task. You can specify multiple task IDs at a time to modify the switching time of the tasks in a unified manner. The task IDs must be separated with commas (,).

This parameter is required.', example='111111'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the region ID details.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  switchTime?: string(name='SwitchTime', description='The time that you specify for the background to perform the action that corresponds to the pending event. Specify the time in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in UTC.

This parameter is required.', example='2020-06-09T22:00:00Z'),
}

model ModifyPendingMaintenanceActionResponseBody = {
  ids?: string(name='Ids', description='The ID of the task.', example='111111'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='93061E17-B56A-4324-BC95-D0FFD2******'),
}

model ModifyPendingMaintenanceActionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyPendingMaintenanceActionResponseBody(name='body'),
}

/**
 * @summary Modifies the switching time of a pending event.
 *
 * @param request ModifyPendingMaintenanceActionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPendingMaintenanceActionResponse
 */
async function modifyPendingMaintenanceActionWithOptions(request: ModifyPendingMaintenanceActionRequest, runtime: Util.RuntimeOptions): ModifyPendingMaintenanceActionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.switchTime)) {
    query['SwitchTime'] = request.switchTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPendingMaintenanceAction',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the switching time of a pending event.
 *
 * @param request ModifyPendingMaintenanceActionRequest
 * @return ModifyPendingMaintenanceActionResponse
 */
async function modifyPendingMaintenanceAction(request: ModifyPendingMaintenanceActionRequest): ModifyPendingMaintenanceActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPendingMaintenanceActionWithOptions(request, runtime);
}

model ModifyResourcePackageRequest {
  autoQuota?: boolean(name='AutoQuota', example='true'),
  resourcePackageId?: string(name='ResourcePackageId', description='This parameter is required.', example='pm-bp11b0i9389******'),
}

model ModifyResourcePackageResponseBody = {
  requestId?: string(name='RequestId', example='E56531A4-E552-40BA-9C58-137B80******'),
}

model ModifyResourcePackageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyResourcePackageResponseBody(name='body'),
}

/**
 * @summary 配置资源包
 *
 * @param request ModifyResourcePackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyResourcePackageResponse
 */
async function modifyResourcePackageWithOptions(request: ModifyResourcePackageRequest, runtime: Util.RuntimeOptions): ModifyResourcePackageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoQuota)) {
    query['AutoQuota'] = request.autoQuota;
  }
  if (!Util.isUnset(request.resourcePackageId)) {
    query['ResourcePackageId'] = request.resourcePackageId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyResourcePackage',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 配置资源包
 *
 * @param request ModifyResourcePackageRequest
 * @return ModifyResourcePackageResponse
 */
async function modifyResourcePackage(request: ModifyResourcePackageRequest): ModifyResourcePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyResourcePackageWithOptions(request, runtime);
}

model ModifySQLRateLimitingRulesRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleConfig?: string(name='RuleConfig', description='This parameter is required.', example='{"id":"test","enabled":"true","match_mode":"0","template":"dXBkYXRlIHQgc2V0IGEgPSAxIHdoZXJlIGlkID0gMQ==","user":"","database":"","waiting":1024,"endpoint":"[{"EndpointName":"pe-***********","EndpointType":"Cluster","DBEndpointDescription":"Cluster Address"}]","throttle_mode":0,"concurrency":1}'),
  ruleName?: string(name='RuleName', description='This parameter is required.', example='testrule'),
}

model ModifySQLRateLimitingRulesResponseBody = {
  message?: string(name='Message', example='Successful'),
  requestId?: string(name='RequestId', description='Id of the request', example='35D3E3DA-4650-407A-BFF5-59BFF1******'),
  success?: boolean(name='Success', example='true'),
}

model ModifySQLRateLimitingRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySQLRateLimitingRulesResponseBody(name='body'),
}

/**
 * @summary 修改SQL限流规则
 *
 * @param request ModifySQLRateLimitingRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySQLRateLimitingRulesResponse
 */
async function modifySQLRateLimitingRulesWithOptions(request: ModifySQLRateLimitingRulesRequest, runtime: Util.RuntimeOptions): ModifySQLRateLimitingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleConfig)) {
    query['RuleConfig'] = request.ruleConfig;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySQLRateLimitingRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改SQL限流规则
 *
 * @param request ModifySQLRateLimitingRulesRequest
 * @return ModifySQLRateLimitingRulesResponse
 */
async function modifySQLRateLimitingRules(request: ModifySQLRateLimitingRulesRequest): ModifySQLRateLimitingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySQLRateLimitingRulesWithOptions(request, runtime);
}

model ModifyScheduleTaskRequest {
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime', description='This parameter is required.', example='2023-04-18T19:20:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='This parameter is required.', example='2023-05-15T20:00:00Z'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  taskId?: string(name='TaskId', description='This parameter is required.', example='53879cdb-9a00-428e-acaf-ff4cff******'),
}

model ModifyScheduleTaskResponseBody = {
  requestId?: string(name='RequestId', example='E56531A4-E552-40BA-9C58-137B80******'),
  success?: boolean(name='Success', example='True'),
}

model ModifyScheduleTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyScheduleTaskResponseBody(name='body'),
}

/**
 * @summary 修改目标计划任务
 *
 * @param request ModifyScheduleTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyScheduleTaskResponse
 */
async function modifyScheduleTaskWithOptions(request: ModifyScheduleTaskRequest, runtime: Util.RuntimeOptions): ModifyScheduleTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyScheduleTask',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改目标计划任务
 *
 * @param request ModifyScheduleTaskRequest
 * @return ModifyScheduleTaskResponse
 */
async function modifyScheduleTask(request: ModifyScheduleTaskRequest): ModifyScheduleTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyScheduleTaskWithOptions(request, runtime);
}

model OpenAITaskRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-****************'),
  nodeType?: string(name='NodeType', description='The node type. Valid values:

*   **DLNode**: This node is an AI node.
*   **SearchNode**: This node is a node for which the PolarDB for AI feature is enabled.', example='DLNode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  password?: string(name='Password', description='The password used to access the database for which you want to enable the PolarDB for AI feature.', example='testPassword'),
  regionId?: string(name='RegionId', description='The ID of the region.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  username?: string(name='Username', description='The username used to access the database for which you want to enable the PolarDB for AI feature.', example='testAccountName'),
}

model OpenAITaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
  taskId?: string(name='TaskId', description='The task ID.', example='53879cdb-9a00-428e-acaf-ff4cff******'),
}

model OpenAITaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenAITaskResponseBody(name='body'),
}

/**
 * @summary Enables the PolarDB for AI feature for a cluster.
 *
 * @param request OpenAITaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenAITaskResponse
 */
async function openAITaskWithOptions(request: OpenAITaskRequest, runtime: Util.RuntimeOptions): OpenAITaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['NodeType'] = request.nodeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenAITask',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables the PolarDB for AI feature for a cluster.
 *
 * @param request OpenAITaskRequest
 * @return OpenAITaskResponse
 */
async function openAITask(request: OpenAITaskRequest): OpenAITaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return openAITaskWithOptions(request, runtime);
}

model ReactivateDBClusterBackupRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-**************'),
}

model ReactivateDBClusterBackupResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-****************'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2035629******'),
  requestId?: string(name='RequestId', description='Id of the request', example='F2A9EFA7-915F-4572-8299-85A307******'),
}

model ReactivateDBClusterBackupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReactivateDBClusterBackupResponseBody(name='body'),
}

/**
 * @summary Reactivates the backup feature.
 *
 * @param request ReactivateDBClusterBackupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReactivateDBClusterBackupResponse
 */
async function reactivateDBClusterBackupWithOptions(request: ReactivateDBClusterBackupRequest, runtime: Util.RuntimeOptions): ReactivateDBClusterBackupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReactivateDBClusterBackup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Reactivates the backup feature.
 *
 * @param request ReactivateDBClusterBackupRequest
 * @return ReactivateDBClusterBackupResponse
 */
async function reactivateDBClusterBackup(request: ReactivateDBClusterBackupRequest): ReactivateDBClusterBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return reactivateDBClusterBackupWithOptions(request, runtime);
}

model RefreshDBClusterStorageUsageRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  syncRealTime?: boolean(name='SyncRealTime', description='Specifies whether to enable real-time synchronization. Valid values:

*   **true**
*   **false**: T + 1', example='true'),
}

model RefreshDBClusterStorageUsageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='E56531A4-E552-40BA-9C58-137B80******'),
}

model RefreshDBClusterStorageUsageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RefreshDBClusterStorageUsageResponseBody(name='body'),
}

/**
 * @summary Updates the storage usage of a cluster.
 *
 * @param request RefreshDBClusterStorageUsageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshDBClusterStorageUsageResponse
 */
async function refreshDBClusterStorageUsageWithOptions(request: RefreshDBClusterStorageUsageRequest, runtime: Util.RuntimeOptions): RefreshDBClusterStorageUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.syncRealTime)) {
    query['SyncRealTime'] = request.syncRealTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshDBClusterStorageUsage',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the storage usage of a cluster.
 *
 * @param request RefreshDBClusterStorageUsageRequest
 * @return RefreshDBClusterStorageUsageResponse
 */
async function refreshDBClusterStorageUsage(request: RefreshDBClusterStorageUsageRequest): RefreshDBClusterStorageUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshDBClusterStorageUsageWithOptions(request, runtime);
}

model RemoveDBClusterFromGDNRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster in the GDN.

>  You can call the [DescribeGlobalDatabaseNetwork](https://help.aliyun.com/document_detail/264580.html) operation to view the ID of the cluster in the GDN.

This parameter is required.', example='pc-wz9fb5nn44u1d****'),
  force?: boolean(name='Force'),
  GDNId?: string(name='GDNId', description='The ID of the GDN.

This parameter is required.', example='gdn-bp1fttxsrmv*****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model RemoveDBClusterFromGDNResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='67F2E75F-AE67-4FB2-821F-A81237EACD15'),
}

model RemoveDBClusterFromGDNResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveDBClusterFromGDNResponseBody(name='body'),
}

/**
 * @summary Removes a secondary cluster from a GDN.
 *
 * @description >  You cannot remove the primary cluster from a GDN.
 *
 * @param request RemoveDBClusterFromGDNRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveDBClusterFromGDNResponse
 */
async function removeDBClusterFromGDNWithOptions(request: RemoveDBClusterFromGDNRequest, runtime: Util.RuntimeOptions): RemoveDBClusterFromGDNResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.GDNId)) {
    query['GDNId'] = request.GDNId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveDBClusterFromGDN',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Removes a secondary cluster from a GDN.
 *
 * @description >  You cannot remove the primary cluster from a GDN.
 *
 * @param request RemoveDBClusterFromGDNRequest
 * @return RemoveDBClusterFromGDNResponse
 */
async function removeDBClusterFromGDN(request: RemoveDBClusterFromGDNRequest): RemoveDBClusterFromGDNResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeDBClusterFromGDNWithOptions(request, runtime);
}

model ResetAccountRequest {
  accountName?: string(name='AccountName', description='The username of the account.

> You can reset only the permissions of a privileged account.

This parameter is required.', example='testacc'),
  accountPassword?: string(name='AccountPassword', description='The password of the account. The password must meet the following requirements:

*   It must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.
*   The password must be 8 to 32 characters in length.
*   Special characters include `! @ # $ % ^ & * ( ) _ + - =`', example='Pw123456'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-**************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ResetAccountResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model ResetAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetAccountResponseBody(name='body'),
}

/**
 * @summary Resets the permissions of a privileged account for a PolarDB cluster.
 *
 * @description >- Only PolarDB for MySQL clusters support this operation.
 * >- If the privileged account of your cluster encounters exceptions, you can call this operation to reset the permissions. For example, the permissions are accidentally revoked.
 *
 * @param request ResetAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetAccountResponse
 */
async function resetAccountWithOptions(request: ResetAccountRequest, runtime: Util.RuntimeOptions): ResetAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetAccount',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Resets the permissions of a privileged account for a PolarDB cluster.
 *
 * @description >- Only PolarDB for MySQL clusters support this operation.
 * >- If the privileged account of your cluster encounters exceptions, you can call this operation to reset the permissions. For example, the permissions are accidentally revoked.
 *
 * @param request ResetAccountRequest
 * @return ResetAccountResponse
 */
async function resetAccount(request: ResetAccountRequest): ResetAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetAccountWithOptions(request, runtime);
}

model ResetAccountPasswordRequest {
  accountName?: string(name='AccountName', description='This parameter is required.', example='your_account_name'),
  accountPassword?: string(name='AccountPassword', description='This parameter is required.', example='Test1111'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-***'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ResetAccountPasswordResponseBody = {
  requestId?: string(name='RequestId', example='3AA69096-757C-4647-B36C-29EBC2******'),
}

model ResetAccountPasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetAccountPasswordResponseBody(name='body'),
}

/**
 * @param request ResetAccountPasswordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetAccountPasswordResponse
 */
async function resetAccountPasswordWithOptions(request: ResetAccountPasswordRequest, runtime: Util.RuntimeOptions): ResetAccountPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetAccountPassword',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ResetAccountPasswordRequest
 * @return ResetAccountPasswordResponse
 */
async function resetAccountPassword(request: ResetAccountPasswordRequest): ResetAccountPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetAccountPasswordWithOptions(request, runtime);
}

model ResetAccountZonalRequest {
  accountName?: string(name='AccountName', description='This parameter is required.', example='testacc'),
  accountPassword?: string(name='AccountPassword', example='Test1111'),
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f54a343f1a42***********'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ResetAccountZonalResponseBody = {
  requestId?: string(name='RequestId', example='24A1990B-4F6E-482B-B8CB-75C612******'),
}

model ResetAccountZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetAccountZonalResponseBody(name='body'),
}

/**
 * @summary 重置PolarDB边缘集群账号
 *
 * @param request ResetAccountZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetAccountZonalResponse
 */
async function resetAccountZonalWithOptions(request: ResetAccountZonalRequest, runtime: Util.RuntimeOptions): ResetAccountZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetAccountZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 重置PolarDB边缘集群账号
 *
 * @param request ResetAccountZonalRequest
 * @return ResetAccountZonalResponse
 */
async function resetAccountZonal(request: ResetAccountZonalRequest): ResetAccountZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetAccountZonalWithOptions(request, runtime);
}

model ResetGlobalDatabaseNetworkRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster in the GDN.

>  You can call the [DescribeGlobalDatabaseNetwork](https://help.aliyun.com/document_detail/264580.html) operation to view the ID of the cluster in the GDN.

This parameter is required.', example='pc-wz9fb5nn44u1d****'),
  GDNId?: string(name='GDNId', description='The ID of the GDN.

This parameter is required.', example='gdn-bp1fttxsrmv*****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ResetGlobalDatabaseNetworkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='67F2E75F-AE67-4FB2-821F-A81237EACD15'),
}

model ResetGlobalDatabaseNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetGlobalDatabaseNetworkResponseBody(name='body'),
}

/**
 * @summary Rebuilds a secondary cluster in a Global Database Network (GDN).
 *
 * @param request ResetGlobalDatabaseNetworkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetGlobalDatabaseNetworkResponse
 */
async function resetGlobalDatabaseNetworkWithOptions(request: ResetGlobalDatabaseNetworkRequest, runtime: Util.RuntimeOptions): ResetGlobalDatabaseNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.GDNId)) {
    query['GDNId'] = request.GDNId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetGlobalDatabaseNetwork',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Rebuilds a secondary cluster in a Global Database Network (GDN).
 *
 * @param request ResetGlobalDatabaseNetworkRequest
 * @return ResetGlobalDatabaseNetworkResponse
 */
async function resetGlobalDatabaseNetwork(request: ResetGlobalDatabaseNetworkRequest): ResetGlobalDatabaseNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetGlobalDatabaseNetworkWithOptions(request, runtime);
}

model RestartDBLinkRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the IDs of all clusters in an Alibaba Cloud account.

This parameter is required.', example='pc-****************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model RestartDBLinkResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-****************'),
  requestId?: string(name='RequestId', description='The request ID.', example='E56531A4-E552-40BA-9C58-137B80******'),
  taskId?: string(name='TaskId', description='The task ID.', example='ec8c4723-eac5-4f12-becb-01ac08******'),
}

model RestartDBLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestartDBLinkResponseBody(name='body'),
}

/**
 * @summary Restarts database links.
 *
 * @param request RestartDBLinkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RestartDBLinkResponse
 */
async function restartDBLinkWithOptions(request: RestartDBLinkRequest, runtime: Util.RuntimeOptions): RestartDBLinkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartDBLink',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Restarts database links.
 *
 * @param request RestartDBLinkRequest
 * @return RestartDBLinkResponse
 */
async function restartDBLink(request: RestartDBLinkRequest): RestartDBLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartDBLinkWithOptions(request, runtime);
}

model RestartDBNodeRequest {
  DBNodeId?: string(name='DBNodeId', description='The ID of the node.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/185342.html) operation to query the details of all clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pi-*************'),
  fromTimeService?: string(name='FromTimeService'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime'),
  plannedStartTime?: string(name='PlannedStartTime'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RestartDBNodeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model RestartDBNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestartDBNodeResponseBody(name='body'),
}

/**
 * @summary Restarts a node in a PolarDB cluster.
 *
 * @param request RestartDBNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RestartDBNodeResponse
 */
async function restartDBNodeWithOptions(request: RestartDBNodeRequest, runtime: Util.RuntimeOptions): RestartDBNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBNodeId)) {
    query['DBNodeId'] = request.DBNodeId;
  }
  if (!Util.isUnset(request.fromTimeService)) {
    query['FromTimeService'] = request.fromTimeService;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartDBNode',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Restarts a node in a PolarDB cluster.
 *
 * @param request RestartDBNodeRequest
 * @return RestartDBNodeResponse
 */
async function restartDBNode(request: RestartDBNodeRequest): RestartDBNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartDBNodeWithOptions(request, runtime);
}

model RestartDBNodeZonalRequest {
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  DBNodeId?: string(name='DBNodeId', description='This parameter is required.', example='pi-*************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RestartDBNodeZonalResponseBody = {
  requestId?: string(name='RequestId', example='925B84D9-CA72-432C-95CF-738C22******'),
}

model RestartDBNodeZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestartDBNodeZonalResponseBody(name='body'),
}

/**
 * @summary 重启poalrdb边缘云集群节点
 *
 * @param request RestartDBNodeZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RestartDBNodeZonalResponse
 */
async function restartDBNodeZonalWithOptions(request: RestartDBNodeZonalRequest, runtime: Util.RuntimeOptions): RestartDBNodeZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeId)) {
    query['DBNodeId'] = request.DBNodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartDBNodeZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 重启poalrdb边缘云集群节点
 *
 * @param request RestartDBNodeZonalRequest
 * @return RestartDBNodeZonalResponse
 */
async function restartDBNodeZonal(request: RestartDBNodeZonalRequest): RestartDBNodeZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartDBNodeZonalWithOptions(request, runtime);
}

model RestoreTableRequest {
  backupId?: string(name='BackupId', description='The ID of the backup set.

>  You must specify this parameter if you need to restore a database or a table by using a backup set. You can call the [DescribeBackups](https://help.aliyun.com/document_detail/98102.html) operation to query the ID of the backup set.', example='111111'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of all clusters within your account.

This parameter is required.', example='pc-bp***************'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime', description='The point in time for the restoration. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mmZ format. The time must be in UTC.

> 

*   You must specify this parameter if you need to restore the database or the table to a point in time.

*   You can restore your cluster to a particular time only over the past seven days.', example='2020-10-04T01:40:00Z'),
  securityToken?: string(name='SecurityToken'),
  tableMeta?: string(name='TableMeta', description='The JSON string that contains the information of the database and the table that you want to restore. All values of the database and table information are of the string type. Example: `[ { "tables":[ { "name":"testtb", "type":"table", "newname":"testtb_restore" } ], "name":"testdb", "type":"db", "newname":"testdb_restore" } ]`.

>  You can call the [DescribeMetaList](https://help.aliyun.com/document_detail/194770.html) operation to query the names and details of databases and tables that can be restored and enter their information into the corresponding locations in the preceding example.

This parameter is required.', example='[ { "tables":[ { "name":"testtb", "type":"table", "newname":"testtb_restore" } ], "name":"testdb", "type":"db", "newname":"testdb_restore" } ]'),
}

model RestoreTableResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0C47508C-9DC8-455B-985E-2F2FA8******'),
}

model RestoreTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestoreTableResponseBody(name='body'),
}

/**
 * @summary Restores PolarDB databases and tables.
 *
 * @param request RestoreTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RestoreTableResponse
 */
async function restoreTableWithOptions(request: RestoreTableRequest, runtime: Util.RuntimeOptions): RestoreTableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.tableMeta)) {
    query['TableMeta'] = request.tableMeta;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestoreTable',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Restores PolarDB databases and tables.
 *
 * @param request RestoreTableRequest
 * @return RestoreTableResponse
 */
async function restoreTable(request: RestoreTableRequest): RestoreTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return restoreTableWithOptions(request, runtime);
}

model RevokeAccountPrivilegeRequest {
  accountName?: string(name='AccountName', description='The name of the account.

>  You can specify only a standard account.

This parameter is required.', example='testacc'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the PolarDB cluster.

This parameter is required.', example='pc-****************'),
  DBName?: string(name='DBName', description='The names of the databases. If you need to specify multiple database names, separate the names with commas (,).

This parameter is required.', example='testdb'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RevokeAccountPrivilegeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model RevokeAccountPrivilegeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokeAccountPrivilegeResponseBody(name='body'),
}

/**
 * @summary Revokes the access permissions on one or more databases from a specified PolarDB standard account.
 *
 * @param request RevokeAccountPrivilegeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokeAccountPrivilegeResponse
 */
async function revokeAccountPrivilegeWithOptions(request: RevokeAccountPrivilegeRequest, runtime: Util.RuntimeOptions): RevokeAccountPrivilegeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RevokeAccountPrivilege',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Revokes the access permissions on one or more databases from a specified PolarDB standard account.
 *
 * @param request RevokeAccountPrivilegeRequest
 * @return RevokeAccountPrivilegeResponse
 */
async function revokeAccountPrivilege(request: RevokeAccountPrivilegeRequest): RevokeAccountPrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeAccountPrivilegeWithOptions(request, runtime);
}

model RevokeAccountPrivilegeZonalRequest {
  accountName?: string(name='AccountName', description='This parameter is required.', example='testacc'),
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f5********************'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  DBName?: string(name='DBName', description='This parameter is required.', example='testdb'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RevokeAccountPrivilegeZonalResponseBody = {
  requestId?: string(name='RequestId', example='F9F1CB1A-B1D5-4EF5-A53A-************'),
}

model RevokeAccountPrivilegeZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokeAccountPrivilegeZonalResponseBody(name='body'),
}

/**
 * @summary 撤销账号权限
 *
 * @param request RevokeAccountPrivilegeZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokeAccountPrivilegeZonalResponse
 */
async function revokeAccountPrivilegeZonalWithOptions(request: RevokeAccountPrivilegeZonalRequest, runtime: Util.RuntimeOptions): RevokeAccountPrivilegeZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RevokeAccountPrivilegeZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 撤销账号权限
 *
 * @param request RevokeAccountPrivilegeZonalRequest
 * @return RevokeAccountPrivilegeZonalResponse
 */
async function revokeAccountPrivilegeZonal(request: RevokeAccountPrivilegeZonalRequest): RevokeAccountPrivilegeZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeAccountPrivilegeZonalWithOptions(request, runtime);
}

model SwitchOverGlobalDatabaseNetworkRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster that will become the primary cluster in the GDN.

You can call the [DescribeGlobalDatabaseNetwork](https://help.aliyun.com/document_detail/264580.html) operation to query the ID of the cluster in the GDN.', example='pc-wz9fb5nn44u1d****'),
  forced?: boolean(name='Forced', description='Specifies whether to forcibly switch over the primary and secondary clusters in the GDN. Valid values:

*   **true**
*   **false**', example='false'),
  GDNId?: string(name='GDNId', description='The ID of the GDN.

This parameter is required.', example='gdn-bp1fttxsrmv*****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-qingdao'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model SwitchOverGlobalDatabaseNetworkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='67F2E75F-AE67-4FB2-821F-A81237EACD15'),
}

model SwitchOverGlobalDatabaseNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SwitchOverGlobalDatabaseNetworkResponseBody(name='body'),
}

/**
 * @param request SwitchOverGlobalDatabaseNetworkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SwitchOverGlobalDatabaseNetworkResponse
 */
async function switchOverGlobalDatabaseNetworkWithOptions(request: SwitchOverGlobalDatabaseNetworkRequest, runtime: Util.RuntimeOptions): SwitchOverGlobalDatabaseNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.forced)) {
    query['Forced'] = request.forced;
  }
  if (!Util.isUnset(request.GDNId)) {
    query['GDNId'] = request.GDNId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SwitchOverGlobalDatabaseNetwork',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SwitchOverGlobalDatabaseNetworkRequest
 * @return SwitchOverGlobalDatabaseNetworkResponse
 */
async function switchOverGlobalDatabaseNetwork(request: SwitchOverGlobalDatabaseNetworkRequest): SwitchOverGlobalDatabaseNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchOverGlobalDatabaseNetworkWithOptions(request, runtime);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

This parameter is required.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The cluster ID.

This parameter is required.', example='pc-*****************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Set the value to **cluster**.

This parameter is required.', example='cluster'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag that you want to create for the cluster. To create multiple tags for a cluster at a time, click **Add** to add tag keys.

>  You can create up to 20 tags for a cluster at a time. The value of `Tag.N.Key` is paired with the value of `Tag.N.Value`.', example='type'),
      value?: string(name='Value', description='The value of the tag that you want to create for the cluster. To create multiple tags for a cluster at a time, click **Add** to add tag values.

>  You can create up to 20 tags for a cluster at a time. The value of `Tag.N.Key` is paired with the value of `Tag.N.Value`.', example='test'),
    }
  ](name='Tag', description='The tags.

This parameter is required.'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='1CB5286F-AF5A-4E09-BFE9-588D4C******'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
 * @summary Creates tags for a PolarDB cluster.
 *
 * @param request TagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates tags for a PolarDB cluster.
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model TempModifyDBNodeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value. Make sure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='6000170000591aed949d0f5********************'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-xxxxxxxxxx'),
  DBNode?: [ 
    {
      targetClass?: string(name='TargetClass', description='The specifications of the scaled/added node.

> 

*   The specification of the new node must be consistent with the specifications of the original nodes.

*   You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to view the specifications of the original nodes.', example='polar.mysql.x4.medium'),
      zoneId?: string(name='ZoneId', description='The ID of the zone in which the added node is deployed. It must be the same zone as the original nodes.', example='cn-hangzhou-i'),
    }
  ](name='DBNode', description='The information about the scaled/added node.

This parameter is required.'),
  modifyType?: string(name='ModifyType', description='The type of configuration change. Set the value to **TempUpgrade**.

This parameter is required.', example='TempUpgrade'),
  operationType?: string(name='OperationType', description='The operation type. Valid values:

*   **Modify**: temporarily upgrades the configuration of the cluster.

This parameter is required.', example='Modify'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime', description='The rollback time of the configuration for the temporary upgrade. Specify the time in the ISO 8601 standard in the YYYY-MM-DD hh:mm:ss format.

>  The rollback time cannot be 1 hour earlier than the current time and cannot be later than one day before the time when the cluster expires.

This parameter is required.', example='2021-09-23 18:16:00'),
}

model TempModifyDBNodeResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-xxxxxxxxxxxxxxxxx'),
  DBNodeIds?: [ string ](name='DBNodeIds', description='The details of the nodes.'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2035638*******'),
  requestId?: string(name='RequestId', description='The request ID.', example='69A85BAF-1089-4CDF-A82F-0A140F******'),
}

model TempModifyDBNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TempModifyDBNodeResponseBody(name='body'),
}

/**
 * @summary Temporarily changes the node configurations.
 *
 * @param request TempModifyDBNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TempModifyDBNodeResponse
 */
async function tempModifyDBNodeWithOptions(request: TempModifyDBNodeRequest, runtime: Util.RuntimeOptions): TempModifyDBNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNode)) {
    query['DBNode'] = request.DBNode;
  }
  if (!Util.isUnset(request.modifyType)) {
    query['ModifyType'] = request.modifyType;
  }
  if (!Util.isUnset(request.operationType)) {
    query['OperationType'] = request.operationType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TempModifyDBNode',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Temporarily changes the node configurations.
 *
 * @param request TempModifyDBNodeRequest
 * @return TempModifyDBNodeResponse
 */
async function tempModifyDBNode(request: TempModifyDBNodeRequest): TempModifyDBNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return tempModifyDBNodeWithOptions(request, runtime);
}

model TransformDBClusterPayTypeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value. Make sure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='6000170000591aed949d0f5********************'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-bp10gr51qasnl****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go.
*   **Prepaid**: subscription.

This parameter is required.', example='Prepaid'),
  period?: string(name='Period', description='The renewal cycle of the cluster. Valid values:

*   **Year**
*   **Month**

>  This parameter is required if you set the **PayType** parameter to **Prepaid**.', example='Month'),
  regionId?: string(name='RegionId', description='The ID of the region.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfm3f4un32****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  usedTime?: string(name='UsedTime', description='The subscription duration of the cluster. Valid values:

*   If the **Period** parameter is set to **Year**, the **UsedTime** parameter can be set to 1, 2, or 3.
*   If the **Period** parameter is set to **Month**, the **UsedTime** parameter can be set to 1, 2, 3, 4, 5, 6, 7, 8, or 9.

>  This parameter is required if you set the **PayType** parameter to **Prepaid**.', example='1'),
}

model TransformDBClusterPayTypeResponseBody = {
  chargeType?: string(name='ChargeType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go.
*   **Prepaid**: subscription.', example='Prepaid'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-bp10gr51qasnl****'),
  expiredTime?: string(name='ExpiredTime', description='The time when the cluster expires.

>  This parameter is returned if you set the **PayType** parameter to **Prepaid**.', example='2020-04-20T10:00:00Z'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='20515760028****'),
  requestId?: string(name='RequestId', description='The request ID.', example='5E71541A-6007-4DCC-A38A-F872C31FEB45'),
}

model TransformDBClusterPayTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TransformDBClusterPayTypeResponseBody(name='body'),
}

/**
 * @summary Changes the billing method of a PolarDB cluster.
 *
 * @description > 
 * *   PolarDB clusters support the subscription and pay-as-you-go billing methods. You can change the billing method from subscription to pay-as-you-go or from pay-as-you-go to subscription based on your business requirements. For more information, see [Change the billing method from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/172886.html) and [Change the billing method from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/84076.html).
 * *   You cannot change the billing method from pay-as-you-go to subscription if your account balance is insufficient.
 * *   If you change the billing method from subscription to pay-as-you-go, the system automatically refunds the balance of the prepaid subscription fees.
 *
 * @param request TransformDBClusterPayTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TransformDBClusterPayTypeResponse
 */
async function transformDBClusterPayTypeWithOptions(request: TransformDBClusterPayTypeRequest, runtime: Util.RuntimeOptions): TransformDBClusterPayTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TransformDBClusterPayType',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the billing method of a PolarDB cluster.
 *
 * @description > 
 * *   PolarDB clusters support the subscription and pay-as-you-go billing methods. You can change the billing method from subscription to pay-as-you-go or from pay-as-you-go to subscription based on your business requirements. For more information, see [Change the billing method from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/172886.html) and [Change the billing method from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/84076.html).
 * *   You cannot change the billing method from pay-as-you-go to subscription if your account balance is insufficient.
 * *   If you change the billing method from subscription to pay-as-you-go, the system automatically refunds the balance of the prepaid subscription fees.
 *
 * @param request TransformDBClusterPayTypeRequest
 * @return TransformDBClusterPayTypeResponse
 */
async function transformDBClusterPayType(request: TransformDBClusterPayTypeRequest): TransformDBClusterPayTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return transformDBClusterPayTypeWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to detach all tags from the cluster. Valid values: **true** and **false**. Default value: **false**.

>  This parameter takes effect only if `TagKey.n` is empty.', example='true'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region.

>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the available regions.

This parameter is required.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The IDs of the clusters.

This parameter is required.', example='pc-***************'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Set the value to **cluster**.

This parameter is required.', example='cluster'),
  tagKey?: [ string ](name='TagKey', description='The keys of the tags.', example='type'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF5189******'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
 * @summary Unbinds tags from PolarDB clusters.
 *
 * @param request UntagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesResponse
 */
async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Unbinds tags from PolarDB clusters.
 *
 * @param request UntagResourcesRequest
 * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateExtensionsRequest {
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f5********************'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-**************'),
  DBNames?: string(name='DBNames', description='This parameter is required.', example='auto_test_db'),
  extensions?: string(name='Extensions', description='This parameter is required.', example='postgres_fdw'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-**********'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  version?: string(name='Version', example='7.7'),
  vpcId?: string(name='VpcId', example='vpc-bp1qpo0kug3a20qqe****'),
}

model UpdateExtensionsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='A83B6055-F891-5596-96E3-52D62567DFBB'),
}

model UpdateExtensionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateExtensionsResponseBody(name='body'),
}

/**
 * @summary 更新插件
 *
 * @param request UpdateExtensionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateExtensionsResponse
 */
async function updateExtensionsWithOptions(request: UpdateExtensionsRequest, runtime: Util.RuntimeOptions): UpdateExtensionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNames)) {
    query['DBNames'] = request.DBNames;
  }
  if (!Util.isUnset(request.extensions)) {
    query['Extensions'] = request.extensions;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateExtensions',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新插件
 *
 * @param request UpdateExtensionsRequest
 * @return UpdateExtensionsResponse
 */
async function updateExtensions(request: UpdateExtensionsRequest): UpdateExtensionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateExtensionsWithOptions(request, runtime);
}

model UpgradeDBClusterVersionRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-****************'),
  fromTimeService?: boolean(name='FromTimeService', description='Specifies whether to immediately run the kernel upgrade task. Valid values:

*   **false** (default)
*   **true**

>  This parameter is not required when you call the operation.', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to run the task that updates the kernel version of the cluster. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> *   The value of this parameter must be at least 30 minutes later than the value of PlannedStartTime.
>*   If you specify `PlannedStartTime` but do not specify PlannedEndTime, the latest start time of the task is `PlannedEndTime + 30 minutes`. For example, if you set `PlannedStartTime` to `2021-01-14T09:00:00Z` and do not specify PlannedEndTime, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time to run the task that updates the kernel version of the cluster. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The earliest start time of the task can be a point in time within the next 72 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in time from `2021-01-14T09:00:00Z` to `2021-01-17T09:00:00Z`.

*   If you do not specify this parameter, the kernel update task runs immediately after you submit the request.', example='2021-01-14T09:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  targetDBRevisionVersionCode?: string(name='TargetDBRevisionVersionCode', description='The code of the db version to which you want to upgrade the cluster. You can call the [DescribeDBClusterVersion](https://help.aliyun.com/document_detail/2319145.html) operation to query the version code.', example='20230707'),
  targetProxyRevisionVersionCode?: string(name='TargetProxyRevisionVersionCode', description='The code of the proxy version to which you want to upgrade the cluster. You can call the [DescribeDBClusterVersion](https://help.aliyun.com/document_detail/2319145.html) operation to query the version code.', example='20240702'),
  upgradeLabel?: string(name='UpgradeLabel', description='The upgrade tag. The value is fixed as **INNOVATE**.

> *   This parameter is applicable only when you upgrade PolarDB for MySQL 8.0.1 to PolarDB for MySQL 8.0.2.
>*   If you specify this parameter, you must set `UpgradePolicy` to **COLD**.', example='INNOVATE'),
  upgradePolicy?: string(name='UpgradePolicy', description='The engine version upgrade policy. Valid values:

*   **HOT**: hot upgrade.
*   **COLD**: cold upgrade. Only PolarDB for MySQL 8.0 Cluster Edition supports this upgrade method.', example='HOT'),
  upgradeType?: string(name='UpgradeType', description='The update type. Valid values:

*   **PROXY**: specifies to upgrade PloarProxy.
*   **DB**: specifies to upgrade the kernel version.
*   **ALL**: specifies to upgrade both PloarProxy and kernel version.', example='PROXY'),
}

model UpgradeDBClusterVersionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CAE6755F-B79A-4861-B227-801FE8******'),
}

model UpgradeDBClusterVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeDBClusterVersionResponseBody(name='body'),
}

/**
 * @summary Upgrades the kernel version of a PolarDB for MySQL cluster.
 *
 * @description > *  You can update only the revision version of a PolarDB for MySQL cluster, for example, from 8.0.1.1.3 to 8.0.1.1.4.
 * >*   You can use only your Alibaba Cloud account to create scheduled tasks that update the kernel version of a PolarDB for MySQL cluster. RAM users are not authorized to update the kernel version of a PolarDB for MySQL cluster.
 *
 * @param request UpgradeDBClusterVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeDBClusterVersionResponse
 */
async function upgradeDBClusterVersionWithOptions(request: UpgradeDBClusterVersionRequest, runtime: Util.RuntimeOptions): UpgradeDBClusterVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.fromTimeService)) {
    query['FromTimeService'] = request.fromTimeService;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.targetDBRevisionVersionCode)) {
    query['TargetDBRevisionVersionCode'] = request.targetDBRevisionVersionCode;
  }
  if (!Util.isUnset(request.targetProxyRevisionVersionCode)) {
    query['TargetProxyRevisionVersionCode'] = request.targetProxyRevisionVersionCode;
  }
  if (!Util.isUnset(request.upgradeLabel)) {
    query['UpgradeLabel'] = request.upgradeLabel;
  }
  if (!Util.isUnset(request.upgradePolicy)) {
    query['UpgradePolicy'] = request.upgradePolicy;
  }
  if (!Util.isUnset(request.upgradeType)) {
    query['UpgradeType'] = request.upgradeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeDBClusterVersion',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Upgrades the kernel version of a PolarDB for MySQL cluster.
 *
 * @description > *  You can update only the revision version of a PolarDB for MySQL cluster, for example, from 8.0.1.1.3 to 8.0.1.1.4.
 * >*   You can use only your Alibaba Cloud account to create scheduled tasks that update the kernel version of a PolarDB for MySQL cluster. RAM users are not authorized to update the kernel version of a PolarDB for MySQL cluster.
 *
 * @param request UpgradeDBClusterVersionRequest
 * @return UpgradeDBClusterVersionResponse
 */
async function upgradeDBClusterVersion(request: UpgradeDBClusterVersionRequest): UpgradeDBClusterVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeDBClusterVersionWithOptions(request, runtime);
}

model UpgradeDBClusterVersionZonalRequest {
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******'),
  DBClusterId?: string(name='DBClusterId', description='This parameter is required.', example='pc-a************'),
  fromTimeService?: boolean(name='FromTimeService', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plannedEndTime?: string(name='PlannedEndTime', example='2021-01-14T09:30:00Z'),
  plannedStartTime?: string(name='PlannedStartTime', example='2022-04-28T14:00:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  targetDBRevisionVersionCode?: string(name='TargetDBRevisionVersionCode', example='20230707'),
  targetProxyRevisionVersionCode?: string(name='TargetProxyRevisionVersionCode', example='20240702'),
  upgradeLabel?: string(name='UpgradeLabel', example='INNOVATE'),
  upgradePolicy?: string(name='UpgradePolicy', example='HOT'),
  upgradeType?: string(name='UpgradeType', example='PROXY'),
}

model UpgradeDBClusterVersionZonalResponseBody = {
  requestId?: string(name='RequestId', example='CAE6755F-B79A-4861-B227-801FE8******'),
}

model UpgradeDBClusterVersionZonalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeDBClusterVersionZonalResponseBody(name='body'),
}

/**
 * @summary PolarDB边缘云集群小版本升级
 *
 * @param request UpgradeDBClusterVersionZonalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeDBClusterVersionZonalResponse
 */
async function upgradeDBClusterVersionZonalWithOptions(request: UpgradeDBClusterVersionZonalRequest, runtime: Util.RuntimeOptions): UpgradeDBClusterVersionZonalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.fromTimeService)) {
    query['FromTimeService'] = request.fromTimeService;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plannedEndTime)) {
    query['PlannedEndTime'] = request.plannedEndTime;
  }
  if (!Util.isUnset(request.plannedStartTime)) {
    query['PlannedStartTime'] = request.plannedStartTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.targetDBRevisionVersionCode)) {
    query['TargetDBRevisionVersionCode'] = request.targetDBRevisionVersionCode;
  }
  if (!Util.isUnset(request.targetProxyRevisionVersionCode)) {
    query['TargetProxyRevisionVersionCode'] = request.targetProxyRevisionVersionCode;
  }
  if (!Util.isUnset(request.upgradeLabel)) {
    query['UpgradeLabel'] = request.upgradeLabel;
  }
  if (!Util.isUnset(request.upgradePolicy)) {
    query['UpgradePolicy'] = request.upgradePolicy;
  }
  if (!Util.isUnset(request.upgradeType)) {
    query['UpgradeType'] = request.upgradeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeDBClusterVersionZonal',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary PolarDB边缘云集群小版本升级
 *
 * @param request UpgradeDBClusterVersionZonalRequest
 * @return UpgradeDBClusterVersionZonalResponse
 */
async function upgradeDBClusterVersionZonal(request: UpgradeDBClusterVersionZonalRequest): UpgradeDBClusterVersionZonalResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeDBClusterVersionZonalWithOptions(request, runtime);
}

