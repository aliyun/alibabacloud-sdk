/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'polardb';
  @version = '2017-08-01';
  @endpointRule = 'regional';
  @endpointMap = {
    'cn-qingdao' = 'polardb.aliyuncs.com',
    'cn-beijing' = 'polardb.aliyuncs.com',
    'cn-wulanchabu' = 'polardb.aliyuncs.com',
    'cn-hangzhou' = 'polardb.aliyuncs.com',
    'cn-shanghai' = 'polardb.aliyuncs.com',
    'cn-shenzhen' = 'polardb.aliyuncs.com',
    'cn-guangzhou' = 'polardb.aliyuncs.com',
    'cn-hongkong' = 'polardb.aliyuncs.com',
    'cn-hangzhou-finance' = 'polardb.aliyuncs.com',
    'cn-shanghai-finance-1' = 'polardb.aliyuncs.com',
    'cn-shenzhen-finance-1' = 'polardb.aliyuncs.com',
    'cn-north-2-gov-1' = 'polardb.aliyuncs.com',
    'ap-northeast-2-pop' = 'polardb.aliyuncs.com',
    'cn-beijing-finance-1' = 'polardb.aliyuncs.com',
    'cn-beijing-finance-pop' = 'polardb.aliyuncs.com',
    'cn-beijing-gov-1' = 'polardb.aliyuncs.com',
    'cn-beijing-nu16-b01' = 'polardb.aliyuncs.com',
    'cn-edge-1' = 'polardb.aliyuncs.com',
    'cn-fujian' = 'polardb.aliyuncs.com',
    'cn-haidian-cm12-c01' = 'polardb.aliyuncs.com',
    'cn-hangzhou-bj-b01' = 'polardb.aliyuncs.com',
    'cn-hangzhou-internal-prod-1' = 'polardb.aliyuncs.com',
    'cn-hangzhou-internal-test-1' = 'polardb.aliyuncs.com',
    'cn-hangzhou-internal-test-2' = 'polardb.aliyuncs.com',
    'cn-hangzhou-internal-test-3' = 'polardb.aliyuncs.com',
    'cn-hangzhou-test-306' = 'polardb.aliyuncs.com',
    'cn-hongkong-finance-pop' = 'polardb.aliyuncs.com',
    'cn-huhehaote-nebula-1' = 'polardb.aliyuncs.com',
    'cn-qingdao-nebula' = 'polardb.aliyuncs.com',
    'cn-shanghai-et15-b01' = 'polardb.aliyuncs.com',
    'cn-shanghai-et2-b01' = 'polardb.aliyuncs.com',
    'cn-shanghai-inner' = 'polardb.aliyuncs.com',
    'cn-shanghai-internal-test-1' = 'polardb.aliyuncs.com',
    'cn-shenzhen-inner' = 'polardb.aliyuncs.com',
    'cn-shenzhen-st4-d01' = 'polardb.aliyuncs.com',
    'cn-shenzhen-su18-b01' = 'polardb.aliyuncs.com',
    'cn-wuhan' = 'polardb.aliyuncs.com',
    'cn-yushanfang' = 'polardb.aliyuncs.com',
    'cn-zhangbei' = 'polardb.aliyuncs.com',
    'cn-zhangbei-na61-b01' = 'polardb.aliyuncs.com',
    'cn-zhangjiakou-na62-a01' = 'polardb.aliyuncs.com',
    'cn-zhengzhou-nebula-1' = 'polardb.aliyuncs.com',
    'eu-west-1-oxs' = 'polardb.aliyuncs.com',
    'rus-west-1-pop' = 'polardb.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model CancelActiveOperationTasksRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID.

> 

*   You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the region information about all clusters within a specified account.

*   If you do not specify this parameter, scheduled tasks on your clusters that are deployed in all regions are queried.

This parameter is required.', example='cn-beijing', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  taskIds: string(name='TaskIds', description='The IDs of O\\&M events that are canceled at a time. Separate multiple IDs with commas (,).

This parameter is required.', example='2355,2352', position='Query'),
}

model CancelActiveOperationTasksResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='25C70FF3-D49B-594D-BECE-0DE2BA1D8BBB'),
  taskIds?: string(name='TaskIds', description='The IDs of O\\&M events that are canceled at a time. Separate multiple IDs with commas (,).', example='2355,2352'),
}

model CancelActiveOperationTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelActiveOperationTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CancelActiveOperationTasks  CancelActiveOperationTasksRequest
  * @return CancelActiveOperationTasksResponse
 */
async function cancelActiveOperationTasks(request: CancelActiveOperationTasksRequest): CancelActiveOperationTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelActiveOperationTasks', 'POST', '/', 'json', false, 'json', request);
}

model CancelScheduleTasksRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the information of all clusters that are deployed in a specified region, such as the cluster IDs.

This parameter is required.', example='pc-**************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  taskId: string(name='TaskId', description='The ID of the scheduled task that you want to cancel.

> *   You can call the [DescribeScheduleTasks](https://help.aliyun.com/document_detail/199648.html) operation to query the details of all scheduled tasks that belong to the current account, such as the task IDs.
>*   You can cancel only the tasks whose status is `pending`.``

This parameter is required.', example='ec8c4723-eac5-4f12-becb-01ac08******', position='Query'),
}

model CancelScheduleTasksResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7F2007D3-7E74-4ECB-89A8-BF130D******'),
  success?: boolean(name='Success', description='Indicates whether the request is successful.', example='true'),
}

model CancelScheduleTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelScheduleTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CancelScheduleTasks  CancelScheduleTasksRequest
  * @return CancelScheduleTasksResponse
 */
async function cancelScheduleTasks(request: CancelScheduleTasksRequest): CancelScheduleTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelScheduleTasks', 'POST', '/', 'json', false, 'json', request);
}

model CheckAccountNameRequest {
  accountName: string(name='AccountName', description='The name of the account.

This parameter is required.', example='test_acc', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.

This parameter is required.', example='pc-****************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CheckAccountNameResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='925B84D9-CA72-432C-95CF-738C22******'),
}

model CheckAccountNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckAccountNameResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CheckAccountName  CheckAccountNameRequest
  * @return CheckAccountNameResponse
 */
async function checkAccountName(request: CheckAccountNameRequest): CheckAccountNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckAccountName', 'POST', '/', 'json', false, 'json', request);
}

model CheckDBNameRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query information about all clusters that are deployed in a region, such as the cluster IDs.

This parameter is required.', example='pc-****************', position='Query'),
  DBName: string(name='DBName', description='The name of the database.

This parameter is required.', example='test_db', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CheckDBNameResponseBody = {
  DBName?: string(name='DBName', description='The name of the database.', example='test_db'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CDB3258F-B5DE-43C4-8935-CBA0CA******'),
}

model CheckDBNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckDBNameResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CheckDBName  CheckDBNameRequest
  * @return CheckDBNameResponse
 */
async function checkDBName(request: CheckDBNameRequest): CheckDBNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckDBName', 'POST', '/', 'json', false, 'json', request);
}

model CheckKMSAuthorizedRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the information of all clusters that are deployed in a specific region, such as the cluster IDs.

This parameter is required.', example='pc-************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region.

>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query all regions that are available for your account, such as the region IDs.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  TDERegion?: string(name='TDERegion', description='The region in which the TDE key resides.', example='cn-beijing', position='Query'),
}

model CheckKMSAuthorizedResponseBody = {
  authorizationState?: int32(name='AuthorizationState', description='Indicates whether the cluster is authorized to use KMS. Valid values:

*   **0**: no.
*   **1**: yes.', example='0'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-************'),
  requestId?: string(name='RequestId', description='The request ID.', example='A7E6A8FD-C50B-46B2-BA85-D8B8D3******'),
  roleArn?: string(name='RoleArn', description='The Alibaba Cloud Resource Name (ARN) of the RAM role. A RAM role is a virtual identity that you can create within your Alibaba Cloud account. For more information, see [RAM role overview](https://help.aliyun.com/document_detail/93689.html).', example='acs:ram::1406926*****:role/aliyunrdsinstanceencryptiondefaultrole'),
}

model CheckKMSAuthorizedResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckKMSAuthorizedResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CheckKMSAuthorized  CheckKMSAuthorizedRequest
  * @return CheckKMSAuthorizedResponse
 */
async function checkKMSAuthorized(request: CheckKMSAuthorizedRequest): CheckKMSAuthorizedResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckKMSAuthorized', 'POST', '/', 'json', false, 'json', request);
}

model CheckServiceLinkedRoleRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CheckServiceLinkedRoleResponseBody = {
  hasServiceLinkedRole?: boolean(name='HasServiceLinkedRole', description='Indicates whether the SLR is created.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3F9E6A3B-C13E-4064-A010-18582A******'),
}

model CheckServiceLinkedRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckServiceLinkedRoleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CheckServiceLinkedRole  CheckServiceLinkedRoleRequest
  * @return CheckServiceLinkedRoleResponse
 */
async function checkServiceLinkedRole(request: CheckServiceLinkedRoleRequest): CheckServiceLinkedRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckServiceLinkedRole', 'POST', '/', 'json', false, 'json', request);
}

model CloseAITaskRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-**************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the cluster.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CloseAITaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='936C7025-27A5-4CB1-BB31-540E1F0CCA12'),
  taskId?: string(name='TaskId', description='The ID of the task for disabling the PolarDB for AI feature.', example='53879cdb-9a00-428e-acaf-ff4cff******'),
}

model CloseAITaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloseAITaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CloseAITask  CloseAITaskRequest
  * @return CloseAITaskResponse
 */
async function closeAITask(request: CloseAITaskRequest): CloseAITaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CloseAITask', 'POST', '/', 'json', false, 'json', request);
}

model CloseDBClusterMigrationRequest {
  regionId?: string(name='RegionId', position='Host'),
  continueEnableBinlog?: boolean(name='ContinueEnableBinlog', description='Specifies whether to continue to enable binary logging. Valid values:

*   **true**: continues to enable binary logging.
*   **false**: disables binary logging.

Default value: **true**.

> If binary logging is disabled, your PolarDB cluster is restarted.', example='true', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-**************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CloseDBClusterMigrationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='3AA69096-757C-4647-B36C-29EBC2******'),
}

model CloseDBClusterMigrationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloseDBClusterMigrationResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to cancel the migration task before data migration.
  * *   You can call this operation to perform the migration task after data migration.
  * > Before you call this operation, ensure that a one-click upgrade task has been created for the cluster. You can call the [CreateDBCluster](https://help.aliyun.com/document_detail/98169.html) operation to create an upgrade task. Set the **CreationOption** parameter to **MigrationFromRDS**. For more information, see [Create a PolarDB for MySQL cluster by using the Migration from RDS method](https://help.aliyun.com/document_detail/121582.html).
  * @param request  the request parameters of CloseDBClusterMigration  CloseDBClusterMigrationRequest
  * @return CloseDBClusterMigrationResponse
 */
async function closeDBClusterMigration(request: CloseDBClusterMigrationRequest): CloseDBClusterMigrationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CloseDBClusterMigration', 'POST', '/', 'json', false, 'json', request);
}

model CreateAccountRequest {
  accountDescription?: string(name='AccountDescription', description='The description of the account. The description must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must be 2 to 256 characters in length.', example='testdes', position='Query'),
  accountName: string(name='AccountName', description='The name of the account. The name must meet the following requirements:

*   It must start with a lowercase letter and end with a letter or a digit.
*   It can contain lowercase letters, digits, and underscores (_).
*   It must be 2 to 16 characters in length.
*   It cannot be root, admin, or another username that is reserved by the system.

This parameter is required.', example='testacc', position='Query'),
  accountPassword: string(name='AccountPassword', description='The password of the account. The password must meet the following requirements:

*   The password must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.
*   The password must be 8 to 32 characters in length.
*   Special characters include `! @ # $ % ^ & * ( ) _ + - =`

This parameter is required.', example='Test1111', position='Query'),
  accountPrivilege?: string(name='AccountPrivilege', description='The permissions that are granted to the account. Valid values:

*   **ReadWrite**: read and write permissions.
*   **ReadOnly**: read-only permissions.
*   **DMLOnly**: the permissions to execute only DML statements.
*   **DDLOnly**: the permissions to execute only DDL statements.
*   **ReadIndex**: the read-only and index permissions.

> 

*   `AccountPrivilege` is valid only after you specify `DBName`.

*   If multiple database names are specified by the `DBName` parameter, you must grant permissions on the databases. Separate multiple permissions with commas (,), and make sure that the length of the value of `AccountPrivilege` does not exceed 900. For example, if you want to grant the account the read and write permissions on DB1 and the read-only permissions on DB2, set `DBName` to `DB1,DB2` and set `AccountPrivilege` to `ReadWrite,ReadOnly`.

*   This parameter is valid only for standard accounts of PolarDB for MySQL clusters.', example='ReadWrite', maxLength=900, position='Query'),
  accountType?: string(name='AccountType', description='The type of the account. Valid values:

*   **Normal**: standard account
*   **Super**: privileged account.

> 

*   If you leave this parameter empty, the default value **Super** is used.

*   You can create multiple privileged accounts for a PolarDB for PostgreSQL (Compatible with Oracle) cluster or a PolarDB for PostgreSQL cluster. A privileged account has more permissions than a standard account. For more information, see [Create a database account](https://help.aliyun.com/document_detail/68508.html).

*   You can create only one privileged account for a PolarDB for MySQL cluster. A privileged account has more permissions than a standard account. For more information, see [Create a database account](https://help.aliyun.com/document_detail/68508.html).', example='Normal', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-**************', position='Query'),
  DBName?: string(name='DBName', description='The name of the database that can be accessed by the account. To enter multiple database names, separate the names with commas (,).

>  This parameter is valid only for standard accounts of PolarDB for MySQL clusters.', example='testdb', maxLength=6400, position='Query'),
  nodeType?: string(name='NodeType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  privForAllDB?: string(name='PrivForAllDB', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateAccountResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CED079B7-A408-41A1-BFF1-EC608E******'),
}

model CreateAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAccountResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateAccount  CreateAccountRequest
  * @return CreateAccountResponse
 */
async function createAccount(request: CreateAccountRequest): CreateAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAccount', 'POST', '/', 'json', false, 'json', request);
}

model CreateActivationCodeRequest {
  aliyunOrderId: string(name='AliyunOrderId', description='The Alibaba Cloud order ID (including the virtual order ID).

This parameter is required.', example='2233****445566', position='Query'),
  description?: string(name='Description', description='The description of the activation code.', example='testCode', position='Query'),
  macAddress: string(name='MacAddress', description='The MAC address.

This parameter is required.', example='12:34:56:78:98:00', position='Query'),
  name: string(name='Name', description='The name of the activation code. The name can contain only letters, digits, underscores (_), and hyphens (-). The activation code file downloaded from the console is named based on this name.

This parameter is required.', example='testName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  systemIdentifier?: string(name='SystemIdentifier', description='The system identifier of the database. This parameter is required if you set AllowEmptySystemIdentifier to false.', example='1234567890123456', position='Query'),
}

model CreateActivationCodeResponseBody = {
  activateAt?: string(name='ActivateAt', description='The time when the activation code takes effect.', example='2024-10-16 16:46:20'),
  certContentB64?: string(name='CertContentB64', description='The activation code in the base64 format. The activation code is decoded and stored into a file named license.lic. PolarDB can access and read the license.lic file upon startup to validate the license or perform related operations.', example='AAEAA******AAA='),
  description?: string(name='Description', description='The description of the activation code.', example='testCode'),
  expireAt?: string(name='ExpireAt', description='The time when the activation code expires.', example='2054-10-09 16:46:20'),
  gmtCreated?: string(name='GmtCreated', description='The time when the activation code was created.', example='2024-10-16 16:46:20'),
  gmtModified?: string(name='GmtModified', description='The time when the activation code was last updated.', example='2024-10-16 16:46:20'),
  id?: int32(name='Id', description='The activation code ID.', example='123'),
  macAddress?: string(name='MacAddress', description='The MAC address.', example='12:34:56:78:98:00'),
  name?: string(name='Name', description='The name of the activation code.', example='testName'),
  requestId?: string(name='RequestId', description='The request ID.', example='4CE6DF97-AEA4-484F-906F-C407EE******'),
  systemIdentifier?: string(name='SystemIdentifier', description='The system identifier of the database.', example='1234567890123456'),
}

model CreateActivationCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateActivationCodeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateActivationCode  CreateActivationCodeRequest
  * @return CreateActivationCodeResponse
 */
async function createActivationCode(request: CreateActivationCodeRequest): CreateActivationCodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateActivationCode', 'POST', '/', 'json', false, 'json', request);
}

model CreateBackupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-*************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateBackupResponseBody = {
  backupJobId?: string(name='BackupJobId', description='The ID of the backup set.', example='11111111'),
  requestId?: string(name='RequestId', description='The request ID.', example='F3322AFE-083E-4D77-A074-421301******'),
}

model CreateBackupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateBackupResponseBody(name='body'),
}

/**
  * @description > 
  * *   You can manually create up to three backups for each cluster.
  * *   The `Exceeding the daily backup times of this DB cluster` error message indicates that three manual backups already exist in your cluster. You must delete existing backups before you call this operation to manually create backups. For more information about how to delete backups, see [Delete backups](https://help.aliyun.com/document_detail/98101.html).
  * *   After you call this operation, a backup task is created in the backend. The task may be time-consuming if you want to back up large amounts of data.
  * @param request  the request parameters of CreateBackup  CreateBackupRequest
  * @return CreateBackupResponse
 */
async function createBackup(request: CreateBackupRequest): CreateBackupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBackup', 'POST', '/', 'json', false, 'json', request);
}

model CreateColdStorageInstanceRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='6000170000591aed949d0f5********************', position='Query'),
  coldStorageInstanceDescription?: string(name='ColdStorageInstanceDescription', description='The description of the cluster. The description cannot exceed 256 characters in length.', example='xxxxxxxxx', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID. > You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of all clusters within your account, such as cluster IDs.

This parameter is required.', example='pc-wz9ye3xrtj60ua6d1', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateColdStorageInstanceResponseBody = {
  coldStorageInstanceId?: string(name='ColdStorageInstanceId', description='The cluster ID.', example='pcs_2zeth2gf4i83e578t'),
  requestId?: string(name='RequestId', description='The request ID.', example='F6EBB4ED-D12F-5F49-824C-9DD9C0EC4CF2'),
}

model CreateColdStorageInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateColdStorageInstanceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateColdStorageInstance  CreateColdStorageInstanceRequest
  * @return CreateColdStorageInstanceResponse
 */
async function createColdStorageInstance(request: CreateColdStorageInstanceRequest): CreateColdStorageInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateColdStorageInstance', 'POST', '/', 'json', false, 'json', request);
}

model CreateDBClusterRequest {
  allowShutDown?: string(name='AllowShutDown', description='Whether to enable idle pause. Values:

- **true**: Enabled

- **false**: Disabled (default)

> Only supported by Serverless clusters.', example='true', position='Query'),
  architecture?: string(name='Architecture', description='CPU architecture. Available values include:
- X86
- ARM', example='X86', position='Query'),
  autoRenew?: boolean(name='AutoRenew', description='Whether to enable auto-renewal, with available values as follows:

- **true**: Auto-renew.
- **false**: Do not auto-renew.

The default is **false**.

> This parameter takes effect only when **PayType** is set to **Prepaid**.', example='true', position='Query'),
  backupRetentionPolicyOnClusterDeletion?: string(name='BackupRetentionPolicyOnClusterDeletion', description='Backup retention policy upon cluster deletion, with valid values as follows:
* **ALL**: Permanently retain all backups.
* **LATEST**: Permanently retain the latest backup (automatically backed up before deletion).
* **NONE**: Do not retain backup sets upon cluster deletion.

By default, the value is set to **NONE**, indicating no backup sets are retained upon cluster deletion.
> This parameter applies only when **DBType** is **MySQL**.
> Serverless clusters do not support this parameter.', example='NONE', position='Query'),
  burstingEnabled?: string(name='BurstingEnabled', example='false', position='Query'),
  clientToken?: string(name='ClientToken', description='Used to ensure idempotency of the request. Generated by the client, ensuring uniqueness across different requests, case-sensitive, and not exceeding 64 ASCII characters.', example='6000170000591aed949d0f5********************', position='Query'),
  cloneDataPoint?: string(name='CloneDataPoint', description='The point in time to clone data, with the following options:

- **LATEST**: Data from the latest time point.
- **BackupID**: Historical backup set ID, please enter the specific backup set ID.
- **Timestamp**: Historical time point, please enter the specific time in the format `YYYY-MM-DDThh:mm:ssZ` (UTC time).

The default value is **LATEST**.

> If **CreationOption** is **CloneFromRDS**, this parameter can only be set to **LATEST**.', example='LATEST', position='Query'),
  clusterNetworkType?: string(name='ClusterNetworkType', description='Cluster network type, currently only VPC is supported, with a fixed value of **VPC**.', example='VPC', position='Query'),
  creationCategory?: string(name='CreationCategory', description='Product series, with valid values as follows:
* **Normal**: Cluster Edition (default)
* **Basic**: Single-node
* **ArchiveNormal**: High Compression Engine (X-Engine)
* **NormalMultimaster**: Multi-master Cluster Edition
* **SENormal**: Standard Edition

> * **MySQL** **5.6**, **5.7**, **8.0**, **PostgreSQL** **14**, and **Oracle Syntax Compatible 2.0** support **Basic**.
> * **MySQL** **8.0** supports **ArchiveNormal** and **NormalMultimaster**.
> * **MySQL** **5.6**, **5.7**, **8.0**, and **PostgreSQL** **14** support **SENormal**.

For more information about product series, see [Product Series](https://help.aliyun.com/document_detail/183258.html).', example='Normal', position='Query'),
  creationOption?: string(name='CreationOption', description='Creation method, with the following values supported:

* **Normal**: Creates a brand new PolarDB cluster. For console operations, refer to the following documents:
    * [Create a PolarDB MySQL Edition Database Cluster](https://help.aliyun.com/document_detail/58769.html)
    * [Create a PolarDB PostgreSQL Edition Database Cluster](https://help.aliyun.com/document_detail/118063.html)
    * [Create a PolarDB PostgreSQL Edition (Oracle Compatible) Database Cluster](https://help.aliyun.com/document_detail/118182.html)

* **CloneFromPolarDB**: Clones data from an existing PolarDB cluster to a new PolarDB cluster. For console operations, refer to the following documents:
    * [Clone a PolarDB MySQL Edition Cluster](https://help.aliyun.com/document_detail/87966.html)
    * [Clone a PolarDB PostgreSQL Edition Cluster](https://help.aliyun.com/document_detail/118108.html)
    * [Clone a PolarDB PostgreSQL Edition (Oracle Compatible) Cluster](https://help.aliyun.com/document_detail/118221.html)

* **RecoverFromRecyclebin**: Recovers data from a released PolarDB cluster to a new PolarDB cluster. For console operations, refer to the following documents:
    * [Restore a Released PolarDB MySQL Edition Cluster](https://help.aliyun.com/document_detail/164880.html)
    * [Restore a Released PolarDB PostgreSQL Edition Cluster](https://help.aliyun.com/document_detail/432844.html)
    * [Restore a Released PolarDB PostgreSQL Edition (Oracle Compatible) Cluster](https://help.aliyun.com/document_detail/424632.html)

* **CloneFromRDS**: Clones data from an existing RDS instance to a new PolarDB cluster. Console operation guide is available at [One-click Clone from RDS MySQL to PolarDB MySQL Edition](https://help.aliyun.com/document_detail/121812.html).

* **MigrationFromRDS**: Migrates data from an existing RDS instance to a new PolarDB cluster. The created PolarDB cluster operates in read-only mode with Binlog enabled by default. Console operation guide is at [One-click Upgrade from RDS MySQL to PolarDB MySQL Edition](https://help.aliyun.com/document_detail/121582.html).

* **CreateGdnStandby**: Creates a standby cluster. Console operation guide can be found at [Add Standby Cluster](https://help.aliyun.com/document_detail/160381.html).

* **UpgradeFromPolarDB**: Upgrades and migrates from PolarDB. Console operation guide is detailed in [Major Version Upgrade](https://help.aliyun.com/document_detail/459712.html).

The default value is **Normal**.

> When **DBType** is **MySQL** and **DBVersion** is **8.0**, this parameter can also take the value **CreateGdnStandby**.', example='Normal', position='Query'),
  DBClusterDescription?: string(name='DBClusterDescription', description='Cluster name, which must meet the following requirements:
* Cannot start with `http://` or `https://`.
* Length should be between 2 and 256 characters.', example='test', position='Query'),
  DBMinorVersion?: string(name='DBMinorVersion', description='Database engine minor version number. Valid values include:

- **8.0.2**
- **8.0.1**

> This parameter takes effect only when **DBType** is **MySQL** and **DBVersion** is **8.0**.', example='8.0.1', position='Query'),
  DBNodeClass?: string(name='DBNodeClass', description='Node specifications. For details, refer to the following documents:

- PolarDB MySQL Edition: [Compute Node Specifications](https://help.aliyun.com/document_detail/102542.html).
- PolarDB PostgreSQL Edition (Oracle Compatible): [Compute Node Specifications](https://help.aliyun.com/document_detail/207921.html).
- PolarDB PostgreSQL Edition: [Compute Node Specifications](https://help.aliyun.com/document_detail/209380.html).

> - For a Serverless cluster in PolarDB MySQL, enter **polar.mysql.sl.small**.
<props="china">> - For a Serverless cluster in both PolarDB PostgreSQL (Oracle Compatible) and PolarDB PostgreSQL, enter **polar.pg.sl.small.c**.', example='polar.mysql.x4.medium', position='Query'),
  DBNodeNum?: int32(name='DBNodeNum', description='The number of nodes. This parameter is supported for Standard Edition clusters. Valid values:

*   **1** (default): only one primary node.
*   **2**: one read-only node and one primary node.

> 

*   By default, an Enterprise Edition cluster has two nodes and a Standard Edition cluster has one node.

*   This parameter is supported only for PolarDB for MySQL clusters.', example='1', position='Query'),
  DBType: string(name='DBType', description='Database engine type, with available values as follows:

- **MySQL**
- **PostgreSQL**
- **Oracle**

This parameter is required.', example='MySQL', position='Query'),
  DBVersion: string(name='DBVersion', description='Database engine version number.
* For MySQL, the version numbers are as follows:
    * **5.6**
    * **5.7**
    * **8.0**
* For PostgreSQL, the version numbers are as follows:
    * **11**
    * **14**
    * **15**
    <props="china">
      
      > When creating a Serverless cluster in PolarDB PostgreSQL, only version **14** is supported.
    
    
* For Oracle, the version numbers are as follows:
    * **11**
    * **14**

This parameter is required.', example='5.6', position='Query'),
  defaultTimeZone?: string(name='DefaultTimeZone', description='Cluster timezone (UTC), with selectable values ranging from **-12:00** to **+13:00** at whole-hour intervals, e.g., **00:00**. The default value is **SYSTEM**, which matches the Region\\"s timezone.
> This parameter applies only when **DBType** is **MySQL**.', example='SYSTEM', position='Query'),
  GDNId?: string(name='GDNId', description='Global Database Network (GDN) ID.

> This parameter is required when **CreationOption** is **CreateGdnStandby**.', example='gdn-***********', position='Query'),
  hotStandbyCluster?: string(name='HotStandbyCluster', description='Whether to enable the hot standby cluster. Values are as follows:

- **ON** (default): Enables the hot standby cluster.
- **OFF**: Disables the hot standby cluster.
- **STANDBY**: Enables the hot standby cluster for the standard edition.
> The default value for standard edition clusters is **STANDBY**.', example='ON', position='Query'),
  loosePolarLogBin?: string(name='LoosePolarLogBin', description='Enable Binlog feature, valid values are as follows:
- **ON**: Cluster enables the Binlog feature. - **OFF**: Cluster disables the Binlog feature. > This parameter takes effect only when the **DBType** parameter is set to **MySQL**.', example='ON', position='Query'),
  looseXEngine?: string(name='LooseXEngine', description='Enable the X-Engine storage engine feature, with valid values as follows:

- **ON**: The cluster enables the X-Engine engine.
- **OFF**: The cluster disables the X-Engine engine.
> This parameter is effective only when **CreationOption** is not **CreateGdnStandby**, **DBType** is **MySQL**, and **DBVersion** is **8.0**. The memory specification of nodes that enable the X-Engine engine must be at least 8 GB.', example='ON', position='Query'),
  looseXEngineUseMemoryPct?: string(name='LooseXEngineUseMemoryPct', description='Set the ratio for enabling the X-Engine storage engine, with a range of integers from 10 to 90.
> This parameter takes effect only when **LooseXEngine** is **ON**.', example='50', position='Query'),
  lowerCaseTableNames?: string(name='LowerCaseTableNames', description='Whether table names are case-sensitive, with valid values as follows:
* **1**: Case-insensitive
* **0**: Case-sensitive

The default value is **1**.
> This parameter applies only when **DBType** is **MySQL**.', example='1', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  parameterGroupId?: string(name='ParameterGroupId', description='Parameter template ID.

> You can view the list of parameter templates in the target region, including the parameter template ID, by calling the [DescribeParameterGroups](https://help.aliyun.com/document_detail/207178.html) interface.', example='pcpg-**************', position='Query'),
  payType: string(name='PayType', description='Payment type, with available values as follows:

- **Postpaid**: Pay-as-you-go.
- **Prepaid**: Subscription (monthly or yearly).

This parameter is required.', example='Postpaid', position='Query'),
  period?: string(name='Period', description='If the payment type is **Prepaid**, this parameter is required. It specifies whether the prepaid cluster is on a monthly or yearly basis.

- **Year**: Yearly subscription.
- **Month**: Monthly subscription.', example='Month', position='Query'),
  provisionedIops?: long(name='ProvisionedIops', description='<p id="p_wyg_t4a_glm">The provisioned read and write IOPS for ESSD AutoPL cloud disks. Possible values: 0 to min{50,000, 1000*capacity-Baseline Performance}.</p>
<p id="p_6de_jxy_k2g">Baseline Performance = min{1,800+50*capacity, 50000}.</p>
<note id="note_7kj_j0o_rgs">This parameter is supported only when StorageType is ESSDAUTOPL.</note>', example='1000', position='Query'),
  proxyClass?: string(name='ProxyClass', description='Standard edition database proxy specifications. Values are as follows:

- **polar.maxscale.g2.medium.c**: 2 cores.
- **polar.maxscale.g2.large.c**: 4 cores.
- **polar.maxscale.g2.xlarge.c**: 8 cores.
- **polar.maxscale.g2.2xlarge.c**: 16 cores.
- **polar.maxscale.g2.3xlarge.c**: 24 cores.
- **polar.maxscale.g2.4xlarge.c**: 32 cores.
- **polar.maxscale.g2.8xlarge.c**: 64 cores.', example='polar.maxscale.g2.medium.c', position='Query'),
  proxyType?: string(name='ProxyType', description='Database proxy type, with values including:
- **EXCLUSIVE**: Enterprise Exclusive Edition
- **GENERAL**: Enterprise General Purpose Edition
> The proxy type must match the type of the cluster\\"s node specifications, i.e.,
>- If the node specification is general, the proxy type should be Enterprise General Purpose Edition;
>- If the node specification is dedicated, the proxy type should be Enterprise Exclusive Edition.', example='Exclusive', position='Query'),
  regionId: string(name='RegionId', description='Region ID.

> You can view available regions through the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) interface.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='Resource group ID.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scaleMax?: string(name='ScaleMax', description='Maximum scaling limit for a single node. The value range is: 1 PCU~32 PCU.

> Only supported by Serverless clusters.', example='3', position='Query'),
  scaleMin?: string(name='ScaleMin', description='Minimum scaling limit for a single node. The value range is: 1 PCU~31 PCU.

> Only supported by Serverless clusters.', example='1', position='Query'),
  scaleRoNumMax?: string(name='ScaleRoNumMax', description='Maximum scaling limit for the number of read-only nodes. The value range is: 0~15.

> Only supported by Serverless clusters.', example='4', position='Query'),
  scaleRoNumMin?: string(name='ScaleRoNumMin', description='Minimum scaling limit for the number of read-only nodes. The value range is: 0~15.

> Only supported by Serverless clusters.', example='2', position='Query'),
  securityIPList?: string(name='SecurityIPList', description='PolarDB cluster whitelist IP address.
> Supports configuring multiple whitelist IP addresses, with English commas separating multiple IP addresses.', example='10.***.***.***', position='Query'),
  serverlessType?: string(name='ServerlessType', description='Serverless type. The current value is fixed to **AgileServerless** (sensitive mode).
> This parameter is only supported by Serverless clusters.', example='AgileServerless', position='Query'),
  sourceResourceId?: string(name='SourceResourceId', description='Source RDS instance ID or source PolarDB cluster ID. This parameter is mandatory only when **CreationOption** is set to **MigrationFromRDS**, **CloneFromRDS**, **CloneFromPolarDB**, or **RecoverFromRecyclebin**.
* If **CreationOption** is **MigrationFromRDS** or **CloneFromRDS**, you need to input the source RDS instance ID. The source RDS instance version must be RDS MySQL 5.6, 5.7, or 8.0 High Availability edition.

* If **CreationOption** is **CloneFromPolarDB**, you need to input the source PolarDB cluster ID. The DBType of the cloned cluster will default to match the source cluster. For example, if the source cluster is MySQL 8.0, the cloned cluster must also have **DBType** set to **MySQL** and **DBVersion** to **8.0**.

* If **CreationOption** is **RecoverFromRecyclebin**, you need to input the released source PolarDB cluster ID. The DBType of the cluster being recovered from the recycle bin must match the source cluster. For example, if the source cluster was MySQL 8.0, the recovered cluster must also have **DBType** set to **MySQL** and **DBVersion** to **8.0**.', example='rm-*************', position='Query'),
  standbyAZ?: string(name='StandbyAZ', description='The availability zone where the hot standby cluster is stored. Applicable to the standard edition 3AZ scenario.

> This parameter takes effect only when multi-zone data strong consistency is enabled.', example='cn-hangzhou-g', position='Query'),
  storageAutoScale?: string(name='StorageAutoScale', description='Whether to enable automatic storage expansion for standard edition clusters, with valid values as follows:

- Enable: Enables automatic storage expansion.
- Disable: Disables automatic storage expansion.', example='Enable', position='Query'),
  storageEncryption?: boolean(name='StorageEncryption', description='Specifies whether to enable disk encryption. Valid values:

*   **true**
*   **false** (default)

>  This parameter takes effect only when **DBType** is set to **MySQL**.

>  This parameter takes effect only when **StorageType** is set to one of the Standard Edition storage types.', position='Query'),
  storageEncryptionKey?: string(name='StorageEncryptionKey', description='The ID of the custom key that is used for disk encryption in the region in which the instance resides. If this parameter is specified, disk encryption is automatically enabled and cannot be disabled afterwards. If you want to use the default service key for disk encryption, leave this parameter empty.

You can obtain the ID of the key in the KMS console or create a key.

>  This parameter takes effect only when **DBType** is set to **MySQL**.

>  This parameter takes effect only when **StorageType** is set to one of the Standard Edition storage types.', position='Query'),
  storagePayType?: string(name='StoragePayType', description='The storage billing type, with valid values as follows:

- Postpaid: Pay-as-you-go (hourly).
- Prepaid: Pay-per-use based on space (subscription).', example='Prepaid', position='Query'),
  storageSpace?: long(name='StorageSpace', description='The storage that is billed based on the subscription billing method. Unit: GB.

> 

*   Valid values for the subscription storage capacity of a PolarDB for MySQL Standard Edition cluster: 20 to 32000.

*   Valid values for the subscription storage capacity of a Standard Edition cluster that uses the ESSD AUTOPL storage type: 40 to 64000, in increments of 10.', example='50', minimum=10, maximum=64000, position='Query'),
  storageType?: string(name='StorageType', description='Enterprise edition storage types include:
- **PSL5**
- **PSL4**

Standard edition storage types include:
- **ESSDPL0**
- **ESSDPL1**
- **ESSDPL2**
- **ESSDPL3**
- **ESSDAUTOPL**', example='PSL4', position='Query'),
  storageUpperBound?: long(name='StorageUpperBound', description='Set the upper limit for automatic storage expansion of standard edition clusters, in GB.

> The maximum value is 32000.', example='800', minimum=20, maximum=64000, position='Query'),
  strictConsistency?: string(name='StrictConsistency', description='Whether the cluster has enabled strong data consistency across multiple zones. Values are as follows:

- **ON**: Indicates strong data consistency across multiple zones is enabled, applicable to the standard edition 3AZ scenario.

- **OFF**: Indicates strong data consistency across multiple zones is not enabled.', example='ON', position='Query'),
  TDEStatus?: boolean(name='TDEStatus', description='Enables TDE encryption. Valid values are as follows:

- **true**: Enabled.
- **false**: Disabled (default).

> * This parameter takes effect only when **DBType** is **PostgreSQL** or **Oracle**.
> * You can call the [ModifyDBClusterTDE](https://help.aliyun.com/document_detail/167982.html) interface to enable TDE encryption for a PolarDB MySQL cluster.
> * Once the TDE feature is enabled, it cannot be disabled.', example='true', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='Tag key. If you need to add multiple tags to the target cluster at once, click **Add** to add a tag key.

> Up to 20 pairs of tags can be added each time, where `Tag.N.Key` corresponds to `Tag.N.Value`.', example='type'),
      value?: string(name='Value', description='Tag value. If you need to add multiple tags to the target cluster at once, click **Add** to add tag values.

> Up to 20 pairs of tags can be added each time, where `Tag.N.Value` corresponds to `Tag.N.Key`.', example='test'),
    }
  ](name='Tag', description='List of tags.', position='Query'),
  targetMinorVersion?: string(name='TargetMinorVersion', position='Query'),
  usedTime?: string(name='UsedTime', description='If the payment type is **Prepaid**, this parameter is required.
- When **Period** is **Month**, **UsedTime** should be an integer within `[1-9]`.
- When **Period** is **Year**, **UsedTime** should be an integer within `[1-3]`.', example='1', position='Query'),
  VPCId?: string(name='VPCId', description='VPC ID.', example='vpc-**********', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='Virtual switch ID.

> If VPCId has been selected, VSwitchId is mandatory.', example='vsw-**********', position='Query'),
  zoneId?: string(name='ZoneId', description='Availability Zone ID.

> You can view the available zones through the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) interface.', example='cn-hangzhou-j', position='Query'),
}

model CreateDBClusterResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='Cluster ID.', example='pc-bp1s826a1up******'),
  orderId?: string(name='OrderId', description='Order ID.', example='211454967******'),
  requestId?: string(name='RequestId', description='Request ID.', example='E56531A4-E552-40BA-9C58-137B80******'),
  resourceGroupId?: string(name='ResourceGroupId', description='Resource group ID.', example='rg-***************'),
}

model CreateDBClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDBClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateDBCluster  CreateDBClusterRequest
  * @return CreateDBClusterResponse
 */
async function createDBCluster(request: CreateDBClusterRequest): CreateDBClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDBCluster', 'POST', '/', 'json', false, 'json', request);
}

model CreateDBClusterEndpointRequest {
  autoAddNewNodes?: string(name='AutoAddNewNodes', description='Specifies whether to enable automatic association of newly added nodes with the cluster endpoint. Valid values:

*   **Enable**
*   **Disable** (default)', example='Disable', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f******************', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-**************', position='Query'),
  DBEndpointDescription?: string(name='DBEndpointDescription', description='The name of the custom cluster endpoint.', example='test', position='Query'),
  endpointConfig?: string(name='EndpointConfig', description='The advanced configurations of the cluster endpoint. You must specify the configurations in the JSON format. You can specify the configurations of the following attributes: consistency level, transaction splitting, connection pool, and offload reads from the primary node.

*   Specify the consistency level in the format of `{"ConsistLevel":"Consistency level"}`. Default value: 1. Valid values:

    *   **0**: eventual consistency.
    *   **1**: session consistency.
    *   **2**: global consistency.

*   Specify the transaction splitting feature in the format of `{"DistributedTransaction":"Transaction splitting"}`. Valid values:

    *   **on**: enables the transaction splitting feature. By default, the feature is enabled.
    *   **off**: disables the transaction splitting feature.

*   Specify the offload reads from the primary node feature in the format of `{"MasterAcceptReads":"Offload reads from the primary node"}`. Default value: off. Valid values:

    *   **on**: The primary node accepts read requests.
    *   **off**: The primary node does not accept read requests.

*   Specify the connection pool in the format of `{"ConnectionPersist":"Connection pool"}`. Default value: off. Valid values:

    *   **off**: disables the connection pool.
    *   **Session**: enables the session-level connection pool.
    *   **Transaction**: enables the transaction-level connection pool.

>- You can specify the transaction splitting, connection pool, and offload reads from the primary node features for a PolarDB for MySQL cluster only if ReadWriteMode is set to ReadWrite for the cluster endpoint.
>- Only PolarDB for MySQL supports global consistency.
>- If the **ReadWriteMode** parameter is set to **ReadOnly**, the consistency level must be **0**.
>- You can use one record to specify the consistency level, transaction splitting, connection pool, and offload reads from the primary node features, such as `{"ConsistLevel":"1","DistributedTransaction":"on","ConnectionPersist":"Session","MasterAcceptReads":"on"}`.
>- The transaction splitting settings are restricted by the consistency level settings. For example, if you set the consistency level to **0**, transaction splitting cannot be enabled. If you set the consistency level to **1** or **2**, transaction splitting can be enabled.', example='{"ConsistLevel": "1","DistributedTransaction": "on"}', position='Query'),
  endpointType: string(name='EndpointType', description='The type of the cluster endpoint. Set the value to **Custom**.

This parameter is required.', example='Custom', position='Query'),
  nodes?: string(name='Nodes', description='The reader nodes that you want to associate with the endpoint. If you want to specify multiple reader nodes, separate the reader nodes with commas (,). If you do not specify this parameter, all nodes are used.

>- You need to specify the node IDs for a PolarDB for MySQL cluster.
>- You need to specify the role name of each node for a PolarDB for PostgreSQL cluster or a PolarDB for PostgreSQL (Compatible with Oracle) cluster. Example: `Writer, Reader1, Reader2`.
>- If you set **ReadWriteMode** to **ReadOnly**, you can associate only one node with the endpoint. If the only node becomes faulty, the cluster endpoint may be unavailable for up to 1 hour. We recommend that you associate more than one node with the cluster endpoint in production environments. We recommend that you associate at least two nodes with the cluster endpoint to improve service availability.
>- If you set **ReadWriteMode** to **ReadWrite**, you need to associate at least two nodes with the cluster endpoint.
>- PolarDB for MySQL does not impose a limit on the types of the two nodes. If the nodes are read-only nodes, write requests are forwarded to the primary node. 
>- PolarDB for PostgreSQL and PolarDB for PostgreSQL (compatible with Oracle) require a primary node.', example='pi-**********,pi-*********', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  polarSccTimeoutAction?: string(name='PolarSccTimeoutAction', description='Global consistency timeout strategy. The value range is as follows:
- **0**: Send the request to the primary node
- **2**: Timeout degradation, when a global consistency read times out, the query operation will automatically degrade to an inconsistent read, and the client will not receive an error message', example='0', position='Query'),
  polarSccWaitTimeout?: string(name='PolarSccWaitTimeout', description='Global consistency timeout', example='100', position='Query'),
  readWriteMode?: string(name='ReadWriteMode', description='The read/write mode. Valid values:

*   **ReadWrite**: receives and forwards read and write requests. Automatic read/write splitting is enabled.
*   **ReadOnly**: The account has the read-only permissions on the database.

Default value: **ReadOnly**.', example='ReadOnly', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sccMode?: string(name='SccMode', description='Specifies whether to enable the global consistency (high-performance mode) feature for the nodes. Valid values:

*   **ON**
*   **OFF**', example='on', position='Query'),
}

model CreateDBClusterEndpointResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CD35F3-F3-44CA-AFFF-BAF869******'),
}

model CreateDBClusterEndpointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDBClusterEndpointResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateDBClusterEndpoint  CreateDBClusterEndpointRequest
  * @return CreateDBClusterEndpointResponse
 */
async function createDBClusterEndpoint(request: CreateDBClusterEndpointRequest): CreateDBClusterEndpointResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDBClusterEndpoint', 'POST', '/', 'json', false, 'json', request);
}

model CreateDBEndpointAddressRequest {
  connectionStringPrefix?: string(name='ConnectionStringPrefix', description='The prefix of the new endpoint. The prefix of the endpoint must meet the following requirements:

*   The prefix can contain lowercase letters, digits, and hyphens (-).
*   The prefix must start with a letter and end with a digit or a letter.
*   The prefix must be 6 to 40 characters in length.', example='test-1', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-**************', position='Query'),
  DBEndpointId: string(name='DBEndpointId', description='The ID of the endpoint.

>  You can call the [DescribeDBClusterEndpoints](https://help.aliyun.com/document_detail/98205.html) operation to query endpoint details.

This parameter is required.', example='pe-**************', position='Query'),
  netType: string(name='NetType', description='The network type of the endpoint. Set the value to **Public**.

This parameter is required.', example='Public', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the ECS security group.', example='sg-bp**************', position='Query'),
  VPCId?: string(name='VPCId', description='The ID of the virtual private cloud (VPC).', example='vpc-**********', position='Query'),
  zoneInfo?: [ 
    {
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-**********'),
      zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-b'),
    }
  ](name='ZoneInfo', description='The details of the zones.', position='Query'),
}

model CreateDBEndpointAddressResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6BD9CDE4-5E7B-4BF3-9BB8-83C73E******'),
}

model CreateDBEndpointAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDBEndpointAddressResponseBody(name='body'),
}

/**
  * @description > You can create a public endpoint for the primary endpoint, the default cluster endpoint, or a custom cluster endpoint.
  * @param request  the request parameters of CreateDBEndpointAddress  CreateDBEndpointAddressRequest
  * @return CreateDBEndpointAddressResponse
 */
async function createDBEndpointAddress(request: CreateDBEndpointAddressRequest): CreateDBEndpointAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDBEndpointAddress', 'POST', '/', 'json', false, 'json', request);
}

model CreateDBLinkRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the source cluster that the database link connects.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/173433.html) operation to query PolarDB clusters.

This parameter is required.', example='pc-a************', position='Query'),
  DBLinkName: string(name='DBLinkName', description='The name of the database link.

*   The name must contain lowercase letters and can also contain digits and underscores (_).
*   The name must start with a letter and end with a letter or digit.
*   The name must be 1 to 64 characters in length.

This parameter is required.', example='dblink_test', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region.

>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query information about regions.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sourceDBName: string(name='SourceDBName', description='The name of the source database.

>  You can call the [DescribeDatabases](https://help.aliyun.com/document_detail/173558.html) operation to query information about databases in a PolarDB cluster.

This parameter is required.', example='testdb1', position='Query'),
  targetDBAccount: string(name='TargetDBAccount', description='The account of the destination database.

>  You can call the [DescribeAccounts](https://help.aliyun.com/document_detail/173549.html) operation to query the account of a PolarDB cluster.

This parameter is required.', example='testacc', position='Query'),
  targetDBInstanceName?: string(name='TargetDBInstanceName', description='The ID of the destination cluster that the database link connects.

> *   If the destination cluster is a user-created Oracle database on an ECS instance, set the value to `null`.
> *   You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/173433.html) operation to query PolarDB clusters.', example='pc-b************', position='Query'),
  targetDBName: string(name='TargetDBName', description='The name of the destination database.

>  You can call the [DescribeDatabases](https://help.aliyun.com/document_detail/173558.html) operation to query information about databases in a PolarDB cluster.

This parameter is required.', example='testdb2', position='Query'),
  targetDBPasswd: string(name='TargetDBPasswd', description='The account password of the destination database.

This parameter is required.', example='Test1111', position='Query'),
  targetIp?: string(name='TargetIp', description='The IP address of the user-created Oracle database on an ECS instance.', example='192.**.**.46', position='Query'),
  targetPort?: string(name='TargetPort', description='The port number of the user-created Oracle database on an ECS instance.', example='1521', position='Query'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).

>  You can call the [DescribeVpcs](https://help.aliyun.com/document_detail/35739.html) operation to query information about VPCs.', example='vpc-bp1qpo0kug3a20qqe****', position='Query'),
}

model CreateDBLinkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F9F1CB1A-B1D5-4EF5-A53A-************'),
}

model CreateDBLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDBLinkResponseBody(name='body'),
}

/**
  * @description A database link can be used to connect two PolarDB for PostgreSQL(Compatible with Oracle) clusters, or connect a PolarDB for PostgreSQL(Compatible with Oracle) cluster to a user-created PostgreSQL database that is hosted on an Elastic Compute Service (ECS) instance. You can use database links to query data across clusters.
  * > *   You can create up to 10 database links for a cluster.
  * > *   Each database link connects a source cluster and a destination cluster.
  * > *   The source cluster and the destination cluster or the destination ECS instance must be located in the same region.
  * @param request  the request parameters of CreateDBLink  CreateDBLinkRequest
  * @return CreateDBLinkResponse
 */
async function createDBLink(request: CreateDBLinkRequest): CreateDBLinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDBLink', 'POST', '/', 'json', false, 'json', request);
}

model CreateDBNodesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-*************', position='Query'),
  DBNode: [ 
    {
      targetClass?: string(name='TargetClass', description='The specifications of the read-only node that you want to add, which must be the same as the specifications of the existing nodes. For more information, see the following topics:

*   PolarDB for MySQL: [Specifications of compute nodes](https://help.aliyun.com/document_detail/102542.html)
*   PolarDB for PostgreSQL (Compatible with Oracle): [Specifications of compute nodes](https://help.aliyun.com/document_detail/207921.html)
*   PolarDB for PostgreSQL: [Specifications of compute nodes](https://help.aliyun.com/document_detail/209380.html)

>- You need to specify either DBNode.N.ZoneId or DBNode.N.TargetClass. N is an integer that starts from 1. The maximum value of N is equal to 16 minus the number of existing nodes.
>- You can add multiple read-only nodes at the same time only to PolarDB for MySQL clusters, which can contain up to of 15 read-only nodes.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters. This parameter is optional for PolarDB for MySQL clusters.', example='polar.mysql.x4.medium'),
      zoneId?: string(name='ZoneId', description='The zone ID of the node that you want to add, which must be the same as the zone ID of existing nodes. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the IDs of zones.

>- You need to specify either DBNode.N.ZoneId or DBNode.N.TargetClass. N is an integer that starts from 1. The maximum value of N is equal to 16 minus the number of existing nodes.
>- You can add multiple read-only nodes at the same time only to PolarDB for MySQL clusters, which can contain up to of 15 read-only nodes.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters. This parameter is optional for PolarDB for MySQL clusters.', example='cn-qingdao-c'),
    }
  ](name='DBNode', description='The details of the read-only node.

This parameter is required.', position='Query'),
  DBNodeType?: string(name='DBNodeType', description='The node type. Valid values:

*   RO
*   STANDBY
*   DLNode

Enumerated values:

*   DLNode: AI node
*   STANDBY: standby node
*   RO: read-only node', example='RO', position='Query'),
  endpointBindList?: string(name='EndpointBindList', description='The ID of the cluster endpoint to which the read-only node is added. If you want to add the read-only node to multiple endpoints at the same time, separate the endpoint IDs with commas (,).
> - You can call the [DescribeDBClusterEndpoints](https://help.aliyun.com/document_detail/98205.html) operation to query the details of cluster endpoints, including endpoint IDs.
>- You can enter the ID of the default cluster endpoint or a custom cluster endpoint.
>- If you leave this parameter empty, the read-only node is added to all cluster endpoints for which the **Automatically Associate New Nodes** feature is enabled. If you set `AutoAddNewNodes` to `Enable`, the Automatically Associate New Nodes feature is enabled.', example='pe-****************,pe-****************', position='Query'),
  imciSwitch?: string(name='ImciSwitch', description='Specifies whether to enable the In-Memory Column Index (IMCI) feature. Default value: OFF. Valid values:

*   **ON**
*   **OFF**

> This parameter is invalid for a PolarDB for Oracle or PolarDB for PostgreSQL cluster.', example='ON', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time for upgrading the specifications within the scheduled time period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

>- The value of this parameter must be at least 30 minutes later than the value of PlannedStartTime.
>- If you specify `PlannedStartTime` but do not specify PlannedEndTime, the latest start time of the task is set to a value that is calculated by using the following formula: `PlannedEndTime value + 30 minutes`. For example, if you set `PlannedStartTime` to `2021-01-14T09:00:00Z` and you do not specify PlannedEndTime, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z', position='Query'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time of the scheduled task for adding the read-only node. The scheduled task specifies that the task is run in the required period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

>- The earliest start time of the scheduled task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in time between `2021-01-14T09:00:00Z` and `2021-01-15T09:00:00Z`.
>- If you leave this parameter empty, the task for adding the read-only node is immediately run by default.', example='2021-01-14T09:00:00Z', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateDBNodesResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-***************'),
  DBNodeIds?: {
    DBNodeId?: [ string ](name='DBNodeId')
  }(name='DBNodeIds', description='Details about the nodes.'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2148126708*****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E053E730-5755-4AA9-AA9D-A47867******'),
}

model CreateDBNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDBNodesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateDBNodes  CreateDBNodesRequest
  * @return CreateDBNodesResponse
 */
async function createDBNodes(request: CreateDBNodesRequest): CreateDBNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDBNodes', 'POST', '/', 'json', false, 'json', request);
}

model CreateDatabaseRequest {
  accountName?: string(name='AccountName', description='The name of the account that is authorized to access the database. You can call the [DescribeAccounts](https://help.aliyun.com/document_detail/98107.html) operation to query account information.
>- You can specify only a standard account. By default, privileged accounts have all permissions on all databases. You do not need to grant privileged accounts the permissions to access the database.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters. This parameter is optional for PolarDB for MySQL clusters.', example='testacc', position='Query'),
  accountPrivilege?: string(name='AccountPrivilege', description='The permissions that are granted to the account. Valid values:

*   **ReadWrite**: read and write permissions.
*   **ReadOnly**: read-only permissions.
*   **DMLOnly**: the permissions to execute only DML statements.
*   **DDLOnly**: the permissions to execute only DDL statements.
*   **ReadIndex**: the read-only and index permissions.

If you leave this parameter empty, the default value **ReadWrite** is used.

>- This parameter is valid only if you specify **AccountName**.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is optional for PolarDB for MySQL clusters.', example='ReadWrite', position='Query'),
  characterSetName: string(name='CharacterSetName', description='The character set that is used by the cluster. For more information, see [Character set tables](https://help.aliyun.com/document_detail/99716.html).

This parameter is required.', example='utf8', position='Query'),
  collate?: string(name='Collate', description='The language that defines the collation rules in the database.

> 

*   The language must be compatible with the character set that is specified by **CharacterSetName**.

*   This parameter is required for a PolarDB for PostgreSQL (Compatible with Oracle) or PolarDB for PostgreSQL cluster. This parameter is optional for a PolarDB for MySQL cluster. To view the valid values of this parameter, perform the following steps: Log on to the PolarDB console and click the ID of the cluster. In the left-side navigation pane, choose **Settings and Management** > **Databases**. Then, click **Create Database**.', example='C', position='Query'),
  ctype?: string(name='Ctype', description='The language that indicates the character type of the database.

>- The language must be compatible with the character set that is specified by **CharacterSetName**.
>- The value that you specify must be the same as the value of **Collate**.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters. This parameter is optional for PolarDB for MySQL clusters.

To view the valid values for this parameter, perform the following steps: Log on to the PolarDB console and click the ID of a cluster. In the left-side navigation pane, choose **Settings and Management** > **Databases**. Then, click **Create Database**.', example='C', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-**************', position='Query'),
  DBDescription?: string(name='DBDescription', description='The description of the database. The description must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must be 2 to 256 characters in length.

> This parameter is required for a PolarDB for Oracle or PolarDB for PostgreSQL cluster. This parameter is optional for a PolarDB for MySQL cluster.', example='testdesc', position='Query'),
  DBName: string(name='DBName', description='The name of the database. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, hyphens (-), and underscores (_).
*   The name must start with a lowercase letter and end with a lowercase letter or a digit. The name must be 1 to 64 characters in length.

> Do not use reserved words as database names, such as `test` or `mysql`.

This parameter is required.', example='testDB', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateDatabaseResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='93E98F25-BE02-40DA-83E3-F77F8D******'),
}

model CreateDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDatabaseResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that the following requirements are met:
  * *   The cluster is in the Running state.
  * *   The cluster is unlocked.
  * @param request  the request parameters of CreateDatabase  CreateDatabaseRequest
  * @return CreateDatabaseResponse
 */
async function createDatabase(request: CreateDatabaseRequest): CreateDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDatabase', 'POST', '/', 'json', false, 'json', request);
}

model CreateGlobalDatabaseNetworkRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBClusterId: string(name='DBClusterId', description='The ID of the primary cluster.

This parameter is required.', example='pc-bp1q76364ird*****', position='Query'),
  enableGlobalDomainName?: boolean(name='EnableGlobalDomainName', description='Specifies whether to create a global domain name.', example='false', position='Query'),
  GDNDescription?: string(name='GDNDescription', description='The description of the GDN. The description must meet the following requirements:

*   It cannot start with [http:// or https://.](http://https://。)
*   It must start with a letter.
*   It can contain letters, digits, underscores (_), and hyphens (-).
*   It must be 2 to 126 characters in length.', example='GDN-fortest', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model CreateGlobalDatabaseNetworkResponseBody = {
  GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gd-m5ex5wqfqbou*****'),
  requestId?: string(name='RequestId', description='The request ID.', example='C61892A4-0850-4516-9E26-44D96C1782DE'),
}

model CreateGlobalDatabaseNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateGlobalDatabaseNetworkResponseBody(name='body'),
}

/**
  * @description >  A cluster belongs to only one GDN.
  * @param request  the request parameters of CreateGlobalDatabaseNetwork  CreateGlobalDatabaseNetworkRequest
  * @return CreateGlobalDatabaseNetworkResponse
 */
async function createGlobalDatabaseNetwork(request: CreateGlobalDatabaseNetworkRequest): CreateGlobalDatabaseNetworkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGlobalDatabaseNetwork', 'POST', '/', 'json', false, 'json', request);
}

model CreateGlobalSecurityIPGroupRequest {
  gIpList: string(name='GIpList', description='The IP address in the whitelist template.

>  Multiple IP addresses are separated by commas (,). You can create up to 1,000 IP addresses or CIDR blocks for all IP whitelists.

This parameter is required.', example='192.168.0.1', position='Query'),
  globalIgName: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or digit.
*   The name must be 2 to 120 characters in length.

This parameter is required.', example='test_123', minLength=2, maxLength=120, position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model CreateGlobalSecurityIPGroupResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      gIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroup', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model CreateGlobalSecurityIPGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateGlobalSecurityIPGroupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateGlobalSecurityIPGroup  CreateGlobalSecurityIPGroupRequest
  * @return CreateGlobalSecurityIPGroupResponse
 */
async function createGlobalSecurityIPGroup(request: CreateGlobalSecurityIPGroupRequest): CreateGlobalSecurityIPGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGlobalSecurityIPGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateOrGetVirtualLicenseOrderRequest {
  engine: string(name='Engine', description='The type of the engine. Valid values: PG, Oracle, and MySQL.

This parameter is required.', example='PG', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateOrGetVirtualLicenseOrderResponseBody = {
  activatedCodeCount?: int32(name='ActivatedCodeCount', description='The number of generated activation codes.', example='1'),
  activationCodeQuota?: int32(name='ActivationCodeQuota', description='The maximum number of activation codes that you can apply for.', example='10'),
  aliyunOrderId?: string(name='AliyunOrderId', description='The Alibaba Cloud order ID (including the virtual order ID).', example='2233****445566'),
  allowEmptySystemIdentifier?: boolean(name='AllowEmptySystemIdentifier', description='Indicates whether activation codes can be generated without the system identifier.', example='false'),
  gmtCreated?: string(name='GmtCreated', description='The time when the order was created.', example='2024-10-16 16:46:20'),
  gmtModified?: string(name='GmtModified', description='The time when the order was last updated.', example='2024-10-16 16:46:20'),
  isVirtualOrder?: boolean(name='IsVirtualOrder', description='Indicates whether the order is a virtual order (virtual orders allow pre-generation of activation codes).', example='true'),
  isVirtualOrderFrozen?: boolean(name='IsVirtualOrderFrozen', description='Indicates whether the virtual order is frozen (activation codes cannot be generated for a frozen virtual order).', example='false'),
  packageType?: string(name='PackageType', description='The plan type.', example='pre_generation_long_term'),
  packageValidity?: string(name='PackageValidity', description='The validity period of the plan, which is one year (common) or thirty years (long-term).', example='30 years'),
  purchaseChannel?: string(name='PurchaseChannel', description='The purchase channel.', example='aliyun_market'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='45D24263-7E3A-4140-9472-************'),
  virtualOrderId?: string(name='VirtualOrderId', description='The ID of the virtual order.', example='2024********483'),
}

model CreateOrGetVirtualLicenseOrderResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOrGetVirtualLicenseOrderResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateOrGetVirtualLicenseOrder  CreateOrGetVirtualLicenseOrderRequest
  * @return CreateOrGetVirtualLicenseOrderResponse
 */
async function createOrGetVirtualLicenseOrder(request: CreateOrGetVirtualLicenseOrderRequest): CreateOrGetVirtualLicenseOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOrGetVirtualLicenseOrder', 'POST', '/', 'json', false, 'json', request);
}

model CreateParameterGroupRequest {
  DBType: string(name='DBType', description='The type of the database engine. Only **MySQL** is supported.

This parameter is required.', example='MySQL', position='Query'),
  DBVersion: string(name='DBVersion', description='The version of the database engine. Valid values:

*   **5.6**
*   **5.7**
*   **8.0**

This parameter is required.', example='8.0', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  parameterGroupDesc?: string(name='ParameterGroupDesc', description='The description of the parameter template. It must be 0 to 199 characters in length.', example='test_group', position='Query'),
  parameterGroupName: string(name='ParameterGroupName', description='The name of the parameter template. The name must meet the following requirements:

*   It can contain letters, digits, and underscores (_). It must start with a letter and cannot end with an underscore.**
*   It must be 8 to 64 characters in length.

This parameter is required.', example='test_group', position='Query'),
  parameters: string(name='Parameters', description='The JSON string that consists of parameters and values. The parameter values are strings. Example: `{"wait_timeout":"86400","innodb_old_blocks_time":"1000"}`.

> You can call the [DescribeParameterTemplates](https://help.aliyun.com/document_detail/207428.html) operation to query the details of all parameters in the cluster of a specified engine version, such as the parameter name and valid values.

This parameter is required.', example='{"wait_timeout":"86400","innodb_old_blocks_time":"1000"}', position='Query'),
  regionId: string(name='RegionId', description='The region ID.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query available regions.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateParameterGroupResponseBody = {
  parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template.

> You can call the [DescribeParameterGroups](https://help.aliyun.com/document_detail/207178.html) operation to query the details of all parameter templates of a specified region, such as the ID of a parameter template.', example='pcpg-**************'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='514D1D87-E243-4A5F-A87D-2785C3******'),
}

model CreateParameterGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateParameterGroupResponseBody(name='body'),
}

/**
  * @description You can use parameter templates to manage multiple parameters at a time and apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](https://help.aliyun.com/document_detail/207009.html).
  * > You can call this operation only on a PolarDB for MySQL cluster.
  * @param request  the request parameters of CreateParameterGroup  CreateParameterGroupRequest
  * @return CreateParameterGroupResponse
 */
async function createParameterGroup(request: CreateParameterGroupRequest): CreateParameterGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateParameterGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateServiceLinkedRoleRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateServiceLinkedRoleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='3F9E6A3B-C13E-4064-A010-18582A******'),
}

model CreateServiceLinkedRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateServiceLinkedRoleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateServiceLinkedRole  CreateServiceLinkedRoleRequest
  * @return CreateServiceLinkedRoleResponse
 */
async function createServiceLinkedRole(request: CreateServiceLinkedRoleRequest): CreateServiceLinkedRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateServiceLinkedRole', 'POST', '/', 'json', false, 'json', request);
}

model CreateStoragePlanRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value. Make sure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='6000170000591aed949d0f5********************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period: string(name='Period', description='The unit of the subscription duration for the storage plan. Valid values:

*   **Month**
*   **Year**

This parameter is required.', example='Month', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  storageClass: string(name='StorageClass', description='The capacity of the storage plan. Unit: GB. Valid values: 50, 100, 200, 300, 500, 1000, 2000, 3000, 5000, 10000, 15000, 20000, 25000, 30000, 50000, 100000, and 200000

This parameter is required.', example='500', position='Query'),
  storageType: string(name='StorageType', description='The type of the storage plan. Valid values:

*   **Mainland**: The storage plan is used inside the Chinese mainland.
*   **Overseas**: The storage plan is used outside the Chinese mainland.

This parameter is required.', example='Mainland', position='Query'),
  usedTime: string(name='UsedTime', description='The subscription duration of the storage plan.

*   If **Period** is set to **Month**, the value ranges from 1 to 9.
*   If **Period** is set to **Year**, the value can be 1, 2, 3, or 5.

This parameter is required.', example='3', position='Query'),
}

model CreateStoragePlanResponseBody = {
  DBInstanceId?: string(name='DBInstanceId', description='The instance ID.', example='POLARDB-cn-**************'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2035638*******'),
  requestId?: string(name='RequestId', description='The request ID.', example='69A85BAF-1089-4CDF-A82F-0A140F******'),
}

model CreateStoragePlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateStoragePlanResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateStoragePlan  CreateStoragePlanRequest
  * @return CreateStoragePlanResponse
 */
async function createStoragePlan(request: CreateStoragePlanRequest): CreateStoragePlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateStoragePlan', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAccountRequest {
  accountName: string(name='AccountName', description='The username of the account.

This parameter is required.', example='testacc', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-*************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteAccountResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model DeleteAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAccountResponseBody(name='body'),
}

/**
  * @description > Before you call this operation, make sure that the cluster is in the Running state. Otherwise, the operation fails.
  * @param request  the request parameters of DeleteAccount  DeleteAccountRequest
  * @return DeleteAccountResponse
 */
async function deleteAccount(request: DeleteAccountRequest): DeleteAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAccount', 'POST', '/', 'json', false, 'json', request);
}

model DeleteBackupRequest {
  backupId: string(name='BackupId', description='The backup ID. If you need to specify multiple backup IDs, separate the backup IDs with commas (,).

>  You can call the [DescribeBackups](https://help.aliyun.com/document_detail/98102.html) operation to query the backup IDs.

This parameter is required.', example='11111111', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-**************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteBackupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='3CF4F9FE-BF77-4739-8D68-B8DF5D******'),
}

model DeleteBackupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteBackupResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that the cluster meets the following requirements:
  * *   The cluster is in the Running state.
  * *   The backup sets are in the Success state.
  * > *   You can call the [DescribeBackups](https://help.aliyun.com/document_detail/98102.html) operation to query the status of backup sets.
  * >*   After you delete the backup set file, the storage space that is occupied by the file is released. The released storage space is smaller than the size of the file because your snapshots share some data blocks
  * @param request  the request parameters of DeleteBackup  DeleteBackupRequest
  * @return DeleteBackupResponse
 */
async function deleteBackup(request: DeleteBackupRequest): DeleteBackupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBackup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDBClusterRequest {
  backupRetentionPolicyOnClusterDeletion?: string(name='BackupRetentionPolicyOnClusterDeletion', description='The retention policy applied to the backup sets when the cluster is released. Valid values:

*   **ALL**: permanently retains all backup sets.
*   **LATEST**: permanently retains the most recent backup set that is automatically created before the cluster is released.
*   **NONE**: does not retain backup sets.', example='NONE', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-**************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDBClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model DeleteDBClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDBClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteDBCluster  DeleteDBClusterRequest
  * @return DeleteDBClusterResponse
 */
async function deleteDBCluster(request: DeleteDBClusterRequest): DeleteDBClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDBCluster', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDBClusterEndpointRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-******************', position='Query'),
  DBEndpointId: string(name='DBEndpointId', description='The ID of the custom cluster endpoint.

This parameter is required.', example='pe-******************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDBClusterEndpointResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CD3FA5F3-FAF3-44CA-AFFF-BAF869******'),
}

model DeleteDBClusterEndpointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDBClusterEndpointResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteDBClusterEndpoint  DeleteDBClusterEndpointRequest
  * @return DeleteDBClusterEndpointResponse
 */
async function deleteDBClusterEndpoint(request: DeleteDBClusterEndpointRequest): DeleteDBClusterEndpointResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDBClusterEndpoint', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDBEndpointAddressRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of all clusters that belong to your account, such as the cluster ID.

This parameter is required.', example='pc-************', position='Query'),
  DBEndpointId: string(name='DBEndpointId', description='The ID of the endpoint.

>  You can call the [DescribeDBClusterEndpoints](https://help.aliyun.com/document_detail/98205.html) operation to query the endpoints of a specified PolarDB cluster.

This parameter is required.', example='pe-***************', position='Query'),
  netType: string(name='NetType', description='The network type of the endpoint. Set the value to **Public** (public network).

This parameter is required.', example='Public', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDBEndpointAddressResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model DeleteDBEndpointAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDBEndpointAddressResponseBody(name='body'),
}

/**
  * @description > *   You can delete a public-facing or classic network endpoint of the primary endpoint, the default cluster endpoint, or a custom cluster endpoint.
  * > *   Classic network endpoints are supported only on the China site (aliyun.com). Therefore, you do not need to delete classic network endpoints on the International site (alibabacloud.com).
  * @param request  the request parameters of DeleteDBEndpointAddress  DeleteDBEndpointAddressRequest
  * @return DeleteDBEndpointAddressResponse
 */
async function deleteDBEndpointAddress(request: DeleteDBEndpointAddressRequest): DeleteDBEndpointAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDBEndpointAddress', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDBLinkRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the source cluster where a database link is to be deleted.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/173433.html) operation to query PolarDB clusters.

This parameter is required.', example='pc-**************', position='Query'),
  DBLinkName: string(name='DBLinkName', description='The name of the database link to be deleted.

This parameter is required.', example='dblink_test', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDBLinkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F9F1CB1A-B1D5-4EF5-A53A-************'),
}

model DeleteDBLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDBLinkResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteDBLink  DeleteDBLinkRequest
  * @return DeleteDBLinkResponse
 */
async function deleteDBLink(request: DeleteDBLinkRequest): DeleteDBLinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDBLink', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDBNodesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a42***********', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-**************', position='Query'),
  DBNodeId: [ string ](name='DBNodeId', description='The IDs of the nodes.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/185342.html) operation to query the details of all clusters that belong to your Alibaba Cloud account, such as the cluster ID.

This parameter is required.', example='pi-************', position='Query'),
  DBNodeType?: string(name='DBNodeType', description='The node type. Valid values:

*   RO
*   STANDBY
*   DLNode

Enumerated values:

*   DLNode: AI node
*   STANDBY: standby node
*   RO: read-only node', example='RO', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDBNodesResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-**************'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2035638*******'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6566B2E6-3157-4B57-A693-AFB751******'),
}

model DeleteDBNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDBNodesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteDBNodes  DeleteDBNodesRequest
  * @return DeleteDBNodesResponse
 */
async function deleteDBNodes(request: DeleteDBNodesRequest): DeleteDBNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDBNodes', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDatabaseRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-*************', position='Query'),
  DBName: string(name='DBName', description='The name of the database.

This parameter is required.', example='testdb', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDatabaseResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model DeleteDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDatabaseResponseBody(name='body'),
}

/**
  * @description >- The cluster must be in the Running state and unlocked. Otherwise, the specified database cannot be deleted.
  * >- The delete operation is performed in an asynchronous manner. A long period of time may be required to delete a large database. A success response for this operation only indicates that the request to delete the database is sent. You must query the database to check whether the database is deleted.
  * @param request  the request parameters of DeleteDatabase  DeleteDatabaseRequest
  * @return DeleteDatabaseResponse
 */
async function deleteDatabase(request: DeleteDatabaseRequest): DeleteDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDatabase', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGlobalDatabaseNetworkRequest {
  regionId?: string(name='RegionId', position='Host'),
  GDNId: string(name='GDNId', description='The ID of the GDN.

This parameter is required.', example='gdn-bp1fttxsrmv*****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DeleteGlobalDatabaseNetworkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C61892A4-0850-4516-9E26-44D96C1782DE'),
}

model DeleteGlobalDatabaseNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGlobalDatabaseNetworkResponseBody(name='body'),
}

/**
  * @description >  You can delete a GDN only when the GDN includes only a primary cluster.
  * @param request  the request parameters of DeleteGlobalDatabaseNetwork  DeleteGlobalDatabaseNetworkRequest
  * @return DeleteGlobalDatabaseNetworkResponse
 */
async function deleteGlobalDatabaseNetwork(request: DeleteGlobalDatabaseNetworkRequest): DeleteGlobalDatabaseNetworkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGlobalDatabaseNetwork', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGlobalSecurityIPGroupRequest {
  globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name of the IP whitelist template must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or digit.
*   The name must be 2 to 120 characters in length.', example='test_123', position='Query'),
  globalSecurityGroupId: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.

This parameter is required.', example='g-zsldxfiwjmti0kcm****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DeleteGlobalSecurityIPGroupResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      DBInstances?: [ string ](name='DBInstances', description='The clusters that are associated with the IP address whitelist template.'),
      gIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Multiple IP addresses are separated by commas (,). You can create up to 1,000 IP addresses or CIDR blocks for all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the global IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the global IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroup', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model DeleteGlobalSecurityIPGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGlobalSecurityIPGroupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteGlobalSecurityIPGroup  DeleteGlobalSecurityIPGroupRequest
  * @return DeleteGlobalSecurityIPGroupResponse
 */
async function deleteGlobalSecurityIPGroup(request: DeleteGlobalSecurityIPGroupRequest): DeleteGlobalSecurityIPGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGlobalSecurityIPGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMaskingRulesRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pc-*****************', position='Query'),
  interfaceVersion?: string(name='InterfaceVersion', description='Deletes data masking or encryption rules. Valid values:

v1: deletes data masking rules. v2: deletes data encryption rules.', example='v1', position='Query'),
  ruleNameList: string(name='RuleNameList', description='The name of the masking rule. You can specify multiple masking rules at a time. Separate the masking rules with commas (,).

> You can call the [DescribeMaskingRules](https://help.aliyun.com/document_detail/212573.html) operation to query details of all the masking rules for a specified cluster, such as the names of the masking rules.

This parameter is required.', example='testrule', position='Query'),
}

model DeleteMaskingRulesResponseBody = {
  message?: string(name='Message', description='The message that is returned for the request.

> If the request is successful, `Successful` is returned. If the request fails, an error message such as an error code is returned.', example='Successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2BCEE25B-797C-426B-BA7B-D28CCF******'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid value:

*   **true**
*   **false**', example='true'),
}

model DeleteMaskingRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMaskingRulesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMaskingRules  DeleteMaskingRulesRequest
  * @return DeleteMaskingRulesResponse
 */
async function deleteMaskingRules(request: DeleteMaskingRulesRequest): DeleteMaskingRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMaskingRules', 'POST', '/', 'json', false, 'json', request);
}

model DeleteParameterGroupRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  parameterGroupId: string(name='ParameterGroupId', description='The parameter template ID.

 
>  You can call the [DescribeParameterGroups](https://help.aliyun.com/document_detail/207178.html) operation to query the parameter template ID.

This parameter is required.', example='pcpg-**************', position='Query'),
  regionId: string(name='RegionId', description='The region ID.
 
>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query available regions.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteParameterGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F7195E7-5F74-479D-AF59-1B4BF9******'),
}

model DeleteParameterGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteParameterGroupResponseBody(name='body'),
}

/**
  * @description You can use parameter templates to manage multiple parameters at a time and quickly apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](https://help.aliyun.com/document_detail/207009.html).
  * >  When you delete a parameter template, the parameter settings that are applied to PolarDB clusters are not affected.
  * @param request  the request parameters of DeleteParameterGroup  DeleteParameterGroupRequest
  * @return DeleteParameterGroupResponse
 */
async function deleteParameterGroup(request: DeleteParameterGroupRequest): DeleteParameterGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteParameterGroup', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAITaskStatusRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-xxxxxxxxxx', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeAITaskStatusResponseBody = {
  accountName?: string(name='AccountName', description='The name of the database account that is used to connect to the AI nodes in the cluster.', example='testacc'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-xxxxxxxxxx'),
  requestId?: string(name='RequestId', description='The request ID.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
  status?: string(name='Status', description='The status of the PolarDB for AI feature. Valid values:

*   **1**: enabled.
*   **2**: disabled.', example='1'),
  statusName?: string(name='StatusName', description='The description of the status of the PolarDB for AI feature.', example='Closed State'),
}

model DescribeAITaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAITaskStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeAITaskStatus  DescribeAITaskStatusRequest
  * @return DescribeAITaskStatusResponse
 */
async function describeAITaskStatus(request: DescribeAITaskStatusRequest): DescribeAITaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAITaskStatus', 'GET', '/', 'json', false, 'json', request);
}

model DescribeAccountsRequest {
  accountName?: string(name='AccountName', description='The name of the account.', example='test_acc', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-***************', position='Query'),
  nodeType?: string(name='NodeType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. Set this parameter to an integer that is larger than 0. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeAccountsResponseBody = {
  accounts?: [ 
    {
      accountDescription?: string(name='AccountDescription', description='The description of the account.', example='test'),
      accountLockState?: string(name='AccountLockState', description='The locking state of the account. Valid values:

*   **UnLock**
*   **Lock**', example='UnLock'),
      accountName?: string(name='AccountName', description='The name of the account.', example='test_acc'),
      accountPasswordValidTime?: string(name='AccountPasswordValidTime', description='The validity period of the password.', example='undefined'),
      accountStatus?: string(name='AccountStatus', description='The state of the account. Valid values:

*   **Creating**: The account is being created.
*   **Available**: The account is available.
*   **Deleting**: The account is being deleted', example='Available'),
      accountType?: string(name='AccountType', description='The type of the account. Valid values:

*   **Normal**: standard account.
*   **Super**: privileged account.
*   **ReadOnly**: global read-only account.', example='Normal'),
      databasePrivileges?: [ 
        {
          accountPrivilege?: string(name='AccountPrivilege', description='The permissions that the account is granted on the database. Valid values:', example='ReadOnly'),
          DBName?: string(name='DBName', description='The name of the database.', example='DBtest'),
        }
      ](name='DatabasePrivileges', description='The list of database permissions that are granted to the account.'),
    }
  ](name='Accounts', description='The details of the account.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page returned.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='155462B9-205F-4FFC-BB43-4855FE******'),
}

model DescribeAccountsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAccountsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeAccounts  DescribeAccountsRequest
  * @return DescribeAccountsResponse
 */
async function describeAccounts(request: DescribeAccountsRequest): DescribeAccountsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAccounts', 'POST', '/', 'json', false, 'json', request);
}

model DescribeActivationCodeDetailsRequest {
  activationCodeId?: int32(name='ActivationCodeId', description='The ID of the activation code.', example='123', position='Query'),
  aliyunOrderId: string(name='AliyunOrderId', description='The Alibaba Cloud order ID (including the virtual order ID).

This parameter is required.', example='2233****445566', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeActivationCodeDetailsResponseBody = {
  activateAt?: string(name='ActivateAt', description='The time when the activation code takes effect.', example='2024-10-16 16:46:20'),
  certContentB64?: string(name='CertContentB64', description='The activation code in the base64 format. The activation code is decoded and stored into a file named license.lic. PolarDB can access and read the license.lic file upon startup to validate the license or perform related operations.', example='AAEAA******AAA='),
  description?: string(name='Description', description='The description of the activation code.', example='testCode'),
  expireAt?: string(name='ExpireAt', description='The time when the activation code expires.', example='2054-10-09 16:46:20'),
  gmtCreated?: string(name='GmtCreated', description='The time when the activation code was created.', example='2024-10-16 16:46:20'),
  gmtModified?: string(name='GmtModified', description='The time when the activation code was last updated.', example='2024-10-16 16:46:20'),
  id?: int32(name='Id', description='The ID of the activation code.', example='123'),
  macAddress?: string(name='MacAddress', description='The MAC address.', example='12:34:56:78:98:00'),
  name?: string(name='Name', description='The name of the activation code.', example='testName'),
  requestId?: string(name='RequestId', description='The request ID.', example='F2A9EFA7-915F-4572-8299-85A307******'),
  systemIdentifier?: string(name='SystemIdentifier', description='The system identifier of the database.', example='1234567890123456'),
}

model DescribeActivationCodeDetailsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeActivationCodeDetailsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeActivationCodeDetails  DescribeActivationCodeDetailsRequest
  * @return DescribeActivationCodeDetailsResponse
 */
async function describeActivationCodeDetails(request: DescribeActivationCodeDetailsRequest): DescribeActivationCodeDetailsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeActivationCodeDetails', 'POST', '/', 'json', false, 'json', request);
}

model DescribeActivationCodesRequest {
  aliyunOrderId: string(name='AliyunOrderId', description='The ID of the Alibaba Cloud order. The value can be the ID of a virtual order.

This parameter is required.', example='2233****445566', position='Query'),
  macAddress?: string(name='MacAddress', example='aa:bb:cc:dd:ee:ff', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30', minimum=1, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  systemIdentifier?: string(name='SystemIdentifier', example='3312548696141831911', position='Query'),
}

model DescribeActivationCodesResponseBody = {
  items?: [ 
    {
      activateAt?: string(name='ActivateAt', description='The time when the activation code takes effect.', example='2024-10-16 16:46:20'),
      description?: string(name='Description', description='The description of the activation code.', example='testCode'),
      expireAt?: string(name='ExpireAt', description='The time when the activation code expires.', example='2054-10-16 16:46:20'),
      gmtCreated?: string(name='GmtCreated', description='The time when the activation code was generated.', example='2024-10-16 16:46:20'),
      gmtModified?: string(name='GmtModified', description='The time when the activation code was updated.', example='2024-10-16 16:46:20'),
      id?: int32(name='Id', description='The activation code ID.', example='123'),
      macAddress?: string(name='MacAddress', description='The media access control (MAC) address used in the generation of the activation code.', example='12:34:56:78:98:00'),
      name?: string(name='Name', description='The name of the activation code.', example='testName'),
      systemIdentifier?: string(name='SystemIdentifier', description='The unique identifier of the database.', example='1234567890123456'),
    }
  ](name='Items', description='The queried activation codes.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of entries returned on the current page.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='65D7ACE6-4A61-4B6E-B357-8CB24A******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of entries returned.', example='1'),
}

model DescribeActivationCodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeActivationCodesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeActivationCodes  DescribeActivationCodesRequest
  * @return DescribeActivationCodesResponse
 */
async function describeActivationCodes(request: DescribeActivationCodesRequest): DescribeActivationCodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeActivationCodes', 'POST', '/', 'json', false, 'json', request);
}

model DescribeActiveOperationTasksRequest {
  allowCancel?: long(name='AllowCancel', example='-1', position='Query'),
  allowChange?: long(name='AllowChange', example='-1', position='Query'),
  changeLevel?: string(name='ChangeLevel', example='all', position='Query'),
  DBClusterId?: string(name='DBClusterId', example='pc-3ns***********d5d', position='Query'),
  DBType?: string(name='DBType', example='MySQL', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. The value must be an integer that is greater than 0. Default value: 1.', example='1', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values:

*   **30** (default)
*   **50**
*   **100**', example='30', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', description='This parameter is required.', example='cn-beijing', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  status?: long(name='Status', example='-1', position='Query'),
  taskType?: string(name='TaskType', example='DatabaseProxyUpgrading', position='Query'),
}

model DescribeActiveOperationTasksResponseBody = {
  items?: [ 
    {
      allowCancel?: long(name='AllowCancel', example='0'),
      allowChange?: long(name='AllowChange', example='0'),
      changeLevel?: string(name='ChangeLevel', example='S0'),
      changeLevelEn?: string(name='ChangeLevelEn', example='System maintenance'),
      changeLevelZh?: string(name='ChangeLevelZh'),
      createdTime?: string(name='CreatedTime', example='2020-06-09T22:00:42Z'),
      currentAVZ?: string(name='CurrentAVZ', example='cn-beijing-h'),
      DBClusterId?: string(name='DBClusterId', example='pc-*****************'),
      DBNodeIds?: [ string ](name='DBNodeIds'),
      DBType?: string(name='DBType', example='MySQL'),
      DBVersion?: string(name='DBVersion', example='8.0'),
      deadline?: string(name='Deadline', example='2020-06-11T15:59:59Z'),
      impact?: string(name='Impact', example='TransientDisconnection'),
      impactEn?: string(name='ImpactEn', example='Transient instance disconnection'),
      impactZh?: string(name='ImpactZh'),
      insComment?: string(name='InsComment', example='test'),
      modifiedTime?: string(name='ModifiedTime', example='2020-06-09T22:00:42Z'),
      prepareInterval?: string(name='PrepareInterval', example='04:00:00'),
      region?: string(name='Region', example='cn-hangzhou'),
      resultInfo?: string(name='ResultInfo', example='userCancel'),
      startTime?: string(name='StartTime', example='2023-05-19T02:48:17Z'),
      status?: int32(name='Status', example='3'),
      switchTime?: string(name='SwitchTime', example='2020-06-09T22:00:00Z'),
      taskId?: int32(name='TaskId', example='107202351'),
      taskParams?: string(name='TaskParams', example='{
      "Action": "UpgradeDBInstance"
}'),
      taskType?: string(name='TaskType', example='DatabaseSoftwareUpgrading'),
      taskTypeEn?: string(name='TaskTypeEn', example='Minor version update'),
      taskTypeZh?: string(name='TaskTypeZh'),
    }
  ](name='Items'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  requestId?: string(name='RequestId', example='FAF88508-D5F8-52B1-8824-262601769E31'),
  totalRecordCount?: int32(name='TotalRecordCount', example='1'),
}

model DescribeActiveOperationTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeActiveOperationTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeActiveOperationTasks  DescribeActiveOperationTasksRequest
  * @return DescribeActiveOperationTasksResponse
 */
async function describeActiveOperationTasks(request: DescribeActiveOperationTasksRequest): DescribeActiveOperationTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeActiveOperationTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAutoRenewAttributeRequest {
  DBClusterIds?: string(name='DBClusterIds', description='The ID of the cluster. If you need to specify multiple cluster IDs, separate the cluster IDs with commas (,).', example='pc-****************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value must be an integer that is greater than 0. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 30, 50, and 100. Default value: 30.', example='30', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.

>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the region ID details.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-re*********', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeAutoRenewAttributeResponseBody = {
  items?: {
    autoRenewAttribute?: [ 
    {
      autoRenewEnabled?: boolean(name='AutoRenewEnabled', description='Indicates whether the auto-renewal feature is enabled. Valid values:

*   true: enabled
*   false: disabled', example='true'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-*****************'),
      duration?: int32(name='Duration', description='The renewal duration.', example='4'),
      periodUnit?: string(name='PeriodUnit', description='The unit of the duration. Valid values:

*   Year
*   Month', example='Month'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      renewalStatus?: string(name='RenewalStatus', description='The renewal status. Valid values:

*   AutoRenewal: The cluster is automatically renewed.
*   Normal: The cluster is manually renewed. The system sends a text message to remind you before the cluster expires.
*   NotRenewal: The cluster is not renewed. The system does not send a reminder for expiration but only sends a text message three days before the cluster expires to remind you that the cluster is not renewed.', example='AutoRenewal'),
    }
  ](name='AutoRenewAttribute')
  }(name='Items', description='The renewal information about the clusters.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page returned.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The total number of pages returned.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='65D7ACE6-4A61-4B6E-B357-8CB24A******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of entries.', example='1'),
}

model DescribeAutoRenewAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAutoRenewAttributeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeAutoRenewAttribute  DescribeAutoRenewAttributeRequest
  * @return DescribeAutoRenewAttributeResponse
 */
async function describeAutoRenewAttribute(request: DescribeAutoRenewAttributeRequest): DescribeAutoRenewAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoRenewAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupLogsRequest {
  backupRegion?: string(name='BackupRegion', description='The region for the backup data.', example='cn-hangzhou', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-**************', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-02-12T15:00Z', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. The value must be an integer that is larger than 0. Default value: **1**.', example='1', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30', minimum=30, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-02-01T15:00Z', position='Query'),
}

model DescribeBackupLogsResponseBody = {
  items?: {
    backupLog?: [ 
    {
      backupLogEndTime?: string(name='BackupLogEndTime', description='The time when the backup task ended. The time follows the ISO 8601 standard in the `YYYY-MM-DD\\"T\\"HH:mm:ssZ` format. The time is displayed in UTC.', example='2020-02-12T03:55:31Z'),
      backupLogId?: string(name='BackupLogId', description='The ID of the backup log.', example='1111111111'),
      backupLogName?: string(name='BackupLogName', description='The name of the backup log.', example='ib_logfile1'),
      backupLogSize?: string(name='BackupLogSize', description='The size of the backup log. Unit: bytes.', example='1073741824'),
      backupLogStartTime?: string(name='BackupLogStartTime', description='The time when the backup task started. The time follows the ISO 8601 standard in the `YYYY-MM-DD\\"T\\"HH:mm:ssZ` format. The time is displayed in UTC.', example='2020-02-12T03:54:43Z'),
      downloadLink?: string(name='DownloadLink', description='The public URL used to download the backup log.', example='http://***********.oss-cn-hangzhou.aliyuncs.com'),
      intranetDownloadLink?: string(name='IntranetDownloadLink', description='The internal URL used to download the backup log.', example='http://***********.oss-cn-hangzhou-internal.aliyuncs.com'),
      linkExpiredTime?: string(name='LinkExpiredTime', description='The time when the download URL expires.', example='2020-02-14T08:40:50Z'),
    }
  ](name='BackupLog')
  }(name='Items', description='The details of the backup logs.'),
  pageNumber?: string(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageRecordCount?: string(name='PageRecordCount', description='The number of entries returned per page.', example='2'),
  requestId?: string(name='RequestId', description='The request ID.', example='ADAC63DB-0691-4ECE-949A-FAEA68******'),
  totalRecordCount?: string(name='TotalRecordCount', description='The total number of returned entries.', example='2'),
}

model DescribeBackupLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupLogsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeBackupLogs  DescribeBackupLogsRequest
  * @return DescribeBackupLogsResponse
 */
async function describeBackupLogs(request: DescribeBackupLogsRequest): DescribeBackupLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupPolicyRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/2319131.html) operation to query the information about all AnalyticDB for MySQL clusters within a region, including cluster IDs.

This parameter is required.', example='pc-*************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeBackupPolicyResponseBody = {
  backupFrequency?: string(name='BackupFrequency', description='The backup frequency. Default value: Normal. Valid values:

*   **Normal**: standard backup. The system backs up data once a day.
*   **2/24H**: enhanced backup. The system backs up data every 2 hours.
*   **3/24H**: enhanced backup. The system backs up data every 3 hours.
*   **4/24H**: enhanced backup. The system backs up data every 4 hours.

> - If enhanced backup is enabled, all backups are retained for 24 hours. Backups are automatically deleted when the retention period ends. However, the system permanently retains the first backup that is created after 00:00 every day.
>-  If enhanced backup is enabled, **PreferredBackupPeriod** is automatically set to all days in a week (from Monday to Sunday).', example='Normal'),
  backupRetentionPolicyOnClusterDeletion?: string(name='BackupRetentionPolicyOnClusterDeletion', description='Indicates whether backups are retained when you delete a cluster. Valid values:

*   **ALL**: permanently retains all backups.
*   **LATEST**: permanently retains the most recent backup.
*   **NONE**: does not retain backups.', example='NONE'),
  dataLevel1BackupFrequency?: string(name='DataLevel1BackupFrequency', description='The backup frequency of level-1 backups. Default value: Normal. Valid values:

*   **Normal**: standard backup. The system backs up data once a day.
*   **2/24H**: frequent backup. The system backs up data every 2 hours.
*   **3/24H**: frequent backup. The system backs up data every 3 hours.
*   **4/24H**: frequent backup. The system backs up data every 4 hours.

>- This parameter is not supported for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is unavailable if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Normal'),
  dataLevel1BackupPeriod?: string(name='DataLevel1BackupPeriod', description='The backup cycle of level-1 backups. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is not supported for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is unavailable if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Monday,Tuesday'),
  dataLevel1BackupRetentionPeriod?: string(name='DataLevel1BackupRetentionPeriod', description='The retention period of level-1 backups. Valid values: 3 to 14. Unit: day.', example='7'),
  dataLevel1BackupTime?: string(name='DataLevel1BackupTime', description='The period of time during which automatic backup is performed. The value must be in the `hh:mmZ-hh:mmZ` format. The time must be in UTC. The start time and the end time must be on the hour and must have an interval of 1 hour. Example: `14:00Z-15:00Z`.

>- This parameter is not supported for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is unavailable if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='15:00Z-16:00Z'),
  dataLevel2BackupAnotherRegionRegion?: string(name='DataLevel2BackupAnotherRegionRegion', description='The region where the cross-region level-2 backup is stored. For information about regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='cn-hangzhou'),
  dataLevel2BackupAnotherRegionRetentionPeriod?: string(name='DataLevel2BackupAnotherRegionRetentionPeriod', description='The retention period of cross-region level-2 backups. Valid values:

*   **0**: The cross-region level-2 backup feature is disabled.
*   **30 to 7300**: Cross-region level-2 backups are retained for 30 to 7,300 days.
*   **1**: Cross-region level-2 backups are retained for a long period of time.

>  The default value of the parameter is **0**.', example='30'),
  dataLevel2BackupPeriod?: string(name='DataLevel2BackupPeriod', description='The backup cycle of level-2 backups. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is not supported for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is unavailable if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Monday,Tuesday'),
  dataLevel2BackupRetentionPeriod?: string(name='DataLevel2BackupRetentionPeriod', description='The retention period of level-2 backups. Valid values:

*   0: The level-2 backup feature is disabled.
*   30 to 7300: Level-2 backups are retained for 30 to 7,300 days.
*   \\-1: Level-2 backups are retained for a long period of time.

>  The default value of this parameter is **0**.', example='0'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod', description='The backup cycle. Valid values:

*   Monday
*   Tuesday
*   Wednesday
*   Thursday
*   Friday
*   Saturday
*   Sunday', example='Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday'),
  preferredBackupTime?: string(name='PreferredBackupTime', description='The time period when automatic backups are performed. The format is `HH:mmZ-HH:mmZ`. The time is displayed in UTC.', example='07:00Z-08:00Z'),
  preferredNextBackupTime?: string(name='PreferredNextBackupTime', description='The time when the next automatic backup will be performed. The format is `YYYY-MM-DDThh:mmZ`. The time is displayed in UTC.', example='2020-11-16T07:30Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EADFCE0F-9FB5-4685-B395-1440B******'),
}

model DescribeBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupPolicyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeBackupPolicy  DescribeBackupPolicyRequest
  * @return DescribeBackupPolicyResponse
 */
async function describeBackupPolicy(request: DescribeBackupPolicyRequest): DescribeBackupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupPolicy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupTasksRequest {
  backupJobId?: string(name='BackupJobId', description='The ID of the backup task.', example='11111111', position='Query'),
  backupMode?: string(name='BackupMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Manual', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-***************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeBackupTasksResponseBody = {
  items?: {
    backupJob?: [ 
    {
      backupJobId?: string(name='BackupJobId', description='The ID of the backup task.', example='11111111'),
      backupProgressStatus?: string(name='BackupProgressStatus', description='The state of the backup task. Valid values:

*   **NoStart**
*   **Preparing**
*   **Waiting**
*   **Uploading**
*   **Checking**
*   **Finished**', example='NoStart'),
      jobMode?: string(name='JobMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Automated'),
      process?: string(name='Process', description='The progress of the backup task in percentage.', example='0'),
      startTime?: string(name='StartTime', description='The time when the backup task started. The time follows the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.', example='2020-08-08T07:24:01Z'),
      taskAction?: string(name='TaskAction', description='The type of the backup task. Valid values:

*   **TempBackupTask**: The backup task is an adhoc backup task.
*   **NormalBackupTask**: The backup task is a common backup task.', example='NormalBackupTask'),
    }
  ](name='BackupJob')
  }(name='Items', description='The details of the backup task.'),
  requestId?: string(name='RequestId', description='The request ID.', example='FA8C1EF1-E3D4-44D7-B809-823187******'),
}

model DescribeBackupTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeBackupTasks  DescribeBackupTasksRequest
  * @return DescribeBackupTasksResponse
 */
async function describeBackupTasks(request: DescribeBackupTasksRequest): DescribeBackupTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupsRequest {
  backupId?: string(name='BackupId', description='The ID of the backup set.', example='11111111', position='Query'),
  backupMode?: string(name='BackupMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Automated', position='Query'),
  backupRegion?: string(name='BackupRegion', description='The region where the cross-region data backup file of the instance is stored.

> This parameter is valid only for PolarDB for MySQL clusters.', example='cn-hangzhou', position='Query'),
  backupStatus?: string(name='BackupStatus', description='The status of the backup set. Valid values:

*   **Success**
*   **Failed**', example='Success', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-****************', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. Specify the time in the `YYYY-MM-DDThh:mmZ` format. The time must be in UTC. The end time must be later than the start time.

This parameter is required.', example='2020-11-16T00:00Z', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value must be a positive integer that does not exceed the maximum value of the INTEGER data type. Default value: **1**.', example='1', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30', minimum=30, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-11-14T00:00Z', position='Query'),
}

model DescribeBackupsResponseBody = {
  items?: {
    backup?: [ 
    {
      backupEndTime?: string(name='BackupEndTime', description='The end time of the backup task. The time is displayed in UTC.', example='2020-11-15T07:30:20Z'),
      backupId?: string(name='BackupId', description='The ID of the backup set.', example='61*******'),
      backupMethod?: string(name='BackupMethod', description='The backup method. Only **Snapshot** may be returned.', example='Snapshot'),
      backupMode?: string(name='BackupMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Automated'),
      backupSetSize?: string(name='BackupSetSize', description='The size of the backup set. Unit: bytes.

> After you delete the target snapshot backups, the storage space that is consumed by the backups is released. The released storage space is smaller than the size of the backup file, because the snapshots share specific data blocks. For more information, see [FAQ about backup](https://help.aliyun.com/document_detail/164881.html).', example='4639948800'),
      backupStartTime?: string(name='BackupStartTime', description='The start time of the backup task. The time is displayed in UTC. Unit: seconds.', example='2020-11-15T07:30:05Z'),
      backupStatus?: string(name='BackupStatus', description='The status of the backup set. Valid values:

*   **Success**
*   **Failed**', example='Success'),
      backupType?: string(name='BackupType', description='The type of the backup. Only **FullBackup** may be returned.', example='FullBackup'),
      backupsLevel?: string(name='BackupsLevel', description='The level of the backup set. Valid values:

*   **Level-1**
*   **Level-2**', example='Level-1'),
      consistentTime?: string(name='ConsistentTime', description='The snapshot checkpoint time. The value follows the Unix time format. Unit: seconds.', example='1605425407'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-****************'),
      expectExpireTime?: string(name='ExpectExpireTime', description='The expected expiration time of the backup set (This parameter is supported only for clusters for which sparse backup is enabled).', example='2022-10-24T08:13:23Z'),
      expectExpireType?: string(name='ExpectExpireType', description='The expected expiration type of the backup set (This parameter is supported only for instances that are enabled with sparse backup).

Valid values:

*   NEVER

    <!-- -->

    <!-- -->

    <!-- -->

*   EXPIRED

    <!-- -->

    <!-- -->

    <!-- -->

*   DELAY

    <!-- -->

    <!-- -->

    <!-- -->', example='EXPIRED'),
      isAvail?: string(name='IsAvail', description='Indicates whether the backup set is available. Valid values:

*   **0**: The backup set is unavailable.
*   **1**: The backup set is available.', example='0'),
    }
  ](name='Backup')
  }(name='Items', description='The queried backup sets.'),
  pageNumber?: string(name='PageNumber', description='The page number.', example='1'),
  pageRecordCount?: string(name='PageRecordCount', description='The number of entries per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='24A1990B-4F6E-482B-B8CB-75C612******'),
  totalLevel2BackupSize?: string(name='TotalLevel2BackupSize', example='4639948800'),
  totalRecordCount?: string(name='TotalRecordCount', description='The total number of returned entries.', example='1'),
}

model DescribeBackupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeBackups  DescribeBackupsRequest
  * @return DescribeBackupsResponse
 */
async function describeBackups(request: DescribeBackupsRequest): DescribeBackupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCharacterSetNameRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can only query character sets that PolarDB for MySQL clusters support. If you enter the ID of a PolarDB for PostgreSQL or PolarDB for Oracle cluster, the returned value of the `CharacterSetNameItems` parameter is an empty string.', example='pc-****************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the cluster.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query available regions.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeCharacterSetNameResponseBody = {
  characterSetNameItems?: {
    characterSetName?: [ string ](name='CharacterSetName')
  }(name='CharacterSetNameItems', description='The character sets that are supported.'),
  engine?: string(name='Engine', description='The type of the database engine.', example='POLARDB'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='34458CD3-33E0-4624-BFEF-840C15******'),
}

model DescribeCharacterSetNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCharacterSetNameResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeCharacterSetName  DescribeCharacterSetNameRequest
  * @return DescribeCharacterSetNameResponse
 */
async function describeCharacterSetName(request: DescribeCharacterSetNameRequest): DescribeCharacterSetNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCharacterSetName', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClassListRequest {
  commodityCode: string(name='CommodityCode', description='The code of the commodity. Valid values:

*   polardb_sub: the subscription cluster in regions in the Chinese mainland
*   polardb_sub _intl: the subscription cluster in regions outside the Chinese mainland
*   polardb_payg: the pay-as-you-go cluster in regions in the Chinese mainland
*   polardb_payg_intl: the pay-as-you-go cluster in regions outside the Chinese mainland
*   polardb_sub_jushita: the subscription cluster for CloudTmall
*   polardb_payg_jushita: the pay-as-you-go cluster for CloudTmall
*   polardb_sub_cainiao: the subscription cluster for Cainiao
*   polardb_payg_cainiao: the pay-as-you-go cluster for Cainiao

> *   If you use an Alibaba Cloud account on the China site, you can view only the codes of the commodities that are available in the Chinese mainland.
>*   If you are using an Alibaba Cloud international account, you can view only the codes of the commodities that are available outside the Chinese mainland.
>*   If you use a CloudTmall account, you can view only the codes of the commodities that are available in CloudTmall.
>*   If you use a Cainiao account, you can view only the codes of the commodities that are available in Cainiao.

This parameter is required.', example='polardb_sub', position='Query'),
  masterHa?: string(name='MasterHa', description='The number of nodes. Valid values:

*   single: Standalone Edition.
*   cluster: Cluster Edition.
*   all: both Standalone Edition and Cluster Edition.', example='cluster', position='Query'),
  orderType?: string(name='OrderType', description='The type of the order. Valid values:

*   BUY: The order is used to purchase a cluster.
*   UPGRADE: The order is used to change the specifications of a cluster.
*   RENEW: The order is used to renew a cluster.
*   CONVERT: The order is used to change the billing method of a cluster.', example='BUY', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeClassListResponseBody = {
  items?: [ 
    {
      classCode?: string(name='ClassCode', description='The specifications of the cluster.', example='polar.mysql.x4.medium'),
      classGroup?: string(name='ClassGroup', description='The instance family of the cluster. Valid values:

*   Exclusive package: dedicated
*   Exclusive physical machine: dedicated host
*   Beginner: starter
*   Historical specifications: historical', example='Exclusive package'),
      classTypeLevel?: string(name='ClassTypeLevel', description='The specification type of the cluster.', example='enterprise'),
      cpu?: string(name='Cpu', description='The number of vCPU cores. Unit: cores.', example='8'),
      essdMaxStorageCapacity?: string(name='EssdMaxStorageCapacity', description='The maximum ESSD storage capacity. Unit: TB.', example='64'),
      maxConnections?: string(name='MaxConnections', description='The maximum number of concurrent connections in the cluster.', example='8000'),
      maxIOPS?: string(name='MaxIOPS', description='The maximum IOPS. Unit: operations per second.', example='32000'),
      maxStorageCapacity?: string(name='MaxStorageCapacity', description='The maximum storage capacity. Unit: TB.', example='20'),
      memoryClass?: string(name='MemoryClass', description='The memory size. Unit: GB.', example='32'),
      pl1MaxIOPS?: string(name='Pl1MaxIOPS', description='The maximum IOPS of an enhanced SSD (ESSD) of performance level 1 (PL1). Unit: operations per second.', example='50000'),
      pl2MaxIOPS?: string(name='Pl2MaxIOPS', description='The maximum IOPS of an ESSD of performance level 2 (PL2). Unit: operations per second.', example='100000'),
      pl3MaxIOPS?: string(name='Pl3MaxIOPS', description='The maximum IOPS of an ESSD of performance level 3 (PL3). Unit: operations per second.', example='1000000'),
      polarStoreMaxStorageCapacity?: string(name='PolarStoreMaxStorageCapacity', description='The maximum PSL4/PSL5 storage capacity. Unit: TB.', example='500'),
      psl4MaxIOPS?: string(name='Psl4MaxIOPS', description='The maximum Input/output operations per second (IOPS) for PolarStore Level 4 (PSL4). Unit: operations per second.', example='48000'),
      psl5MaxIOPS?: string(name='Psl5MaxIOPS', description='The maximum IOPS for PolarStore Level 5 (PSL5). Unit: operations per second.', example='96000'),
      referenceExtPrice?: string(name='ReferenceExtPrice', description='The additional price.

Unit: cents (USD).

>- If you set MasterHa to cluster or single, the value of ReferenceExtPrice is the same as the value of ReferencePrice.
>- If you set MasterHa to cluster or single, the value of ReferenceExtPrice is the price of the single-node cluster.', example='200000'),
      referencePrice?: string(name='ReferencePrice', description='The price.

Unit: cents (USD).

>- If you set CommodityCode to a commodity that uses the pay-as-you-go billing method, ReferencePrice indicates the hourly fee that you need to pay.
>- If you set CommodityCode to a commodity that uses the subscription billing method, ReferencePrice indicates the monthly fee that you need to pay.', example='200000'),
    }
  ](name='Items', description='The cluster specifications.'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='69A85BAF-1089-4CDF-A82F-0A140F******'),
}

model DescribeClassListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClassListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeClassList  DescribeClassListRequest
  * @return DescribeClassListResponse
 */
async function describeClassList(request: DescribeClassListRequest): DescribeClassListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClassList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClusterAccessWhitelistRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the PolarDB cluster.

This parameter is required.', example='pc-***************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBClusterAccessWhitelistResponseBody = {
  DBClusterSecurityGroups?: {
    DBClusterSecurityGroup?: [ 
    {
      securityGroupId?: string(name='SecurityGroupId', description='The ID of the ECS security group.', example='sg-bp**************'),
      securityGroupName?: string(name='SecurityGroupName', description='The name of the ECS security group.', example='vpc-********************'),
    }
  ](name='DBClusterSecurityGroup')
  }(name='DBClusterSecurityGroups', description='The Elastic Compute Service (ECS) security groups that are associated with the cluster.'),
  items?: {
    DBClusterIPArray?: [ 
    {
      DBClusterIPArrayAttribute?: string(name='DBClusterIPArrayAttribute', description='The attributes of the IP whitelist group. Set this parameter to **hidden** to hide the IP whitelist group in the console.

> *   The IP whitelist group that has appeared in the console cannot be hidden.
> *   This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='hidden'),
      DBClusterIPArrayName?: string(name='DBClusterIPArrayName', description='The name of the IP whitelist group. The group name must be 2 to 120 characters in length and consists of lowercase letters and digits. It must start with a letter, and end with a letter or a digit.

*   If the specified whitelist group name does not exist, the whitelist group is created.
*   If the specified whitelist group name exists, the whitelist group is modified.
*   If you do not specify this parameter, the default group is modified.

> *   You can create a maximum of 50 IP whitelist groups for a cluster.
>*   This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='default'),
      securityIps?: string(name='SecurityIps', description='The IP addresses or Classless Inter-Domain Routing (CIDR) blocks in the IP whitelist group. You can add 1,000 IP addresses or CIDR blocks to all the IP whitelist groups. Separate multiple IP addresses with commas (,). The following two formats are supported:

*   IP addresses. Example: 10.23.12.24.
*   CIDR blocks. Example: 10.23.12.24/24. 24 indicates the length of the prefix of the CIDR block. The length is the range of 1 to 32.

>  This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='11.***.***.***,11.***.***.***'),
    }
  ](name='DBClusterIPArray')
  }(name='Items', description='The details about the cluster.'),
  requestId?: string(name='RequestId', description='The request ID.', example='559E91A2-CDA3-4E9F-808B-29D738******'),
}

model DescribeDBClusterAccessWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterAccessWhitelistResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDBClusterAccessWhitelist  DescribeDBClusterAccessWhitelistRequest
  * @return DescribeDBClusterAccessWhitelistResponse
 */
async function describeDBClusterAccessWhitelist(request: DescribeDBClusterAccessWhitelistRequest): DescribeDBClusterAccessWhitelistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusterAccessWhitelist', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClusterAttributeRequest {
  DBClusterId: string(name='DBClusterId', description='Cluster ID.
> You can view detailed information about all clusters under your account, including the cluster ID, through the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) interface.

This parameter is required.', example='pc-*****************', position='Query'),
  describeType?: string(name='DescribeType', description='Whether to obtain information about AI-related nodes.', example='AI', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBClusterAttributeResponseBody = {
  aiCreatingTime?: string(name='AiCreatingTime', description='Start time for free AI activation', example='2024-03-13T01:20:28Z'),
  aiType?: string(name='AiType', description='Types of AI nodes. Values include:

- **SearchNode**: Search node.
- **DLNode**: AI node.', example='DLNode'),
  architecture?: string(name='Architecture', description='CPU architecture. Available options are:
- **X86**
- **ARM**', example='X86'),
  autoUpgradeMinorVersion?: string(name='AutoUpgradeMinorVersion'),
  blktagTotal?: long(name='BlktagTotal', description='Maximum number of blktags in the file system.', example='7,864,320'),
  blktagUsed?: long(name='BlktagUsed', description='Current blktag usage.', example='5,242,880'),
  burstingEnabled?: string(name='BurstingEnabled', example='false'),
  category?: string(name='Category', description='[Product Series](https://help.aliyun.com/document_detail/183258.html), with values as follows:
* **Normal**: Cluster Edition
* **Basic**: Single Node
* **Archive**: High Compression Engine (X-Engine)
* **NormalMultimaster**: Multi-Master Cluster Edition
* **SENormal**: Standard Edition

> * PolarDB PostgreSQL version 11 does not support single-node.
>* PolarDB MySQL versions 8.0 and 5.7, and PolarDB PostgreSQL version 14 support the Standard Edition.
>* PolarDB MySQL version 8.0 supports High Compression Engine (X-Engine) and Multi-Master Cluster Edition.', example='Normal'),
  compressStorageMode?: string(name='CompressStorageMode', description='Whether storage compression is enabled. Values are as follows:
- ON: Enabled
- OFF: Disabled', example='ON'),
  compressStorageUsed?: long(name='CompressStorageUsed', description='Compressed storage data size.
> This parameter is supported only when the cluster\\"s storage compression feature is enabled.', example='15529410560'),
  creationTime?: string(name='CreationTime', description='Cluster creation time.', example='2020-08-14T05:58:42Z'),
  DBClusterDescription?: string(name='DBClusterDescription', description='Cluster description.', example='test'),
  DBClusterId?: string(name='DBClusterId', description='Cluster ID.', example='pc-*****************'),
  DBClusterNetworkType?: string(name='DBClusterNetworkType', description='Network type of the cluster.', example='VPC'),
  DBClusterStatus?: string(name='DBClusterStatus', description='Cluster status. For the full list of values, refer to [Cluster Status Table](https://help.aliyun.com/document_detail/99286.html).', example='Running'),
  DBNodes?: [ 
    {
      addedCpuCores?: string(name='AddedCpuCores', description='Number of CPU cores for second-level elastic scaling.', example='6'),
      cpuCores?: string(name='CpuCores', description='Number of CPU cores for the node.', example='2'),
      creationTime?: string(name='CreationTime', description='Node creation time.', example='2020-03-23T21:35:43Z'),
      DBNodeClass?: string(name='DBNodeClass', description='Node specification.', example='polar.mysql.x4.large'),
      DBNodeDescription?: string(name='DBNodeDescription', example='test'),
      DBNodeId?: string(name='DBNodeId', description='Node ID.', example='pi-****************'),
      DBNodeRole?: string(name='DBNodeRole', description='Node role, with possible values as follows:

- **Writer**: Primary node.
- **Reader**: Read-only node.', example='Reader'),
      DBNodeStatus?: string(name='DBNodeStatus', description='Node status, with possible values as follows:
* **Creating**: Creating
* **Running**: Running
* **Deleting**: Deleting
* **Rebooting**: Rebooting
* **DBNodeCreating**: Adding node
* **DBNodeDeleting**: Removing node
* **ClassChanging**: Modifying node specification
* **NetAddressCreating**: Creating network connection
* **NetAddressDeleting**: Deleting network connection
* **NetAddressModifying**: Modifying network connection
* **MinorVersionUpgrading**: Upgrading minor version
* **Maintaining**: Instance maintenance
* **Switching**: Switching', example='Running'),
      failoverPriority?: int32(name='FailoverPriority', description='Failover priority. Each node has a failover priority, determining the likelihood of being elected as the primary node during a failover. A higher value indicates a higher priority.
Range: 1 to 15.', example='1'),
      hotReplicaMode?: string(name='HotReplicaMode', description='Whether hot standby is enabled. Possible values are:

- **ON**: Enabled
- **OFF**: Disabled', example='ON'),
      imciSwitch?: string(name='ImciSwitch', description='Whether columnar index is enabled. Possible values are:

- **ON**: Enabled
- **OFF**: Disabled', example='ON'),
      masterId?: string(name='MasterId', description='Primary node ID of the multi-master architecture cluster edition.', example='pi-bp18z52akld3*****'),
      maxConnections?: int32(name='MaxConnections', description='Maximum concurrent connections of the cluster.', example='8000'),
      maxIOPS?: int32(name='MaxIOPS', description='Maximum number of I/O requests, that is, IOPS.', example='32000'),
      memorySize?: string(name='MemorySize', description='Node memory size, in MB.', example='8192'),
      mirrorInsName?: string(name='MirrorInsName', description='The name of the hot standby compute node corresponding to the node when the hot standby storage and compute clusters feature is enabled.', example='pi-bp18z52mirror*****'),
      multiMasterLocalStandby?: string(name='MultiMasterLocalStandby'),
      multiMasterPrimaryNode?: string(name='MultiMasterPrimaryNode'),
      orca?: string(name='Orca', description='Orca feature, valid values are:
- on: enabled
- off: disabled', example='off'),
      remoteMemorySize?: string(name='RemoteMemorySize', description='Remote memory size, in MB.', example='3072'),
      sccMode: string(name='SccMode', description='Whether the node has the global consistency (high-performance mode) feature enabled. Possible values are:

- **ON**: Enabled

- **OFF**: Disabled

This parameter is required.', example='ON'),
      serverWeight?: string(name='ServerWeight', description='Routing weight.
Range: 1~100. Default is 1.', example='1'),
      serverlessType?: string(name='ServerlessType', description='Serverless type. Possible values include:

- **AgileServerless**: Agile
- **SteadyServerless**: Steady

> This parameter is only supported by Serverless clusters.', example='AgileServerless'),
      subCluster?: string(name='SubCluster', description='Identifies whether the node is in the primary or standby availability zone, primarily used in resource mirroring scenarios.
Values include:
- **Primary**: Primary Availability Zone
- **Standby**: Standby Availability Zone', example='Primary'),
      subGroupDescription?: string(name='SubGroupDescription'),
      zoneId?: string(name='ZoneId', description='Availability zone ID.', example='cn-hangzhou-i'),
    }
  ](name='DBNodes', description='The information about the nodes.'),
  DBType?: string(name='DBType', description='Database engine type.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='Database engine version.', example='8.0'),
  DBVersionStatus?: string(name='DBVersionStatus', description='The status of the minor version. Valid values:

*   **Stable**: The minor version is stable.
*   **Old**: The minor version is outdated. We recommend that you update it to the latest version.
*   **HighRisk**: The minor version has critical defects. We recommend that you immediately update it to the latest version.
*   **Beta**: The minor version is a Beta version.

>  For information about how to update the minor version, see [Minor version update](https://help.aliyun.com/document_detail/158572.html).', example='Stable'),
  dataLevel1BackupChainSize?: long(name='DataLevel1BackupChainSize', description='Total size of Level 1 backups (snapshots), in bytes.', example='74448896'),
  dataSyncMode?: string(name='DataSyncMode', description='Data replication relationship mode. Values are as follows:
- **AsyncSync**: Asynchronous
- **SemiSync**: Semi-synchronous', example='AsyncSync'),
  deletionLock?: int32(name='DeletionLock', description='Lock status for cluster deletion, with values as follows:
* **0**: Unlocked, cluster can be deleted.
* **1**: Locked, cluster cannot be deleted.', example='0'),
  engine?: string(name='Engine', description='Cluster engine.', example='POLARDB'),
  expireTime?: string(name='ExpireTime', description='Cluster expiration time.

> Only clusters with **Prepaid** (subscription) payment methods return specific parameter values; **Postpaid** (pay-as-you-go) clusters return empty values.', example='2020-11-14T16:00:00Z'),
  expired?: string(name='Expired', description='Whether the cluster has expired.
> This parameter is only supported for clusters with **Prepaid** (Subscription) payment methods.', example='false'),
  hasCompleteStandbyRes?: boolean(name='HasCompleteStandbyRes', description='Whether to replenish resources for the new primary after cross-AZ switch. Values are as follows:
- **true**: Yes
- **false**: No', example='false'),
  hotStandbyCluster?: string(name='HotStandbyCluster', description='Whether to enable storage hot backup cluster (and Standby compute nodes). Values are as follows:
- **StandbyClusterON**: Enable storage hot backup/Enable storage hot backup and Standby compute nodes.
- **StandbyClusterOFF**: Disable storage hot backup/Disable storage hot backup and Standby compute nodes.', example='StandbyClusterON'),
  imciAutoIndex?: string(name='ImciAutoIndex', description='Indicates whether the automatic IMCI-based query acceleration feature is enabled. Valid values:

*   `ON`: enabled
*   `OFF`: disabled', example='OFF'),
  imperceptibleSwitch?: string(name='ImperceptibleSwitch', description='Indicates whether failover with hot replica is enabled. Valid values:

*   `true`
*   `false` (default)'),
  inodeTotal?: long(name='InodeTotal', description='Maximum number of inodes in the file system.', example='6,291,456'),
  inodeUsed?: long(name='InodeUsed', description='Current inode usage.', example='4,194,304'),
  isLatestVersion?: boolean(name='IsLatestVersion', description='Indicates whether it is the latest kernel version. Values are as follows:

- **true**: Yes

- **false**: No', example='false'),
  isProxyLatestVersion?: boolean(name='IsProxyLatestVersion', description='Indicates whether it is the latest version of the database proxy, with possible values as follows:

- **true**: Yes
- **false**: No', example='false'),
  lockMode?: string(name='LockMode', description='Lock mode. Possible values are as follows:

- **Unlock**: Unlocked.
- **ManualLock**: Manually triggered lock.
- **LockByExpiration**: Automatic cluster lock upon expiration.', example='Unlock'),
  maintainTime?: string(name='MaintainTime', description='The maintenance window for the cluster, formatted as `HH:mmZ-HH:mmZ` (UTC time). For example, `16:00Z-17:00Z` indicates that routine maintenance can be performed from 0:00 to 1:00 (UTC+08:00).', example='18:00Z-19:00Z'),
  orca?: string(name='Orca', description='Orca function with possible values as follows:

- **on**: Enabled

- **off**: Disabled', example='ON'),
  payType?: string(name='PayType', description='Payment type. Possible values are:

- **Postpaid**: Pay-As-You-Go
- **Prepaid**: Prepaid (Subscription).', example='Prepaid'),
  provisionedIops?: string(name='ProvisionedIops', description='Describes the preconfigured read and write IOPS for ESSD AutoPL cloud disks. Possible values: 0 to min{50,000, 1000*capacity - baseline performance}.<br>Baseline performance = min{1,800 + 50*capacity, 50000}.<br>Note: This parameter is supported only when StorageType is ESSDAUTOPL.', example='2500'),
  proxyCpuCores?: string(name='ProxyCpuCores', description='Number of CPU cores for the database proxy.', example='4'),
  proxyServerlessType?: string(name='ProxyServerlessType', description='Serverless type for the database proxy. Currently, the value is fixed to AgileServerless.', example='AgileServerless'),
  proxyStandardCpuCores?: string(name='ProxyStandardCpuCores', description='Standard configuration CPU cores for the database proxy.', example='2'),
  proxyStatus?: string(name='ProxyStatus', description='Status of the database proxy. Possible values include:

- **Creating**: Creating
- **Running**: Running
- **Deleting**: Releasing
- **Rebooting**: Restarting
- **DBNodeCreating**: Adding nodes
- **DBNodeDeleting**: Deleting nodes
- **ClassChanging**: Changing node specifications
- **NetAddressCreating**: Creating network connections
- **NetAddressDeleting**: Deleting network connections
- **NetAddressModifying**: Modifying network connections
- **Deleted**: Released', example='Running'),
  proxyType?: string(name='ProxyType', description='Database proxy types, with the following values:

- **Exclusive**: Enterprise Exclusive Edition
- **General**: Enterprise General Purpose Edition', example='Exclusive'),
  regionId?: string(name='RegionId', description='Region ID.', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='Request ID.', example='074467EF-86B9-4C23-ACBF-E9B81A******'),
  resourceGroupId?: string(name='ResourceGroupId', description='Resource group ID.', example='rg-***************'),
  restoreDataPoint?: string(name='RestoreDataPoint', description='If RestoreType is **RestoreByTime** or **RestoreByTimeOss**, this value represents the recovery time point. If RestoreType is **RestoreByBackupSet** or **RestoreByBackupSetOss**, this value indicates the ID of the backup set on which the recovery is based.
<note>Only clusters restored from a backup set or time point after June 1, 2024, support this parameter.</note>', example='2179639137'),
  restoreType?: string(name='RestoreType', description='Cluster recovery method, with possible values:
* **RestoreByTime**: Restore from a time point based on primary backup. * **RestoreByBackupSet**: Restore from a backup set based on primary backup. * **RestoreByTimeOss**: Restore from a time point based on secondary backup. * **RestoreByBackupSetOss**: Restore from a backup set based on secondary backup. * **CloneFromSourceCluster**: Clone from the source cluster.
<note>This parameter is only supported for clusters restored from a backup set or time point after June 1, 2024.</note>', example='RestoreByTime'),
  rowCompression?: string(name='RowCompression'),
  SQLSize?: long(name='SQLSize', description='Storage amount of SQL, in bytes. If the value is -1, it indicates no data.', example='0'),
  serverlessType?: string(name='ServerlessType', description='Serverless type. Valid values are as follows:
- AgileServerless: Agile - SteadyServerless: Stable', example='AgileServerless'),
  sourceDBCluster?: string(name='SourceDBCluster', description='Source cluster ID. <note>Clusters restored from backup sets or specific points in time after June 1, 2024, support this parameter.</note>', example='pc-pz51ziv48317b2880'),
  sourceRegionId?: string(name='SourceRegionId', description='The region ID of the source cluster.

>  This parameter is returned only if the source cluster ID exists.', example='cn-beijing'),
  standbyHAMode?: string(name='StandbyHAMode', description='Cross-AZ disaster recovery mode. Values are as follows:
- **ON**: Enable cross-AZ disaster recovery mode.
- **OFF**: Disable cross-AZ disaster recovery mode.
- **0**: Customer drill mode.', example='OFF'),
  storageMax?: long(name='StorageMax', description='The maximum storage capacity of the current cluster specification, in bytes.', example='10995116277760'),
  storagePayType?: string(name='StoragePayType', description='Storage billing type. Valid values are as follows:
- **Postpaid**: Pay-as-you-go (by capacity).
- **Prepaid**: Subscription (by space).', example='Prepaid'),
  storageSpace?: long(name='StorageSpace', description='Storage space for pay-by-space (subscription) billing. Unit: Byte.', example='50'),
  storageType?: string(name='StorageType', description='Storage type, with a fixed value of **HighPerformance**.', example='HighPerformance'),
  storageUsed?: long(name='StorageUsed', description='Amount of used storage space, in bytes.', example='3012558848'),
  strictConsistency?: string(name='StrictConsistency', description='Indicates whether multi-AZ data strong consistency is enabled for the cluster. The value ranges are as follows:
- **ON**: Indicates that multi-AZ data strong consistency is enabled, applicable to the Standard 3AZ scenario.
- **OFF**: Indicates that multi-AZ data strong consistency is not enabled.', example='ON'),
  subCategory?: string(name='SubCategory', description='Specification type of compute nodes, with possible values as follows:
* **Exclusive**: Dedicated specification
* **General**: General-purpose specification

> This parameter is supported only for PolarDB MySQL Edition with the product series set to Cluster Edition.', example='Exclusive'),
  supportInstantSwitchWithImci?: string(name='SupportInstantSwitchWithImci', description='Indicates whether queries based on In-Memory Column Indexes (IMCIs) are supported during and after a failover with hot replica.', example='ON'),
  tags?: [ 
    {
      key?: string(name='Key', description='Tag key.', example='test'),
      value?: string(name='Value', description='Tag value.', example='MySQL'),
    }
  ](name='Tags', description='Details of tags.'),
  VPCId?: string(name='VPCId', description='VPC ID.', example='vpc-*******************'),
  vSwitchId?: string(name='VSwitchId', description='VSwitch ID.', example='vsw-*********************'),
  zoneIds?: string(name='ZoneIds', description='Availability Zone IDs.', example='cn-hangzhou-i,cn-hangzhou-g'),
}

model DescribeDBClusterAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterAttributeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDBClusterAttribute  DescribeDBClusterAttributeRequest
  * @return DescribeDBClusterAttributeResponse
 */
async function describeDBClusterAttribute(request: DescribeDBClusterAttributeRequest): DescribeDBClusterAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusterAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClusterAuditLogCollectorRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-***************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBClusterAuditLogCollectorResponseBody = {
  collectorStatus?: string(name='CollectorStatus', description='The status of SQL collector. Valid values:

*   Enable
*   Disabled', example='Disabled'),
  requestId?: string(name='RequestId', description='The request ID.', example='59011D2B-2A38-4207-A86C-72BC1F882D19'),
}

model DescribeDBClusterAuditLogCollectorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterAuditLogCollectorResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDBClusterAuditLogCollector  DescribeDBClusterAuditLogCollectorRequest
  * @return DescribeDBClusterAuditLogCollectorResponse
 */
async function describeDBClusterAuditLogCollector(request: DescribeDBClusterAuditLogCollectorRequest): DescribeDBClusterAuditLogCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusterAuditLogCollector', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClusterAvailableResourcesRequest {
  DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node. For more information, see [Specifications of compute nodes](https://help.aliyun.com/document_detail/102542.html).', example='polar.mysql.x4.large', position='Query'),
  DBType?: string(name='DBType', description='The type of the database engine. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL', position='Query'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine. Valid values for the MySQL database engine:

*   **5.6**
*   **5.7**
*   **8.0**

Valid values for the PostgreSQL database engine:

*   **11**
*   **14**

Valid value for the Oracle database engine: **11**

> This parameter is required when you specify the **DBType** parameter.', example='5.6', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payType: string(name='PayType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go
*   **Prepaid**: subscription

This parameter is required.', example='Postpaid', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the cluster. Default value: **cn-hangzhou**.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the available regions.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', description='The zone ID of the cluster.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the available zones.', example='cn-hangzhou-i', position='Query'),
}

model DescribeDBClusterAvailableResourcesResponseBody = {
  availableZones?: [ 
    {
      regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
      supportedEngines?: [ 
        {
          availableResources?: [ 
            {
              category?: string(name='Category', description='The edition of the cluster. Valid values:

*   **Normal**: Cluster Edition.
*   **Basic**: Single Node Edition.
*   **ArchiveNormal**: X-Engine.
*   **NormalMultimaster**: Multi-master Cluster (Database/Table) Edition.
*   **SENormal**: Standard Edition.

>- Only PolarDB for MySQL supports Single Node Edition.
>- Only PolarDB for MySQL 8.0 supports X-Engine Edition and Multi-master Cluster (Database/Table) Edition.', example='Normal'),
              DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node.', example='polar.mysql.x4.large'),
            }
          ](name='AvailableResources', description='The available resources.'),
          engine?: string(name='Engine', description='The version of the database engine.', example='mysql57'),
        }
      ](name='SupportedEngines', description='The database engines that the available resources support.'),
      zoneId?: string(name='ZoneId', description='The zone ID of the cluster.', example='cn-hangzhou-i'),
    }
  ](name='AvailableZones', description='The available zones of the cluster.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2B19F698-8FFC-4918-B9E2-58D878******'),
}

model DescribeDBClusterAvailableResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterAvailableResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDBClusterAvailableResources  DescribeDBClusterAvailableResourcesRequest
  * @return DescribeDBClusterAvailableResourcesResponse
 */
async function describeDBClusterAvailableResources(request: DescribeDBClusterAvailableResourcesRequest): DescribeDBClusterAvailableResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusterAvailableResources', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClusterConnectivityRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-xxxxxxxxxxxxx', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  sourceIpAddress: string(name='SourceIpAddress', description='The source IP address.

This parameter is required.', example='192.***.***.1', position='Query'),
}

model DescribeDBClusterConnectivityResponseBody = {
  connCheckErrorCode?: string(name='ConnCheckErrorCode', description='The error code for connection diagnosis. Valid values:

*   **SRC_IP_NOT_IN_USER_WHITELIST**: The source IP address is not added to the whitelist.
*   **CONNECTION_ABNORMAL**: The connection to the cluster is normal.', example='SRC_IP_NOT_IN_USER_WHITELIST'),
  connCheckErrorMessage?: string(name='ConnCheckErrorMessage', description='The error message for connection diagnosis.', example='Src ip:192.***.***.1 not in user whitelist'),
  connCheckResult?: string(name='ConnCheckResult', description='The connection diagnosis result. Valid values:

*   **Success**
*   **Failed**', example='Failed'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-xxxxxxxxxxxxx'),
  requestId?: string(name='RequestId', description='The request ID.', example='73A85BAF-1039-4CDE-A83F-1A140F******'),
}

model DescribeDBClusterConnectivityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterConnectivityResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDBClusterConnectivity  DescribeDBClusterConnectivityRequest
  * @return DescribeDBClusterConnectivityResponse
 */
async function describeDBClusterConnectivity(request: DescribeDBClusterConnectivityRequest): DescribeDBClusterConnectivityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusterConnectivity', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClusterEndpointsRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pc-*************', position='Query'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.', example='pe-*************', position='Query'),
  describeType?: string(name='DescribeType', example='AI', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBClusterEndpointsResponseBody = {
  items?: [ 
    {
      addressItems?: [ 
        {
          connectionString?: string(name='ConnectionString', description='The endpoint.', example='********.rwlb.polardb-pg-public.rds.aliyuncs.com'),
          dashboardUsed?: boolean(name='DashboardUsed'),
          IPAddress?: string(name='IPAddress', description='The IP address.', example='192.***.***.***'),
          netType?: string(name='NetType', description='The network type of the endpoint. Valid values:

*   **Public**
*   **Private**', example='Private'),
          port?: string(name='Port', description='The port.', example='1521'),
          privateZoneConnectionString?: string(name='PrivateZoneConnectionString', description='The private domain name that is bound to the endpoint.', example='***.***.**.com'),
          VPCId?: string(name='VPCId', description='The ID of the VPC.', example='vpc-***************'),
          vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-************'),
          vpcInstanceId?: string(name='VpcInstanceId', description='The ID of the virtual private cloud (VPC) instance.

> This parameter is returned for only PolarDB for MySQL clusters.', example='pe-*************'),
        }
      ](name='AddressItems', description='The details of the endpoint.'),
      autoAddNewNodes?: string(name='AutoAddNewNodes', description='Indicates whether new nodes are automatically associated with the default cluster endpoint. Valid values:

*   **Enable**
*   **Disable**', example='Enable'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-bp1s826a1up******'),
      DBEndpointDescription?: string(name='DBEndpointDescription', description='The name of the endpoint.', example='test'),
      DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.', example='pe-*************'),
      endpointConfig?: string(name='EndpointConfig', description='The advanced configurations of the endpoint.

*   **DistributedTransaction**: indicates whether transaction splitting is enabled. Valid values:

    *   **on**
    *   **off**

*   **ConsistLevel**: the consistency level of sessions. Valid values:

    *   **0**: eventual consistency.
    *   **1**: session consistency.
    *   **2**: global consistency.

*   **LoadBalanceStrategy**: the load balancing policy that automatically schedules loads. Only **load** may be returned.

*   **MasterAcceptReads**: indicates whether the primary node processes read requests. Valid values:

    *   **on**
    *   **off**', example='{\\"DistributedTransaction\\":\\"off\\",\\"ConsistLevel\\":\\"0\\",\\"LoadBalanceStrategy\\":\\"load\\",\\"MasterAcceptReads\\":\\"on\\"}'),
      endpointType?: string(name='EndpointType', description='The type of the endpoint. Valid values:

*   **Cluster**: the default endpoint.
*   **Primary**: the primary endpoint.
*   **Custom**: a custom cluster endpoint.', example='Custom'),
      nodeWithRoles?: string(name='NodeWithRoles', description='The role name of each node in the endpoint. The role name of the primary node is **Writer**. Multiple read-only nodes can be associated with an endpoint. Therefore, the role name of each read-only node is suffixed with a number, such as **Reader1** and **Reader2**.

> This parameter is valid only for PolarDB for PostgreSQL clusters and PolarDB for PostgreSQL (Compatible with Oracle)) clusters.', example='Reader1'),
      nodes?: string(name='Nodes', description='The nodes in the endpoint.', example='pi-***************,pi-***************'),
      polarSccTimeoutAction?: string(name='PolarSccTimeoutAction', description='The global consistency timeout policy. Valid values:

*   **0**: sends the request to the primary node.
*   **2**: downgrades the consistency level of a query to inconsistent read when a global consistent read in the query times out. No error message is returned to the client.', example='0'),
      polarSccWaitTimeout?: string(name='PolarSccWaitTimeout', description='Global consistency timeout.', example='100'),
      readWriteMode?: string(name='ReadWriteMode', description='The read/write mode. Valid values:

*   **ReadWrite**: handles read and write requests. Automatic read/write splitting is enabled.
*   **ReadOnly**: handles read-only requests.', example='ReadOnly'),
      sccMode?: string(name='SccMode', description='Indicates whether the global consistency (high-performance mode) feature is enabled for the node. Valid values:

*   **on**: enabled.
*   **off**: disabled', example='on'),
    }
  ](name='Items', description='The information about the endpoints.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2DC120BF-6EBA-4C63-BE99-B09F9E******'),
}

model DescribeDBClusterEndpointsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterEndpointsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDBClusterEndpoints  DescribeDBClusterEndpointsRequest
  * @return DescribeDBClusterEndpointsResponse
 */
async function describeDBClusterEndpoints(request: DescribeDBClusterEndpointsRequest): DescribeDBClusterEndpointsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusterEndpoints', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClusterMigrationRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBClusterId: string(name='DBClusterId', description='The network type of the endpoint. Valid values:

*   **Public**: the public endpoint
*   **Private**: the internal endpoint (VPC)
*   **Inner**: the internal endpoint (classic network)

This parameter is required.', example='pc-**************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBClusterMigrationResponseBody = {
  comment?: string(name='Comment', description='The mode of the source ApsaraDB RDS instance. Valid values:

*   **rw**: read and write mode
*   **ro**: read-only mode', example='test'),
  DBClusterEndpointList?: [ 
    {
      addressItems?: [ 
        {
          connectionString?: string(name='ConnectionString', description='Indicates whether SSL encryption is enabled. Valid values:

*   **Enabled**
*   **Disabled**', example='pc-**************.rwlb.rds.aliyuncs.com'),
          IPAddress?: string(name='IPAddress', description='The description of a migration exception. If no exception occurs during the migration, an empty string is returned.', example='192.***.***.10'),
          netType?: string(name='NetType', description='The ID of the endpoint.', example='Private'),
          port?: string(name='Port', description='The type of the endpoint. Valid values:

*   **Cluster**: the default cluster endpoint
*   **Primary**: the primary endpoint
*   **Custom**: the custom endpoint', example='3306'),
          SSLEnabled?: string(name='SSLEnabled', description='The ID of the request.', example='Enabled'),
          VPCId?: string(name='VPCId', description='The read/write mode. Valid values:

*   ReadWrite: receives and forwards read and write requests (automatic read-write splitting).
*   ReadOnly (default): receives and forwards read requests only.', example='vpc-**********'),
          vSwitchId?: string(name='VSwitchId', description='The IP address of the endpoint.', example='vsw-**********'),
        }
      ](name='AddressItems', description='The VPC ID.'),
      DBEndpointId?: string(name='DBEndpointId', description='The expiration time of the replication between ApsaraDB RDS and PolarDB. The time is in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.', example='pe-***********'),
      endpointType?: string(name='EndpointType', description='The ID of the cluster.', example='Cluster'),
      readWriteMode?: string(name='ReadWriteMode', description='The synchronization direction. Valid values:

*   **RDS2POLARDB**: Data is replicated from an ApsaraDB RDS instance to a PolarDB cluster.
*   **POLARDB2RDS**: Data is replicated from a PolarDB cluster to an ApsaraDB RDS instance.', example='ReadOnly'),
    }
  ](name='DBClusterEndpointList', description='The port number.'),
  DBClusterId?: string(name='DBClusterId', description='The replication latency between the ApsaraDB RDS instance and the PolarDB cluster. Unit: seconds.', example='pc-****************'),
  DBClusterReadWriteMode?: string(name='DBClusterReadWriteMode', description='Details about the endpoints.', example='ro'),
  delayedSeconds?: int32(name='DelayedSeconds', description='The vSwitch ID.', example='0'),
  dtsInstanceId?: string(name='DtsInstanceId', description='The network type of the endpoint. Valid values:

*   **Public**: the public endpoint
*   **Private**: the internal endpoint (VPC)
*   **Inner**: the internal endpoint (classic network)', example='dts**********618bs'),
  expiredTime?: string(name='ExpiredTime', description='The mode of the PolarDB cluster. Valid values:

*   **rw**: read and write mode
*   **ro**: read-only mode', example='2020-06-17T01:56:36Z'),
  migrationStatus?: string(name='MigrationStatus', description='The endpoint.', example='RDS2POLARDB_SYNCING'),
  rdsEndpointList?: [ 
    {
      addressItems?: [ 
        {
          connectionString?: string(name='ConnectionString', description='Indicates whether SSL encryption is enabled. Valid values:

*   **Enabled**
*   **Disabled**', example='rm-***********.mysql.rds.aliyuncs.com'),
          IPAddress?: string(name='IPAddress', description='The type of the source database. Valid values:

*   **PolarDBMySQL**: The source database is a PolarDB for MySQL database when the major version of your PolarDB cluster is upgraded.
*   **RDS**: The source database is an ApsaraDB RDS database when data is migrated from ApsaraDB RDS to PolarDB for MySQL.', example='172.***.***.173'),
          netType?: string(name='NetType', description='The ID of the endpoint.', example='Private'),
          port?: string(name='Port', description='The type of the endpoint. Valid values:

*   **Normal**: the standard endpoint
*   **ReadWriteSplitting**: the read/write splitting endpoint', example='3306'),
          SSLEnabled?: string(name='SSLEnabled', description='Indicates whether SSL encryption is enabled. Valid values:

- **Enabled**
- **Disabled**', example='Enabled'),
          VPCId?: string(name='VPCId', description='The instance type.', example='vpc-************'),
          vSwitchId?: string(name='VSwitchId', description='The IP address of the endpoint.', example='vsw-**************'),
        }
      ](name='AddressItems', description='The VPC ID.'),
      custinsType?: string(name='CustinsType', description='The instance type.', example='ReadOnly
Maxscale
Primary'),
      DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.', example='rm-************-normal'),
      endpointType?: string(name='EndpointType', description='The type of the endpoint. Valid values:

- **Normal**: the standard endpoint
- **ReadWriteSplitting**: the read/write splitting endpoint', example='Normal'),
    }
  ](name='RdsEndpointList', description='The endpoints of the ApsaraDB RDS instance.'),
  rdsReadWriteMode?: string(name='RdsReadWriteMode', description='The ID of the synchronous task.', example='rw'),
  requestId?: string(name='RequestId', description='The ID of the source ApsaraDB RDS instance.', example='F2A9EFA7-915F-4572-8299-85A307******'),
  sourceRDSDBInstanceId?: string(name='SourceRDSDBInstanceId', description='The endpoints of the ApsaraDB RDS instance.', example='rm-************'),
  srcDbType?: string(name='SrcDbType', description='The type of the source database. Valid values:

- **PolarDBMySQL**: The source database is a PolarDB for MySQL database when the major version of your PolarDB cluster is upgraded.
- **RDS**: The source database is an ApsaraDB RDS database when data is migrated from ApsaraDB RDS to PolarDB for MySQL.', example='PolarDBMySQL'),
  topologies?: string(name='Topologies', description='The migration state of the PolarDB cluster. Valid values:

*   **NO_MIGRATION**: No migration task is running.
*   **RDS2POLARDB_CLONING**: Data is being replicated.
*   **RDS2POLARDB_SYNCING**: Data is being replicated. During the replication, the PolarDB cluster is running in read-only mode and the source ApsaraDB RDS instance is running in read and write mode.
*   **SWITCHING**: Databases are being switched.
*   **POLARDB2RDS_SYNCING**: Databases are switched. The PolarDB cluster is running in read and write mode and the source ApsaraDB RDS instance is running in read-only mode. In this state, you can modify the endpoints for your applications.
*   **ROLLBACK**: The migration is being rolled back. After the rollback is complete, the value **RDS2POLARDB_SYNCING** is returned.
*   **CLOSING_MIGRATION**: The migration task is being terminated.', example='RDS2POLARDB'),
}

model DescribeDBClusterMigrationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterMigrationResponseBody(name='body'),
}

/**
  * @description The ID of the request.
  * @param request  the request parameters of DescribeDBClusterMigration  DescribeDBClusterMigrationRequest
  * @return DescribeDBClusterMigrationResponse
 */
async function describeDBClusterMigration(request: DescribeDBClusterMigrationRequest): DescribeDBClusterMigrationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusterMigration', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClusterMonitorRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-****************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBClusterMonitorResponseBody = {
  period?: string(name='Period', description='The interval at which monitoring data is collected. Unit: seconds.', example='60'),
  requestId?: string(name='RequestId', description='The request ID.', example='593AE1C5-B70C-463F-9207-074639******'),
}

model DescribeDBClusterMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterMonitorResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDBClusterMonitor  DescribeDBClusterMonitorRequest
  * @return DescribeDBClusterMonitorResponse
 */
async function describeDBClusterMonitor(request: DescribeDBClusterMonitorRequest): DescribeDBClusterMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusterMonitor', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClusterParametersRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-**********', position='Query'),
  describeType?: string(name='DescribeType', description='The type of the parameter information to query. Valid values:

*   **Normal**: the information about the cluster parameters
*   **MigrationFromRDS**: a comparison of parameters between the source RDS instance and the destination PolarDB cluster', example='Normal', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBClusterParametersResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-bp1s826a1up******'),
  DBType?: string(name='DBType', description='The database engine that the clusters runs. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine. 

- Valid values for the MySQL database engine:   
  - **5.6**
  - **5.7**
  - **8.0**
- Valid value for the PostgreSQL database engine:    
  - **11**
  - **14**
- Valid value for the Oracle database engine:  **11**', example='5.6'),
  engine?: string(name='Engine', description='The cluster engine.', example='POLARDB'),
  parameterNumbers?: string(name='ParameterNumbers', description='The number of parameters.', example='1'),
  parameters?: {
    parameters?: [ 
    {
      isEqual?: string(name='IsEqual', description='Indicates whether the source and current parameters have the same value.', example='true'),
      isInstancePolarDBKey?: string(name='IsInstancePolarDBKey', description='Indicate whether the parameter is a primary parameter of the destination cluster. Valid values:

*   **1**: The parameter is a primary parameter of the destination cluster.
*   **0**: The parameter is not a primary parameter of the destination cluster.', example='1'),
      isInstanceRdsKey?: string(name='IsInstanceRdsKey', description='Indicate whether the parameter is a primary parameter of the source instance. Valid values:

*   **1**: The parameter is a primary parameter of the source instance.
*   **0**: The parameter is not a primary parameter of the source instance.', example='0'),
      isPolarDBKey?: string(name='IsPolarDBKey', description='Indicate whether the parameter is a primary parameter of the destination cluster. Valid values:

*   **1**: The parameter is a primary parameter of the destination cluster.
*   **0**: The parameter is not a primary parameter of the destination cluster.', example='0'),
      isRdsKey?: string(name='IsRdsKey', description='Indicate whether the parameter is a primary parameter of the source instance. Valid values:

*   **1**: The parameter is a primary parameter of the source instance.
*   **0**: The parameter is not a primary parameter of the source instance.', example='1'),
      distParameterDescription?: string(name='distParameterDescription', description='The description of the parameter of the destination cluster.', example='The server\\"s default character set.'),
      distParameterName?: string(name='distParameterName', description='The name of the parameter of the destination cluster.', example='character_set_server'),
      distParameterOptional?: string(name='distParameterOptional', description='The valid values of the parameter of the destination cluster.', example='- utf8
- gbk'),
      distParameterValue?: string(name='distParameterValue', description='The value of the parameter of the destination cluster.', example='utf8'),
      rdsParameterDescription?: string(name='rdsParameterDescription', description='The description of the parameter of the source instance.', example='The server\\"s default character set.'),
      rdsParameterName?: string(name='rdsParameterName', description='The name of the parameter of the source instance.', example='character_set_server'),
      rdsParameterOptional?: string(name='rdsParameterOptional', description='The valid values of the parameter of the source instance.', example='- utf8
- gbk'),
      rdsParameterValue?: string(name='rdsParameterValue', description='The value of the parameter of the source instance.', example='utf8'),
    }
  ](name='Parameters')
  }(name='Parameters', description='A comparison of parameters between the source RDS instance and the destination PolarDB cluster.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EBEAA83D-1734-42E3-85E3-E25F6E******'),
  runningParameters?: {
    parameter?: [ 
    {
      checkingCode?: string(name='CheckingCode', description='The valid values of the parameter.', example='[utf8|latin1|gbk|utf8mb4]'),
      dataType?: string(name='DataType', description='The data type of the parameter value. Valid values:

*   **INT**
*   **STRING**
*   **B**', example='INT'),
      defaultParameterValue?: string(name='DefaultParameterValue', description='The default value of the parameter.', example='utf8'),
      factor?: string(name='Factor', description='A divisor of the parameter. For a parameter of the integer or byte type, the valid values must be a multiple of Factor unless you set Factor to 0.', example='20'),
      forceRestart?: boolean(name='ForceRestart', description='Indicates whether a cluster restart is required for the parameter modification to take effect. Valid values:

*   **false**
*   **true**', example='true'),
      isModifiable?: boolean(name='IsModifiable', description='Indicates whether the parameter can be modified. Valid values:

*   **false**
*   **true**', example='true'),
      isNodeAvailable?: string(name='IsNodeAvailable', description='Indicates whether the parameter is a global parameter. Valid values:

*   **0**: The parameter is a global parameter. The modified parameter value is synchronized to other nodes.
*   **1**: The parameter is not a global parameter. You can specify the nodes to which the modified parameter value can be synchronized.', example='0'),
      paramRelyRule?: string(name='ParamRelyRule', description='The dependencies of the parameter.', example='utf8'),
      parameterDescription?: string(name='ParameterDescription', description='The description of the parameter.', example='The server\\"s default character set.'),
      parameterName?: string(name='ParameterName', description='The name of the parameter.', example='character_set_server'),
      parameterStatus?: string(name='ParameterStatus', description='The status of the parameter. Valid values:

*   **Normal**
*   **Modifying**', example='Normal'),
      parameterValue?: string(name='ParameterValue', description='The value of the parameter.', example='utf8'),
    }
  ](name='Parameter')
  }(name='RunningParameters', description='The parameters of the PolarDB cluster.'),
}

model DescribeDBClusterParametersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterParametersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDBClusterParameters  DescribeDBClusterParametersRequest
  * @return DescribeDBClusterParametersResponse
 */
async function describeDBClusterParameters(request: DescribeDBClusterParametersRequest): DescribeDBClusterParametersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusterParameters', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClusterPerformanceRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-****************', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-09-23T01:00Z', position='Query'),
  interval?: string(name='Interval', description='The interval at which performance data is collected. Valid values: 5, 30, 60, 600, 1800, 3600, 86400, in seconds.', example='60', position='Query'),
  key: string(name='Key', description='The performance metrics that you want to query. Separate multiple metrics with commas (,). For more information, see [Performance parameters](https://help.aliyun.com/document_detail/141787.html).

>  You can specify a maximum of five performance metrics.

This parameter is required.', example='PolarDBDiskUsage', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-09-23T01:01Z', position='Query'),
  type?: string(name='Type', description='The query type.', example='orca', position='Query'),
}

model DescribeDBClusterPerformanceResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*****************'),
  DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='8.0'),
  endTime?: string(name='EndTime', description='The end time of the query. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:01:00Z'),
  performanceKeys?: {
    performanceItem?: [ 
    {
      DBNodeId?: string(name='DBNodeId', description='The ID of the cluster node.

>  The value of this parameter is not returned if the `Key` parameter is set to `PolarDBDiskUsage`.', example='pi-*************'),
      measurement?: string(name='Measurement', description='The performance metrics that are returned.', example='PolarDBDiskUsage'),
      metricName?: string(name='MetricName', description='The name of the performance metric.', example='mean_data_size'),
      points?: {
        performanceItemValue?: [ 
        {
          timestamp?: long(name='Timestamp', description='The timestamp of the metric. This value is a UNIX timestamp. Unit: millisecond.', example='1600822800000'),
          value?: string(name='Value', description='The value of the metric.', example='42.38'),
        }
      ](name='PerformanceItemValue')
      }(name='Points', description='The performance metrics.'),
    }
  ](name='PerformanceItem')
  }(name='PerformanceKeys', description='The cluster performance metrics.'),
  requestId?: string(name='RequestId', description='The request ID.', example='35D3E3DA-4650-407A-BFF5-59BFF1******'),
  startTime?: string(name='StartTime', description='The start time of the query. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:00:00Z'),
}

model DescribeDBClusterPerformanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterPerformanceResponseBody(name='body'),
}

/**
  * @description *   When the monitoring data is collected every 5 seconds:
  *     *   If the query time range is less than or equal to 1 hour, the data is displayed at intervals of 5 seconds.
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  * *   When the monitoring data is collected every 60 seconds:
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  * >  By default, the monitoring data is collected once every 60 seconds. You can call the [ModifyDBClusterMonitor](https://help.aliyun.com/document_detail/159557.html) operation to set the data collection interval to every 5 seconds.
  * @param request  the request parameters of DescribeDBClusterPerformance  DescribeDBClusterPerformanceRequest
  * @return DescribeDBClusterPerformanceResponse
 */
async function describeDBClusterPerformance(request: DescribeDBClusterPerformanceRequest): DescribeDBClusterPerformanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusterPerformance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClusterSSLRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pc-************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBClusterSSLResponseBody = {
  items?: [ 
    {
      DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.', example='pe-************'),
      SSLAutoRotate?: string(name='SSLAutoRotate', example='Enable'),
      SSLConnectionString?: string(name='SSLConnectionString', description='The SSL connection string.', example='pc-************.mysql.polardb.rds.aliyuncs.com'),
      SSLEnabled?: string(name='SSLEnabled', description='Indicates whether SSL encryption is enabled. Valid values:

*   **Enabled**: SSL is enabled.
*   **Disable**: SSL is disabled.', example='Enabled'),
      SSLExpireTime?: string(name='SSLExpireTime', description='The time when the server certificate expires. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2021-11-13T07:14:22Z'),
    }
  ](name='Items', description='The list of SSL connections.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C890995A-CF06-4F4D-8DB8-DD26C2******'),
  SSLAutoRotate?: string(name='SSLAutoRotate', description='Indicates whether automatic rotation of SSL certificates is enabled. Valid values:

*   **Enable**: The feature is enabled.
*   **Disable**: The feature is disabled.

> This parameter is valid only for a PolarDB for MySQL cluster.', example='Enable'),
}

model DescribeDBClusterSSLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterSSLResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDBClusterSSL  DescribeDBClusterSSLRequest
  * @return DescribeDBClusterSSLResponse
 */
async function describeDBClusterSSL(request: DescribeDBClusterSSLRequest): DescribeDBClusterSSLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusterSSL', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClusterServerlessConfRequest {
  DBClusterId: string(name='DBClusterId', description='Serverless cluster ID.

This parameter is required.', example='pc-bp10gr51qasnl****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBClusterServerlessConfResponseBody = {
  agileScaleMax?: string(name='AgileScaleMax'),
  allowShutDown?: string(name='AllowShutDown', description='Whether to enable idle shutdown. Values:

- **true**: Enable

- **false**: Disable (default)', example='true'),
  DBClusterId?: string(name='DBClusterId', description='Serverless cluster ID.', example='pc-bp10gr51qasnl****'),
  requestId?: string(name='RequestId', description='Request ID.', example='5E71541A-6007-4DCC-A38A-F872C31FEB45'),
  scaleApRoNumMax?: string(name='ScaleApRoNumMax', description='The maximum number of read-only column store nodes. Valid values: 0 to 15.', example='1'),
  scaleApRoNumMin?: string(name='ScaleApRoNumMin', description='The minimum number of read-only column store nodes. Valid values: 0 to 15.', example='1'),
  scaleMax?: string(name='ScaleMax', description='Maximum scaling limit for a single node. Range: 1 PCU~32 PCU.', example='3'),
  scaleMin?: string(name='ScaleMin', description='Minimum scaling limit for a single node. Range: 1 PCU~31 PCU.', example='1'),
  scaleRoNumMax?: string(name='ScaleRoNumMax', description='Maximum scaling limit for the number of read-only nodes. Range: 0~15.', example='4'),
  scaleRoNumMin?: string(name='ScaleRoNumMin', description='Minimum scaling limit for the number of read-only nodes. Range: 0~15.', example='2'),
  secondsUntilAutoPause?: string(name='SecondsUntilAutoPause', description='Detection duration for idle shutdown. Range: 300~86,400. Unit: seconds. The detection duration must be a multiple of 300 seconds.', example='10'),
  serverlessRuleCpuEnlargeThreshold?: string(name='ServerlessRuleCpuEnlargeThreshold', description='CPU upscale threshold.', example='60'),
  serverlessRuleCpuShrinkThreshold?: string(name='ServerlessRuleCpuShrinkThreshold', description='CPU downscale threshold.', example='30'),
  serverlessRuleMode?: string(name='ServerlessRuleMode', description='Elasticity sensitivity. Values:

- normal: Standard

- flexible: Sensitive', example='normal'),
  switchs?: string(name='Switchs', description='Whether steady state is enabled. Values:

1: Enabled

0: Disabled', example='1'),
  traditionalScaleMaxThreshold?: string(name='TraditionalScaleMaxThreshold'),
}

model DescribeDBClusterServerlessConfResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterServerlessConfResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDBClusterServerlessConf  DescribeDBClusterServerlessConfRequest
  * @return DescribeDBClusterServerlessConfResponse
 */
async function describeDBClusterServerlessConf(request: DescribeDBClusterServerlessConfRequest): DescribeDBClusterServerlessConfResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusterServerlessConf', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClusterTDERequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-***************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBClusterTDEResponseBody = {
  automaticRotation?: string(name='AutomaticRotation', description='Indicates whether automatic key rotation is allowed. Valid values:

*   **Enabled**: Automatic key rotation is allowed.
*   **Disabled**: Automatic key rotation is not allowed.

>  This parameter is returned only for a PolarDB for PostgreSQL or PolarDB for PostgreSQL (Compatible with Oracle) cluster.', example='Enabled'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-***************'),
  encryptNewTables?: string(name='EncryptNewTables', description='Indicates whether automatic encryption is enabled for new tables. Valid values:

*   **ON**
*   **OFF**

>  This parameter is returned only for a PolarDB for MySQL cluster.', example='ON'),
  encryptionKey?: string(name='EncryptionKey', description='The ID of the custom key.', example='2a4f4ac2-****-****-****-************'),
  encryptionKeyStatus?: string(name='EncryptionKeyStatus', example='Enabled'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E37D1508-EC3B-4E06-A24A-C7AC31******'),
  rotationInterval?: string(name='RotationInterval', description='The automatic key rotation period configured in Key Management Service (KMS). If no automatic key rotation period is configured, 0s is returned. Unit: seconds.

For example, if the rotation period is set to 7 days, 604800s is returned.

>  This parameter is returned only for a PolarDB for PostgreSQL or PolarDB for PostgreSQL (Compatible with Oracle) cluster whose AutomaticRotation parameter is set to Enabled.', example='604800s'),
  TDERegion?: string(name='TDERegion', description='The region where the TDE key resides.', example='cn-beijing'),
  TDEStatus?: string(name='TDEStatus', description='Indicates whether TDE encryption is enabled. Valid values:

*   **Enabled**
*   **Disabled**', example='Enabled'),
}

model DescribeDBClusterTDEResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterTDEResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDBClusterTDE  DescribeDBClusterTDERequest
  * @return DescribeDBClusterTDEResponse
 */
async function describeDBClusterTDE(request: DescribeDBClusterTDERequest): DescribeDBClusterTDEResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusterTDE', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClusterVersionRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-****************', position='Query'),
  describeType?: string(name='DescribeType', description='Specifies whether to query the information about the latest versions or the versions to which the cluster can be updated. Valid values:

*   LATEST_VERSION: the information about the latest versions.
*   AVAILABLE_VERSION: the information about the versions to which the cluster can be updated.', example='LATEST_VERSION', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBClusterVersionResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-****************'),
  DBLatestVersion?: string(name='DBLatestVersion', description='The latest version of the database engine.', example='8.0.1.1.16'),
  DBMinorVersion?: string(name='DBMinorVersion', description='The minor version of the database engine.

- If DBVersion is 8.0, the valid values of this parameter are:
  - 8.0.2
  - 8.0.1
- If DBVersion is 5.7, set the value of this parameter to 5.7.28.
- If DBVersion is 5.6, the value of this parameter is 5.6.16.', example='8.0.1'),
  DBRevisionVersion?: string(name='DBRevisionVersion', description='The revision version of the database engine.
>For a cluster of the PolarDB for MySQL 5.6, the DBRevisionVersion parameter returns the revision version information only if the Revision Version is released later than August 31, 2020. Otherwise, this parameter returns an empty value.', example='8.0.1.1.7'),
  DBRevisionVersionList?: [ 
    {
      releaseNote?: string(name='ReleaseNote', description='The release notes for the database engine revision version.', example='ReleaseNote'),
      releaseType?: string(name='ReleaseType', description='The release status of the database engine revision version. Valid values:

*   **Stable**: The database engine revision version is stable.
*   **Old**: The database engine revision version is outdated. We recommend that you do not update the database engine to this revision version.
*   **HighRisk**: The database engine revision version has critical defects. We recommend that you do not update the database engine to this revision version.
*   **Beta**: The database engine revision version is a Beta version.', example='Stable'),
      revisionVersionCode?: string(name='RevisionVersionCode', description='The code of the database engine revision version. You can use the code to specify the database engine revision version.', example='20230707'),
      revisionVersionName?: string(name='RevisionVersionName', description='The database engine revision version number.', example='8.0.1.1.35.1'),
    }
  ](name='DBRevisionVersionList', description='The versions to which the cluster can be upgraded.'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine. Valid values:

- 5.6
- 5.7
- 8.0', example='8.0'),
  DBVersionStatus?: string(name='DBVersionStatus', description='The status of the minor version. Valid values:

*   **Stable**: The minor version is stable.
*   **Old**: The minor version is outdated. We recommend that you upgrade the cluster to the latest version.
*   **HighRisk**: The minor version has critical defects. We recommend that you immediately update the cluster to the latest minor version.

>  For more information about how to update the minor version, see [Minor version update](https://help.aliyun.com/document_detail/158572.html).', example='Stable'),
  isLatestVersion?: string(name='IsLatestVersion', description='Indicates whether the kernel is of the latest version. Valid values:

- true
- false', example='true'),
  isProxyLatestVersion?: string(name='IsProxyLatestVersion', description='Indicates whether PolarProxy uses the latest version. Valid values:

- true
- false', example='true'),
  proxyLatestVersion?: string(name='ProxyLatestVersion', description='The latest version of PolarProxy.', example='2.4.17'),
  proxyRevisionVersion?: string(name='ProxyRevisionVersion', description='The revision version of the database engine.', example='2.4.15'),
  proxyRevisionVersionList?: [ 
    {
      releaseNote?: string(name='ReleaseNote', description='The release notes for the PolarProxy revision version.', example='ReleaseNote'),
      releaseType?: string(name='ReleaseType', description='The release type. Valid values:

*   **LTS**: a long-term version
*   **BETA**: a preview version', example='LTS'),
      revisionVersionCode?: string(name='RevisionVersionCode', description='The PolarProxy revision version code. You can use this code to specify the PolarProxy revision version.', example='20230707'),
      revisionVersionName?: string(name='RevisionVersionName', description='The PolarProxy revision version number.', example='2.8.24'),
    }
  ](name='ProxyRevisionVersionList', description='The release status of the PolarProxy version. Valid values:

*   **Stable**: The PolarProxy revision version is stable.
*   **Old**: The PolarProxy revision version is outdated. We recommend that you do not update the PolarProxy to this revision version.
*   **HighRisk**: The PolarProxy revision version has critical defects. We recommend that you do not update the PolarProxy to this revision version.
*   **Beta**: The PolarProxy revision version is a Beta version.'),
  proxyVersionStatus?: string(name='ProxyVersionStatus', description='The status of PolarProxy. Valid values:

- Stable: The minor version is stable.
- Old: The minor version is outdated. We recommend that you upgrade the cluster to the latest version.
- HighRisk: The minor version has critical defects. We recommend that you immediately upgrade the cluster to the latest version.
- Beta: The minor version is a beta version.', example='Stable'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='47921222-0D37-4133-8C0D-017DC3******'),
}

model DescribeDBClusterVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterVersionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDBClusterVersion  DescribeDBClusterVersionRequest
  * @return DescribeDBClusterVersionResponse
 */
async function describeDBClusterVersion(request: DescribeDBClusterVersionRequest): DescribeDBClusterVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusterVersion', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClustersRequest {
  connectionString?: string(name='ConnectionString', description='The endpoint of the cluster.', example='********.rwlb.polardb-pg-public.rds.aliyuncs.com', position='Query'),
  DBClusterDescription?: string(name='DBClusterDescription', description='The description of the cluster. Fuzzy match is supported.', example='pc-****************', position='Query'),
  DBClusterIds?: string(name='DBClusterIds', description='The ID of the cluster. Separate multiple cluster IDs with commas (,).', example='pc-****************', position='Query'),
  DBClusterStatus?: string(name='DBClusterStatus', description='The state of the cluster that you want to query. For information about valid values, see [Cluster states](https://help.aliyun.com/document_detail/99286.html).', example='Running', position='Query'),
  DBNodeIds?: string(name='DBNodeIds', description='The ID of the node. You can specify multiple node IDs. Separate multiple node IDs with commas (,).', example='pi-***************', position='Query'),
  DBType?: string(name='DBType', description='The database engine that the cluster runs. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL', position='Query'),
  DBVersion?: string(name='DBVersion', description='The database engine version of the cluster.', example='5.6', position='Query'),
  describeType?: string(name='DescribeType', description='The query mode of the list. The value Simple indicates that the simple mode is used. In this mode, only the basic metadata information of the cluster is returned.

> If you do not specify this parameter, the detailed mode is used by default. Detailed information about the cluster is returned.', example='Simple', position='Query'),
  expired?: boolean(name='Expired', description='Specifies whether the cluster has expired. Valid values:

*   **true**
*   **false**', example='true', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value must be a positive integer that does not exceed the maximum value of the INTEGER data type. Default value: **1**.', example='10', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **30**, **50**, and **100**.

Default value: **30**.', example='30', position='Query'),
  payType?: string(name='PayType', description='The billing method. Valid values:

*   **Postpaid**: pay-as-you-go
*   **Prepaid**: subscription', example='Postpaid', position='Query'),
  recentCreationInterval?: int32(name='RecentCreationInterval', description='Filters clusters created in the last N days. Valid values: 0 to 15.', example='7', position='Query'),
  recentExpirationInterval?: int32(name='RecentExpirationInterval', description='Filters clusters that expire after N days. Valid values: 0 to 15.', example='6', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the cluster.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the available regions.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag. You can use tags to filter clusters. You can specify up to 20 tags. N specifies the serial number of each tag. The values that you specify for N must be unique and consecutive integers that start from 1. The value of Tag.N.Key is Tag.N.Value.

> The tag key can be up to 64 characters in length and cannot start with `aliyun`, `acs:`, `http://`, or `https://`.', example='MySQL'),
      value?: string(name='Value', description='The value of the tag.

> The tag value can be up to 64 characters in length and cannot start with `aliyun`, `acs:`, `http://`, or `https://`.', example='5.6'),
    }
  ](name='Tag', description='The tags of the cluster.', position='Query'),
}

model DescribeDBClustersResponseBody = {
  items?: {
    DBCluster?: [ 
    {
      aiType?: string(name='AiType', description='The type of the AI node. Valid values:

*   SearchNode: search node
*   DLNode: AI node

Enumeration values:

*   SearchNode | DLNode: both
*   DLNode: AI node
*   SearchNode: search node', example='SearchNode'),
      category?: string(name='Category', description='The edition of the cluster. Valid values:

*   **Normal**: Cluster Edition
*   **Basic**: Single Node Edition
*   **Archive**: X-Engine Edition
*   **NormalMultimaster**: Multi-master Cluster (Database/Table) Edition', example='Normal'),
      cpuCores?: string(name='CpuCores', description='The number of CPU cores.', example='1'),
      createTime?: string(name='CreateTime', description='The time when the cluster was created.', example='2020-08-14T05:58:42Z'),
      DBClusterDescription?: string(name='DBClusterDescription', description='The description of the cluster.', example='GDN-1'),
      DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-****************'),
      DBClusterNetworkType?: string(name='DBClusterNetworkType', description='The network type of the cluster.', example='VPC'),
      DBClusterStatus?: string(name='DBClusterStatus', description='The state of the cluster.', example='Running'),
      DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node.', example='polar.mysql.x4.large'),
      DBNodeNumber?: int32(name='DBNodeNumber', description='The number of nodes.', example='2'),
      DBNodes?: {
        DBNode?: [ 
        {
          DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node.', example='polar.mysql.x4.large'),
          DBNodeId?: string(name='DBNodeId', description='The ID of the node.', example='pi-****************'),
          DBNodeRole?: string(name='DBNodeRole', description='The role of the node. Valid values:

*   **Writer**: primary node
*   **Reader**: read-only node
*   **ColumnReader**: column store read-only node
*   **AI**: AI node', example='Reader'),
          hotReplicaMode?: string(name='HotReplicaMode', description='Indicates whether the hot standby feature is enabled. Valid values:

*   **ON**
*   **OFF**', example='OFF'),
          imciSwitch?: string(name='ImciSwitch', description='Indicates whether the In-Memory Column Index (IMCI) feature is enabled. Valid values:

*   **ON**
*   **OFF**', example='OFF'),
          regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
          serverless?: string(name='Serverless', description='Indicates whether the serverless feature is enabled for the node.

*   **ON** indicates that the serverless feature is enabled.
*   No value is returned if the serverless feature is disabled.', example='ON'),
          zoneId?: string(name='ZoneId', description='The zone ID of the cluster.', example='cn-hangzhou-i'),
        }
      ](name='DBNode')
      }(name='DBNodes', description='The information about the nodes.'),
      DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='5.6'),
      deletionLock?: int32(name='DeletionLock', description='Indicates whether the cluster is protected from deletion. Valid values:

*   **0**: The cluster is not protected from deletion.
*   **1**: The cluster is protected from deletion.

>  You cannot delete clusters that are protected from deletion.', example='0'),
      engine?: string(name='Engine', description='The database engine of the cluster.', example='POLARDB'),
      expireTime?: string(name='ExpireTime', description='The expiration time of the cluster.

>  A specific value is returned only for subscription (**Prepaid**) clusters. For pay-as-you-go (**Postpaid**) clusters, no value is returned.', example='2020-11-14T16:00:00Z'),
      expired?: string(name='Expired', description='Indicates whether the cluster has expired. Valid values:

*   **true**
*   **false**

>  A specific value is returned only for subscription (**Prepaid**) clusters.', example='false'),
      hotStandbyCluster?: string(name='HotStandbyCluster', description='Indicates whether the hot standby storage cluster feature is enabled. Valid values:

*   ON
*   OFF', example='OFF'),
      lockMode?: string(name='LockMode', description='The lock state of the cluster. Valid values:

*   **Unlock**: The cluster is unlocked.
*   **ManualLock**: The cluster is manually locked.
*   **LockByExpiration**: The cluster is locked due to cluster expiration.', example='Unlock'),
      memorySize?: string(name='MemorySize', description='The memory size for local operations. Unit: MB.', example='2048'),
      payType?: string(name='PayType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go
*   **Prepaid**: subscription', example='Prepaid'),
      regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
      remoteMemorySize?: string(name='RemoteMemorySize', description='The memory size for distributed operations. Unit: MB.', example='3612'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
      serverlessType?: string(name='ServerlessType', description='Indicates whether the cluster is a serverless cluster. **AgileServerless** indicates the cluster is a serverless cluster. No value is returned for a common cluster.', example='AgileServerless'),
      storagePayType?: string(name='StoragePayType', description='The storage billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go
*   **Prepaid**: subscription', example='Prepaid'),
      storageSpace?: long(name='StorageSpace', description='The storage that is billed based on the subscription billing method. Unit: bytes.', example='50'),
      storageType?: string(name='StorageType', description='The storage type.', example='essdautopl'),
      storageUsed?: long(name='StorageUsed', description='The used storage. Unit: bytes.', example='3009413120'),
      strictConsistency?: string(name='StrictConsistency', description='Indicates whether multi-zone data consistency is enabled for the cluster. Valid values:

*   **ON**: Multi-zone data consistency is enabled. For Standard Edition clusters of Multi-zone Edition, this value is returned.
*   **OFF**: Multi-zone data consistency is disabled.', example='ON'),
      subCategory?: string(name='SubCategory', description='The specification type of the compute node. Valid values:

*   **Exclusive**: dedicated.
*   **General**: general-purpose.', example='Exclusive'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key', description='The key of the tag.', example='MySQL'),
          value?: string(name='Value', description='The value of the tag.', example='5.6'),
        }
      ](name='Tag')
      }(name='Tags', description='The information about the tags.'),
      vpcId?: string(name='VpcId', description='The virtual private cloud (VPC) ID of the cluster.', example='vpc-****************'),
      vswitchId?: string(name='VswitchId', description='The vSwitch ID of the cluster.', example='vsw-***************'),
      zoneId?: string(name='ZoneId', description='The zone ID of the cluster.', example='cn-hangzhou-i'),
    }
  ](name='DBCluster')
  }(name='Items', description='The information about the clusters.'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='12'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of clusters returned per page.', example='5'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of returned entries.', example='16'),
}

model DescribeDBClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClustersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDBClusters  DescribeDBClustersRequest
  * @return DescribeDBClustersResponse
 */
async function describeDBClusters(request: DescribeDBClustersRequest): DescribeDBClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClusters', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBClustersWithBackupsRequest {
  DBClusterDescription?: string(name='DBClusterDescription', description='The name of the cluster. The name must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must be 2 to 256 characters in length.', example='test', position='Query'),
  DBClusterIds?: string(name='DBClusterIds', description='The ID of the cluster. If you need to specify multiple cluster IDs, separate the cluster IDs with commas (,).', example='pc-**************', position='Query'),
  DBType?: string(name='DBType', description='The type of the database engine. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL', position='Query'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.

*   Valid values for the MySQL database engine:

    *   **5.6**
    *   **5.7**
    *   **8.0**

*   Valid values for the PostgreSQL database engine:

    *   **11**
    *   **14**

*   Valid value for the Oracle database engine: **11**', example='8.0', position='Query'),
  isDeleted?: int32(name='IsDeleted', description='Specifies whether the cluster is deleted. Valid values:

*   **0**: not deleted
*   **1**: deleted', example='0', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. The value must be a positive integer that does not exceed the maximum value of the INTEGER data type. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: 30.', example='30', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the cluster.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query information about regions.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBClustersWithBackupsResponseBody = {
  items?: {
    DBCluster?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the cluster was created.', example='2022-05-09T09:33:51Z'),
      DBClusterDescription?: string(name='DBClusterDescription', description='The name of the cluster.', example='test'),
      DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-****************'),
      DBClusterNetworkType?: string(name='DBClusterNetworkType', description='The network type of the cluster.', example='VPC'),
      DBClusterStatus?: string(name='DBClusterStatus', description='The status of the cluster. Valid values:

*   Creating: The cluster is being created.
*   Running: The cluster is running.
*   Deleting: The cluster is being released.
*   Rebooting: The cluster is restarting.
*   DBNodeCreating: The node is being added.
*   DBNodeDeleting: The node is being deleted.
*   ClassChanging: The specifications of the node are being changed.
*   NetAddressCreating: The network connection is being created.
*   NetAddressDeleting: The network connection is being deleted.
*   NetAddressModifying: The network connection is being modified.
*   Deleted: The cluster has been released.', example='Running'),
      DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node.', example='polar.mysql.x4.medium'),
      DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='8.0'),
      deletedTime?: string(name='DeletedTime', description='The time when the cluster was deleted.', example='2022-05-12T03:25:37Z'),
      deletionLock?: int32(name='DeletionLock', description='Indicates whether the cluster is locked and can be deleted. Valid values:

*   **0**: The cluster is not locked and can be deleted.
*   **1**: The cluster is locked and cannot be deleted.', example='0'),
      engine?: string(name='Engine', description='The type of the database engine.', example='POLARDB'),
      expireTime?: string(name='ExpireTime', description='The time when the cluster expires.

> A specific value will be returned only for subscription clusters. For pay-as-you-go clusters, an empty string will be returned.', example='2022-09-14T16:00:00Z'),
      expired?: string(name='Expired', description='Indicates whether the cluster has expired.

> A specific value will be returned only for subscription clusters.', example='false'),
      isDeleted?: int32(name='IsDeleted', description='Indicates whether the cluster was released. Valid values:

*   1: released
*   0: not released', example='1'),
      lockMode?: string(name='LockMode', description='The state of the cluster lock. Valid values:

*   **Unlock**: The cluster is not locked.
*   **ManualLock**: The cluster is manually locked.
*   **LockByExpiration**: The cluster is automatically locked after the cluster expires.', example='Unlock'),
      payType?: string(name='PayType', description='The billing method. Valid values:

*   **Postpaid**: pay-as-you-go.
*   **Prepaid**: subscription', example='Postpaid'),
      regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
      vpcId?: string(name='VpcId', description='The VPC ID of the cluster.', example='vpc-******************'),
      zoneId?: string(name='ZoneId', description='The ID of the zone in which the instance is located.', example='cn-hangzhou-h'),
    }
  ](name='DBCluster')
  }(name='Items', description='The details about the cluster.'),
  pageNumber?: int32(name='PageNumber', description='The total number of returned pages.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of clusters returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F8529AA2-522F-4B30-B80B-8F7D39******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of returned entries.', example='1'),
}

model DescribeDBClustersWithBackupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClustersWithBackupsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDBClustersWithBackups  DescribeDBClustersWithBackupsRequest
  * @return DescribeDBClustersWithBackupsResponse
 */
async function describeDBClustersWithBackups(request: DescribeDBClustersWithBackupsRequest): DescribeDBClustersWithBackupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBClustersWithBackups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInitializeVariableRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.

This parameter is required.', example='pc-****************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBInitializeVariableResponseBody = {
  DBType?: string(name='DBType', description='The database type. Valid values:

*   Oracle
*   PostgreSQL
*   MySQL', example='PostgreSQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='11'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='475F58B7-F394-4394-AA6E-4F1CBA******'),
  variables?: {
    variable?: [ 
    {
      charset?: string(name='Charset', description='The character set that is supported.', example='EUC_CN'),
      collate?: string(name='Collate', description='The language that indicates the collation of the databases that are created.

>- The language must be compatible with the character set that is specified by **CharacterSetName**.
>- This parameter is required for PolarDB for PostgreSQL (Compatible with Oracle) clusters or PolarDB for PostgreSQL clusters.
>- This parameter is optional for PolarDB for MySQL clusters.

To view the valid values for this parameter, perform the following steps: Log on to the PolarDB console and click the ID of a cluster. In the left-side navigation pane, choose **Settings and Management** > **Databases**. Then, click **Create Database**.', example='C'),
      ctype?: string(name='Ctype', description='The language that indicates the character type of the database.

> 

*   The language must be compatible with the character set that is specified by **CharacterSetName**.

*   The specified parameter value must be the same as the value of **Collate**.

*   If the PolarDB cluster runs PolarDB for PostgreSQL (Compatible with Oracle) or PolarDB for PostgreSQL, this parameter is required. If the cluster runs PolarDB for MySQL, this parameter is not supported.

To view the valid values of this parameter, perform the following steps: First, log on to the PolarDB console and click the ID of a cluster. Then, in the left-side navigation pane, choose **Settings and Management** > **Databases**. Finally, click **Create Database**.', example='C'),
    }
  ](name='Variable')
  }(name='Variables', description='The attributes that are returned.'),
}

model DescribeDBInitializeVariableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBInitializeVariableResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDBInitializeVariable  DescribeDBInitializeVariableRequest
  * @return DescribeDBInitializeVariableResponse
 */
async function describeDBInitializeVariable(request: DescribeDBInitializeVariableRequest): DescribeDBInitializeVariableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInitializeVariable', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBLinksRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster for which you want to query the database links.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/173433.html) operation to query PolarDB clusters.

This parameter is required.', example='pc-a*************', position='Query'),
  DBLinkName?: string(name='DBLinkName', description='The name of the database link. If you leave this parameter empty, the system returns all the database links.', example='dblink_test', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBLinksResponseBody = {
  DBInstanceName?: string(name='DBInstanceName', description='The ID of the cluster.', example='pc-a*************'),
  DBLinkInfos?: [ 
    {
      DBInstanceName?: string(name='DBInstanceName', description='The ID of the source cluster that the database link connects.', example='pc-a*************'),
      DBLinkName?: string(name='DBLinkName', description='The name of the database link.', example='dblink_test'),
      sourceDBName?: string(name='SourceDBName', description='The name of the source database of the database link.', example='testdb1'),
      targetAccount?: string(name='TargetAccount', description='The account of the destination database of the database link.', example='testacc'),
      targetDBInstanceName?: string(name='TargetDBInstanceName', description='The ID of the destination cluster that the database link connects.

> If the destination cluster is not a PolarDB for Oracle cluster, the returned value is empty.', example='pc-b************'),
      targetDBName?: string(name='TargetDBName', description='The name of the destination database of the database link.', example='testdb2'),
    }
  ](name='DBLinkInfos', description='Details about the database links.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='45D24263-7E3A-4140-9472-************'),
}

model DescribeDBLinksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBLinksResponseBody(name='body'),
}

/**
  * @description > You can query only the database links that use a PolarDB for Oracle cluster as the source.
  * @param request  the request parameters of DescribeDBLinks  DescribeDBLinksRequest
  * @return DescribeDBLinksResponse
 */
async function describeDBLinks(request: DescribeDBLinksRequest): DescribeDBLinksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBLinks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBNodePerformanceRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-****************', position='Query'),
  DBNodeId: string(name='DBNodeId', description='The ID of the cluster node.

This parameter is required.', example='pi-*************', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-09-23T01:01Z', position='Query'),
  interval?: string(name='Interval', description='The interval at which performance data is collected. Valid values:

*   5
*   30
*   60
*   600
*   1800
*   3600
*   86400', example='60', position='Query'),
  key: string(name='Key', description='The performance metrics that you want to query. Separate multiple metrics with commas (,). For more information, see [Performance parameters](https://help.aliyun.com/document_detail/141787.html).

>  You can specify a maximum of five performance metrics.

This parameter is required.', example='PolarDBDiskUsage', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-09-23T01:00Z', position='Query'),
  type?: string(name='Type', description='The special metric. Set the value to tair, which indicates the PolarTair architecture.', example='tair', position='Query'),
}

model DescribeDBNodePerformanceResponseBody = {
  DBNodeId?: string(name='DBNodeId', description='The ID of the cluster node.', example='pi-*****************'),
  DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='8.0'),
  endTime?: string(name='EndTime', description='The end time of the query. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:01:00Z'),
  performanceKeys?: {
    performanceItem?: [ 
    {
      measurement?: string(name='Measurement', description='The performance metrics that you want to query.', example='PolarDBDiskUsage'),
      metricName?: string(name='MetricName', description='The name of the performance metric.', example='mean_sys_dir_size'),
      points?: {
        performanceItemValue?: [ 
        {
          timestamp?: long(name='Timestamp', description='The timestamp of the metric. This value is a UNIX timestamp. Unit: millisecond.', example='1600822800000'),
          value?: string(name='Value', description='The value of the metric.', example='9.33'),
        }
      ](name='PerformanceItemValue')
      }(name='Points', description='The performance metrics.'),
    }
  ](name='PerformanceItem')
  }(name='PerformanceKeys', description='The cluster performance metrics.'),
  requestId?: string(name='RequestId', description='The request ID.', example='E2FDB684-751D-424D-98B9-704BEA******'),
  startTime?: string(name='StartTime', description='The start time of the query. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:00:00Z'),
}

model DescribeDBNodePerformanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBNodePerformanceResponseBody(name='body'),
}

/**
  * @description *   When the monitoring data is collected every 5 seconds:
  *     *   If the query time range is less than or equal to 1 hour, the data is displayed at intervals of 5 seconds.
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  * *   When the monitoring data is collected every 60 seconds:
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  * >  By default, the monitoring data is collected once every 60 seconds. You can call the [ModifyDBClusterMonitor](https://help.aliyun.com/document_detail/159557.html) operation to set the data collection interval to every 5 seconds.
  * @param request  the request parameters of DescribeDBNodePerformance  DescribeDBNodePerformanceRequest
  * @return DescribeDBNodePerformanceResponse
 */
async function describeDBNodePerformance(request: DescribeDBNodePerformanceRequest): DescribeDBNodePerformanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBNodePerformance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBNodesParametersRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-****************', position='Query'),
  DBNodeIds: string(name='DBNodeIds', description='The node ID. You can specify multiple node IDs. Separate multiple node IDs with commas (,).

This parameter is required.', example='pi-****************,pi-****************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBNodesParametersResponseBody = {
  DBNodeIds?: [ 
    {
      DBNodeId?: string(name='DBNodeId', description='The ID of the node.', example='pi-bp1r4qe3s534*****'),
      runningParameters?: [ 
        {
          checkingCode?: string(name='CheckingCode', description='The valid values of the parameter.', example='[utf8|latin1|gbk|utf8mb4]'),
          dataType?: string(name='DataType', description='The data type of the parameter value. Valid values:

*   **INT**
*   **STRING**
*   **B**', example='INT'),
          defaultParameterValue?: string(name='DefaultParameterValue', description='The default value of the parameter.', example='utf8'),
          factor?: string(name='Factor', description='A divisor of the parameter. For a parameter of the integer or byte type, the valid values must be a multiple of Factor unless you set Factor to 0.', example='20'),
          forceRestart?: boolean(name='ForceRestart', description='Indicates whether a cluster restart is required to allow the parameter modification to take effect. Valid values:

*   **false**
*   **true**', example='true'),
          isModifiable?: boolean(name='IsModifiable', description='Indicates whether the parameter can be modified. Valid values:

*   **false**
*   **true**', example='true'),
          isNodeAvailable?: string(name='IsNodeAvailable', description='Indicates whether the parameter is a global parameter. Valid values:

*   **0**: yes. The modified parameter value is synchronized to other nodes.
*   **1**: no. You can customize the nodes to which the modified parameter value can be synchronized to.', example='1'),
          paramRelyRule?: string(name='ParamRelyRule', description='The dependencies of the parameter.', example='utf8'),
          parameterDescription?: string(name='ParameterDescription', description='The description of the parameter.', example='The server\\"s default character set.'),
          parameterName?: string(name='ParameterName', description='The name of the parameter.', example='character_set_server'),
          parameterStatus?: string(name='ParameterStatus', description='The status of the parameter. Valid values:

*   **normal**
*   **modifying**', example='normal'),
          parameterValue?: string(name='ParameterValue', description='The value of the parameter.', example='utf8'),
        }
      ](name='RunningParameters', description='The parameters of the current node.'),
    }
  ](name='DBNodeIds', description='The IDs of the nodes.'),
  DBType?: string(name='DBType', description='The type of the database engine. Set the value to **MySQL**.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the MySQL database engine. Valid values:

*   **5.6**
*   **5.7**
*   **8.0**', example='5.6'),
  engine?: string(name='Engine', description='The cluster engine.', example='POLARDB'),
  requestId?: string(name='RequestId', description='The request ID.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model DescribeDBNodesParametersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBNodesParametersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDBNodesParameters  DescribeDBNodesParametersRequest
  * @return DescribeDBNodesParametersResponse
 */
async function describeDBNodesParameters(request: DescribeDBNodesParametersRequest): DescribeDBNodesParametersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBNodesParameters', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBProxyPerformanceRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-****************', position='Query'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.', example='pe-****************', position='Query'),
  DBNodeId?: string(name='DBNodeId', description='The ID of the node in the cluster. This parameter can be used to query the performance metrics of PolarProxy on different nodes. The following metrics are supported: PolarProxy_DBConns, PolarProxy_DBQps, and PolarProxy_DBActionOps.', example='pi-******************', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-09-24T02:08Z', position='Query'),
  interval?: string(name='Interval', description='The interval at which performance data is collected. Valid values: 5, 30, 60, 600, 1800, 3600, 86400, in seconds.', example='60', position='Query'),
  key: string(name='Key', description='The performance metrics that you want to query. Separate multiple indicators with commas (,). For more information, see [Performance parameters](https://help.aliyun.com/document_detail/141787.html).

This parameter is required.', example='PolarProxy_CpuUsage', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-09-23T01:01Z', position='Query'),
  type?: string(name='Type', description='Special metric. Set the value to tair, which indicates the PolarTair architecture.', example='tair', position='Query'),
}

model DescribeDBProxyPerformanceResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-*****************'),
  DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='8.0'),
  endTime?: string(name='EndTime', description='The end time of the query. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:01:00Z'),
  performanceKeys?: {
    performanceItem?: [ 
    {
      DBNodeId?: string(name='DBNodeId', description='The ID of the node.', example='pi-*************'),
      measurement?: string(name='Measurement', description='The performance metric.', example='PolarProxy_CpuUsage'),
      metricName?: string(name='MetricName', description='The name of the performance metric.', example='service_connections_ps'),
      points?: {
        performanceItemValue?: [ 
        {
          timestamp?: long(name='Timestamp', description='The time when the metric value was collected. This value is a timestamp in milliseconds.', example='1600822800000'),
          value?: string(name='Value', description='The value of the metric.', example='10'),
        }
      ](name='PerformanceItemValue')
      }(name='Points', description='The list of the performance metrics.'),
    }
  ](name='PerformanceItem')
  }(name='PerformanceKeys', description='Details about the performance metrics.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='35D3E3DA-4650-407A-BFF5-59BFF1******'),
  startTime?: string(name='StartTime', description='The start time of the query. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-09-23T01:00:00Z'),
}

model DescribeDBProxyPerformanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBProxyPerformanceResponseBody(name='body'),
}

/**
  * @description > This operation is applicable only to PolarDB for MySQL clusters.
  * @param request  the request parameters of DescribeDBProxyPerformance  DescribeDBProxyPerformanceRequest
  * @return DescribeDBProxyPerformanceResponse
 */
async function describeDBProxyPerformance(request: DescribeDBProxyPerformanceRequest): DescribeDBProxyPerformanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBProxyPerformance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDasConfigRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pc-****************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDasConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='593AE1C5-B70C-463F-9207-074639******'),
  storageAutoScale?: string(name='StorageAutoScale', description='Specifies whether to enable automatic storage scaling for the Standard Edition cluster. Valid values:

*   Enable
*   Disable', example='Enable'),
  storageUpperBound?: long(name='StorageUpperBound', description='The maximum storage capacity that is allowed for storage automatic scaling of the Standard Edition cluster. Unit: GB.

>  This parameter is valid only when the StorageAutoScale parameter is set to Enable.', example='800'),
}

model DescribeDasConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDasConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDasConfig  DescribeDasConfigRequest
  * @return DescribeDasConfigResponse
 */
async function describeDasConfig(request: DescribeDasConfigRequest): DescribeDasConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDasConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDatabasesRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-**************', position='Query'),
  DBName?: string(name='DBName', description='The name of the database.

> You cannot specify multiple database names.', example='test_db', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value must be a positive integer that does not exceed the maximum value of the INTEGER data type. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDatabasesResponseBody = {
  databases?: {
    database?: [ 
    {
      accounts?: {
        account?: [ 
        {
          accountName?: string(name='AccountName', description='The username of the account.

> A PolarDB for MySQL cluster does not support privileged accounts.', example='test_acc'),
          accountPrivilege?: string(name='AccountPrivilege', description='The permissions that are granted to the account. Valid values:

*   **ReadWrite**: read and write permissions
*   **ReadOnly**: read-only permissions
*   **DMLOnly**: The account is granted the permissions to execute only DML statements on the database.
*   **DDLOnly**: The account is granted the permissions to execute only DDL statements on the database.
*   **ReadIndex**: The account has the read and index permissions on the database.', example='ReadOnly'),
          accountStatus?: string(name='AccountStatus', description='The state of the account. Valid values:

*   **Creating**
*   **Available**
*   **Deleting**', example='Available'),
          privilegeStatus?: string(name='PrivilegeStatus', description='The authorization state of the account. Valid values:

*   **Empowering**: The system is granting permissions to the account.
*   **Empowered**: Permissions are granted to the account.
*   **Removing**: The system is revoking permissions from the account.', example='Empowered'),
        }
      ](name='Account')
      }(name='Accounts', description='Details about the accounts.

> A PolarDB for MySQL cluster does not support privileged accounts.'),
      characterSetName?: string(name='CharacterSetName', description='The character set that the database uses. For more information, see [Character set tables](https://help.aliyun.com/document_detail/99716.html).', example='utf8mb4'),
      DBDescription?: string(name='DBDescription', description='The description of the database.', example='test_des'),
      DBName?: string(name='DBName', description='The name of the database.', example='test_db'),
      DBStatus?: string(name='DBStatus', description='The state of the database. Valid values:

*   **Creating**
*   **Running**
*   **Deleting**', example='Running'),
      engine?: string(name='Engine', description='The type of the database engine. Valid values:

*   **MySQL**
*   **Oracle**
*   **PostgreSQL**', example='MySQL'),
      masterID?: string(name='MasterID', description='The ID of the primary node in the cluster of Multi-master Cluster (Database/Table) Edition.', example='2'),
    }
  ](name='Database')
  }(name='Databases', description='Details about databases.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of entries per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E1DF8CA6-2300-448B-9ABF-760C4B******'),
}

model DescribeDatabasesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDatabasesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDatabases  DescribeDatabasesRequest
  * @return DescribeDatabasesResponse
 */
async function describeDatabases(request: DescribeDatabasesRequest): DescribeDatabasesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDatabases', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDetachedBackupsRequest {
  backupId?: string(name='BackupId', description='The ID of the backup set.', example='111111111', position='Query'),
  backupMode?: string(name='BackupMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Manual', position='Query'),
  backupRegion?: string(name='BackupRegion', description='The region where the cross-region data backup file of the instance is stored.

> This parameter is valid only for PolarDB for MySQL clusters.', example='cn-hangzhou', position='Query'),
  backupStatus?: string(name='BackupStatus', description='The status of the backup set. Valid values:

*   **Success**
*   **Failed**', example='Success', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-****************', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. Specify the time in the `YYYY-MM-DDThh:mmZ` format. The time must be in UTC. The end time must be later than the start time.

This parameter is required.', example='2020-05-14T00:00Z', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value must be a positive integer that does not exceed the maximum value of the INTEGER data type. Default value: **1**.', example='1', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30', minimum=30, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-05-01T00:00Z', position='Query'),
}

model DescribeDetachedBackupsResponseBody = {
  items?: {
    backup?: [ 
    {
      backupEndTime?: string(name='BackupEndTime', description='The end time of the backup task. The time is displayed in UTC.', example='2020-05-12T03:25:55Z'),
      backupId?: string(name='BackupId', description='The ID of the backup set.', example='111111111'),
      backupMethod?: string(name='BackupMethod', description='The backup method. Only snapshot backups are supported. The value is set to **Snapshot**.', example='Snapshot'),
      backupMode?: string(name='BackupMode', description='The backup mode. Valid values:

*   **Automated**
*   **Manual**', example='Manual'),
      backupSetSize?: string(name='BackupSetSize', description='The size of the backup set. Unit: bytes.

> After you delete the target snapshot backups, the storage space consumed by the backups is released. The released storage space is smaller than the size of the backup file, because the snapshots share certain data blocks.', example='7251056'),
      backupStartTime?: string(name='BackupStartTime', description='The start time of the backup task. The time is displayed in UTC.', example='2020-05-12T03:25:44Z'),
      backupStatus?: string(name='BackupStatus', description='The status of the backup set. Valid values:

*   **Success**
*   **Failed**', example='Success'),
      backupType?: string(name='BackupType', description='The type of the backup. Only full backups are supported. The value is set to **FullBackup**.', example='FullBackup'),
      backupsLevel?: string(name='BackupsLevel', description='The level of the backup set. Valid values:

*   **Level-1**: level-1 backup set
*   **Level-2**: level-2 backup set', example='Level-2'),
      consistentTime?: string(name='ConsistentTime', description='The snapshot checkpoint time. The value is a Unix timestamp.', example='1589253947'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-**************'),
      isAvail?: string(name='IsAvail', description='Indicates whether the backup set is available. Valid values:

*   **0**: The data backup set is unavailable.
*   **1**: The data backup set is available.', example='1'),
      storeStatus?: string(name='StoreStatus', description='Indicates whether the backup set can be deleted. Valid values:

*   **Enabled**: The backup set can be deleted.
*   **Disabled**: The backup set cannot be deleted.', example='Disabled'),
    }
  ](name='Backup')
  }(name='Items', description='Details about the backup sets.'),
  pageNumber?: string(name='PageNumber', description='The page number.', example='1'),
  pageRecordCount?: string(name='PageRecordCount', description='The number of entries per page.', example='15'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='717B2382-BB14-4DCB-BBC2-32DBE0******'),
  totalRecordCount?: string(name='TotalRecordCount', description='The total number of returned entries.', example='50'),
}

model DescribeDetachedBackupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDetachedBackupsResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that the PolarDB cluster is in the **Released** state. You must also confirm that the **Retain All Backups Permanently** or **Retain Last Automatic Backup Permanently** backup retention policy takes effect after you release the cluster. If you delete all backup sets after the cluster is released, you cannot use this API operation to query the cluster.
  * >  You can call the [DescribeDBClusterAttribute](https://help.aliyun.com/document_detail/98181.html) operation to query the cluster status.
  * @param request  the request parameters of DescribeDetachedBackups  DescribeDetachedBackupsRequest
  * @return DescribeDetachedBackupsResponse
 */
async function describeDetachedBackups(request: DescribeDetachedBackupsRequest): DescribeDetachedBackupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDetachedBackups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGlobalDatabaseNetworkRequest {
  regionId?: string(name='RegionId', position='Host'),
  GDNId: string(name='GDNId', description='The ID of the GDN.

This parameter is required.', example='gdn-bp1fttxsrmv*****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeGlobalDatabaseNetworkResponseBody = {
  connections?: [ 
    {
      connectionString?: string(name='ConnectionString', description='The endpoint URL of the database service.', example='abc.polardb.rds.aliyuncs.com'),
      netType?: string(name='NetType', description='The network type for the database connection.', example='Private'),
      port?: string(name='Port', description='The port number for the database connection.', example='3306'),
    }
  ](name='Connections', description='The information about the connection to the cluster.'),
  createTime?: string(name='CreateTime', description='The time at which the GDN was created.', example='2020-02-24T11:57:54Z'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-bp1s826a1up******'),
  DBClusters?: [ 
    {
      category?: string(name='Category', description='The edition of the cluster. Valid values:

Normal: Cluster Edition Basic: Single Node Edition Archive: X-Engine Edition NormalMultimaster: Multi-master Cluster Edition SENormal: Standard Edition

> 

*   PolarDB for PostgreSQL clusters that run the PostgreSQL 11 database engine do not support Single Node Edition.

*   PolarDB for MySQL 8.0 and 5.7 clusters, and PolarDB for PostgreSQL clusters that run the PostgreSQL 14 database engine support Standard Edition.

*   PolarDB for MySQL 8.0 clusters support X-Engine Edition and Multi-master Cluster Edition.', example='Normal'),
      DBClusterDescription?: string(name='DBClusterDescription', description='The description of the cluster.', example='test'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-wz9fb5nn44u1d****'),
      DBClusterStatus?: string(name='DBClusterStatus', description='The status of the cluster. For more information, see [Cluster status table](https://help.aliyun.com/document_detail/99286.html).', example='Running'),
      DBNodeClass?: string(name='DBNodeClass', description='The node specifications of the cluster.', example='polar.mysql.x4.large'),
      DBNodes?: [ 
        {
          creationTime?: string(name='CreationTime', description='The time when the node was created.', example='2020-03-23T21:35:43Z'),
          DBNodeClass?: string(name='DBNodeClass', description='The specifications of the node.', example='polar.mysql.x4.large'),
          DBNodeId?: string(name='DBNodeId', description='The node ID.', example='pi-****************'),
          DBNodeRole?: string(name='DBNodeRole', description='The role of the node. Valid values:

*   **Writer**: the primary node
*   **Reader**: a read-only node', example='Reader'),
          DBNodeStatus?: string(name='DBNodeStatus', description='The status of the node. Valid values:

*   **Creating**: The node is being created.
*   **Running**: The node is running.
*   **Deleting**: The node is being deleted.
*   **Rebooting**: The node is restarting.
*   **ClassChanging**: The specifications of the node are being changed.
*   **NetAddressCreating**: The network connection is being created.
*   **NetAddressDeleting**: The network connection is being deleted.
*   **NetAddressModifying**: The network connection is being modified.
*   **MinorVersionUpgrading**: The minor version of the node is being updated.
*   **Maintaining**: The node is being maintained.
*   **Switching**: A failover is being performed.', example='Running'),
          failoverPriority?: int32(name='FailoverPriority', description='The failover priority. Each node is assigned a failover priority. The failover priority determines which node is selected as the primary node when a failover occurs. A larger value indicates a higher priority. Valid values: 1 to 15.', example='1'),
          maxConnections?: int32(name='MaxConnections', description='The maximum number of concurrent connections.', example='8000'),
          maxIOPS?: int32(name='MaxIOPS', description='The maximum input/output operations per second (IOPS).', example='32000'),
          zoneId?: string(name='ZoneId', description='The zone ID of the node.', example='cn-hangzhou-i'),
        }
      ](name='DBNodes', description='The nodes of the cluster.'),
      DBType?: string(name='DBType', description='The database engine type of the cluster. Only MySQL is supported.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine. Only version 8.0 is supported.', example='8.0'),
      expireTime?: string(name='ExpireTime', description='The expiration time of the cluster.

>  A specific value is returned only for subscription (**Prepaid**) clusters. No value is returned for pay-as-you-go (**Postpaid**) clusters.', example='2020-11-14T16:00:00Z'),
      expired?: string(name='Expired', description='Indicates whether the cluster has expired. Valid values:

*   **true** (default)
*   **false**

>  This parameter is returned only for subscription (**Prepaid**) clusters.', example='false'),
      payType?: string(name='PayType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go
*   **Prepaid**: subscription', example='Prepaid'),
      regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
      replicaLag?: string(name='ReplicaLag', description='The cross-region data replication latency between the primary cluster and secondary clusters. Unit: seconds.', example='1'),
      role?: string(name='Role', description='The role of the cluster. Valid values:

*   **Primary**: the primary cluster
*   **standby**: a secondary cluster

>  A GDN consists of one primary cluster and up to four secondary clusters.', example='primary'),
      serverlessType?: string(name='ServerlessType', description='Indicates whether the cluster is a serverless cluster. The value is fixed at AgileServerless.

>  This parameter is returned only for serverless clusters.', example='AgileServerless'),
      storageUsed?: string(name='StorageUsed', description='The storage usage of the cluster. Unit: bytes.', example='3012558848'),
    }
  ](name='DBClusters', description='The clusters in the GDN.'),
  DBType?: string(name='DBType', description='The type of the database engine. Only MySQL is supported.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine. Only version 8.0 is supported.', example='8.0'),
  GDNDescription?: string(name='GDNDescription', description='The description of the GDN. The description must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must start with a letter.
*   It can contain letters, digits, underscores (_), and hyphens (-).
*   It must be 2 to 126 characters in length.', example='GDN-fortest'),
  GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gdn-bp1fttxsrmv*****'),
  GDNStatus?: string(name='GDNStatus', description='The status of the GDN. Valid values:

*   **Creating**: The GDN is being created.
*   **active**: The GDN is running.
*   **deleting**: The GDN is being deleted.
*   **locked**: The GDN is locked. If the GDN is locked, you cannot perform operations on clusters in the GDN.
*   **removing_member**: The secondary cluster is being removed from the GDN.', example='active'),
  globalDomainName?: string(name='GlobalDomainName', description='The global domain name.', example='[gdnid].gdn.rds.aliyuncs.com'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='67F2E75F-AE67-4FB2-821F-A81237EACD15'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************'),
}

model DescribeGlobalDatabaseNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGlobalDatabaseNetworkResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGlobalDatabaseNetwork  DescribeGlobalDatabaseNetworkRequest
  * @return DescribeGlobalDatabaseNetworkResponse
 */
async function describeGlobalDatabaseNetwork(request: DescribeGlobalDatabaseNetworkRequest): DescribeGlobalDatabaseNetworkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGlobalDatabaseNetwork', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGlobalDatabaseNetworksRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.', example='pc-**************', position='Query'),
  filterRegion?: string(name='FilterRegion', description='Specify the region in which you want to query GDNs. You can create secondary clusters for the GDNs.', example='cn-beijing', position='Query'),
  GDNDescription?: string(name='GDNDescription', description='The description of the GDN. The description must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must start with a letter.
*   It can contain letters, digits, underscores (_), and hyphens (-).
*   It must be 2 to 126 characters in length.', example='test', position='Query'),
  GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gdn-****************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Default value: 1. The value must be an integer that is greater than 0.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 30. Valid values:

*   30
*   50
*   100', example='30', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeGlobalDatabaseNetworksResponseBody = {
  items?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the GDN was created. The time is in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.', example='2020-03-23T05:46:54Z'),
      DBClusters?: [ 
        {
          DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-****************'),
          regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
          role?: string(name='Role', description='The role of the cluster. Valid values:

*   **Primary**: the primary cluster
*   **standby**: the secondary cluster

> A GDN consists of one primary cluster and up to four secondary clusters. For more information, see [GDN](https://help.aliyun.com/document_detail/160381.html).', example='primary'),
        }
      ](name='DBClusters', description='Details about clusters in the GDN.'),
      DBType?: string(name='DBType', description='The type of the database engine. Only **MySQL** is supported.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine. Only the **8.0** version is supported.', example='8.0'),
      GDNDescription?: string(name='GDNDescription', description='The description of the GDN. The description must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must start with a letter.
*   It can contain letters, digits, underscores (_), and hyphens (-).
*   It must be 2 to 126 characters in length.', example='test'),
      GDNId?: string(name='GDNId', description='The ID of the GDN.', example='gdn-****************'),
      GDNStatus?: string(name='GDNStatus', description='The status of the GDN. Valid values:

*   **Creating**: The GDN is being created.
*   **active**: The GDN is running.
*   **deleting**: The GDN is being deleted.
*   **locked**: The GDN is locked. If the GDN is locked, you cannot perform operations on clusters in the GDN.
*   **removing_member**: The secondary cluster is being removed from the GDN.', example='active'),
    }
  ](name='Items', description='Details about the GDNs.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of records on the current page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='69A85BAF-1089-4CDF-A82F-0A140F******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of returned entries.', example='1'),
}

model DescribeGlobalDatabaseNetworksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGlobalDatabaseNetworksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGlobalDatabaseNetworks  DescribeGlobalDatabaseNetworksRequest
  * @return DescribeGlobalDatabaseNetworksResponse
 */
async function describeGlobalDatabaseNetworks(request: DescribeGlobalDatabaseNetworksRequest): DescribeGlobalDatabaseNetworksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGlobalDatabaseNetworks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGlobalSecurityIPGroupRequest {
  globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the IP whitelist template.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeGlobalSecurityIPGroupResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      DBInstances?: [ string ](name='DBInstances', description='The details of the clusters that are associated with the global IP address whitelist template.'),
      gIpList?: string(name='GIpList', description='The IP address in the global IP whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the global IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the global IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroup', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model DescribeGlobalSecurityIPGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGlobalSecurityIPGroupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGlobalSecurityIPGroup  DescribeGlobalSecurityIPGroupRequest
  * @return DescribeGlobalSecurityIPGroupResponse
 */
async function describeGlobalSecurityIPGroup(request: DescribeGlobalSecurityIPGroupRequest): DescribeGlobalSecurityIPGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGlobalSecurityIPGroup', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGlobalSecurityIPGroupRelationRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-*****************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the IP whitelist template.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeGlobalSecurityIPGroupRelationResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-*****************'),
  globalSecurityIPGroupRel?: [ 
    {
      gIpList?: string(name='GIpList', description='The IP address in the global IP whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the global IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the global IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroupRel', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model DescribeGlobalSecurityIPGroupRelationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGlobalSecurityIPGroupRelationResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeGlobalSecurityIPGroupRelation  DescribeGlobalSecurityIPGroupRelationRequest
  * @return DescribeGlobalSecurityIPGroupRelationResponse
 */
async function describeGlobalSecurityIPGroupRelation(request: DescribeGlobalSecurityIPGroupRelationRequest): DescribeGlobalSecurityIPGroupRelationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGlobalSecurityIPGroupRelation', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHistoryTasksRequest {
  fromExecTime?: int32(name='FromExecTime', example='0', position='Query'),
  fromStartTime: string(name='FromStartTime', description='This parameter is required.', example='2025-01-02T11:31:03Z', position='Query'),
  instanceId?: string(name='InstanceId', example='pc-2zed3m89cw***', position='Query'),
  instanceType?: string(name='InstanceType', example='Instance', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', example='1', position='Query'),
  pageSize?: int32(name='PageSize', example='10', position='Query'),
  regionId?: string(name='RegionId', example='cn-beijing', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-************', position='Query'),
  resourceOwnerAccount?: long(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  status?: string(name='Status', example='Running', position='Query'),
  taskId?: string(name='TaskId', example='t-0mqi38ho0cgjv***', position='Query'),
  taskType?: string(name='TaskType', example='ChangeVariable', position='Query'),
  toExecTime?: int32(name='ToExecTime', example='0', position='Query'),
  toStartTime: string(name='ToStartTime', description='This parameter is required.', example='2025-01-03T11:31:03Z', position='Query'),
}

model DescribeHistoryTasksResponseBody = {
  items?: [ 
    {
      actionInfo?: string(name='ActionInfo', example='{}'),
      callerSource?: string(name='CallerSource', example='User'),
      callerUid?: string(name='CallerUid', example='1816563541899***'),
      currentStepName?: string(name='CurrentStepName', example='finish_task'),
      dbType?: string(name='DbType', example='polardb_mysql'),
      endTime?: string(name='EndTime', example='2025-03-03T07:30:57Z'),
      instanceId?: string(name='InstanceId', example='pc-2zed3m89cw***'),
      instanceName?: string(name='InstanceName', example='pc-2zed3m89cw***'),
      instanceType?: string(name='InstanceType', example='Instance'),
      product?: string(name='Product', example='polardb'),
      progress?: float(name='Progress', example='100.0'),
      reasonCode?: string(name='ReasonCode', example='""'),
      regionId?: string(name='RegionId', example='cn-beijing'),
      remainTime?: int32(name='RemainTime', example='0'),
      startTime?: string(name='StartTime', example='2025-03-03T07:25:16Z'),
      status?: string(name='Status', example='Succeed'),
      taskDetail?: string(name='TaskDetail', example='{\\"steps\\":[{\\"step_name\\":\\"init_task\\"},{\\"step_name\\":\\"exec_task\\"},{\\"step_name\\":\\"finish_task\\"}]}'),
      taskId?: string(name='TaskId', example='t-0mqt8qhnw04ipz0***'),
      taskType?: string(name='TaskType', example='ChangeVariable'),
      uid?: string(name='Uid', example='1816563541899***'),
    }
  ](name='Items'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
  requestId?: string(name='RequestId', example='F90D7C14-2D1C-5B88-9CD1-23AB2CF89***'),
  totalCount?: string(name='TotalCount', example='2'),
}

model DescribeHistoryTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHistoryTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeHistoryTasks  DescribeHistoryTasksRequest
  * @return DescribeHistoryTasksResponse
 */
async function describeHistoryTasks(request: DescribeHistoryTasksRequest): DescribeHistoryTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHistoryTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLicenseOrderDetailsRequest {
  aliyunOrderId: string(name='AliyunOrderId', description='The Alibaba Cloud order ID (or virtual order ID).

This parameter is required.', example='239618016570503', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeLicenseOrderDetailsResponseBody = {
  activatedCodeCount?: int32(name='ActivatedCodeCount', description='The number of generated activation codes.', example='2'),
  activationCodeQuota?: int32(name='ActivationCodeQuota', description='The maximum number of activation codes that you can apply for.', example='8'),
  aliyunOrderId?: string(name='AliyunOrderId', description='The Alibaba Cloud order ID (including the virtual order ID).', example='239618016570503'),
  allowEmptySystemIdentifier?: boolean(name='AllowEmptySystemIdentifier', description='Indicates whether activation codes can be generated without the system identifier.', example='false'),
  engine?: string(name='Engine', description='The type of the engine. Valid values: PG, Oracle, and MySQL.', example='PG'),
  gmtCreated?: string(name='GmtCreated', description='The time when the order was created.', example='2021-10-19 01:13:45'),
  gmtModified?: string(name='GmtModified', description='The time when the order was last updated.', example='2024-10-16 16:46:20'),
  isVirtualOrder?: boolean(name='IsVirtualOrder', description='Indicates whether the order is a virtual order (virtual orders allow pre-generation of activation codes).', example='false'),
  isVirtualOrderFrozen?: boolean(name='IsVirtualOrderFrozen', description='Indicates whether the virtual order is frozen (activation codes cannot be generated for a frozen virtual order).', example='false'),
  packageType?: string(name='PackageType', description='The plan type. Valid values:

*   single_node_subscribe
*   single_node_long_term
*   primary_backup_subscribe
*   primary_backup_long_term
*   pre_generation_long_term', example='pre_generation_long_term'),
  packageValidity?: string(name='PackageValidity', description='The validity period of the plan, which is one year (common) or thirty years (long-term).', example='1 year'),
  purchaseChannel?: string(name='PurchaseChannel', description='The plan validity period, one year (common) or thirty years (long-term).', example='aliyun_market'),
  requestId?: string(name='RequestId', description='The request ID.', example='22C0ACF0-DD29-4B67-9190-B7A48C******'),
  virtualOrderId?: string(name='VirtualOrderId', description='The virtual order ID.', example='239618016570503'),
}

model DescribeLicenseOrderDetailsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLicenseOrderDetailsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeLicenseOrderDetails  DescribeLicenseOrderDetailsRequest
  * @return DescribeLicenseOrderDetailsResponse
 */
async function describeLicenseOrderDetails(request: DescribeLicenseOrderDetailsRequest): DescribeLicenseOrderDetailsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLicenseOrderDetails', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLicenseOrdersRequest {
  aliyunOrderId?: string(name='AliyunOrderId', description='The ID of the Alibaba Cloud order. The value can be the ID of a virtual order.', example='239618016570503', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  packageType?: string(name='PackageType', description='The plan type. Valid values:

*   single_node_subscribe: Single-node Edition (Subscription).
*   single_node_long_term: Single-node Edition (Long-term).
*   primary_backup_subscribe: HA Edition (Subscription).
*   primary_backup_long_term: HA Edition (Long-term).
*   pre_generation_long_term: Pre-generated (Long-term).', example='single_node_subscribe', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30', minimum=1, maximum=100, position='Query'),
  purchaseChannel?: string(name='PurchaseChannel', description='The purchase channel. Valid values: aliyun_market and aliyun_public. aliyun_market specifies Alibaba Cloud Marketplace. aliyun_public specifies the PolarDB buy page.', example='aliyun_market', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  virtualOrder?: boolean(name='VirtualOrder', description='Specifies whether to query only virtual orders.', example='true', position='Query'),
}

model DescribeLicenseOrdersResponseBody = {
  items?: [ 
    {
      activatedCodeCount?: int32(name='ActivatedCodeCount', description='The number of generated activation codes.', example='10'),
      activationCodeQuota?: int32(name='ActivationCodeQuota', description='The maximum number of activation codes that you can apply for.', example='10'),
      aliyunOrderId?: string(name='AliyunOrderId', description='The ID of the Alibaba Cloud order. The ID of a virtual order may be returned.', example='227638319690519'),
      allowEmptySystemIdentifier?: boolean(name='AllowEmptySystemIdentifier', description='Indicates whether the SystemIdentifier parameter can be left empty when the system generates an activation code.', example='false'),
      engine?: string(name='Engine', description='The engine of the PolarDB cluster. Valid values: PG, Oracle, and MySQL.', example='PG'),
      gmtCreated?: string(name='GmtCreated', description='The time when the order was created.', example='2022-02-11 03:14:15'),
      gmtModified?: string(name='GmtModified', description='The time when the order was updated.', example='2022-02-11 03:14:15'),
      isVirtualOrder?: boolean(name='IsVirtualOrder', description='Indicates whether the order is a virtual order. Pre-generation of activation codes is allowed for virtual orders.', example='false'),
      isVirtualOrderFrozen?: boolean(name='IsVirtualOrderFrozen', description='Indicates whether the virtual order is frozen. Generation of activation codes is not allowed for frozen virtual orders.', example='false'),
      packageType?: string(name='PackageType', description='The type of the package. Valid values:

*   single_node_subscribe: Single-node Edition (Subscription).
*   single_node_long_term: Single-node Edition (Long-term).
*   primary_backup_subscribe: HA Edition (Subscription).
*   primary_backup_long_term: HA Edition (Long-term).
*   pre_generation_long_term: Pre-generated (Long-term).', example='single_node_subscribe'),
      packageValidity?: string(name='PackageValidity', description='The validity period of the package. Valid values: 1 year and 30 years.', example='1 year'),
      purchaseChannel?: string(name='PurchaseChannel', description='The purchase channel. Valid values: aliyun_market and aliyun_public. aliyun_market indicates Alibaba Cloud Marketplace. aliyun_public indicates the PolarDB buy page.', example='aliyun_public'),
      virtualAliyunOrderId?: string(name='VirtualAliyunOrderId', description='The ID of the virtual order.', example='227638319690519'),
    }
  ](name='Items', description='The queried orders.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of entries returned on the current page.', example='12'),
  requestId?: string(name='RequestId', description='The request ID.', example='34458CD3-33E0-4624-BFEF-840C15******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of entries returned.', example='50'),
}

model DescribeLicenseOrdersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLicenseOrdersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeLicenseOrders  DescribeLicenseOrdersRequest
  * @return DescribeLicenseOrdersResponse
 */
async function describeLicenseOrders(request: DescribeLicenseOrdersRequest): DescribeLicenseOrdersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLicenseOrders', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLogBackupPolicyRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query all the information about the available clusters in the target region, including the cluster ID.

This parameter is required.', example='pc-*****************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeLogBackupPolicyResponseBody = {
  enableBackupLog?: int32(name='EnableBackupLog', description='Indicates whether the log backup feature is enabled. Valid values:

*   0: The log backup feature is disabled.
*   1: The log backup feature is enabled. By default, the log backup feature is enabled and cannot be disabled.', example='1'),
  logBackupAnotherRegionRegion?: string(name='LogBackupAnotherRegionRegion', description='The region in which you want to store cross-region log backups. For more information about regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='cn-beijing'),
  logBackupAnotherRegionRetentionPeriod?: string(name='LogBackupAnotherRegionRetentionPeriod', description='The retention period of cross-region log backups. Valid values:

*   **0**: The cross-region backup feature is disabled.
*   **30 to 7300**: Cross-region log backups are retained for 30 to 7,300 days.
*   **-1**: The log backups are permanently retained.

>  When you create a cluster, the default value of this parameter is **0**.', example='0'),
  logBackupRetentionPeriod?: int32(name='LogBackupRetentionPeriod', description='The retention period of the log backups. Valid values:

*   3 to 7300: The log backups are retained for 3 to 7,300 days.
*   \\-1: The log backups are permanently retained.', example='7'),
  requestId?: string(name='RequestId', description='The request ID.', example='62EE0051-102B-488D-9C79-D607B8******'),
}

model DescribeLogBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLogBackupPolicyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeLogBackupPolicy  DescribeLogBackupPolicyRequest
  * @return DescribeLogBackupPolicyResponse
 */
async function describeLogBackupPolicy(request: DescribeLogBackupPolicyRequest): DescribeLogBackupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLogBackupPolicy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMaskingRulesRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pc-*****************', position='Query'),
  interfaceVersion?: string(name='InterfaceVersion', position='Query'),
  ruleNameList?: string(name='RuleNameList', description='The name of the masking rule.', example='testrule', position='Query'),
}

model DescribeMaskingRulesResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-bp1s826a1up******'),
  data?: {
    ruleList?: [ string ](name='RuleList', description='Details about the masking rules.'),
    ruleVersion?: string(name='RuleVersion', description='The version of the masking rule. Valid values: v1 and v2. Default value: v1', example='v1'),
  }(name='Data', description='The result data that is returned.'),
  message?: string(name='Message', description='The message that is returned for the request.

> If the request is successful, Successful is returned. If the request fails, an error message such as an error code is returned.', example='Successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2F83D131-1C18-4599-889D-729A9D******'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid value:

*   **true**
*   **false**', example='true'),
}

model DescribeMaskingRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMaskingRulesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeMaskingRules  DescribeMaskingRulesRequest
  * @return DescribeMaskingRulesResponse
 */
async function describeMaskingRules(request: DescribeMaskingRulesRequest): DescribeMaskingRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMaskingRules', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMetaListRequest {
  regionId?: string(name='RegionId', position='Host'),
  backupId?: string(name='BackupId', description='The ID of the data backup file.

>*   When you run a query, you must specify the `BackId` or `RestoreTime` parameter.
>*   You can call the [DescribeBackups](https://help.aliyun.com/document_detail/98102.html) operation to query the ID of the backup set.', example='111111', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of all clusters under your account.

This parameter is required.', example='pc-**************', position='Query'),
  getDbName?: string(name='GetDbName', description='Specify the specific database name (such as `test_db`) to query the names of all data tables that can be restored in the desired database.

>*   You can specify only one database name each time.
>*   If you do not specify this parameter, you can query the names of all databases that can be restored in the current backup set. However, you cannot query the names of data tables in each database.', example='test_db', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. The value must be an integer that is greater than 0. Default value: **1**.', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values:

*   **30**

*   **50**

*   **100**

    Default value: **30**.', example='30', minimum=1, maximum=500, position='Query'),
  regionCode?: string(name='RegionCode', description='The ID of the region in which the instance resides. You can call the [DescribeDBClusterAttribute](https://help.aliyun.com/document_detail/2319132.html) operation to query the region ID of the instance.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restoreTime?: string(name='RestoreTime', description='The point in time for the restoration. Specify the time in the YYYY-MM-DDThh:mmZ format. The time must be in UTC.

>  When you run a query, you must specify the `BackId` or `RestoreTime` parameter. You can call the [DescribeBackups](https://help.aliyun.com/document_detail/98102.html) operation to query the point in time for the restoration.', example='2020-10-04T01:40:00Z', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeMetaListResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-bp1s826a1up******'),
  items?: [ 
    {
      database?: string(name='Database', description='The name of the database that can be restored.', example='test_db'),
      tables?: [ string ](name='Tables', description='The name of the table that can be restored.'),
    }
  ](name='Items', description='The details of databases and tables that can be restored.'),
  pageNumber?: string(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='AA815DE7-B576-4B22-B33C-3FB31A******'),
  totalPageCount?: string(name='TotalPageCount', description='The total number of returned pages.', example='1'),
  totalRecordCount?: string(name='TotalRecordCount', description='The total number of entries.', example='2'),
}

model DescribeMetaListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMetaListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeMetaList  DescribeMetaListRequest
  * @return DescribeMetaListResponse
 */
async function describeMetaList(request: DescribeMetaListRequest): DescribeMetaListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMetaList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeParameterGroupRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  parameterGroupId: string(name='ParameterGroupId', description='The ID of the parameter template.

> You can call the [DescribeParameterGroups](https://help.aliyun.com/document_detail/207178.html) operation to query the details of all parameter templates of a specified region, such as the ID of a parameter template.

This parameter is required.', example='pcpg-**************', position='Query'),
  regionId: string(name='RegionId', description='The region ID.

>You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query all regions that are available within your account, such as the region ID.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeParameterGroupResponseBody = {
  parameterGroup?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the parameter template was created. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2023-03-10T08:40:39Z'),
      DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='8.0'),
      forceRestart?: string(name='ForceRestart', description='Indicates whether to restart the cluster when this parameter template is applied. Valid values:

*   **0**: A restart is not required.
*   **1**: A restart is required.', example='1'),
      parameterCounts?: int32(name='ParameterCounts', description='The number of parameters in the parameter template.', example='2'),
      parameterDetail?: [ 
        {
          paramName?: string(name='ParamName', description='The name of the parameter.', example='back_log'),
          paramValue?: string(name='ParamValue', description='The value of the parameter.', example='3000'),
        }
      ](name='ParameterDetail', description='Details about the parameters.'),
      parameterGroupDesc?: string(name='ParameterGroupDesc', description='The description of the parameter template.', example='testgroup'),
      parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template.', example='pcpg-**************'),
      parameterGroupName?: string(name='ParameterGroupName', description='The name of the parameter template.', example='test'),
      parameterGroupType?: string(name='ParameterGroupType', description='The type of the parameter template. Valid values:

*   **0**: the default parameter template.
*   **1**: a custom parameter template.
*   **2**: an automatic backup parameter template. After you apply this type of template, the system automatically backs up the original parameter settings and saves the backup as a template.', example='1'),
    }
  ](name='ParameterGroup', description='Details about the parameter templates.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F1F16757-D31B-49CA-9BF4-305BAF******'),
}

model DescribeParameterGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeParameterGroupResponseBody(name='body'),
}

/**
  * @description You can use parameter templates to manage multiple parameters at a time and apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](https://help.aliyun.com/document_detail/207009.html).
  * > This parameter is valid only for a PolarDB for MySQL cluster.
  * @param request  the request parameters of DescribeParameterGroup  DescribeParameterGroupRequest
  * @return DescribeParameterGroupResponse
 */
async function describeParameterGroup(request: DescribeParameterGroupRequest): DescribeParameterGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeParameterGroup', 'POST', '/', 'json', false, 'json', request);
}

model DescribeParameterGroupsRequest {
  DBType?: string(name='DBType', description='The type of the database engine. Only **MySQL** is supported.', example='MySQL', position='Query'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine. Valid values:

*   **5.6**
*   **5.7**
*   **8.0**', example='8.0', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the cluster.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query all regions that are available for your account, such as the region ID.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the virtual node belongs.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeParameterGroupsResponseBody = {
  parameterGroups?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the parameter template was created. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2023-03-10T08:40:39Z'),
      DBType?: string(name='DBType', description='The type of the engine.', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine', example='8.0'),
      forceRestart?: string(name='ForceRestart', description='Indicates whether to restart the cluster when this parameter template is applied. Valid values:

*   **0**: A restart is not required.
*   **1**: A restart is required.', example='1'),
      parameterCounts?: long(name='ParameterCounts', description='The number of parameters in the parameter template.', example='2'),
      parameterGroupDesc?: string(name='ParameterGroupDesc', description='The description of the parameter template.', example='testgroup'),
      parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template.', example='pcpg-**************'),
      parameterGroupName?: string(name='ParameterGroupName', description='The name of the parameter template.', example='test'),
      parameterGroupType?: string(name='ParameterGroupType', description='The type of the parameter template. Valid values:

*   **0**: the default parameter template.
*   **1**: a custom parameter template.
*   **2**: an automatic backup parameter template. After you apply this type of template, the system automatically backs up the original parameter settings and saves the backup as a template.', example='1'),
    }
  ](name='ParameterGroups', description='The details of parameter templates.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='944CED46-A6F7-40C6-B6DC-C6E5CC******'),
}

model DescribeParameterGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeParameterGroupsResponseBody(name='body'),
}

/**
  * @description You can use parameter templates to manage multiple parameters at a time and apply existing parameters to a PolarDB cluster. For more information, see [Use a parameter template](https://help.aliyun.com/document_detail/207009.html).
  * > This operation is applicable only to PolarDB for MySQL clusters.
  * @param request  the request parameters of DescribeParameterGroups  DescribeParameterGroupsRequest
  * @return DescribeParameterGroupsResponse
 */
async function describeParameterGroups(request: DescribeParameterGroupsRequest): DescribeParameterGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeParameterGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeParameterTemplatesRequest {
  DBType: string(name='DBType', description='The type of the database engine. Only **MySQL** is supported.

This parameter is required.', example='MySQL', position='Query'),
  DBVersion: string(name='DBVersion', description='The version of the database. Valid values:

*   **5.6**
*   **5.7**
*   **8.0**

This parameter is required.', example='5.7', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID.

>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query all regions that are available within your account, such as the region IDs.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeParameterTemplatesResponseBody = {
  DBType?: string(name='DBType', description='The type of the database engine.', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine.', example='5.7'),
  engine?: string(name='Engine', description='The database engine of the cluster.', example='POLARDB'),
  parameterCount?: string(name='ParameterCount', description='The number of parameters.', example='183'),
  parameters?: {
    templateRecord?: [ 
    {
      checkingCode?: string(name='CheckingCode', description='The valid values of the parameter.', example='[ROW|STATEMENT|MIXED]'),
      forceModify?: string(name='ForceModify', description='Indicates whether the parameter setting can be modified. Valid values:

*   **true**
*   **false**', example='true'),
      forceRestart?: string(name='ForceRestart', description='Indicates whether a cluster restart is required to make the parameter modification take effect. Valid values:

*   **true**
*   **false**', example='false'),
      isNodeAvailable?: string(name='IsNodeAvailable', description='Indicates whether the parameter is a global parameter. Valid values:

*   **0**: yes. The modified parameter value is synchronized to other nodes by default.
*   **1**: no. You can customize the nodes to which the modified parameter value can be synchronized.', example='1'),
      paramRelyRule?: string(name='ParamRelyRule', description='The parameter dependencies.', example='utf8'),
      parameterDescription?: string(name='ParameterDescription', description='The description of the parameter.', example='What form of binary logging the master will use.'),
      parameterName?: string(name='ParameterName', description='The name of the parameter.', example='binlog_format'),
      parameterValue?: string(name='ParameterValue', description='The default value of the parameter.', example='ROW'),
    }
  ](name='TemplateRecord')
  }(name='Parameters', description='The details of the parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D963934D-8605-4473-8EAC-54C719******'),
}

model DescribeParameterTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeParameterTemplatesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeParameterTemplates  DescribeParameterTemplatesRequest
  * @return DescribeParameterTemplatesResponse
 */
async function describeParameterTemplates(request: DescribeParameterTemplatesRequest): DescribeParameterTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeParameterTemplates', 'POST', '/', 'json', false, 'json', request);
}

model DescribePendingMaintenanceActionRequest {
  regionId?: string(name='RegionId', position='Host'),
  isHistory?: int32(name='IsHistory', description='Specifies whether to return the historical tasks. Valid values:

*   **0**: returns the current task.
*   **1**: returns the historical tasks.

Default value: **0**.', example='0', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Specify the parameter to a positive integer that does not exceed the maximum value of the INTEGER data type. Default value: **1**.', example='1', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **30**, **50**, and **100**.

Default value: **30**.', example='30', minimum=10, maximum=100, position='Query'),
  region: string(name='Region', description='The region ID of the pending event. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the regions and zones that are supported by PolarDB.
>- You can set this parameter to **all** to view all pending events within your account.
>- If you set `Region` to **all**, you must set `TaskType` to **all**.

This parameter is required.', example='all', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  taskType: string(name='TaskType', description='The task type of pending events. Valid values:

*   **DatabaseSoftwareUpgrading**: database software upgrades
*   **DatabaseHardwareMaintenance**: hardware maintenance and upgrades
*   **DatabaseStorageUpgrading**: database storage upgrades
*   **DatabaseProxyUpgrading**: minor version upgrades of the proxy
*   **all**: queries the details of the pending events of all preceding types.

> If the `Region` parameter is set to **all**, the `TaskType` parameter must be set to **all**.

This parameter is required.', example='all', position='Query'),
}

model DescribePendingMaintenanceActionResponseBody = {
  items?: [ 
    {
      createdTime?: string(name='CreatedTime', description='The time when the task was created. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-06-09T22:00:42Z'),
      DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-************'),
      DBType?: string(name='DBType', description='The type of the database engine. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL'),
      DBVersion?: string(name='DBVersion', description='The version of the database engine.

*   Valid values for the MySQL database engine:

    *   **5.6**
    *   **5.7**
    *   **8.0**

*   Valid values for the PostgreSQL database engine:

    *   **11**
    *   **14**

*   Valid value for the Oracle database engine: **11**', example='8.0'),
      deadline?: string(name='Deadline', description='The deadline before which the task can be executed. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-06-11T15:59:59Z'),
      id?: int32(name='Id', description='The ID of the task.', example='111111'),
      modifiedTime?: string(name='ModifiedTime', description='The time when the parameter was modified. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-06-09T22:00:42Z'),
      prepareInterval?: string(name='PrepareInterval', description='The preparation time that is required before the pending event is switched. The time follows the `HH:mm:ss` format.', example='04:00:00'),
      region?: string(name='Region', description='The region ID of the pending event.', example='cn-hangzhou'),
      resultInfo?: string(name='ResultInfo', description='The execution result of the task. Valid values:

*   **manualCancel**: The task is manually canceled.
*   **paramCheckNotPass**: The task fails to pass the parameter check.

> This parameter is returned only when the value of the `Status` parameter is **6** or **7**. The value 6 indicates that the task is completed but fails to be executed. The value 7 indicates that the task is canceled.', example='manualCancel'),
      startTime?: string(name='StartTime', description='The time when the task was executed in the background. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-06-09T18:00:00Z'),
      status?: int32(name='Status', description='The status of the pending task.

*   If you set the `IsHistory` parameter to **0**, the status of the pending task is returned. Valid values:

    *   **2**: The start time of the task is to be specified.
    *   **3**: The task is pending.
    *   **4**: The task is running. In this case, you cannot modify the execution time.

*   If you set the `IsHistory` parameter to **1**, the details of the historical tasks are returned. Valid values:

    *   **5**: The task is completed and executed.
    *   **6**: The task is completed but fails to be executed.
    *   **7**: The task is canceled.', example='3'),
      switchTime?: string(name='SwitchTime', description='The time when the pending event was switched. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2020-06-09T22:00:00Z'),
      taskType?: string(name='TaskType', description='The type of the pending event.', example='DatabaseSoftwareUpgrading'),
    }
  ](name='Items', description='Details about tasks.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2F029645-FED9-4FE8-A6D3-488954******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of returned entries.', example='1'),
}

model DescribePendingMaintenanceActionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePendingMaintenanceActionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePendingMaintenanceAction  DescribePendingMaintenanceActionRequest
  * @return DescribePendingMaintenanceActionResponse
 */
async function describePendingMaintenanceAction(request: DescribePendingMaintenanceActionRequest): DescribePendingMaintenanceActionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePendingMaintenanceAction', 'POST', '/', 'json', false, 'json', request);
}

model DescribePendingMaintenanceActionsRequest {
  isHistory?: int32(name='IsHistory', description='Specifies whether to return the historical tasks. Valid values:

*   **0**: returns the current task.
*   **1**: returns the historical tasks.

Default value: **0**.', example='1', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribePendingMaintenanceActionsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='314127C2-B6C1-4F58-B1F6-E6B645******'),
  typeList?: [ 
    {
      count?: int32(name='Count', description='The number of pending events.', example='1'),
      taskType?: string(name='TaskType', description='The task type of pending events. Valid values:

*   **DatabaseSoftwareUpgrading**: database software upgrades
*   **DatabaseHardwareMaintenance**: hardware maintenance and upgrades
*   **DatabaseStorageUpgrading**: database storage upgrades
*   **DatabaseProxyUpgrading**: minor version upgrades of the proxy', example='DatabaseSoftwareUpgrading'),
    }
  ](name='TypeList', description='The details of pending events.'),
}

model DescribePendingMaintenanceActionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePendingMaintenanceActionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePendingMaintenanceActions  DescribePendingMaintenanceActionsRequest
  * @return DescribePendingMaintenanceActionsResponse
 */
async function describePendingMaintenanceActions(request: DescribePendingMaintenanceActionsRequest): DescribePendingMaintenanceActionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePendingMaintenanceActions', 'POST', '/', 'json', false, 'json', request);
}

model DescribePolarSQLCollectorPolicyRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of all the clusters for your account, such as the cluster ID.

This parameter is required.', example='pc-****************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribePolarSQLCollectorPolicyResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The IDs of the clusters.', example='pc-bp1s826a1up******'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3655211B-4D74-4E13-91E6-FF2AFE******'),
  SQLCollectorStatus?: string(name='SQLCollectorStatus', description='Indicates whether the SQL Explorer feature is enabled. Valid values:

*   **Enable**
*   **Disabled**', example='Enable'),
}

model DescribePolarSQLCollectorPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePolarSQLCollectorPolicyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePolarSQLCollectorPolicy  DescribePolarSQLCollectorPolicyRequest
  * @return DescribePolarSQLCollectorPolicyResponse
 */
async function describePolarSQLCollectorPolicy(request: DescribePolarSQLCollectorPolicyRequest): DescribePolarSQLCollectorPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePolarSQLCollectorPolicy', 'GET', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      zones?: {
        zone?: [ 
        {
          vpcEnabled?: boolean(name='VpcEnabled', description='Indicates whether virtual private clouds (VPCs) are supported.', example='true'),
          zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-g'),
        }
      ](name='Zone')
      }(name='Zones', description='The list of zones.'),
    }
  ](name='Region')
  }(name='Regions', description='The list of regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3F9E6A3B-C13E-4064-A010-18582A******'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeRegions  DescribeRegionsRequest
  * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeScheduleTasksRequest {
  DBClusterDescription?: string(name='DBClusterDescription', description='The description of the cluster.', example='testdb', position='Query'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

> 

*   You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the information of all PolarDB clusters that are deployed in a specific region, such as the cluster IDs.

*   If you do not specify this parameter, all scheduled tasks on your clusters are queried.', example='pc-**************', position='Query'),
  orderId?: string(name='OrderId', description='The ID of the order.

>  The order ID can contain only digits.', example='20951253014****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. Set this parameter to an integer that is greater than 0. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: **30**, **50**, and **100**. Default value: 30.', example='30', position='Query'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time of the task that you specified when you created the scheduled task. The time is displayed in UTC.', example='2021-01-28T12:30Z', position='Query'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time of the task that you specified when you created the scheduled task. The time is displayed in UTC.', example='2021-01-28T12:00Z', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region.

> 

*   You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the region information of all clusters in a specific account.

*   If you do not specify this parameter, scheduled tasks on your clusters that are deployed in all regions are queried.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', description='The state of the tasks that you want to query. Valid values:

*   **pending**: The tasks are pending execution.
*   **executing**: The tasks are being executed.
*   **failure**: The tasks failed and need to be run again.
*   **finish**: The tasks are complete.
*   **cancel**: The tasks are canceled.
*   **expired**: The tasks are expired. The tasks are not started within the time periods that are specified to start the tasks.
*   **rollback**: The tasks are being rolled back.

>  If you do not specify this parameter, all scheduled tasks in all states are queried.', example='finish', position='Query'),
  taskAction?: string(name='TaskAction', description='The type of scheduled tasks that you want to query. Valid values:

*   **CreateDBNodes**
*   **ModifyDBNodeClass**
*   **UpgradeDBClusterVersion**
*   **ModifyDBClusterPrimaryZone**

> 

*   If you specify the `PlannedStartTime` parameter when you call the four preceding operations, the details of each task are returned. Otherwise, an empty string is returned for the `TimerInfos` parameter.

*   If you do not specify this parameter, all types of scheduled tasks on you clusters are queried.', example='CreateDBNodes', position='Query'),
}

model DescribeScheduleTasksResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber', description='The page number of the page returned.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
    timerInfos?: [ 
      {
        action?: string(name='Action', description='The type of the scheduled tasks.', example='CreateDBNodes'),
        crontabJobId?: string(name='CrontabJobId', description='The ID of the scheduled task.', example='86293c29-a03d-4872-b625-***********'),
        DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-**************'),
        dbClusterDescription?: string(name='DbClusterDescription', description='The description of the cluster.', example='test_cluster'),
        dbClusterStatus?: string(name='DbClusterStatus', description='The state of the cluster.', example='Running'),
        orderId?: string(name='OrderId', description='The ID of the order.

>  This parameter is returned only when you set the `Action` parameter to **CreateDBNodes** or **ModifyDBNodeClass**.', example='208161753******'),
        plannedEndTime?: string(name='PlannedEndTime', description='The latest start time of the task that you specified when you created the scheduled task. The time is displayed in UTC.', example='2021-01-28T12:30Z'),
        plannedFlashingOffTime?: string(name='PlannedFlashingOffTime'),
        plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time of the task that you specified when you created the scheduled task. The time is displayed in UTC.', example='2021-01-28T12:00Z'),
        plannedTime?: string(name='PlannedTime', description='The expected start time of the task. The time is displayed in UTC.', example='2021-01-28T12:16Z'),
        region?: string(name='Region', description='The ID of the region in which the scheduled task runs.', example='cn-hangzhou'),
        status?: string(name='Status', description='The state of the scheduled task.', example='finish'),
        taskCancel?: boolean(name='TaskCancel', description='Indicates whether the scheduled task can be canceled. Valid values:

*   **true**
*   **false**', example='true'),
        taskId?: string(name='TaskId', description='The ID of the task.', example='53879cdb-9a00-428e-acaf-ff4cff******'),
      }
    ](name='TimerInfos', description='The details of the scheduled tasks.'),
    totalRecordCount?: int32(name='TotalRecordCount', description='The total number of entries returned.', example='1'),
  }(name='Data', description='The result data.'),
  message?: string(name='Message', description='The message that is returned for the request.

>  If the request is successful, **Successful** is returned. If the request fails, an error message such as an error code is returned.', example='Successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='936C7025-27A5-4CB1-BB31-540E1F0CCA12'),
  success?: boolean(name='Success', description='Indicates whether the request is successful.', example='true'),
}

model DescribeScheduleTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeScheduleTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeScheduleTasks  DescribeScheduleTasksRequest
  * @return DescribeScheduleTasksResponse
 */
async function describeScheduleTasks(request: DescribeScheduleTasksRequest): DescribeScheduleTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeScheduleTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSlowLogRecordsRequest {
  DBClusterId: string(name='DBClusterId', description='Cluster ID.
> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) interface to view all cluster information in the target region, including the Cluster ID.

This parameter is required.', example='pc-************', position='Query'),
  DBName?: string(name='DBName', description='Database name.', example='testdb', position='Query'),
  endTime: string(name='EndTime', description='End time of the query, which must be later than the start time, and the time interval between the start and end times must not exceed 24 hours. The format is `YYYY-MM-DDThh:mmZ` (UTC time).

> The input is UTC time (i.e., 0 timezone). If your service is currently in a different timezone, please perform a time conversion. For example, if the current timezone of your service is Beijing Time (UTC+8) at 12:00, and you need to query the slow logs between 08:00-12:00 Beijing Time, you should input 00:00-04:00.

This parameter is required.', example='2022-11-16T04:00Z', position='Query'),
  nodeId?: string(name='NodeId', description='Node ID', example='pi-**********', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value must be an integer that is greater than 0.

Default value: **1**.', example='1', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values:

*   **30**
*   **50**
*   **100**

Default value: **30**.', example='30', minimum=30, maximum=100, position='Query'),
  regionId: string(name='RegionId', description='Region ID.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) interface to view the available regions under the target account, including the Region ID.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  SQLHASH?: string(name='SQLHASH', description='Unique identifier of the SQL statement in the slow log statistics, which can be used to obtain the detailed slow logs for that SQL statement.', example='U2FsdGVk****', position='Query'),
  startTime: string(name='StartTime', description='Start time of the query. The format is `YYYY-MM-DDThh:mmZ` (UTC time).

> * Supports viewing slow log information up to 30 days.
> * The input is UTC time (i.e., 0 timezone). If your service is currently in a different timezone, please perform a time conversion. For example, if the current timezone of your service is Beijing Time (UTC+8) at 12:00, and you need to query the slow logs between 08:00-12:00 Beijing Time, you should input 00:00-04:00.

This parameter is required.', example='2022-11-15T16:00Z', position='Query'),
}

model DescribeSlowLogRecordsResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='Cluster ID.', example='pc-*****************'),
  engine?: string(name='Engine', description='Database engine.', example='polardb_mysql'),
  items?: {
    SQLSlowRecord?: [ 
    {
      DBName?: string(name='DBName', description='Database name.', example='testdb'),
      DBNodeId?: string(name='DBNodeId', description='Node ID.', example='pi-*****************'),
      executionStartTime?: string(name='ExecutionStartTime', description='Time when the SQL starts execution. The format is `YYYY-MM-DDThh:mmZ` (UTC time).', example='2021-04-07T03:47Z'),
      hostAddress?: string(name='HostAddress', description='Client address connecting to the database.', example='testdb[testdb] @  [100.**.**.242]'),
      lockTimes?: long(name='LockTimes', description='SQL lock duration in seconds.', example='0'),
      parseRowCounts?: long(name='ParseRowCounts', description='Number of rows parsed.', example='0'),
      queryTimeMS?: long(name='QueryTimeMS', description='Query time. Unit: milliseconds.', example='100'),
      queryTimes?: long(name='QueryTimes', description='SQL execution duration, in seconds.', example='20'),
      returnRowCounts?: long(name='ReturnRowCounts', description='Number of rows returned.', example='0'),
      SQLHash?: string(name='SQLHash', description='Unique identifier for the SQL statement in slow log statistics.', example='U2FsdGVk****'),
      SQLText?: string(name='SQLText', description='Query statement.'),
    }
  ](name='SQLSlowRecord')
  }(name='Items', description='List of slow log details.'),
  pageNumber?: int32(name='PageNumber', description='Page number.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='Number of records on this page.', example='1'),
  requestId?: string(name='RequestId', description='Request ID.', example='A7E6A8FD-C50B-46B2-BA85-D8B8D3******'),
  totalRecordCount?: int32(name='TotalRecordCount', description='Total number of SQL statements.', example='1'),
}

model DescribeSlowLogRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSlowLogRecordsResponseBody(name='body'),
}

/**
  * @description >- Only PolarDB MySQL Edition clusters support calling this interface.
  * >- Starting from September 1, 2024, due to the optimization of the SQL template algorithm, when calling this interface, the value of the SQLHash field will change. For more details, please refer to [Notice] Optimization of Slow SQL Template Algorithm (~~2845725~~).
  * @param request  the request parameters of DescribeSlowLogRecords  DescribeSlowLogRecordsRequest
  * @return DescribeSlowLogRecordsResponse
 */
async function describeSlowLogRecords(request: DescribeSlowLogRecordsRequest): DescribeSlowLogRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSlowLogRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSlowLogsRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-****************', position='Query'),
  DBName?: string(name='DBName', description='The name of the database.', example='PolarDB_MySQL', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. The time span between the start time and the end time cannot exceed 31 days. Specify the time in the yyyy-MM-ddZ format. The time must be in UTC.

This parameter is required.', example='2021-05-30Z', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from 1.

Default value: 1.', example='1', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 30 to 100. Default value: 30.', example='30', minimum=30, maximum=100, position='Query'),
  regionId: string(name='RegionId', description='The region ID of the cluster.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the yyyy-MM-ddZ format. The time must be in UTC.

This parameter is required.', example='2021-05-01Z', position='Query'),
}

model DescribeSlowLogsResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of cluster.', example='pc-****************'),
  endTime?: string(name='EndTime', description='The end date of the query.', example='2021-05-30Z'),
  engine?: string(name='Engine', description='The type of the database engine.', example='polardb_mysql'),
  items?: {
    SQLSlowLog?: [ 
    {
      createTime?: string(name='CreateTime', description='The date when the data was generated.', example='2021-05-30Z'),
      DBName?: string(name='DBName', description='The name of the database.', example='PolarDB_MySQL'),
      DBNodeId?: string(name='DBNodeId', description='The ID of the node.', example='pi-***************'),
      maxExecutionTime?: long(name='MaxExecutionTime', description='The longest execution duration of a specific SQL statement in the query. Unit: seconds.', example='60'),
      maxLockTime?: long(name='MaxLockTime', description='The longest lock duration that was caused by a specific SQL statement in the query. Unit: seconds.', example='1'),
      parseMaxRowCount?: long(name='ParseMaxRowCount', description='The largest number of rows that were parsed by a specific SQL statement in the query.', example='1'),
      parseTotalRowCounts?: long(name='ParseTotalRowCounts', description='The total number of rows that were parsed by all SQL statements in the query.', example='2'),
      returnMaxRowCount?: long(name='ReturnMaxRowCount', description='The largest number of rows that were returned by a specific SQL statement in the query.', example='3'),
      returnTotalRowCounts?: long(name='ReturnTotalRowCounts', description='The total number of rows that were returned by all SQL statements in the query.', example='1'),
      SQLHASH?: string(name='SQLHASH', description='The unique ID of the SQL statement. The ID is used to obtain the slow query logs of the SQL statement.', example='U2FsdGVkxxxx'),
      SQLText?: string(name='SQLText', description='The SQL statement that is executed in the query.', example='select id,name from tb_table'),
      totalExecutionCounts?: long(name='TotalExecutionCounts', description='The total number of executions of the SQL statements.', example='2'),
      totalExecutionTimes?: long(name='TotalExecutionTimes', description='The total duration that was caused by all SQL statements in the query. Unit: seconds.', example='2'),
      totalLockTimes?: long(name='TotalLockTimes', description='The total lock duration that was caused by all SQL statements in the query. Unit: seconds.', example='1'),
    }
  ](name='SQLSlowLog')
  }(name='Items', description='Details about slow query logs.'),
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='3'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of SQL statements that are returned on the current page.', example='6'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2553A660-E4EB-4AF4-A402-8AFF70A49143'),
  startTime?: string(name='StartTime', description='The start date of the query.', example='2021-05-01Z'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of returned entries.', example='5'),
}

model DescribeSlowLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSlowLogsResponseBody(name='body'),
}

/**
  * @description > This operation is applicable only to PolarDB for MySQL clusters.
  * @param request  the request parameters of DescribeSlowLogs  DescribeSlowLogsRequest
  * @return DescribeSlowLogsResponse
 */
async function describeSlowLogs(request: DescribeSlowLogsRequest): DescribeSlowLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSlowLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTasksRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

>  You must specify `DBNodeId` or `DBClusterId`. You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.', example='pc-***************', position='Query'),
  DBNodeId?: string(name='DBNodeId', description='The node ID.

>  You must specify `DBNodeId` or `DBClusterId`. You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as node IDs.', example='pi-***************', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mmZ` format. The time must be in UTC. The end time must be later than the start time.

This parameter is required.', example='2020-12-02T03:00Z', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1.

Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **30**, **50**, and **100**.

Default value: **30**.', example='30', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.

This parameter is required.', example='2020-11-30T00:00Z', position='Query'),
  status?: string(name='Status', description='The state of the tasks that you want to query. Valid values:

*   **Waiting**: The task is pending.
*   **Running**: The task is running.
*   **Finished**: The task is completed.
*   **Closed**: The task is closed.
*   **Pause**: The task is paused.
*   **Stop**: The task is interrupted.

> 

*   If you do not specify this parameter, the operation returns the details of only the tasks that are in the **Waiting** or **Running** state for the cluster or node.

*   You can enter multiple task states. Separate multiple task states with commas (,).', example='Running', position='Query'),
}

model DescribeTasksResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster for which the task was created.', example='pc-***************'),
  endTime?: string(name='EndTime', description='The end time of the query.', example='2020-12-02T03:00Z'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page returned.', example='1'),
  pageRecordCount?: int32(name='PageRecordCount', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The request ID.', example='4352AD99-9FF5-41A6-A319-068089******'),
  startTime?: string(name='StartTime', description='The start time of the query.', example='2020-11-30T00:00Z'),
  tasks?: {
    task?: [ 
    {
      beginTime?: string(name='BeginTime', description='The time when the task was started. The time follows the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.', example='2020-12-02T02:39:15Z'),
      currentStepName?: string(name='CurrentStepName', description='The name of the current step.', example='create_instance'),
      DBName?: string(name='DBName', description='The database name.

>  This parameter is returned for only the tasks that involve database operations.', example='test'),
      expectedFinishTime?: string(name='ExpectedFinishTime', description='The estimated end time of the task. In most cases, this parameter is empty.', example='null'),
      finishTime?: string(name='FinishTime', description='The time when the task was completed. The time follows the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time is displayed in UTC.', example='2020-12-02T02:40:15Z'),
      progress?: int32(name='Progress', description='The progress of the task in percentage.', example='100'),
      progressInfo?: string(name='ProgressInfo', description='The description of the task progress. If no progress description is provided for the task, this parameter is empty.', example='null'),
      remain?: int32(name='Remain', description='The estimated remaining duration of the task. Unit: seconds.', example='1767'),
      stepProgressInfo?: string(name='StepProgressInfo', description='The progress of the subtasks. For example, the value `1/4` indicates that the task consists of four subtasks and the first subtask is in progress.', example='1/4'),
      stepsInfo?: string(name='StepsInfo', description='The details of the subtasks.', example='[{\\"remain\\":0,\\"name\\":\\"init_task\\",\\"progress\\":100},{\\"remain\\":1764,\\"name\\":\\"create_instance\\",\\"progress\\":0},{\\"remain\\":1,\\"name\\":\\"init_cluster\\",\\"progress\\":0},{\\"remain\\":2,\\"name\\":\\"create_backup\\",\\"progress\\":0}]'),
      taskAction?: string(name='TaskAction', description='The API operation that is used by the task. Example: `CreateDBInstance`.', example='CreateDBInstance'),
      taskErrorCode?: string(name='TaskErrorCode', description='The error code that is returned when an error occurs.

>  This parameter is returned only when the task is in the **Stop** state.', example='null'),
      taskErrorMessage?: string(name='TaskErrorMessage', description='The error message that is returned when an error occurs.

>  This parameter is returned only when the task is in the **Stop** state.', example='null'),
      taskId?: string(name='TaskId', description='The ID of the task.', example='111111111'),
    }
  ](name='Task')
  }(name='Tasks', description='The details of the task.'),
  totalRecordCount?: int32(name='TotalRecordCount', description='The total number of entries returned.', example='1'),
}

model DescribeTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTasksResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to view the details of a task that is generated by a specific API operation or in the PolarDB console. The system calls the specific API operation when you perform an operation in the PolarDB console. For example, you can view the details of the task when you call the [CreateDBCluster](https://help.aliyun.com/document_detail/98169.html) operation or [create a cluster](https://help.aliyun.com/document_detail/58769.html) in the PolarDB console.
  * *   You can view the details of tasks that are generated only when you call the [CreateDBCluster](https://help.aliyun.com/document_detail/98169.html) operation to create a cluster and `CreationOption` is not set to `CreateGdnStandby`.
  * @param request  the request parameters of DescribeTasks  DescribeTasksRequest
  * @return DescribeTasksResponse
 */
async function describeTasks(request: DescribeTasksRequest): DescribeTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUserEncryptionKeyListRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.', example='pc-************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query all regions that are available for your account, such as the region ID.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  TDERegion?: string(name='TDERegion', description='The region where the TDE key resides.', example='cn-beijing', position='Query'),
}

model DescribeUserEncryptionKeyListResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-************'),
  keyList?: [ string ](name='KeyList', description='Cluster key list.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A7E6A8FD-C50B-46B2-BA85-D8B8D3******'),
}

model DescribeUserEncryptionKeyListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUserEncryptionKeyListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeUserEncryptionKeyList  DescribeUserEncryptionKeyListRequest
  * @return DescribeUserEncryptionKeyListResponse
 */
async function describeUserEncryptionKeyList(request: DescribeUserEncryptionKeyListRequest): DescribeUserEncryptionKeyListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUserEncryptionKeyList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVSwitchesRequest {
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId', description='The dedicated cluster ID.

>  You must specify at least one of the **VpcId** and **DedicatedHostGroupId** parameters.', example='dhg-4n****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 50. The default value is 50.', example='50', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region where the vSwitch is deployed.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the vSwitch belongs.', example='rg-bp67acfmxazb4ph****', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private type (VPC) to which the vSwitch belongs.

>  You must specify at least one of the **VpcId** and **DedicatedHostGroupId** parameters.', example='vpc-25cdvfeq58pl****', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone to which the vSwitch belongs.', example='cn-hangzhou-d', position='Query'),
}

model DescribeVSwitchesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='9A572171-4E27-40D1-BD36-D26C9E71E29E'),
  totalCount?: int32(name='TotalCount', description='The number of returned entries.', example='1'),
  vSwitchs?: [ 
    {
      availableIpAddressCount?: long(name='AvailableIpAddressCount', description='The number of available IP addresses in the vSwitch.', example='1'),
      cidrBlock?: string(name='CidrBlock', description='The IPv4 CIDR block of the vSwitch.', example='172.16.0.0/24'),
      description?: string(name='Description', description='The description of the vSwitch.', example='vSwitchDescription'),
      isDefault?: boolean(name='IsDefault', description='Indicates whether the vSwitch is the default vSwitch. Valid values:

*   **true**
*   **false**', example='true'),
      izNo?: string(name='IzNo', description='The zone to which the NAT gateway belongs.', example='cn-hangzhou-b'),
      status?: string(name='Status', description='The status of the vSwitch. Valid values:

*   **Pending**: The vSwitch is being configured.
*   **Available**: The vSwitch is available.', example='Available'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-25bcdxs7pv1****'),
      vSwitchName?: string(name='VSwitchName', description='The name of the vSwitch.', example='vSwitch'),
    }
  ](name='VSwitchs', description='The vSwitches.'),
}

model DescribeVSwitchesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVSwitchesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeVSwitches  DescribeVSwitchesRequest
  * @return DescribeVSwitchesResponse
 */
async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVSwitches', 'POST', '/', 'json', false, 'json', request);
}

model DisableDBClusterServerlessRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-***************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DisableDBClusterServerlessResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the serverless cluster.', example='pc-****************'),
  requestId?: string(name='RequestId', description='The request ID.', example='CD3FA5F3-FAF3-44CA-AFFF-BAF869******'),
}

model DisableDBClusterServerlessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableDBClusterServerlessResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DisableDBClusterServerless  DisableDBClusterServerlessRequest
  * @return DisableDBClusterServerlessResponse
 */
async function disableDBClusterServerless(request: DisableDBClusterServerlessRequest): DisableDBClusterServerlessResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableDBClusterServerless', 'POST', '/', 'json', false, 'json', request);
}

model EnableDBClusterServerlessRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-**************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scaleApRoNumMax?: string(name='ScaleApRoNumMax', description='The maximum number of stable AP read-only nodes. Valid values: 0 to 7.', example='1', position='Query'),
  scaleApRoNumMin?: string(name='ScaleApRoNumMin', description='The minimum number of stable AP read-only nodes. Valid values: 0 to 7.', example='1', position='Query'),
  scaleMax?: string(name='ScaleMax', description='The maximum number of PCUs per node for scaling. Valid values: 1 to 8 PCUs.', example='2', position='Query'),
  scaleMin?: string(name='ScaleMin', description='The minimum number of PolarDB capacity units (PCUs) per node for scaling. Valid values: 1 to 8 PCUs.', example='1', position='Query'),
  scaleRoNumMax?: string(name='ScaleRoNumMax', description='The maximum number of read-only nodes for scaling. Valid values: 0 to 7.', example='2', position='Query'),
  scaleRoNumMin?: string(name='ScaleRoNumMin', description='The minimum number of read-only nodes for scaling. Valid values: 0 to 7.', example='1', position='Query'),
}

model EnableDBClusterServerlessResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the serverless cluster.', example='pc-bp10gr51qasnl****'),
  requestId?: string(name='RequestId', description='The request ID.', example='5E71541A-6007-4DCC-A38A-F872C31FEB45'),
}

model EnableDBClusterServerlessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableDBClusterServerlessResponseBody(name='body'),
}

/**
  * @param request  the request parameters of EnableDBClusterServerless  EnableDBClusterServerlessRequest
  * @return EnableDBClusterServerlessResponse
 */
async function enableDBClusterServerless(request: EnableDBClusterServerlessRequest): EnableDBClusterServerlessResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableDBClusterServerless', 'POST', '/', 'json', false, 'json', request);
}

model EnableFirewallRulesRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-************', position='Query'),
  enable?: boolean(name='Enable', description='Specifies whether to enable or disable the specified firewall rules. Valid values:

*   **true**: enables the specified firewall rules.
*   **false**: disables the specified firewall rules.

> This parameter is valid only when you specify the **RuleNameList** parameter.', example='true', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ruleNameList: string(name='RuleNameList', description='The name of the firewall rule that you want to enable for the cluster. You can specify multiple firewall rules at a time. Separate multiple rules with commas (,).

> You can call the **DescribeFirewallRules** operation to query the details of all firewall rules that are applicable to a cluster, such as rule names.

This parameter is required.', example='test111', position='Query'),
}

model EnableFirewallRulesResponseBody = {
  message?: string(name='Message', description='The message that is returned for the request.

> If the request was successful, Successful is returned. If the request failed, an error message that contains information such as an error code is returned.', example='Message'),
  requestId?: string(name='RequestId', description='Id of the request', example='99B355CE-526C-478B-B730-AD9D7C******'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model EnableFirewallRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableFirewallRulesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of EnableFirewallRules  EnableFirewallRulesRequest
  * @return EnableFirewallRulesResponse
 */
async function enableFirewallRules(request: EnableFirewallRulesRequest): EnableFirewallRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableFirewallRules', 'POST', '/', 'json', false, 'json', request);
}

model EvaluateRegionResourceRequest {
  DBInstanceConnType?: string(name='DBInstanceConnType', description='The cluster link type. The backend randomly selects the default value. Valid values:

*   **lvs**: Linux virtual server.
*   **proxy**: proxy server.
*   **dns**: domain name system.', example='lvs', position='Query'),
  DBNodeClass: string(name='DBNodeClass', description='The specifications of the node. For information about node specifications, see the following topics:

*   PolarDB for MySQL: [Specifications of compute nodes](https://help.aliyun.com/document_detail/102542.html)
*   PolarDB for Oracle: [Specifications of compute nodes](https://help.aliyun.com/document_detail/207921.html)
*   PolarDB for PostgreSQL: [Specifications of compute nodes](https://help.aliyun.com/document_detail/209380.html)

This parameter is required.', example='polar.mysql.x4.large', position='Query'),
  DBType: string(name='DBType', description='The type of the database engine. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**

This parameter is required.', example='MySQL', position='Query'),
  DBVersion: string(name='DBVersion', description='The version of the database engine

*   Valid values for the MySQL database engine:

    *   **5.6**
    *   **5.7**
    *   **8.0**

*   Valid values for the PostgreSQL database engine:

    *   **11**
    *   **14**

*   Valid value for the Oracle database engine: **11**

This parameter is required.', example='8.0', position='Query'),
  dispenseMode?: string(name='DispenseMode', description='Specifies whether to return the zones in which the single-zone deployment method is supported. Default value: 0. Valid values:

*   **0**: no value returned
*   **1**: returns the zones.', example='1', position='Query'),
  needMaxScaleLink: string(name='NeedMaxScaleLink', description='Specifies whether to create Maxscale. Valid values:

*   **true** (default)
*   **false**

This parameter is required.', example='true', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query available regions.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  subDomain?: string(name='SubDomain', description='The subdomain. It is the child domain of the top-level domain name or parent domain. For example, if the parent domain name is cn-beijing, its child domain can be cn-beijing-i-aliyun.', example='cn-beijing-i-aliyun', position='Query'),
  zoneId: string(name='ZoneId', description='The zone ID.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query available zones.

This parameter is required.', example='cn-hangzhou-g', position='Query'),
}

model EvaluateRegionResourceResponseBody = {
  DBInstanceAvailable?: string(name='DBInstanceAvailable', description='Indicates whether sufficient resources are available. Valid values:

*   **true**
*   **false**', example='true'),
  DBType?: string(name='DBType', description='The type of the database engine. Valid values:

*   **MySQL**
*   **PostgreSQL**
*   **Oracle**', example='MySQL'),
  DBVersion?: string(name='DBVersion', description='The version of the database engine

*   Valid values for the MySQL database engine:

    *   **5.6**
    *   **5.7**
    *   **8.0**

*   Valid values for the PostgreSQL database engine:

    *   **11**
    *   **14**

*   Valid value for the Oracle database engine: **11**', example='8.0'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='69A85BAF-1089-4CDF-A82F-0A140F******'),
}

model EvaluateRegionResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EvaluateRegionResourceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of EvaluateRegionResource  EvaluateRegionResourceRequest
  * @return EvaluateRegionResourceResponse
 */
async function evaluateRegionResource(request: EvaluateRegionResourceRequest): EvaluateRegionResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EvaluateRegionResource', 'POST', '/', 'json', false, 'json', request);
}

model FailoverDBClusterRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5******', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-**************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  rollBackForDisaster?: boolean(name='RollBackForDisaster', description='Specifies whether to switch back services to the original primary zone when the original primary zone recovers.

*   true
*   false', example='false', position='Query'),
  targetDBNodeId?: string(name='TargetDBNodeId', description='The ID of the read-only node that you want to promote to the primary node. You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query node information, such as node IDs.

> *   If you leave this parameter empty, the system selects one or more available read-only nodes that have the highest failover priority as candidate primary nodes. If the failover to the first read-only node fails due to network issues, abnormal replication status, or other reasons, the system attempts to fail over your applications to the next read-only node until the failover is successful.
>*  This parameter is required for PolarDB for Oracle and PolarDB for PostgreSQL clusters. This parameter is optional for PolarDB for MySQL clusters.', example='pi-***********', position='Query'),
  targetZoneType?: string(name='TargetZoneType', description='Whether it is a primary-standby switch within the primary availability zone, with the following values:

Primary: Primary-standby switch within the primary availability zone.
Standby: Switch to the storage hot backup cluster.', example='Primary', position='Query'),
}

model FailoverDBClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model FailoverDBClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: FailoverDBClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of FailoverDBCluster  FailoverDBClusterRequest
  * @return FailoverDBClusterResponse
 */
async function failoverDBCluster(request: FailoverDBClusterRequest): FailoverDBClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'FailoverDBCluster', 'POST', '/', 'json', false, 'json', request);
}

model GrantAccountPrivilegeRequest {
  accountName: string(name='AccountName', description='The username of the account.

This parameter is required.', example='testacc', position='Query'),
  accountPrivilege: string(name='AccountPrivilege', description='The permissions that are granted to the account. Valid values:

*   **ReadWrite**: read and write permissions
*   **ReadOnly**: read-only permissions
*   **DMLOnly**: The account is granted the permissions to execute only DML statements on the database.
*   **DDLOnly**: The account is granted the permissions to execute only DDL statements on the database.
*   **ReadIndex**: The account has the read and index permissions on the database.

> The number of **AccountPrivilege** values must be the consistent with the number of **DBName** values. Each account permission must correspond to a database name in sequence. For example, you can set **DBName** to `testdb_1,testdb_2` and set **AccountPrivilege** to `ReadWrite,ReadOnly`. In this case, the specified standard account is granted the **read and write** permissions on the **testdb_1** database and the **read** permission on the **testdb_2** database.

This parameter is required.', example='ReadWrite,ReadOnly', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-****************', position='Query'),
  DBName: string(name='DBName', description='The names of the databases that the account can access. You can grant the access permissions on one or more databases to the specified standard account. If you need to specify multiple database names, separate the database names with commas (,).

This parameter is required.', example='testdb_1,testdb_2', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model GrantAccountPrivilegeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627*****'),
}

model GrantAccountPrivilegeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GrantAccountPrivilegeResponseBody(name='body'),
}

/**
  * @description > *   An account can be authorized to access one or more databases.
  * > *   If the specified account already has the access permissions on the specified databases, the operation returns a successful response.
  * > *   Before you call this operation, make sure that the cluster is in the Running state. Otherwise, the operation fails.
  * > *   You can call this operation only on a PolarDB for MySQL cluster.
  * > *   By default, a privileged account for a cluster has all the permissions on the databases in the cluster.
  * @param request  the request parameters of GrantAccountPrivilege  GrantAccountPrivilegeRequest
  * @return GrantAccountPrivilegeResponse
 */
async function grantAccountPrivilege(request: GrantAccountPrivilegeRequest): GrantAccountPrivilegeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GrantAccountPrivilege', 'POST', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', description='The token required to obtain more results. This parameter is not required in the first query. If the first query does not return all results, you can use the token that is returned from the first query in the next query to obtain more results.', example='212db86sca4384811e0b5e8707e******', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query available region IDs.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceId?: [ string ](name='ResourceId', description='The IDs of the clusters. To query the tags of multiple clusters, click **Add** to add cluster IDs.

> 

*   You must specify at least one of the `ResourceId.N` and `Tag.N.Key` parameters.

*   If you specify the `ResourceId.N` parameter, you can add a maximum of 50 cluster IDs at a time.', example='pc-****************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', description='The type of the resource. Set the value to **cluster**.

This parameter is required.', example='cluster', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. To query the details of clusters to which multiple tags are added, click **Add** to add tags.

> 

*   You must specify at least one of the `ResourceId.N` and `Tag.N.Key` parameters.

*   If you specify the `Tag.N.Key` parameter, you can create up to 20 tags at a time.', example='type'),
      value?: string(name='Value', description='The tag value that is paired with the tag key. This parameter can be set to an empty string.', example='test'),
    }
  ](name='Tag', description='The tags.', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='The token required to obtain more results. If not all results are returned in this query, the token is returned. You can use this token in the next query to obtain more results.', example='212db86sca4384811e0b5e8707e******'),
  requestId?: string(name='RequestId', description='The request ID.', example='688C04E4-23F8-409F-8A38-B954D5******'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId', description='The cluster ID.', example='pc-****************'),
      resourceType?: string(name='ResourceType', description='The type of the resource. This parameter is set to **cluster**.', example='cluster'),
      tagKey?: string(name='TagKey', description='The key of the tag.', example='type'),
      tagValue?: string(name='TagValue', description='The value of the tag.', example='test'),
    }
  ](name='TagResource')
  }(name='TagResources', description='The details of the queried clusters and tags.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListTagResources  ListTagResourcesRequest
  * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ManuallyStartDBClusterRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-xxxxxxxxxxxxx', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.

> You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query available regions.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ManuallyStartDBClusterResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='73A85BAF-1039-4CDE-A83F-1A140F******'),
}

model ManuallyStartDBClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ManuallyStartDBClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ManuallyStartDBCluster  ManuallyStartDBClusterRequest
  * @return ManuallyStartDBClusterResponse
 */
async function manuallyStartDBCluster(request: ManuallyStartDBClusterRequest): ManuallyStartDBClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ManuallyStartDBCluster', 'POST', '/', 'json', false, 'json', request);
}

model ModifyAccountDescriptionRequest {
  accountDescription: string(name='AccountDescription', description='The description of the account. The description must meet the following requirements:

*   The description cannot start with `http://` or `https://`.
*   The description must be 2 to 256 characters in length.

This parameter is required.', example='test', position='Query'),
  accountName: string(name='AccountName', description='The name of the account.

This parameter is required.', example='testacc', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-*************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyAccountDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model ModifyAccountDescriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAccountDescriptionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyAccountDescription  ModifyAccountDescriptionRequest
  * @return ModifyAccountDescriptionResponse
 */
async function modifyAccountDescription(request: ModifyAccountDescriptionRequest): ModifyAccountDescriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyAccountDescription', 'POST', '/', 'json', false, 'json', request);
}

model ModifyAccountPasswordRequest {
  accountName: string(name='AccountName', description='The username of the account.

This parameter is required.', example='testacc', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-************', position='Query'),
  newAccountPassword: string(name='NewAccountPassword', description='The new password of the account. The new password must meet the following requirements:

*   It must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.
*   It must be 8 to 32 characters in length.
*   Special characters include `! @ # $ % ^ & * ( ) _ + - =`

This parameter is required.', example='Pw123456', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  passwordType?: string(name='PasswordType', description='The password type.', example='Tair', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyAccountPasswordResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model ModifyAccountPasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAccountPasswordResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyAccountPassword  ModifyAccountPasswordRequest
  * @return ModifyAccountPasswordResponse
 */
async function modifyAccountPassword(request: ModifyAccountPasswordRequest): ModifyAccountPasswordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyAccountPassword', 'POST', '/', 'json', false, 'json', request);
}

model ModifyActiveOperationTasksRequest {
  immediateStart?: int32(name='ImmediateStart', description='Specifies whether to immediately start scheduling. Valid values:

*   0: No. This is the default value.
*   1: Yes.

> 

*   If you set this parameter to 0, you must specify the SwitchTime parameter.

*   If you set this parameter to 1, the SwitchTime parameter does not take effect. In this case, the start time of the event is set to the current time, and the system determines the switching time based on the start time. Scheduling is started immediately, which is a prerequisite for the switchover. Then, the switchover is performed. You can call the DescribeActiveOperationTasks operation and check the return value of the PrepareInterval parameter for the preparation time.', example='0', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID.

>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the region information about all clusters within a specified account.

This parameter is required.', example='cn-beijing', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  switchTime?: string(name='SwitchTime', description='The scheduled switching time that you want to specify. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

> 

*   The time that is specified by this parameter cannot be later than the latest execution time.

*   You can call the DescribeActiveOperationTasks operation and check the return value of the Deadline parameter for the latest execution time.', example='2023-04-25T06:00:00Z', position='Query'),
  taskIds: string(name='TaskIds', description='The task IDs.

This parameter is required.', example='11111,22222', position='Query'),
}

model ModifyActiveOperationTasksResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='42CD2EF5-D77E-5AD4-961B-159330D98286'),
  taskIds?: string(name='TaskIds', description='The task IDs.', example='11111,22222'),
}

model ModifyActiveOperationTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyActiveOperationTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyActiveOperationTasks  ModifyActiveOperationTasksRequest
  * @return ModifyActiveOperationTasksResponse
 */
async function modifyActiveOperationTasks(request: ModifyActiveOperationTasksRequest): ModifyActiveOperationTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyActiveOperationTasks', 'POST', '/', 'json', false, 'json', request);
}

model ModifyAutoRenewAttributeRequest {
  DBClusterIds: string(name='DBClusterIds', description='The cluster ID. If you need to specify multiple cluster IDs, separate the cluster IDs with commas (,).

This parameter is required.', example='pc-***************', position='Query'),
  duration?: string(name='Duration', description='The automatic renewal period.

*   Valid values when you set the **PeriodUnit** parameter to **Month**: `1, 2, 3, 6, and 12`.
*   Valid values when you set the **PeriodUnit** parameter to **Year**: `1, 2, and 3`.

Default value: **1**.', example='1', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the renewal period. Valid values:

*   **Year**
*   **Month**

Default value: **Month**.', example='Month', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region. The region ID can be up to 50 characters in length.
cn-hangzhou
 
>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the available regions.

This parameter is required.', example='cn-hangzhou', position='Query'),
  renewalStatus?: string(name='RenewalStatus', description='The auto-renewal status of the cluster. Valid values:

*   **AutoRenewal:** The cluster is automatically renewed.
*   **Normal**: The cluster is manually renewed.
*   **NotRenewal:** The cluster is not renewed after expiration.

Default value: **AutoRenewal**.

>  If you set this parameter to **NotRenewal**, the system sends a notification that indicates the cluster is not renewed three days before the cluster expires. After the cluster expires, the system no longer sends a notification.', example='AutoRenewal', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyAutoRenewAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='4CE6DF97-AEA4-484F-906F-C407EE******'),
}

model ModifyAutoRenewAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAutoRenewAttributeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyAutoRenewAttribute  ModifyAutoRenewAttributeRequest
  * @return ModifyAutoRenewAttributeResponse
 */
async function modifyAutoRenewAttribute(request: ModifyAutoRenewAttributeRequest): ModifyAutoRenewAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyAutoRenewAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyBackupPolicyRequest {
  backupFrequency?: string(name='BackupFrequency', description='The backup frequency. Default value: Normal. Valid values:

*   **Normal**: standard backup. The system backs up data once a day.
*   **2/24H**: enhanced backup. The system backs up data every 2 hours.
*   **3/24H**: enhanced backup. The system backs up data every 3 hours.
*   **4/24H**: enhanced backup. The system backs up data every 4 hours.

>- If you enable enhanced backup, all backups are retained for 24 hours. For backup files that are created earlier than the previous 24 hours, the system permanently retains only the first backup that is created after 00:00 every day and deletes the rest.
>- If you enable enhanced backup, **PreferredBackupPeriod** is automatically set to all days in a week (from Monday to Sunday).
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed supports the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Normal', position='Query'),
  backupRetentionPolicyOnClusterDeletion?: string(name='BackupRetentionPolicyOnClusterDeletion', description='Specifies whether to retain backups when a cluster is deleted. Valid values:

*   **ALL**: permanently retains all backups.
*   **LATEST**: permanently retains the most recent backup.
*   **NONE**: does not retain backups.

>  The default value of the parameter is NONE.', example='NONE', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.

This parameter is required.', example='pc-bp13wz9586voc****', position='Query'),
  dataLevel1BackupFrequency?: string(name='DataLevel1BackupFrequency', description='The frequency of level-1 backups. Default value: Normal. Valid values:

*   **Normal**: standard backup. The system backs up data once a day.
*   **2/24H**: enhanced backup. The system backs up data every 2 hours.
*   **3/24H**: enhanced backup. The system backs up data every 3 hours.
*   **4/24H**: enhanced backup. The system backs up data every 4 hours.

>- This parameter is invalid for PolarDB for Oracle clusters or PolarDB for PostgreSQL clusters.
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Normal', position='Query'),
  dataLevel1BackupPeriod?: string(name='DataLevel1BackupPeriod', description='The backup cycle of level-1 backups. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is invalid for PolarDB for Oracle clusters or PolarDB for PostgreSQL clusters.
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Monday,Tuesday', position='Query'),
  dataLevel1BackupRetentionPeriod?: string(name='DataLevel1BackupRetentionPeriod', description='The retention period of level-1 backups. Valid values: 3 to 14. Unit: days.', example='3', position='Query'),
  dataLevel1BackupTime?: string(name='DataLevel1BackupTime', description='The time period during which automatic backup for level-1 backup is performed. The time period is in the `hh:mmZ-hh:mmZ` format and is displayed in UTC. The start time and end time are on the hour and have an interval of 1 hour. Example: `14:00Z-15:00Z`.
>- This parameter is invalid for PolarDB for Oracle clusters or PolarDB for PostgreSQL clusters.
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='15:00Z-16:00Z', position='Query'),
  dataLevel2BackupAnotherRegionRegion?: string(name='DataLevel2BackupAnotherRegionRegion', description='The region where the cross-region level-2 backup is stored. For information about regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='cn-hangzhou', position='Query'),
  dataLevel2BackupAnotherRegionRetentionPeriod?: string(name='DataLevel2BackupAnotherRegionRetentionPeriod', description='The retention period of cross-region level-2 backups. Valid values:

*   **0**: The cross-region level-2 backup feature is disabled.
*   **30 to 7300**: Cross-region level-2 backups are retained for 30 to 7,300 days.
*   **1**: Cross-region level-2 backups are permanently retained.

>  The default value of the parameter is **0**.', example='30', position='Query'),
  dataLevel2BackupPeriod?: string(name='DataLevel2BackupPeriod', description='The backup cycle of level-2 backups. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is invalid for PolarDB for Oracle clusters or PolarDB for PostgreSQL clusters.
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed does not support the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Monday,Tuesday', position='Query'),
  dataLevel2BackupRetentionPeriod?: string(name='DataLevel2BackupRetentionPeriod', description='The retention period of level-2 backups. Valid values:

*   **0**: The level-2 backup feature is disabled.
*   **30 to 7300**: Level-2 backups are retained for 30 to 7,300 days.
*   **1**: Level-2 backups are permanently retained.

>  The default value of this parameter is **0**.', example='0', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod', description='The backup cycle. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

>- You need to specify at least two values. Separate multiple values with commas (,).
>- This parameter is invalid if the region where your PolarDB for MySQL cluster is deployed supports the cross-region backup feature. For information about the regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='Monday,Tuesday', position='Query'),
  preferredBackupTime?: string(name='PreferredBackupTime', description='The time period during which automatic backup for level-1 backup is performed. The format is `hh:mmZ-hh:mmZ` format. The time is displayed in UTC. The start time and end time are on the hour and with an interval of one hour. Example: `14:00Z-15:00Z`.', example='15:00Z-16:00Z', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyBackupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C5A5DF0E-5968-4DC1-882E-AC2FE7******'),
}

model ModifyBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyBackupPolicyResponseBody(name='body'),
}

/**
  * @description > You can also modify the automatic backup policy of a PolarDB cluster in the console. For more information, see [Backup settings](https://help.aliyun.com/document_detail/280422.html).
  * @param request  the request parameters of ModifyBackupPolicy  ModifyBackupPolicyRequest
  * @return ModifyBackupPolicyResponse
 */
async function modifyBackupPolicy(request: ModifyBackupPolicyRequest): ModifyBackupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyBackupPolicy', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterRequest {
  compressStorage?: string(name='CompressStorage', description='Specifies whether to enable storage compression. Set the value to **ON**.', example='ON', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

>  You can call the DescribeDBClusters operation to query information about all PolarDB clusters that are deployed in a specified region, such as cluster IDs.

This parameter is required.', example='pc-*************', position='Query'),
  DBNodeCrashList?: string(name='DBNodeCrashList', description='The list of nodes for the drill.

>  You can specify only one node for a node-level disaster recovery drill. For a primary zone-level disaster recovery drill, you can either choose not to specify this parameter or specify all nodes.', example='pi-rwxxx', position='Query'),
  dataSyncMode?: string(name='DataSyncMode', description='The method used to replicate data across zones. Valid values:

*   **AsyncSync**: the asynchronous mode.
*   **SemiSync**: the semi-synchronous mode.', example='AsynSync', position='Query'),
  faultInjectionType?: string(name='FaultInjectionType', description='The fault injection method. Valid values:

*   0: `Crash SQL`-based fault injection.

Valid values:

*   CrashSQLInjection: CrashSQLInjection.', example='0', position='Query'),
  faultSimulateMode?: string(name='FaultSimulateMode', description='The level of the disaster recovery drill. Valid values:

*   `0` or `FaultInjection`: The primary zone level.
*   `1`: The node level.

> 

*   In **primary zone-level disaster recovery drill** scenarios, all compute nodes in the primary zone are unavailable. Data loss occurs during failovers in the scenarios.

*   In **node-level disaster recovery drill** scenarios, you can specify only one compute node for the disaster recovery drill. You can use the `DBNodeCrashList` parameter to specify the name of the compute node that you want to use for the drill.', example='0', position='Query'),
  imciAutoIndex?: string(name='ImciAutoIndex', description='Specifies whether to enable automatic IMCI-based query acceleration. IMCI is short for In-Memory Column Index. Valid values:

*   `ON`: enables automatic IMCI-based query acceleration.
*   `OFF`: disables automatic IMCI-based query acceleration.

> 

*   This parameter is supported only for PolarDB for MySQL clusters.

*   For information about the cluster version limits, see [Automatic IMCI-based query acceleration](https://help.aliyun.com/document_detail/2854119.html).', example='OFF', position='Query'),
  modifyRowCompression?: string(name='ModifyRowCompression', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  standbyHAMode?: string(name='StandbyHAMode', description='Specifies whether to enable cross-zone automatic switchover. Valid values:

*   **ON**: enables cross-zone automatic switchover.
*   **OFF**: disables cross-zone automatic switchover.', example='ON', position='Query'),
  storageAutoScale?: string(name='StorageAutoScale', description='Specifies whether to enable automatic storage scaling. This parameter is available only for Standard Edition clusters. Valid values:

*   Enable
*   Disable', example='Enable', position='Query'),
  storageUpperBound?: long(name='StorageUpperBound', description='The maximum storage capacity of the cluster of Standard Edition in automatic scaling. Unit: GB.

>  The maximum value of this parameter is 32000.', example='800', minimum=20, maximum=64000, position='Query'),
  tableMeta?: string(name='TableMeta', position='Query'),
}

model ModifyDBClusterResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*************'),
  orderId?: string(name='OrderId', description='The order ID.', example='2148126708*****'),
  requestId?: string(name='RequestId', description='The request ID.', example='CD3FA5F3-FAF3-44CA-AFFF-BAF869******'),
}

model ModifyDBClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBCluster  ModifyDBClusterRequest
  * @return ModifyDBClusterResponse
 */
async function modifyDBCluster(request: ModifyDBClusterRequest): ModifyDBClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBCluster', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterAccessWhitelistRequest {
  DBClusterIPArrayAttribute?: string(name='DBClusterIPArrayAttribute', description='The attributes of the IP whitelist group. Set this parameter to **hidden** to hide the IP whitelist group in the console.

> *   The IP whitelist group that has appeared in the console cannot be hidden.
> *   This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='hidden', position='Query'),
  DBClusterIPArrayName?: string(name='DBClusterIPArrayName', description='The name of the IP whitelist group. The group name must be 2 to 120 characters in length and consists of lowercase letters and digits. It must start with a letter, and end with a letter or a digit.

*   If the specified whitelist group name does not exist, the whitelist group is created.
*   If the specified whitelist group name exists, the whitelist group is modified.
*   If you do not specify this parameter, the default group is modified.

> 

*   You can create a maximum of 50 IP whitelist groups for a cluster.

*   This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='default', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-*************', position='Query'),
  modifyMode?: string(name='ModifyMode', description='The method used to modify the IP whitelist. Valid values:

*   **Cover** (default): overwrites the original IP whitelist.
*   **Append**: appends IP addresses to the original whitelist.
*   **Delete**: deletes IP addresses.

>  This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='Cover', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupIds?: string(name='SecurityGroupIds', description='The ID of the security group. Separate multiple security groups with commas (,).

> *   You can add a maximum of three security groups to a cluster.
> *   This parameter can be specified only when the **WhiteListType** parameter is set to **SecurityGroup**.', example='sg-*********', position='Query'),
  securityIps?: string(name='SecurityIps', description='The IP addresses or Classless Inter-Domain Routing (CIDR) blocks in the IP whitelist group. You can add 1,000 IP addresses or CIDR blocks to all the IP whitelist groups. Separate multiple IP addresses with commas (,). The following two formats are supported:

*   IP addresses. Example: 10.23.12.24.
*   CIDR blocks. Example: 10.23.12.24/24. 24 indicates the length of the prefix of the CIDR block. The length is the range of 1 to 32.

>  This parameter can be specified only when the **WhiteListType** parameter is set to **IP**.', example='10.23.12.24', position='Query'),
  whiteListType?: string(name='WhiteListType', description='The type of the whitelist. Valid values:

*   **IP**: IP whitelist group.
*   **SecurityGroup**: security group.

Default value: **IP**.', example='IP', position='Query'),
}

model ModifyDBClusterAccessWhitelistResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model ModifyDBClusterAccessWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterAccessWhitelistResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBClusterAccessWhitelist  ModifyDBClusterAccessWhitelistRequest
  * @return ModifyDBClusterAccessWhitelistResponse
 */
async function modifyDBClusterAccessWhitelist(request: ModifyDBClusterAccessWhitelistRequest): ModifyDBClusterAccessWhitelistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterAccessWhitelist', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterAndNodesParametersRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-****************', position='Query'),
  DBNodeIds?: string(name='DBNodeIds', description='The IDs of nodes. You can specify this parameter, or leave this parameter empty. Separate multiple node IDs with commas (,).

>  If you do not specify this parameter, only the cluster parameters are modified.', example='pi-****************,pi-**********,', position='Query'),
  fromTimeService?: boolean(name='FromTimeService', description='Specifies an immediate or scheduled task to modify parameters and restart the cluster. Default value: false. Valid values:

*   **false**: runs the kernel upgrade task in a scheduled manner.
*   **true**: immediately runs the kernel upgrade task.', example='false', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template.', example='pcpg-**************', position='Query'),
  parameters?: string(name='Parameters', description='The JSON string for the parameter and its value.', example='{"wait_timeout":"86","innodb_old_blocks_time":"10"}', position='Query'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to run the task. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The value of this parameter must be at least 30 minutes later than the value of the PlannedStartTime parameter.

*   By default, if you specify the `PlannedStartTime` parameter but do not specify the PlannedEndTime parameter, the latest start time of the task is set to a value that is calculated by using the following formula: `Value of the PlannedEndTime parameter + 30 minutes`. For example, if you set the `PlannedStartTime` parameter to `2021-01-14T09:00:00Z` and you do not specify the PlannedEndTime parameter, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z', position='Query'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest time to upgrade the specifications within the scheduled time period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in the time range from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.

*   If this parameter is empty, the upgrade task is immediately performed.', example='2021-01-14T09:00:00Z', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  standbyClusterIdListNeedToSync?: string(name='StandbyClusterIdListNeedToSync', description='The secondary clusters in the GDN to which the parameter settings are synchronized.', example='gdn-**********,gdn-**********', position='Query'),
}

model ModifyDBClusterAndNodesParametersResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model ModifyDBClusterAndNodesParametersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterAndNodesParametersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBClusterAndNodesParameters  ModifyDBClusterAndNodesParametersRequest
  * @return ModifyDBClusterAndNodesParametersResponse
 */
async function modifyDBClusterAndNodesParameters(request: ModifyDBClusterAndNodesParametersRequest): ModifyDBClusterAndNodesParametersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterAndNodesParameters', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterArchRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-****************', position='Query'),
  hotStandbyCluster?: string(name='HotStandbyCluster', description='Specifies whether to enable the hot standby storage cluster feature. Valid values:

*   **on**: enables hot standby storage cluster.
*   **equal**: Enable a peer-to-peer cluster.', example='on', position='Query'),
  regionId?: string(name='RegionId', description='The region ID.

>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query information about regions.', example='cn-beijing', position='Query'),
  standbyAZ?: string(name='StandbyAZ', description='The zone of the hot standby storage cluster. Valid values:

*   **auto** (default): The zone is automatically selected.

>  You can use the default value when HotStandbyCluster is set to on. If HotStandbyCluster is set to equal, specify the zone of the hot standby storage cluster. You can call the [DescribeZones](https://help.aliyun.com/document_detail/98041.html) operation to query information about zones.', example='cn-beijing-i', position='Query'),
}

model ModifyDBClusterArchResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-**************'),
  orderId?: string(name='OrderId', description='The order ID.', example='2148126708*****'),
  requestId?: string(name='RequestId', description='The request ID.', example='6A2EE5B4-CC9F-46E1-A747-E43BC9******'),
}

model ModifyDBClusterArchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterArchResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBClusterArch  ModifyDBClusterArchRequest
  * @return ModifyDBClusterArchResponse
 */
async function modifyDBClusterArch(request: ModifyDBClusterArchRequest): ModifyDBClusterArchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterArch', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterAuditLogCollectorRequest {
  collectorStatus: string(name='CollectorStatus', description='Specifies whether to enable or disable SQL collector. Valid values:

*   Enable
*   Disable

This parameter is required.', example='Enable', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-***************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBClusterAuditLogCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='22C0ACF0-DD29-4B67-9190-B7A48C******'),
}

model ModifyDBClusterAuditLogCollectorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterAuditLogCollectorResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBClusterAuditLogCollector  ModifyDBClusterAuditLogCollectorRequest
  * @return ModifyDBClusterAuditLogCollectorResponse
 */
async function modifyDBClusterAuditLogCollector(request: ModifyDBClusterAuditLogCollectorRequest): ModifyDBClusterAuditLogCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterAuditLogCollector', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterDeletionRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to.obtain the cluster ID.

This parameter is required.', example='pc-bp1313h70cd5m****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  protection?: boolean(name='Protection', description='Specifies whether to enable the cluster lock feature. Default value: false. Valid values:

*   **true**: enables the cluster lock feature. If you enable the cluster lock feature, you cannot directly release the cluster. You must disable the cluster lock feature before you can release the cluster.
*   **false**: disables the cluster lock feature.', example='true', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBClusterDeletionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='24C80BD8-C710-4138-893A-D2AFED4FC13D'),
}

model ModifyDBClusterDeletionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterDeletionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBClusterDeletion  ModifyDBClusterDeletionRequest
  * @return ModifyDBClusterDeletionResponse
 */
async function modifyDBClusterDeletion(request: ModifyDBClusterDeletionRequest): ModifyDBClusterDeletionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterDeletion', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterDescriptionRequest {
  DBClusterDescription: string(name='DBClusterDescription', description='The name of the cluster. The name must meet the following requirements:

*   The name cannot start with `http://` or `https://`.
*   The name must be 2 to 256 characters in length.

This parameter is required.', example='ClusterDescriptionTest', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the PolarDB cluster.

This parameter is required.', example='pc-**************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBClusterDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model ModifyDBClusterDescriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterDescriptionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBClusterDescription  ModifyDBClusterDescriptionRequest
  * @return ModifyDBClusterDescriptionResponse
 */
async function modifyDBClusterDescription(request: ModifyDBClusterDescriptionRequest): ModifyDBClusterDescriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterDescription', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterEndpointRequest {
  autoAddNewNodes?: string(name='AutoAddNewNodes', description='Specifies whether to enable automatic association of newly added nodes with the cluster endpoint. Valid values:

*   **Enable**: enables automatic association of newly added nodes with the cluster endpoint.
*   **Disable** (default): disables automatic association of newly added nodes with the cluster endpoint.', example='Enable', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-*************', position='Query'),
  DBEndpointDescription?: string(name='DBEndpointDescription', description='The name of the custom cluster endpoint.', example='test', position='Query'),
  DBEndpointId: string(name='DBEndpointId', description='The ID of the endpoint.

This parameter is required.', example='pe-**************', position='Query'),
  endpointConfig?: string(name='EndpointConfig', description='The advanced configurations of the cluster endpoint, which are in the JSON format. You can configure the consistency level, transaction splitting, and connection pool settings, and specify whether the primary node accepts read requests.

*   The load balancing policy. Format: `{\\"LoadBalancePolicy\\":\\"Load balancing policy\\"}`. Valid values:

    *   **0** (default): connections-based load balancing
    *   **1**: active requests-based load balancing

*   Specifies whether to allow the primary node to accept read requests. Format: `{\\"MasterAcceptReads\\":\\"Specification about whether to allow the primary node to accept read requests\\"}`. Valid values:

    *   **on** (default): allows the primary node to accept read requests.
    *   **off**: does not allow the primary node to accept read requests.

*   Specifies whether to enable the transaction splitting feature. Format: `{\\"DistributedTransaction\\":\\"Specification about whether to enable the transaction splitting feature\\"}`. Valid values:

    *   **on** (default): enables the transaction splitting feature.
    *   **off**: disables the transaction splitting feature.

*   The consistency level. Format: `{\\"ConsistLevel\\":\\"Consistency level\\"}`. Valid values:

    *   **0**: eventual consistency (weak)
    *   **1** (default): session consistency (medium)
    *   **2**: global consistency (strong)

*   The global consistency timeout. Format: `{\\"ConsistTimeout\\":\\"Global consistency timeout\\"}`. Valid values: 0 to 60,000. Default value: 20. Unit: ms.

*   The session consistency timeout. Format: `{\\"ConsistSessionTimeout\\":\\"Session consistency timeout\\"}`. Valid values: 0 to 60,000. Default value: 0. Unit: ms.

*   The global (or session) consistency timeout policy. Format: `{\\"ConsistTimeoutAction\\":\\"Consistency timeout policy\\"}`. Valid values:

    *   **0** (default): PolarProxy sends read requests to the primary node.
    *   **1**: PolarProxy returns the "wait replication complete timeout, please retry" error message to the application.

*   Specifies whether to enable the connection pool feature. Format: `{\\"ConnectionPersist\\":\\"Specification about whether to enable the connection pool feature\\"}`. Valid values:

    *   **off** (default): disables the connection pool feature.
    *   **Session**: enables the session-level connection pool.
    *   **Transaction**: enables the transaction-level connection pool.

*   Specifies whether to enable the parallel query feature. Format: `{\\"MaxParallelDegree\\":\\"Specification about whether to enable the parallel query feature\\"}`. Valid values:

    *   **on**: enables the parallel query feature.
    *   **off** (default): disables the parallel query feature.

*   Specifies whether to enable the automatic request distribution among row store and column store nodes feature. Format: `{\\"EnableHtapImci\\":\\"Specification about whether to enable automatic request distribution among row store and column store nodes feature\\"}`. Valid values:

    *   **on**: enables the automatic request distribution among row store and column store nodes feature.
    *   **off** (default): disables the automatic request distribution among row store and column store nodes feature.

*   Specifies whether to enable the overload protection feature. Format: `{\\"EnableOverloadThrottle\\":\\"Specification about whether to enable the overload protection feature\\"}`. Valid values:

    *   **on**: enables the overload protection feature.
    *   **off** (default): disables the overload protection feature.

> 

*   You can configure the transaction splitting, connection pool, and overload protection settings, and specify whether the primary node accepts read requests settings for the cluster endpoint of a PolarDB for MySQL cluster only if ReadWriteMode of the cluster endpoint is set to Read and Write (Automatic Read/Write Splitting).

*   If ReadWriteMode of the cluster endpoint of a PolarDB for MySQL cluster is set to **Read-only**, you can specify the **Connections-based Load Balancing** or **Active Request-based Load Balancing** policy for the cluster endpoint. If ReadWriteMode of the cluster endpoint of a PolarDB for MySQL cluster is set to **Read/Write (Automatic Read/Write Splitting)**, you can specify only the **Active Request-based Load Balancing** policy for the cluster endpoint.

*   You can enable automatic request distribution among column store and row store nodes for the cluster endpoint of a PolarDB for MySQL cluster if ReadWriteMode of the cluster endpoint is set to **Read and Write (Automatic Read/Write Splitting)**, or if the ReadWriteMode of the cluster endpoint is set to **Read-only** and the load balancing policy is set to **Active requests-based load balancing**.

*   Only PolarDB for MySQL supports global consistency.

*   You can set the consistency level of the cluster endpoint of a PolarDB for MySQL cluster only to **0** if **ReadWriteMode** of the cluster endpoint is set to **ReadOnly**.

*   You can configure the settings for the consistency level, transaction splitting, and connection pool features, and specify whether the primary node accepts read requests settings at a time. Example: `{\\"ConsistLevel\\":\\"1\\",\\"DistributedTransaction\\":\\"on\\",\\"ConnectionPersist\\":\\"Session\\",\\"MasterAcceptReads\\":\\"on\\"}`.

*   The configuration for transaction splitting is limited by the configuration for the consistency level. For example, if you set the consistency level to **0**, you cannot enable transaction splitting. If you set the consistency level to **1** or **2**, you can enable transaction splitting.', example='{"ConsistLevel":"1","DistributedTransaction":"on","MasterAcceptReads":"off","ConnectionPersist": "on"}', position='Query'),
  nodes?: string(name='Nodes', description='The reader nodes to be associated with the endpoint. If you need to specify multiple reader nodes, separate the reader nodes with commas (,). If you do not specify this parameter, the predefined nodes are used by default.

> 

*   You must specify the node ID for each PolarDB for MySQL cluster.

*   You must specify the role name of each node for each PolarDB for PostgreSQL or PolarDB for Oracle cluster. Example: `Writer,Reader1,Reader2`.

*   If you set **ReadWriteMode** to **ReadOnly**, only one node can be associated with the cluster endpoint. If the only node becomes faulty, the cluster endpoint may be unavailable for up to an hour. We recommend that you do not associate only one node with the cluster endpoint in production environments. We recommend that you associate at least two nodes with the cluster endpoint to improve service availability.

*   If you set **ReadWriteMode** to **ReadWrite**, you must associate at least two nodes with the cluster endpoint.

    *   No limits are imposed on the two nodes that you select for each PolarDB for MySQL cluster. If the two nodes are read-only nodes, write requests are forwarded to the primary node.
    *   The following limit applies to PolarDB for PostgreSQL and PolarDB for Oracle clusters: One of the selected nodes must be the primary node.', example='pi-**************,pi-*************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  polarSccTimeoutAction?: string(name='PolarSccTimeoutAction', description='Global consistency timeout policy. Valid values:

*   **0**: sends the request to the primary node.
*   **2**: downgrades the consistency level of a query to inconsistent read when a global consistent read in the query times out. No error message is returned to the client.', example='0', position='Query'),
  polarSccWaitTimeout?: string(name='PolarSccWaitTimeout', description='Global consistency timeout.', example='100', position='Query'),
  readWriteMode?: string(name='ReadWriteMode', description='The read/write mode. Valid values:

*   **ReadWrite**: The cluster endpoint handles read and write requests. Automatic read/write splitting is enabled.
*   **ReadOnly**: The cluster endpoint handles read-only requests.', example='ReadWrite', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sccMode?: string(name='SccMode', description='Specifies whether to enable the global consistency (high-performance mode) feature for the nodes. Valid values:

*   **ON**
*   **OFF**', example='on', position='Query'),
}

model ModifyDBClusterEndpointResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CD3FA5F3-FAF3-44CA-AFFF-BAF869******'),
}

model ModifyDBClusterEndpointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterEndpointResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBClusterEndpoint  ModifyDBClusterEndpointRequest
  * @return ModifyDBClusterEndpointResponse
 */
async function modifyDBClusterEndpoint(request: ModifyDBClusterEndpointRequest): ModifyDBClusterEndpointResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterEndpoint', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterMaintainTimeRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-***************', position='Query'),
  maintainTime: string(name='MaintainTime', description='The maintenance window of the cluster. Specify the maintenance window in the `HH:mmZ-HH:mmZ` format. For example, the value `16:00Z-17:00Z` indicates that the cluster can be maintained from 00:00 to 01:00 (UTC+8).
 
>  The maintenance window must start on the hour and last for an hour.

This parameter is required.', example='02:00Z-03:00Z', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBClusterMaintainTimeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='70656639-1416-479F-AF13-D08197******'),
}

model ModifyDBClusterMaintainTimeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterMaintainTimeResponseBody(name='body'),
}

/**
  * @description >  We recommend that you set the routine maintenance window to off-peak hours. Alibaba Cloud maintains your cluster within the specified maintenance window to minimize the negative impacts on your business.
  * @param request  the request parameters of ModifyDBClusterMaintainTime  ModifyDBClusterMaintainTimeRequest
  * @return ModifyDBClusterMaintainTimeResponse
 */
async function modifyDBClusterMaintainTime(request: ModifyDBClusterMaintainTimeRequest): ModifyDBClusterMaintainTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterMaintainTime', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterMigrationRequest {
  regionId?: string(name='RegionId', position='Host'),
  connectionStrings?: string(name='ConnectionStrings', description='The endpoints to be switched. The endpoints are in the JSON format.

> This parameter is valid when the SwapConnectionString parameter is set to true.', example='{"rm-2ze73el581cs*****.mysql.pre.rds.aliyuncs.com":"pc-2ze8200s298e*****.mysql.polardb.pre.rds.aliyuncs.com","rm-2ze73el581cs86*****.mysql.pre.rds.aliyuncs.com":"test-p*****.mysql.polardb.pre.rds.aliyuncs.com"}', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-**************', position='Query'),
  newMasterInstanceId: string(name='NewMasterInstanceId', description='The ID of the new instance or new cluster. Valid values:

*   To perform a data migration, enter the ID of the PolarDB cluster.
*   To perform a migration rollback, enter the ID of the ApsaraDB for RDS instance.

This parameter is required.', example='pc-**************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  sourceRDSDBInstanceId: string(name='SourceRDSDBInstanceId', description='The ID of the source ApsaraDB RDS instance.

This parameter is required.', example='rm-************', position='Query'),
  swapConnectionString?: string(name='SwapConnectionString', description='Specifies whether to switch the endpoints. Valid values:

*   **true**: switches the endpoints. If you select this option, you do not need the change the endpoint in your applications.
*   **false**: does not switch the endpoints. If you select this option, you must specify the endpoint of the PolarDB cluster in your applications.

Default value: **false**.', example='false', position='Query'),
}

model ModifyDBClusterMigrationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='A1B303A5-653F-4AEE-A598-023FF9******'),
}

model ModifyDBClusterMigrationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterMigrationResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to switch the task that migrates data from ApsaraDB for RDS to PolarDB.
  * *   You can call this operation to roll back the task that migrates data from ApsaraDB for RDS to PolarDB.
  * > Before you call this operation, ensure that a one-click upgrade task has been created for the cluster. You can call the [CreateDBCluster](https://help.aliyun.com/document_detail/98169.html) operation to create an upgrade task. Set the **CreationOption** parameter to **MigrationFromRDS**. For more information, see [Create a PolarDB for MySQL cluster by using the Migration from RDS method](https://help.aliyun.com/document_detail/121582.html).
  * @param request  the request parameters of ModifyDBClusterMigration  ModifyDBClusterMigrationRequest
  * @return ModifyDBClusterMigrationResponse
 */
async function modifyDBClusterMigration(request: ModifyDBClusterMigrationRequest): ModifyDBClusterMigrationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterMigration', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterMonitorRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-****************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period: string(name='Period', description='The interval at which monitoring data is collected. Valid values: **5** and **60**. Unit: seconds.

This parameter is required.', example='5', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBClusterMonitorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='75B92353-73B4-447B-8477-C85F3C******'),
}

model ModifyDBClusterMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterMonitorResponseBody(name='body'),
}

/**
  * @description *   When the monitoring data is collected every 5 seconds:
  *     *   If the query time range is less than or equal to 1 hour, the data is displayed at intervals of 5 seconds.
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  * *   When the monitoring data is collected every 60 seconds:
  *     *   If the query time range is less than or equal to one day, the data is displayed at intervals of 1 minute.
  *     *   If the query time range is less than or equal to seven days, the data is displayed at intervals of 10 minutes.
  *     *   If the query time range is less than or equal to 30 days, the data is displayed at intervals of 1 hour.
  *     *   When the query time range is greater than 30 days, the data is displayed at intervals of 1 day.
  * @param request  the request parameters of ModifyDBClusterMonitor  ModifyDBClusterMonitorRequest
  * @return ModifyDBClusterMonitorResponse
 */
async function modifyDBClusterMonitor(request: ModifyDBClusterMonitorRequest): ModifyDBClusterMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterMonitor', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterParametersRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.

This parameter is required.', example='pc-**************', position='Query'),
  fromTimeService?: boolean(name='FromTimeService', description='Specifies an immediate or scheduled task to modify parameters and restart the cluster. Valid values:

*   false: scheduled task
*   true: immediate task', example='false', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template.

> 

*   You can call the [DescribeParameterGroups](https://help.aliyun.com/document_detail/207178.html) operation to query the parameter template ID.

*   You must specify this parameter or the `Parameters` parameter.
*   This parameter is valid only for a PolarDB for MySQL cluster.', example='pcpg-**************', position='Query'),
  parameters?: string(name='Parameters', description='The JSON string that consists of parameters and values. The parameter values are strings, for example, `{"wait_timeout":"86","innodb_old_blocks_time":"10"}`.

> 

*   You can call the [DescribeDBClusterParameters](https://help.aliyun.com/document_detail/98122.html) operation to query the parameters of the PolarDB cluster.

*   This parameter is required for a PolarDB for Oracle or PolarDB for PostgreSQL cluster.
*   For PolarDB for MySQL clusters, you must specify this parameter or the `ParameterGroupId` parameter.', example='{"wait_timeout":"86","innodb_old_blocks_time":"10"}', position='Query'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to run the task. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The value of this parameter must be at least 30 minutes later than the value of the PlannedStartTime parameter.

*   By default, if you specify the `PlannedStartTime` parameter but do not specify the PlannedEndTime parameter, the latest start time of the task is set to a value that is calculated by using the following formula: `Value of the PlannedEndTime parameter + 30 minutes`. For example, if you set the `PlannedStartTime` parameter to `2021-01-14T09:00:00Z` and you do not specify the PlannedEndTime parameter, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2022-04-28T14:30:00Z', position='Query'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest time to upgrade the specifications within the scheduled time period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in the time range from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.

*   If this parameter is empty, the upgrade task is immediately performed.', example='2022-04-28T14:00:00Z', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBClusterParametersResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C5D526E5-91B5-48B8-B980-FE07FF******'),
}

model ModifyDBClusterParametersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterParametersResponseBody(name='body'),
}

/**
  * @description PolarDB supports the parameter template feature to centrally manage clusters. You can configure a number of parameters at a time by using a parameter template and apply the template to a PolarDB cluster. For more information, see [Use a parameter template](https://help.aliyun.com/document_detail/207009.html).
  * **
  * **Only PolarDB for MySQL clusters support parameter templates.
  * @param request  the request parameters of ModifyDBClusterParameters  ModifyDBClusterParametersRequest
  * @return ModifyDBClusterParametersResponse
 */
async function modifyDBClusterParameters(request: ModifyDBClusterParametersRequest): ModifyDBClusterParametersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterParameters', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterPrimaryZoneRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/173433.html) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.

This parameter is required.', example='pc-**************', position='Query'),
  fromTimeService?: boolean(name='FromTimeService', description='Specifies whether to change the primary zone immediately. Valid values:

*   false (default): changes the primary zone as scheduled.
*   true: changes the primary zone immediately.', example='false', position='Query'),
  isSwitchOverForDisaster?: string(name='IsSwitchOverForDisaster', description='Specifies whether to switch back to the original primary zone.

*   true: switches back to the original primary zone.
*   false: does not switch back to the original primary zone.', example='false', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to switch the primary zone within the scheduled time period. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> *   The latest start time must be at least 30 minutes later than the earliest start time.
>*   If you specify the `PlannedStartTime` parameter but do not specify the PlannedEndTime parameter, the latest start time of the task is set to a value that is calculated by `the value of the PlannedEndTime parameter + 30 minutes` by default. For example, if you set the `PlannedStartTime` parameter to `2021-01-14T09:00:00Z` and you do not specify the PlannedEndTime parameter, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z', position='Query'),
  plannedStartTime?: string(name='PlannedStartTime', description='The start time to change the primary zone within the scheduled time period. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> *   The start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in time from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.
>*   If you leave this parameter empty, the primary zone is immediately changed.', example='2021-01-14T09:00:00Z', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  VPCId?: string(name='VPCId', description='The virtual private cloud (VPC) ID of the destination primary zone.', example='vpc-**********', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch in the destination primary zone.

> *   For a PolarDB for PostgreSQL (Compatible with Oracle) cluster or a PolarDB for PostgreSQL cluster, this parameter is required.
>*   For a PolarDB for MySQL cluster, the default vSwitch is used if no vSwitches are created in the destination zone. If a vSwitch is in the destination zone, this parameter is required.', example='vsw-**************', position='Query'),
  zoneId: string(name='ZoneId', description='The ID of the destination primary zone.

>  You can call the DescribeRegions operation to query available zones.[](~~98041~~)

This parameter is required.', example='cn-hangzhou-g', position='Query'),
  zoneType?: string(name='ZoneType', description='The zone type. Valid values:

*   **Primary**: primary zone
*   **Standby**: secondary zone', example='Primary', position='Query'),
}

model ModifyDBClusterPrimaryZoneResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='ED12C6FF-3261-4571-AB57-3570F6******'),
}

model ModifyDBClusterPrimaryZoneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterPrimaryZoneResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBClusterPrimaryZone  ModifyDBClusterPrimaryZoneRequest
  * @return ModifyDBClusterPrimaryZoneResponse
 */
async function modifyDBClusterPrimaryZone(request: ModifyDBClusterPrimaryZoneRequest): ModifyDBClusterPrimaryZoneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterPrimaryZone', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterResourceGroupRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-*************', position='Query'),
  newResourceGroupId: string(name='NewResourceGroupId', description='The ID of the new resource group.

This parameter is required.', example='rg-**********', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the original resource group.', example='rg-**********', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBClusterResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='70656639-1416-479F-AF13-D08197******'),
}

model ModifyDBClusterResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterResourceGroupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBClusterResourceGroup  ModifyDBClusterResourceGroupRequest
  * @return ModifyDBClusterResourceGroupResponse
 */
async function modifyDBClusterResourceGroup(request: ModifyDBClusterResourceGroupRequest): ModifyDBClusterResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterResourceGroup', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterSSLRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-************', position='Query'),
  DBEndpointId?: string(name='DBEndpointId', description='The ID of the endpoint.

> 

*   This parameter is required for PolarDB for MySQL clusters.

*   This parameter is not required for PolarDB for PostgreSQL or PolarDB for PostgreSQL (Compatible with Oracle) clusters. By default, SSL encryption is enabled for all endpoints of the clusters.

*   You can call the [DescribeDBClusterSSL](https://help.aliyun.com/document_detail/2319159.html) operation to view the details of the endpoint.', example='pe-******************', position='Query'),
  netType?: string(name='NetType', description='The network type supported by the endpoint that is specified by **DBEndpointId**. Valid values:

*   **Public**
*   **Private**
*   **Inner**

> 

*   This parameter is required for a PolarDB for MySQL cluster.

*   This parameter is not required for a PolarDB for Oracle or PolarDB for PostgreSQL cluster. By default, SSL encryption is enabled for all endpoints.', example='Public', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  SSLAutoRotate?: string(name='SSLAutoRotate', description='Specifies whether automatic rotation of SSL certificates is enabled.

*   **Enable**: The feature is enabled.
*   **Disable**: The feature is disabled.', example='Enable', position='Query'),
  SSLEnabled?: string(name='SSLEnabled', description='The SSL encryption status. Valid values:

*   **Disable**: SSL encryption is disabled.
*   **Enable**: SSL encryption is enabled.
*   **Update**: The SSL certificate is updated.

> After you enable SSL encryption or update the SSL certificate, you must download and configure the certificate. For more information, see [Configure SSL encryption](https://help.aliyun.com/document_detail/153182.html).', example='Enable', position='Query'),
}

model ModifyDBClusterSSLResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='A94B1755-6D8B-4E27-BF3C-8562BC******'),
}

model ModifyDBClusterSSLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterSSLResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBClusterSSL  ModifyDBClusterSSLRequest
  * @return ModifyDBClusterSSLResponse
 */
async function modifyDBClusterSSL(request: ModifyDBClusterSSLRequest): ModifyDBClusterSSLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterSSL', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterServerlessConfRequest {
  allowShutDown?: string(name='AllowShutDown', description='Specifies whether to enable No-activity Suspension. Default value: false. Valid values:

*   **true**
*   **false**', example='true', position='Query'),
  crontabJobId?: string(name='CrontabJobId', description='Cycle policy ID.', example='143f8e9f-2566-4dff-be47-bed79f28fc78', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the serverless cluster.

This parameter is required.', example='pc-bp10gr51qasnl****', position='Query'),
  fromTimeService?: boolean(name='FromTimeService', description='Specifies an immediate or scheduled task to modify parameters and restart the cluster. Valid values:

*   false: scheduled task
*   true: immediate task', example='false', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time for upgrading the specifications within the scheduled time period. Specify the time in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
> * The value of this parameter must be at least 30 minutes later than the value of PlannedStartTime.
>*   If you specify PlannedStartTime but do not specify PlannedEndTime, the latest start time of the task is set to a value that is calculated by using the following formula: `PlannedEndTime value + 30 minutes`. For example, if you set PlannedStartTime to `2021-01-14T09:00:00Z` and you do not specify PlannedEndTime, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z', position='Query'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time of the scheduled task for adding the read-only node. The scheduled task specifies that the task is run in the required period. Specify the time in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.

> *   The earliest start time of the scheduled task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in time between `2021-01-14T09:00:00Z` and `2021-01-15T09:00:00Z`.
>*   If you leave this parameter empty, the task for adding the read-only node is immediately run by default.', example='2021-01-14T09:00:00Z', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scaleApRoNumMax?: string(name='ScaleApRoNumMax', description='The maximum number of stable AP read-only nodes. Valid values: 0 to 7.', example='1', position='Query'),
  scaleApRoNumMin?: string(name='ScaleApRoNumMin', description='The minimum number of stable AP read-only nodes. Valid values: 0 to 7.', example='1', position='Query'),
  scaleMax?: string(name='ScaleMax', description='The maximum number of PCUs per node for scaling. Valid values: 1 PCU to 32 PCUs.', example='10', position='Query'),
  scaleMin?: string(name='ScaleMin', description='The minimum number of PCUs per node for scaling. Valid values: 1 PCU to 31 PCUs.', example='1', position='Query'),
  scaleRoNumMax?: string(name='ScaleRoNumMax', description='The maximum number of read-only nodes for scaling. Valid values: 0 to 15.', example='2', position='Query'),
  scaleRoNumMin?: string(name='ScaleRoNumMin', description='The minimum number of read-only nodes for scaling. Valid values: 0 to 15.', example='1', position='Query'),
  secondsUntilAutoPause?: string(name='SecondsUntilAutoPause', description='The detection period for No-activity Suspension. Valid values: 5 to 1440. Unit: minutes. The detection duration must be a multiple of 5 minutes.', example='10', position='Query'),
  serverlessRuleCpuEnlargeThreshold?: string(name='ServerlessRuleCpuEnlargeThreshold', description='CPU burst threshold', example='80', position='Query'),
  serverlessRuleCpuShrinkThreshold?: string(name='ServerlessRuleCpuShrinkThreshold', description='CPU downscale threshold', example='50', position='Query'),
  serverlessRuleMode?: string(name='ServerlessRuleMode', description='Elastic sensitivity. Values: - normal: standard - flexible: sensitive', example='normal', position='Query'),
  taskId?: string(name='TaskId', description='Asynchronous task ID.', example='143f8e9f-2566-4dff-be47-bed79f28fc78', position='Query'),
}

model ModifyDBClusterServerlessConfResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the serverless cluster.', example='pc-bp10gr51qasnl****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5E71541A-6007-4DCC-A38A-F872C31FEB45'),
}

model ModifyDBClusterServerlessConfResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterServerlessConfResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBClusterServerlessConf  ModifyDBClusterServerlessConfRequest
  * @return ModifyDBClusterServerlessConfResponse
 */
async function modifyDBClusterServerlessConf(request: ModifyDBClusterServerlessConfRequest): ModifyDBClusterServerlessConfResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterServerlessConf', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterStoragePerformanceRequest {
  burstingEnabled?: string(name='BurstingEnabled', description='Specifies whether to enable the I/O Burst feature for the ESSD AutoPL disk. Valid value:

*   **true**
*   **false** (default)

>  This parameter is available only when the StorageType parameter is set to ESSDAUTOPL.', example='false', position='Query'),
  clientToken?: string(name='ClientToken', example='6000170000591aed949d0f******************', position='Query'),
  DBClusterId: string(name='DBClusterId', description='This parameter is required.', example='pc-*************', position='Query'),
  modifyType?: string(name='ModifyType', example='Upgrade', position='Query'),
  provisionedIops?: int32(name='ProvisionedIops', example='2500', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  storageType?: string(name='StorageType', example='ESSDAUTOPL', position='Query'),
}

model ModifyDBClusterStoragePerformanceResponseBody = {
  DBClusterId?: string(name='DBClusterId', example='pc-************'),
  orderId?: string(name='OrderId', example='2035629******'),
  requestId?: string(name='RequestId', example='E56531A4-E552-40BA-9C58-137B80******'),
}

model ModifyDBClusterStoragePerformanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterStoragePerformanceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBClusterStoragePerformance  ModifyDBClusterStoragePerformanceRequest
  * @return ModifyDBClusterStoragePerformanceResponse
 */
async function modifyDBClusterStoragePerformance(request: ModifyDBClusterStoragePerformanceRequest): ModifyDBClusterStoragePerformanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterStoragePerformance', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterStorageSpaceRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-*************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest time to upgrade the specifications within the scheduled time period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.
>- The value of this parameter must be at least 30 minutes later than PlannedStartTime.
>- By default, if you specify `PlannedStartTime` but do not specify PlannedEndTime, the latest start time of the task is set to `PlannedEndTime + 30 minutes`. For example, if you set `PlannedStartTime` to `2021-01-14T09:00:00Z` and you do not specify PlannedEndTime, the latest start time of the task is `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z', position='Query'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest time to upgrade the specifications within the scheduled time period. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.
>- This parameter takes effect only when `ModifyType` is set to `Upgrade`.
>- The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in the time that ranges from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.
>- If this parameter is left empty, the upgrade task is immediately performed.', example='2021-01-14T09:00:00Z', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  storageSpace: long(name='StorageSpace', description='The storage capacity that you can select when you change the cluster. Unit: GB.

>  You can set this parameter for PolarDB for MySQL clusters of Standard Edition to a value that ranges from 20 to 32000.

This parameter is required.', example='50', position='Query'),
  subCategory?: string(name='SubCategory', description='The category of the cluster. Default value: ON. Valid values:

*   **normal_exclusive**: dedicated
*   **normal_general**: general-purpose', example='normal_general', position='Query'),
}

model ModifyDBClusterStorageSpaceResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*************'),
  orderId?: string(name='OrderId', description='The order ID.', example='2035629******'),
  requestId?: string(name='RequestId', description='The request ID.', example='685F028C-4FCD-407D-A559-072D63******'),
}

model ModifyDBClusterStorageSpaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterStorageSpaceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBClusterStorageSpace  ModifyDBClusterStorageSpaceRequest
  * @return ModifyDBClusterStorageSpaceResponse
 */
async function modifyDBClusterStorageSpace(request: ModifyDBClusterStorageSpaceRequest): ModifyDBClusterStorageSpaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterStorageSpace', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBClusterTDERequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-************', position='Query'),
  enableAutomaticRotation?: string(name='EnableAutomaticRotation', description='Specifies whether to allow the TDE key of the cluster to be automatically rotated within the next maintenance window after a lapse of the rotation period when a change in the KMS key version is detected. This parameter is supported only for custom keys. Valid values:

*   **true**
*   **false**

>  This parameter is supported only for a PolarDB for PostgreSQL or PolarDB for PostgreSQL (Compatible with Oracle) cluster.', example='false', position='Query'),
  encryptNewTables?: string(name='EncryptNewTables', description='Specifies whether to enable automatic encryption for new tables. Valid values:

*   **ON**
*   **OFF**

>  This parameter takes effect only for a PolarDB for MySQL cluster.', example='ON', position='Query'),
  encryptionKey?: string(name='EncryptionKey', description='The ID of the custom key.', example='749c1df7-****-****-****-*********', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleArn?: string(name='RoleArn', description='The Alibaba Cloud Resource Name (ARN) of the RAM role. A RAM role is a virtual identity that you can create within your Alibaba Cloud account. For more information, see [RAM role overview](https://help.aliyun.com/document_detail/93689.html).', example='acs:ram::1406926*****:role/aliyunrdsinstanceencryptiondefaultrole', position='Query'),
  TDEStatus: string(name='TDEStatus', description='Modifies the TDE status. Set the value to **Enable**.

This parameter is required.', example='Enable', position='Query'),
}

model ModifyDBClusterTDEResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5F859238-2A36-4A8D-BD0F-732112******'),
}

model ModifyDBClusterTDEResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterTDEResponseBody(name='body'),
}

/**
  * @description > *   To perform this operation, you must activate KMS first. For more information, see [Purchase a dedicated KMS instance](https://help.aliyun.com/document_detail/153781.html).
  * > *   After TDE is enabled, you cannot disable TDE.
  * @param request  the request parameters of ModifyDBClusterTDE  ModifyDBClusterTDERequest
  * @return ModifyDBClusterTDEResponse
 */
async function modifyDBClusterTDE(request: ModifyDBClusterTDERequest): ModifyDBClusterTDEResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBClusterTDE', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBDescriptionRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-***************', position='Query'),
  DBDescription: string(name='DBDescription', description='The description of the database. The description must meet the following requirements:

*   It cannot start with `http://` or `https://`.
*   It must be 2 to 256 characters in length.

This parameter is required.', example='DBDesc', position='Query'),
  DBName: string(name='DBName', description='The name of the database.

This parameter is required.', example='testDB', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5F295AAB-B599-4F0E-96D0-DBFAB3******'),
}

model ModifyDBDescriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBDescriptionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBDescription  ModifyDBDescriptionRequest
  * @return ModifyDBDescriptionResponse
 */
async function modifyDBDescription(request: ModifyDBDescriptionRequest): ModifyDBDescriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBDescription', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBEndpointAddressRequest {
  connectionStringPrefix?: string(name='ConnectionStringPrefix', description='The prefix of the new endpoint. The prefix must meet the following requirements:

*   It can contain lowercase letters, digits, and hyphens (-).
*   It must start with a letter and end with a digit or a letter.
*   It must be 6 to 30 characters in length.', example='example', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pc-***************', position='Query'),
  DBEndpointId: string(name='DBEndpointId', description='The ID of the endpoint.

> You can call the [DescribeDBClusterEndpoints](https://help.aliyun.com/document_detail/98205.html) operation to query endpoint IDs.

This parameter is required.', example='pe-****************', position='Query'),
  netType: string(name='NetType', description='The network type of the endpoint. Valid values:

*   **Public**
*   **Private**

This parameter is required.', example='Public', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  port?: string(name='Port', description='The port number. Valid values: 3000 to 5999.

> This parameter is valid only for PolarDB for MySQL clusters. If you leave this parameter empty, the default port 3306 is used.', example='3306', position='Query'),
  privateZoneAddressPrefix?: string(name='PrivateZoneAddressPrefix', description='The prefix of the private domain name. The prefix must meet the following requirements:

*   The prefix can contain lowercase letters, digits, and hyphens (-).
*   The prefix must start with a letter and end with a digit or a letter.
*   The prefix must be 6 to 30 characters in length.

>- You can bind each internal endpoint of PolarDB to a private domain name. The private domain name takes effect only in the specified virtual private clouds (VPCs) in the current region. Private domain names are managed by using PrivateZone. You can use the CNAME record of PrivateZone to map domain names to PolarDB. You are charged a small fee for this feature. For more information, see [Pricing](https://help.aliyun.com/document_detail/71338.html).
>- This parameter takes effect only if you set **NetType** to Private.', example='aliyundoc', position='Query'),
  privateZoneName?: string(name='PrivateZoneName', description='The name of the private zone.

> This parameter takes effect only when **NetType** is set to Private.', example='aliyundoc.com', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBEndpointAddressResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model ModifyDBEndpointAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBEndpointAddressResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBEndpointAddress  ModifyDBEndpointAddressRequest
  * @return ModifyDBEndpointAddressResponse
 */
async function modifyDBEndpointAddress(request: ModifyDBEndpointAddressRequest): ModifyDBEndpointAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBEndpointAddress', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBNodeClassRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-*************', position='Query'),
  DBNodeTargetClass: string(name='DBNodeTargetClass', description='The specifications of all nodes. For more information, see [Specifications of computing nodes](https://help.aliyun.com/document_detail/102542.html).

This parameter is required.', example='polar.mysql.x4.large', position='Query'),
  DBNodeType?: string(name='DBNodeType', description='The type of the node. Valid values:

*   RO
*   STANDBY
*   DLNode', example='DLNode', position='Query'),
  modifyType: string(name='ModifyType', description='The type of the configuration change. Valid values:

*   **Upgrade**
*   **Downgrade**

This parameter is required.', example='Upgrade', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to upgrade the specifications within the scheduled time period. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> *   The value of this parameter must be at least 30 minutes later than the value of PlannedStartTime.
>*   By default, if you specify `PlannedStartTime` but do not specify PlannedEndTime, the latest start time of the task is set to `Value of PlannedEndTime + 30 minutes`. For example, if you set `PlannedStartTime` to `2021-01-14T09:00:00Z` and you do not specify PlannedEndTime, the latest start time of the task is `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z', position='Query'),
  plannedFlashingOffTime?: string(name='PlannedFlashingOffTime', position='Query'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time to upgrade the specifications within the scheduled time period. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

>*   This parameter takes effect only when `ModifyType` is set to `Upgrade`.
>*   The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in the time that ranges from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.
>*   If this parameter is left empty, the upgrade task is immediately performed.', example='2021-01-14T09:00:00Z', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  subCategory?: string(name='SubCategory', description='The category of the cluster. Valid values:

*   **normal_exclusive**: dedicated.
*   **normal_general**: genera-purpose.', example='normal_general', position='Query'),
}

model ModifyDBNodeClassResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*************'),
  orderId?: string(name='OrderId', description='The order ID.', example='2035629******'),
  requestId?: string(name='RequestId', description='The request ID.', example='685F028C-4FCD-407D-A559-072D63******'),
}

model ModifyDBNodeClassResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBNodeClassResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBNodeClass  ModifyDBNodeClassRequest
  * @return ModifyDBNodeClassResponse
 */
async function modifyDBNodeClass(request: ModifyDBNodeClassRequest): ModifyDBNodeClassResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBNodeClass', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBNodeHotReplicaModeRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pc-2vc327c2a14a3u858', position='Query'),
  DBNodeId: string(name='DBNodeId', description='The ID of the node in the cluster.

This parameter is required.', example='pi-2ze28275h9x5r4wt1', position='Query'),
  hotReplicaMode: string(name='HotReplicaMode', description='Specifies whether to enable the hot standby feature. Valid values:

*   **ON**
*   **OFF**

This parameter is required.', example='ON', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBNodeHotReplicaModeResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query information about all clusters that are deployed in a specified region, such as the cluster ID.', example='pc-2vc327c2a14a3u858'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2148126708*****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9F4DDFBF-205C-5A3E-8DC2-C60F3E3FDC38'),
}

model ModifyDBNodeHotReplicaModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBNodeHotReplicaModeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBNodeHotReplicaMode  ModifyDBNodeHotReplicaModeRequest
  * @return ModifyDBNodeHotReplicaModeResponse
 */
async function modifyDBNodeHotReplicaMode(request: ModifyDBNodeHotReplicaModeRequest): ModifyDBNodeHotReplicaModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBNodeHotReplicaMode', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBNodesClassRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. The token is case-sensitive.', example='6000170000591aed949d0f54a343f1a4233c1e7d1c5c******', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-*************', position='Query'),
  DBNode: [ 
    {
      DBNodeId?: string(name='DBNodeId', description='The ID of the node.

>  If you specify this parameter, DBNode.N.TargetClass is required. N is an integer that starts from 1. The maximum value of N is calculated by using the following formula:16 - The number of current nodes.', example='pi-*************'),
      targetClass?: string(name='TargetClass', description='The specifications of the node that you want to change. For more information, see [Specifications of compute nodes](https://help.aliyun.com/document_detail/102542.html).

>  If you specify this parameter, DBNode.N.DBNodeId is required. N is an integer that starts from 1. The maximum value of N is calculated by using the following formula:16 - The number of current nodes.', example='polar.mysql.x4.medium'),
    }
  ](name='DBNode', description='The details of the nodes.

This parameter is required.', position='Query'),
  modifyType: string(name='ModifyType', description='The type of the configuration change. Valid values:

*   **Upgrade**
*   **Downgrade**

This parameter is required.', example='Upgrade', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to upgrade the specifications within the scheduled time period. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

>*   The value of this parameter must be at least 30 minutes later than the value of PlannedStartTime.
>*   By default, if you specify `PlannedStartTime` but do not specify PlannedEndTime, the latest start time of the task is set to `Value of PlannedEndTime + 30 minutes`. For example, if you set `PlannedStartTime` to `2021-01-14T09:00:00Z` and you do not specify PlannedEndTime, the latest start time of the task is `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z', position='Query'),
  plannedFlashingOffTime?: string(name='PlannedFlashingOffTime', position='Query'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time to upgrade the specifications within the scheduled time period. Specify the time in the ISO 8601 standard in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> *   This parameter takes effect only when `ModifyType` is set to `Upgrade`.
>*   The earliest start time of the task can be a point in time within the next 24 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in the time that ranges from `2021-01-14T09:00:00Z` to `2021-01-15T09:00:00Z`.
>*   If this parameter is left empty, the upgrade task is immediately performed.', example='2021-01-14T09:00:00Z', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  subCategory?: string(name='SubCategory', description='The category of the cluster. Valid values:

*   **normal_exclusive**: dedicated
*   **normal_general**: genera-purpose', example='normal_general', position='Query'),
}

model ModifyDBNodesClassResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-*************'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2035629******'),
  requestId?: string(name='RequestId', description='The request ID.', example='685F028C-4FCD-407D-A559-072D63******'),
}

model ModifyDBNodesClassResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBNodesClassResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBNodesClass  ModifyDBNodesClassRequest
  * @return ModifyDBNodesClassResponse
 */
async function modifyDBNodesClass(request: ModifyDBNodesClassRequest): ModifyDBNodesClassResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBNodesClass', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBNodesParametersRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-**************', position='Query'),
  DBNodeIds: string(name='DBNodeIds', description='The ID of the node. You can specify multiple node IDs. Separate multiple node IDs with commas (,).

This parameter is required.', example='pi-****************， pi-****************', position='Query'),
  fromTimeService?: boolean(name='FromTimeService', description='Specifies whether to immediately run the task to modify parameters and restart the cluster. Valid values: false: runs the task on schedule. true: runs the task immediately. Default value: false.', example='false', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  parameterGroupId?: string(name='ParameterGroupId', description='The ID of the parameter template that is used for the cluster.', example='pcpg-**************', position='Query'),
  parameters?: string(name='Parameters', description='The JSON string that specifies the parameter and its value.', example='{"wait_timeout":"86","innodb_old_blocks_time":"10"}', position='Query'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to run the task. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.', example='2022-04-28T14:30:00Z', position='Query'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time to run the task to upgrade the kernel version of the cluster. The task runs within a specified period of time. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.', example='2022-04-28T14:00:00Z', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBNodesParametersResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EBEAA83D-1734-42E3-85E3-E25F6E******'),
}

model ModifyDBNodesParametersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBNodesParametersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyDBNodesParameters  ModifyDBNodesParametersRequest
  * @return ModifyDBNodesParametersResponse
 */
async function modifyDBNodesParameters(request: ModifyDBNodesParametersRequest): ModifyDBNodesParametersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBNodesParameters', 'POST', '/', 'json', false, 'json', request);
}

model ModifyGlobalDatabaseNetworkRequest {
  regionId?: string(name='RegionId', position='Host'),
  enableGlobalDomainName?: boolean(name='EnableGlobalDomainName', description='Create a global domain', example='false', position='Query'),
  GDNDescription?: string(name='GDNDescription', description='The description of the GDN. The description must meet the following requirements:

*   The description cannot start with http:// or https://.
*   The description must start with a letter.
*   The description can contain letters, digits, underscores (_), and hyphens (-).
*   The description must be 2 to 126 characters in length.', example='GDN-fortest', position='Query'),
  GDNId: string(name='GDNId', description='The GDN ID.

This parameter is required.', example='gdn-bp1fttxsrmv*****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifyGlobalDatabaseNetworkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C61892A4-0850-4516-9E26-44D96C1782DE'),
}

model ModifyGlobalDatabaseNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyGlobalDatabaseNetworkResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyGlobalDatabaseNetwork  ModifyGlobalDatabaseNetworkRequest
  * @return ModifyGlobalDatabaseNetworkResponse
 */
async function modifyGlobalDatabaseNetwork(request: ModifyGlobalDatabaseNetworkRequest): ModifyGlobalDatabaseNetworkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyGlobalDatabaseNetwork', 'POST', '/', 'json', false, 'json', request);
}

model ModifyGlobalSecurityIPGroupRequest {
  gIpList: string(name='GIpList', description='The IP address in the whitelist template.

>  Multiple IP addresses are separated by commas (,). You can create up to 1,000 IP addresses or CIDR blocks for all IP whitelists.

This parameter is required.', example='192.168.0.1', position='Query'),
  globalIgName: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or digit.
*   The name must be 2 to 120 characters in length.

This parameter is required.', example='test_123', minLength=2, maxLength=120, position='Query'),
  globalSecurityGroupId: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.

This parameter is required.', example='g-zsldxfiwjmti0kcm****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifyGlobalSecurityIPGroupResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      DBInstances?: [ string ](name='DBInstances', description='The clusters that are associated with the IP address whitelist template.'),
      gIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroup', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model ModifyGlobalSecurityIPGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyGlobalSecurityIPGroupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyGlobalSecurityIPGroup  ModifyGlobalSecurityIPGroupRequest
  * @return ModifyGlobalSecurityIPGroupResponse
 */
async function modifyGlobalSecurityIPGroup(request: ModifyGlobalSecurityIPGroupRequest): ModifyGlobalSecurityIPGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyGlobalSecurityIPGroup', 'POST', '/', 'json', false, 'json', request);
}

model ModifyGlobalSecurityIPGroupNameRequest {
  globalIgName: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or digit.
*   The name must be 2 to 120 characters in length.

This parameter is required.', example='test_123', minLength=2, maxLength=120, position='Query'),
  globalSecurityGroupId: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.

This parameter is required.', example='g-zsldxfiwjmti0kcm****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifyGlobalSecurityIPGroupNameResponseBody = {
  globalSecurityIPGroup?: [ 
    {
      gIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroup', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model ModifyGlobalSecurityIPGroupNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyGlobalSecurityIPGroupNameResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyGlobalSecurityIPGroupName  ModifyGlobalSecurityIPGroupNameRequest
  * @return ModifyGlobalSecurityIPGroupNameResponse
 */
async function modifyGlobalSecurityIPGroupName(request: ModifyGlobalSecurityIPGroupNameRequest): ModifyGlobalSecurityIPGroupNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyGlobalSecurityIPGroupName', 'POST', '/', 'json', false, 'json', request);
}

model ModifyGlobalSecurityIPGroupRelationRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-*****************', position='Query'),
  globalSecurityGroupId: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.

This parameter is required.', example='g-zsldxfiwjmti0kcm****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-**********', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifyGlobalSecurityIPGroupRelationResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster.', example='pc-*****************'),
  globalSecurityIPGroupRel?: [ 
    {
      gIpList?: string(name='GIpList', description='The IP address in the whitelist template.

>  Separate multiple IP addresses with commas (,). You can add up to 1,000 IP addresses or CIDR blocks to all IP whitelists.', example='192.168.0.1'),
      globalIgName?: string(name='GlobalIgName', description='The name of the IP whitelist template. The name must meet the following requirements:

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a letter and end with a letter or a digit.
*   The name must be 2 to 120 characters in length.', example='test_123'),
      globalSecurityGroupId?: string(name='GlobalSecurityGroupId', description='The ID of the IP whitelist template.', example='g-zsldxfiwjmti0kcm****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='GlobalSecurityIPGroupRel', description='The details of the global IP whitelist template.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
}

model ModifyGlobalSecurityIPGroupRelationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyGlobalSecurityIPGroupRelationResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyGlobalSecurityIPGroupRelation  ModifyGlobalSecurityIPGroupRelationRequest
  * @return ModifyGlobalSecurityIPGroupRelationResponse
 */
async function modifyGlobalSecurityIPGroupRelation(request: ModifyGlobalSecurityIPGroupRelationRequest): ModifyGlobalSecurityIPGroupRelationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyGlobalSecurityIPGroupRelation', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLogBackupPolicyRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the information of all clusters that are deployed in a specific region, such as the cluster IDs.

This parameter is required.', example='pc-****************', position='Query'),
  logBackupAnotherRegionRegion?: string(name='LogBackupAnotherRegionRegion', description='The region in which you want to store cross-region log backups. For information about regions that support the cross-region backup feature, see [Overview](https://help.aliyun.com/document_detail/72672.html).', example='cn-hangzhou', position='Query'),
  logBackupAnotherRegionRetentionPeriod?: string(name='LogBackupAnotherRegionRetentionPeriod', description='The retention period of cross-region log backups. Valid values:

*   **0**: The cross-region backup feature is disabled.
*   **30 to 7300**: Cross-region log backups are retained for 30 to 7,300 days.
*   **-1**: The log backups are permanently retained.

>  When you create a cluster, the default value of this parameter is **0**.', example='30', position='Query'),
  logBackupRetentionPeriod?: string(name='LogBackupRetentionPeriod', description='The retention period of the log backups. Valid values:

*   3 to 7300: The log backups are retained for 3 to 7,300 days.
*   \\-1: The log backups are permanently retained.', example='3', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyLogBackupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='345174B4-FAB3-412E-A326-BEDDA9******'),
}

model ModifyLogBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLogBackupPolicyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyLogBackupPolicy  ModifyLogBackupPolicyRequest
  * @return ModifyLogBackupPolicyResponse
 */
async function modifyLogBackupPolicy(request: ModifyLogBackupPolicyRequest): ModifyLogBackupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLogBackupPolicy', 'POST', '/', 'json', false, 'json', request);
}

model ModifyMaskingRulesRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

> You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of the clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pc-*****************', position='Query'),
  enable?: string(name='Enable', description='Specifies whether to enable the specified masking rule. Valid values:

*   **true**
*   **false**

> This parameter is valid only when the `RuleNameList` parameter is specfied.', example='true', position='Query'),
  interfaceVersion?: string(name='InterfaceVersion', position='Query'),
  ruleConfig?: string(name='RuleConfig', description='The parameter that is used to specify the masking rule that you want to modify and the value in the JSON format. All parameter values are of the string type. Example: `{"auto": {"databases": ["db1"], "tables": ["tb1"], "columns": ["c1,c2"] }, "description": "This rule will be applied to the columns c1 and c2 in table t1", "enabled": true, "applies_to": ["user"]}`. Where,

*   `"auto"`: specifies that the dynamic masking algorithm is supported. This parameter is required.
*   `"databases"`: Optional. The names of databases to which the masking rule is applied. Separate the names with commas (,). If you leave this parameter empty, the masking rule applies to all databases in the cluster.
*   `"tables"`: Optional. The names of tables to which the masking rule is applied. Separate the names with commas (,). If you leave this parameter empty, the rule applies to all tables in the cluster.
*   `"columns"`: Required. The names of fields to which the masking rule is applied. Separate the names with commas (,).
*   `"description"`: Optional. The description of the masking rule. The description is up to 64 characters in length.
*   `"enabled"`: Required. Specifies whether to enable the masking rule. Valid values: **true** (enable) and **false** (disable).
*   `"applies_to"`: The names of database accounts to which the masking rule is applied. Separate the names with commas (,).
*   `"exempted"`: The names of database accounts to which the masking rule is not applied. Separate the names with commas (,).

> 

*   If you specify `RuleName`, `RuleConfig` parameter is required.

*   You need to select either `"applies_to"` or `"exempted"`.', example='{"auto": {"databases": ["db1"], "tables": ["tb1"], "columns": ["c1,c2"] }, "description": "This rule will be applied to the columns c1 and c2 in table t1", "enabled": true, "applies_to": ["user"]}', maxLength=8192, position='Query'),
  ruleName?: string(name='RuleName', description='The name of the data masking rule. You can specify only one rule name at a time.

> 

*   You can call the [DescribeMaskingRules](https://help.aliyun.com/document_detail/212573.html) operation to query the details of all masking rules for a specified cluster, such as the names of the masking rules.

*   If the rule name does not exist in the cluster, the system automatically creates a masking rule based on the name and the value of `RuleConfig`.', example='testrule', maxLength=8192, position='Query'),
  ruleNameList?: string(name='RuleNameList', description='The list of masking rule names. You can specify one or more masking rules at a time. Separate the masking rule names with commas (,).

> You must specify either the `RuleName` or `RuleNameList` parameter.', example='testrule', position='Query'),
  ruleVersion?: string(name='RuleVersion', description='The version of the masking rule. Default value: v1. Valid values:

*   v1
*   v2', example='v2', position='Query'),
}

model ModifyMaskingRulesResponseBody = {
  message?: string(name='Message', description='The message that is returned for the request.

> If the request is successful, Successful is returned. If the request fails, an error message such as an error code is returned.', example='Message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='99B355CE-526C-478B-B730-AD9D7C******'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid value:

*   **true**:
*   **false**', example='true'),
}

model ModifyMaskingRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyMaskingRulesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyMaskingRules  ModifyMaskingRulesRequest
  * @return ModifyMaskingRulesResponse
 */
async function modifyMaskingRules(request: ModifyMaskingRulesRequest): ModifyMaskingRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyMaskingRules', 'POST', '/', 'json', false, 'json', request);
}

model ModifyPendingMaintenanceActionRequest {
  ids: string(name='Ids', description='The ID of the task. You can specify multiple task IDs at a time to modify the switching time of the tasks in a unified manner. The task IDs must be separated with commas (,).

This parameter is required.', example='111111', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the cluster.

>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the region ID details.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  switchTime: string(name='SwitchTime', description='The time that you specify for the background to perform the action that corresponds to the pending event. Specify the time in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in UTC.

This parameter is required.', example='2020-06-09T22:00:00Z', position='Query'),
}

model ModifyPendingMaintenanceActionResponseBody = {
  ids?: string(name='Ids', description='The ID of the task.', example='111111'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='93061E17-B56A-4324-BC95-D0FFD2******'),
}

model ModifyPendingMaintenanceActionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyPendingMaintenanceActionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyPendingMaintenanceAction  ModifyPendingMaintenanceActionRequest
  * @return ModifyPendingMaintenanceActionResponse
 */
async function modifyPendingMaintenanceAction(request: ModifyPendingMaintenanceActionRequest): ModifyPendingMaintenanceActionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyPendingMaintenanceAction', 'POST', '/', 'json', false, 'json', request);
}

model OpenAITaskRequest {
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-****************', position='Query'),
  nodeType?: string(name='NodeType', description='The node type. Valid values:

*   **DLNode**: This node is an AI node.
*   **SearchNode**: This node is a node for which the PolarDB for AI feature is enabled.', example='DLNode', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  password?: string(name='Password', description='The password used to access the database for which you want to enable the PolarDB for AI feature.', example='testPassword', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  username?: string(name='Username', description='The username used to access the database for which you want to enable the PolarDB for AI feature.', example='testAccountName', position='Query'),
}

model OpenAITaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9B7BFB11-C077-4FE3-B051-F69CEB******'),
  taskId?: string(name='TaskId', description='The task ID.', example='53879cdb-9a00-428e-acaf-ff4cff******'),
}

model OpenAITaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenAITaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of OpenAITask  OpenAITaskRequest
  * @return OpenAITaskResponse
 */
async function openAITask(request: OpenAITaskRequest): OpenAITaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenAITask', 'POST', '/', 'json', false, 'json', request);
}

model RefreshDBClusterStorageUsageRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  syncRealTime?: boolean(name='SyncRealTime', description='Specifies whether to enable real-time synchronization. Valid values:

*   **true**
*   **false**: T + 1', example='true', position='Query'),
}

model RefreshDBClusterStorageUsageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='E56531A4-E552-40BA-9C58-137B80******'),
}

model RefreshDBClusterStorageUsageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RefreshDBClusterStorageUsageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RefreshDBClusterStorageUsage  RefreshDBClusterStorageUsageRequest
  * @return RefreshDBClusterStorageUsageResponse
 */
async function refreshDBClusterStorageUsage(request: RefreshDBClusterStorageUsageRequest): RefreshDBClusterStorageUsageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RefreshDBClusterStorageUsage', 'POST', '/', 'json', false, 'json', request);
}

model RemoveDBClusterFromGDNRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster in the GDN.

>  You can call the [DescribeGlobalDatabaseNetwork](https://help.aliyun.com/document_detail/264580.html) operation to view the ID of the cluster in the GDN.

This parameter is required.', example='pc-wz9fb5nn44u1d****', position='Query'),
  GDNId: string(name='GDNId', description='The ID of the GDN.

This parameter is required.', example='gdn-bp1fttxsrmv*****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model RemoveDBClusterFromGDNResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='67F2E75F-AE67-4FB2-821F-A81237EACD15'),
}

model RemoveDBClusterFromGDNResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveDBClusterFromGDNResponseBody(name='body'),
}

/**
  * @description >  You cannot remove the primary cluster from a GDN.
  * @param request  the request parameters of RemoveDBClusterFromGDN  RemoveDBClusterFromGDNRequest
  * @return RemoveDBClusterFromGDNResponse
 */
async function removeDBClusterFromGDN(request: RemoveDBClusterFromGDNRequest): RemoveDBClusterFromGDNResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveDBClusterFromGDN', 'POST', '/', 'json', false, 'json', request);
}

model ResetAccountRequest {
  accountName: string(name='AccountName', description='The username of the account.

> You can reset only the permissions of a privileged account.

This parameter is required.', example='testacc', position='Query'),
  accountPassword?: string(name='AccountPassword', description='The password of the account. The password must meet the following requirements:

*   It must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.
*   The password must be 8 to 32 characters in length.
*   Special characters include `! @ # $ % ^ & * ( ) _ + - =`', example='Pw123456', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster.

This parameter is required.', example='pc-**************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ResetAccountResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model ResetAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetAccountResponseBody(name='body'),
}

/**
  * @description >- Only PolarDB for MySQL clusters support this operation.
  * >- If the privileged account of your cluster encounters exceptions, you can call this operation to reset the permissions. For example, the permissions are accidentally revoked.
  * @param request  the request parameters of ResetAccount  ResetAccountRequest
  * @return ResetAccountResponse
 */
async function resetAccount(request: ResetAccountRequest): ResetAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetAccount', 'POST', '/', 'json', false, 'json', request);
}

model ResetGlobalDatabaseNetworkRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of the cluster in the GDN.

>  You can call the [DescribeGlobalDatabaseNetwork](https://help.aliyun.com/document_detail/264580.html) operation to view the ID of the cluster in the GDN.

This parameter is required.', example='pc-wz9fb5nn44u1d****', position='Query'),
  GDNId: string(name='GDNId', description='The ID of the GDN.

This parameter is required.', example='gdn-bp1fttxsrmv*****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-qingdao', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ResetGlobalDatabaseNetworkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='67F2E75F-AE67-4FB2-821F-A81237EACD15'),
}

model ResetGlobalDatabaseNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetGlobalDatabaseNetworkResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ResetGlobalDatabaseNetwork  ResetGlobalDatabaseNetworkRequest
  * @return ResetGlobalDatabaseNetworkResponse
 */
async function resetGlobalDatabaseNetwork(request: ResetGlobalDatabaseNetworkRequest): ResetGlobalDatabaseNetworkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetGlobalDatabaseNetwork', 'POST', '/', 'json', false, 'json', request);
}

model RestartDBLinkRequest {
  regionId?: string(name='RegionId', position='Host'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the IDs of all clusters in an Alibaba Cloud account.

This parameter is required.', example='pc-****************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model RestartDBLinkResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-****************'),
  requestId?: string(name='RequestId', description='The request ID.', example='E56531A4-E552-40BA-9C58-137B80******'),
  taskId?: string(name='TaskId', description='The task ID.', example='ec8c4723-eac5-4f12-becb-01ac08******'),
}

model RestartDBLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestartDBLinkResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RestartDBLink  RestartDBLinkRequest
  * @return RestartDBLinkResponse
 */
async function restartDBLink(request: RestartDBLinkRequest): RestartDBLinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestartDBLink', 'POST', '/', 'json', false, 'json', request);
}

model RestartDBNodeRequest {
  DBNodeId: string(name='DBNodeId', description='The ID of the node.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/185342.html) operation to query the details of all clusters that belong to your Alibaba Cloud account, such as cluster IDs.

This parameter is required.', example='pi-*************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RestartDBNodeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D0CEC6AC-7760-409A-A0D5-E6CD86******'),
}

model RestartDBNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestartDBNodeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RestartDBNode  RestartDBNodeRequest
  * @return RestartDBNodeResponse
 */
async function restartDBNode(request: RestartDBNodeRequest): RestartDBNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestartDBNode', 'POST', '/', 'json', false, 'json', request);
}

model RestoreTableRequest {
  regionId?: string(name='RegionId', position='Host'),
  backupId?: string(name='BackupId', description='The ID of the backup set.

>  You must specify this parameter if you need to restore a database or a table by using a backup set. You can call the [DescribeBackups](https://help.aliyun.com/document_detail/98102.html) operation to query the ID of the backup set.', example='111111', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to query the details of all clusters within your account.

This parameter is required.', example='pc-bp***************', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restoreTime?: string(name='RestoreTime', description='The point in time for the restoration. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mmZ format. The time must be in UTC.

> 

*   You must specify this parameter if you need to restore the database or the table to a point in time.

*   You can restore your cluster to a particular time only over the past seven days.', example='2020-10-04T01:40:00Z', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  tableMeta: string(name='TableMeta', description='The JSON string that contains the information of the database and the table that you want to restore. All values of the database and table information are of the string type. Example: `[ { "tables":[ { "name":"testtb", "type":"table", "newname":"testtb_restore" } ], "name":"testdb", "type":"db", "newname":"testdb_restore" } ]`.

>  You can call the [DescribeMetaList](https://help.aliyun.com/document_detail/194770.html) operation to query the names and details of databases and tables that can be restored and enter their information into the corresponding locations in the preceding example.

This parameter is required.', example='[ { "tables":[ { "name":"testtb", "type":"table", "newname":"testtb_restore" } ], "name":"testdb", "type":"db", "newname":"testdb_restore" } ]', position='Query'),
}

model RestoreTableResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0C47508C-9DC8-455B-985E-2F2FA8******'),
}

model RestoreTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestoreTableResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RestoreTable  RestoreTableRequest
  * @return RestoreTableResponse
 */
async function restoreTable(request: RestoreTableRequest): RestoreTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestoreTable', 'POST', '/', 'json', false, 'json', request);
}

model RevokeAccountPrivilegeRequest {
  accountName: string(name='AccountName', description='The name of the account.

>  You can specify only a standard account.

This parameter is required.', example='testacc', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The ID of the PolarDB cluster.

This parameter is required.', example='pc-****************', position='Query'),
  DBName: string(name='DBName', description='The names of the databases. If you need to specify multiple database names, separate the names with commas (,).

This parameter is required.', example='testdb', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RevokeAccountPrivilegeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FED790E-FB61-4721-8C1C-07C627******'),
}

model RevokeAccountPrivilegeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokeAccountPrivilegeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RevokeAccountPrivilege  RevokeAccountPrivilegeRequest
  * @return RevokeAccountPrivilegeResponse
 */
async function revokeAccountPrivilege(request: RevokeAccountPrivilegeRequest): RevokeAccountPrivilegeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokeAccountPrivilege', 'POST', '/', 'json', false, 'json', request);
}

model SwitchOverGlobalDatabaseNetworkRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the cluster that will become the primary cluster in the GDN.

You can call the [DescribeGlobalDatabaseNetwork](https://help.aliyun.com/document_detail/264580.html) operation to query the ID of the cluster in the GDN.', example='pc-wz9fb5nn44u1d****', position='Query'),
  forced?: boolean(name='Forced', description='Specifies whether to forcibly switch over the primary and secondary clusters in the GDN. Valid values:

*   **true**
*   **false**', example='false', position='Query'),
  GDNId: string(name='GDNId', description='The ID of the GDN.

This parameter is required.', example='gdn-bp1fttxsrmv*****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-qingdao', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model SwitchOverGlobalDatabaseNetworkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='67F2E75F-AE67-4FB2-821F-A81237EACD15'),
}

model SwitchOverGlobalDatabaseNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SwitchOverGlobalDatabaseNetworkResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SwitchOverGlobalDatabaseNetwork  SwitchOverGlobalDatabaseNetworkRequest
  * @return SwitchOverGlobalDatabaseNetworkResponse
 */
async function switchOverGlobalDatabaseNetwork(request: SwitchOverGlobalDatabaseNetworkRequest): SwitchOverGlobalDatabaseNetworkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SwitchOverGlobalDatabaseNetwork', 'POST', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the cluster.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceId: [ string ](name='ResourceId', description='The cluster ID.

This parameter is required.', example='pc-*****************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', description='The type of the resource. Set the value to **cluster**.

This parameter is required.', example='cluster', position='Query'),
  tag: [ 
    {
      key?: string(name='Key', description='The key of the tag that you want to create for the cluster. To create multiple tags for a cluster at a time, click **Add** to add tag keys.

>  You can create up to 20 tags for a cluster at a time. The value of `Tag.N.Key` is paired with the value of `Tag.N.Value`.', example='type'),
      value?: string(name='Value', description='The value of the tag that you want to create for the cluster. To create multiple tags for a cluster at a time, click **Add** to add tag values.

>  You can create up to 20 tags for a cluster at a time. The value of `Tag.N.Key` is paired with the value of `Tag.N.Value`.', example='test'),
    }
  ](name='Tag', description='The tags.

This parameter is required.', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='1CB5286F-AF5A-4E09-BFE9-588D4C******'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of TagResources  TagResourcesRequest
  * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model TempModifyDBNodeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value. Make sure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='6000170000591aed949d0f5********************', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-xxxxxxxxxx', position='Query'),
  DBNode: [ 
    {
      targetClass?: string(name='TargetClass', description='The instance type of the added node. The instance type of the added node must be the same as the instance type of the original node.

>  You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/98094.html) operation to view the instance types of original nodes.', example='polar.mysql.x4.medium'),
      zoneId?: string(name='ZoneId', description='The ID of the zone in which the added node is deployed. The instance type of the added node must be the same as the instance type of the original node.', example='cn-hangzhou-i'),
    }
  ](name='DBNode', description='The information of the added node.

This parameter is required.', position='Query'),
  modifyType: string(name='ModifyType', description='The type of configuration change. Set the value to **TempUpgrade**.

This parameter is required.', example='TempUpgrade', position='Query'),
  operationType: string(name='OperationType', description='The operation type. Valid values:

*   **Modify**: temporarily upgrades the configuration of the cluster.

This parameter is required.', example='Modify', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restoreTime: string(name='RestoreTime', description='The rollback time of the configuration for the temporary upgrade. Specify the time in the ISO 8601 standard in the YYYY-MM-DD hh:mm:ss format.

>  The rollback time cannot be 1 hour earlier than the current time and cannot be later than one day before the time when the cluster expires.

This parameter is required.', example='2021-09-23 18:16:00', position='Query'),
}

model TempModifyDBNodeResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-xxxxxxxxxxxxxxxxx'),
  DBNodeIds?: [ string ](name='DBNodeIds', description='The details of the nodes.'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='2035638*******'),
  requestId?: string(name='RequestId', description='The request ID.', example='69A85BAF-1089-4CDF-A82F-0A140F******'),
}

model TempModifyDBNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TempModifyDBNodeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of TempModifyDBNode  TempModifyDBNodeRequest
  * @return TempModifyDBNodeResponse
 */
async function tempModifyDBNode(request: TempModifyDBNodeRequest): TempModifyDBNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TempModifyDBNode', 'POST', '/', 'json', false, 'json', request);
}

model TransformDBClusterPayTypeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value. Make sure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='6000170000591aed949d0f5********************', position='Query'),
  DBClusterId: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='pc-bp10gr51qasnl****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payType: string(name='PayType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go.
*   **Prepaid**: subscription.

This parameter is required.', example='Prepaid', position='Query'),
  period?: string(name='Period', description='The renewal cycle of the cluster. Valid values:

*   **Year**
*   **Month**

>  This parameter is required if you set the **PayType** parameter to **Prepaid**.', example='Month', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfm3f4un32****', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  usedTime?: string(name='UsedTime', description='The subscription duration of the cluster. Valid values:

*   If the **Period** parameter is set to **Year**, the **UsedTime** parameter can be set to 1, 2, or 3.
*   If the **Period** parameter is set to **Month**, the **UsedTime** parameter can be set to 1, 2, 3, 4, 5, 6, 7, 8, or 9.

>  This parameter is required if you set the **PayType** parameter to **Prepaid**.', example='1', position='Query'),
}

model TransformDBClusterPayTypeResponseBody = {
  chargeType?: string(name='ChargeType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: pay-as-you-go.
*   **Prepaid**: subscription.', example='Prepaid'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='pc-bp10gr51qasnl****'),
  expiredTime?: string(name='ExpiredTime', description='The time when the cluster expires.

>  This parameter is returned if you set the **PayType** parameter to **Prepaid**.', example='2020-04-20T10:00:00Z'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='20515760028****'),
  requestId?: string(name='RequestId', description='The request ID.', example='5E71541A-6007-4DCC-A38A-F872C31FEB45'),
}

model TransformDBClusterPayTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TransformDBClusterPayTypeResponseBody(name='body'),
}

/**
  * @description > 
  * *   PolarDB clusters support the subscription and pay-as-you-go billing methods. You can change the billing method from subscription to pay-as-you-go or from pay-as-you-go to subscription based on your business requirements. For more information, see [Change the billing method from subscription to pay-as-you-go](https://help.aliyun.com/document_detail/172886.html) and [Change the billing method from pay-as-you-go to subscription](https://help.aliyun.com/document_detail/84076.html).
  * *   You cannot change the billing method from pay-as-you-go to subscription if your account balance is insufficient.
  * *   If you change the billing method from subscription to pay-as-you-go, the system automatically refunds the balance of the prepaid subscription fees.
  * @param request  the request parameters of TransformDBClusterPayType  TransformDBClusterPayTypeRequest
  * @return TransformDBClusterPayTypeResponse
 */
async function transformDBClusterPayType(request: TransformDBClusterPayTypeRequest): TransformDBClusterPayTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TransformDBClusterPayType', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to detach all tags from the cluster. Valid values: **true** and **false**. Default value: **false**.

>  This parameter takes effect only if `TagKey.n` is empty.', example='true', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.

>  You can call the [DescribeRegions](https://help.aliyun.com/document_detail/98041.html) operation to query the available regions.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceId: [ string ](name='ResourceId', description='The IDs of the clusters.

This parameter is required.', example='pc-***************', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', description='The type of the resource. Set the value to **cluster**.

This parameter is required.', example='cluster', position='Query'),
  tagKey?: [ string ](name='TagKey', description='The keys of the tags.', example='type', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF5189******'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UntagResources  UntagResourcesRequest
  * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

model UpgradeDBClusterVersionRequest {
  DBClusterId: string(name='DBClusterId', description='The ID of cluster.

This parameter is required.', example='pc-****************', position='Query'),
  fromTimeService?: boolean(name='FromTimeService', description='Specifies whether to immediately run the kernel upgrade task. Valid values:

*   **false** (default)
*   **true**

>  This parameter is not required when you call the operation.', example='false', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  plannedEndTime?: string(name='PlannedEndTime', description='The latest start time to run the task that updates the kernel version of the cluster. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> *   The value of this parameter must be at least 30 minutes later than the value of PlannedStartTime.
>*   If you specify `PlannedStartTime` but do not specify PlannedEndTime, the latest start time of the task is `PlannedEndTime + 30 minutes`. For example, if you set `PlannedStartTime` to `2021-01-14T09:00:00Z` and do not specify PlannedEndTime, the latest start time of the task is set to `2021-01-14T09:30:00Z`.', example='2021-01-14T09:30:00Z', position='Query'),
  plannedStartTime?: string(name='PlannedStartTime', description='The earliest start time to run the task that updates the kernel version of the cluster. Specify the time in the `YYYY-MM-DDThh:mm:ssZ` format. The time must be in UTC.

> 

*   The earliest start time of the task can be a point in time within the next 72 hours. For example, if the current time is `2021-01-14T09:00:00Z`, you can specify a point in time from `2021-01-14T09:00:00Z` to `2021-01-17T09:00:00Z`.

*   If you do not specify this parameter, the kernel update task runs immediately after you submit the request.', example='2021-01-14T09:00:00Z', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  targetDBRevisionVersionCode?: string(name='TargetDBRevisionVersionCode', description='The code of the db version to which you want to upgrade the cluster. You can call the [DescribeDBClusterVersion](https://help.aliyun.com/document_detail/2319145.html) operation to query the version code.', example='20230707', position='Query'),
  targetProxyRevisionVersionCode?: string(name='TargetProxyRevisionVersionCode', description='The code of the proxy version to which you want to upgrade the cluster. You can call the [DescribeDBClusterVersion](https://help.aliyun.com/document_detail/2319145.html) operation to query the version code.', example='20240702', position='Query'),
  upgradeLabel?: string(name='UpgradeLabel', description='The upgrade tag. The value is fixed as **INNOVATE**.

> *   This parameter is applicable only when you upgrade PolarDB for MySQL 8.0.1 to PolarDB for MySQL 8.0.2.
>*   If you specify this parameter, you must set `UpgradePolicy` to **COLD**.', example='INNOVATE', position='Query'),
  upgradePolicy?: string(name='UpgradePolicy', description='The engine version upgrade policy. Valid values:

*   **HOT**: hot upgrade.
*   **COLD**: cold upgrade. Only PolarDB for MySQL 8.0 Cluster Edition supports this upgrade method.', example='HOT', position='Query'),
  upgradeType?: string(name='UpgradeType', description='The update type. Valid values:

*   **PROXY**: specifies to upgrade PloarProxy.
*   **DB**: specifies to upgrade the kernel version.
*   **ALL**: specifies to upgrade both PloarProxy and kernel version.', example='PROXY', position='Query'),
}

model UpgradeDBClusterVersionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CAE6755F-B79A-4861-B227-801FE8******'),
}

model UpgradeDBClusterVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeDBClusterVersionResponseBody(name='body'),
}

/**
  * @description > *  You can update only the revision version of a PolarDB for MySQL cluster, for example, from 8.0.1.1.3 to 8.0.1.1.4.
  * >*   You can use only your Alibaba Cloud account to create scheduled tasks that update the kernel version of a PolarDB for MySQL cluster. RAM users are not authorized to update the kernel version of a PolarDB for MySQL cluster.
  * @param request  the request parameters of UpgradeDBClusterVersion  UpgradeDBClusterVersionRequest
  * @return UpgradeDBClusterVersionResponse
 */
async function upgradeDBClusterVersion(request: UpgradeDBClusterVersionRequest): UpgradeDBClusterVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeDBClusterVersion', 'POST', '/', 'json', false, 'json', request);
}

