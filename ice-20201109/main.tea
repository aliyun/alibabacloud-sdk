/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'ice.aliyuncs.com',
    ap-northeast-2-pop = 'ice.aliyuncs.com',
    ap-south-1 = 'ice.aliyuncs.com',
    ap-southeast-1 = 'ice.aliyuncs.com',
    ap-southeast-2 = 'ice.aliyuncs.com',
    ap-southeast-3 = 'ice.aliyuncs.com',
    ap-southeast-5 = 'ice.aliyuncs.com',
    cn-beijing = 'ice.aliyuncs.com',
    cn-beijing-finance-1 = 'ice.aliyuncs.com',
    cn-beijing-finance-pop = 'ice.aliyuncs.com',
    cn-beijing-gov-1 = 'ice.aliyuncs.com',
    cn-beijing-nu16-b01 = 'ice.aliyuncs.com',
    cn-chengdu = 'ice.aliyuncs.com',
    cn-edge-1 = 'ice.aliyuncs.com',
    cn-fujian = 'ice.aliyuncs.com',
    cn-haidian-cm12-c01 = 'ice.aliyuncs.com',
    cn-hangzhou = 'ice.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'ice.aliyuncs.com',
    cn-hangzhou-finance = 'ice.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'ice.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'ice.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'ice.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'ice.aliyuncs.com',
    cn-hangzhou-test-306 = 'ice.aliyuncs.com',
    cn-hongkong = 'ice.aliyuncs.com',
    cn-hongkong-finance-pop = 'ice.aliyuncs.com',
    cn-huhehaote = 'ice.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'ice.aliyuncs.com',
    cn-north-2-gov-1 = 'ice.aliyuncs.com',
    cn-qingdao = 'ice.aliyuncs.com',
    cn-qingdao-nebula = 'ice.aliyuncs.com',
    cn-shanghai-et15-b01 = 'ice.aliyuncs.com',
    cn-shanghai-et2-b01 = 'ice.aliyuncs.com',
    cn-shanghai-finance-1 = 'ice.aliyuncs.com',
    cn-shanghai-inner = 'ice.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'ice.aliyuncs.com',
    cn-shenzhen = 'ice.aliyuncs.com',
    cn-shenzhen-finance-1 = 'ice.aliyuncs.com',
    cn-shenzhen-inner = 'ice.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'ice.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'ice.aliyuncs.com',
    cn-wuhan = 'ice.aliyuncs.com',
    cn-wulanchabu = 'ice.aliyuncs.com',
    cn-yushanfang = 'ice.aliyuncs.com',
    cn-zhangbei = 'ice.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'ice.aliyuncs.com',
    cn-zhangjiakou = 'ice.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'ice.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'ice.aliyuncs.com',
    eu-central-1 = 'ice.aliyuncs.com',
    eu-west-1 = 'ice.aliyuncs.com',
    eu-west-1-oxs = 'ice.aliyuncs.com',
    me-east-1 = 'ice.aliyuncs.com',
    rus-west-1-pop = 'ice.aliyuncs.com',
    us-east-1 = 'ice.aliyuncs.com',
    us-west-1 = 'ice.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('ice', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddCategoryRequest {
  cateName?: string(name='CateName'),
  parentId?: long(name='ParentId'),
  type?: string(name='Type'),
}

model AddCategoryResponseBody = {
  category?: {
    cateId?: long(name='CateId'),
    cateName?: string(name='CateName'),
    level?: long(name='Level'),
    parentId?: long(name='ParentId'),
    type?: string(name='Type'),
  }(name='Category'),
  requestId?: string(name='RequestId'),
}

model AddCategoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddCategoryResponseBody(name='body'),
}

async function addCategoryWithOptions(request: AddCategoryRequest, runtime: Util.RuntimeOptions): AddCategoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cateName)) {
    query['CateName'] = request.cateName;
  }
  if (!Util.isUnset(request.parentId)) {
    query['ParentId'] = request.parentId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddCategory',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addCategory(request: AddCategoryRequest): AddCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCategoryWithOptions(request, runtime);
}

model AddEditingProjectMaterialsRequest {
  materialMaps?: string(name='MaterialMaps', description='素材ID'),
  projectId?: string(name='ProjectId', description='云剪辑工程ID'),
}

model AddEditingProjectMaterialsResponseBody = {
  liveMaterials?: [ 
    {
      appName?: string(name='AppName'),
      domainName?: string(name='DomainName'),
      liveUrl?: string(name='LiveUrl'),
      streamName?: string(name='StreamName'),
    }
  ](name='LiveMaterials'),
  mediaInfos?: [ 
    {
      fileInfoList?: [ 
        {
          fileBasicInfo?: {
            bitrate?: string(name='Bitrate', description='码率'),
            duration?: string(name='Duration', description='时长'),
            fileName?: string(name='FileName', description='文件名'),
            fileSize?: string(name='FileSize', description='文件大小（字节）'),
            fileStatus?: string(name='FileStatus', description='文件状态'),
            fileType?: string(name='FileType', description='文件类型'),
            fileUrl?: string(name='FileUrl', description='文件oss地址'),
            formatName?: string(name='FormatName', description='封装格式'),
            height?: string(name='Height', description='高'),
            region?: string(name='Region', description='文件存储区域'),
            width?: string(name='Width', description='宽'),
          }(name='FileBasicInfo', description='文件基础信息，包含时长，大小等'),
        }
      ](name='FileInfoList', description='FileInfos'),
      mediaBasicInfo?: {
        businessType?: string(name='BusinessType', description='媒资业务类型'),
        category?: string(name='Category', description='分类'),
        coverURL?: string(name='CoverURL', description='封面地址'),
        createTime?: string(name='CreateTime', description='媒资创建时间'),
        deletedTime?: string(name='DeletedTime', description='媒资删除时间'),
        description?: string(name='Description', description='内容描述'),
        inputURL?: string(name='InputURL', description='待注册的媒资在相应系统中的地址'),
        mediaId?: string(name='MediaId', description='MediaId'),
        mediaTags?: string(name='MediaTags', description='标签'),
        mediaType?: string(name='MediaType', description='媒资媒体类型'),
        modifiedTime?: string(name='ModifiedTime', description='媒资修改时间'),
        snapshots?: string(name='Snapshots', description='截图'),
        source?: string(name='Source', description='来源'),
        spriteImages?: string(name='SpriteImages', description='雪碧图'),
        status?: string(name='Status', description='资源状态'),
        title?: string(name='Title', description='标题'),
        transcodeStatus?: string(name='TranscodeStatus', description='转码状态'),
        userData?: string(name='UserData', description='用户数据'),
      }(name='MediaBasicInfo', description='BasicInfo'),
      mediaId?: string(name='MediaId', description='媒资ID'),
    }
  ](name='MediaInfos', description='符合要求的媒资集合'),
  projectId?: string(name='ProjectId'),
  projectMaterials?: [ string ](name='ProjectMaterials'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AddEditingProjectMaterialsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddEditingProjectMaterialsResponseBody(name='body'),
}

async function addEditingProjectMaterialsWithOptions(request: AddEditingProjectMaterialsRequest, runtime: Util.RuntimeOptions): AddEditingProjectMaterialsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.materialMaps)) {
    query['MaterialMaps'] = request.materialMaps;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddEditingProjectMaterials',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addEditingProjectMaterials(request: AddEditingProjectMaterialsRequest): AddEditingProjectMaterialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addEditingProjectMaterialsWithOptions(request, runtime);
}

model AddFavoritePublicMediaRequest {
  mediaIds?: string(name='MediaIds'),
}

model AddFavoritePublicMediaResponseBody = {
  ignoredList?: [ string ](name='IgnoredList'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AddFavoritePublicMediaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddFavoritePublicMediaResponseBody(name='body'),
}

async function addFavoritePublicMediaWithOptions(request: AddFavoritePublicMediaRequest, runtime: Util.RuntimeOptions): AddFavoritePublicMediaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaIds)) {
    query['MediaIds'] = request.mediaIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddFavoritePublicMedia',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addFavoritePublicMedia(request: AddFavoritePublicMediaRequest): AddFavoritePublicMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return addFavoritePublicMediaWithOptions(request, runtime);
}

model AddTemplateRequest {
  config?: string(name='Config', description='参见Timeline模板Config文档'),
  coverUrl?: string(name='CoverUrl', description='模板封面'),
  name?: string(name='Name', description='模板名称'),
  previewMedia?: string(name='PreviewMedia', description='预览视频媒资id'),
  source?: string(name='Source', description='模板创建来源，默认OpenAPI'),
  status?: string(name='Status', description='模板状态'),
  type?: string(name='Type', description='模板类型，取值范围：Timeline'),
}

model AddTemplateResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
  template?: {
    config?: string(name='Config', description='参见Timeline模板Config文档'),
    coverUrl?: string(name='CoverUrl', description='模板封面'),
    createSource?: string(name='CreateSource', description='模板创建来源'),
    modifiedSource?: string(name='ModifiedSource', description='模板修改来源'),
    name?: string(name='Name', description='模板名称'),
    previewMedia?: string(name='PreviewMedia', description='预览视频媒资id'),
    status?: string(name='Status', description='模板状态'),
    templateId?: string(name='TemplateId', description='模板Id'),
    type?: string(name='Type', description='模板类型'),
  }(name='Template', description='模板信息'),
}

model AddTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddTemplateResponseBody(name='body'),
}

async function addTemplateWithOptions(request: AddTemplateRequest, runtime: Util.RuntimeOptions): AddTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.coverUrl)) {
    query['CoverUrl'] = request.coverUrl;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.previewMedia)) {
    query['PreviewMedia'] = request.previewMedia;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addTemplate(request: AddTemplateRequest): AddTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTemplateWithOptions(request, runtime);
}

model BatchGetMediaInfosRequest {
  additionType?: string(name='AdditionType'),
  mediaIds?: string(name='MediaIds'),
}

model BatchGetMediaInfosResponseBody = {
  mediaInfos?: [ 
    {
      fileInfoList?: [ 
        {
          fileBasicInfo?: {
            bitrate?: string(name='Bitrate', description='码率'),
            duration?: string(name='Duration', description='时长'),
            fileName?: string(name='FileName', description='文件名'),
            fileSize?: string(name='FileSize', description='文件大小（字节）'),
            fileStatus?: string(name='FileStatus', description='文件状态'),
            fileType?: string(name='FileType', description='文件类型'),
            fileUrl?: string(name='FileUrl', description='文件oss地址'),
            formatName?: string(name='FormatName', description='封装格式'),
            height?: string(name='Height', description='高'),
            region?: string(name='Region', description='文件存储区域'),
            width?: string(name='Width', description='宽'),
          }(name='FileBasicInfo', description='文件基础信息，包含时长，大小等'),
        }
      ](name='FileInfoList', description='FileInfos'),
      mediaBasicInfo?: {
        businessType?: string(name='BusinessType', description='媒资业务类型'),
        category?: string(name='Category', description='分类'),
        coverURL?: string(name='CoverURL', description='封面地址'),
        createTime?: string(name='CreateTime', description='媒资创建时间'),
        deletedTime?: string(name='DeletedTime', description='媒资删除时间'),
        description?: string(name='Description', description='内容描述'),
        inputURL?: string(name='InputURL', description='待注册的媒资在相应系统中的地址'),
        mediaId?: string(name='MediaId', description='MediaId'),
        mediaTags?: string(name='MediaTags', description='标签'),
        mediaType?: string(name='MediaType', description='媒资媒体类型'),
        modifiedTime?: string(name='ModifiedTime', description='媒资修改时间'),
        snapshots?: string(name='Snapshots', description='截图'),
        source?: string(name='Source', description='来源'),
        spriteImages?: string(name='SpriteImages', description='雪碧图'),
        status?: string(name='Status', description='资源状态'),
        title?: string(name='Title', description='标题'),
        transcodeStatus?: string(name='TranscodeStatus', description='转码状态'),
        userData?: string(name='UserData', description='用户数据'),
      }(name='MediaBasicInfo', description='BasicInfo'),
      mediaId?: string(name='MediaId', description='媒资ID'),
    }
  ](name='MediaInfos', description='符合要求的媒资集合'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model BatchGetMediaInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchGetMediaInfosResponseBody(name='body'),
}

async function batchGetMediaInfosWithOptions(request: BatchGetMediaInfosRequest, runtime: Util.RuntimeOptions): BatchGetMediaInfosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.additionType)) {
    query['AdditionType'] = request.additionType;
  }
  if (!Util.isUnset(request.mediaIds)) {
    query['MediaIds'] = request.mediaIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetMediaInfos',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchGetMediaInfos(request: BatchGetMediaInfosRequest): BatchGetMediaInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchGetMediaInfosWithOptions(request, runtime);
}

model CancelFavoritePublicMediaRequest {
  mediaIds?: string(name='MediaIds'),
}

model CancelFavoritePublicMediaResponseBody = {
  ignoredList?: [ string ](name='IgnoredList'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CancelFavoritePublicMediaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelFavoritePublicMediaResponseBody(name='body'),
}

async function cancelFavoritePublicMediaWithOptions(request: CancelFavoritePublicMediaRequest, runtime: Util.RuntimeOptions): CancelFavoritePublicMediaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaIds)) {
    query['MediaIds'] = request.mediaIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelFavoritePublicMedia',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelFavoritePublicMedia(request: CancelFavoritePublicMediaRequest): CancelFavoritePublicMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelFavoritePublicMediaWithOptions(request, runtime);
}

model CancelUrlUploadJobsRequest {
  jobIds?: string(name='JobIds'),
  uploadUrls?: string(name='UploadUrls'),
}

model CancelUrlUploadJobsResponseBody = {
  canceledJobs?: [ string ](name='CanceledJobs'),
  nonExists?: [ string ](name='NonExists'),
  requestId?: string(name='RequestId'),
}

model CancelUrlUploadJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelUrlUploadJobsResponseBody(name='body'),
}

async function cancelUrlUploadJobsWithOptions(request: CancelUrlUploadJobsRequest, runtime: Util.RuntimeOptions): CancelUrlUploadJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobIds)) {
    query['JobIds'] = request.jobIds;
  }
  if (!Util.isUnset(request.uploadUrls)) {
    query['UploadUrls'] = request.uploadUrls;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelUrlUploadJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelUrlUploadJobs(request: CancelUrlUploadJobsRequest): CancelUrlUploadJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelUrlUploadJobsWithOptions(request, runtime);
}

model CreateAuditRequest {
  appId?: string(name='AppId'),
  auditContent?: string(name='AuditContent'),
}

model CreateAuditResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
}

model CreateAuditResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAuditResponseBody(name='body'),
}

async function createAuditWithOptions(request: CreateAuditRequest, runtime: Util.RuntimeOptions): CreateAuditResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.auditContent)) {
    query['AuditContent'] = request.auditContent;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAudit',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAudit(request: CreateAuditRequest): CreateAuditResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAuditWithOptions(request, runtime);
}

model CreateCustomTemplateRequest {
  name?: string(name='Name', description='模板名称'),
  subtype?: int32(name='Subtype', description='模板子类型。'),
  templateConfig?: string(name='TemplateConfig', description='模板参数'),
  type?: int32(name='Type', description='模板类型。'),
}

model CreateCustomTemplateResponseBody = {
  customTemplate?: {
    createTime?: string(name='CreateTime', description='模板创建时间'),
    isDefault?: boolean(name='IsDefault', description='是否默认模板'),
    modifiedTime?: string(name='ModifiedTime', description='模板修改时间'),
    status?: string(name='Status', description='模板状态'),
    subtype?: string(name='Subtype', description='模板子类型名称'),
    templateConfig?: string(name='TemplateConfig', description='模板参数'),
    templateId?: string(name='TemplateId', description='模板Id'),
    templateName?: string(name='TemplateName', description='模板名称'),
    type?: int32(name='Type', description='模板类型ID'),
    typeName?: string(name='TypeName', description='模板类型名称'),
  }(name='CustomTemplate', description='模板信息'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model CreateCustomTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCustomTemplateResponseBody(name='body'),
}

async function createCustomTemplateWithOptions(request: CreateCustomTemplateRequest, runtime: Util.RuntimeOptions): CreateCustomTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.subtype)) {
    query['Subtype'] = request.subtype;
  }
  if (!Util.isUnset(request.templateConfig)) {
    query['TemplateConfig'] = request.templateConfig;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCustomTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCustomTemplate(request: CreateCustomTemplateRequest): CreateCustomTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCustomTemplateWithOptions(request, runtime);
}

model CreateEditingProjectRequest {
  businessConfig?: string(name='BusinessConfig', description='工程业务配置。如果是直播剪辑工程必填OutputMediaConfig.StorageLocation,   Path 不填默认合成的直播片段存储在根路径下 OutputMediaTarget 不填默认oss-object，可以填vod-media 表示存储到vod  OutputMediaTarget 为vod-media 时，Path不生效。'),
  clipsParam?: string(name='ClipsParam', description='模板素材参数'),
  coverURL?: string(name='CoverURL', description='云剪辑工程封面'),
  description?: string(name='Description', description='云剪辑工程描述'),
  materialMaps?: string(name='MaterialMaps', description='工程关联素材，多个素材以逗号（,）分隔；每种类型最多支持10个素材ID'),
  projectType?: string(name='ProjectType', description='剪辑工程类型，EditingProject: 普通剪辑工程；LiveEditingProject: 直播剪辑工程'),
  templateId?: string(name='TemplateId', description='模板Id'),
  timeline?: string(name='Timeline', description='云剪辑工程时间线，Json格式'),
  title?: string(name='Title', description='云剪辑工程标题'),
}

model CreateEditingProjectResponseBody = {
  project?: {
    businessConfig?: string(name='BusinessConfig', description='工程业务配置'),
    businessStatus?: string(name='BusinessStatus', description='业务状态，业务状态 /** 预约中 **/ RESERVING(0, "Reserving"), /** 预约取消 **/ RESERVATION_CANCELED(1, "ReservationCanceled"), /** 直播中 **/ BROADCASTING(3, "BroadCasting"), /** 加载失败 **/ LOADING_FAILED(4, "LoadingFailed"), /** 直播结束 **/ LIVE_FINISHED(5, "LiveFinished");'),
    clipsParam?: string(name='ClipsParam', description='模板素材参数'),
    coverURL?: string(name='CoverURL', description='云剪辑工程封面。'),
    createSource?: string(name='CreateSource', description='云剪辑工程创建方式  -OpenAPI  -AliyunConsole  -WebSDK -LiveEditingOpenAPI -LiveEditingConsole'),
    createTime?: string(name='CreateTime', description='云剪辑工程创建时间'),
    description?: string(name='Description', description='云剪辑工程描述'),
    duration?: float(name='Duration', description='云剪辑工程时长'),
    modifiedSource?: string(name='ModifiedSource', description='云剪辑工程创建方式  -OpenAPI  -AliyunConsole  -WebSDK -LiveEditingOpenAPI -LiveEditingConsole'),
    modifiedTime?: string(name='ModifiedTime', description='云剪辑工程编辑时间'),
    projectId?: string(name='ProjectId', description='云剪辑工程ID'),
    projectType?: string(name='ProjectType', description='剪辑工程类型，EditingProject: 普通剪辑工程；LiveEditingProject: 直播剪辑工程'),
    status?: long(name='Status', description='云剪辑工程状态。  所有云剪辑工程状态列表：  -1:Draft  -2:Editing  -3:Producing  -4:Produced  -5:ProduceFailed  -7:Deleted'),
    statusName?: string(name='StatusName', description='云剪辑状态名称，对应状态列表中状态名称。'),
    templateId?: string(name='TemplateId', description='模板Id'),
    templateType?: string(name='TemplateType'),
    timeline?: string(name='Timeline', description='云剪辑工程时间线，Json格式'),
    title?: string(name='Title', description='云剪辑工程标题'),
  }(name='Project'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model CreateEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEditingProjectResponseBody(name='body'),
}

async function createEditingProjectWithOptions(request: CreateEditingProjectRequest, runtime: Util.RuntimeOptions): CreateEditingProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessConfig)) {
    query['BusinessConfig'] = request.businessConfig;
  }
  if (!Util.isUnset(request.clipsParam)) {
    query['ClipsParam'] = request.clipsParam;
  }
  if (!Util.isUnset(request.coverURL)) {
    query['CoverURL'] = request.coverURL;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.materialMaps)) {
    query['MaterialMaps'] = request.materialMaps;
  }
  if (!Util.isUnset(request.projectType)) {
    query['ProjectType'] = request.projectType;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.timeline)) {
    query['Timeline'] = request.timeline;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEditingProject',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createEditingProject(request: CreateEditingProjectRequest): CreateEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEditingProjectWithOptions(request, runtime);
}

model CreateLiveRecordTemplateRequest {
  name?: bytes(name='Name', description='资源名称'),
  recordFormat?: [ 
    {
      cycleDuration?: int32(name='CycleDuration'),
      format?: bytes(name='Format', description='格式'),
      ossObjectPrefix?: bytes(name='OssObjectPrefix', description='Oss对象名'),
      sliceDuration?: int32(name='SliceDuration', description='切片时长'),
      sliceOssObjectPrefix?: bytes(name='SliceOssObjectPrefix', description='切片Oss对象名'),
    }
  ](name='RecordFormat', description='录制格式'),
}

model CreateLiveRecordTemplateShrinkRequest {
  name?: bytes(name='Name', description='资源名称'),
  recordFormatShrink?: string(name='RecordFormat', description='录制格式'),
}

model CreateLiveRecordTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: bytes(name='TemplateId', description='资源一级ID'),
}

model CreateLiveRecordTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLiveRecordTemplateResponseBody(name='body'),
}

async function createLiveRecordTemplateWithOptions(tmpReq: CreateLiveRecordTemplateRequest, runtime: Util.RuntimeOptions): CreateLiveRecordTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new CreateLiveRecordTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.recordFormat)) {
    request.recordFormatShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.recordFormat, 'RecordFormat', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.recordFormatShrink)) {
    body['RecordFormat'] = request.recordFormatShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLiveRecordTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLiveRecordTemplate(request: CreateLiveRecordTemplateRequest): CreateLiveRecordTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLiveRecordTemplateWithOptions(request, runtime);
}

model CreatePipelineRequest {
  name?: string(name='Name', description='管道名称'),
  priority?: int32(name='Priority', description='优先级，1-10，默认6。数值越大，优先级越高'),
  speed?: string(name='Speed', description='管道类型。'),
}

model CreatePipelineResponseBody = {
  pipeline?: {
    createTime?: string(name='CreateTime', description='模板创建时间'),
    modifiedTime?: string(name='ModifiedTime', description='模板修改时间'),
    name?: string(name='Name', description='管道名称'),
    pipelineId?: string(name='PipelineId', description='管道Id'),
    priority?: int32(name='Priority', description='管道优先级'),
    speed?: string(name='Speed', description='管道类型'),
    status?: string(name='Status', description='管道状态'),
  }(name='Pipeline', description='管道信息'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model CreatePipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePipelineResponseBody(name='body'),
}

async function createPipelineWithOptions(request: CreatePipelineRequest, runtime: Util.RuntimeOptions): CreatePipelineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.speed)) {
    query['Speed'] = request.speed;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePipeline',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPipeline(request: CreatePipelineRequest): CreatePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPipelineWithOptions(request, runtime);
}

model CreateUploadMediaRequest {
  appId?: string(name='AppId'),
  entityId?: string(name='EntityId'),
  fileInfo?: string(name='FileInfo'),
  mediaMetaData?: string(name='MediaMetaData'),
  postProcessConfig?: string(name='PostProcessConfig'),
  uploadTargetConfig?: string(name='UploadTargetConfig'),
  userData?: string(name='UserData'),
}

model CreateUploadMediaResponseBody = {
  fileURL?: string(name='FileURL'),
  mediaId?: string(name='MediaId'),
  mediaURL?: string(name='MediaURL'),
  requestId?: string(name='RequestId', description='RequestId'),
  uploadAddress?: string(name='UploadAddress'),
  uploadAuth?: string(name='UploadAuth'),
}

model CreateUploadMediaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUploadMediaResponseBody(name='body'),
}

async function createUploadMediaWithOptions(request: CreateUploadMediaRequest, runtime: Util.RuntimeOptions): CreateUploadMediaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.entityId)) {
    query['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.fileInfo)) {
    query['FileInfo'] = request.fileInfo;
  }
  if (!Util.isUnset(request.mediaMetaData)) {
    query['MediaMetaData'] = request.mediaMetaData;
  }
  if (!Util.isUnset(request.postProcessConfig)) {
    query['PostProcessConfig'] = request.postProcessConfig;
  }
  if (!Util.isUnset(request.uploadTargetConfig)) {
    query['UploadTargetConfig'] = request.uploadTargetConfig;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUploadMedia',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUploadMedia(request: CreateUploadMediaRequest): CreateUploadMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUploadMediaWithOptions(request, runtime);
}

model CreateUploadStreamRequest {
  definition?: string(name='Definition'),
  fileExtension?: string(name='FileExtension'),
  HDRType?: string(name='HDRType'),
  mediaId?: string(name='MediaId'),
  userData?: string(name='UserData'),
}

model CreateUploadStreamResponseBody = {
  fileURL?: string(name='FileURL'),
  mediaId?: string(name='MediaId'),
  requestId?: string(name='RequestId'),
  uploadAddress?: string(name='UploadAddress'),
  uploadAuth?: string(name='UploadAuth'),
}

model CreateUploadStreamResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUploadStreamResponseBody(name='body'),
}

async function createUploadStreamWithOptions(request: CreateUploadStreamRequest, runtime: Util.RuntimeOptions): CreateUploadStreamResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.definition)) {
    query['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.fileExtension)) {
    query['FileExtension'] = request.fileExtension;
  }
  if (!Util.isUnset(request.HDRType)) {
    query['HDRType'] = request.HDRType;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUploadStream',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUploadStream(request: CreateUploadStreamRequest): CreateUploadStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUploadStreamWithOptions(request, runtime);
}

model DeleteCategoryRequest {
  cateId?: long(name='CateId'),
}

model DeleteCategoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCategoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCategoryResponseBody(name='body'),
}

async function deleteCategoryWithOptions(request: DeleteCategoryRequest, runtime: Util.RuntimeOptions): DeleteCategoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCategory',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCategory(request: DeleteCategoryRequest): DeleteCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCategoryWithOptions(request, runtime);
}

model DeleteCustomTemplateRequest {
  templateId?: string(name='TemplateId', description='模板ID'),
}

model DeleteCustomTemplateResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='是否成功'),
}

model DeleteCustomTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCustomTemplateResponseBody(name='body'),
}

async function deleteCustomTemplateWithOptions(request: DeleteCustomTemplateRequest, runtime: Util.RuntimeOptions): DeleteCustomTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCustomTemplate(request: DeleteCustomTemplateRequest): DeleteCustomTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomTemplateWithOptions(request, runtime);
}

model DeleteEditingProjectMaterialsRequest {
  materialIds?: string(name='MaterialIds', description='素材ID'),
  materialType?: string(name='MaterialType', description='素材类型'),
  projectId?: string(name='ProjectId', description='云剪辑工程ID'),
}

model DeleteEditingProjectMaterialsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteEditingProjectMaterialsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEditingProjectMaterialsResponseBody(name='body'),
}

async function deleteEditingProjectMaterialsWithOptions(request: DeleteEditingProjectMaterialsRequest, runtime: Util.RuntimeOptions): DeleteEditingProjectMaterialsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.materialIds)) {
    query['MaterialIds'] = request.materialIds;
  }
  if (!Util.isUnset(request.materialType)) {
    query['MaterialType'] = request.materialType;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEditingProjectMaterials',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEditingProjectMaterials(request: DeleteEditingProjectMaterialsRequest): DeleteEditingProjectMaterialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEditingProjectMaterialsWithOptions(request, runtime);
}

model DeleteEditingProjectsRequest {
  projectIds?: string(name='ProjectIds', description='云剪辑工程ID。支持多个云剪辑工程，以逗号分隔。'),
}

model DeleteEditingProjectsResponseBody = {
  ignoredList?: string(name='IgnoredList'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteEditingProjectsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEditingProjectsResponseBody(name='body'),
}

async function deleteEditingProjectsWithOptions(request: DeleteEditingProjectsRequest, runtime: Util.RuntimeOptions): DeleteEditingProjectsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectIds)) {
    query['ProjectIds'] = request.projectIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEditingProjects',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEditingProjects(request: DeleteEditingProjectsRequest): DeleteEditingProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEditingProjectsWithOptions(request, runtime);
}

model DeleteLiveTranscodeJobRequest {
  jobId?: string(name='JobId', description='模板Id'),
}

model DeleteLiveTranscodeJobResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
}

model DeleteLiveTranscodeJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLiveTranscodeJobResponseBody(name='body'),
}

async function deleteLiveTranscodeJobWithOptions(request: DeleteLiveTranscodeJobRequest, runtime: Util.RuntimeOptions): DeleteLiveTranscodeJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLiveTranscodeJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLiveTranscodeJob(request: DeleteLiveTranscodeJobRequest): DeleteLiveTranscodeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLiveTranscodeJobWithOptions(request, runtime);
}

model DeleteLiveTranscodeTemplateRequest {
  templateId?: string(name='TemplateId', description='模板Id'),
}

model DeleteLiveTranscodeTemplateResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
}

model DeleteLiveTranscodeTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLiveTranscodeTemplateResponseBody(name='body'),
}

async function deleteLiveTranscodeTemplateWithOptions(request: DeleteLiveTranscodeTemplateRequest, runtime: Util.RuntimeOptions): DeleteLiveTranscodeTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLiveTranscodeTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLiveTranscodeTemplate(request: DeleteLiveTranscodeTemplateRequest): DeleteLiveTranscodeTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLiveTranscodeTemplateWithOptions(request, runtime);
}

model DeleteMediaInfosRequest {
  inputURLs?: string(name='InputURLs', description='待注册的媒资在相应系统中的地址'),
  mediaIds?: string(name='MediaIds', description='ICE 媒资ID'),
}

model DeleteMediaInfosResponseBody = {
  ignoredList?: [ string ](name='IgnoredList', description='出现获取错误的ID或inputUr'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model DeleteMediaInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMediaInfosResponseBody(name='body'),
}

async function deleteMediaInfosWithOptions(request: DeleteMediaInfosRequest, runtime: Util.RuntimeOptions): DeleteMediaInfosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.inputURLs)) {
    query['InputURLs'] = request.inputURLs;
  }
  if (!Util.isUnset(request.mediaIds)) {
    query['MediaIds'] = request.mediaIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMediaInfos',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMediaInfos(request: DeleteMediaInfosRequest): DeleteMediaInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMediaInfosWithOptions(request, runtime);
}

model DeleteMediaProducingJobsRequest {
  jobIds?: string(name='JobIds'),
}

model DeleteMediaProducingJobsResponseBody = {
  ignoreList?: string(name='IgnoreList'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteMediaProducingJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMediaProducingJobsResponseBody(name='body'),
}

async function deleteMediaProducingJobsWithOptions(request: DeleteMediaProducingJobsRequest, runtime: Util.RuntimeOptions): DeleteMediaProducingJobsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.jobIds)) {
    body['JobIds'] = request.jobIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMediaProducingJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMediaProducingJobs(request: DeleteMediaProducingJobsRequest): DeleteMediaProducingJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMediaProducingJobsWithOptions(request, runtime);
}

model DeletePipelineRequest {
  pipelineId?: string(name='PipelineId', description='管道ID'),
}

model DeletePipelineResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='是否成功'),
}

model DeletePipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePipelineResponseBody(name='body'),
}

async function deletePipelineWithOptions(request: DeletePipelineRequest, runtime: Util.RuntimeOptions): DeletePipelineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePipeline',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePipeline(request: DeletePipelineRequest): DeletePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePipelineWithOptions(request, runtime);
}

model DeletePlayInfoRequest {
  fileURLs?: string(name='FileURLs'),
  mediaId?: string(name='MediaId'),
}

model DeletePlayInfoResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
}

model DeletePlayInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePlayInfoResponseBody(name='body'),
}

async function deletePlayInfoWithOptions(request: DeletePlayInfoRequest, runtime: Util.RuntimeOptions): DeletePlayInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileURLs)) {
    query['FileURLs'] = request.fileURLs;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePlayInfo',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePlayInfo(request: DeletePlayInfoRequest): DeletePlayInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePlayInfoWithOptions(request, runtime);
}

model DeleteSmartJobRequest {
  jobId?: string(name='JobId', description='任务id，多个任务id用英文逗号分割'),
}

model DeleteSmartJobResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
}

model DeleteSmartJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSmartJobResponseBody(name='body'),
}

async function deleteSmartJobWithOptions(request: DeleteSmartJobRequest, runtime: Util.RuntimeOptions): DeleteSmartJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSmartJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSmartJob(request: DeleteSmartJobRequest): DeleteSmartJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSmartJobWithOptions(request, runtime);
}

model DeleteTemplateRequest {
  templateIds?: string(name='TemplateIds', description='模板id，多个id用英文逗号隔开'),
}

model DeleteTemplateResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
}

model DeleteTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTemplateResponseBody(name='body'),
}

async function deleteTemplateWithOptions(request: DeleteTemplateRequest, runtime: Util.RuntimeOptions): DeleteTemplateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTemplate(request: DeleteTemplateRequest): DeleteTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTemplateWithOptions(request, runtime);
}

model DescribeBizUserTypeRequest {
  region?: string(name='Region'),
}

model DescribeBizUserTypeResponseBody = {
  data?: [ 
    {
      profile?: string(name='Profile'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId', description='Id'),
}

model DescribeBizUserTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBizUserTypeResponseBody(name='body'),
}

async function describeBizUserTypeWithOptions(request: DescribeBizUserTypeRequest, runtime: Util.RuntimeOptions): DescribeBizUserTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBizUserType',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBizUserType(request: DescribeBizUserTypeRequest): DescribeBizUserTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBizUserTypeWithOptions(request, runtime);
}

model DescribeFilterConfigsRequest {
  type?: string(name='Type'),
}

model DescribeFilterConfigsResponseBody = {
  filterConfigs?: [ 
    {
      filterName?: string(name='FilterName'),
      itemConfigs?: string(name='ItemConfigs'),
      type?: string(name='Type'),
    }
  ](name='FilterConfigs'),
  requestId?: string(name='RequestId', description='Id'),
}

model DescribeFilterConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFilterConfigsResponseBody(name='body'),
}

async function describeFilterConfigsWithOptions(request: DescribeFilterConfigsRequest, runtime: Util.RuntimeOptions): DescribeFilterConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFilterConfigs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFilterConfigs(request: DescribeFilterConfigsRequest): DescribeFilterConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFilterConfigsWithOptions(request, runtime);
}

model DescribeLivePubExperienceMetricDataRequest {
  beginTs?: string(name='BeginTs'),
  domain?: string(name='Domain'),
  endTs?: string(name='EndTs'),
  metricType?: string(name='MetricType'),
  os?: string(name='Os'),
  pubProtocol?: string(name='PubProtocol'),
  terminalType?: string(name='TerminalType'),
}

model DescribeLivePubExperienceMetricDataResponseBody = {
  metricList?: [ 
    {
      avgScore?: float(name='AvgScore'),
      maxScore?: float(name='MaxScore'),
      minScore?: float(name='MinScore'),
    }
  ](name='MetricList'),
  requestId?: string(name='RequestId', description='Id'),
}

model DescribeLivePubExperienceMetricDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLivePubExperienceMetricDataResponseBody(name='body'),
}

async function describeLivePubExperienceMetricDataWithOptions(request: DescribeLivePubExperienceMetricDataRequest, runtime: Util.RuntimeOptions): DescribeLivePubExperienceMetricDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.pubProtocol)) {
    query['PubProtocol'] = request.pubProtocol;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLivePubExperienceMetricData',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLivePubExperienceMetricData(request: DescribeLivePubExperienceMetricDataRequest): DescribeLivePubExperienceMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLivePubExperienceMetricDataWithOptions(request, runtime);
}

model DescribeLivePubListRequest {
  beginTs?: string(name='BeginTs'),
  domain?: string(name='Domain'),
  endTs?: string(name='EndTs'),
  metricType?: string(name='MetricType'),
  os?: string(name='Os'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  pubProtocol?: string(name='PubProtocol'),
  terminalType?: string(name='TerminalType'),
}

model DescribeLivePubListResponseBody = {
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  pubInfoList?: [ 
    {
      area?: string(name='Area'),
      cpuUsageRate?: string(name='CpuUsageRate'),
      domain?: string(name='Domain'),
      endTs?: string(name='EndTs'),
      fps?: string(name='Fps'),
      kbps?: string(name='Kbps'),
      pubHeapUpDuration?: string(name='PubHeapUpDuration'),
      pubMachineType?: string(name='PubMachineType'),
      secondPlayRate?: string(name='SecondPlayRate'),
      startTs?: string(name='StartTs'),
      streamName?: string(name='StreamName'),
    }
  ](name='PubInfoList'),
  requestId?: string(name='RequestId', description='Id'),
  totalCount?: long(name='TotalCount'),
}

model DescribeLivePubListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLivePubListResponseBody(name='body'),
}

async function describeLivePubListWithOptions(request: DescribeLivePubListRequest, runtime: Util.RuntimeOptions): DescribeLivePubListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pubProtocol)) {
    query['PubProtocol'] = request.pubProtocol;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLivePubList',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLivePubList(request: DescribeLivePubListRequest): DescribeLivePubListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLivePubListWithOptions(request, runtime);
}

model DescribeLivePubMetricDataRequest {
  beginTs?: long(name='BeginTs'),
  domain?: string(name='Domain'),
  endTs?: long(name='EndTs'),
  experienceLevel?: string(name='ExperienceLevel'),
  metricType?: string(name='MetricType'),
  os?: string(name='Os'),
  pubProtocol?: string(name='PubProtocol'),
  sdkVersion?: string(name='SdkVersion'),
  streamName?: string(name='StreamName'),
  terminalType?: string(name='TerminalType'),
}

model DescribeLivePubMetricDataResponseBody = {
  nodes?: [ 
    {
      duration?: long(name='Duration'),
      time?: long(name='Time'),
    }
  ](name='Nodes'),
  requestId?: string(name='RequestId', description='Id'),
}

model DescribeLivePubMetricDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLivePubMetricDataResponseBody(name='body'),
}

async function describeLivePubMetricDataWithOptions(request: DescribeLivePubMetricDataRequest, runtime: Util.RuntimeOptions): DescribeLivePubMetricDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.experienceLevel)) {
    query['ExperienceLevel'] = request.experienceLevel;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.pubProtocol)) {
    query['PubProtocol'] = request.pubProtocol;
  }
  if (!Util.isUnset(request.sdkVersion)) {
    query['SdkVersion'] = request.sdkVersion;
  }
  if (!Util.isUnset(request.streamName)) {
    query['StreamName'] = request.streamName;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLivePubMetricData',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLivePubMetricData(request: DescribeLivePubMetricDataRequest): DescribeLivePubMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLivePubMetricDataWithOptions(request, runtime);
}

model DescribeLiveSubExperienceMetricDataRequest {
  appName?: string(name='AppName'),
  beginTs?: string(name='BeginTs'),
  endTs?: string(name='EndTs'),
  experienceLevel?: string(name='ExperienceLevel'),
  metricType?: string(name='MetricType'),
  os?: string(name='Os'),
  subProtocol?: string(name='SubProtocol'),
  terminalType?: string(name='TerminalType'),
}

model DescribeLiveSubExperienceMetricDataResponseBody = {
  metricList?: [ 
    {
      avgScore?: float(name='AvgScore'),
      maxScore?: float(name='MaxScore'),
      minScore?: float(name='MinScore'),
    }
  ](name='MetricList'),
  requestId?: string(name='RequestId', description='Id'),
}

model DescribeLiveSubExperienceMetricDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLiveSubExperienceMetricDataResponseBody(name='body'),
}

async function describeLiveSubExperienceMetricDataWithOptions(request: DescribeLiveSubExperienceMetricDataRequest, runtime: Util.RuntimeOptions): DescribeLiveSubExperienceMetricDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.experienceLevel)) {
    query['ExperienceLevel'] = request.experienceLevel;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.subProtocol)) {
    query['SubProtocol'] = request.subProtocol;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLiveSubExperienceMetricData',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLiveSubExperienceMetricData(request: DescribeLiveSubExperienceMetricDataRequest): DescribeLiveSubExperienceMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLiveSubExperienceMetricDataWithOptions(request, runtime);
}

model DescribeLiveSubListRequest {
  appName?: string(name='AppName'),
  beginTs?: string(name='BeginTs'),
  definition?: string(name='Definition'),
  endTs?: string(name='EndTs'),
  experienceLevel?: string(name='ExperienceLevel'),
  itemConfigs?: string(name='ItemConfigs'),
  metricType?: string(name='MetricType'),
  network?: string(name='Network'),
  os?: string(name='Os'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  streamName?: string(name='StreamName'),
  subProtocol?: string(name='SubProtocol'),
  terminalType?: string(name='TerminalType'),
}

model DescribeLiveSubListResponseBody = {
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId', description='Id'),
  subInfoList?: [ 
    {
      cacheDuration?: string(name='CacheDuration'),
      cpuUsageRate?: string(name='CpuUsageRate'),
      firstFrameDuration?: string(name='FirstFrameDuration'),
      playFps?: string(name='PlayFps'),
      secondPlayRate?: string(name='SecondPlayRate'),
      subNetBitrate?: string(name='SubNetBitrate'),
      subRate?: string(name='SubRate'),
      traceId?: string(name='TraceId'),
      videoStuck?: string(name='VideoStuck'),
    }
  ](name='SubInfoList'),
  totalCount?: long(name='TotalCount'),
}

model DescribeLiveSubListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLiveSubListResponseBody(name='body'),
}

async function describeLiveSubListWithOptions(request: DescribeLiveSubListRequest, runtime: Util.RuntimeOptions): DescribeLiveSubListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.definition)) {
    query['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.experienceLevel)) {
    query['ExperienceLevel'] = request.experienceLevel;
  }
  if (!Util.isUnset(request.itemConfigs)) {
    query['ItemConfigs'] = request.itemConfigs;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.network)) {
    query['Network'] = request.network;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.streamName)) {
    query['StreamName'] = request.streamName;
  }
  if (!Util.isUnset(request.subProtocol)) {
    query['SubProtocol'] = request.subProtocol;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLiveSubList',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLiveSubList(request: DescribeLiveSubListRequest): DescribeLiveSubListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLiveSubListWithOptions(request, runtime);
}

model DescribeLiveSubMetricDataRequest {
  appName?: string(name='AppName'),
  beginTs?: long(name='BeginTs'),
  definition?: string(name='Definition'),
  endTs?: long(name='EndTs'),
  experienceLevel?: string(name='ExperienceLevel'),
  itemConfigs?: string(name='ItemConfigs'),
  metricType?: string(name='MetricType'),
  network?: string(name='Network'),
  os?: string(name='Os'),
  sdkVersion?: string(name='SdkVersion'),
  streamName?: string(name='StreamName'),
  subProtocol?: string(name='SubProtocol'),
  terminalType?: string(name='TerminalType'),
}

model DescribeLiveSubMetricDataResponseBody = {
  nodes?: [ 
    {
      duration?: long(name='Duration'),
      time?: long(name='Time'),
    }
  ](name='Nodes'),
  requestId?: string(name='RequestId', description='Id'),
}

model DescribeLiveSubMetricDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLiveSubMetricDataResponseBody(name='body'),
}

async function describeLiveSubMetricDataWithOptions(request: DescribeLiveSubMetricDataRequest, runtime: Util.RuntimeOptions): DescribeLiveSubMetricDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.definition)) {
    query['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.experienceLevel)) {
    query['ExperienceLevel'] = request.experienceLevel;
  }
  if (!Util.isUnset(request.itemConfigs)) {
    query['ItemConfigs'] = request.itemConfigs;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.network)) {
    query['Network'] = request.network;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.sdkVersion)) {
    query['SdkVersion'] = request.sdkVersion;
  }
  if (!Util.isUnset(request.streamName)) {
    query['StreamName'] = request.streamName;
  }
  if (!Util.isUnset(request.subProtocol)) {
    query['SubProtocol'] = request.subProtocol;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLiveSubMetricData',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLiveSubMetricData(request: DescribeLiveSubMetricDataRequest): DescribeLiveSubMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLiveSubMetricDataWithOptions(request, runtime);
}

model DescribeMeterIceEditUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: long(name='Interval'),
  region?: string(name='Region'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterIceEditUsageResponseBody = {
  data?: [ 
    {
      duration?: long(name='Duration'),
      profile?: string(name='Profile'),
      time?: long(name='Time'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId', description='Id'),
}

model DescribeMeterIceEditUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterIceEditUsageResponseBody(name='body'),
}

async function describeMeterIceEditUsageWithOptions(request: DescribeMeterIceEditUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterIceEditUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterIceEditUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterIceEditUsage(request: DescribeMeterIceEditUsageRequest): DescribeMeterIceEditUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterIceEditUsageWithOptions(request, runtime);
}

model DescribeMeterIceLiveMediaConvertUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: long(name='Interval'),
  region?: string(name='Region'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterIceLiveMediaConvertUsageResponseBody = {
  data?: [ 
    {
      duration?: long(name='Duration'),
      specification?: string(name='Specification'),
      time?: long(name='Time'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId', description='Id'),
}

model DescribeMeterIceLiveMediaConvertUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterIceLiveMediaConvertUsageResponseBody(name='body'),
}

async function describeMeterIceLiveMediaConvertUsageWithOptions(request: DescribeMeterIceLiveMediaConvertUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterIceLiveMediaConvertUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterIceLiveMediaConvertUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterIceLiveMediaConvertUsage(request: DescribeMeterIceLiveMediaConvertUsageRequest): DescribeMeterIceLiveMediaConvertUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterIceLiveMediaConvertUsageWithOptions(request, runtime);
}

model DescribeMeterIceMediaConvertUHDUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: string(name='Interval'),
  regionId?: string(name='RegionId'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterIceMediaConvertUHDUsageResponseBody = {
  data?: [ 
    {
      duration?: long(name='Duration'),
      specification?: string(name='Specification'),
      time?: long(name='Time'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId', description='Id'),
}

model DescribeMeterIceMediaConvertUHDUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterIceMediaConvertUHDUsageResponseBody(name='body'),
}

async function describeMeterIceMediaConvertUHDUsageWithOptions(request: DescribeMeterIceMediaConvertUHDUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterIceMediaConvertUHDUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterIceMediaConvertUHDUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterIceMediaConvertUHDUsage(request: DescribeMeterIceMediaConvertUHDUsageRequest): DescribeMeterIceMediaConvertUHDUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterIceMediaConvertUHDUsageWithOptions(request, runtime);
}

model DescribeMeterIceMediaConvertUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: long(name='Interval'),
  region?: string(name='Region'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterIceMediaConvertUsageResponseBody = {
  data?: [ 
    {
      duration?: long(name='Duration'),
      specification?: string(name='Specification'),
      time?: long(name='Time'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId', description='Id'),
}

model DescribeMeterIceMediaConvertUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterIceMediaConvertUsageResponseBody(name='body'),
}

async function describeMeterIceMediaConvertUsageWithOptions(request: DescribeMeterIceMediaConvertUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterIceMediaConvertUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterIceMediaConvertUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterIceMediaConvertUsage(request: DescribeMeterIceMediaConvertUsageRequest): DescribeMeterIceMediaConvertUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterIceMediaConvertUsageWithOptions(request, runtime);
}

model DescribeMeterIceMpsAiUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: long(name='Interval'),
  region?: string(name='Region'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterIceMpsAiUsageResponseBody = {
  data?: [ 
    {
      duration?: long(name='Duration'),
      time?: long(name='Time'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId', description='Id'),
}

model DescribeMeterIceMpsAiUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterIceMpsAiUsageResponseBody(name='body'),
}

async function describeMeterIceMpsAiUsageWithOptions(request: DescribeMeterIceMpsAiUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterIceMpsAiUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterIceMpsAiUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterIceMpsAiUsage(request: DescribeMeterIceMpsAiUsageRequest): DescribeMeterIceMpsAiUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterIceMpsAiUsageWithOptions(request, runtime);
}

model DescribeMeterIceSummaryRequest {
  endTs?: long(name='EndTs'),
  region?: string(name='Region'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterIceSummaryResponseBody = {
  data?: [ 
    {
      editingDuration?: string(name='EditingDuration'),
      liveTranscodeDuration?: long(name='LiveTranscodeDuration'),
      mpsAiDuration?: long(name='MpsAiDuration'),
      mpsTranscodeDuration?: long(name='MpsTranscodeDuration'),
      mpsTranscodeUHDDuration?: long(name='MpsTranscodeUHDDuration'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId', description='Id'),
}

model DescribeMeterIceSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterIceSummaryResponseBody(name='body'),
}

async function describeMeterIceSummaryWithOptions(request: DescribeMeterIceSummaryRequest, runtime: Util.RuntimeOptions): DescribeMeterIceSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterIceSummary',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterIceSummary(request: DescribeMeterIceSummaryRequest): DescribeMeterIceSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterIceSummaryWithOptions(request, runtime);
}

model DescribePalyDetailRequest {
  traceId?: string(name='TraceId'),
}

model DescribePalyDetailResponseBody = {
  data?: [ 
    {
      appName?: string(name='AppName'),
      bps?: string(name='Bps'),
      broadcastPace?: string(name='BroadcastPace'),
      codec?: string(name='Codec'),
      decodeStuckTime?: string(name='DecodeStuckTime'),
      definition?: string(name='Definition'),
      firstFrameDuration?: string(name='FirstFrameDuration'),
      fps?: string(name='Fps'),
      isHardDecode?: string(name='IsHardDecode'),
      mdat?: string(name='Mdat'),
      moov?: string(name='Moov'),
      netWorkDuration?: string(name='NetWorkDuration'),
      network?: string(name='Network'),
      networkStuckTime?: string(name='NetworkStuckTime'),
      os?: string(name='Os'),
      playTs?: string(name='PlayTs'),
      playerLoadDuration?: string(name='PlayerLoadDuration'),
      playerPreDealDuration?: string(name='PlayerPreDealDuration'),
      playerReadyDuration?: string(name='PlayerReadyDuration'),
      sdkVersion?: string(name='SdkVersion'),
      sessionId?: string(name='SessionId'),
      status?: string(name='Status'),
      terminalType?: string(name='TerminalType'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId', description='Id'),
}

model DescribePalyDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePalyDetailResponseBody(name='body'),
}

async function describePalyDetailWithOptions(request: DescribePalyDetailRequest, runtime: Util.RuntimeOptions): DescribePalyDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.traceId)) {
    query['TraceId'] = request.traceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePalyDetail',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePalyDetail(request: DescribePalyDetailRequest): DescribePalyDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePalyDetailWithOptions(request, runtime);
}

model DescribePalyEventListRequest {
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  traceId?: string(name='TraceId'),
}

model DescribePalyEventListResponseBody = {
  eventList?: [ 
    {
      description?: string(name='Description'),
      duration?: float(name='Duration'),
      eventName?: string(name='EventName'),
      time?: long(name='Time'),
      topic?: string(name='Topic'),
    }
  ](name='EventList'),
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId', description='Id'),
  totalCnt?: long(name='TotalCnt'),
}

model DescribePalyEventListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePalyEventListResponseBody(name='body'),
}

async function describePalyEventListWithOptions(request: DescribePalyEventListRequest, runtime: Util.RuntimeOptions): DescribePalyEventListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.traceId)) {
    query['TraceId'] = request.traceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePalyEventList',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePalyEventList(request: DescribePalyEventListRequest): DescribePalyEventListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePalyEventListWithOptions(request, runtime);
}

model DescribePalyListRequest {
  beginTs?: string(name='BeginTs'),
  endTs?: string(name='EndTs'),
  orderName?: string(name='OrderName'),
  orderType?: string(name='OrderType'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  playType?: string(name='PlayType'),
  status?: string(name='Status'),
  traceId?: string(name='TraceId'),
}

model DescribePalyListResponseBody = {
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  playList?: [ 
    {
      firstFrameDuration?: string(name='FirstFrameDuration'),
      playDuration?: string(name='PlayDuration'),
      playType?: string(name='PlayType'),
      sessionId?: string(name='SessionId'),
      status?: string(name='Status'),
      stuckDuration?: string(name='StuckDuration'),
      traceId?: string(name='TraceId'),
      videoDuration?: string(name='VideoDuration'),
      videoId?: string(name='VideoId'),
    }
  ](name='PlayList'),
  requestId?: string(name='RequestId', description='Id'),
  totalCnt?: long(name='TotalCnt'),
}

model DescribePalyListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePalyListResponseBody(name='body'),
}

async function describePalyListWithOptions(request: DescribePalyListRequest, runtime: Util.RuntimeOptions): DescribePalyListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.orderName)) {
    query['OrderName'] = request.orderName;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.playType)) {
    query['PlayType'] = request.playType;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.traceId)) {
    query['TraceId'] = request.traceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePalyList',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePalyList(request: DescribePalyListRequest): DescribePalyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePalyListWithOptions(request, runtime);
}

model DescribePlayExperienceMetricDataRequest {
  appName?: string(name='AppName'),
  beginTs?: string(name='BeginTs'),
  endTs?: string(name='EndTs'),
  experienceLevel?: string(name='ExperienceLevel'),
  os?: string(name='Os'),
  terminalType?: string(name='TerminalType'),
}

model DescribePlayExperienceMetricDataResponseBody = {
  data?: [ 
    {
      avgScore?: float(name='AvgScore'),
      maxScore?: float(name='MaxScore'),
      minScore?: float(name='MinScore'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId', description='Id'),
}

model DescribePlayExperienceMetricDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePlayExperienceMetricDataResponseBody(name='body'),
}

async function describePlayExperienceMetricDataWithOptions(request: DescribePlayExperienceMetricDataRequest, runtime: Util.RuntimeOptions): DescribePlayExperienceMetricDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.experienceLevel)) {
    query['ExperienceLevel'] = request.experienceLevel;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePlayExperienceMetricData',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePlayExperienceMetricData(request: DescribePlayExperienceMetricDataRequest): DescribePlayExperienceMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlayExperienceMetricDataWithOptions(request, runtime);
}

model DescribePlayFirstFrameDurationMetricDataRequest {
  beginTs?: string(name='BeginTs'),
  endTs?: string(name='EndTs'),
  traceId?: string(name='TraceId'),
}

model DescribePlayFirstFrameDurationMetricDataResponseBody = {
  nodes?: [ 
    {
      duration?: long(name='Duration'),
      time?: long(name='Time'),
    }
  ](name='Nodes'),
  requestId?: string(name='RequestId', description='Id'),
}

model DescribePlayFirstFrameDurationMetricDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePlayFirstFrameDurationMetricDataResponseBody(name='body'),
}

async function describePlayFirstFrameDurationMetricDataWithOptions(request: DescribePlayFirstFrameDurationMetricDataRequest, runtime: Util.RuntimeOptions): DescribePlayFirstFrameDurationMetricDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.traceId)) {
    query['TraceId'] = request.traceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePlayFirstFrameDurationMetricData',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePlayFirstFrameDurationMetricData(request: DescribePlayFirstFrameDurationMetricDataRequest): DescribePlayFirstFrameDurationMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlayFirstFrameDurationMetricDataWithOptions(request, runtime);
}

model DescribePlayMetricDataRequest {
  appName?: string(name='AppName'),
  beginTs?: long(name='BeginTs'),
  definition?: string(name='Definition'),
  endTs?: long(name='EndTs'),
  experienceLevel?: string(name='ExperienceLevel'),
  itemConfigs?: string(name='ItemConfigs'),
  metricType?: string(name='MetricType'),
  network?: string(name='Network'),
  os?: string(name='Os'),
  sdkVersion?: string(name='SdkVersion'),
  terminalType?: string(name='TerminalType'),
}

model DescribePlayMetricDataResponseBody = {
  nodes?: [ 
    {
      x?: long(name='X'),
      y?: long(name='Y'),
    }
  ](name='Nodes'),
  requestId?: string(name='RequestId', description='Id'),
}

model DescribePlayMetricDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePlayMetricDataResponseBody(name='body'),
}

async function describePlayMetricDataWithOptions(request: DescribePlayMetricDataRequest, runtime: Util.RuntimeOptions): DescribePlayMetricDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.definition)) {
    query['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.experienceLevel)) {
    query['ExperienceLevel'] = request.experienceLevel;
  }
  if (!Util.isUnset(request.itemConfigs)) {
    query['ItemConfigs'] = request.itemConfigs;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.network)) {
    query['Network'] = request.network;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.sdkVersion)) {
    query['SdkVersion'] = request.sdkVersion;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePlayMetricData',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePlayMetricData(request: DescribePlayMetricDataRequest): DescribePlayMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlayMetricDataWithOptions(request, runtime);
}

model DescribePlayQoeListRequest {
  appName?: string(name='AppName'),
  beginTs?: long(name='BeginTs'),
  definition?: string(name='Definition'),
  endTs?: long(name='EndTs'),
  itemConfigs?: string(name='ItemConfigs'),
  metricType?: string(name='MetricType'),
  network?: string(name='Network'),
  os?: string(name='Os'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  terminalType?: string(name='TerminalType'),
}

model DescribePlayQoeListResponseBody = {
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  qoeInfoList?: [ 
    {
      qoeFinishedVV?: float(name='QoeFinishedVV'),
      qoeFinishedVVRate?: float(name='QoeFinishedVVRate'),
      qoeUFinishedVVTime?: float(name='QoeUFinishedVVTime'),
      qoeUV?: float(name='QoeUV'),
      qoeUVVDuration?: float(name='QoeUVVDuration'),
      qoeUVVTime?: float(name='QoeUVVTime'),
      qoeVDuration?: float(name='QoeVDuration'),
      qoeVVDuration?: float(name='QoeVVDuration'),
      vpsid?: string(name='Vpsid'),
    }
  ](name='QoeInfoList'),
  requestId?: string(name='RequestId', description='Id'),
  totalCount?: long(name='TotalCount'),
}

model DescribePlayQoeListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePlayQoeListResponseBody(name='body'),
}

async function describePlayQoeListWithOptions(request: DescribePlayQoeListRequest, runtime: Util.RuntimeOptions): DescribePlayQoeListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.definition)) {
    query['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.itemConfigs)) {
    query['ItemConfigs'] = request.itemConfigs;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.network)) {
    query['Network'] = request.network;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePlayQoeList',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePlayQoeList(request: DescribePlayQoeListRequest): DescribePlayQoeListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlayQoeListWithOptions(request, runtime);
}

model DescribePlayQosListRequest {
  appName?: string(name='AppName'),
  beginTs?: string(name='BeginTs'),
  definition?: string(name='Definition'),
  endTs?: string(name='EndTs'),
  itemConfigs?: string(name='ItemConfigs'),
  metricType?: string(name='MetricType'),
  network?: string(name='Network'),
  os?: string(name='Os'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  terminalType?: string(name='TerminalType'),
}

model DescribePlayQosListResponseBody = {
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  qosInfoList?: [ 
    {
      qosFirstFrame?: string(name='QosFirstFrame'),
      qosKbps?: string(name='QosKbps'),
      qosPlay?: string(name='QosPlay'),
      qosPlayFail?: string(name='QosPlayFail'),
      qosRealPlay?: string(name='QosRealPlay'),
      qosSeedFailRate?: string(name='QosSeedFailRate'),
      qosStuckRate?: string(name='QosStuckRate'),
      vpsid?: string(name='Vpsid'),
    }
  ](name='QosInfoList'),
  requestId?: string(name='RequestId', description='Id'),
  totalCount?: long(name='TotalCount'),
}

model DescribePlayQosListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePlayQosListResponseBody(name='body'),
}

async function describePlayQosListWithOptions(request: DescribePlayQosListRequest, runtime: Util.RuntimeOptions): DescribePlayQosListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.definition)) {
    query['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.itemConfigs)) {
    query['ItemConfigs'] = request.itemConfigs;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.network)) {
    query['Network'] = request.network;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePlayQosList',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePlayQosList(request: DescribePlayQosListRequest): DescribePlayQosListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlayQosListWithOptions(request, runtime);
}

model DescribeQueryConfigsRequest {
  type?: string(name='Type'),
}

model DescribeQueryConfigsResponseBody = {
  configs?: [ 
    {
      value?: string(name='Value'),
    }
  ](name='Configs'),
  requestId?: string(name='RequestId', description='Id'),
}

model DescribeQueryConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeQueryConfigsResponseBody(name='body'),
}

async function describeQueryConfigsWithOptions(request: DescribeQueryConfigsRequest, runtime: Util.RuntimeOptions): DescribeQueryConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeQueryConfigs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeQueryConfigs(request: DescribeQueryConfigsRequest): DescribeQueryConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeQueryConfigsWithOptions(request, runtime);
}

model DownloadResourceByResourceIdsRequest {
  resourceIds?: string(name='ResourceIds', description='资源id号'),
}

model DownloadResourceByResourceIdsResponseBody = {
  expireTime?: long(name='ExpireTime', description='过期时间'),
  requestId?: string(name='RequestId', description='请求Id'),
  resourcePackageUrl?: string(name='ResourcePackageUrl', description='资源地址'),
}

model DownloadResourceByResourceIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DownloadResourceByResourceIdsResponseBody(name='body'),
}

async function downloadResourceByResourceIdsWithOptions(request: DownloadResourceByResourceIdsRequest, runtime: Util.RuntimeOptions): DownloadResourceByResourceIdsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DownloadResourceByResourceIds',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function downloadResourceByResourceIds(request: DownloadResourceByResourceIdsRequest): DownloadResourceByResourceIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return downloadResourceByResourceIdsWithOptions(request, runtime);
}

model GetAuditConfigRequest {
  appId?: string(name='AppId'),
}

model GetAuditConfigResponseBody = {
  audit?: {
    channel?: string(name='Channel'),
    createTime?: string(name='CreateTime'),
    legalSwitch?: string(name='LegalSwitch'),
    updateTime?: string(name='UpdateTime'),
    userId?: string(name='UserId'),
  }(name='Audit'),
  requestId?: string(name='RequestId'),
}

model GetAuditConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAuditConfigResponseBody(name='body'),
}

async function getAuditConfigWithOptions(request: GetAuditConfigRequest, runtime: Util.RuntimeOptions): GetAuditConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAuditConfig',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAuditConfig(request: GetAuditConfigRequest): GetAuditConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuditConfigWithOptions(request, runtime);
}

model GetCategoriesRequest {
  cateId?: long(name='CateId'),
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  sortBy?: string(name='SortBy'),
  type?: string(name='Type'),
}

model GetCategoriesResponseBody = {
  category?: {
    cateId?: long(name='CateId'),
    cateName?: string(name='CateName'),
    level?: long(name='Level'),
    parentId?: long(name='ParentId'),
    type?: string(name='Type'),
  }(name='Category'),
  requestId?: string(name='RequestId'),
  subCategories?: {
    category?: [ 
    {
      cateId?: long(name='CateId'),
      cateName?: string(name='CateName'),
      level?: long(name='Level'),
      parentId?: long(name='ParentId'),
      subTotal?: long(name='SubTotal'),
      type?: string(name='Type'),
    }
  ](name='Category')
  }(name='SubCategories'),
  subTotal?: long(name='SubTotal'),
}

model GetCategoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCategoriesResponseBody(name='body'),
}

async function getCategoriesWithOptions(request: GetCategoriesRequest, runtime: Util.RuntimeOptions): GetCategoriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCategories',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCategories(request: GetCategoriesRequest): GetCategoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCategoriesWithOptions(request, runtime);
}

model GetClientConfigRequest {
  bundleId?: string(name='BundleId', description='云端配置所对应的IOS BundleId'),
  pkgName?: string(name='PkgName', description='云端配置所对应的包名。'),
  pkgSignature?: string(name='PkgSignature', description='云端配置所对应的包签名'),
}

model GetClientConfigResponseBody = {
  clientUploadBucket?: string(name='ClientUploadBucket', description='oss bucket 名称'),
  clientUploadPath?: string(name='ClientUploadPath', description='路径'),
  clientUploadStorageStatus?: string(name='ClientUploadStorageStatus', description='状态'),
  clientUploadStorageType?: string(name='ClientUploadStorageType', description='存储类型'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetClientConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClientConfigResponseBody(name='body'),
}

async function getClientConfigWithOptions(request: GetClientConfigRequest, runtime: Util.RuntimeOptions): GetClientConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bundleId)) {
    query['BundleId'] = request.bundleId;
  }
  if (!Util.isUnset(request.pkgName)) {
    query['PkgName'] = request.pkgName;
  }
  if (!Util.isUnset(request.pkgSignature)) {
    query['PkgSignature'] = request.pkgSignature;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClientConfig',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getClientConfig(request: GetClientConfigRequest): GetClientConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClientConfigWithOptions(request, runtime);
}

model GetCustomTemplateRequest {
  subtype?: int32(name='Subtype'),
  templateId?: string(name='TemplateId', description='模板ID'),
  type?: int32(name='Type'),
}

model GetCustomTemplateResponseBody = {
  customTemplate?: {
    createTime?: string(name='CreateTime', description='模板创建时间'),
    isDefault?: boolean(name='IsDefault', description='是否默认模板'),
    modifiedTime?: string(name='ModifiedTime', description='模板修改时间'),
    status?: string(name='Status', description='模板状态'),
    subtype?: int32(name='Subtype', description='模板子类型ID'),
    subtypeName?: string(name='SubtypeName', description='模板子类型名称'),
    templateConfig?: string(name='TemplateConfig', description='模板参数'),
    templateId?: string(name='TemplateId', description='模板Id'),
    templateName?: string(name='TemplateName', description='模板名称'),
    type?: int32(name='Type', description='模板类型ID'),
    typeName?: string(name='TypeName', description='模板类型名称'),
  }(name='CustomTemplate', description='模板信息'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model GetCustomTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCustomTemplateResponseBody(name='body'),
}

async function getCustomTemplateWithOptions(request: GetCustomTemplateRequest, runtime: Util.RuntimeOptions): GetCustomTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.subtype)) {
    query['Subtype'] = request.subtype;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCustomTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCustomTemplate(request: GetCustomTemplateRequest): GetCustomTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCustomTemplateWithOptions(request, runtime);
}

model GetDefaultStorageLocationResponseBody = {
  bucket?: string(name='Bucket', description='oss bucket 名称'),
  path?: string(name='Path', description='路径'),
  requestId?: string(name='RequestId', description='Id of the request'),
  status?: string(name='Status', description='状态'),
  storageType?: string(name='StorageType', description='存储类型'),
}

model GetDefaultStorageLocationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDefaultStorageLocationResponseBody(name='body'),
}

async function getDefaultStorageLocationWithOptions(runtime: Util.RuntimeOptions): GetDefaultStorageLocationResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetDefaultStorageLocation',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDefaultStorageLocation(): GetDefaultStorageLocationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDefaultStorageLocationWithOptions(runtime);
}

model GetDynamicImageJobRequest {
  jobId?: string(name='JobId'),
}

model GetDynamicImageJobResponseBody = {
  dynamicImageJob?: {
    code?: string(name='Code'),
    createTime?: string(name='CreateTime'),
    finishTime?: string(name='FinishTime'),
    input?: {
      media?: string(name='Media'),
      ossFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='OssFile', description='输入类型为媒资ID时的OSS地址'),
      type?: string(name='Type'),
    }(name='Input'),
    jobId?: string(name='JobId'),
    message?: string(name='Message'),
    modifiedTime?: string(name='ModifiedTime'),
    name?: string(name='Name'),
    output?: {
      media?: string(name='Media'),
      ossFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='OssFile', description='输出类型为媒资ID时的OSS地址'),
      type?: string(name='Type'),
    }(name='Output'),
    outputUrl?: string(name='OutputUrl'),
    pipelineId?: string(name='PipelineId'),
    status?: string(name='Status'),
    submitTime?: string(name='SubmitTime'),
    templateConfig?: string(name='TemplateConfig'),
    templateId?: string(name='TemplateId'),
    triggerSource?: string(name='TriggerSource'),
    userData?: string(name='UserData'),
  }(name='DynamicImageJob', description='截图任务信息'),
  requestId?: string(name='RequestId'),
}

model GetDynamicImageJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDynamicImageJobResponseBody(name='body'),
}

async function getDynamicImageJobWithOptions(request: GetDynamicImageJobRequest, runtime: Util.RuntimeOptions): GetDynamicImageJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDynamicImageJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDynamicImageJob(request: GetDynamicImageJobRequest): GetDynamicImageJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDynamicImageJobWithOptions(request, runtime);
}

model GetEditingProjectRequest {
  projectId?: string(name='ProjectId', description='云剪辑工程ID'),
}

model GetEditingProjectResponseBody = {
  project?: {
    businessConfig?: string(name='BusinessConfig'),
    businessStatus?: string(name='BusinessStatus'),
    clipsParam?: string(name='ClipsParam', description='模板素材参数'),
    coverURL?: string(name='CoverURL', description='云剪辑工程封面'),
    createSource?: string(name='CreateSource', description='云剪辑工程创建来源'),
    createTime?: string(name='CreateTime', description='云剪辑工程创建时间'),
    description?: string(name='Description', description='云剪辑工程描述'),
    duration?: long(name='Duration', description='云剪辑工程总时长'),
    modifiedSource?: string(name='ModifiedSource', description='云剪辑工程修改来源'),
    modifiedTime?: string(name='ModifiedTime', description='云剪辑工程最新修改时间'),
    projectId?: string(name='ProjectId', description='云剪辑工程ID'),
    projectType?: string(name='ProjectType'),
    status?: string(name='Status', description='云剪辑工程状态'),
    templateId?: string(name='TemplateId', description='模板Id'),
    templateType?: string(name='TemplateType', description='云剪辑工程模板类型'),
    timeline?: string(name='Timeline', description='云剪辑工程时间线'),
    title?: string(name='Title', description='云剪辑工程标题'),
  }(name='Project'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEditingProjectResponseBody(name='body'),
}

async function getEditingProjectWithOptions(request: GetEditingProjectRequest, runtime: Util.RuntimeOptions): GetEditingProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEditingProject',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEditingProject(request: GetEditingProjectRequest): GetEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEditingProjectWithOptions(request, runtime);
}

model GetEditingProjectMaterialsRequest {
  projectId?: string(name='ProjectId', description='云剪辑工程ID'),
}

model GetEditingProjectMaterialsResponseBody = {
  liveMaterials?: [ 
    {
      appName?: string(name='AppName'),
      domainName?: string(name='DomainName'),
      liveUrl?: string(name='LiveUrl'),
      streamName?: string(name='StreamName'),
    }
  ](name='LiveMaterials'),
  mediaInfos?: [ 
    {
      fileInfoList?: [ 
        {
          fileBasicInfo?: {
            bitrate?: string(name='Bitrate', description='码率'),
            duration?: string(name='Duration', description='时长'),
            fileName?: string(name='FileName', description='文件名'),
            fileSize?: string(name='FileSize', description='文件大小（字节）'),
            fileStatus?: string(name='FileStatus', description='文件状态'),
            fileType?: string(name='FileType', description='文件类型'),
            fileUrl?: string(name='FileUrl', description='文件oss地址'),
            formatName?: string(name='FormatName', description='封装格式'),
            height?: string(name='Height', description='高'),
            region?: string(name='Region', description='文件存储区域'),
            width?: string(name='Width', description='宽'),
          }(name='FileBasicInfo', description='文件基础信息，包含时长，大小等'),
        }
      ](name='FileInfoList', description='FileInfos'),
      mediaBasicInfo?: {
        businessType?: string(name='BusinessType', description='媒资业务类型'),
        category?: string(name='Category', description='分类'),
        coverURL?: string(name='CoverURL', description='封面地址'),
        createTime?: string(name='CreateTime', description='媒资创建时间'),
        deletedTime?: string(name='DeletedTime', description='媒资删除时间'),
        description?: string(name='Description', description='内容描述'),
        inputURL?: string(name='InputURL', description='待注册的媒资在相应系统中的地址'),
        mediaId?: string(name='MediaId', description='MediaId'),
        mediaTags?: string(name='MediaTags', description='标签'),
        mediaType?: string(name='MediaType', description='媒资媒体类型'),
        modifiedTime?: string(name='ModifiedTime', description='媒资修改时间'),
        snapshots?: string(name='Snapshots', description='截图'),
        source?: string(name='Source', description='来源'),
        spriteImages?: string(name='SpriteImages', description='雪碧图'),
        status?: string(name='Status', description='资源状态'),
        title?: string(name='Title', description='标题'),
        transcodeStatus?: string(name='TranscodeStatus', description='转码状态'),
        userData?: string(name='UserData', description='用户数据'),
      }(name='MediaBasicInfo', description='BasicInfo'),
      mediaId?: string(name='MediaId', description='媒资ID'),
    }
  ](name='MediaInfos', description='符合要求的媒资集合'),
  projectId?: string(name='ProjectId'),
  projectMaterials?: [ string ](name='ProjectMaterials'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetEditingProjectMaterialsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEditingProjectMaterialsResponseBody(name='body'),
}

async function getEditingProjectMaterialsWithOptions(request: GetEditingProjectMaterialsRequest, runtime: Util.RuntimeOptions): GetEditingProjectMaterialsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEditingProjectMaterials',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEditingProjectMaterials(request: GetEditingProjectMaterialsRequest): GetEditingProjectMaterialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEditingProjectMaterialsWithOptions(request, runtime);
}

model GetEventCallbackResponseBody = {
  authKey?: string(name='AuthKey'),
  authSwitch?: string(name='AuthSwitch'),
  callbackQueueName?: string(name='CallbackQueueName'),
  callbackType?: string(name='CallbackType'),
  callbackURL?: string(name='CallbackURL'),
  eventTypeList?: string(name='EventTypeList'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetEventCallbackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEventCallbackResponseBody(name='body'),
}

async function getEventCallbackWithOptions(runtime: Util.RuntimeOptions): GetEventCallbackResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetEventCallback',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEventCallback(): GetEventCallbackResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEventCallbackWithOptions(runtime);
}

model GetLiveEditingIndexFileRequest {
  appName?: string(name='AppName'),
  domainName?: string(name='DomainName'),
  projectId?: string(name='ProjectId'),
  streamName?: string(name='StreamName'),
}

model GetLiveEditingIndexFileResponseBody = {
  indexFile?: string(name='IndexFile'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetLiveEditingIndexFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveEditingIndexFileResponseBody(name='body'),
}

async function getLiveEditingIndexFileWithOptions(request: GetLiveEditingIndexFileRequest, runtime: Util.RuntimeOptions): GetLiveEditingIndexFileResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLiveEditingIndexFile',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLiveEditingIndexFile(request: GetLiveEditingIndexFileRequest): GetLiveEditingIndexFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveEditingIndexFileWithOptions(request, runtime);
}

model GetLiveEditingJobRequest {
  jobId?: string(name='JobId', description='直播剪辑JobId'),
}

model GetLiveEditingJobResponseBody = {
  liveEditingJob?: {
    clips?: string(name='Clips', description='剪辑片段列表'),
    code?: string(name='Code', description='剪辑合成作业错误码  注：作业失败时关注该字段'),
    completeTime?: string(name='CompleteTime', description='直播剪辑作业完成时间，格式为utc时间。  格式为："2021-06-21T08:01:00Z"。'),
    creationTime?: string(name='CreationTime', description='直播剪辑作业创建时间，格式为utc时间。  格式为："2021-06-21T08:01:00Z"。'),
    jobId?: string(name='JobId', description='直播剪辑任务ID'),
    liveStreamConfig?: {
      appName?: string(name='AppName', description='播流所属应用名称'),
      domainName?: string(name='DomainName', description='播流所属域名'),
      streamName?: string(name='StreamName', description='播流所属流名'),
    }(name='LiveStreamConfig', description='直播剪辑配置'),
    mediaId?: string(name='MediaId', description='输出成品的资源Id'),
    mediaProduceConfig?: {
      mode?: string(name='Mode', description='剪辑模式，默认Accurate'),
    }(name='MediaProduceConfig', description='直播剪辑合成配置'),
    mediaURL?: string(name='MediaURL', description='输出成品的资源文件URL'),
    message?: string(name='Message', description='剪辑合成作业错误信息  注：作业失败时关注该字段'),
    modifiedTime?: string(name='ModifiedTime', description='直播剪辑作业修改时间，格式为utc时间。  格式为："2021-06-21T08:01:00Z"。'),
    outputMediaConfig?: {
      bitrate?: long(name='Bitrate', description='输出成品的码率，单位为Kbps。可以不填，默认值是多个素材的最高码率'),
      fileName?: string(name='FileName', description='当 OutputMediaTarget 的目标为 vod-media 时，指定 fileName(包含文件后缀，不含路径）作为输出文件名'),
      height?: int32(name='Height', description='输出成品的高。可以不填，默认值是多个素材的最大高'),
      mediaURL?: string(name='MediaURL', description='输出成片的文件地址'),
      storageLocation?: string(name='StorageLocation', description='当 OutputMediaTarget 的目标为 vod-media 时， 指定 storage location 来存储媒资到 VOD; storage location 是 VOD 中的文件存储位置， 不包含 http:// 的前缀， 如:  outin-xxxxxx.oss-cn-shanghai.aliyuncs.com'),
      vodTemplateGroupId?: string(name='VodTemplateGroupId', description='合成成片输出到vod，指定vod转码模板组。如不需要VOD转码，请填写 "VOD_NO_TRANSCODE".'),
      width?: int32(name='Width', description='输出成品的宽。可以不填，默认值是多个素材的最大宽'),
    }(name='OutputMediaConfig', description='输出成片的存储配置'),
    projectId?: string(name='ProjectId', description='直播剪辑工程ID'),
    status?: string(name='Status', description='直播剪辑作业状态，取值可能为如下值：  -Init （初始状态）  -Queuing（排队中）  -Processing（处理中）  -Success（成功）  -Failed（失败）'),
    userData?: string(name='UserData', description='用户数据'),
  }(name='LiveEditingJob', description='直播剪辑任务'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model GetLiveEditingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveEditingJobResponseBody(name='body'),
}

async function getLiveEditingJobWithOptions(request: GetLiveEditingJobRequest, runtime: Util.RuntimeOptions): GetLiveEditingJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLiveEditingJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLiveEditingJob(request: GetLiveEditingJobRequest): GetLiveEditingJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveEditingJobWithOptions(request, runtime);
}

model GetLiveTranscodeJobRequest {
  jobId?: string(name='JobId', description='模板Id'),
}

model GetLiveTranscodeJobResponseBody = {
  job?: {
    createTime?: string(name='CreateTime'),
    jobId?: string(name='JobId'),
    name?: string(name='Name'),
    outputStream?: {
      streamInfos?: [ 
        {
          outputUrl?: string(name='OutputUrl'),
          type?: string(name='Type'),
        }
      ](name='StreamInfos'),
    }(name='OutputStream'),
    startMode?: int32(name='StartMode'),
    status?: int32(name='Status'),
    streamInput?: {
      inputUrl?: string(name='InputUrl'),
      type?: string(name='Type'),
    }(name='StreamInput'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateType?: string(name='TemplateType'),
  }(name='Job'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model GetLiveTranscodeJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveTranscodeJobResponseBody(name='body'),
}

async function getLiveTranscodeJobWithOptions(request: GetLiveTranscodeJobRequest, runtime: Util.RuntimeOptions): GetLiveTranscodeJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLiveTranscodeJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLiveTranscodeJob(request: GetLiveTranscodeJobRequest): GetLiveTranscodeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveTranscodeJobWithOptions(request, runtime);
}

model GetLiveTranscodeTemplateRequest {
  templateId?: string(name='TemplateId'),
}

model GetLiveTranscodeTemplateResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
  templateContent?: {
    category?: string(name='Category'),
    createTime?: string(name='CreateTime'),
    name?: string(name='Name'),
    templateConfig?: {
      audioParams?: {
        bitrate?: string(name='Bitrate'),
        channels?: string(name='Channels'),
        codec?: string(name='Codec'),
        profile?: string(name='Profile'),
        samplerate?: string(name='Samplerate'),
      }(name='AudioParams'),
      videoParams?: {
        bitrate?: string(name='Bitrate'),
        codec?: string(name='Codec'),
        fps?: string(name='Fps'),
        gop?: string(name='Gop'),
        height?: string(name='Height'),
        profile?: string(name='Profile'),
        width?: string(name='Width'),
      }(name='VideoParams'),
    }(name='TemplateConfig'),
    templateId?: string(name='TemplateId'),
    type?: string(name='Type'),
  }(name='TemplateContent'),
}

model GetLiveTranscodeTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveTranscodeTemplateResponseBody(name='body'),
}

async function getLiveTranscodeTemplateWithOptions(request: GetLiveTranscodeTemplateRequest, runtime: Util.RuntimeOptions): GetLiveTranscodeTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLiveTranscodeTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLiveTranscodeTemplate(request: GetLiveTranscodeTemplateRequest): GetLiveTranscodeTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveTranscodeTemplateWithOptions(request, runtime);
}

model GetMediaAuditResultRequest {
  appId?: string(name='AppId'),
  mediaId?: string(name='MediaId'),
}

model GetMediaAuditResultResponseBody = {
  audioResult?: {
    label?: string(name='Label'),
    scene?: string(name='Scene'),
    score?: string(name='Score'),
    suggestion?: string(name='Suggestion'),
  }(name='AudioResult'),
  coverResult?: {
    label?: string(name='Label'),
    scene?: string(name='Scene'),
    score?: string(name='Score'),
    suggestion?: string(name='Suggestion'),
  }(name='CoverResult'),
  descResult?: {
    label?: string(name='Label'),
    scene?: string(name='Scene'),
    score?: string(name='Score'),
    suggestion?: string(name='Suggestion'),
  }(name='DescResult'),
  mediaAuditResult?: {
    abnormalModules?: string(name='AbnormalModules'),
    label?: string(name='Label'),
    suggestion?: string(name='Suggestion'),
  }(name='MediaAuditResult'),
  requestId?: string(name='RequestId', description='RequestId'),
  titleResult?: {
    label?: string(name='Label'),
    scene?: string(name='Scene'),
    score?: string(name='Score'),
    suggestion?: string(name='Suggestion'),
  }(name='TitleResult'),
  videoResult?: {
    label?: string(name='Label'),
    scene?: string(name='Scene'),
    score?: string(name='Score'),
    suggestion?: string(name='Suggestion'),
  }(name='VideoResult'),
}

model GetMediaAuditResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMediaAuditResultResponseBody(name='body'),
}

async function getMediaAuditResultWithOptions(request: GetMediaAuditResultRequest, runtime: Util.RuntimeOptions): GetMediaAuditResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMediaAuditResult',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMediaAuditResult(request: GetMediaAuditResultRequest): GetMediaAuditResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaAuditResultWithOptions(request, runtime);
}

model GetMediaAuditResultDetailRequest {
  appId?: string(name='AppId'),
  mediaId?: string(name='MediaId'),
}

model GetMediaAuditResultDetailResponseBody = {
  auditResultDetails?: [ 
    {
      adLabel?: string(name='AdLabel'),
      adScore?: string(name='AdScore'),
      liveLabel?: string(name='LiveLabel'),
      liveScore?: string(name='LiveScore'),
      logoLabel?: string(name='LogoLabel'),
      logoScore?: string(name='LogoScore'),
      pornLabel?: string(name='PornLabel'),
      pornScore?: string(name='PornScore'),
      terrorismLabel?: string(name='TerrorismLabel'),
      terrorismScore?: string(name='TerrorismScore'),
      timestamp?: string(name='Timestamp'),
      url?: string(name='Url'),
    }
  ](name='AuditResultDetails'),
  requestId?: string(name='RequestId', description='RequestId'),
  total?: string(name='Total'),
}

model GetMediaAuditResultDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMediaAuditResultDetailResponseBody(name='body'),
}

async function getMediaAuditResultDetailWithOptions(request: GetMediaAuditResultDetailRequest, runtime: Util.RuntimeOptions): GetMediaAuditResultDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMediaAuditResultDetail',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMediaAuditResultDetail(request: GetMediaAuditResultDetailRequest): GetMediaAuditResultDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaAuditResultDetailWithOptions(request, runtime);
}

model GetMediaInfoRequest {
  inputURL?: string(name='InputURL'),
  mediaId?: string(name='MediaId'),
  outputType?: string(name='OutputType'),
}

model GetMediaInfoResponseBody = {
  mediaInfo?: {
    fileInfoList?: [ 
      {
        audioStreamInfoList?: [ 
          {
            bitrate?: string(name='Bitrate', description='码率'),
            channelLayout?: string(name='ChannelLayout', description='声道输出样式'),
            channels?: string(name='Channels', description='声道数'),
            codecLongName?: string(name='CodecLongName', description='编码格式长述名'),
            codecName?: string(name='CodecName', description='编码格式简述名'),
            codecTag?: string(name='CodecTag', description='编码格式标记'),
            codecTagString?: string(name='CodecTagString', description='编码格式标记文本'),
            codecTimeBase?: string(name='CodecTimeBase', description='编码时基'),
            duration?: string(name='Duration', description='时长'),
            fps?: string(name='Fps', description='音频帧率'),
            index?: string(name='Index', description='音频流序号'),
            lang?: string(name='Lang', description='语言'),
            numFrames?: string(name='NumFrames', description='总帧数'),
            profile?: string(name='Profile', description='编码预置'),
            sampleFmt?: string(name='SampleFmt', description='采样格式'),
            sampleRate?: string(name='SampleRate', description='采样率'),
            startTime?: string(name='StartTime', description='起始时间'),
            timebase?: string(name='Timebase', description='时基'),
          }
        ](name='AudioStreamInfoList', description='音频流信息，一个媒资可能有多条音频流'),
        fileBasicInfo?: {
          bitrate?: string(name='Bitrate', description='码率'),
          createTime?: string(name='CreateTime'),
          duration?: string(name='Duration', description='时长'),
          fileName?: string(name='FileName', description='文件名'),
          fileSize?: string(name='FileSize', description='文件大小（字节）'),
          fileStatus?: string(name='FileStatus', description='文件状态'),
          fileType?: string(name='FileType', description='文件类型'),
          fileUrl?: string(name='FileUrl', description='文件oss地址'),
          formatName?: string(name='FormatName', description='封装格式'),
          height?: string(name='Height', description='高'),
          modifiedTime?: string(name='ModifiedTime'),
          region?: string(name='Region', description='文件存储区域'),
          width?: string(name='Width', description='宽'),
        }(name='FileBasicInfo', description='文件基础信息，包含时长，大小等'),
        subtitleStreamInfoList?: [ 
          {
            codecLongName?: string(name='CodecLongName', description='编码格式长述名'),
            codecName?: string(name='CodecName', description='编码格式简述名'),
            codecTag?: string(name='CodecTag', description='编码格式标记'),
            codecTagString?: string(name='CodecTagString', description='编码格式标记文本'),
            codecTimeBase?: string(name='CodecTimeBase', description='编码时基'),
            duration?: string(name='Duration', description='时长'),
            index?: string(name='Index', description='音频流序号'),
            lang?: string(name='Lang', description='语言'),
            startTime?: string(name='StartTime', description='起始时间'),
            timebase?: string(name='Timebase', description='时基'),
          }
        ](name='SubtitleStreamInfoList', description='字幕流信息，一个媒资可能有多条字幕流'),
        videoStreamInfoList?: [ 
          {
            avgFPS?: string(name='AvgFPS', description='平均帧率'),
            bitrate?: string(name='Bitrate', description='码率'),
            codecLongName?: string(name='CodecLongName', description='编码格式长述名'),
            codecName?: string(name='CodecName', description='编码格式简述名'),
            codecTag?: string(name='CodecTag', description='编码格式标记'),
            codecTagString?: string(name='CodecTagString', description='编码格式标记文本'),
            codecTimeBase?: string(name='CodecTimeBase', description='编码时基'),
            dar?: string(name='Dar', description='编码显示分辨率比'),
            duration?: string(name='Duration', description='时长'),
            fps?: string(name='Fps', description='视频帧率'),
            hasBFrames?: string(name='HasBFrames', description='是否有B帧'),
            height?: string(name='Height', description='高'),
            index?: string(name='Index', description='视频流序号'),
            lang?: string(name='Lang', description='语言'),
            level?: string(name='Level', description='编码等级'),
            nbFrames?: string(name='Nb_frames', description='总帧数'),
            numFrames?: string(name='NumFrames', description='总帧数'),
            pixFmt?: string(name='PixFmt', description='像素格式'),
            profile?: string(name='Profile', description='编码预置'),
            rotate?: string(name='Rotate', description='旋转'),
            sar?: string(name='Sar', description='编码信号分辨率比'),
            startTime?: string(name='StartTime', description='起始时间'),
            timebase?: string(name='Timebase', description='时基'),
            width?: string(name='Width', description='宽'),
          }
        ](name='VideoStreamInfoList', description='视频流信息，一个媒资可能有多条视频流'),
      }
    ](name='FileInfoList', description='FileInfos'),
    mediaBasicInfo?: {
      biz?: string(name='Biz'),
      businessType?: string(name='BusinessType', description='媒资业务类型'),
      cateId?: long(name='CateId'),
      cateName?: string(name='CateName'),
      category?: string(name='Category', description='分类'),
      coverURL?: string(name='CoverURL', description='封面地址'),
      createTime?: string(name='CreateTime', description='媒资创建时间'),
      deletedTime?: string(name='DeletedTime', description='媒资删除时间'),
      description?: string(name='Description', description='内容描述'),
      inputURL?: string(name='InputURL', description='待注册的媒资在相应系统中的地址'),
      mediaId?: string(name='MediaId', description='MediaId'),
      mediaTags?: string(name='MediaTags', description='标签'),
      mediaType?: string(name='MediaType', description='媒资媒体类型'),
      modifiedTime?: string(name='ModifiedTime', description='媒资修改时间'),
      source?: string(name='Source', description='来源'),
      spriteImages?: string(name='SpriteImages', description='雪碧图'),
      status?: string(name='Status', description='资源状态'),
      title?: string(name='Title', description='标题'),
      uploadSource?: string(name='UploadSource'),
      userData?: string(name='UserData', description='用户数据'),
    }(name='MediaBasicInfo', description='BasicInfo'),
    mediaId?: string(name='MediaId', description='媒资ID'),
  }(name='MediaInfo'),
  requestId?: string(name='RequestId', description='RequestId'),
}

model GetMediaInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMediaInfoResponseBody(name='body'),
}

async function getMediaInfoWithOptions(request: GetMediaInfoRequest, runtime: Util.RuntimeOptions): GetMediaInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.inputURL)) {
    query['InputURL'] = request.inputURL;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.outputType)) {
    query['OutputType'] = request.outputType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMediaInfo',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMediaInfo(request: GetMediaInfoRequest): GetMediaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaInfoWithOptions(request, runtime);
}

model GetMediaInfoJobRequest {
  jobId?: string(name='JobId', description='任务 id'),
}

model GetMediaInfoJobResponseBody = {
  mediaInfoJob?: {
    async?: boolean(name='Async', description='是否异步处理'),
    finishTime?: string(name='FinishTime', description='任务完成时间'),
    input?: {
      media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
      type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
    }(name='Input', description='任务输入'),
    jobId?: string(name='JobId', description='任务 id'),
    mediaInfoProperty?: {
      audioStreamInfoList?: [ 
        {
          bitrate?: string(name='Bitrate', description='码率'),
          channelLayout?: string(name='ChannelLayout', description='声道布局'),
          channels?: string(name='Channels', description='声道数'),
          codecLongName?: string(name='CodecLongName', description='编码格式名'),
          codecName?: string(name='CodecName', description='编码格式'),
          codecTag?: string(name='CodecTag', description='编码器标签'),
          codecTagString?: string(name='CodecTagString', description='编码器标签名'),
          codecTimeBase?: string(name='CodecTimeBase', description='编码器时间基'),
          duration?: string(name='Duration', description='时长'),
          index?: string(name='Index', description='流序号'),
          lang?: string(name='Lang', description='语言'),
          sampleFmt?: string(name='SampleFmt'),
          sampleRate?: string(name='SampleRate', description='采样率'),
          startTime?: string(name='StartTime', description='开始时间'),
          timebase?: string(name='Timebase', description='时间基'),
        }
      ](name='AudioStreamInfoList', description='音频流信息'),
      fileBasicInfo?: {
        bitrate?: string(name='Bitrate', description='视频码率'),
        duration?: string(name='Duration', description='视频时长'),
        fileName?: string(name='FileName', description='文件名'),
        fileSize?: string(name='FileSize', description='文件大小'),
        fileStatus?: string(name='FileStatus', description='文件状态'),
        fileType?: string(name='FileType', description='文件类型'),
        fileUrl?: string(name='FileUrl', description='文件url'),
        formatName?: string(name='FormatName', description='视频格式名称'),
        height?: string(name='Height', description='高'),
        mediaId?: string(name='MediaId', description='媒资ID'),
        region?: string(name='Region', description='文件所在区域'),
        width?: string(name='Width', description='宽'),
      }(name='FileBasicInfo', description='基础文件信息'),
      videoStreamInfoList?: [ 
        {
          avgFps?: string(name='Avg_fps'),
          bitRate?: string(name='Bit_rate'),
          codecLongName?: string(name='Codec_long_name', description='编码格式名'),
          codecName?: string(name='Codec_name', description='编码格式'),
          codecTag?: string(name='Codec_tag', description='编码格式标记'),
          codecTagString?: string(name='Codec_tag_string', description='编码格式标记文本'),
          codecTimeBase?: string(name='Codec_time_base'),
          dar?: string(name='Dar', description='图像显示宽高比'),
          duration?: string(name='Duration', description='时长'),
          fps?: string(name='Fps', description='帧率'),
          hasBFrames?: string(name='Has_b_frames'),
          height?: string(name='Height', description='高'),
          index?: string(name='Index', description='流序号'),
          lang?: string(name='Lang', description='语言'),
          level?: string(name='Level', description='编码等级'),
          numFrames?: string(name='NumFrames', description='总帧数'),
          pixFmt?: string(name='PixFmt', description='颜色存储格式'),
          profile?: string(name='Profile', description='编码器预设'),
          rotate?: string(name='Rotate', description='视频画面旋转角度'),
          sar?: string(name='Sar', description='采集点数宽高比'),
          startTime?: string(name='Start_time', description='起始时间'),
          timeBase?: string(name='Time_base'),
          width?: string(name='Width', description='宽'),
        }
      ](name='VideoStreamInfoList', description='视频流信息'),
    }(name='MediaInfoProperty', description='媒体信息详情'),
    name?: string(name='Name', description='任务名字'),
    requestId?: string(name='RequestId', description='请求 id'),
    scheduleConfig?: {
      pipelineId?: string(name='PipelineId', description='管道 id'),
      priority?: int32(name='Priority', description='任务优先级，取值范围：1~10'),
    }(name='ScheduleConfig', description='调度信息'),
    status?: string(name='Status', description='任务状态 - Init: 已提交, Success: 成功, Fail: 失败'),
    submitResultJson?: map[string]any(name='SubmitResultJson', description='任务提交信息'),
    submitTime?: string(name='SubmitTime', description='任务提交时间'),
    triggerSource?: string(name='TriggerSource', description='任务来源 - API, WorkFlow, Console'),
    userData?: string(name='UserData', description='用户数据'),
  }(name='MediaInfoJob', description='MediaInfoJobDTO'),
  requestId?: string(name='RequestId', description='请求 id'),
}

model GetMediaInfoJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMediaInfoJobResponseBody(name='body'),
}

async function getMediaInfoJobWithOptions(request: GetMediaInfoJobRequest, runtime: Util.RuntimeOptions): GetMediaInfoJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMediaInfoJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMediaInfoJob(request: GetMediaInfoJobRequest): GetMediaInfoJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaInfoJobWithOptions(request, runtime);
}

model GetMediaProducingJobRequest {
  jobId?: string(name='JobId'),
}

model GetMediaProducingJobResponseBody = {
  mediaProducingJob?: {
    clipsParam?: string(name='ClipsParam'),
    code?: string(name='Code'),
    completeTime?: string(name='CompleteTime'),
    createTime?: string(name='CreateTime'),
    duration?: float(name='Duration'),
    jobId?: string(name='JobId'),
    mediaId?: string(name='MediaId'),
    mediaURL?: string(name='MediaURL'),
    message?: string(name='Message'),
    modifiedTime?: string(name='ModifiedTime'),
    projectId?: string(name='ProjectId'),
    status?: string(name='Status'),
    templateId?: string(name='TemplateId'),
    timeline?: string(name='Timeline'),
    vodMediaId?: string(name='VodMediaId'),
  }(name='MediaProducingJob'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetMediaProducingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMediaProducingJobResponseBody(name='body'),
}

async function getMediaProducingJobWithOptions(request: GetMediaProducingJobRequest, runtime: Util.RuntimeOptions): GetMediaProducingJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMediaProducingJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMediaProducingJob(request: GetMediaProducingJobRequest): GetMediaProducingJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaProducingJobWithOptions(request, runtime);
}

model GetPipelineRequest {
  pipelineId?: string(name='PipelineId', description='管道ID'),
}

model GetPipelineResponseBody = {
  pipeline?: {
    createTime?: string(name='CreateTime', description='模板创建时间'),
    modifiedTime?: string(name='ModifiedTime', description='模板修改时间'),
    name?: string(name='Name', description='管道名称'),
    pipelineId?: string(name='PipelineId', description='管道Id'),
    priority?: int32(name='Priority', description='管道优先级'),
    speed?: string(name='Speed', description='管道类型'),
    status?: string(name='Status', description='管道状态'),
  }(name='Pipeline', description='管道信息'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model GetPipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPipelineResponseBody(name='body'),
}

async function getPipelineWithOptions(request: GetPipelineRequest, runtime: Util.RuntimeOptions): GetPipelineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPipeline',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPipeline(request: GetPipelineRequest): GetPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPipelineWithOptions(request, runtime);
}

model GetPlayInfoRequest {
  mediaId?: string(name='MediaId'),
}

model GetPlayInfoResponseBody = {
  mediaBase?: {
    coverURL?: string(name='CoverURL'),
    creationTime?: string(name='CreationTime'),
    mediaId?: string(name='MediaId'),
    mediaType?: string(name='MediaType'),
    status?: string(name='Status'),
    title?: string(name='Title'),
  }(name='MediaBase'),
  playInfoList?: [ 
    {
      bitDepth?: int32(name='BitDepth', description='颜色位深'),
      bitrate?: string(name='Bitrate'),
      creationTime?: string(name='CreationTime'),
      definition?: string(name='Definition'),
      duration?: string(name='Duration'),
      encrypt?: long(name='Encrypt'),
      encryptType?: string(name='EncryptType'),
      fileURL?: string(name='FileURL'),
      format?: string(name='Format'),
      fps?: string(name='Fps'),
      HDRType?: string(name='HDRType', description='视频流HDR类型'),
      height?: long(name='Height'),
      modificationTime?: string(name='ModificationTime'),
      narrowBandType?: string(name='NarrowBandType'),
      playURL?: string(name='PlayURL'),
      size?: long(name='Size'),
      status?: string(name='Status'),
      streamType?: string(name='StreamType'),
      transTemplateType?: string(name='TransTemplateType'),
      watermarkId?: string(name='WatermarkId'),
      width?: long(name='Width'),
    }
  ](name='PlayInfoList'),
  requestId?: string(name='RequestId', description='RequestId'),
}

model GetPlayInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPlayInfoResponseBody(name='body'),
}

async function getPlayInfoWithOptions(request: GetPlayInfoRequest, runtime: Util.RuntimeOptions): GetPlayInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPlayInfo',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPlayInfo(request: GetPlayInfoRequest): GetPlayInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPlayInfoWithOptions(request, runtime);
}

model GetPublicMediaInfoRequest {
  mediaId?: string(name='MediaId'),
}

model GetPublicMediaInfoResponseBody = {
  mediaInfo?: {
    dynamicMetaData?: {
      data?: string(name='Data', description='元数据json'),
      type?: string(name='Type', description='类型'),
    }(name='DynamicMetaData', description='公共媒资动态元数据'),
    fileInfoList?: [ 
      {
        audioStreamInfoList?: [ 
          {
            bitrate?: string(name='Bitrate', description='码率'),
            channelLayout?: string(name='ChannelLayout', description='声道输出样式'),
            channels?: string(name='Channels', description='声道数'),
            codecLongName?: string(name='CodecLongName', description='编码格式长述名'),
            codecName?: string(name='CodecName', description='编码格式简述名'),
            codecTag?: string(name='CodecTag', description='编码格式标记'),
            codecTagString?: string(name='CodecTagString', description='编码格式标记文本'),
            codecTimeBase?: string(name='CodecTimeBase', description='编码时基'),
            duration?: string(name='Duration', description='时长'),
            fps?: string(name='Fps', description='音频帧率'),
            index?: string(name='Index', description='音频流序号'),
            lang?: string(name='Lang', description='语言'),
            numFrames?: string(name='NumFrames', description='总帧数'),
            profile?: string(name='Profile', description='编码预置'),
            sampleFmt?: string(name='SampleFmt', description='采样格式'),
            sampleRate?: string(name='SampleRate', description='采样率'),
            startTime?: string(name='StartTime', description='起始时间'),
            timebase?: string(name='Timebase', description='时基'),
          }
        ](name='AudioStreamInfoList', description='音频流信息，一个媒资可能有多条音频流'),
        fileBasicInfo?: {
          bitrate?: string(name='Bitrate', description='码率'),
          duration?: string(name='Duration', description='时长'),
          fileName?: string(name='FileName', description='文件名'),
          fileSize?: string(name='FileSize', description='文件大小（字节）'),
          fileStatus?: string(name='FileStatus', description='文件状态'),
          fileType?: string(name='FileType', description='文件类型'),
          fileUrl?: string(name='FileUrl', description='文件oss地址'),
          formatName?: string(name='FormatName', description='封装格式'),
          height?: string(name='Height', description='高'),
          region?: string(name='Region', description='文件存储区域'),
          width?: string(name='Width', description='宽'),
        }(name='FileBasicInfo', description='文件基础信息，包含时长，大小等'),
        subtitleStreamInfoList?: [ 
          {
            codecLongName?: string(name='CodecLongName', description='编码格式长述名'),
            codecName?: string(name='CodecName', description='编码格式简述名'),
            codecTag?: string(name='CodecTag', description='编码格式标记'),
            codecTagString?: string(name='CodecTagString', description='编码格式标记文本'),
            codecTimeBase?: string(name='CodecTimeBase', description='编码时基'),
            duration?: string(name='Duration', description='时长'),
            index?: string(name='Index', description='音频流序号'),
            lang?: string(name='Lang', description='语言'),
            startTime?: string(name='StartTime', description='起始时间'),
            timebase?: string(name='Timebase', description='时基'),
          }
        ](name='SubtitleStreamInfoList', description='字幕流信息，一个媒资可能有多条字幕流'),
        videoStreamInfoList?: [ 
          {
            avgFPS?: string(name='AvgFPS', description='平均帧率'),
            bitrate?: string(name='Bitrate', description='码率'),
            codecLongName?: string(name='CodecLongName', description='编码格式长述名'),
            codecName?: string(name='CodecName', description='编码格式简述名'),
            codecTag?: string(name='CodecTag', description='编码格式标记'),
            codecTagString?: string(name='CodecTagString', description='编码格式标记文本'),
            codecTimeBase?: string(name='CodecTimeBase', description='编码时基'),
            dar?: string(name='Dar', description='编码显示分辨率比'),
            duration?: string(name='Duration', description='时长'),
            fps?: string(name='Fps', description='视频帧率'),
            hasBFrames?: string(name='HasBFrames', description='是否有B帧'),
            height?: string(name='Height', description='高'),
            index?: string(name='Index', description='视频流序号'),
            lang?: string(name='Lang', description='语言'),
            level?: string(name='Level', description='编码等级'),
            nbFrames?: string(name='Nb_frames', description='总帧数'),
            numFrames?: string(name='NumFrames', description='总帧数'),
            pixFmt?: string(name='PixFmt', description='像素格式'),
            profile?: string(name='Profile', description='编码预置'),
            rotate?: string(name='Rotate', description='旋转'),
            sar?: string(name='Sar', description='编码信号分辨率比'),
            startTime?: string(name='StartTime', description='起始时间'),
            timebase?: string(name='Timebase', description='时基'),
            width?: string(name='Width', description='宽'),
          }
        ](name='VideoStreamInfoList', description='视频流信息，一个媒资可能有多条视频流'),
      }
    ](name='FileInfoList', description='FileInfos'),
    mediaBasicInfo?: {
      businessType?: string(name='BusinessType', description='媒资业务类型'),
      category?: string(name='Category', description='分类'),
      coverURL?: string(name='CoverURL', description='封面地址'),
      createTime?: string(name='CreateTime', description='媒资创建时间'),
      deletedTime?: string(name='DeletedTime', description='媒资删除时间'),
      description?: string(name='Description', description='内容描述'),
      mediaId?: string(name='MediaId', description='MediaId'),
      mediaTags?: string(name='MediaTags', description='标签'),
      mediaType?: string(name='MediaType', description='媒资媒体类型'),
      modifiedTime?: string(name='ModifiedTime', description='媒资修改时间'),
      source?: string(name='Source', description='来源'),
      spriteImages?: string(name='SpriteImages', description='雪碧图'),
      status?: string(name='Status', description='资源状态'),
      title?: string(name='Title', description='标题'),
      userData?: string(name='UserData', description='用户数据'),
    }(name='MediaBasicInfo', description='BasicInfo'),
    mediaId?: string(name='MediaId', description='媒资ID'),
  }(name='MediaInfo'),
  requestId?: string(name='RequestId', description='RequestId'),
}

model GetPublicMediaInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPublicMediaInfoResponseBody(name='body'),
}

async function getPublicMediaInfoWithOptions(request: GetPublicMediaInfoRequest, runtime: Util.RuntimeOptions): GetPublicMediaInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPublicMediaInfo',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPublicMediaInfo(request: GetPublicMediaInfoRequest): GetPublicMediaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPublicMediaInfoWithOptions(request, runtime);
}

model GetSmartHandleJobRequest {
  jobId?: string(name='JobId', description='任务Id'),
}

model GetSmartHandleJobResponseBody = {
  jobId?: string(name='JobId', description='任务Id'),
  output?: string(name='Output', description='任务结果'),
  requestId?: string(name='RequestId', description='请求Id'),
  smartJobInfo?: {
    createTime?: string(name='CreateTime', description='创建时间'),
    description?: string(name='Description', description='任务描述'),
    inputConfig?: {
      inputFile?: string(name='InputFile', description='OSS地址 或 内容库素材ID'),
    }(name='InputConfig', description='输入参数'),
    jobType?: string(name='JobType', description='任务类型'),
    modifiedTime?: string(name='ModifiedTime', description='修改时间'),
    outputConfig?: {
      bucket?: string(name='Bucket', description='OSS Bucket'),
      object?: string(name='Object', description='OSS Object'),
    }(name='OutputConfig', description='输出配置'),
    title?: string(name='Title', description='任务标题'),
    userId?: string(name='UserId', description='userid'),
  }(name='SmartJobInfo', description='智能任务信息'),
  state?: string(name='State', description='任务状态'),
  userData?: string(name='UserData', description='用户自定义信息'),
}

model GetSmartHandleJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSmartHandleJobResponseBody(name='body'),
}

async function getSmartHandleJobWithOptions(request: GetSmartHandleJobRequest, runtime: Util.RuntimeOptions): GetSmartHandleJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSmartHandleJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSmartHandleJob(request: GetSmartHandleJobRequest): GetSmartHandleJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSmartHandleJobWithOptions(request, runtime);
}

model GetSnapshotJobRequest {
  jobId?: string(name='JobId'),
}

model GetSnapshotJobResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
  snapshotJob?: {
    async?: boolean(name='Async'),
    code?: string(name='Code'),
    count?: int32(name='Count'),
    createTime?: string(name='CreateTime'),
    finishTime?: string(name='FinishTime'),
    input?: {
      media?: string(name='Media'),
      ossFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='OssFile', description='输入类型为媒资ID时的OSS地址'),
      type?: string(name='Type'),
    }(name='Input'),
    jobId?: string(name='JobId'),
    message?: string(name='Message'),
    modifiedTime?: string(name='ModifiedTime'),
    name?: string(name='Name'),
    output?: {
      media?: string(name='Media'),
      ossFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='OssFile', description='输出类型为媒资ID时的OSS地址'),
      type?: string(name='Type'),
    }(name='Output'),
    pipelineId?: string(name='PipelineId'),
    status?: string(name='Status'),
    submitTime?: string(name='SubmitTime'),
    templateConfig?: string(name='TemplateConfig'),
    templateId?: string(name='TemplateId'),
    triggerSource?: string(name='TriggerSource'),
    type?: string(name='Type'),
    userData?: string(name='UserData'),
  }(name='SnapshotJob', description='截图任务信息'),
}

model GetSnapshotJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSnapshotJobResponseBody(name='body'),
}

async function getSnapshotJobWithOptions(request: GetSnapshotJobRequest, runtime: Util.RuntimeOptions): GetSnapshotJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSnapshotJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSnapshotJob(request: GetSnapshotJobRequest): GetSnapshotJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSnapshotJobWithOptions(request, runtime);
}

model GetSnapshotUrlsRequest {
  jobId?: string(name='JobId'),
  orderBy?: string(name='OrderBy', description='排列顺序。取值：Asc，Desc'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  timeout?: long(name='Timeout', description='鉴权超时时间'),
}

model GetSnapshotUrlsResponseBody = {
  requestId?: string(name='RequestId'),
  snapshotUrls?: [ string ](name='SnapshotUrls', description='截图URL'),
  total?: int32(name='Total', description='截图总数量'),
  webVTTUrl?: string(name='WebVTTUrl', description='WebVTT文件URL'),
}

model GetSnapshotUrlsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSnapshotUrlsResponseBody(name='body'),
}

async function getSnapshotUrlsWithOptions(request: GetSnapshotUrlsRequest, runtime: Util.RuntimeOptions): GetSnapshotUrlsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSnapshotUrls',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSnapshotUrls(request: GetSnapshotUrlsRequest): GetSnapshotUrlsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSnapshotUrlsWithOptions(request, runtime);
}

model GetSystemTemplateRequest {
  templateId?: string(name='TemplateId', description='模板ID'),
}

model GetSystemTemplateResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
  systemTemplate?: {
    status?: string(name='Status', description='模板状态'),
    subtype?: int32(name='Subtype', description='模板子类型ID'),
    subtypeName?: string(name='SubtypeName', description='模板子类型名称'),
    templateConfig?: string(name='TemplateConfig', description='模板参数'),
    templateId?: string(name='TemplateId', description='模板Id'),
    templateName?: string(name='TemplateName', description='模板名称'),
    type?: int32(name='Type', description='模板类型ID'),
    typeName?: string(name='TypeName', description='模板类型名称'),
  }(name='SystemTemplate', description='模板信息'),
}

model GetSystemTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSystemTemplateResponseBody(name='body'),
}

async function getSystemTemplateWithOptions(request: GetSystemTemplateRequest, runtime: Util.RuntimeOptions): GetSystemTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSystemTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSystemTemplate(request: GetSystemTemplateRequest): GetSystemTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSystemTemplateWithOptions(request, runtime);
}

model GetTemplateRequest {
  relatedMediaidFlag?: string(name='RelatedMediaidFlag', description='是否返回模板关联素材，1返回，默认0，不返回'),
  templateId?: string(name='TemplateId', description='模板Id'),
}

model GetTemplateResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  template?: {
    clipsParam?: string(name='ClipsParam', description='提交合成任务的ClipsParam参数'),
    config?: string(name='Config', description='模板配置'),
    coverURL?: string(name='CoverURL', description='封面URL'),
    createSource?: string(name='CreateSource', description='创建来源'),
    creationTime?: string(name='CreationTime', description='创建时间'),
    modifiedSource?: string(name='ModifiedSource', description='修改来源'),
    modifiedTime?: string(name='ModifiedTime', description='修改时间'),
    name?: string(name='Name', description='模板名称'),
    previewMedia?: string(name='PreviewMedia', description='预览素材'),
    previewMediaStatus?: string(name='PreviewMediaStatus', description='预览素材状态'),
    relatedMediaids?: string(name='RelatedMediaids', description='模板关联素材'),
    status?: string(name='Status', description='模板状态'),
    templateId?: string(name='TemplateId', description='模板ID'),
    type?: string(name='Type', description='模板类型'),
  }(name='Template'),
}

model GetTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTemplateResponseBody(name='body'),
}

async function getTemplateWithOptions(request: GetTemplateRequest, runtime: Util.RuntimeOptions): GetTemplateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTemplate(request: GetTemplateRequest): GetTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTemplateWithOptions(request, runtime);
}

model GetTemplateMaterialsRequest {
  fileList?: string(name='FileList', description='所需文件列表'),
  templateId?: string(name='TemplateId', description='模板Id'),
}

model GetTemplateMaterialsResponseBody = {
  materialUrls?: string(name='MaterialUrls', description='关联素材地址'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetTemplateMaterialsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTemplateMaterialsResponseBody(name='body'),
}

async function getTemplateMaterialsWithOptions(request: GetTemplateMaterialsRequest, runtime: Util.RuntimeOptions): GetTemplateMaterialsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTemplateMaterials',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTemplateMaterials(request: GetTemplateMaterialsRequest): GetTemplateMaterialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTemplateMaterialsWithOptions(request, runtime);
}

model GetTranscodeJobRequest {
  jobId?: string(name='JobId', description='任务 id'),
}

model GetTranscodeJobResponseBody = {
  requestId?: string(name='RequestId', description='请求 id'),
  transcodeParentJob?: {
    createTime?: string(name='CreateTime', description='任务创建时间'),
    finishTime?: string(name='FinishTime', description='任务结束时间'),
    inputGroup?: [ 
      {
        media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
        type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
      }
    ](name='InputGroup', description='任务输入组 (目前只支持单个输入)'),
    jobCount?: int32(name='JobCount', description='子任务数量'),
    name?: string(name='Name', description='任务名'),
    outputGroup?: [ 
      {
        output?: {
          media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
          type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
        }(name='Output', description='输出媒体配置'),
        processConfig?: {
          imageWatermarks?: [ 
            {
              overwriteParams?: {
                dx?: string(name='Dx', description='水印位置，x'),
                dy?: string(name='Dy', description='水印位置，y'),
                file?: {
                  media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
                  type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
                }(name='File', description='水印文件oss路径'),
                height?: string(name='Height', description='高'),
                referPos?: string(name='ReferPos', description='参考位置: TopLeft, TopRight, BottomLeft, BottomRight  default: TopLeft'),
                timeline?: {
                  duration?: string(name='Duration', description='显示时长，秒数 或者 "ToEND"'),
                  start?: string(name='Start', description='开始时间'),
                }(name='Timeline', description='显示时间设置'),
                width?: string(name='Width', description='宽'),
              }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
              templateId?: string(name='TemplateId', description='模板 id'),
            }
          ](name='ImageWatermarks', description='图片水印配置'),
          subtitles?: [ 
            {
              overwriteParams?: {
                charEnc?: string(name='CharEnc', description='文件 encoding 格式'),
                file?: {
                  media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
                  type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
                }(name='File', description='字幕文件'),
                format?: string(name='Format', description='字幕文件格式'),
              }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
              templateId?: string(name='TemplateId', description='模板 id'),
            }
          ](name='Subtitles', description='字幕压制配置'),
          textWatermarks?: [ 
            {
              overwriteParams?: {
                adaptive?: string(name='Adaptive', description='根据输出视频大小调整字体 size。 true / false, default: false'),
                borderColor?: string(name='BorderColor', description='边框颜色'),
                borderWidth?: int32(name='BorderWidth', description='边框宽度'),
                content?: string(name='Content', description='水印文本，不需要 base64 encode，字符串需要 utf-8 编码'),
                fontAlpha?: string(name='FontAlpha', description='透明度'),
                fontColor?: string(name='FontColor', description='颜色'),
                fontName?: string(name='FontName', description='字体'),
                fontSize?: int32(name='FontSize', description='字体大小'),
                left?: string(name='Left', description='水印位置，距离左边距离'),
                top?: string(name='Top', description='水印位置，距离上边距离'),
              }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
              templateId?: string(name='TemplateId', description='模板 id'),
            }
          ](name='TextWatermarks', description='文字水印配置'),
          transcode?: {
            overwriteParams?: {
              audio?: {
                bitrate?: string(name='Bitrate', description='输出文件的音频码率。'),
                channels?: string(name='Channels', description='声道数。'),
                codec?: string(name='Codec', description='音频编解码格式，AAC、MP3、VORBIS、FLAC。'),
                profile?: string(name='Profile', description='音频编码预置。'),
                remove?: string(name='Remove', description='是否删除音频流。'),
                samplerate?: string(name='Samplerate', description='采样率。'),
                volume?: {
                  integratedLoudnessTarget?: string(name='IntegratedLoudnessTarget', description='目标音量'),
                  loudnessRangeTarget?: string(name='LoudnessRangeTarget', description='音量范围'),
                  method?: string(name='Method', description='音量调整方式'),
                  truePeak?: string(name='TruePeak', description='最大峰值'),
                }(name='Volume', description='音量控制'),
              }(name='Audio', description='audio 设置'),
              container?: {
                format?: string(name='Format', description='容器格式'),
              }(name='Container', description='封装格式设置'),
              muxConfig?: {
                segment?: {
                  duration?: string(name='Duration', description='切片时长'),
                  forceSegTime?: string(name='ForceSegTime', description='强制切片时间点'),
                }(name='Segment', description='切片设置'),
              }(name='MuxConfig', description='封装设置'),
              video?: {
                abrMax?: string(name='AbrMax'),
                bitrate?: string(name='Bitrate', description='视频平均码率。'),
                bufsize?: string(name='Bufsize', description='缓冲区大小'),
                codec?: string(name='Codec', description='编码格式'),
                crf?: string(name='Crf', description='码率-质量控制因子。'),
                crop?: string(name='Crop', description='视频画面裁切'),
                fps?: string(name='Fps', description='帧率。'),
                gop?: string(name='Gop', description='关键帧间最大帧数。'),
                height?: string(name='Height', description='高。'),
                longShortMode?: string(name='LongShortMode', description='是否开启横竖屏自适应（即：长短边模式）'),
                maxrate?: string(name='Maxrate', description='视频码率峰值'),
                pad?: string(name='Pad', description='视频贴黑边'),
                pixFmt?: string(name='PixFmt', description='视频颜色格式。'),
                preset?: string(name='Preset', description='只有H264支持该参数'),
                profile?: string(name='Profile', description='编码级别。'),
                remove?: string(name='Remove', description='是否去掉视频'),
                scanMode?: string(name='ScanMode', description='扫描模式。'),
                width?: string(name='Width', description='宽。'),
              }(name='Video', description='video 设置'),
            }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
            templateId?: string(name='TemplateId', description='模板 id'),
          }(name='Transcode', description='转码配置'),
        }(name='ProcessConfig', description='任务处理配置'),
      }
    ](name='OutputGroup', description='任务输出组'),
    parentJobId?: string(name='ParentJobId', description='主任务 id'),
    percent?: int32(name='Percent', description='任务完成百分比'),
    requestId?: string(name='RequestId', description='提交任务时请求 id'),
    scheduleConfig?: {
      pipelineId?: string(name='PipelineId', description='管道 id'),
      priority?: int32(name='Priority', description='任务优先级，取值范围：1~10'),
    }(name='ScheduleConfig', description='任务调度配置'),
    status?: string(name='Status', description='任务状态 Success: 有子任务成功, Fail: 所有子任务失败'),
    submitTime?: string(name='SubmitTime', description='任务提交时间'),
    transcodeJobList?: [ 
      {
        createTime?: string(name='CreateTime', description='任务创建时间'),
        finishTime?: string(name='FinishTime', description='任务结束时间'),
        inputGroup?: [ 
          {
            media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
            type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
          }
        ](name='InputGroup', description='任务输入组 (目前只支持单个输入)'),
        jobId?: string(name='JobId', description='子任务 id'),
        jobIndex?: int32(name='JobIndex', description='子任务在整个任务中的索引号'),
        name?: string(name='Name', description='任务名'),
        outFileMeta?: {
          audioStreamInfoList?: [ 
            {
              bitrate?: string(name='Bitrate', description='码率'),
              channelLayout?: string(name='ChannelLayout', description='声道布局'),
              channels?: string(name='Channels', description='声道数'),
              codecLongName?: string(name='CodecLongName', description='编码格式名'),
              codecName?: string(name='CodecName', description='编码格式'),
              codecTag?: string(name='CodecTag', description='编码器标签'),
              codecTagString?: string(name='CodecTagString', description='编码器标签名'),
              codecTimeBase?: string(name='CodecTimeBase', description='编码器时间基'),
              duration?: string(name='Duration', description='时长'),
              index?: string(name='Index', description='流序号'),
              lang?: string(name='Lang', description='语言'),
              sampleFmt?: string(name='SampleFmt'),
              sampleRate?: string(name='SampleRate', description='采样率'),
              startTime?: string(name='StartTime', description='开始时间'),
              timebase?: string(name='Timebase', description='时间基'),
            }
          ](name='AudioStreamInfoList', description='音频流信息'),
          fileBasicInfo?: {
            bitrate?: string(name='Bitrate', description='视频码率'),
            duration?: string(name='Duration', description='视频时长'),
            fileName?: string(name='FileName', description='文件名'),
            fileSize?: string(name='FileSize', description='文件大小'),
            fileStatus?: string(name='FileStatus', description='文件状态'),
            fileType?: string(name='FileType', description='文件类型'),
            fileUrl?: string(name='FileUrl', description='文件url'),
            formatName?: string(name='FormatName', description='视频格式名称'),
            height?: string(name='Height', description='高'),
            mediaId?: string(name='MediaId', description='媒资ID'),
            region?: string(name='Region', description='文件所在区域'),
            width?: string(name='Width', description='宽'),
          }(name='FileBasicInfo', description='基础文件信息'),
          videoStreamInfoList?: [ 
            {
              avgFps?: string(name='Avg_fps'),
              bitRate?: string(name='Bit_rate'),
              codecLongName?: string(name='Codec_long_name', description='编码格式名'),
              codecName?: string(name='Codec_name', description='编码格式'),
              codecTag?: string(name='Codec_tag', description='编码格式标记'),
              codecTagString?: string(name='Codec_tag_string', description='编码格式标记文本'),
              codecTimeBase?: string(name='Codec_time_base'),
              dar?: string(name='Dar', description='图像显示宽高比'),
              duration?: string(name='Duration', description='时长'),
              fps?: string(name='Fps', description='帧率'),
              hasBFrames?: string(name='Has_b_frames'),
              height?: string(name='Height', description='高'),
              index?: string(name='Index', description='流序号'),
              lang?: string(name='Lang', description='语言'),
              level?: string(name='Level', description='编码等级'),
              numFrames?: string(name='NumFrames', description='总帧数'),
              pixFmt?: string(name='PixFmt', description='颜色存储格式'),
              profile?: string(name='Profile', description='编码器预设'),
              rotate?: string(name='Rotate', description='视频画面旋转角度'),
              sar?: string(name='Sar', description='采集点数宽高比'),
              startTime?: string(name='Start_time', description='起始时间'),
              timeBase?: string(name='Time_base'),
              width?: string(name='Width', description='宽'),
            }
          ](name='VideoStreamInfoList', description='视频流信息'),
        }(name='OutFileMeta', description='任务生成视频 media 信息'),
        output?: {
          media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
          type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
        }(name='Output', description='输出媒体配置'),
        parentJobId?: string(name='ParentJobId', description='主任务 id'),
        processConfig?: {
          imageWatermarks?: [ 
            {
              overwriteParams?: {
                dx?: string(name='Dx', description='水印位置，x'),
                dy?: string(name='Dy', description='水印位置，y'),
                file?: {
                  media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
                  type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
                }(name='File', description='水印文件oss路径'),
                height?: string(name='Height', description='高'),
                referPos?: string(name='ReferPos', description='参考位置: TopLeft, TopRight, BottomLeft, BottomRight  default: TopLeft'),
                timeline?: {
                  duration?: string(name='Duration', description='显示时长，秒数 或者 "ToEND"'),
                  start?: string(name='Start', description='开始时间'),
                }(name='Timeline', description='显示时间设置'),
                width?: string(name='Width', description='宽'),
              }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
              templateId?: string(name='TemplateId', description='模板 id'),
            }
          ](name='ImageWatermarks', description='图片水印配置'),
          subtitles?: [ 
            {
              overwriteParams?: {
                charEnc?: string(name='CharEnc', description='文件 encoding 格式'),
                file?: {
                  media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
                  type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
                }(name='File', description='字幕文件'),
                format?: string(name='Format', description='字幕文件格式'),
              }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
              templateId?: string(name='TemplateId', description='模板 id'),
            }
          ](name='Subtitles', description='字幕压制配置'),
          textWatermarks?: [ 
            {
              overwriteParams?: {
                adaptive?: string(name='Adaptive', description='根据输出视频大小调整字体 size。 true / false, default: false'),
                borderColor?: string(name='BorderColor', description='边框颜色'),
                borderWidth?: int32(name='BorderWidth', description='边框宽度'),
                content?: string(name='Content', description='水印文本，不需要 base64 encode，字符串需要 utf-8 编码'),
                fontAlpha?: string(name='FontAlpha', description='透明度'),
                fontColor?: string(name='FontColor', description='颜色'),
                fontName?: string(name='FontName', description='字体'),
                fontSize?: int32(name='FontSize', description='字体大小'),
                left?: string(name='Left', description='水印位置，距离左边距离'),
                top?: string(name='Top', description='水印位置，距离上边距离'),
              }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
              templateId?: string(name='TemplateId', description='模板 id'),
            }
          ](name='TextWatermarks', description='文字水印配置'),
          transcode?: {
            overwriteParams?: {
              audio?: {
                bitrate?: string(name='Bitrate', description='输出文件的音频码率。'),
                channels?: string(name='Channels', description='声道数。'),
                codec?: string(name='Codec', description='音频编解码格式，AAC、MP3、VORBIS、FLAC。'),
                profile?: string(name='Profile', description='音频编码预置。'),
                remove?: string(name='Remove', description='是否删除音频流。'),
                samplerate?: string(name='Samplerate', description='采样率。'),
                volume?: {
                  integratedLoudnessTarget?: string(name='IntegratedLoudnessTarget', description='目标音量'),
                  loudnessRangeTarget?: string(name='LoudnessRangeTarget', description='音量范围'),
                  method?: string(name='Method', description='音量调整方式'),
                  truePeak?: string(name='TruePeak', description='最大峰值'),
                }(name='Volume', description='音量控制'),
              }(name='Audio', description='audio 设置'),
              container?: {
                format?: string(name='Format', description='容器格式'),
              }(name='Container', description='封装格式设置'),
              muxConfig?: {
                segment?: {
                  duration?: string(name='Duration', description='切片时长'),
                  forceSegTime?: string(name='ForceSegTime', description='强制切片时间点'),
                }(name='Segment', description='切片设置'),
              }(name='MuxConfig', description='封装设置'),
              video?: {
                abrMax?: string(name='AbrMax'),
                bitrate?: string(name='Bitrate', description='视频平均码率。'),
                bufsize?: string(name='Bufsize', description='缓冲区大小'),
                codec?: string(name='Codec', description='编码格式'),
                crf?: string(name='Crf', description='码率-质量控制因子。'),
                crop?: string(name='Crop', description='视频画面裁切'),
                fps?: string(name='Fps', description='帧率。'),
                gop?: string(name='Gop', description='关键帧间最大帧数。'),
                height?: string(name='Height', description='高。'),
                longShortMode?: string(name='LongShortMode', description='是否开启横竖屏自适应（即：长短边模式）'),
                maxrate?: string(name='Maxrate', description='视频码率峰值'),
                pad?: string(name='Pad', description='视频贴黑边'),
                pixFmt?: string(name='PixFmt', description='视频颜色格式。'),
                preset?: string(name='Preset', description='只有H264支持该参数'),
                profile?: string(name='Profile', description='编码级别。'),
                remove?: string(name='Remove', description='是否去掉视频'),
                scanMode?: string(name='ScanMode', description='扫描模式。'),
                width?: string(name='Width', description='宽。'),
              }(name='Video', description='video 设置'),
            }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
            templateId?: string(name='TemplateId', description='模板 id'),
          }(name='Transcode', description='转码配置'),
        }(name='ProcessConfig', description='转码处理配置'),
        requestId?: string(name='RequestId', description='请求 id'),
        scheduleConfig?: {
          pipelineId?: string(name='PipelineId', description='管道 id'),
          priority?: int32(name='Priority', description='任务优先级，取值范围：1~10'),
        }(name='ScheduleConfig', description='任务调度信息'),
        status?: string(name='Status', description='转码任务任务状态 - Init: 已提交, Processing: 转码中, Success: 转码成功, Fail: 转码失败, Deleted: 已删除'),
        submitResultJson?: map[string]any(name='SubmitResultJson', description='任务提交结果'),
        submitTime?: string(name='SubmitTime', description='任务提交时间'),
        userData?: string(name='UserData', description='用户数据'),
      }
    ](name='TranscodeJobList', description='子任务列表'),
    triggerSource?: string(name='TriggerSource', description='任务来源 - API, WorkFlow, Console'),
    userData?: string(name='UserData', description='用户数据'),
  }(name='TranscodeParentJob', description='TranscodeParentJobWithSubJobDTO'),
}

model GetTranscodeJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTranscodeJobResponseBody(name='body'),
}

async function getTranscodeJobWithOptions(request: GetTranscodeJobRequest, runtime: Util.RuntimeOptions): GetTranscodeJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTranscodeJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTranscodeJob(request: GetTranscodeJobRequest): GetTranscodeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTranscodeJobWithOptions(request, runtime);
}

model GetUrlUploadInfosRequest {
  jobIds?: string(name='JobIds'),
  uploadURLs?: string(name='UploadURLs'),
}

model GetUrlUploadInfosResponseBody = {
  nonExists?: [ string ](name='NonExists'),
  requestId?: string(name='RequestId'),
  URLUploadInfoList?: [ 
    {
      completeTime?: string(name='CompleteTime'),
      creationTime?: string(name='CreationTime'),
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      fileSize?: string(name='FileSize'),
      jobId?: string(name='JobId'),
      mediaId?: string(name='MediaId'),
      status?: string(name='Status'),
      uploadURL?: string(name='UploadURL'),
      userData?: string(name='UserData'),
    }
  ](name='URLUploadInfoList'),
}

model GetUrlUploadInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUrlUploadInfosResponseBody(name='body'),
}

async function getUrlUploadInfosWithOptions(request: GetUrlUploadInfosRequest, runtime: Util.RuntimeOptions): GetUrlUploadInfosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobIds)) {
    query['JobIds'] = request.jobIds;
  }
  if (!Util.isUnset(request.uploadURLs)) {
    query['UploadURLs'] = request.uploadURLs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUrlUploadInfos',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUrlUploadInfos(request: GetUrlUploadInfosRequest): GetUrlUploadInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUrlUploadInfosWithOptions(request, runtime);
}

model ListAllPublicMediaTagsRequest {
  businessType?: string(name='BusinessType', description='媒资业务类型'),
  entityId?: string(name='EntityId'),
}

model ListAllPublicMediaTagsResponseBody = {
  mediaTagList?: [ 
    {
      mediaTagId?: string(name='MediaTagId', description='素材标签id'),
      mediaTagNameChinese?: string(name='MediaTagNameChinese', description='素材标签中文名'),
      mediaTagNameEnglish?: string(name='MediaTagNameEnglish', description='素材标签英文名'),
      options?: [ 
        {
          optionChineseName?: string(name='OptionChineseName'),
          optionEnglishName?: string(name='OptionEnglishName'),
          optionId?: string(name='OptionId'),
        }
      ](name='Options'),
    }
  ](name='MediaTagList', description='公共素材库标签列表'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListAllPublicMediaTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAllPublicMediaTagsResponseBody(name='body'),
}

async function listAllPublicMediaTagsWithOptions(request: ListAllPublicMediaTagsRequest, runtime: Util.RuntimeOptions): ListAllPublicMediaTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessType)) {
    query['BusinessType'] = request.businessType;
  }
  if (!Util.isUnset(request.entityId)) {
    query['EntityId'] = request.entityId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAllPublicMediaTags',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAllPublicMediaTags(request: ListAllPublicMediaTagsRequest): ListAllPublicMediaTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAllPublicMediaTagsWithOptions(request, runtime);
}

model ListCustomTemplatesRequest {
  name?: string(name='Name', description='模板名称'),
  orderBy?: string(name='OrderBy', description='排序顺序：CreateTimeDesc 和 CreateTimeAsc'),
  pageNumber?: int32(name='PageNumber', description='分页数目'),
  pageSize?: int32(name='PageSize', description='分页大小'),
  subtype?: string(name='Subtype', description='模板子类型ID'),
  templateId?: string(name='TemplateId', description='模板ID'),
  type?: string(name='Type', description='模板类型。逗号分隔'),
}

model ListCustomTemplatesResponseBody = {
  customTemplateList?: [ 
    {
      createTime?: string(name='CreateTime', description='模板创建时间'),
      isDefault?: boolean(name='IsDefault', description='是否默认模板'),
      modifiedTime?: string(name='ModifiedTime', description='模板修改时间'),
      status?: string(name='Status', description='模板状态'),
      subtype?: int32(name='Subtype', description='模板子类型ID'),
      subtypeName?: string(name='SubtypeName', description='模板子类型名称'),
      templateConfig?: string(name='TemplateConfig', description='模板参数'),
      templateId?: string(name='TemplateId', description='模板Id'),
      templateName?: string(name='TemplateName', description='模板名称'),
      type?: int32(name='Type', description='模板类型ID'),
      typeName?: string(name='TypeName', description='模板类型名称'),
    }
  ](name='CustomTemplateList', description='模板信息列表'),
  requestId?: string(name='RequestId', description='请求ID'),
  total?: int32(name='Total', description='模板总数'),
}

model ListCustomTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCustomTemplatesResponseBody(name='body'),
}

async function listCustomTemplatesWithOptions(request: ListCustomTemplatesRequest, runtime: Util.RuntimeOptions): ListCustomTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.subtype)) {
    query['Subtype'] = request.subtype;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCustomTemplates',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCustomTemplates(request: ListCustomTemplatesRequest): ListCustomTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCustomTemplatesWithOptions(request, runtime);
}

model ListDynamicImageJobsRequest {
  endOfCreateTime?: string(name='EndOfCreateTime'),
  jobId?: string(name='JobId', description='任务ID'),
  nextPageToken?: string(name='NextPageToken', description='连续分页查询时下一页的标记'),
  orderBy?: string(name='OrderBy', description='排序顺序：CreateTimeDesc 和 CreateTimeAsc'),
  pageSize?: int32(name='PageSize'),
  startOfCreateTime?: string(name='StartOfCreateTime'),
  status?: string(name='Status'),
}

model ListDynamicImageJobsResponseBody = {
  jobs?: [ 
    {
      createTime?: string(name='CreateTime'),
      finishTime?: string(name='FinishTime'),
      input?: {
        media?: string(name='Media'),
        type?: string(name='Type'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      modifiedTime?: string(name='ModifiedTime'),
      name?: string(name='Name'),
      output?: {
        media?: string(name='Media'),
        type?: string(name='Type'),
      }(name='Output'),
      pipelineId?: string(name='PipelineId'),
      status?: string(name='Status'),
      submitTime?: string(name='SubmitTime'),
      templateId?: string(name='TemplateId'),
      triggerSource?: string(name='TriggerSource'),
    }
  ](name='Jobs'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListDynamicImageJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDynamicImageJobsResponseBody(name='body'),
}

async function listDynamicImageJobsWithOptions(request: ListDynamicImageJobsRequest, runtime: Util.RuntimeOptions): ListDynamicImageJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endOfCreateTime)) {
    query['EndOfCreateTime'] = request.endOfCreateTime;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startOfCreateTime)) {
    query['StartOfCreateTime'] = request.startOfCreateTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDynamicImageJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDynamicImageJobs(request: ListDynamicImageJobsRequest): ListDynamicImageJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDynamicImageJobsWithOptions(request, runtime);
}

model ListLiveRecordTemplatesRequest {
  keyword?: string(name='Keyword'),
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  sortBy?: string(name='SortBy'),
  templateIds?: [ string ](name='TemplateIds'),
  type?: string(name='Type'),
}

model ListLiveRecordTemplatesResponseBody = {
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  recordTemplateList?: [ 
    {
      createTime?: string(name='CreateTime', description='创建时间'),
      lastModified?: string(name='LastModified', description='最后修改时间'),
      name?: bytes(name='Name', description='资源名称'),
      recordFormatList?: [ 
        {
          cycleDuration?: bytes(name='CycleDuration', description='录制周期时长'),
          format?: bytes(name='Format', description='格式'),
          ossObjectPrefix?: bytes(name='OssObjectPrefix', description='Oss对象名'),
          sliceDuration?: int32(name='SliceDuration', description='切片时长'),
          sliceOssObjectPrefix?: bytes(name='SliceOssObjectPrefix', description='切片Oss对象名'),
        }
      ](name='RecordFormatList', description='录制格式'),
      templateId?: bytes(name='TemplateId', description='资源一级ID'),
      type?: bytes(name='Type', description='资源名称'),
    }
  ](name='RecordTemplateList', description='数组，返回示例目录。'),
  requestId?: string(name='RequestId', description='Id of the request'),
  sortBy?: string(name='SortBy'),
  totalCount?: long(name='TotalCount', description='总记录数。'),
}

model ListLiveRecordTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLiveRecordTemplatesResponseBody(name='body'),
}

async function listLiveRecordTemplatesWithOptions(request: ListLiveRecordTemplatesRequest, runtime: Util.RuntimeOptions): ListLiveRecordTemplatesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLiveRecordTemplates',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLiveRecordTemplates(request: ListLiveRecordTemplatesRequest): ListLiveRecordTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLiveRecordTemplatesWithOptions(request, runtime);
}

model ListLiveTranscodeJobsRequest {
  keyWord?: string(name='KeyWord'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  sortBy?: string(name='SortBy'),
  startMode?: int32(name='StartMode'),
  status?: int32(name='Status'),
  type?: string(name='Type', description='模板Id'),
}

model ListLiveTranscodeJobsResponseBody = {
  jobList?: [ 
    {
      createTime?: string(name='CreateTime'),
      jobId?: string(name='JobId'),
      name?: string(name='Name'),
      outputStream?: {
        streamInfos?: [ 
          {
            outputUrl?: string(name='OutputUrl'),
            type?: string(name='Type'),
          }
        ](name='StreamInfos'),
      }(name='OutputStream'),
      startMode?: int32(name='StartMode'),
      status?: int32(name='Status'),
      streamInput?: {
        inputUrl?: string(name='InputUrl'),
        type?: string(name='Type'),
      }(name='StreamInput'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateType?: string(name='TemplateType'),
    }
  ](name='JobList'),
  requestId?: string(name='RequestId', description='请求ID'),
  totalCount?: int32(name='TotalCount'),
}

model ListLiveTranscodeJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLiveTranscodeJobsResponseBody(name='body'),
}

async function listLiveTranscodeJobsWithOptions(request: ListLiveTranscodeJobsRequest, runtime: Util.RuntimeOptions): ListLiveTranscodeJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.startMode)) {
    query['StartMode'] = request.startMode;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLiveTranscodeJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLiveTranscodeJobs(request: ListLiveTranscodeJobsRequest): ListLiveTranscodeJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLiveTranscodeJobsWithOptions(request, runtime);
}

model ListLiveTranscodeTemplatesRequest {
  category?: string(name='Category'),
  keyWord?: string(name='KeyWord'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  sortBy?: string(name='SortBy'),
  type?: string(name='Type', description='模板Id'),
  videoCodec?: string(name='VideoCodec'),
}

model ListLiveTranscodeTemplatesResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
  templateContentList?: [ 
    {
      category?: string(name='Category'),
      createTime?: string(name='CreateTime'),
      name?: string(name='Name'),
      templateConfig?: {
        audioParams?: {
          bitrate?: string(name='Bitrate'),
          channels?: string(name='Channels'),
          codec?: string(name='Codec'),
          profile?: string(name='Profile'),
          samplerate?: string(name='Samplerate'),
        }(name='AudioParams'),
        videoParams?: {
          bitrate?: string(name='Bitrate'),
          codec?: string(name='Codec'),
          fps?: string(name='Fps'),
          gop?: string(name='Gop'),
          height?: string(name='Height'),
          profile?: string(name='Profile'),
          width?: string(name='Width'),
        }(name='VideoParams'),
      }(name='TemplateConfig'),
      templateId?: string(name='TemplateId'),
      type?: string(name='Type'),
    }
  ](name='TemplateContentList'),
  totalCount?: int32(name='TotalCount'),
}

model ListLiveTranscodeTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLiveTranscodeTemplatesResponseBody(name='body'),
}

async function listLiveTranscodeTemplatesWithOptions(request: ListLiveTranscodeTemplatesRequest, runtime: Util.RuntimeOptions): ListLiveTranscodeTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.videoCodec)) {
    query['VideoCodec'] = request.videoCodec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLiveTranscodeTemplates',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLiveTranscodeTemplates(request: ListLiveTranscodeTemplatesRequest): ListLiveTranscodeTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLiveTranscodeTemplatesWithOptions(request, runtime);
}

model ListMediaBasicInfosRequest {
  businessType?: string(name='BusinessType', description='媒资业务类型'),
  endTime?: string(name='EndTime', description='结束时间'),
  includeFileBasicInfo?: boolean(name='IncludeFileBasicInfo', description='返回值中是否包含文件基础信息'),
  maxResults?: int32(name='MaxResults', description='分页大小'),
  mediaId?: string(name='MediaId', description='媒资ID，单个媒资ID支持前缀匹配'),
  mediaType?: string(name='MediaType', description='媒资媒体类型'),
  nextToken?: string(name='NextToken', description='页号'),
  sortBy?: string(name='SortBy', description='排序'),
  source?: string(name='Source', description='来源'),
  startTime?: string(name='StartTime', description='创建时间'),
  status?: string(name='Status', description='资源状态'),
}

model ListMediaBasicInfosResponseBody = {
  maxResults?: int32(name='MaxResults'),
  mediaInfos?: [ 
    {
      fileInfoList?: [ 
        {
          fileBasicInfo?: {
            bitrate?: string(name='Bitrate', description='码率'),
            createTime?: string(name='CreateTime'),
            duration?: string(name='Duration', description='时长'),
            fileName?: string(name='FileName', description='文件名'),
            fileSize?: string(name='FileSize', description='文件大小（字节）'),
            fileStatus?: string(name='FileStatus', description='文件状态'),
            fileType?: string(name='FileType'),
            fileUrl?: string(name='FileUrl', description='文件oss地址'),
            formatName?: string(name='FormatName', description='封装格式'),
            height?: string(name='Height', description='高'),
            modifiedTime?: string(name='ModifiedTime'),
            region?: string(name='Region', description='文件存储区域'),
            width?: string(name='Width', description='宽'),
          }(name='FileBasicInfo', description='文件基础信息，包含时长，大小等'),
        }
      ](name='FileInfoList', description='FileInfos'),
      mediaBasicInfo?: {
        biz?: string(name='Biz'),
        businessType?: string(name='BusinessType', description='媒资业务类型'),
        cateId?: long(name='CateId'),
        category?: string(name='Category', description='分类'),
        coverURL?: string(name='CoverURL', description='封面地址'),
        createTime?: string(name='CreateTime', description='媒资创建时间'),
        deletedTime?: string(name='DeletedTime', description='媒资删除时间'),
        description?: string(name='Description', description='内容描述'),
        inputURL?: string(name='InputURL', description='待注册的媒资在相应系统中的地址'),
        mediaId?: string(name='MediaId', description='MediaId'),
        mediaTags?: string(name='MediaTags', description='标签'),
        mediaType?: string(name='MediaType', description='媒资媒体类型'),
        modifiedTime?: string(name='ModifiedTime', description='媒资修改时间'),
        snapshots?: string(name='Snapshots', description='截图'),
        source?: string(name='Source', description='来源'),
        spriteImages?: string(name='SpriteImages', description='雪碧图'),
        status?: string(name='Status', description='资源状态'),
        title?: string(name='Title', description='标题'),
        transcodeStatus?: string(name='TranscodeStatus', description='转码状态'),
        uploadSource?: string(name='UploadSource'),
        userData?: string(name='UserData', description='用户数据'),
      }(name='MediaBasicInfo', description='BasicInfo'),
      mediaId?: string(name='MediaId', description='媒资ID'),
    }
  ](name='MediaInfos', description='符合要求的媒资集合'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount', description='符合要求的媒资总数'),
}

model ListMediaBasicInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMediaBasicInfosResponseBody(name='body'),
}

async function listMediaBasicInfosWithOptions(request: ListMediaBasicInfosRequest, runtime: Util.RuntimeOptions): ListMediaBasicInfosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessType)) {
    query['BusinessType'] = request.businessType;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.includeFileBasicInfo)) {
    query['IncludeFileBasicInfo'] = request.includeFileBasicInfo;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.mediaType)) {
    query['MediaType'] = request.mediaType;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMediaBasicInfos',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMediaBasicInfos(request: ListMediaBasicInfosRequest): ListMediaBasicInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMediaBasicInfosWithOptions(request, runtime);
}

model ListMediaInfoJobsRequest {
  endOfCreateTime?: string(name='EndOfCreateTime', description='任务创建时间筛选条件的结束时间'),
  jobId?: string(name='JobId', description='按 jobId 筛选'),
  nextPageToken?: string(name='NextPageToken', description='连续分页查询时下一页的标记 (第一页没有)'),
  orderBy?: string(name='OrderBy', description='排序顺序，目前只支持两种：CreateTimeDesc 和 CreateTimeAsc'),
  pageSize?: int32(name='PageSize'),
  startOfCreateTime?: string(name='StartOfCreateTime', description='任务创建时间筛选条件的起始时间'),
  status?: string(name='Status', description='任务状态'),
}

model ListMediaInfoJobsResponseBody = {
  jobs?: [ 
    {
      async?: boolean(name='Async', description='是否异步处理'),
      finishTime?: string(name='FinishTime', description='任务完成时间'),
      input?: {
        media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
        type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
      }(name='Input', description='任务输入'),
      jobId?: string(name='JobId', description='任务 id'),
      mediaInfoProperty?: {
        audioStreamInfoList?: [ 
          {
            bitrate?: string(name='Bitrate', description='码率'),
            channelLayout?: string(name='ChannelLayout', description='声道布局'),
            channels?: string(name='Channels', description='声道数'),
            codecLongName?: string(name='CodecLongName', description='编码格式名'),
            codecName?: string(name='CodecName', description='编码格式'),
            codecTag?: string(name='CodecTag', description='编码器标签'),
            codecTagString?: string(name='CodecTagString', description='编码器标签名'),
            codecTimeBase?: string(name='CodecTimeBase', description='编码器时间基'),
            duration?: string(name='Duration', description='时长'),
            index?: string(name='Index', description='流序号'),
            lang?: string(name='Lang', description='语言'),
            sampleFmt?: string(name='SampleFmt'),
            sampleRate?: string(name='SampleRate', description='采样率'),
            startTime?: string(name='StartTime', description='开始时间'),
            timebase?: string(name='Timebase', description='时间基'),
          }
        ](name='AudioStreamInfoList', description='音频流信息'),
        fileBasicInfo?: {
          bitrate?: string(name='Bitrate', description='视频码率'),
          duration?: string(name='Duration', description='视频时长'),
          fileName?: string(name='FileName', description='文件名'),
          fileSize?: string(name='FileSize', description='文件大小'),
          fileStatus?: string(name='FileStatus', description='文件状态'),
          fileType?: string(name='FileType', description='文件类型'),
          fileUrl?: string(name='FileUrl', description='文件url'),
          formatName?: string(name='FormatName', description='视频格式名称'),
          height?: string(name='Height', description='高'),
          mediaId?: string(name='MediaId', description='媒资ID'),
          region?: string(name='Region', description='文件所在区域'),
          width?: string(name='Width', description='宽'),
        }(name='FileBasicInfo', description='基础文件信息'),
        videoStreamInfoList?: [ 
          {
            avgFps?: string(name='Avg_fps'),
            bitRate?: string(name='Bit_rate'),
            codecLongName?: string(name='Codec_long_name', description='编码格式名'),
            codecName?: string(name='Codec_name', description='编码格式'),
            codecTag?: string(name='Codec_tag', description='编码格式标记'),
            codecTagString?: string(name='Codec_tag_string', description='编码格式标记文本'),
            codecTimeBase?: string(name='Codec_time_base'),
            dar?: string(name='Dar', description='图像显示宽高比'),
            duration?: string(name='Duration', description='时长'),
            fps?: string(name='Fps', description='帧率'),
            hasBFrames?: string(name='Has_b_frames'),
            height?: string(name='Height', description='高'),
            index?: string(name='Index', description='流序号'),
            lang?: string(name='Lang', description='语言'),
            level?: string(name='Level', description='编码等级'),
            numFrames?: string(name='NumFrames', description='总帧数'),
            pixFmt?: string(name='PixFmt', description='颜色存储格式'),
            profile?: string(name='Profile', description='编码器预设'),
            rotate?: string(name='Rotate', description='视频画面旋转角度'),
            sar?: string(name='Sar', description='采集点数宽高比'),
            startTime?: string(name='Start_time', description='起始时间'),
            timeBase?: string(name='Time_base'),
            width?: string(name='Width', description='宽'),
          }
        ](name='VideoStreamInfoList', description='视频流信息'),
      }(name='MediaInfoProperty', description='媒体信息详情'),
      name?: string(name='Name', description='任务名字'),
      requestId?: string(name='RequestId', description='请求 id'),
      scheduleConfig?: {
        pipelineId?: string(name='PipelineId', description='管道 id'),
        priority?: int32(name='Priority', description='任务优先级，取值范围：1~10'),
      }(name='ScheduleConfig', description='调度信息'),
      status?: string(name='Status', description='任务状态 - Init: 已提交, Success: 成功, Fail: 失败'),
      submitResultJson?: map[string]any(name='SubmitResultJson', description='任务提交信息'),
      submitTime?: string(name='SubmitTime', description='任务提交时间'),
      triggerSource?: string(name='TriggerSource', description='任务来源 - API, WorkFlow, Console'),
      userData?: string(name='UserData', description='用户数据'),
    }
  ](name='Jobs'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId', description='请求 id'),
}

model ListMediaInfoJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMediaInfoJobsResponseBody(name='body'),
}

async function listMediaInfoJobsWithOptions(request: ListMediaInfoJobsRequest, runtime: Util.RuntimeOptions): ListMediaInfoJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endOfCreateTime)) {
    query['EndOfCreateTime'] = request.endOfCreateTime;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startOfCreateTime)) {
    query['StartOfCreateTime'] = request.startOfCreateTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMediaInfoJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMediaInfoJobs(request: ListMediaInfoJobsRequest): ListMediaInfoJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMediaInfoJobsWithOptions(request, runtime);
}

model ListPipelinesRequest {
  speed?: string(name='Speed', description='管道类型。'),
}

model ListPipelinesResponseBody = {
  pipelineList?: [ 
    {
      createTime?: string(name='CreateTime', description='模板创建时间'),
      modifiedTime?: string(name='ModifiedTime', description='模板修改时间'),
      name?: string(name='Name', description='管道名称'),
      pipelineId?: string(name='PipelineId', description='管道Id'),
      priority?: int32(name='Priority', description='管道优先级'),
      speed?: string(name='Speed', description='管道类型'),
      status?: string(name='Status', description='管道状态'),
    }
  ](name='PipelineList'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model ListPipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPipelinesResponseBody(name='body'),
}

async function listPipelinesWithOptions(request: ListPipelinesRequest, runtime: Util.RuntimeOptions): ListPipelinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.speed)) {
    query['Speed'] = request.speed;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPipelines',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPipelines(request: ListPipelinesRequest): ListPipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPipelinesWithOptions(request, runtime);
}

model ListPublicMediaBasicInfosRequest {
  includeFileBasicInfo?: boolean(name='IncludeFileBasicInfo', description='返回值中是否包含文件基础信息'),
  maxResults?: int32(name='MaxResults', description='分页大小'),
  mediaTagId?: string(name='MediaTagId', description='标签'),
  nextToken?: string(name='NextToken', description='下一次读取的位置'),
}

model ListPublicMediaBasicInfosResponseBody = {
  maxResults?: int32(name='MaxResults'),
  mediaInfos?: [ 
    {
      fileInfoList?: [ 
        {
          fileBasicInfo?: {
            bitrate?: string(name='Bitrate', description='码率'),
            duration?: string(name='Duration', description='时长'),
            fileName?: string(name='FileName', description='文件名'),
            fileSize?: string(name='FileSize', description='文件大小（字节）'),
            fileStatus?: string(name='FileStatus', description='文件状态'),
            fileType?: string(name='FileType', description='文件类型'),
            fileUrl?: string(name='FileUrl', description='文件oss地址'),
            formatName?: string(name='FormatName', description='封装格式'),
            height?: string(name='Height', description='高'),
            region?: string(name='Region', description='文件存储区域'),
            width?: string(name='Width', description='宽'),
          }(name='FileBasicInfo', description='文件基础信息，包含时长，大小等'),
        }
      ](name='FileInfoList', description='FileInfos'),
      mediaBasicInfo?: {
        businessType?: string(name='BusinessType', description='媒资业务类型'),
        category?: string(name='Category', description='分类'),
        coverURL?: string(name='CoverURL', description='封面地址'),
        createTime?: string(name='CreateTime', description='媒资创建时间'),
        deletedTime?: string(name='DeletedTime', description='媒资删除时间'),
        description?: string(name='Description', description='内容描述'),
        inputURL?: string(name='InputURL', description='待注册的媒资在相应系统中的地址'),
        mediaId?: string(name='MediaId', description='MediaId'),
        mediaTags?: string(name='MediaTags', description='标签'),
        mediaType?: string(name='MediaType', description='媒资媒体类型'),
        modifiedTime?: string(name='ModifiedTime', description='媒资修改时间'),
        snapshots?: string(name='Snapshots', description='截图'),
        source?: string(name='Source', description='来源'),
        status?: string(name='Status', description='资源状态'),
        title?: string(name='Title', description='标题'),
        transcodeStatus?: string(name='TranscodeStatus', description='转码状态'),
        userData?: string(name='UserData', description='用户数据'),
      }(name='MediaBasicInfo', description='BasicInfo'),
      mediaId?: string(name='MediaId', description='媒资ID'),
    }
  ](name='MediaInfos', description='符合要求的媒资集合'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount', description='符合要求的媒资总数'),
}

model ListPublicMediaBasicInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPublicMediaBasicInfosResponseBody(name='body'),
}

async function listPublicMediaBasicInfosWithOptions(request: ListPublicMediaBasicInfosRequest, runtime: Util.RuntimeOptions): ListPublicMediaBasicInfosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.includeFileBasicInfo)) {
    query['IncludeFileBasicInfo'] = request.includeFileBasicInfo;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.mediaTagId)) {
    query['MediaTagId'] = request.mediaTagId;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPublicMediaBasicInfos',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPublicMediaBasicInfos(request: ListPublicMediaBasicInfosRequest): ListPublicMediaBasicInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPublicMediaBasicInfosWithOptions(request, runtime);
}

model ListSmartJobsRequest {
  jobState?: string(name='JobState', description='任务状态'),
  jobType?: string(name='JobType', description='任务类型'),
  maxResults?: long(name='MaxResults', description='分页大小。最大不超过100。  默认值：10'),
  nextToken?: string(name='NextToken', description='当前开始读取的位置'),
  pageNo?: long(name='PageNo', description='当前页码。默认值为1。'),
  pageSize?: long(name='PageSize', description='分页大小，每页显示条数。默认值为10，最大值为100。'),
  sortBy?: string(name='SortBy', description='排序参数，默认根据创建时间倒序'),
}

model ListSmartJobsResponseBody = {
  maxResults?: string(name='MaxResults', description='本次请求所返回的最大记录条数，最后一页前每页记录条数为MaxResults取值。  例如：  正例：10,10,5，反例：10,5,10'),
  nextToken?: string(name='NextToken', description='用来表示当前调用返回读取到的位置，空代表数据已经读取完毕。'),
  requestId?: string(name='RequestId', description='请求ID。'),
  smartJobList?: [ 
    {
      createTime?: string(name='CreateTime', description='创建时间'),
      description?: string(name='Description', description='任务描述'),
      editingConfig?: string(name='EditingConfig', description='输入配置'),
      inputConfig?: {
        inputFile?: string(name='InputFile', description='文件信息'),
        keyword?: string(name='Keyword', description='关键词信息'),
      }(name='InputConfig', description='任务输入配置'),
      jobId?: string(name='JobId', description='任务Id'),
      jobState?: string(name='JobState', description='任务状态'),
      jobType?: string(name='JobType', description='任务类型'),
      modifiedTime?: string(name='ModifiedTime', description='最后修改时间'),
      outputConfig?: {
        bucket?: string(name='Bucket', description='OSS Bucket'),
        object?: string(name='Object', description='OSS Object'),
      }(name='OutputConfig', description='任务输出配置'),
      title?: string(name='Title', description='任务标题'),
      userData?: string(name='UserData', description='用户自定义字段'),
      userId?: long(name='UserId', description='用户Id'),
    }
  ](name='SmartJobList'),
  totalCount?: string(name='TotalCount', description='本次请求条件下的数据总量，此参数为可选参数，默认可不返回。'),
}

model ListSmartJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSmartJobsResponseBody(name='body'),
}

async function listSmartJobsWithOptions(request: ListSmartJobsRequest, runtime: Util.RuntimeOptions): ListSmartJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSmartJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSmartJobs(request: ListSmartJobsRequest): ListSmartJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSmartJobsWithOptions(request, runtime);
}

model ListSnapshotJobsRequest {
  endOfCreateTime?: string(name='EndOfCreateTime'),
  jobId?: string(name='JobId'),
  nextPageToken?: string(name='NextPageToken', description='连续分页查询时下一页的标记'),
  orderBy?: string(name='OrderBy', description='排序顺序：CreateTimeDesc 和 CreateTimeAsc'),
  pageSize?: int32(name='PageSize'),
  startOfCreateTime?: string(name='StartOfCreateTime'),
  status?: string(name='Status'),
}

model ListSnapshotJobsResponseBody = {
  jobs?: [ 
    {
      async?: boolean(name='Async'),
      count?: int32(name='Count'),
      createTime?: string(name='CreateTime'),
      finishTime?: string(name='FinishTime'),
      input?: {
        media?: string(name='Media'),
        type?: string(name='Type'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      modifiedTime?: string(name='ModifiedTime'),
      name?: string(name='Name'),
      output?: {
        media?: string(name='Media'),
        type?: string(name='Type'),
      }(name='Output'),
      pipelineId?: string(name='PipelineId'),
      status?: string(name='Status'),
      submitTime?: string(name='SubmitTime'),
      templateId?: string(name='TemplateId'),
      triggerSource?: string(name='TriggerSource'),
      type?: string(name='Type'),
    }
  ](name='Jobs'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model ListSnapshotJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSnapshotJobsResponseBody(name='body'),
}

async function listSnapshotJobsWithOptions(request: ListSnapshotJobsRequest, runtime: Util.RuntimeOptions): ListSnapshotJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endOfCreateTime)) {
    query['EndOfCreateTime'] = request.endOfCreateTime;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startOfCreateTime)) {
    query['StartOfCreateTime'] = request.startOfCreateTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSnapshotJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSnapshotJobs(request: ListSnapshotJobsRequest): ListSnapshotJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSnapshotJobsWithOptions(request, runtime);
}

model ListSystemTemplatesRequest {
  name?: string(name='Name', description='模板名称'),
  pageNumber?: int32(name='PageNumber', description='分页数目'),
  pageSize?: int32(name='PageSize', description='分页大小'),
  status?: string(name='Status', description='模板状态：Normal正常，Invisible不可见，ALL全部'),
  subtype?: string(name='Subtype', description='模板子类型ID'),
  templateId?: string(name='TemplateId', description='模板ID'),
  type?: string(name='Type', description='模板类型。逗号分隔'),
}

model ListSystemTemplatesResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
  systemTemplateList?: [ 
    {
      status?: string(name='Status', description='模板状态'),
      subtype?: int32(name='Subtype', description='模板子类型ID'),
      subtypeName?: string(name='SubtypeName', description='模板子类型名称'),
      templateConfig?: string(name='TemplateConfig', description='模板参数'),
      templateId?: string(name='TemplateId', description='模板Id'),
      templateName?: string(name='TemplateName', description='模板名称'),
      type?: int32(name='Type', description='模板类型ID'),
      typeName?: string(name='TypeName', description='模板类型名称'),
    }
  ](name='SystemTemplateList', description='模板信息列表'),
  total?: int32(name='Total', description='模板总数'),
}

model ListSystemTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSystemTemplatesResponseBody(name='body'),
}

async function listSystemTemplatesWithOptions(request: ListSystemTemplatesRequest, runtime: Util.RuntimeOptions): ListSystemTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.subtype)) {
    query['Subtype'] = request.subtype;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSystemTemplates',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSystemTemplates(request: ListSystemTemplatesRequest): ListSystemTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSystemTemplatesWithOptions(request, runtime);
}

model ListTemplatesRequest {
  createSource?: string(name='CreateSource', description='创建来源'),
  keyword?: string(name='Keyword', description='搜索关键词，可以根据模板id和title搜索'),
  pageNo?: long(name='PageNo', description='当前页码。默认值为1。'),
  pageSize?: long(name='PageSize', description='分页大小，每页显示条数。默认值为10，最大值为100。'),
  sortType?: string(name='SortType', description='排序参数，默认根据创建时间倒序'),
  status?: string(name='Status', description='模板状态'),
  type?: string(name='Type', description='模板类型'),
}

model ListTemplatesResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
  templates?: [ 
    {
      clipsParam?: string(name='ClipsParam', description='ClipsParam'),
      config?: string(name='Config', description='模板配置'),
      coverURL?: string(name='CoverURL', description='封面URL'),
      createSource?: string(name='CreateSource', description='创建来源'),
      creationTime?: string(name='CreationTime', description='创建时间'),
      modifiedSource?: string(name='ModifiedSource', description='修改来源'),
      modifiedTime?: string(name='ModifiedTime', description='修改时间'),
      name?: string(name='Name', description='模板名称'),
      previewMedia?: string(name='PreviewMedia', description='预览素材'),
      previewMediaStatus?: string(name='PreviewMediaStatus', description='预览素材状态'),
      status?: string(name='Status', description='模板状态'),
      templateId?: string(name='TemplateId', description='模板ID'),
      type?: string(name='Type', description='模板类型'),
    }
  ](name='Templates'),
  totalCount?: int32(name='TotalCount', description='本次请求条件下的数据总量。'),
}

model ListTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTemplatesResponseBody(name='body'),
}

async function listTemplatesWithOptions(request: ListTemplatesRequest, runtime: Util.RuntimeOptions): ListTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createSource)) {
    query['CreateSource'] = request.createSource;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortType)) {
    query['SortType'] = request.sortType;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTemplates',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTemplates(request: ListTemplatesRequest): ListTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTemplatesWithOptions(request, runtime);
}

model ListTranscodeJobsRequest {
  endOfCreateTime?: string(name='EndOfCreateTime', description='任务创建时间筛选条件的结束时间'),
  jobId?: string(name='JobId', description='按 jobId 筛选'),
  nextPageToken?: string(name='NextPageToken', description='连续分页查询时下一页的标记 (第一页没有)'),
  orderBy?: string(name='OrderBy', description='排序顺序，目前只支持两种：CreateTimeDesc 和 CreateTimeAsc'),
  pageSize?: int32(name='PageSize'),
  startOfCreateTime?: string(name='StartOfCreateTime', description='任务创建时间筛选条件的起始时间'),
  status?: string(name='Status', description='任务状态'),
}

model ListTranscodeJobsResponseBody = {
  jobs?: [ 
    {
      createTime?: string(name='CreateTime', description='任务创建时间'),
      finishTime?: string(name='FinishTime', description='任务结束时间'),
      inputGroup?: [ 
        {
          media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
          type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
        }
      ](name='InputGroup', description='任务输入组 (目前只支持单个输入)'),
      jobCount?: int32(name='JobCount', description='子任务数量'),
      name?: string(name='Name', description='任务名'),
      outputGroup?: [ 
        {
          output?: {
            media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
            type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
          }(name='Output', description='输出媒体配置'),
          processConfig?: {
            imageWatermarks?: [ 
              {
                overwriteParams?: {
                  dx?: string(name='Dx', description='水印位置，x'),
                  dy?: string(name='Dy', description='水印位置，y'),
                  file?: {
                    media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
                    type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
                  }(name='File', description='水印文件oss路径'),
                  height?: string(name='Height', description='高'),
                  referPos?: string(name='ReferPos', description='参考位置: TopLeft, TopRight, BottomLeft, BottomRight  default: TopLeft'),
                  timeline?: {
                    duration?: string(name='Duration', description='显示时长，秒数 或者 "ToEND"'),
                    start?: string(name='Start', description='开始时间'),
                  }(name='Timeline', description='显示时间设置'),
                  width?: string(name='Width', description='宽'),
                }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
                templateId?: string(name='TemplateId', description='模板 id'),
              }
            ](name='ImageWatermarks', description='图片水印配置'),
            subtitles?: [ 
              {
                overwriteParams?: {
                  charEnc?: string(name='CharEnc', description='文件 encoding 格式'),
                  file?: {
                    media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
                    type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
                  }(name='File', description='字幕文件'),
                  format?: string(name='Format', description='字幕文件格式'),
                }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
                templateId?: string(name='TemplateId', description='模板 id'),
              }
            ](name='Subtitles', description='字幕压制配置'),
            textWatermarks?: [ 
              {
                overwriteParams?: {
                  adaptive?: string(name='Adaptive', description='根据输出视频大小调整字体 size。 true / false, default: false'),
                  borderColor?: string(name='BorderColor', description='边框颜色'),
                  borderWidth?: int32(name='BorderWidth', description='边框宽度'),
                  content?: string(name='Content', description='水印文本，不需要 base64 encode，字符串需要 utf-8 编码'),
                  fontAlpha?: string(name='FontAlpha', description='透明度'),
                  fontColor?: string(name='FontColor', description='颜色'),
                  fontName?: string(name='FontName', description='字体'),
                  fontSize?: int32(name='FontSize', description='字体大小'),
                  left?: string(name='Left', description='水印位置，距离左边距离'),
                  top?: string(name='Top', description='水印位置，距离上边距离'),
                }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
                templateId?: string(name='TemplateId', description='模板 id'),
              }
            ](name='TextWatermarks', description='文字水印配置'),
            transcode?: {
              overwriteParams?: {
                audio?: {
                  bitrate?: string(name='Bitrate', description='输出文件的音频码率。'),
                  channels?: string(name='Channels', description='声道数。'),
                  codec?: string(name='Codec', description='音频编解码格式，AAC、MP3、VORBIS、FLAC。'),
                  profile?: string(name='Profile', description='音频编码预置。'),
                  remove?: string(name='Remove', description='是否删除音频流。'),
                  samplerate?: string(name='Samplerate', description='采样率。'),
                  volume?: {
                    integratedLoudnessTarget?: string(name='IntegratedLoudnessTarget', description='目标音量'),
                    loudnessRangeTarget?: string(name='LoudnessRangeTarget', description='音量范围'),
                    method?: string(name='Method', description='音量调整方式'),
                    truePeak?: string(name='TruePeak', description='最大峰值'),
                  }(name='Volume', description='音量控制'),
                }(name='Audio', description='audio 设置'),
                container?: {
                  format?: string(name='Format', description='容器格式'),
                }(name='Container', description='封装格式设置'),
                muxConfig?: {
                  segment?: {
                    duration?: string(name='Duration', description='切片时长'),
                    forceSegTime?: string(name='ForceSegTime', description='强制切片时间点'),
                  }(name='Segment', description='切片设置'),
                }(name='MuxConfig', description='封装设置'),
                video?: {
                  abrMax?: string(name='AbrMax'),
                  bitrate?: string(name='Bitrate', description='视频平均码率。'),
                  bufsize?: string(name='Bufsize', description='缓冲区大小'),
                  codec?: string(name='Codec', description='编码格式'),
                  crf?: string(name='Crf', description='码率-质量控制因子。'),
                  crop?: string(name='Crop', description='视频画面裁切'),
                  fps?: string(name='Fps', description='帧率。'),
                  gop?: string(name='Gop', description='关键帧间最大帧数。'),
                  height?: string(name='Height', description='高。'),
                  longShortMode?: string(name='LongShortMode', description='是否开启横竖屏自适应（即：长短边模式）'),
                  maxrate?: string(name='Maxrate', description='视频码率峰值'),
                  pad?: string(name='Pad', description='视频贴黑边'),
                  pixFmt?: string(name='PixFmt', description='视频颜色格式。'),
                  preset?: string(name='Preset', description='只有H264支持该参数'),
                  profile?: string(name='Profile', description='编码级别。'),
                  remove?: string(name='Remove', description='是否去掉视频'),
                  scanMode?: string(name='ScanMode', description='扫描模式。'),
                  width?: string(name='Width', description='宽。'),
                }(name='Video', description='video 设置'),
              }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
              templateId?: string(name='TemplateId', description='模板 id'),
            }(name='Transcode', description='转码配置'),
          }(name='ProcessConfig', description='任务处理配置'),
        }
      ](name='OutputGroup', description='任务输出组'),
      parentJobId?: string(name='ParentJobId', description='主任务 id'),
      percent?: int32(name='Percent', description='任务完成百分比'),
      requestId?: string(name='RequestId', description='提交任务时请求 id'),
      scheduleConfig?: {
        pipelineId?: string(name='PipelineId', description='管道 id'),
        priority?: int32(name='Priority', description='任务优先级，取值范围：1~10'),
      }(name='ScheduleConfig', description='任务调度配置'),
      status?: string(name='Status', description='任务状态 Success: 有子任务成功, Fail: 所有子任务失败'),
      submitTime?: string(name='SubmitTime', description='任务提交时间'),
      triggerSource?: string(name='TriggerSource', description='任务来源 - API, WorkFlow, Console'),
      userData?: string(name='UserData', description='用户数据'),
    }
  ](name='Jobs'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId', description='请求 id'),
}

model ListTranscodeJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTranscodeJobsResponseBody(name='body'),
}

async function listTranscodeJobsWithOptions(request: ListTranscodeJobsRequest, runtime: Util.RuntimeOptions): ListTranscodeJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endOfCreateTime)) {
    query['EndOfCreateTime'] = request.endOfCreateTime;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startOfCreateTime)) {
    query['StartOfCreateTime'] = request.startOfCreateTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTranscodeJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTranscodeJobs(request: ListTranscodeJobsRequest): ListTranscodeJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTranscodeJobsWithOptions(request, runtime);
}

model NotifyPreOssUploadCompleteRequest {
  fileName?: string(name='FileName'),
}

model NotifyPreOssUploadCompleteResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
}

model NotifyPreOssUploadCompleteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: NotifyPreOssUploadCompleteResponseBody(name='body'),
}

async function notifyPreOssUploadCompleteWithOptions(request: NotifyPreOssUploadCompleteRequest, runtime: Util.RuntimeOptions): NotifyPreOssUploadCompleteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'NotifyPreOssUploadComplete',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function notifyPreOssUploadComplete(request: NotifyPreOssUploadCompleteRequest): NotifyPreOssUploadCompleteResponse {
  var runtime = new Util.RuntimeOptions{};
  return notifyPreOssUploadCompleteWithOptions(request, runtime);
}

model QueryCensorJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryCensorJobListResponseBody = {
  jobs?: {
    censorJob?: [ 
    {
      barrageCensorResult?: string(name='BarrageCensorResult'),
      censorConfig?: {
        bizType?: string(name='BizType'),
        interval?: string(name='Interval'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='OutputFile'),
        saveType?: string(name='SaveType'),
        scenes?: string(name='Scenes'),
      }(name='CensorConfig'),
      censorPornResult?: {
        averageScore?: string(name='AverageScore'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
        pornCounterList?: {
          counter?: [ 
          {
            count?: int32(name='Count'),
            label?: string(name='Label'),
          }
        ](name='Counter')
        }(name='PornCounterList'),
        pornTopList?: {
          top?: [ 
          {
            index?: string(name='Index'),
            label?: string(name='Label'),
            object?: string(name='Object'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
          }
        ](name='Top')
        }(name='PornTopList'),
        suggestion?: string(name='Suggestion'),
      }(name='CensorPornResult'),
      censorTerrorismResult?: {
        averageScore?: string(name='AverageScore'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
        suggestion?: string(name='Suggestion'),
        terrorismCounterList?: {
          counter?: [ 
          {
            count?: int32(name='Count'),
            label?: string(name='Label'),
          }
        ](name='Counter')
        }(name='TerrorismCounterList'),
        terrorismTopList?: {
          top?: [ 
          {
            index?: string(name='Index'),
            label?: string(name='Label'),
            object?: string(name='Object'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
          }
        ](name='Top')
        }(name='TerrorismTopList'),
      }(name='CensorTerrorismResult'),
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      descCensorResult?: string(name='DescCensorResult'),
      id?: string(name='Id'),
      imageCensorResults?: {
        imageCensorResult?: [ 
        {
          imageBucket?: string(name='ImageBucket'),
          imageLocation?: string(name='ImageLocation'),
          imageObject?: string(name='ImageObject'),
          result?: string(name='Result'),
        }
      ](name='ImageCensorResult')
      }(name='ImageCensorResults'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      resultSaveObject?: string(name='ResultSaveObject'),
      state?: string(name='State'),
      titleCensorResult?: string(name='TitleCensorResult'),
      userData?: string(name='UserData'),
    }
  ](name='CensorJob')
  }(name='Jobs'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryCensorJobListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryCensorJobListResponseBody(name='body'),
}

async function queryCensorJobListWithOptions(request: QueryCensorJobListRequest, runtime: Util.RuntimeOptions): QueryCensorJobListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobIds)) {
    query['JobIds'] = request.jobIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryCensorJobList',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryCensorJobList(request: QueryCensorJobListRequest): QueryCensorJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCensorJobListWithOptions(request, runtime);
}

model QueryIProductionJobRequest {
  clientToken?: string(name='ClientToken', description='幂等参数'),
  jobId?: string(name='JobId'),
}

model QueryIProductionJobResponseBody = {
  createTime?: string(name='CreateTime'),
  finishTime?: string(name='FinishTime'),
  functionName?: string(name='FunctionName'),
  input?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Input'),
  jobId?: string(name='JobId'),
  jobParams?: string(name='JobParams'),
  name?: string(name='Name'),
  output?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Output'),
  outputFiles?: [ string ](name='OutputFiles'),
  outputUrls?: [ string ](name='OutputUrls'),
  requestId?: string(name='RequestId', description='Id of the request'),
  result?: string(name='Result'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId'),
    priority?: int32(name='Priority'),
  }(name='ScheduleConfig'),
  status?: string(name='Status'),
  templateId?: string(name='TemplateId'),
  userData?: string(name='UserData'),
}

model QueryIProductionJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryIProductionJobResponseBody(name='body'),
}

async function queryIProductionJobWithOptions(request: QueryIProductionJobRequest, runtime: Util.RuntimeOptions): QueryIProductionJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryIProductionJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryIProductionJob(request: QueryIProductionJobRequest): QueryIProductionJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIProductionJobWithOptions(request, runtime);
}

model QueryMediaCensorJobDetailRequest {
  jobId?: string(name='JobId'),
  maximumPageSize?: long(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryMediaCensorJobDetailResponseBody = {
  mediaCensorJobDetail?: {
    barrageCensorResult?: {
      label?: string(name='Label'),
      rate?: string(name='Rate'),
      scene?: string(name='Scene'),
      suggestion?: string(name='Suggestion'),
    }(name='BarrageCensorResult'),
    code?: string(name='Code'),
    coverImageCensorResults?: {
      coverImageCensorResult?: [ 
      {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        results?: {
          result?: [ 
          {
            label?: string(name='Label'),
            rate?: string(name='Rate'),
            scene?: string(name='Scene'),
            suggestion?: string(name='Suggestion'),
          }
        ](name='Result')
        }(name='Results'),
      }
    ](name='CoverImageCensorResult')
    }(name='CoverImageCensorResults'),
    creationTime?: string(name='CreationTime'),
    descCensorResult?: {
      label?: string(name='Label'),
      rate?: string(name='Rate'),
      scene?: string(name='Scene'),
      suggestion?: string(name='Suggestion'),
    }(name='DescCensorResult'),
    finishTime?: string(name='FinishTime'),
    input?: {
      bucket?: string(name='Bucket'),
      location?: string(name='Location'),
      object?: string(name='Object'),
    }(name='Input'),
    jobId?: string(name='JobId'),
    message?: string(name='Message'),
    pipelineId?: string(name='PipelineId'),
    state?: string(name='State'),
    suggestion?: string(name='Suggestion'),
    titleCensorResult?: {
      label?: string(name='Label'),
      rate?: string(name='Rate'),
      scene?: string(name='Scene'),
      suggestion?: string(name='Suggestion'),
    }(name='TitleCensorResult'),
    userData?: string(name='UserData'),
    vensorCensorResult?: {
      censorResults?: {
        censorResult?: [ 
        {
          label?: string(name='Label'),
          rate?: string(name='Rate'),
          scene?: string(name='Scene'),
          suggestion?: string(name='Suggestion'),
        }
      ](name='CensorResult')
      }(name='CensorResults'),
      nextPageToken?: string(name='NextPageToken'),
      videoTimelines?: {
        videoTimeline?: [ 
        {
          censorResults?: {
            censorResult?: [ 
            {
              label?: string(name='Label'),
              rate?: string(name='Rate'),
              scene?: string(name='Scene'),
              suggestion?: string(name='Suggestion'),
            }
          ](name='CensorResult')
          }(name='CensorResults'),
          object?: string(name='Object'),
          timestamp?: string(name='Timestamp'),
        }
      ](name='VideoTimeline')
      }(name='VideoTimelines'),
    }(name='VensorCensorResult'),
    videoCensorConfig?: {
      bizType?: string(name='BizType'),
      outputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='OutputFile'),
      videoCensor?: string(name='VideoCensor'),
    }(name='VideoCensorConfig'),
  }(name='MediaCensorJobDetail'),
  requestId?: string(name='RequestId'),
}

model QueryMediaCensorJobDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMediaCensorJobDetailResponseBody(name='body'),
}

async function queryMediaCensorJobDetailWithOptions(request: QueryMediaCensorJobDetailRequest, runtime: Util.RuntimeOptions): QueryMediaCensorJobDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.maximumPageSize)) {
    query['MaximumPageSize'] = request.maximumPageSize;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaCensorJobDetail',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaCensorJobDetail(request: QueryMediaCensorJobDetailRequest): QueryMediaCensorJobDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaCensorJobDetailWithOptions(request, runtime);
}

model RefreshUploadMediaRequest {
  mediaId?: string(name='MediaId'),
}

model RefreshUploadMediaResponseBody = {
  mediaId?: string(name='MediaId'),
  requestId?: string(name='RequestId', description='RequestId'),
  uploadAddress?: string(name='UploadAddress'),
  uploadAuth?: string(name='UploadAuth'),
}

model RefreshUploadMediaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefreshUploadMediaResponseBody(name='body'),
}

async function refreshUploadMediaWithOptions(request: RefreshUploadMediaRequest, runtime: Util.RuntimeOptions): RefreshUploadMediaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshUploadMedia',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshUploadMedia(request: RefreshUploadMediaRequest): RefreshUploadMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshUploadMediaWithOptions(request, runtime);
}

model RegisterMediaInfoRequest {
  businessType?: string(name='BusinessType', description='媒资业务类型'),
  cateId?: long(name='CateId'),
  clientToken?: string(name='ClientToken', description='客户端token'),
  coverURL?: string(name='CoverURL', description='封面图，仅视频媒资有效'),
  description?: string(name='Description', description='描述'),
  inputURL?: string(name='InputURL', description='媒资媒体url'),
  mediaTags?: string(name='MediaTags', description='标签,如果有多个标签用逗号隔开'),
  mediaType?: string(name='MediaType', description='媒资媒体类型'),
  overwrite?: boolean(name='Overwrite', description='是否覆盖已有媒资'),
  registerConfig?: string(name='RegisterConfig', description='注册媒资的配置'),
  title?: string(name='Title', description='标题'),
  userData?: string(name='UserData', description='用户数据，最大1024字节'),
}

model RegisterMediaInfoResponseBody = {
  mediaId?: string(name='MediaId', description='ICE媒资ID'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model RegisterMediaInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterMediaInfoResponseBody(name='body'),
}

async function registerMediaInfoWithOptions(request: RegisterMediaInfoRequest, runtime: Util.RuntimeOptions): RegisterMediaInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessType)) {
    query['BusinessType'] = request.businessType;
  }
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.coverURL)) {
    query['CoverURL'] = request.coverURL;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.inputURL)) {
    query['InputURL'] = request.inputURL;
  }
  if (!Util.isUnset(request.mediaTags)) {
    query['MediaTags'] = request.mediaTags;
  }
  if (!Util.isUnset(request.mediaType)) {
    query['MediaType'] = request.mediaType;
  }
  if (!Util.isUnset(request.overwrite)) {
    query['Overwrite'] = request.overwrite;
  }
  if (!Util.isUnset(request.registerConfig)) {
    query['RegisterConfig'] = request.registerConfig;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RegisterMediaInfo',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerMediaInfo(request: RegisterMediaInfoRequest): RegisterMediaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerMediaInfoWithOptions(request, runtime);
}

model RegisterMediaStreamRequest {
  inputURL?: string(name='InputURL'),
  mediaId?: string(name='MediaId'),
  userData?: string(name='UserData'),
}

model RegisterMediaStreamResponseBody = {
  mediaId?: string(name='MediaId'),
  requestId?: string(name='RequestId'),
}

model RegisterMediaStreamResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterMediaStreamResponseBody(name='body'),
}

async function registerMediaStreamWithOptions(request: RegisterMediaStreamRequest, runtime: Util.RuntimeOptions): RegisterMediaStreamResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.inputURL)) {
    query['InputURL'] = request.inputURL;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RegisterMediaStream',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerMediaStream(request: RegisterMediaStreamRequest): RegisterMediaStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerMediaStreamWithOptions(request, runtime);
}

model SearchEditingProjectRequest {
  createSource?: string(name='CreateSource', description='创建来源'),
  endTime?: string(name='EndTime', description='CreationTime（创建时间）的结束时间'),
  maxResults?: long(name='MaxResults', description='分页参数'),
  nextToken?: string(name='NextToken', description='分页参数'),
  projectType?: string(name='ProjectType'),
  sortBy?: string(name='SortBy', description='结果排序方式'),
  startTime?: string(name='StartTime', description='CreateTime（创建时间）的开始时间'),
  status?: string(name='Status', description='云剪辑工程状态。多个用逗号分隔'),
  templateType?: string(name='TemplateType', description='模板类型'),
}

model SearchEditingProjectResponseBody = {
  maxResults?: long(name='MaxResults', description='云剪辑工程总数'),
  nextToken?: string(name='NextToken'),
  projectList?: [ 
    {
      businessConfig?: string(name='BusinessConfig'),
      businessStatus?: string(name='BusinessStatus'),
      coverURL?: string(name='CoverURL', description='云剪辑工程封面'),
      createSource?: string(name='CreateSource', description='创建来源'),
      createTime?: string(name='CreateTime', description='云剪辑工程创建时间'),
      description?: string(name='Description', description='云剪辑工程描述'),
      duration?: long(name='Duration', description='云剪辑工程总时长'),
      errorCode?: string(name='ErrorCode', description='云剪辑工程合成失败的错误码'),
      errorMessage?: string(name='ErrorMessage', description='云剪辑工程合成失败的消息'),
      modifiedSource?: string(name='ModifiedSource', description='最后一次修改来源'),
      modifiedTime?: string(name='ModifiedTime', description='云剪辑工程最新修改时间'),
      projectId?: string(name='ProjectId', description='云剪辑工程ID'),
      projectType?: string(name='ProjectType'),
      status?: string(name='Status', description='云剪辑工程状态'),
      templateType?: string(name='TemplateType', description='模板类型'),
      timeline?: string(name='Timeline', description='云剪辑工程时间线'),
      title?: string(name='Title', description='云剪辑工程标题'),
    }
  ](name='ProjectList', description='云剪辑工程列表'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
}

model SearchEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchEditingProjectResponseBody(name='body'),
}

async function searchEditingProjectWithOptions(request: SearchEditingProjectRequest, runtime: Util.RuntimeOptions): SearchEditingProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createSource)) {
    query['CreateSource'] = request.createSource;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.projectType)) {
    query['ProjectType'] = request.projectType;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.templateType)) {
    query['TemplateType'] = request.templateType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchEditingProject',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchEditingProject(request: SearchEditingProjectRequest): SearchEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchEditingProjectWithOptions(request, runtime);
}

model SearchMediaRequest {
  entityId?: string(name='EntityId', description='实体Id'),
  match?: string(name='Match', description='过滤条件'),
  pageNo?: int32(name='PageNo', description='当前页码。默认值为1'),
  pageSize?: int32(name='PageSize', description='每页返回的数据条数。默认值为10，最大值为100'),
  sortBy?: string(name='SortBy', description='排序字段和排序顺序。多个使用英文逗号（,）分隔'),
}

model SearchMediaResponseBody = {
  code?: string(name='Code'),
  mediaInfoList?: [ 
    {
      fileInfoList?: [ 
        {
          fileBasicInfo?: {
            bitrate?: string(name='Bitrate', description='码率'),
            createTime?: string(name='CreateTime'),
            duration?: string(name='Duration', description='时长'),
            fileName?: string(name='FileName', description='文件名'),
            fileSize?: string(name='FileSize', description='文件大小（字节）'),
            fileStatus?: string(name='FileStatus', description='文件状态'),
            fileType?: string(name='FileType'),
            fileUrl?: string(name='FileUrl', description='文件oss地址'),
            formatName?: string(name='FormatName', description='封装格式'),
            height?: string(name='Height', description='高'),
            modifiedTime?: string(name='ModifiedTime'),
            region?: string(name='Region', description='文件存储区域'),
            width?: string(name='Width', description='宽'),
          }(name='FileBasicInfo', description='文件基础信息，包含时长，大小等'),
        }
      ](name='FileInfoList', description='FileInfos'),
      mediaBasicInfo?: {
        biz?: string(name='Biz'),
        businessType?: string(name='BusinessType', description='媒资业务类型'),
        cateId?: long(name='CateId'),
        cateName?: string(name='CateName'),
        category?: string(name='Category', description='分类'),
        coverURL?: string(name='CoverURL', description='封面地址'),
        createTime?: string(name='CreateTime', description='媒资创建时间'),
        deletedTime?: string(name='DeletedTime', description='媒资删除时间'),
        description?: string(name='Description', description='内容描述'),
        inputURL?: string(name='InputURL', description='待注册的媒资在相应系统中的地址'),
        mediaId?: string(name='MediaId', description='MediaId'),
        mediaTags?: string(name='MediaTags', description='标签'),
        mediaType?: string(name='MediaType', description='媒资媒体类型'),
        modifiedTime?: string(name='ModifiedTime', description='媒资修改时间'),
        snapshots?: string(name='Snapshots', description='截图'),
        source?: string(name='Source', description='来源'),
        spriteImages?: string(name='SpriteImages', description='雪碧图'),
        status?: string(name='Status', description='资源状态'),
        title?: string(name='Title', description='标题'),
        transcodeStatus?: string(name='TranscodeStatus', description='转码状态'),
        uploadSource?: string(name='UploadSource'),
        userData?: string(name='UserData', description='用户数据'),
      }(name='MediaBasicInfo', description='BasicInfo'),
      mediaId?: string(name='MediaId', description='媒资ID'),
    }
  ](name='MediaInfoList', description='符合要求的媒资集合'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  total?: long(name='Total'),
}

model SearchMediaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchMediaResponseBody(name='body'),
}

async function searchMediaWithOptions(request: SearchMediaRequest, runtime: Util.RuntimeOptions): SearchMediaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.entityId)) {
    query['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.match)) {
    query['Match'] = request.match;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchMedia',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchMedia(request: SearchMediaRequest): SearchMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchMediaWithOptions(request, runtime);
}

model SearchPublicMediaInfoRequest {
  authorized?: boolean(name='Authorized'),
  dynamicMetaDataMatchFields?: string(name='DynamicMetaDataMatchFields'),
  entityId?: string(name='EntityId'),
  favorite?: boolean(name='Favorite'),
  mediaIds?: string(name='MediaIds'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  sortBy?: string(name='SortBy'),
}

model SearchPublicMediaInfoResponseBody = {
  publicMediaInfos?: [ 
    {
      authorized?: boolean(name='Authorized'),
      favorite?: boolean(name='Favorite'),
      mediaInfo?: {
        dynamicMetaData?: {
          data?: string(name='Data'),
          type?: string(name='Type'),
        }(name='DynamicMetaData'),
        mediaBasicInfo?: {
          businessType?: string(name='BusinessType', description='媒资业务类型'),
          category?: string(name='Category', description='分类'),
          coverURL?: string(name='CoverURL', description='封面地址'),
          createTime?: string(name='CreateTime', description='媒资创建时间'),
          deletedTime?: string(name='DeletedTime', description='媒资删除时间'),
          description?: string(name='Description', description='内容描述'),
          mediaId?: string(name='MediaId', description='MediaId'),
          mediaTags?: string(name='MediaTags', description='标签'),
          mediaType?: string(name='MediaType', description='媒资媒体类型'),
          modifiedTime?: string(name='ModifiedTime', description='媒资修改时间'),
          source?: string(name='Source', description='来源'),
          spriteImages?: string(name='SpriteImages', description='雪碧图'),
          status?: string(name='Status', description='资源状态'),
          title?: string(name='Title', description='标题'),
          userData?: string(name='UserData', description='用户数据'),
        }(name='MediaBasicInfo', description='BasicInfo'),
        mediaId?: string(name='MediaId', description='媒资ID'),
      }(name='MediaInfo'),
      remainingAuthTime?: string(name='RemainingAuthTime'),
    }
  ](name='PublicMediaInfos'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
}

model SearchPublicMediaInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchPublicMediaInfoResponseBody(name='body'),
}

async function searchPublicMediaInfoWithOptions(request: SearchPublicMediaInfoRequest, runtime: Util.RuntimeOptions): SearchPublicMediaInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authorized)) {
    query['Authorized'] = request.authorized;
  }
  if (!Util.isUnset(request.dynamicMetaDataMatchFields)) {
    query['DynamicMetaDataMatchFields'] = request.dynamicMetaDataMatchFields;
  }
  if (!Util.isUnset(request.entityId)) {
    query['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.favorite)) {
    query['Favorite'] = request.favorite;
  }
  if (!Util.isUnset(request.mediaIds)) {
    query['MediaIds'] = request.mediaIds;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchPublicMediaInfo',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchPublicMediaInfo(request: SearchPublicMediaInfoRequest): SearchPublicMediaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchPublicMediaInfoWithOptions(request, runtime);
}

model SendLiveTranscodeJobCommandRequest {
  command?: string(name='Command'),
  jobId?: string(name='JobId', description='模板Id'),
}

model SendLiveTranscodeJobCommandResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
}

model SendLiveTranscodeJobCommandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SendLiveTranscodeJobCommandResponseBody(name='body'),
}

async function sendLiveTranscodeJobCommandWithOptions(request: SendLiveTranscodeJobCommandRequest, runtime: Util.RuntimeOptions): SendLiveTranscodeJobCommandResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.command)) {
    query['Command'] = request.command;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SendLiveTranscodeJobCommand',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendLiveTranscodeJobCommand(request: SendLiveTranscodeJobCommandRequest): SendLiveTranscodeJobCommandResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendLiveTranscodeJobCommandWithOptions(request, runtime);
}

model SetAuditConfigRequest {
  appId?: string(name='AppId'),
  channel?: string(name='Channel'),
  legalSwitch?: string(name='LegalSwitch'),
}

model SetAuditConfigResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
}

model SetAuditConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetAuditConfigResponseBody(name='body'),
}

async function setAuditConfigWithOptions(request: SetAuditConfigRequest, runtime: Util.RuntimeOptions): SetAuditConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.legalSwitch)) {
    query['LegalSwitch'] = request.legalSwitch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetAuditConfig',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setAuditConfig(request: SetAuditConfigRequest): SetAuditConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setAuditConfigWithOptions(request, runtime);
}

model SetClientConfigRequest {
  bundleId?: string(name='BundleId', description='云端配置所对应的IOS BundleId'),
  clientUploadBucket?: string(name='ClientUploadBucket', description='端侧上传存储Bucket信息'),
  clientUploadPath?: string(name='ClientUploadPath', description='端侧上传存储bucket下路径信息'),
  clientUploadStorageType?: string(name='ClientUploadStorageType', description='端侧上传存储类型，vod_oss_bucket: vod托管bucket，user_oss_bucket: 用户私有bucket'),
  pkgName?: string(name='PkgName', description='云端配置所对应的安卓包名。'),
  pkgSignature?: string(name='PkgSignature', description='云端配置所对应的安卓包签名，当包名不为空时，必填。'),
}

model SetClientConfigResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success', description='配置是否成功'),
}

model SetClientConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetClientConfigResponseBody(name='body'),
}

async function setClientConfigWithOptions(request: SetClientConfigRequest, runtime: Util.RuntimeOptions): SetClientConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bundleId)) {
    query['BundleId'] = request.bundleId;
  }
  if (!Util.isUnset(request.clientUploadBucket)) {
    query['ClientUploadBucket'] = request.clientUploadBucket;
  }
  if (!Util.isUnset(request.clientUploadPath)) {
    query['ClientUploadPath'] = request.clientUploadPath;
  }
  if (!Util.isUnset(request.clientUploadStorageType)) {
    query['ClientUploadStorageType'] = request.clientUploadStorageType;
  }
  if (!Util.isUnset(request.pkgName)) {
    query['PkgName'] = request.pkgName;
  }
  if (!Util.isUnset(request.pkgSignature)) {
    query['PkgSignature'] = request.pkgSignature;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetClientConfig',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setClientConfig(request: SetClientConfigRequest): SetClientConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setClientConfigWithOptions(request, runtime);
}

model SetDefaultCustomTemplateRequest {
  templateId?: string(name='TemplateId', description='模板ID'),
}

model SetDefaultCustomTemplateResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='是否成功'),
}

model SetDefaultCustomTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDefaultCustomTemplateResponseBody(name='body'),
}

async function setDefaultCustomTemplateWithOptions(request: SetDefaultCustomTemplateRequest, runtime: Util.RuntimeOptions): SetDefaultCustomTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDefaultCustomTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDefaultCustomTemplate(request: SetDefaultCustomTemplateRequest): SetDefaultCustomTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultCustomTemplateWithOptions(request, runtime);
}

model SetDefaultStorageLocationRequest {
  bucket?: string(name='Bucket'),
  path?: string(name='Path'),
  storageType?: string(name='StorageType'),
}

model SetDefaultStorageLocationResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model SetDefaultStorageLocationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDefaultStorageLocationResponseBody(name='body'),
}

async function setDefaultStorageLocationWithOptions(request: SetDefaultStorageLocationRequest, runtime: Util.RuntimeOptions): SetDefaultStorageLocationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bucket)) {
    query['Bucket'] = request.bucket;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDefaultStorageLocation',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDefaultStorageLocation(request: SetDefaultStorageLocationRequest): SetDefaultStorageLocationResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultStorageLocationWithOptions(request, runtime);
}

model SetEventCallbackRequest {
  authKey?: string(name='AuthKey'),
  authSwitch?: string(name='AuthSwitch'),
  callbackQueueName?: string(name='CallbackQueueName'),
  callbackType?: string(name='CallbackType'),
  callbackURL?: string(name='CallbackURL'),
  eventTypeList?: string(name='EventTypeList'),
}

model SetEventCallbackResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success', description='是否设置成功'),
}

model SetEventCallbackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetEventCallbackResponseBody(name='body'),
}

async function setEventCallbackWithOptions(request: SetEventCallbackRequest, runtime: Util.RuntimeOptions): SetEventCallbackResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authKey)) {
    query['AuthKey'] = request.authKey;
  }
  if (!Util.isUnset(request.authSwitch)) {
    query['AuthSwitch'] = request.authSwitch;
  }
  if (!Util.isUnset(request.callbackQueueName)) {
    query['CallbackQueueName'] = request.callbackQueueName;
  }
  if (!Util.isUnset(request.callbackType)) {
    query['CallbackType'] = request.callbackType;
  }
  if (!Util.isUnset(request.callbackURL)) {
    query['CallbackURL'] = request.callbackURL;
  }
  if (!Util.isUnset(request.eventTypeList)) {
    query['EventTypeList'] = request.eventTypeList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetEventCallback',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setEventCallback(request: SetEventCallbackRequest): SetEventCallbackResponse {
  var runtime = new Util.RuntimeOptions{};
  return setEventCallbackWithOptions(request, runtime);
}

model SubmitASRJobRequest {
  description?: string(name='Description', description='任务描述'),
  duration?: string(name='Duration', description='持续时间'),
  inputFile?: string(name='InputFile', description='输入配置，支持OSS地址和内容库素材ID'),
  startTime?: string(name='StartTime', description='开始时间'),
  title?: string(name='Title', description='任务标题'),
  userData?: string(name='UserData', description='自定义设置，为JSON字符串'),
}

model SubmitASRJobResponseBody = {
  jobId?: string(name='JobId', description='智能任务Id'),
  requestId?: string(name='RequestId', description='请求Id'),
  state?: string(name='State', description='任务状态'),
}

model SubmitASRJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitASRJobResponseBody(name='body'),
}

async function submitASRJobWithOptions(request: SubmitASRJobRequest, runtime: Util.RuntimeOptions): SubmitASRJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.inputFile)) {
    query['InputFile'] = request.inputFile;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitASRJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitASRJob(request: SubmitASRJobRequest): SubmitASRJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitASRJobWithOptions(request, runtime);
}

model SubmitAudioProduceJobRequest {
  description?: string(name='Description', description='任务描述'),
  editingConfig?: string(name='EditingConfig', description='音频生产配置'),
  inputConfig?: string(name='InputConfig', description='文本内容。  最大支持300个汉字'),
  outputConfig?: string(name='OutputConfig', description='音频输出配置'),
  overwrite?: boolean(name='Overwrite', description='是否覆盖现有OSS文件'),
  title?: string(name='Title', description='任务标题'),
  userData?: string(name='UserData', description='自定义数据'),
}

model SubmitAudioProduceJobResponseBody = {
  jobId?: string(name='JobId', description='任务ID'),
  requestId?: string(name='RequestId', description='请求Id'),
  state?: string(name='State', description='任务状态'),
}

model SubmitAudioProduceJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitAudioProduceJobResponseBody(name='body'),
}

async function submitAudioProduceJobWithOptions(request: SubmitAudioProduceJobRequest, runtime: Util.RuntimeOptions): SubmitAudioProduceJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.editingConfig)) {
    query['EditingConfig'] = request.editingConfig;
  }
  if (!Util.isUnset(request.inputConfig)) {
    query['InputConfig'] = request.inputConfig;
  }
  if (!Util.isUnset(request.outputConfig)) {
    query['OutputConfig'] = request.outputConfig;
  }
  if (!Util.isUnset(request.overwrite)) {
    query['Overwrite'] = request.overwrite;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitAudioProduceJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitAudioProduceJob(request: SubmitAudioProduceJobRequest): SubmitAudioProduceJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAudioProduceJobWithOptions(request, runtime);
}

model SubmitBatchMediaProducingJobRequest {
  clientToken?: string(name='ClientToken', description='调用方保证请求幂等性Client Token'),
  clipsParam?: string(name='ClipsParam', description='批量混剪ClipsParam'),
  editingProduceConfig?: string(name='EditingProduceConfig', description='剪辑合成配置'),
  jobTitle?: string(name='JobTitle', description='任务名称'),
  outputMediaConfig?: string(name='OutputMediaConfig', description='用户合成输出配置'),
  outputMediaTarget?: string(name='OutputMediaTarget', description='用户合成输出目标'),
  outputNum?: int32(name='OutputNum', description='批量混剪下合成成片的个数'),
  projectMetadata?: string(name='ProjectMetadata', description='剪辑任务工程信息'),
  source?: string(name='Source', description='任务来源'),
  submitBy?: string(name='SubmitBy', description='提交任务类型'),
  templateId?: string(name='TemplateId', description='批量混剪模版id'),
  userData?: string(name='UserData', description='用户配置UserData'),
}

model SubmitBatchMediaProducingJobResponseBody = {
  jobId?: string(name='JobId', description='批量混剪任务jobId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SubmitBatchMediaProducingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitBatchMediaProducingJobResponseBody(name='body'),
}

async function submitBatchMediaProducingJobWithOptions(request: SubmitBatchMediaProducingJobRequest, runtime: Util.RuntimeOptions): SubmitBatchMediaProducingJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clipsParam)) {
    query['ClipsParam'] = request.clipsParam;
  }
  if (!Util.isUnset(request.editingProduceConfig)) {
    query['EditingProduceConfig'] = request.editingProduceConfig;
  }
  if (!Util.isUnset(request.jobTitle)) {
    query['JobTitle'] = request.jobTitle;
  }
  if (!Util.isUnset(request.outputMediaConfig)) {
    query['OutputMediaConfig'] = request.outputMediaConfig;
  }
  if (!Util.isUnset(request.outputMediaTarget)) {
    query['OutputMediaTarget'] = request.outputMediaTarget;
  }
  if (!Util.isUnset(request.outputNum)) {
    query['OutputNum'] = request.outputNum;
  }
  if (!Util.isUnset(request.projectMetadata)) {
    query['ProjectMetadata'] = request.projectMetadata;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.submitBy)) {
    query['SubmitBy'] = request.submitBy;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitBatchMediaProducingJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitBatchMediaProducingJob(request: SubmitBatchMediaProducingJobRequest): SubmitBatchMediaProducingJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitBatchMediaProducingJobWithOptions(request, runtime);
}

model SubmitDynamicChartJobRequest {
  axisParams?: string(name='AxisParams', description='坐标样式。XAxisFontInterval不传或为0则算法自动计算间距'),
  background?: string(name='Background', description='图表背景'),
  chartConfig?: string(name='ChartConfig', description='图表配置'),
  chartTitle?: string(name='ChartTitle', description='主标题'),
  chartType?: string(name='ChartType', description='图表类型'),
  dataSource?: string(name='DataSource', description='数据来源'),
  description?: string(name='Description', description='任务描述'),
  input?: string(name='Input', description='图表输入数据'),
  outputConfig?: string(name='OutputConfig', description='输出设置'),
  subtitle?: string(name='Subtitle', description='副标题'),
  title?: string(name='Title', description='任务标题'),
  unit?: string(name='Unit', description='单位'),
  userData?: string(name='UserData', description='自定义数据，JSON格式'),
}

model SubmitDynamicChartJobResponseBody = {
  jobId?: string(name='JobId', description='任务Id'),
  requestId?: string(name='RequestId', description='请求Id'),
}

model SubmitDynamicChartJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitDynamicChartJobResponseBody(name='body'),
}

async function submitDynamicChartJobWithOptions(request: SubmitDynamicChartJobRequest, runtime: Util.RuntimeOptions): SubmitDynamicChartJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.axisParams)) {
    query['AxisParams'] = request.axisParams;
  }
  if (!Util.isUnset(request.background)) {
    query['Background'] = request.background;
  }
  if (!Util.isUnset(request.chartConfig)) {
    query['ChartConfig'] = request.chartConfig;
  }
  if (!Util.isUnset(request.chartTitle)) {
    query['ChartTitle'] = request.chartTitle;
  }
  if (!Util.isUnset(request.chartType)) {
    query['ChartType'] = request.chartType;
  }
  if (!Util.isUnset(request.dataSource)) {
    query['DataSource'] = request.dataSource;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.input)) {
    query['Input'] = request.input;
  }
  if (!Util.isUnset(request.outputConfig)) {
    query['OutputConfig'] = request.outputConfig;
  }
  if (!Util.isUnset(request.subtitle)) {
    query['Subtitle'] = request.subtitle;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.unit)) {
    query['Unit'] = request.unit;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitDynamicChartJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitDynamicChartJob(request: SubmitDynamicChartJobRequest): SubmitDynamicChartJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitDynamicChartJobWithOptions(request, runtime);
}

model SubmitDynamicImageJobRequest {
  input?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Input'),
  name?: string(name='Name'),
  output?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Output'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId'),
    priority?: int32(name='Priority'),
  }(name='ScheduleConfig'),
  templateConfig?: {
    overwriteParams?: {
      format?: string(name='Format'),
      fps?: int32(name='Fps'),
      height?: int32(name='Height'),
      longShortMode?: boolean(name='LongShortMode'),
      scanMode?: string(name='ScanMode'),
      timeSpan?: {
        duration?: string(name='Duration'),
        end?: string(name='End'),
        seek?: string(name='Seek'),
      }(name='TimeSpan', description='时间线参数'),
      width?: int32(name='Width'),
    }(name='OverwriteParams'),
    templateId?: string(name='TemplateId'),
  }(name='TemplateConfig'),
  userData?: string(name='UserData'),
}

model SubmitDynamicImageJobShrinkRequest {
  inputShrink?: string(name='Input'),
  name?: string(name='Name'),
  outputShrink?: string(name='Output'),
  scheduleConfigShrink?: string(name='ScheduleConfig'),
  templateConfigShrink?: string(name='TemplateConfig'),
  userData?: string(name='UserData'),
}

model SubmitDynamicImageJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model SubmitDynamicImageJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitDynamicImageJobResponseBody(name='body'),
}

async function submitDynamicImageJobWithOptions(tmpReq: SubmitDynamicImageJobRequest, runtime: Util.RuntimeOptions): SubmitDynamicImageJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitDynamicImageJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.input)) {
    request.inputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.input, 'Input', 'json');
  }
  if (!Util.isUnset(tmpReq.output)) {
    request.outputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.output, 'Output', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleConfig)) {
    request.scheduleConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleConfig, 'ScheduleConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.templateConfig)) {
    request.templateConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.templateConfig, 'TemplateConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.inputShrink)) {
    query['Input'] = request.inputShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.outputShrink)) {
    query['Output'] = request.outputShrink;
  }
  if (!Util.isUnset(request.scheduleConfigShrink)) {
    query['ScheduleConfig'] = request.scheduleConfigShrink;
  }
  if (!Util.isUnset(request.templateConfigShrink)) {
    query['TemplateConfig'] = request.templateConfigShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitDynamicImageJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitDynamicImageJob(request: SubmitDynamicImageJobRequest): SubmitDynamicImageJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitDynamicImageJobWithOptions(request, runtime);
}

model SubmitIProductionJobRequest {
  functionName?: string(name='FunctionName'),
  input?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Input'),
  jobParams?: string(name='JobParams'),
  name?: string(name='Name'),
  output?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Output'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId'),
    priority?: int32(name='Priority'),
  }(name='ScheduleConfig'),
  templateId?: string(name='TemplateId'),
  userData?: string(name='UserData'),
}

model SubmitIProductionJobShrinkRequest {
  functionName?: string(name='FunctionName'),
  inputShrink?: string(name='Input'),
  jobParams?: string(name='JobParams'),
  name?: string(name='Name'),
  outputShrink?: string(name='Output'),
  scheduleConfigShrink?: string(name='ScheduleConfig'),
  templateId?: string(name='TemplateId'),
  userData?: string(name='UserData'),
}

model SubmitIProductionJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SubmitIProductionJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitIProductionJobResponseBody(name='body'),
}

async function submitIProductionJobWithOptions(tmpReq: SubmitIProductionJobRequest, runtime: Util.RuntimeOptions): SubmitIProductionJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitIProductionJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.input)) {
    request.inputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.input, 'Input', 'json');
  }
  if (!Util.isUnset(tmpReq.output)) {
    request.outputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.output, 'Output', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleConfig)) {
    request.scheduleConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleConfig, 'ScheduleConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }
  if (!Util.isUnset(request.inputShrink)) {
    query['Input'] = request.inputShrink;
  }
  if (!Util.isUnset(request.jobParams)) {
    query['JobParams'] = request.jobParams;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.outputShrink)) {
    query['Output'] = request.outputShrink;
  }
  if (!Util.isUnset(request.scheduleConfigShrink)) {
    query['ScheduleConfig'] = request.scheduleConfigShrink;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitIProductionJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitIProductionJob(request: SubmitIProductionJobRequest): SubmitIProductionJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitIProductionJobWithOptions(request, runtime);
}

model SubmitLiveEditingJobRequest {
  clips?: string(name='Clips'),
  liveStreamConfig?: string(name='LiveStreamConfig'),
  mediaProduceConfig?: string(name='MediaProduceConfig'),
  outputMediaConfig?: string(name='OutputMediaConfig'),
  outputMediaTarget?: string(name='OutputMediaTarget'),
  projectId?: string(name='ProjectId'),
  userData?: string(name='UserData'),
}

model SubmitLiveEditingJobResponseBody = {
  jobId?: string(name='JobId'),
  mediaId?: string(name='MediaId'),
  mediaURL?: string(name='MediaURL'),
  projectId?: string(name='ProjectId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SubmitLiveEditingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitLiveEditingJobResponseBody(name='body'),
}

async function submitLiveEditingJobWithOptions(request: SubmitLiveEditingJobRequest, runtime: Util.RuntimeOptions): SubmitLiveEditingJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clips)) {
    query['Clips'] = request.clips;
  }
  if (!Util.isUnset(request.liveStreamConfig)) {
    query['LiveStreamConfig'] = request.liveStreamConfig;
  }
  if (!Util.isUnset(request.mediaProduceConfig)) {
    query['MediaProduceConfig'] = request.mediaProduceConfig;
  }
  if (!Util.isUnset(request.outputMediaConfig)) {
    query['OutputMediaConfig'] = request.outputMediaConfig;
  }
  if (!Util.isUnset(request.outputMediaTarget)) {
    query['OutputMediaTarget'] = request.outputMediaTarget;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitLiveEditingJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitLiveEditingJob(request: SubmitLiveEditingJobRequest): SubmitLiveEditingJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitLiveEditingJobWithOptions(request, runtime);
}

model SubmitMediaCensorJobRequest {
  barrages?: string(name='Barrages'),
  coverImages?: string(name='CoverImages'),
  description?: string(name='Description'),
  input?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Input'),
  notifyUrl?: string(name='NotifyUrl'),
  output?: string(name='Output'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId'),
    priority?: int32(name='Priority'),
  }(name='ScheduleConfig'),
  templateId?: string(name='TemplateId'),
  title?: string(name='Title'),
  userData?: string(name='UserData'),
}

model SubmitMediaCensorJobShrinkRequest {
  barrages?: string(name='Barrages'),
  coverImages?: string(name='CoverImages'),
  description?: string(name='Description'),
  inputShrink?: string(name='Input'),
  notifyUrl?: string(name='NotifyUrl'),
  output?: string(name='Output'),
  scheduleConfigShrink?: string(name='ScheduleConfig'),
  templateId?: string(name='TemplateId'),
  title?: string(name='Title'),
  userData?: string(name='UserData'),
}

model SubmitMediaCensorJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitMediaCensorJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitMediaCensorJobResponseBody(name='body'),
}

async function submitMediaCensorJobWithOptions(tmpReq: SubmitMediaCensorJobRequest, runtime: Util.RuntimeOptions): SubmitMediaCensorJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitMediaCensorJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.input)) {
    request.inputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.input, 'Input', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleConfig)) {
    request.scheduleConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleConfig, 'ScheduleConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.barrages)) {
    query['Barrages'] = request.barrages;
  }
  if (!Util.isUnset(request.coverImages)) {
    query['CoverImages'] = request.coverImages;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.inputShrink)) {
    query['Input'] = request.inputShrink;
  }
  if (!Util.isUnset(request.notifyUrl)) {
    query['NotifyUrl'] = request.notifyUrl;
  }
  if (!Util.isUnset(request.output)) {
    query['Output'] = request.output;
  }
  if (!Util.isUnset(request.scheduleConfigShrink)) {
    query['ScheduleConfig'] = request.scheduleConfigShrink;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitMediaCensorJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitMediaCensorJob(request: SubmitMediaCensorJobRequest): SubmitMediaCensorJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMediaCensorJobWithOptions(request, runtime);
}

model SubmitMediaInfoJobRequest {
  input?: {
    media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
    type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
  }(name='Input', description='任务输入'),
  name?: string(name='Name', description='任务名字'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId', description='管道 id'),
    priority?: int32(name='Priority', description='任务优先级，取值范围：1~10'),
  }(name='ScheduleConfig', description='调度参数'),
  userData?: string(name='UserData', description='用户数据'),
}

model SubmitMediaInfoJobShrinkRequest {
  inputShrink?: string(name='Input', description='任务输入'),
  name?: string(name='Name', description='任务名字'),
  scheduleConfigShrink?: string(name='ScheduleConfig', description='调度参数'),
  userData?: string(name='UserData', description='用户数据'),
}

model SubmitMediaInfoJobResponseBody = {
  mediaInfoJob?: {
    async?: boolean(name='Async', description='是否异步处理'),
    finishTime?: string(name='FinishTime', description='任务完成时间'),
    input?: {
      media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
      type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
    }(name='Input', description='任务输入'),
    jobId?: string(name='JobId', description='任务 id'),
    mediaInfoProperty?: {
      audioStreamInfoList?: [ 
        {
          bitrate?: string(name='Bitrate', description='码率'),
          channelLayout?: string(name='ChannelLayout', description='声道布局'),
          channels?: string(name='Channels', description='声道数'),
          codecLongName?: string(name='CodecLongName', description='编码格式名'),
          codecName?: string(name='CodecName', description='编码格式'),
          codecTag?: string(name='CodecTag', description='编码器标签'),
          codecTagString?: string(name='CodecTagString', description='编码器标签名'),
          codecTimeBase?: string(name='CodecTimeBase', description='编码器时间基'),
          duration?: string(name='Duration', description='时长'),
          index?: string(name='Index', description='流序号'),
          lang?: string(name='Lang', description='语言'),
          sampleFmt?: string(name='SampleFmt'),
          sampleRate?: string(name='SampleRate', description='采样率'),
          startTime?: string(name='StartTime', description='开始时间'),
          timebase?: string(name='Timebase', description='时间基'),
        }
      ](name='AudioStreamInfoList', description='音频流信息'),
      fileBasicInfo?: {
        bitrate?: string(name='Bitrate', description='视频码率'),
        duration?: string(name='Duration', description='视频时长'),
        fileName?: string(name='FileName', description='文件名'),
        fileSize?: string(name='FileSize', description='文件大小'),
        fileStatus?: string(name='FileStatus', description='文件状态'),
        fileType?: string(name='FileType', description='文件类型'),
        fileUrl?: string(name='FileUrl', description='文件url'),
        formatName?: string(name='FormatName', description='视频格式名称'),
        height?: string(name='Height', description='高'),
        mediaId?: string(name='MediaId', description='媒资ID'),
        region?: string(name='Region', description='文件所在区域'),
        width?: string(name='Width', description='宽'),
      }(name='FileBasicInfo', description='基础文件信息'),
      videoStreamInfoList?: [ 
        {
          avgFps?: string(name='Avg_fps'),
          bitRate?: string(name='Bit_rate'),
          codecLongName?: string(name='Codec_long_name', description='编码格式名'),
          codecName?: string(name='Codec_name', description='编码格式'),
          codecTag?: string(name='Codec_tag', description='编码格式标记'),
          codecTagString?: string(name='Codec_tag_string', description='编码格式标记文本'),
          codecTimeBase?: string(name='Codec_time_base'),
          dar?: string(name='Dar', description='图像显示宽高比'),
          duration?: string(name='Duration', description='时长'),
          fps?: string(name='Fps', description='帧率'),
          hasBFrames?: string(name='Has_b_frames'),
          height?: string(name='Height', description='高'),
          index?: string(name='Index', description='流序号'),
          lang?: string(name='Lang', description='语言'),
          level?: string(name='Level', description='编码等级'),
          numFrames?: string(name='NumFrames', description='总帧数'),
          pixFmt?: string(name='PixFmt', description='颜色存储格式'),
          profile?: string(name='Profile', description='编码器预设'),
          rotate?: string(name='Rotate', description='视频画面旋转角度'),
          sar?: string(name='Sar', description='采集点数宽高比'),
          startTime?: string(name='Start_time', description='起始时间'),
          timeBase?: string(name='Time_base'),
          width?: string(name='Width', description='宽'),
        }
      ](name='VideoStreamInfoList', description='视频流信息'),
    }(name='MediaInfoProperty', description='媒体信息详情'),
    name?: string(name='Name', description='任务名字'),
    requestId?: string(name='RequestId', description='请求 id'),
    scheduleConfig?: {
      pipelineId?: string(name='PipelineId', description='管道 id'),
      priority?: int32(name='Priority', description='任务优先级，取值范围：1~10'),
    }(name='ScheduleConfig', description='调度信息'),
    status?: string(name='Status', description='任务状态 - Init: 已提交, Success: 成功, Fail: 失败'),
    submitResultJson?: map[string]any(name='SubmitResultJson', description='任务提交信息'),
    submitTime?: string(name='SubmitTime', description='任务提交时间'),
    triggerSource?: string(name='TriggerSource', description='任务来源 - API, WorkFlow, Console'),
    userData?: string(name='UserData', description='用户数据'),
  }(name='MediaInfoJob', description='MediaInfoJobDTO'),
  requestId?: string(name='RequestId', description='请求 id'),
}

model SubmitMediaInfoJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitMediaInfoJobResponseBody(name='body'),
}

async function submitMediaInfoJobWithOptions(tmpReq: SubmitMediaInfoJobRequest, runtime: Util.RuntimeOptions): SubmitMediaInfoJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitMediaInfoJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.input)) {
    request.inputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.input, 'Input', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleConfig)) {
    request.scheduleConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleConfig, 'ScheduleConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.inputShrink)) {
    query['Input'] = request.inputShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.scheduleConfigShrink)) {
    query['ScheduleConfig'] = request.scheduleConfigShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitMediaInfoJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitMediaInfoJob(request: SubmitMediaInfoJobRequest): SubmitMediaInfoJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMediaInfoJobWithOptions(request, runtime);
}

model SubmitMediaProducingJobRequest {
  clientToken?: string(name='ClientToken'),
  clipsParam?: string(name='ClipsParam'),
  editingProduceConfig?: string(name='EditingProduceConfig'),
  outputMediaConfig?: string(name='OutputMediaConfig'),
  outputMediaTarget?: string(name='OutputMediaTarget'),
  projectId?: string(name='ProjectId'),
  projectMetadata?: string(name='ProjectMetadata'),
  source?: string(name='Source'),
  templateId?: string(name='TemplateId'),
  timeline?: string(name='Timeline'),
  userData?: string(name='UserData'),
}

model SubmitMediaProducingJobResponseBody = {
  jobId?: string(name='JobId', description='合成作业Id'),
  mediaId?: string(name='MediaId', description='合成ICE媒资Id'),
  projectId?: string(name='ProjectId', description='剪辑工程Id'),
  requestId?: string(name='RequestId', description='Id of the request'),
  vodMediaId?: string(name='VodMediaId', description='vod媒资id'),
}

model SubmitMediaProducingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitMediaProducingJobResponseBody(name='body'),
}

async function submitMediaProducingJobWithOptions(request: SubmitMediaProducingJobRequest, runtime: Util.RuntimeOptions): SubmitMediaProducingJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clipsParam)) {
    query['ClipsParam'] = request.clipsParam;
  }
  if (!Util.isUnset(request.editingProduceConfig)) {
    query['EditingProduceConfig'] = request.editingProduceConfig;
  }
  if (!Util.isUnset(request.outputMediaConfig)) {
    query['OutputMediaConfig'] = request.outputMediaConfig;
  }
  if (!Util.isUnset(request.outputMediaTarget)) {
    query['OutputMediaTarget'] = request.outputMediaTarget;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectMetadata)) {
    query['ProjectMetadata'] = request.projectMetadata;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.timeline)) {
    query['Timeline'] = request.timeline;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitMediaProducingJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitMediaProducingJob(request: SubmitMediaProducingJobRequest): SubmitMediaProducingJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMediaProducingJobWithOptions(request, runtime);
}

model SubmitSnapshotJobRequest {
  input?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Input'),
  name?: string(name='Name'),
  output?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Output'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId'),
  }(name='ScheduleConfig'),
  templateConfig?: {
    overwriteParams?: {
      blackLevel?: int32(name='BlackLevel'),
      count?: long(name='Count'),
      frameType?: string(name='FrameType', description='截图公共参数'),
      height?: int32(name='Height'),
      interval?: long(name='Interval'),
      isSptFrag?: boolean(name='IsSptFrag', description='Webvtt截图配置:是否拼合输出'),
      pixelBlackThreshold?: int32(name='PixelBlackThreshold'),
      spriteSnapshotConfig?: {
        cellHeight?: int32(name='CellHeight'),
        cellWidth?: int32(name='CellWidth'),
        color?: string(name='Color'),
        columns?: int32(name='Columns'),
        lines?: int32(name='Lines'),
        margin?: int32(name='Margin'),
        padding?: int32(name='Padding'),
      }(name='SpriteSnapshotConfig', description='雪碧图配置'),
      time?: long(name='Time'),
      type?: string(name='Type'),
      width?: int32(name='Width'),
    }(name='OverwriteParams'),
    templateId?: string(name='TemplateId'),
  }(name='TemplateConfig'),
  userData?: string(name='UserData'),
}

model SubmitSnapshotJobShrinkRequest {
  inputShrink?: string(name='Input'),
  name?: string(name='Name'),
  outputShrink?: string(name='Output'),
  scheduleConfigShrink?: string(name='ScheduleConfig'),
  templateConfigShrink?: string(name='TemplateConfig'),
  userData?: string(name='UserData'),
}

model SubmitSnapshotJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model SubmitSnapshotJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitSnapshotJobResponseBody(name='body'),
}

async function submitSnapshotJobWithOptions(tmpReq: SubmitSnapshotJobRequest, runtime: Util.RuntimeOptions): SubmitSnapshotJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitSnapshotJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.input)) {
    request.inputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.input, 'Input', 'json');
  }
  if (!Util.isUnset(tmpReq.output)) {
    request.outputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.output, 'Output', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleConfig)) {
    request.scheduleConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleConfig, 'ScheduleConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.templateConfig)) {
    request.templateConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.templateConfig, 'TemplateConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.inputShrink)) {
    query['Input'] = request.inputShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.outputShrink)) {
    query['Output'] = request.outputShrink;
  }
  if (!Util.isUnset(request.scheduleConfigShrink)) {
    query['ScheduleConfig'] = request.scheduleConfigShrink;
  }
  if (!Util.isUnset(request.templateConfigShrink)) {
    query['TemplateConfig'] = request.templateConfigShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitSnapshotJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitSnapshotJob(request: SubmitSnapshotJobRequest): SubmitSnapshotJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSnapshotJobWithOptions(request, runtime);
}

model SubmitSubtitleProduceJobRequest {
  description?: string(name='Description'),
  editingConfig?: string(name='EditingConfig'),
  inputConfig?: string(name='InputConfig'),
  isAsync?: long(name='IsAsync'),
  outputConfig?: string(name='OutputConfig'),
  title?: string(name='Title'),
  type?: string(name='Type'),
  userData?: string(name='UserData'),
}

model SubmitSubtitleProduceJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SubmitSubtitleProduceJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitSubtitleProduceJobResponseBody(name='body'),
}

async function submitSubtitleProduceJobWithOptions(request: SubmitSubtitleProduceJobRequest, runtime: Util.RuntimeOptions): SubmitSubtitleProduceJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.editingConfig)) {
    query['EditingConfig'] = request.editingConfig;
  }
  if (!Util.isUnset(request.inputConfig)) {
    query['InputConfig'] = request.inputConfig;
  }
  if (!Util.isUnset(request.isAsync)) {
    query['IsAsync'] = request.isAsync;
  }
  if (!Util.isUnset(request.outputConfig)) {
    query['OutputConfig'] = request.outputConfig;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitSubtitleProduceJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitSubtitleProduceJob(request: SubmitSubtitleProduceJobRequest): SubmitSubtitleProduceJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSubtitleProduceJobWithOptions(request, runtime);
}

model SubmitSyncMediaInfoJobRequest {
  input?: {
    media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
    type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
  }(name='Input', description='任务输入'),
  name?: string(name='Name', description='任务名字'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId', description='管道 id'),
    priority?: int32(name='Priority', description='任务优先级，取值范围：1~10'),
  }(name='ScheduleConfig', description='调度参数'),
  userData?: string(name='UserData', description='用户数据'),
}

model SubmitSyncMediaInfoJobShrinkRequest {
  inputShrink?: string(name='Input', description='任务输入'),
  name?: string(name='Name', description='任务名字'),
  scheduleConfigShrink?: string(name='ScheduleConfig', description='调度参数'),
  userData?: string(name='UserData', description='用户数据'),
}

model SubmitSyncMediaInfoJobResponseBody = {
  mediaInfoJob?: {
    async?: boolean(name='Async', description='是否异步处理'),
    finishTime?: string(name='FinishTime', description='任务完成时间'),
    input?: {
      media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
      type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
    }(name='Input', description='任务输入'),
    jobId?: string(name='JobId', description='任务 id'),
    mediaInfoProperty?: {
      audioStreamInfoList?: [ 
        {
          bitrate?: string(name='Bitrate', description='码率'),
          channelLayout?: string(name='ChannelLayout', description='声道布局'),
          channels?: string(name='Channels', description='声道数'),
          codecLongName?: string(name='CodecLongName', description='编码格式名'),
          codecName?: string(name='CodecName', description='编码格式'),
          codecTag?: string(name='CodecTag', description='编码器标签'),
          codecTagString?: string(name='CodecTagString', description='编码器标签名'),
          codecTimeBase?: string(name='CodecTimeBase', description='编码器时间基'),
          duration?: string(name='Duration', description='时长'),
          index?: string(name='Index', description='流序号'),
          lang?: string(name='Lang', description='语言'),
          sampleFmt?: string(name='SampleFmt'),
          sampleRate?: string(name='SampleRate', description='采样率'),
          startTime?: string(name='StartTime', description='开始时间'),
          timebase?: string(name='Timebase', description='时间基'),
        }
      ](name='AudioStreamInfoList', description='音频流信息'),
      fileBasicInfo?: {
        bitrate?: string(name='Bitrate', description='视频码率'),
        duration?: string(name='Duration', description='视频时长'),
        fileName?: string(name='FileName', description='文件名'),
        fileSize?: string(name='FileSize', description='文件大小'),
        fileStatus?: string(name='FileStatus', description='文件状态'),
        fileType?: string(name='FileType', description='文件类型'),
        fileUrl?: string(name='FileUrl', description='文件url'),
        formatName?: string(name='FormatName', description='视频格式名称'),
        height?: string(name='Height', description='高'),
        mediaId?: string(name='MediaId', description='媒资ID'),
        region?: string(name='Region', description='文件所在区域'),
        width?: string(name='Width', description='宽'),
      }(name='FileBasicInfo', description='基础文件信息'),
      videoStreamInfoList?: [ 
        {
          avgFps?: string(name='Avg_fps'),
          bitRate?: string(name='Bit_rate'),
          codecLongName?: string(name='Codec_long_name', description='编码格式名'),
          codecName?: string(name='Codec_name', description='编码格式'),
          codecTag?: string(name='Codec_tag', description='编码格式标记'),
          codecTagString?: string(name='Codec_tag_string', description='编码格式标记文本'),
          codecTimeBase?: string(name='Codec_time_base'),
          dar?: string(name='Dar', description='图像显示宽高比'),
          duration?: string(name='Duration', description='时长'),
          fps?: string(name='Fps', description='帧率'),
          hasBFrames?: string(name='Has_b_frames'),
          height?: string(name='Height', description='高'),
          index?: string(name='Index', description='流序号'),
          lang?: string(name='Lang', description='语言'),
          level?: string(name='Level', description='编码等级'),
          numFrames?: string(name='NumFrames', description='总帧数'),
          pixFmt?: string(name='PixFmt', description='颜色存储格式'),
          profile?: string(name='Profile', description='编码器预设'),
          rotate?: string(name='Rotate', description='视频画面旋转角度'),
          sar?: string(name='Sar', description='采集点数宽高比'),
          startTime?: string(name='Start_time', description='起始时间'),
          timeBase?: string(name='Time_base'),
          width?: string(name='Width', description='宽'),
        }
      ](name='VideoStreamInfoList', description='视频流信息'),
    }(name='MediaInfoProperty', description='媒体信息详情'),
    name?: string(name='Name', description='任务名字'),
    requestId?: string(name='RequestId', description='请求 id'),
    scheduleConfig?: {
      pipelineId?: string(name='PipelineId', description='管道 id'),
      priority?: int32(name='Priority', description='任务优先级，取值范围：1~10'),
    }(name='ScheduleConfig', description='调度信息'),
    status?: string(name='Status', description='任务状态 - Init: 已提交, Success: 成功, Fail: 失败'),
    submitResultJson?: map[string]any(name='SubmitResultJson', description='任务提交信息'),
    submitTime?: string(name='SubmitTime', description='任务提交时间'),
    triggerSource?: string(name='TriggerSource', description='任务来源 - API, WorkFlow, Console'),
    userData?: string(name='UserData', description='用户数据'),
  }(name='MediaInfoJob', description='MediaInfoJobDTO'),
  requestId?: string(name='RequestId', description='请求 id'),
}

model SubmitSyncMediaInfoJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitSyncMediaInfoJobResponseBody(name='body'),
}

async function submitSyncMediaInfoJobWithOptions(tmpReq: SubmitSyncMediaInfoJobRequest, runtime: Util.RuntimeOptions): SubmitSyncMediaInfoJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitSyncMediaInfoJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.input)) {
    request.inputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.input, 'Input', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleConfig)) {
    request.scheduleConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleConfig, 'ScheduleConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.inputShrink)) {
    query['Input'] = request.inputShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.scheduleConfigShrink)) {
    query['ScheduleConfig'] = request.scheduleConfigShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitSyncMediaInfoJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitSyncMediaInfoJob(request: SubmitSyncMediaInfoJobRequest): SubmitSyncMediaInfoJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSyncMediaInfoJobWithOptions(request, runtime);
}

model SubmitTranscodeJobRequest {
  inputGroup?: [ 
    {
      media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
      type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
    }
  ](name='InputGroup', description='任务输入组 (目前只支持一个)'),
  name?: string(name='Name', description='任务名字'),
  outputGroup?: [ 
    {
      output?: {
        media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
        type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
      }(name='Output', description='输出媒体配置'),
      processConfig?: {
        imageWatermarks?: [ 
          {
            overwriteParams?: {
              dx?: string(name='Dx', description='水印位置，x'),
              dy?: string(name='Dy', description='水印位置，y'),
              file?: {
                media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
                type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
              }(name='File', description='水印文件oss路径'),
              height?: string(name='Height', description='高'),
              referPos?: string(name='ReferPos', description='参考位置: TopLeft, TopRight, BottomLeft, BottomRight  default: TopLeft'),
              timeline?: {
                duration?: string(name='Duration', description='显示时长，秒数 或者 "ToEND"'),
                start?: string(name='Start', description='开始时间'),
              }(name='Timeline', description='显示时间设置'),
              width?: string(name='Width', description='宽'),
            }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
            templateId?: string(name='TemplateId', description='模板 id'),
          }
        ](name='ImageWatermarks', description='图片水印配置'),
        subtitles?: [ 
          {
            overwriteParams?: {
              charEnc?: string(name='CharEnc', description='文件 encoding 格式'),
              file?: {
                media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
                type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
              }(name='File', description='字幕文件'),
              format?: string(name='Format', description='字幕文件格式'),
            }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
            templateId?: string(name='TemplateId', description='模板 id'),
          }
        ](name='Subtitles', description='字幕压制配置'),
        textWatermarks?: [ 
          {
            overwriteParams?: {
              adaptive?: string(name='Adaptive', description='根据输出视频大小调整字体 size。 true / false, default: false'),
              borderColor?: string(name='BorderColor', description='边框颜色'),
              borderWidth?: int32(name='BorderWidth', description='边框宽度'),
              content?: string(name='Content', description='水印文本，不需要 base64 encode，字符串需要 utf-8 编码'),
              fontAlpha?: string(name='FontAlpha', description='透明度'),
              fontColor?: string(name='FontColor', description='颜色'),
              fontName?: string(name='FontName', description='字体'),
              fontSize?: int32(name='FontSize', description='字体大小'),
              left?: string(name='Left', description='水印位置，距离左边距离'),
              top?: string(name='Top', description='水印位置，距离上边距离'),
            }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
            templateId?: string(name='TemplateId', description='模板 id'),
          }
        ](name='TextWatermarks', description='文字水印配置'),
        transcode?: {
          overwriteParams?: {
            audio?: {
              bitrate?: string(name='Bitrate', description='输出文件的音频码率。'),
              channels?: string(name='Channels', description='声道数。'),
              codec?: string(name='Codec', description='音频编解码格式，AAC、MP3、VORBIS、FLAC。'),
              profile?: string(name='Profile', description='音频编码预置。'),
              remove?: string(name='Remove', description='是否删除音频流。'),
              samplerate?: string(name='Samplerate', description='采样率。'),
              volume?: {
                integratedLoudnessTarget?: string(name='IntegratedLoudnessTarget', description='目标音量'),
                loudnessRangeTarget?: string(name='LoudnessRangeTarget', description='音量范围'),
                method?: string(name='Method', description='音量调整方式'),
                truePeak?: string(name='TruePeak', description='最大峰值'),
              }(name='Volume', description='音量控制'),
            }(name='Audio', description='audio 设置'),
            container?: {
              format?: string(name='Format', description='容器格式'),
            }(name='Container', description='封装格式设置'),
            muxConfig?: {
              segment?: {
                duration?: string(name='Duration', description='切片时长'),
                forceSegTime?: string(name='ForceSegTime', description='强制切片时间点'),
              }(name='Segment', description='切片设置'),
            }(name='MuxConfig', description='封装设置'),
            video?: {
              abrMax?: string(name='AbrMax'),
              bitrate?: string(name='Bitrate', description='视频平均码率。'),
              bufsize?: string(name='Bufsize', description='缓冲区大小'),
              codec?: string(name='Codec', description='编码格式'),
              crf?: string(name='Crf', description='码率-质量控制因子。'),
              crop?: string(name='Crop', description='视频画面裁切'),
              fps?: string(name='Fps', description='帧率。'),
              gop?: string(name='Gop', description='关键帧间最大帧数。'),
              height?: string(name='Height', description='高。'),
              longShortMode?: string(name='LongShortMode', description='是否开启横竖屏自适应（即：长短边模式）'),
              maxrate?: string(name='Maxrate', description='视频码率峰值'),
              pad?: string(name='Pad', description='视频贴黑边'),
              pixFmt?: string(name='PixFmt', description='视频颜色格式。'),
              preset?: string(name='Preset', description='只有H264支持该参数'),
              profile?: string(name='Profile', description='编码级别。'),
              remove?: string(name='Remove', description='是否去掉视频'),
              scanMode?: string(name='ScanMode', description='扫描模式。'),
              width?: string(name='Width', description='宽。'),
            }(name='Video', description='video 设置'),
          }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
          templateId?: string(name='TemplateId', description='模板 id'),
        }(name='Transcode', description='转码配置'),
      }(name='ProcessConfig', description='任务处理配置'),
    }
  ](name='OutputGroup', description='任务输出组'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId', description='管道 id'),
    priority?: int32(name='Priority', description='任务优先级，取值范围：1~10'),
  }(name='ScheduleConfig', description='任务调度信息'),
  userData?: string(name='UserData', description='用户数据'),
}

model SubmitTranscodeJobShrinkRequest {
  inputGroupShrink?: string(name='InputGroup', description='任务输入组 (目前只支持一个)'),
  name?: string(name='Name', description='任务名字'),
  outputGroupShrink?: string(name='OutputGroup', description='任务输出组'),
  scheduleConfigShrink?: string(name='ScheduleConfig', description='任务调度信息'),
  userData?: string(name='UserData', description='用户数据'),
}

model SubmitTranscodeJobResponseBody = {
  requestId?: string(name='RequestId', description='请求 id'),
  transcodeParentJob?: {
    createTime?: string(name='CreateTime', description='任务创建时间'),
    finishTime?: string(name='FinishTime', description='任务结束时间'),
    inputGroup?: [ 
      {
        media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
        type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
      }
    ](name='InputGroup', description='任务输入组 (目前只支持单个输入)'),
    jobCount?: int32(name='JobCount', description='子任务数量'),
    name?: string(name='Name', description='任务名'),
    outputGroup?: [ 
      {
        output?: {
          media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
          type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
        }(name='Output', description='输出媒体配置'),
        processConfig?: {
          imageWatermarks?: [ 
            {
              overwriteParams?: {
                dx?: string(name='Dx', description='水印位置，x'),
                dy?: string(name='Dy', description='水印位置，y'),
                file?: {
                  media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
                  type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
                }(name='File', description='水印文件oss路径'),
                height?: string(name='Height', description='高'),
                referPos?: string(name='ReferPos', description='参考位置: TopLeft, TopRight, BottomLeft, BottomRight  default: TopLeft'),
                timeline?: {
                  duration?: string(name='Duration', description='显示时长，秒数 或者 "ToEND"'),
                  start?: string(name='Start', description='开始时间'),
                }(name='Timeline', description='显示时间设置'),
                width?: string(name='Width', description='宽'),
              }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
              templateId?: string(name='TemplateId', description='模板 id'),
            }
          ](name='ImageWatermarks', description='图片水印配置'),
          subtitles?: [ 
            {
              overwriteParams?: {
                charEnc?: string(name='CharEnc', description='文件 encoding 格式'),
                file?: {
                  media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
                  type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
                }(name='File', description='字幕文件'),
                format?: string(name='Format', description='字幕文件格式'),
              }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
              templateId?: string(name='TemplateId', description='模板 id'),
            }
          ](name='Subtitles', description='字幕压制配置'),
          textWatermarks?: [ 
            {
              overwriteParams?: {
                adaptive?: string(name='Adaptive', description='根据输出视频大小调整字体 size。 true / false, default: false'),
                borderColor?: string(name='BorderColor', description='边框颜色'),
                borderWidth?: int32(name='BorderWidth', description='边框宽度'),
                content?: string(name='Content', description='水印文本，不需要 base64 encode，字符串需要 utf-8 编码'),
                fontAlpha?: string(name='FontAlpha', description='透明度'),
                fontColor?: string(name='FontColor', description='颜色'),
                fontName?: string(name='FontName', description='字体'),
                fontSize?: int32(name='FontSize', description='字体大小'),
                left?: string(name='Left', description='水印位置，距离左边距离'),
                top?: string(name='Top', description='水印位置，距离上边距离'),
              }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
              templateId?: string(name='TemplateId', description='模板 id'),
            }
          ](name='TextWatermarks', description='文字水印配置'),
          transcode?: {
            overwriteParams?: {
              audio?: {
                bitrate?: string(name='Bitrate', description='输出文件的音频码率。'),
                channels?: string(name='Channels', description='声道数。'),
                codec?: string(name='Codec', description='音频编解码格式，AAC、MP3、VORBIS、FLAC。'),
                profile?: string(name='Profile', description='音频编码预置。'),
                remove?: string(name='Remove', description='是否删除音频流。'),
                samplerate?: string(name='Samplerate', description='采样率。'),
                volume?: {
                  integratedLoudnessTarget?: string(name='IntegratedLoudnessTarget', description='目标音量'),
                  loudnessRangeTarget?: string(name='LoudnessRangeTarget', description='音量范围'),
                  method?: string(name='Method', description='音量调整方式'),
                  truePeak?: string(name='TruePeak', description='最大峰值'),
                }(name='Volume', description='音量控制'),
              }(name='Audio', description='audio 设置'),
              container?: {
                format?: string(name='Format', description='容器格式'),
              }(name='Container', description='封装格式设置'),
              muxConfig?: {
                segment?: {
                  duration?: string(name='Duration', description='切片时长'),
                  forceSegTime?: string(name='ForceSegTime', description='强制切片时间点'),
                }(name='Segment', description='切片设置'),
              }(name='MuxConfig', description='封装设置'),
              video?: {
                abrMax?: string(name='AbrMax'),
                bitrate?: string(name='Bitrate', description='视频平均码率。'),
                bufsize?: string(name='Bufsize', description='缓冲区大小'),
                codec?: string(name='Codec', description='编码格式'),
                crf?: string(name='Crf', description='码率-质量控制因子。'),
                crop?: string(name='Crop', description='视频画面裁切'),
                fps?: string(name='Fps', description='帧率。'),
                gop?: string(name='Gop', description='关键帧间最大帧数。'),
                height?: string(name='Height', description='高。'),
                longShortMode?: string(name='LongShortMode', description='是否开启横竖屏自适应（即：长短边模式）'),
                maxrate?: string(name='Maxrate', description='视频码率峰值'),
                pad?: string(name='Pad', description='视频贴黑边'),
                pixFmt?: string(name='PixFmt', description='视频颜色格式。'),
                preset?: string(name='Preset', description='只有H264支持该参数'),
                profile?: string(name='Profile', description='编码级别。'),
                remove?: string(name='Remove', description='是否去掉视频'),
                scanMode?: string(name='ScanMode', description='扫描模式。'),
                width?: string(name='Width', description='宽。'),
              }(name='Video', description='video 设置'),
            }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
            templateId?: string(name='TemplateId', description='模板 id'),
          }(name='Transcode', description='转码配置'),
        }(name='ProcessConfig', description='任务处理配置'),
      }
    ](name='OutputGroup', description='任务输出组'),
    parentJobId?: string(name='ParentJobId', description='主任务 id'),
    percent?: int32(name='Percent', description='任务完成百分比'),
    requestId?: string(name='RequestId', description='提交任务时请求 id'),
    scheduleConfig?: {
      pipelineId?: string(name='PipelineId', description='管道 id'),
      priority?: int32(name='Priority', description='任务优先级，取值范围：1~10'),
    }(name='ScheduleConfig', description='任务调度配置'),
    status?: string(name='Status', description='任务状态 Success: 有子任务成功, Fail: 所有子任务失败'),
    submitTime?: string(name='SubmitTime', description='任务提交时间'),
    transcodeJobList?: [ 
      {
        createTime?: string(name='CreateTime', description='任务创建时间'),
        finishTime?: string(name='FinishTime', description='任务结束时间'),
        inputGroup?: [ 
          {
            media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
            type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
          }
        ](name='InputGroup', description='任务输入组 (目前只支持单个输入)'),
        jobId?: string(name='JobId', description='子任务 id'),
        jobIndex?: int32(name='JobIndex', description='子任务在整个任务中的索引号'),
        name?: string(name='Name', description='任务名'),
        outFileMeta?: {
          audioStreamInfoList?: [ 
            {
              bitrate?: string(name='Bitrate', description='码率'),
              channelLayout?: string(name='ChannelLayout', description='声道布局'),
              channels?: string(name='Channels', description='声道数'),
              codecLongName?: string(name='CodecLongName', description='编码格式名'),
              codecName?: string(name='CodecName', description='编码格式'),
              codecTag?: string(name='CodecTag', description='编码器标签'),
              codecTagString?: string(name='CodecTagString', description='编码器标签名'),
              codecTimeBase?: string(name='CodecTimeBase', description='编码器时间基'),
              duration?: string(name='Duration', description='时长'),
              index?: string(name='Index', description='流序号'),
              lang?: string(name='Lang', description='语言'),
              sampleFmt?: string(name='SampleFmt'),
              sampleRate?: string(name='SampleRate', description='采样率'),
              startTime?: string(name='StartTime', description='开始时间'),
              timebase?: string(name='Timebase', description='时间基'),
            }
          ](name='AudioStreamInfoList', description='音频流信息'),
          fileBasicInfo?: {
            bitrate?: string(name='Bitrate', description='视频码率'),
            duration?: string(name='Duration', description='视频时长'),
            fileName?: string(name='FileName', description='文件名'),
            fileSize?: string(name='FileSize', description='文件大小'),
            fileStatus?: string(name='FileStatus', description='文件状态'),
            fileType?: string(name='FileType', description='文件类型'),
            fileUrl?: string(name='FileUrl', description='文件url'),
            formatName?: string(name='FormatName', description='视频格式名称'),
            height?: string(name='Height', description='高'),
            mediaId?: string(name='MediaId', description='媒资ID'),
            region?: string(name='Region', description='文件所在区域'),
            width?: string(name='Width', description='宽'),
          }(name='FileBasicInfo', description='基础文件信息'),
          videoStreamInfoList?: [ 
            {
              avgFps?: string(name='Avg_fps'),
              bitRate?: string(name='Bit_rate'),
              codecLongName?: string(name='Codec_long_name', description='编码格式名'),
              codecName?: string(name='Codec_name', description='编码格式'),
              codecTag?: string(name='Codec_tag', description='编码格式标记'),
              codecTagString?: string(name='Codec_tag_string', description='编码格式标记文本'),
              codecTimeBase?: string(name='Codec_time_base'),
              dar?: string(name='Dar', description='图像显示宽高比'),
              duration?: string(name='Duration', description='时长'),
              fps?: string(name='Fps', description='帧率'),
              hasBFrames?: string(name='Has_b_frames'),
              height?: string(name='Height', description='高'),
              index?: string(name='Index', description='流序号'),
              lang?: string(name='Lang', description='语言'),
              level?: string(name='Level', description='编码等级'),
              numFrames?: string(name='NumFrames', description='总帧数'),
              pixFmt?: string(name='PixFmt', description='颜色存储格式'),
              profile?: string(name='Profile', description='编码器预设'),
              rotate?: string(name='Rotate', description='视频画面旋转角度'),
              sar?: string(name='Sar', description='采集点数宽高比'),
              startTime?: string(name='Start_time', description='起始时间'),
              timeBase?: string(name='Time_base'),
              width?: string(name='Width', description='宽'),
            }
          ](name='VideoStreamInfoList', description='视频流信息'),
        }(name='OutFileMeta', description='任务生成视频 media 信息'),
        output?: {
          media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
          type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
        }(name='Output', description='输出媒体配置'),
        parentJobId?: string(name='ParentJobId', description='主任务 id'),
        processConfig?: {
          imageWatermarks?: [ 
            {
              overwriteParams?: {
                dx?: string(name='Dx', description='水印位置，x'),
                dy?: string(name='Dy', description='水印位置，y'),
                file?: {
                  media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
                  type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
                }(name='File', description='水印文件oss路径'),
                height?: string(name='Height', description='高'),
                referPos?: string(name='ReferPos', description='参考位置: TopLeft, TopRight, BottomLeft, BottomRight  default: TopLeft'),
                timeline?: {
                  duration?: string(name='Duration', description='显示时长，秒数 或者 "ToEND"'),
                  start?: string(name='Start', description='开始时间'),
                }(name='Timeline', description='显示时间设置'),
                width?: string(name='Width', description='宽'),
              }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
              templateId?: string(name='TemplateId', description='模板 id'),
            }
          ](name='ImageWatermarks', description='图片水印配置'),
          subtitles?: [ 
            {
              overwriteParams?: {
                charEnc?: string(name='CharEnc', description='文件 encoding 格式'),
                file?: {
                  media?: string(name='Media', description='媒体值：
      type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
      type 为 Media 时，为媒资 id。'),
                  type?: string(name='Type', description='媒体对象类型 - OSS: oss文件, Media: 媒资 ID'),
                }(name='File', description='字幕文件'),
                format?: string(name='Format', description='字幕文件格式'),
              }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
              templateId?: string(name='TemplateId', description='模板 id'),
            }
          ](name='Subtitles', description='字幕压制配置'),
          textWatermarks?: [ 
            {
              overwriteParams?: {
                adaptive?: string(name='Adaptive', description='根据输出视频大小调整字体 size。 true / false, default: false'),
                borderColor?: string(name='BorderColor', description='边框颜色'),
                borderWidth?: int32(name='BorderWidth', description='边框宽度'),
                content?: string(name='Content', description='水印文本，不需要 base64 encode，字符串需要 utf-8 编码'),
                fontAlpha?: string(name='FontAlpha', description='透明度'),
                fontColor?: string(name='FontColor', description='颜色'),
                fontName?: string(name='FontName', description='字体'),
                fontSize?: int32(name='FontSize', description='字体大小'),
                left?: string(name='Left', description='水印位置，距离左边距离'),
                top?: string(name='Top', description='水印位置，距离上边距离'),
              }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
              templateId?: string(name='TemplateId', description='模板 id'),
            }
          ](name='TextWatermarks', description='文字水印配置'),
          transcode?: {
            overwriteParams?: {
              audio?: {
                bitrate?: string(name='Bitrate', description='输出文件的音频码率。'),
                channels?: string(name='Channels', description='声道数。'),
                codec?: string(name='Codec', description='音频编解码格式，AAC、MP3、VORBIS、FLAC。'),
                profile?: string(name='Profile', description='音频编码预置。'),
                remove?: string(name='Remove', description='是否删除音频流。'),
                samplerate?: string(name='Samplerate', description='采样率。'),
                volume?: {
                  integratedLoudnessTarget?: string(name='IntegratedLoudnessTarget', description='目标音量'),
                  loudnessRangeTarget?: string(name='LoudnessRangeTarget', description='音量范围'),
                  method?: string(name='Method', description='音量调整方式'),
                  truePeak?: string(name='TruePeak', description='最大峰值'),
                }(name='Volume', description='音量控制'),
              }(name='Audio', description='audio 设置'),
              container?: {
                format?: string(name='Format', description='容器格式'),
              }(name='Container', description='封装格式设置'),
              muxConfig?: {
                segment?: {
                  duration?: string(name='Duration', description='切片时长'),
                  forceSegTime?: string(name='ForceSegTime', description='强制切片时间点'),
                }(name='Segment', description='切片设置'),
              }(name='MuxConfig', description='封装设置'),
              video?: {
                abrMax?: string(name='AbrMax'),
                bitrate?: string(name='Bitrate', description='视频平均码率。'),
                bufsize?: string(name='Bufsize', description='缓冲区大小'),
                codec?: string(name='Codec', description='编码格式'),
                crf?: string(name='Crf', description='码率-质量控制因子。'),
                crop?: string(name='Crop', description='视频画面裁切'),
                fps?: string(name='Fps', description='帧率。'),
                gop?: string(name='Gop', description='关键帧间最大帧数。'),
                height?: string(name='Height', description='高。'),
                longShortMode?: string(name='LongShortMode', description='是否开启横竖屏自适应（即：长短边模式）'),
                maxrate?: string(name='Maxrate', description='视频码率峰值'),
                pad?: string(name='Pad', description='视频贴黑边'),
                pixFmt?: string(name='PixFmt', description='视频颜色格式。'),
                preset?: string(name='Preset', description='只有H264支持该参数'),
                profile?: string(name='Profile', description='编码级别。'),
                remove?: string(name='Remove', description='是否去掉视频'),
                scanMode?: string(name='ScanMode', description='扫描模式。'),
                width?: string(name='Width', description='宽。'),
              }(name='Video', description='video 设置'),
            }(name='OverwriteParams', description='覆盖参数, 若填写会覆盖模板对应参数'),
            templateId?: string(name='TemplateId', description='模板 id'),
          }(name='Transcode', description='转码配置'),
        }(name='ProcessConfig', description='转码处理配置'),
        requestId?: string(name='RequestId', description='请求 id'),
        scheduleConfig?: {
          pipelineId?: string(name='PipelineId', description='管道 id'),
          priority?: int32(name='Priority', description='任务优先级，取值范围：1~10'),
        }(name='ScheduleConfig', description='任务调度信息'),
        status?: string(name='Status', description='转码任务任务状态 - Init: 已提交, Processing: 转码中, Success: 转码成功, Fail: 转码失败, Deleted: 已删除'),
        submitResultJson?: map[string]any(name='SubmitResultJson', description='任务提交结果'),
        submitTime?: string(name='SubmitTime', description='任务提交时间'),
        userData?: string(name='UserData', description='用户数据'),
      }
    ](name='TranscodeJobList', description='子任务列表'),
    triggerSource?: string(name='TriggerSource', description='任务来源 - API, WorkFlow, Console'),
    userData?: string(name='UserData', description='用户数据'),
  }(name='TranscodeParentJob', description='TranscodeParentJobWithSubJobDTO'),
}

model SubmitTranscodeJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitTranscodeJobResponseBody(name='body'),
}

async function submitTranscodeJobWithOptions(tmpReq: SubmitTranscodeJobRequest, runtime: Util.RuntimeOptions): SubmitTranscodeJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitTranscodeJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.inputGroup)) {
    request.inputGroupShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.inputGroup, 'InputGroup', 'json');
  }
  if (!Util.isUnset(tmpReq.outputGroup)) {
    request.outputGroupShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.outputGroup, 'OutputGroup', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleConfig)) {
    request.scheduleConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleConfig, 'ScheduleConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.inputGroupShrink)) {
    query['InputGroup'] = request.inputGroupShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.outputGroupShrink)) {
    query['OutputGroup'] = request.outputGroupShrink;
  }
  if (!Util.isUnset(request.scheduleConfigShrink)) {
    query['ScheduleConfig'] = request.scheduleConfigShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitTranscodeJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitTranscodeJob(request: SubmitTranscodeJobRequest): SubmitTranscodeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitTranscodeJobWithOptions(request, runtime);
}

model UpdateCategoryRequest {
  cateId?: long(name='CateId'),
  cateName?: string(name='CateName'),
}

model UpdateCategoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateCategoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCategoryResponseBody(name='body'),
}

async function updateCategoryWithOptions(request: UpdateCategoryRequest, runtime: Util.RuntimeOptions): UpdateCategoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.cateName)) {
    query['CateName'] = request.cateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCategory',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCategory(request: UpdateCategoryRequest): UpdateCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCategoryWithOptions(request, runtime);
}

model UpdateCustomTemplateRequest {
  name?: string(name='Name', description='模板名称'),
  templateConfig?: string(name='TemplateConfig', description='模板参数'),
  templateId?: string(name='TemplateId', description='模板ID'),
}

model UpdateCustomTemplateResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='是否成功'),
}

model UpdateCustomTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCustomTemplateResponseBody(name='body'),
}

async function updateCustomTemplateWithOptions(request: UpdateCustomTemplateRequest, runtime: Util.RuntimeOptions): UpdateCustomTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.templateConfig)) {
    query['TemplateConfig'] = request.templateConfig;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCustomTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCustomTemplate(request: UpdateCustomTemplateRequest): UpdateCustomTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCustomTemplateWithOptions(request, runtime);
}

model UpdateEditingProjectRequest {
  businessStatus?: string(name='BusinessStatus'),
  clipsParam?: string(name='ClipsParam', description='模板对应的素材参数'),
  coverURL?: string(name='CoverURL', description='云剪辑工程封面'),
  description?: string(name='Description', description='云剪辑工程描述'),
  projectId?: string(name='ProjectId', description='云剪辑工程ID'),
  templateId?: string(name='TemplateId', description='模板Id'),
  timeline?: string(name='Timeline', description='云剪辑工程时间线，Json格式'),
  title?: string(name='Title', description='云剪辑工程标题'),
}

model UpdateEditingProjectResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEditingProjectResponseBody(name='body'),
}

async function updateEditingProjectWithOptions(request: UpdateEditingProjectRequest, runtime: Util.RuntimeOptions): UpdateEditingProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessStatus)) {
    query['BusinessStatus'] = request.businessStatus;
  }
  if (!Util.isUnset(request.clipsParam)) {
    query['ClipsParam'] = request.clipsParam;
  }
  if (!Util.isUnset(request.coverURL)) {
    query['CoverURL'] = request.coverURL;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.timeline)) {
    query['Timeline'] = request.timeline;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEditingProject',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateEditingProject(request: UpdateEditingProjectRequest): UpdateEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEditingProjectWithOptions(request, runtime);
}

model UpdateLiveTranscodeJobRequest {
  jobId?: string(name='JobId'),
  name?: string(name='Name'),
  streamInput?: {
    inputUrl?: string(name='InputUrl'),
    type?: string(name='Type'),
  }(name='StreamInput'),
  timedConfig?: {
    endTime?: string(name='EndTime'),
    startTime?: string(name='StartTime'),
  }(name='TimedConfig'),
  transcodeOutput?: {
    domainName?: string(name='DomainName'),
    type?: string(name='Type'),
  }(name='TranscodeOutput'),
}

model UpdateLiveTranscodeJobShrinkRequest {
  jobId?: string(name='JobId'),
  name?: string(name='Name'),
  streamInputShrink?: string(name='StreamInput'),
  timedConfigShrink?: string(name='TimedConfig'),
  transcodeOutputShrink?: string(name='TranscodeOutput'),
}

model UpdateLiveTranscodeJobResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
}

model UpdateLiveTranscodeJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLiveTranscodeJobResponseBody(name='body'),
}

async function updateLiveTranscodeJobWithOptions(tmpReq: UpdateLiveTranscodeJobRequest, runtime: Util.RuntimeOptions): UpdateLiveTranscodeJobResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateLiveTranscodeJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.streamInput)) {
    request.streamInputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.streamInput, 'StreamInput', 'json');
  }
  if (!Util.isUnset(tmpReq.timedConfig)) {
    request.timedConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.timedConfig, 'TimedConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.transcodeOutput)) {
    request.transcodeOutputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.transcodeOutput, 'TranscodeOutput', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.streamInputShrink)) {
    query['StreamInput'] = request.streamInputShrink;
  }
  if (!Util.isUnset(request.timedConfigShrink)) {
    query['TimedConfig'] = request.timedConfigShrink;
  }
  if (!Util.isUnset(request.transcodeOutputShrink)) {
    query['TranscodeOutput'] = request.transcodeOutputShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLiveTranscodeJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLiveTranscodeJob(request: UpdateLiveTranscodeJobRequest): UpdateLiveTranscodeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLiveTranscodeJobWithOptions(request, runtime);
}

model UpdateLiveTranscodeTemplateRequest {
  name?: string(name='Name'),
  templateConfig?: {
    audioParams?: {
      bitrate?: string(name='Bitrate'),
      channels?: string(name='Channels'),
      codec?: string(name='Codec'),
      profile?: string(name='Profile'),
      samplerate?: string(name='Samplerate'),
    }(name='AudioParams'),
    videoParams?: {
      bitrate?: string(name='Bitrate'),
      codec?: string(name='Codec'),
      fps?: string(name='Fps'),
      gop?: string(name='Gop'),
      height?: string(name='Height'),
      profile?: string(name='Profile'),
      width?: string(name='Width'),
    }(name='VideoParams'),
  }(name='TemplateConfig'),
  templateId?: string(name='TemplateId'),
}

model UpdateLiveTranscodeTemplateShrinkRequest {
  name?: string(name='Name'),
  templateConfigShrink?: string(name='TemplateConfig'),
  templateId?: string(name='TemplateId'),
}

model UpdateLiveTranscodeTemplateResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
}

model UpdateLiveTranscodeTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLiveTranscodeTemplateResponseBody(name='body'),
}

async function updateLiveTranscodeTemplateWithOptions(tmpReq: UpdateLiveTranscodeTemplateRequest, runtime: Util.RuntimeOptions): UpdateLiveTranscodeTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateLiveTranscodeTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.templateConfig)) {
    request.templateConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.templateConfig, 'TemplateConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.templateConfigShrink)) {
    query['TemplateConfig'] = request.templateConfigShrink;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLiveTranscodeTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLiveTranscodeTemplate(request: UpdateLiveTranscodeTemplateRequest): UpdateLiveTranscodeTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLiveTranscodeTemplateWithOptions(request, runtime);
}

model UpdateMediaInfoRequest {
  appendTags?: boolean(name='AppendTags', description='是否以append的形式更新Tags字段'),
  businessType?: string(name='BusinessType', description='媒资业务类型'),
  cateId?: long(name='CateId'),
  category?: string(name='Category', description='分类'),
  coverURL?: string(name='CoverURL', description='封面图，仅视频媒资有效'),
  description?: string(name='Description', description='描述'),
  inputURL?: string(name='InputURL', description='媒资媒体类型'),
  mediaId?: string(name='MediaId', description='媒资Id'),
  mediaTags?: string(name='MediaTags', description='标签,如果有多个标签用逗号隔开'),
  title?: string(name='Title', description='标题'),
  userData?: string(name='UserData', description='用户数据，最大1024字节'),
}

model UpdateMediaInfoResponseBody = {
  mediaId?: string(name='MediaId', description='ICE媒资ID'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model UpdateMediaInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMediaInfoResponseBody(name='body'),
}

async function updateMediaInfoWithOptions(request: UpdateMediaInfoRequest, runtime: Util.RuntimeOptions): UpdateMediaInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appendTags)) {
    query['AppendTags'] = request.appendTags;
  }
  if (!Util.isUnset(request.businessType)) {
    query['BusinessType'] = request.businessType;
  }
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.coverURL)) {
    query['CoverURL'] = request.coverURL;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.inputURL)) {
    query['InputURL'] = request.inputURL;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.mediaTags)) {
    query['MediaTags'] = request.mediaTags;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMediaInfo',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMediaInfo(request: UpdateMediaInfoRequest): UpdateMediaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaInfoWithOptions(request, runtime);
}

model UpdatePipelineRequest {
  name?: string(name='Name', description='管道名称'),
  pipelineId?: string(name='PipelineId', description='管道ID'),
  priority?: int32(name='Priority', description='优先级'),
  status?: string(name='Status', description='管道状态。'),
}

model UpdatePipelineResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='是否成功'),
}

model UpdatePipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePipelineResponseBody(name='body'),
}

async function updatePipelineWithOptions(request: UpdatePipelineRequest, runtime: Util.RuntimeOptions): UpdatePipelineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePipeline',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePipeline(request: UpdatePipelineRequest): UpdatePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePipelineWithOptions(request, runtime);
}

model UpdateSmartJobRequest {
  FEExtend?: string(name='FEExtend'),
  jobId?: string(name='JobId'),
}

model UpdateSmartJobResponseBody = {
  FEExtend?: string(name='FEExtend'),
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateSmartJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSmartJobResponseBody(name='body'),
}

async function updateSmartJobWithOptions(request: UpdateSmartJobRequest, runtime: Util.RuntimeOptions): UpdateSmartJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.FEExtend)) {
    query['FEExtend'] = request.FEExtend;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSmartJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSmartJob(request: UpdateSmartJobRequest): UpdateSmartJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSmartJobWithOptions(request, runtime);
}

model UpdateTemplateRequest {
  config?: string(name='Config', description='参见模板Config文档'),
  coverUrl?: string(name='CoverUrl', description='模板封面'),
  name?: string(name='Name', description='模板名称'),
  previewMedia?: string(name='PreviewMedia', description='预览视频媒资id'),
  relatedMediaids?: string(name='RelatedMediaids', description='模板相关素材，模板编辑器使用'),
  source?: string(name='Source', description='修改来源，默认OpenAPI'),
  status?: string(name='Status', description='模板状态'),
  templateId?: string(name='TemplateId', description='模板ID'),
}

model UpdateTemplateResponseBody = {
  requestId?: string(name='RequestId', description='请求ID'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTemplateResponseBody(name='body'),
}

async function updateTemplateWithOptions(request: UpdateTemplateRequest, runtime: Util.RuntimeOptions): UpdateTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.coverUrl)) {
    query['CoverUrl'] = request.coverUrl;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.previewMedia)) {
    query['PreviewMedia'] = request.previewMedia;
  }
  if (!Util.isUnset(request.relatedMediaids)) {
    query['RelatedMediaids'] = request.relatedMediaids;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTemplate(request: UpdateTemplateRequest): UpdateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTemplateWithOptions(request, runtime);
}

model UploadMediaByURLRequest {
  appId?: string(name='AppId'),
  entityId?: string(name='EntityId'),
  mediaMetaData?: string(name='MediaMetaData'),
  postProcessConfig?: string(name='PostProcessConfig'),
  uploadTargetConfig?: string(name='UploadTargetConfig'),
  uploadURLs?: string(name='UploadURLs'),
  userData?: string(name='UserData'),
}

model UploadMediaByURLResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
  uploadJobs?: [ 
    {
      jobId?: string(name='JobId'),
      mediaId?: string(name='MediaId'),
      sourceURL?: string(name='SourceURL'),
    }
  ](name='UploadJobs'),
}

model UploadMediaByURLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadMediaByURLResponseBody(name='body'),
}

async function uploadMediaByURLWithOptions(request: UploadMediaByURLRequest, runtime: Util.RuntimeOptions): UploadMediaByURLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.entityId)) {
    query['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.mediaMetaData)) {
    query['MediaMetaData'] = request.mediaMetaData;
  }
  if (!Util.isUnset(request.postProcessConfig)) {
    query['PostProcessConfig'] = request.postProcessConfig;
  }
  if (!Util.isUnset(request.uploadTargetConfig)) {
    query['UploadTargetConfig'] = request.uploadTargetConfig;
  }
  if (!Util.isUnset(request.uploadURLs)) {
    query['UploadURLs'] = request.uploadURLs;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadMediaByURL',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadMediaByURL(request: UploadMediaByURLRequest): UploadMediaByURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadMediaByURLWithOptions(request, runtime);
}

model UploadStreamByURLRequest {
  definition?: string(name='Definition'),
  fileExtension?: string(name='FileExtension'),
  HDRType?: string(name='HDRType'),
  mediaId?: string(name='MediaId'),
  streamURL?: string(name='StreamURL'),
  userData?: string(name='UserData'),
}

model UploadStreamByURLResponseBody = {
  fileURL?: string(name='FileURL'),
  jobId?: string(name='JobId'),
  mediaId?: string(name='MediaId'),
  requestId?: string(name='RequestId'),
  sourceURL?: string(name='SourceURL'),
}

model UploadStreamByURLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadStreamByURLResponseBody(name='body'),
}

async function uploadStreamByURLWithOptions(request: UploadStreamByURLRequest, runtime: Util.RuntimeOptions): UploadStreamByURLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.definition)) {
    query['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.fileExtension)) {
    query['FileExtension'] = request.fileExtension;
  }
  if (!Util.isUnset(request.HDRType)) {
    query['HDRType'] = request.HDRType;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.streamURL)) {
    query['StreamURL'] = request.streamURL;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadStreamByURL',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadStreamByURL(request: UploadStreamByURLRequest): UploadStreamByURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadStreamByURLWithOptions(request, runtime);
}

