/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'ice.aliyuncs.com',
    ap-northeast-2-pop = 'ice.aliyuncs.com',
    ap-south-1 = 'ice.aliyuncs.com',
    ap-southeast-1 = 'ice.aliyuncs.com',
    ap-southeast-2 = 'ice.aliyuncs.com',
    ap-southeast-3 = 'ice.aliyuncs.com',
    ap-southeast-5 = 'ice.aliyuncs.com',
    cn-beijing = 'ice.aliyuncs.com',
    cn-beijing-finance-1 = 'ice.aliyuncs.com',
    cn-beijing-finance-pop = 'ice.aliyuncs.com',
    cn-beijing-gov-1 = 'ice.aliyuncs.com',
    cn-beijing-nu16-b01 = 'ice.aliyuncs.com',
    cn-chengdu = 'ice.aliyuncs.com',
    cn-edge-1 = 'ice.aliyuncs.com',
    cn-fujian = 'ice.aliyuncs.com',
    cn-haidian-cm12-c01 = 'ice.aliyuncs.com',
    cn-hangzhou = 'ice.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'ice.aliyuncs.com',
    cn-hangzhou-finance = 'ice.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'ice.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'ice.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'ice.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'ice.aliyuncs.com',
    cn-hangzhou-test-306 = 'ice.aliyuncs.com',
    cn-hongkong = 'ice.aliyuncs.com',
    cn-hongkong-finance-pop = 'ice.aliyuncs.com',
    cn-huhehaote = 'ice.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'ice.aliyuncs.com',
    cn-north-2-gov-1 = 'ice.aliyuncs.com',
    cn-qingdao = 'ice.aliyuncs.com',
    cn-qingdao-nebula = 'ice.aliyuncs.com',
    cn-shanghai-et15-b01 = 'ice.aliyuncs.com',
    cn-shanghai-et2-b01 = 'ice.aliyuncs.com',
    cn-shanghai-finance-1 = 'ice.aliyuncs.com',
    cn-shanghai-inner = 'ice.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'ice.aliyuncs.com',
    cn-shenzhen = 'ice.aliyuncs.com',
    cn-shenzhen-finance-1 = 'ice.aliyuncs.com',
    cn-shenzhen-inner = 'ice.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'ice.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'ice.aliyuncs.com',
    cn-wuhan = 'ice.aliyuncs.com',
    cn-wulanchabu = 'ice.aliyuncs.com',
    cn-yushanfang = 'ice.aliyuncs.com',
    cn-zhangbei = 'ice.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'ice.aliyuncs.com',
    cn-zhangjiakou = 'ice.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'ice.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'ice.aliyuncs.com',
    eu-central-1 = 'ice.aliyuncs.com',
    eu-west-1 = 'ice.aliyuncs.com',
    eu-west-1-oxs = 'ice.aliyuncs.com',
    me-east-1 = 'ice.aliyuncs.com',
    rus-west-1-pop = 'ice.aliyuncs.com',
    us-east-1 = 'ice.aliyuncs.com',
    us-west-1 = 'ice.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('ice', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddCategoryRequest {
  cateName?: string(name='CateName'),
  parentId?: long(name='ParentId'),
  type?: string(name='Type'),
}

model AddCategoryResponseBody = {
  category?: {
    cateId?: long(name='CateId'),
    cateName?: string(name='CateName'),
    level?: long(name='Level'),
    parentId?: long(name='ParentId'),
    type?: string(name='Type'),
  }(name='Category'),
  requestId?: string(name='RequestId'),
}

model AddCategoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddCategoryResponseBody(name='body'),
}

async function addCategoryWithOptions(request: AddCategoryRequest, runtime: Util.RuntimeOptions): AddCategoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cateName)) {
    query['CateName'] = request.cateName;
  }
  if (!Util.isUnset(request.parentId)) {
    query['ParentId'] = request.parentId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddCategory',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addCategory(request: AddCategoryRequest): AddCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCategoryWithOptions(request, runtime);
}

model AddEditingProjectMaterialsRequest {
  materialMaps?: string(name='MaterialMaps'),
  projectId?: string(name='ProjectId'),
}

model AddEditingProjectMaterialsResponseBody = {
  liveMaterials?: [ 
    {
      appName?: string(name='AppName'),
      domainName?: string(name='DomainName'),
      liveUrl?: string(name='LiveUrl'),
      streamName?: string(name='StreamName'),
    }
  ](name='LiveMaterials'),
  mediaInfos?: [ 
    {
      fileInfoList?: [ 
        {
          fileBasicInfo?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            fileName?: string(name='FileName'),
            fileSize?: string(name='FileSize'),
            fileStatus?: string(name='FileStatus'),
            fileType?: string(name='FileType'),
            fileUrl?: string(name='FileUrl'),
            formatName?: string(name='FormatName'),
            height?: string(name='Height'),
            region?: string(name='Region'),
            width?: string(name='Width'),
          }(name='FileBasicInfo'),
        }
      ](name='FileInfoList'),
      mediaBasicInfo?: {
        businessType?: string(name='BusinessType'),
        category?: string(name='Category'),
        coverURL?: string(name='CoverURL'),
        createTime?: string(name='CreateTime'),
        deletedTime?: string(name='DeletedTime'),
        description?: string(name='Description'),
        inputURL?: string(name='InputURL'),
        mediaId?: string(name='MediaId'),
        mediaTags?: string(name='MediaTags'),
        mediaType?: string(name='MediaType'),
        modifiedTime?: string(name='ModifiedTime'),
        snapshots?: string(name='Snapshots'),
        source?: string(name='Source'),
        spriteImages?: string(name='SpriteImages'),
        status?: string(name='Status'),
        title?: string(name='Title'),
        transcodeStatus?: string(name='TranscodeStatus'),
        userData?: string(name='UserData'),
      }(name='MediaBasicInfo'),
      mediaId?: string(name='MediaId'),
    }
  ](name='MediaInfos'),
  projectId?: string(name='ProjectId'),
  projectMaterials?: [ string ](name='ProjectMaterials'),
  requestId?: string(name='RequestId'),
}

model AddEditingProjectMaterialsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddEditingProjectMaterialsResponseBody(name='body'),
}

async function addEditingProjectMaterialsWithOptions(request: AddEditingProjectMaterialsRequest, runtime: Util.RuntimeOptions): AddEditingProjectMaterialsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.materialMaps)) {
    query['MaterialMaps'] = request.materialMaps;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddEditingProjectMaterials',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addEditingProjectMaterials(request: AddEditingProjectMaterialsRequest): AddEditingProjectMaterialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addEditingProjectMaterialsWithOptions(request, runtime);
}

model AddFavoritePublicMediaRequest {
  mediaIds?: string(name='MediaIds'),
}

model AddFavoritePublicMediaResponseBody = {
  ignoredList?: [ string ](name='IgnoredList'),
  requestId?: string(name='RequestId'),
}

model AddFavoritePublicMediaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddFavoritePublicMediaResponseBody(name='body'),
}

async function addFavoritePublicMediaWithOptions(request: AddFavoritePublicMediaRequest, runtime: Util.RuntimeOptions): AddFavoritePublicMediaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaIds)) {
    query['MediaIds'] = request.mediaIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddFavoritePublicMedia',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addFavoritePublicMedia(request: AddFavoritePublicMediaRequest): AddFavoritePublicMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return addFavoritePublicMediaWithOptions(request, runtime);
}

model AddMediaMarksRequest {
  mediaId?: string(name='MediaId'),
  mediaMarks?: string(name='MediaMarks'),
}

model AddMediaMarksResponseBody = {
  mediaId?: string(name='MediaId'),
  mediaMarkIds?: string(name='MediaMarkIds'),
  requestId?: string(name='RequestId'),
}

model AddMediaMarksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddMediaMarksResponseBody(name='body'),
}

async function addMediaMarksWithOptions(request: AddMediaMarksRequest, runtime: Util.RuntimeOptions): AddMediaMarksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.mediaMarks)) {
    query['MediaMarks'] = request.mediaMarks;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddMediaMarks',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addMediaMarks(request: AddMediaMarksRequest): AddMediaMarksResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMediaMarksWithOptions(request, runtime);
}

model AddTemplateRequest {
  config?: string(name='Config'),
  coverUrl?: string(name='CoverUrl'),
  name?: string(name='Name'),
  previewMedia?: string(name='PreviewMedia'),
  source?: string(name='Source'),
  status?: string(name='Status'),
  type?: string(name='Type'),
}

model AddTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    config?: string(name='Config'),
    coverUrl?: string(name='CoverUrl'),
    createSource?: string(name='CreateSource'),
    modifiedSource?: string(name='ModifiedSource'),
    name?: string(name='Name'),
    previewMedia?: string(name='PreviewMedia'),
    status?: string(name='Status'),
    templateId?: string(name='TemplateId'),
    type?: string(name='Type'),
  }(name='Template'),
}

model AddTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddTemplateResponseBody(name='body'),
}

async function addTemplateWithOptions(request: AddTemplateRequest, runtime: Util.RuntimeOptions): AddTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.coverUrl)) {
    query['CoverUrl'] = request.coverUrl;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.previewMedia)) {
    query['PreviewMedia'] = request.previewMedia;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addTemplate(request: AddTemplateRequest): AddTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTemplateWithOptions(request, runtime);
}

model BatchGetMediaInfosRequest {
  additionType?: string(name='AdditionType'),
  mediaIds?: string(name='MediaIds'),
}

model BatchGetMediaInfosResponseBody = {
  mediaInfos?: [ 
    {
      fileInfoList?: [ 
        {
          fileBasicInfo?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            fileName?: string(name='FileName'),
            fileSize?: string(name='FileSize'),
            fileStatus?: string(name='FileStatus'),
            fileType?: string(name='FileType'),
            fileUrl?: string(name='FileUrl'),
            formatName?: string(name='FormatName'),
            height?: string(name='Height'),
            region?: string(name='Region'),
            width?: string(name='Width'),
          }(name='FileBasicInfo'),
        }
      ](name='FileInfoList'),
      mediaBasicInfo?: {
        businessType?: string(name='BusinessType'),
        category?: string(name='Category'),
        coverURL?: string(name='CoverURL'),
        createTime?: string(name='CreateTime'),
        deletedTime?: string(name='DeletedTime'),
        description?: string(name='Description'),
        inputURL?: string(name='InputURL'),
        mediaId?: string(name='MediaId'),
        mediaTags?: string(name='MediaTags'),
        mediaType?: string(name='MediaType'),
        modifiedTime?: string(name='ModifiedTime'),
        snapshots?: string(name='Snapshots'),
        source?: string(name='Source'),
        spriteImages?: string(name='SpriteImages'),
        status?: string(name='Status'),
        title?: string(name='Title'),
        transcodeStatus?: string(name='TranscodeStatus'),
        userData?: string(name='UserData'),
      }(name='MediaBasicInfo'),
      mediaId?: string(name='MediaId'),
    }
  ](name='MediaInfos'),
  requestId?: string(name='RequestId'),
}

model BatchGetMediaInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchGetMediaInfosResponseBody(name='body'),
}

async function batchGetMediaInfosWithOptions(request: BatchGetMediaInfosRequest, runtime: Util.RuntimeOptions): BatchGetMediaInfosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.additionType)) {
    query['AdditionType'] = request.additionType;
  }
  if (!Util.isUnset(request.mediaIds)) {
    query['MediaIds'] = request.mediaIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetMediaInfos',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchGetMediaInfos(request: BatchGetMediaInfosRequest): BatchGetMediaInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchGetMediaInfosWithOptions(request, runtime);
}

model CancelDNAJobRequest {
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CancelDNAJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model CancelDNAJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelDNAJobResponseBody(name='body'),
}

async function cancelDNAJobWithOptions(request: CancelDNAJobRequest, runtime: Util.RuntimeOptions): CancelDNAJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelDNAJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelDNAJob(request: CancelDNAJobRequest): CancelDNAJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelDNAJobWithOptions(request, runtime);
}

model CancelFavoritePublicMediaRequest {
  mediaIds?: string(name='MediaIds'),
}

model CancelFavoritePublicMediaResponseBody = {
  ignoredList?: [ string ](name='IgnoredList'),
  requestId?: string(name='RequestId'),
}

model CancelFavoritePublicMediaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelFavoritePublicMediaResponseBody(name='body'),
}

async function cancelFavoritePublicMediaWithOptions(request: CancelFavoritePublicMediaRequest, runtime: Util.RuntimeOptions): CancelFavoritePublicMediaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaIds)) {
    query['MediaIds'] = request.mediaIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelFavoritePublicMedia',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelFavoritePublicMedia(request: CancelFavoritePublicMediaRequest): CancelFavoritePublicMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelFavoritePublicMediaWithOptions(request, runtime);
}

model CancelUrlUploadJobsRequest {
  jobIds?: string(name='JobIds'),
  uploadUrls?: string(name='UploadUrls'),
}

model CancelUrlUploadJobsResponseBody = {
  canceledJobs?: [ string ](name='CanceledJobs'),
  nonExists?: [ string ](name='NonExists'),
  requestId?: string(name='RequestId'),
}

model CancelUrlUploadJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelUrlUploadJobsResponseBody(name='body'),
}

async function cancelUrlUploadJobsWithOptions(request: CancelUrlUploadJobsRequest, runtime: Util.RuntimeOptions): CancelUrlUploadJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobIds)) {
    query['JobIds'] = request.jobIds;
  }
  if (!Util.isUnset(request.uploadUrls)) {
    query['UploadUrls'] = request.uploadUrls;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelUrlUploadJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelUrlUploadJobs(request: CancelUrlUploadJobsRequest): CancelUrlUploadJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelUrlUploadJobsWithOptions(request, runtime);
}

model ConvertToFEEditingProjectRequest {
  projectId?: string(name='ProjectId'),
}

model ConvertToFEEditingProjectResponseBody = {
  project?: {
    projectId?: string(name='ProjectId'),
  }(name='Project'),
  requestId?: string(name='RequestId'),
}

model ConvertToFEEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConvertToFEEditingProjectResponseBody(name='body'),
}

async function convertToFEEditingProjectWithOptions(request: ConvertToFEEditingProjectRequest, runtime: Util.RuntimeOptions): ConvertToFEEditingProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConvertToFEEditingProject',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function convertToFEEditingProject(request: ConvertToFEEditingProjectRequest): ConvertToFEEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertToFEEditingProjectWithOptions(request, runtime);
}

model CreateAuditRequest {
  appId?: string(name='AppId'),
  auditContent?: string(name='AuditContent'),
}

model CreateAuditResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateAuditResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAuditResponseBody(name='body'),
}

async function createAuditWithOptions(request: CreateAuditRequest, runtime: Util.RuntimeOptions): CreateAuditResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.auditContent)) {
    query['AuditContent'] = request.auditContent;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAudit',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAudit(request: CreateAuditRequest): CreateAuditResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAuditWithOptions(request, runtime);
}

model CreateCustomTemplateRequest {
  name?: string(name='Name'),
  subtype?: int32(name='Subtype'),
  templateConfig?: string(name='TemplateConfig'),
  type?: int32(name='Type'),
}

model CreateCustomTemplateResponseBody = {
  customTemplate?: {
    createTime?: string(name='CreateTime'),
    isDefault?: boolean(name='IsDefault'),
    modifiedTime?: string(name='ModifiedTime'),
    status?: string(name='Status'),
    subtype?: string(name='Subtype'),
    templateConfig?: string(name='TemplateConfig'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    type?: int32(name='Type'),
    typeName?: string(name='TypeName'),
  }(name='CustomTemplate'),
  requestId?: string(name='RequestId'),
}

model CreateCustomTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCustomTemplateResponseBody(name='body'),
}

async function createCustomTemplateWithOptions(request: CreateCustomTemplateRequest, runtime: Util.RuntimeOptions): CreateCustomTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.subtype)) {
    query['Subtype'] = request.subtype;
  }
  if (!Util.isUnset(request.templateConfig)) {
    query['TemplateConfig'] = request.templateConfig;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCustomTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCustomTemplate(request: CreateCustomTemplateRequest): CreateCustomTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCustomTemplateWithOptions(request, runtime);
}

model CreateDNADBRequest {
  description?: string(name='Description'),
  model?: string(name='Model'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateDNADBResponseBody = {
  DBInfo?: {
    DBId?: string(name='DBId'),
    description?: string(name='Description'),
    model?: string(name='Model'),
    name?: string(name='Name'),
    status?: string(name='Status'),
  }(name='DBInfo'),
  requestId?: string(name='RequestId'),
}

model CreateDNADBResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDNADBResponseBody(name='body'),
}

async function createDNADBWithOptions(request: CreateDNADBRequest, runtime: Util.RuntimeOptions): CreateDNADBResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.model)) {
    query['Model'] = request.model;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDNADB',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDNADB(request: CreateDNADBRequest): CreateDNADBResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDNADBWithOptions(request, runtime);
}

model CreateEditingProjectRequest {
  businessConfig?: string(name='BusinessConfig'),
  clipsParam?: string(name='ClipsParam'),
  coverURL?: string(name='CoverURL'),
  description?: string(name='Description'),
  materialMaps?: string(name='MaterialMaps'),
  projectType?: string(name='ProjectType'),
  templateId?: string(name='TemplateId'),
  timeline?: string(name='Timeline'),
  title?: string(name='Title'),
}

model CreateEditingProjectResponseBody = {
  project?: {
    businessConfig?: string(name='BusinessConfig'),
    businessStatus?: string(name='BusinessStatus'),
    clipsParam?: string(name='ClipsParam'),
    coverURL?: string(name='CoverURL'),
    createSource?: string(name='CreateSource'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    duration?: float(name='Duration'),
    modifiedSource?: string(name='ModifiedSource'),
    modifiedTime?: string(name='ModifiedTime'),
    projectId?: string(name='ProjectId'),
    projectType?: string(name='ProjectType'),
    status?: long(name='Status'),
    statusName?: string(name='StatusName'),
    templateId?: string(name='TemplateId'),
    templateType?: string(name='TemplateType'),
    timeline?: string(name='Timeline'),
    title?: string(name='Title'),
  }(name='Project'),
  requestId?: string(name='RequestId'),
}

model CreateEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEditingProjectResponseBody(name='body'),
}

async function createEditingProjectWithOptions(request: CreateEditingProjectRequest, runtime: Util.RuntimeOptions): CreateEditingProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessConfig)) {
    query['BusinessConfig'] = request.businessConfig;
  }
  if (!Util.isUnset(request.clipsParam)) {
    query['ClipsParam'] = request.clipsParam;
  }
  if (!Util.isUnset(request.coverURL)) {
    query['CoverURL'] = request.coverURL;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.materialMaps)) {
    query['MaterialMaps'] = request.materialMaps;
  }
  if (!Util.isUnset(request.projectType)) {
    query['ProjectType'] = request.projectType;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.timeline)) {
    query['Timeline'] = request.timeline;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEditingProject',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createEditingProject(request: CreateEditingProjectRequest): CreateEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEditingProjectWithOptions(request, runtime);
}

model CreateLiveRecordTemplateRequest {
  name?: string(name='Name'),
  recordFormat?: [ 
    {
      cycleDuration?: int32(name='CycleDuration'),
      format?: string(name='Format'),
      ossObjectPrefix?: string(name='OssObjectPrefix'),
      sliceDuration?: int32(name='SliceDuration'),
      sliceOssObjectPrefix?: string(name='SliceOssObjectPrefix'),
    }
  ](name='RecordFormat'),
}

model CreateLiveRecordTemplateShrinkRequest {
  name?: string(name='Name'),
  recordFormatShrink?: string(name='RecordFormat'),
}

model CreateLiveRecordTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model CreateLiveRecordTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLiveRecordTemplateResponseBody(name='body'),
}

async function createLiveRecordTemplateWithOptions(tmpReq: CreateLiveRecordTemplateRequest, runtime: Util.RuntimeOptions): CreateLiveRecordTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new CreateLiveRecordTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.recordFormat)) {
    request.recordFormatShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.recordFormat, 'RecordFormat', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.recordFormatShrink)) {
    body['RecordFormat'] = request.recordFormatShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLiveRecordTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLiveRecordTemplate(request: CreateLiveRecordTemplateRequest): CreateLiveRecordTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLiveRecordTemplateWithOptions(request, runtime);
}

model CreateLiveSnapshotTemplateRequest {
  overwriteFormat?: string(name='OverwriteFormat'),
  sequenceFormat?: string(name='SequenceFormat'),
  templateName?: string(name='TemplateName'),
  timeInterval?: int32(name='TimeInterval'),
}

model CreateLiveSnapshotTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model CreateLiveSnapshotTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLiveSnapshotTemplateResponseBody(name='body'),
}

async function createLiveSnapshotTemplateWithOptions(request: CreateLiveSnapshotTemplateRequest, runtime: Util.RuntimeOptions): CreateLiveSnapshotTemplateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.overwriteFormat)) {
    body['OverwriteFormat'] = request.overwriteFormat;
  }
  if (!Util.isUnset(request.sequenceFormat)) {
    body['SequenceFormat'] = request.sequenceFormat;
  }
  if (!Util.isUnset(request.templateName)) {
    body['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.timeInterval)) {
    body['TimeInterval'] = request.timeInterval;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLiveSnapshotTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLiveSnapshotTemplate(request: CreateLiveSnapshotTemplateRequest): CreateLiveSnapshotTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLiveSnapshotTemplateWithOptions(request, runtime);
}

model CreateLiveTranscodeTemplateRequest {
  name?: string(name='Name'),
  templateConfig?: {
    audioParams?: {
      bitrate?: string(name='Bitrate'),
      channels?: string(name='Channels'),
      codec?: string(name='Codec'),
      profile?: string(name='Profile'),
      samplerate?: string(name='Samplerate'),
    }(name='AudioParams'),
    videoParams?: {
      bitrate?: string(name='Bitrate'),
      codec?: string(name='Codec'),
      fps?: string(name='Fps'),
      gop?: string(name='Gop'),
      height?: string(name='Height'),
      profile?: string(name='Profile'),
      width?: string(name='Width'),
    }(name='VideoParams'),
  }(name='TemplateConfig'),
  type?: string(name='Type'),
}

model CreateLiveTranscodeTemplateShrinkRequest {
  name?: string(name='Name'),
  templateConfigShrink?: string(name='TemplateConfig'),
  type?: string(name='Type'),
}

model CreateLiveTranscodeTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model CreateLiveTranscodeTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLiveTranscodeTemplateResponseBody(name='body'),
}

async function createLiveTranscodeTemplateWithOptions(tmpReq: CreateLiveTranscodeTemplateRequest, runtime: Util.RuntimeOptions): CreateLiveTranscodeTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new CreateLiveTranscodeTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.templateConfig)) {
    request.templateConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.templateConfig, 'TemplateConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.templateConfigShrink)) {
    query['TemplateConfig'] = request.templateConfigShrink;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLiveTranscodeTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLiveTranscodeTemplate(request: CreateLiveTranscodeTemplateRequest): CreateLiveTranscodeTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLiveTranscodeTemplateWithOptions(request, runtime);
}

model CreatePipelineRequest {
  name?: string(name='Name'),
  priority?: int32(name='Priority'),
  speed?: string(name='Speed'),
}

model CreatePipelineResponseBody = {
  pipeline?: {
    createTime?: string(name='CreateTime'),
    modifiedTime?: string(name='ModifiedTime'),
    name?: string(name='Name'),
    pipelineId?: string(name='PipelineId'),
    priority?: int32(name='Priority'),
    speed?: string(name='Speed'),
    status?: string(name='Status'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model CreatePipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePipelineResponseBody(name='body'),
}

async function createPipelineWithOptions(request: CreatePipelineRequest, runtime: Util.RuntimeOptions): CreatePipelineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.speed)) {
    query['Speed'] = request.speed;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePipeline',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPipeline(request: CreatePipelineRequest): CreatePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPipelineWithOptions(request, runtime);
}

model CreateUploadMediaRequest {
  appId?: string(name='AppId'),
  entityId?: string(name='EntityId'),
  fileInfo?: string(name='FileInfo'),
  mediaMetaData?: string(name='MediaMetaData'),
  postProcessConfig?: string(name='PostProcessConfig'),
  uploadTargetConfig?: string(name='UploadTargetConfig'),
  userData?: string(name='UserData'),
}

model CreateUploadMediaResponseBody = {
  fileURL?: string(name='FileURL'),
  mediaId?: string(name='MediaId'),
  mediaURL?: string(name='MediaURL'),
  requestId?: string(name='RequestId'),
  uploadAddress?: string(name='UploadAddress'),
  uploadAuth?: string(name='UploadAuth'),
}

model CreateUploadMediaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUploadMediaResponseBody(name='body'),
}

async function createUploadMediaWithOptions(request: CreateUploadMediaRequest, runtime: Util.RuntimeOptions): CreateUploadMediaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.entityId)) {
    query['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.fileInfo)) {
    query['FileInfo'] = request.fileInfo;
  }
  if (!Util.isUnset(request.mediaMetaData)) {
    query['MediaMetaData'] = request.mediaMetaData;
  }
  if (!Util.isUnset(request.postProcessConfig)) {
    query['PostProcessConfig'] = request.postProcessConfig;
  }
  if (!Util.isUnset(request.uploadTargetConfig)) {
    query['UploadTargetConfig'] = request.uploadTargetConfig;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUploadMedia',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUploadMedia(request: CreateUploadMediaRequest): CreateUploadMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUploadMediaWithOptions(request, runtime);
}

model CreateUploadStreamRequest {
  definition?: string(name='Definition'),
  fileExtension?: string(name='FileExtension'),
  HDRType?: string(name='HDRType'),
  mediaId?: string(name='MediaId'),
  userData?: string(name='UserData'),
}

model CreateUploadStreamResponseBody = {
  fileURL?: string(name='FileURL'),
  mediaId?: string(name='MediaId'),
  requestId?: string(name='RequestId'),
  uploadAddress?: string(name='UploadAddress'),
  uploadAuth?: string(name='UploadAuth'),
}

model CreateUploadStreamResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUploadStreamResponseBody(name='body'),
}

async function createUploadStreamWithOptions(request: CreateUploadStreamRequest, runtime: Util.RuntimeOptions): CreateUploadStreamResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.definition)) {
    query['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.fileExtension)) {
    query['FileExtension'] = request.fileExtension;
  }
  if (!Util.isUnset(request.HDRType)) {
    query['HDRType'] = request.HDRType;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUploadStream',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUploadStream(request: CreateUploadStreamRequest): CreateUploadStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUploadStreamWithOptions(request, runtime);
}

model DeleteCategoryRequest {
  cateId?: long(name='CateId'),
}

model DeleteCategoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCategoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCategoryResponseBody(name='body'),
}

async function deleteCategoryWithOptions(request: DeleteCategoryRequest, runtime: Util.RuntimeOptions): DeleteCategoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCategory',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCategory(request: DeleteCategoryRequest): DeleteCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCategoryWithOptions(request, runtime);
}

model DeleteCustomTemplateRequest {
  templateId?: string(name='TemplateId'),
}

model DeleteCustomTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteCustomTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCustomTemplateResponseBody(name='body'),
}

async function deleteCustomTemplateWithOptions(request: DeleteCustomTemplateRequest, runtime: Util.RuntimeOptions): DeleteCustomTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCustomTemplate(request: DeleteCustomTemplateRequest): DeleteCustomTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomTemplateWithOptions(request, runtime);
}

model DeleteDNADBRequest {
  DBId?: string(name='DBId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDNADBResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDNADBResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDNADBResponseBody(name='body'),
}

async function deleteDNADBWithOptions(request: DeleteDNADBRequest, runtime: Util.RuntimeOptions): DeleteDNADBResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBId)) {
    query['DBId'] = request.DBId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDNADB',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDNADB(request: DeleteDNADBRequest): DeleteDNADBResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDNADBWithOptions(request, runtime);
}

model DeleteDNAFilesRequest {
  DBId?: string(name='DBId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  primaryKeys?: string(name='PrimaryKeys'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDNAFilesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDNAFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDNAFilesResponseBody(name='body'),
}

async function deleteDNAFilesWithOptions(request: DeleteDNAFilesRequest, runtime: Util.RuntimeOptions): DeleteDNAFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBId)) {
    query['DBId'] = request.DBId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.primaryKeys)) {
    query['PrimaryKeys'] = request.primaryKeys;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDNAFiles',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDNAFiles(request: DeleteDNAFilesRequest): DeleteDNAFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDNAFilesWithOptions(request, runtime);
}

model DeleteEditingProjectMaterialsRequest {
  materialIds?: string(name='MaterialIds'),
  materialType?: string(name='MaterialType'),
  projectId?: string(name='ProjectId'),
}

model DeleteEditingProjectMaterialsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteEditingProjectMaterialsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEditingProjectMaterialsResponseBody(name='body'),
}

async function deleteEditingProjectMaterialsWithOptions(request: DeleteEditingProjectMaterialsRequest, runtime: Util.RuntimeOptions): DeleteEditingProjectMaterialsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.materialIds)) {
    query['MaterialIds'] = request.materialIds;
  }
  if (!Util.isUnset(request.materialType)) {
    query['MaterialType'] = request.materialType;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEditingProjectMaterials',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEditingProjectMaterials(request: DeleteEditingProjectMaterialsRequest): DeleteEditingProjectMaterialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEditingProjectMaterialsWithOptions(request, runtime);
}

model DeleteEditingProjectsRequest {
  projectIds?: string(name='ProjectIds'),
}

model DeleteEditingProjectsResponseBody = {
  ignoredList?: string(name='IgnoredList'),
  requestId?: string(name='RequestId'),
}

model DeleteEditingProjectsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEditingProjectsResponseBody(name='body'),
}

async function deleteEditingProjectsWithOptions(request: DeleteEditingProjectsRequest, runtime: Util.RuntimeOptions): DeleteEditingProjectsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectIds)) {
    query['ProjectIds'] = request.projectIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEditingProjects',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEditingProjects(request: DeleteEditingProjectsRequest): DeleteEditingProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEditingProjectsWithOptions(request, runtime);
}

model DeleteLiveRecordFilesRequest {
  recordIds?: [ string ](name='RecordIds'),
  removeFile?: boolean(name='RemoveFile'),
}

model DeleteLiveRecordFilesResponseBody = {
  deleteFileInfoList?: [ 
    {
      code?: string(name='Code'),
      message?: string(name='Message'),
      recordId?: string(name='RecordId'),
    }
  ](name='DeleteFileInfoList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteLiveRecordFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLiveRecordFilesResponseBody(name='body'),
}

async function deleteLiveRecordFilesWithOptions(request: DeleteLiveRecordFilesRequest, runtime: Util.RuntimeOptions): DeleteLiveRecordFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.recordIds)) {
    query['RecordIds'] = request.recordIds;
  }
  if (!Util.isUnset(request.removeFile)) {
    query['RemoveFile'] = request.removeFile;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLiveRecordFiles',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLiveRecordFiles(request: DeleteLiveRecordFilesRequest): DeleteLiveRecordFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLiveRecordFilesWithOptions(request, runtime);
}

model DeleteLiveRecordTemplateRequest {
  templateId?: string(name='TemplateId'),
}

model DeleteLiveRecordTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLiveRecordTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLiveRecordTemplateResponseBody(name='body'),
}

async function deleteLiveRecordTemplateWithOptions(request: DeleteLiveRecordTemplateRequest, runtime: Util.RuntimeOptions): DeleteLiveRecordTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLiveRecordTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLiveRecordTemplate(request: DeleteLiveRecordTemplateRequest): DeleteLiveRecordTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLiveRecordTemplateWithOptions(request, runtime);
}

model DeleteLiveSnapshotFilesRequest {
  createTimestampList?: [ long ](name='CreateTimestampList'),
  deleteOriginalFile?: boolean(name='DeleteOriginalFile'),
  jobId?: string(name='JobId'),
}

model DeleteLiveSnapshotFilesShrinkRequest {
  createTimestampListShrink?: string(name='CreateTimestampList'),
  deleteOriginalFile?: boolean(name='DeleteOriginalFile'),
  jobId?: string(name='JobId'),
}

model DeleteLiveSnapshotFilesResponseBody = {
  deleteFileResultList?: [ 
    {
      createTimestamp?: long(name='CreateTimestamp'),
      result?: string(name='Result'),
    }
  ](name='DeleteFileResultList'),
  requestId?: string(name='RequestId'),
}

model DeleteLiveSnapshotFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLiveSnapshotFilesResponseBody(name='body'),
}

async function deleteLiveSnapshotFilesWithOptions(tmpReq: DeleteLiveSnapshotFilesRequest, runtime: Util.RuntimeOptions): DeleteLiveSnapshotFilesResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteLiveSnapshotFilesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.createTimestampList)) {
    request.createTimestampListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.createTimestampList, 'CreateTimestampList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.createTimestampListShrink)) {
    query['CreateTimestampList'] = request.createTimestampListShrink;
  }
  if (!Util.isUnset(request.deleteOriginalFile)) {
    query['DeleteOriginalFile'] = request.deleteOriginalFile;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLiveSnapshotFiles',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLiveSnapshotFiles(request: DeleteLiveSnapshotFilesRequest): DeleteLiveSnapshotFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLiveSnapshotFilesWithOptions(request, runtime);
}

model DeleteLiveSnapshotTemplateRequest {
  templateId?: string(name='TemplateId'),
}

model DeleteLiveSnapshotTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLiveSnapshotTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLiveSnapshotTemplateResponseBody(name='body'),
}

async function deleteLiveSnapshotTemplateWithOptions(request: DeleteLiveSnapshotTemplateRequest, runtime: Util.RuntimeOptions): DeleteLiveSnapshotTemplateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLiveSnapshotTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLiveSnapshotTemplate(request: DeleteLiveSnapshotTemplateRequest): DeleteLiveSnapshotTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLiveSnapshotTemplateWithOptions(request, runtime);
}

model DeleteLiveTranscodeJobRequest {
  jobId?: string(name='JobId'),
}

model DeleteLiveTranscodeJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLiveTranscodeJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLiveTranscodeJobResponseBody(name='body'),
}

async function deleteLiveTranscodeJobWithOptions(request: DeleteLiveTranscodeJobRequest, runtime: Util.RuntimeOptions): DeleteLiveTranscodeJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLiveTranscodeJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLiveTranscodeJob(request: DeleteLiveTranscodeJobRequest): DeleteLiveTranscodeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLiveTranscodeJobWithOptions(request, runtime);
}

model DeleteLiveTranscodeTemplateRequest {
  templateId?: string(name='TemplateId'),
}

model DeleteLiveTranscodeTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLiveTranscodeTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLiveTranscodeTemplateResponseBody(name='body'),
}

async function deleteLiveTranscodeTemplateWithOptions(request: DeleteLiveTranscodeTemplateRequest, runtime: Util.RuntimeOptions): DeleteLiveTranscodeTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLiveTranscodeTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLiveTranscodeTemplate(request: DeleteLiveTranscodeTemplateRequest): DeleteLiveTranscodeTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLiveTranscodeTemplateWithOptions(request, runtime);
}

model DeleteMediaInfosRequest {
  deletePhysicalFiles?: boolean(name='DeletePhysicalFiles'),
  inputURLs?: string(name='InputURLs'),
  mediaIds?: string(name='MediaIds'),
}

model DeleteMediaInfosResponseBody = {
  forbiddenList?: [ string ](name='ForbiddenList'),
  ignoredList?: [ string ](name='IgnoredList'),
  requestId?: string(name='RequestId'),
}

model DeleteMediaInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMediaInfosResponseBody(name='body'),
}

async function deleteMediaInfosWithOptions(request: DeleteMediaInfosRequest, runtime: Util.RuntimeOptions): DeleteMediaInfosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deletePhysicalFiles)) {
    query['DeletePhysicalFiles'] = request.deletePhysicalFiles;
  }
  if (!Util.isUnset(request.inputURLs)) {
    query['InputURLs'] = request.inputURLs;
  }
  if (!Util.isUnset(request.mediaIds)) {
    query['MediaIds'] = request.mediaIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMediaInfos',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMediaInfos(request: DeleteMediaInfosRequest): DeleteMediaInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMediaInfosWithOptions(request, runtime);
}

model DeleteMediaMarksRequest {
  mediaId?: string(name='MediaId'),
  mediaMarkIds?: string(name='MediaMarkIds'),
}

model DeleteMediaMarksResponseBody = {
  mediaId?: string(name='MediaId'),
  mediaMarkIds?: string(name='MediaMarkIds'),
  requestId?: string(name='RequestId'),
}

model DeleteMediaMarksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMediaMarksResponseBody(name='body'),
}

async function deleteMediaMarksWithOptions(request: DeleteMediaMarksRequest, runtime: Util.RuntimeOptions): DeleteMediaMarksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.mediaMarkIds)) {
    query['MediaMarkIds'] = request.mediaMarkIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMediaMarks',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMediaMarks(request: DeleteMediaMarksRequest): DeleteMediaMarksResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMediaMarksWithOptions(request, runtime);
}

model DeleteMediaProducingJobsRequest {
  jobIds?: string(name='JobIds'),
}

model DeleteMediaProducingJobsResponseBody = {
  ignoreList?: string(name='IgnoreList'),
  requestId?: string(name='RequestId'),
}

model DeleteMediaProducingJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMediaProducingJobsResponseBody(name='body'),
}

async function deleteMediaProducingJobsWithOptions(request: DeleteMediaProducingJobsRequest, runtime: Util.RuntimeOptions): DeleteMediaProducingJobsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.jobIds)) {
    body['JobIds'] = request.jobIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMediaProducingJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMediaProducingJobs(request: DeleteMediaProducingJobsRequest): DeleteMediaProducingJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMediaProducingJobsWithOptions(request, runtime);
}

model DeletePipelineRequest {
  pipelineId?: string(name='PipelineId'),
}

model DeletePipelineResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeletePipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePipelineResponseBody(name='body'),
}

async function deletePipelineWithOptions(request: DeletePipelineRequest, runtime: Util.RuntimeOptions): DeletePipelineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePipeline',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePipeline(request: DeletePipelineRequest): DeletePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePipelineWithOptions(request, runtime);
}

model DeletePlayInfoRequest {
  deletePhysicalFiles?: boolean(name='DeletePhysicalFiles'),
  fileURLs?: string(name='FileURLs'),
  mediaId?: string(name='MediaId'),
}

model DeletePlayInfoResponseBody = {
  forbiddenList?: [ string ](name='ForbiddenList'),
  ignoredList?: [ string ](name='IgnoredList'),
  requestId?: string(name='RequestId'),
}

model DeletePlayInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePlayInfoResponseBody(name='body'),
}

async function deletePlayInfoWithOptions(request: DeletePlayInfoRequest, runtime: Util.RuntimeOptions): DeletePlayInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deletePhysicalFiles)) {
    query['DeletePhysicalFiles'] = request.deletePhysicalFiles;
  }
  if (!Util.isUnset(request.fileURLs)) {
    query['FileURLs'] = request.fileURLs;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePlayInfo',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePlayInfo(request: DeletePlayInfoRequest): DeletePlayInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePlayInfoWithOptions(request, runtime);
}

model DeleteSmartJobRequest {
  jobId?: string(name='JobId'),
}

model DeleteSmartJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSmartJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSmartJobResponseBody(name='body'),
}

async function deleteSmartJobWithOptions(request: DeleteSmartJobRequest, runtime: Util.RuntimeOptions): DeleteSmartJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSmartJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSmartJob(request: DeleteSmartJobRequest): DeleteSmartJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSmartJobWithOptions(request, runtime);
}

model DeleteTemplateRequest {
  templateIds?: string(name='TemplateIds'),
}

model DeleteTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTemplateResponseBody(name='body'),
}

async function deleteTemplateWithOptions(request: DeleteTemplateRequest, runtime: Util.RuntimeOptions): DeleteTemplateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTemplate(request: DeleteTemplateRequest): DeleteTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTemplateWithOptions(request, runtime);
}

model DescribeFilterConfigsRequest {
  type?: string(name='Type'),
}

model DescribeFilterConfigsResponseBody = {
  filterConfigs?: [ 
    {
      filterName?: string(name='FilterName'),
      itemConfigs?: string(name='ItemConfigs'),
      type?: string(name='Type'),
      uuId?: string(name='UuId'),
    }
  ](name='FilterConfigs'),
  requestId?: string(name='RequestId'),
}

model DescribeFilterConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFilterConfigsResponseBody(name='body'),
}

async function describeFilterConfigsWithOptions(request: DescribeFilterConfigsRequest, runtime: Util.RuntimeOptions): DescribeFilterConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFilterConfigs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFilterConfigs(request: DescribeFilterConfigsRequest): DescribeFilterConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFilterConfigsWithOptions(request, runtime);
}

model DescribeLivePubExperienceMetricDataRequest {
  beginTs?: string(name='BeginTs'),
  domain?: string(name='Domain'),
  endTs?: string(name='EndTs'),
  metricType?: string(name='MetricType'),
  os?: string(name='Os'),
  pubProtocol?: string(name='PubProtocol'),
  terminalType?: string(name='TerminalType'),
}

model DescribeLivePubExperienceMetricDataResponseBody = {
  metricList?: [ 
    {
      avgScore?: float(name='AvgScore'),
      maxScore?: float(name='MaxScore'),
      minScore?: float(name='MinScore'),
    }
  ](name='MetricList'),
  requestId?: string(name='RequestId'),
}

model DescribeLivePubExperienceMetricDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLivePubExperienceMetricDataResponseBody(name='body'),
}

async function describeLivePubExperienceMetricDataWithOptions(request: DescribeLivePubExperienceMetricDataRequest, runtime: Util.RuntimeOptions): DescribeLivePubExperienceMetricDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.pubProtocol)) {
    query['PubProtocol'] = request.pubProtocol;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLivePubExperienceMetricData',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLivePubExperienceMetricData(request: DescribeLivePubExperienceMetricDataRequest): DescribeLivePubExperienceMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLivePubExperienceMetricDataWithOptions(request, runtime);
}

model DescribeLivePubListRequest {
  beginTs?: string(name='BeginTs'),
  domain?: string(name='Domain'),
  endTs?: string(name='EndTs'),
  metricType?: string(name='MetricType'),
  os?: string(name='Os'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  pubProtocol?: string(name='PubProtocol'),
  terminalType?: string(name='TerminalType'),
}

model DescribeLivePubListResponseBody = {
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  pubInfoList?: [ 
    {
      area?: string(name='Area'),
      cpuUsageRate?: string(name='CpuUsageRate'),
      domain?: string(name='Domain'),
      endTs?: string(name='EndTs'),
      fps?: string(name='Fps'),
      kbps?: string(name='Kbps'),
      pubHeapUpDuration?: string(name='PubHeapUpDuration'),
      pubMachineType?: string(name='PubMachineType'),
      secondPlayRate?: string(name='SecondPlayRate'),
      startTs?: string(name='StartTs'),
      streamName?: string(name='StreamName'),
    }
  ](name='PubInfoList'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeLivePubListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLivePubListResponseBody(name='body'),
}

async function describeLivePubListWithOptions(request: DescribeLivePubListRequest, runtime: Util.RuntimeOptions): DescribeLivePubListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pubProtocol)) {
    query['PubProtocol'] = request.pubProtocol;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLivePubList',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLivePubList(request: DescribeLivePubListRequest): DescribeLivePubListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLivePubListWithOptions(request, runtime);
}

model DescribeLivePubMetricDataRequest {
  beginTs?: long(name='BeginTs'),
  domain?: string(name='Domain'),
  endTs?: long(name='EndTs'),
  experienceLevel?: string(name='ExperienceLevel'),
  metricType?: string(name='MetricType'),
  os?: string(name='Os'),
  pubProtocol?: string(name='PubProtocol'),
  sdkVersion?: string(name='SdkVersion'),
  streamName?: string(name='StreamName'),
  terminalType?: string(name='TerminalType'),
}

model DescribeLivePubMetricDataResponseBody = {
  nodes?: [ 
    {
      duration?: long(name='Duration'),
      time?: long(name='Time'),
    }
  ](name='Nodes'),
  requestId?: string(name='RequestId'),
}

model DescribeLivePubMetricDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLivePubMetricDataResponseBody(name='body'),
}

async function describeLivePubMetricDataWithOptions(request: DescribeLivePubMetricDataRequest, runtime: Util.RuntimeOptions): DescribeLivePubMetricDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.experienceLevel)) {
    query['ExperienceLevel'] = request.experienceLevel;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.pubProtocol)) {
    query['PubProtocol'] = request.pubProtocol;
  }
  if (!Util.isUnset(request.sdkVersion)) {
    query['SdkVersion'] = request.sdkVersion;
  }
  if (!Util.isUnset(request.streamName)) {
    query['StreamName'] = request.streamName;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLivePubMetricData',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLivePubMetricData(request: DescribeLivePubMetricDataRequest): DescribeLivePubMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLivePubMetricDataWithOptions(request, runtime);
}

model DescribeLiveSubExperienceMetricDataRequest {
  appName?: string(name='AppName'),
  beginTs?: string(name='BeginTs'),
  endTs?: string(name='EndTs'),
  experienceLevel?: string(name='ExperienceLevel'),
  metricType?: string(name='MetricType'),
  os?: string(name='Os'),
  subProtocol?: string(name='SubProtocol'),
  terminalType?: string(name='TerminalType'),
}

model DescribeLiveSubExperienceMetricDataResponseBody = {
  metricList?: [ 
    {
      avgScore?: float(name='AvgScore'),
      maxScore?: float(name='MaxScore'),
      minScore?: float(name='MinScore'),
    }
  ](name='MetricList'),
  requestId?: string(name='RequestId'),
}

model DescribeLiveSubExperienceMetricDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLiveSubExperienceMetricDataResponseBody(name='body'),
}

async function describeLiveSubExperienceMetricDataWithOptions(request: DescribeLiveSubExperienceMetricDataRequest, runtime: Util.RuntimeOptions): DescribeLiveSubExperienceMetricDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.experienceLevel)) {
    query['ExperienceLevel'] = request.experienceLevel;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.subProtocol)) {
    query['SubProtocol'] = request.subProtocol;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLiveSubExperienceMetricData',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLiveSubExperienceMetricData(request: DescribeLiveSubExperienceMetricDataRequest): DescribeLiveSubExperienceMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLiveSubExperienceMetricDataWithOptions(request, runtime);
}

model DescribeLiveSubListRequest {
  appName?: string(name='AppName'),
  beginTs?: string(name='BeginTs'),
  definition?: string(name='Definition'),
  endTs?: string(name='EndTs'),
  experienceLevel?: string(name='ExperienceLevel'),
  itemConfigs?: string(name='ItemConfigs'),
  metricType?: string(name='MetricType'),
  network?: string(name='Network'),
  os?: string(name='Os'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  streamName?: string(name='StreamName'),
  subProtocol?: string(name='SubProtocol'),
  terminalType?: string(name='TerminalType'),
}

model DescribeLiveSubListResponseBody = {
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  subInfoList?: [ 
    {
      cacheDuration?: string(name='CacheDuration'),
      cpuUsageRate?: string(name='CpuUsageRate'),
      firstFrameDuration?: string(name='FirstFrameDuration'),
      playFps?: string(name='PlayFps'),
      secondPlayRate?: string(name='SecondPlayRate'),
      subNetBitrate?: string(name='SubNetBitrate'),
      subRate?: string(name='SubRate'),
      traceId?: string(name='TraceId'),
      videoStuck?: string(name='VideoStuck'),
    }
  ](name='SubInfoList'),
  totalCount?: long(name='TotalCount'),
}

model DescribeLiveSubListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLiveSubListResponseBody(name='body'),
}

async function describeLiveSubListWithOptions(request: DescribeLiveSubListRequest, runtime: Util.RuntimeOptions): DescribeLiveSubListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.definition)) {
    query['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.experienceLevel)) {
    query['ExperienceLevel'] = request.experienceLevel;
  }
  if (!Util.isUnset(request.itemConfigs)) {
    query['ItemConfigs'] = request.itemConfigs;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.network)) {
    query['Network'] = request.network;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.streamName)) {
    query['StreamName'] = request.streamName;
  }
  if (!Util.isUnset(request.subProtocol)) {
    query['SubProtocol'] = request.subProtocol;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLiveSubList',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLiveSubList(request: DescribeLiveSubListRequest): DescribeLiveSubListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLiveSubListWithOptions(request, runtime);
}

model DescribeLiveSubMetricDataRequest {
  appName?: string(name='AppName'),
  beginTs?: long(name='BeginTs'),
  definition?: string(name='Definition'),
  endTs?: long(name='EndTs'),
  experienceLevel?: string(name='ExperienceLevel'),
  itemConfigs?: string(name='ItemConfigs'),
  metricType?: string(name='MetricType'),
  network?: string(name='Network'),
  os?: string(name='Os'),
  sdkVersion?: string(name='SdkVersion'),
  streamName?: string(name='StreamName'),
  subProtocol?: string(name='SubProtocol'),
  terminalType?: string(name='TerminalType'),
}

model DescribeLiveSubMetricDataResponseBody = {
  nodes?: [ 
    {
      duration?: long(name='Duration'),
      time?: long(name='Time'),
    }
  ](name='Nodes'),
  requestId?: string(name='RequestId'),
}

model DescribeLiveSubMetricDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLiveSubMetricDataResponseBody(name='body'),
}

async function describeLiveSubMetricDataWithOptions(request: DescribeLiveSubMetricDataRequest, runtime: Util.RuntimeOptions): DescribeLiveSubMetricDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.definition)) {
    query['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.experienceLevel)) {
    query['ExperienceLevel'] = request.experienceLevel;
  }
  if (!Util.isUnset(request.itemConfigs)) {
    query['ItemConfigs'] = request.itemConfigs;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.network)) {
    query['Network'] = request.network;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.sdkVersion)) {
    query['SdkVersion'] = request.sdkVersion;
  }
  if (!Util.isUnset(request.streamName)) {
    query['StreamName'] = request.streamName;
  }
  if (!Util.isUnset(request.subProtocol)) {
    query['SubProtocol'] = request.subProtocol;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLiveSubMetricData',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLiveSubMetricData(request: DescribeLiveSubMetricDataRequest): DescribeLiveSubMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLiveSubMetricDataWithOptions(request, runtime);
}

model DescribeMeterIceEditUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: long(name='Interval'),
  region?: string(name='Region'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterIceEditUsageResponseBody = {
  data?: [ 
    {
      duration?: long(name='Duration'),
      profile?: string(name='Profile'),
      time?: long(name='Time'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMeterIceEditUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterIceEditUsageResponseBody(name='body'),
}

async function describeMeterIceEditUsageWithOptions(request: DescribeMeterIceEditUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterIceEditUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterIceEditUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterIceEditUsage(request: DescribeMeterIceEditUsageRequest): DescribeMeterIceEditUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterIceEditUsageWithOptions(request, runtime);
}

model DescribeMeterIceLiveMediaConvertUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: long(name='Interval'),
  region?: string(name='Region'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterIceLiveMediaConvertUsageResponseBody = {
  data?: [ 
    {
      duration?: long(name='Duration'),
      specification?: string(name='Specification'),
      time?: long(name='Time'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMeterIceLiveMediaConvertUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterIceLiveMediaConvertUsageResponseBody(name='body'),
}

async function describeMeterIceLiveMediaConvertUsageWithOptions(request: DescribeMeterIceLiveMediaConvertUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterIceLiveMediaConvertUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterIceLiveMediaConvertUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterIceLiveMediaConvertUsage(request: DescribeMeterIceLiveMediaConvertUsageRequest): DescribeMeterIceLiveMediaConvertUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterIceLiveMediaConvertUsageWithOptions(request, runtime);
}

model DescribeMeterIceMediaConvertUHDUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: string(name='Interval'),
  regionId?: string(name='RegionId'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterIceMediaConvertUHDUsageResponseBody = {
  data?: [ 
    {
      duration?: long(name='Duration'),
      specification?: string(name='Specification'),
      time?: long(name='Time'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMeterIceMediaConvertUHDUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterIceMediaConvertUHDUsageResponseBody(name='body'),
}

async function describeMeterIceMediaConvertUHDUsageWithOptions(request: DescribeMeterIceMediaConvertUHDUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterIceMediaConvertUHDUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterIceMediaConvertUHDUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterIceMediaConvertUHDUsage(request: DescribeMeterIceMediaConvertUHDUsageRequest): DescribeMeterIceMediaConvertUHDUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterIceMediaConvertUHDUsageWithOptions(request, runtime);
}

model DescribeMeterIceMediaConvertUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: long(name='Interval'),
  region?: string(name='Region'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterIceMediaConvertUsageResponseBody = {
  data?: [ 
    {
      duration?: long(name='Duration'),
      specification?: string(name='Specification'),
      time?: long(name='Time'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMeterIceMediaConvertUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterIceMediaConvertUsageResponseBody(name='body'),
}

async function describeMeterIceMediaConvertUsageWithOptions(request: DescribeMeterIceMediaConvertUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterIceMediaConvertUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterIceMediaConvertUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterIceMediaConvertUsage(request: DescribeMeterIceMediaConvertUsageRequest): DescribeMeterIceMediaConvertUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterIceMediaConvertUsageWithOptions(request, runtime);
}

model DescribeMeterIceMpsAiUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: long(name='Interval'),
  region?: string(name='Region'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterIceMpsAiUsageResponseBody = {
  data?: [ 
    {
      duration?: long(name='Duration'),
      time?: long(name='Time'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMeterIceMpsAiUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterIceMpsAiUsageResponseBody(name='body'),
}

async function describeMeterIceMpsAiUsageWithOptions(request: DescribeMeterIceMpsAiUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterIceMpsAiUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterIceMpsAiUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterIceMpsAiUsage(request: DescribeMeterIceMpsAiUsageRequest): DescribeMeterIceMpsAiUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterIceMpsAiUsageWithOptions(request, runtime);
}

model DescribeMeterImsEditUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: long(name='Interval'),
  region?: string(name='Region'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterImsEditUsageResponseBody = {
  data?: [ 
    {
      duration?: long(name='Duration'),
      profile?: string(name='Profile'),
      time?: long(name='Time'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMeterImsEditUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterImsEditUsageResponseBody(name='body'),
}

async function describeMeterImsEditUsageWithOptions(request: DescribeMeterImsEditUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterImsEditUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterImsEditUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterImsEditUsage(request: DescribeMeterImsEditUsageRequest): DescribeMeterImsEditUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterImsEditUsageWithOptions(request, runtime);
}

model DescribeMeterImsLiveEditUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: long(name='Interval'),
  region?: string(name='Region'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterImsLiveEditUsageResponseBody = {
  data?: [ 
    {
      duration?: long(name='Duration'),
      profile?: string(name='Profile'),
      time?: long(name='Time'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMeterImsLiveEditUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterImsLiveEditUsageResponseBody(name='body'),
}

async function describeMeterImsLiveEditUsageWithOptions(request: DescribeMeterImsLiveEditUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterImsLiveEditUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterImsLiveEditUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterImsLiveEditUsage(request: DescribeMeterImsLiveEditUsageRequest): DescribeMeterImsLiveEditUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterImsLiveEditUsageWithOptions(request, runtime);
}

model DescribeMeterImsLiveMediaConvertUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: long(name='Interval'),
  region?: string(name='Region'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterImsLiveMediaConvertUsageResponseBody = {
  data?: [ 
    {
      duration?: long(name='Duration'),
      specification?: string(name='Specification'),
      time?: long(name='Time'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMeterImsLiveMediaConvertUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterImsLiveMediaConvertUsageResponseBody(name='body'),
}

async function describeMeterImsLiveMediaConvertUsageWithOptions(request: DescribeMeterImsLiveMediaConvertUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterImsLiveMediaConvertUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterImsLiveMediaConvertUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterImsLiveMediaConvertUsage(request: DescribeMeterImsLiveMediaConvertUsageRequest): DescribeMeterImsLiveMediaConvertUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterImsLiveMediaConvertUsageWithOptions(request, runtime);
}

model DescribeMeterImsLiveRecordUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: long(name='Interval'),
  region?: string(name='Region'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterImsLiveRecordUsageResponseBody = {
  data?: [ 
    {
      channels?: double(name='Channels'),
      duration?: long(name='Duration'),
      time?: long(name='Time'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMeterImsLiveRecordUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterImsLiveRecordUsageResponseBody(name='body'),
}

async function describeMeterImsLiveRecordUsageWithOptions(request: DescribeMeterImsLiveRecordUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterImsLiveRecordUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterImsLiveRecordUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterImsLiveRecordUsage(request: DescribeMeterImsLiveRecordUsageRequest): DescribeMeterImsLiveRecordUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterImsLiveRecordUsageWithOptions(request, runtime);
}

model DescribeMeterImsLiveSnapshotUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: long(name='Interval'),
  region?: string(name='Region'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterImsLiveSnapshotUsageResponseBody = {
  data?: [ 
    {
      count?: long(name='Count'),
      time?: long(name='Time'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMeterImsLiveSnapshotUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterImsLiveSnapshotUsageResponseBody(name='body'),
}

async function describeMeterImsLiveSnapshotUsageWithOptions(request: DescribeMeterImsLiveSnapshotUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterImsLiveSnapshotUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterImsLiveSnapshotUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterImsLiveSnapshotUsage(request: DescribeMeterImsLiveSnapshotUsageRequest): DescribeMeterImsLiveSnapshotUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterImsLiveSnapshotUsageWithOptions(request, runtime);
}

model DescribeMeterImsMediaConvertUHDUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: string(name='Interval'),
  regionId?: string(name='RegionId'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterImsMediaConvertUHDUsageResponseBody = {
  data?: [ 
    {
      duration?: long(name='Duration'),
      specification?: string(name='Specification'),
      time?: long(name='Time'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMeterImsMediaConvertUHDUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterImsMediaConvertUHDUsageResponseBody(name='body'),
}

async function describeMeterImsMediaConvertUHDUsageWithOptions(request: DescribeMeterImsMediaConvertUHDUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterImsMediaConvertUHDUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterImsMediaConvertUHDUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterImsMediaConvertUHDUsage(request: DescribeMeterImsMediaConvertUHDUsageRequest): DescribeMeterImsMediaConvertUHDUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterImsMediaConvertUHDUsageWithOptions(request, runtime);
}

model DescribeMeterImsMediaConvertUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: long(name='Interval'),
  region?: string(name='Region'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterImsMediaConvertUsageResponseBody = {
  data?: [ 
    {
      duration?: long(name='Duration'),
      specification?: string(name='Specification'),
      time?: long(name='Time'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMeterImsMediaConvertUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterImsMediaConvertUsageResponseBody(name='body'),
}

async function describeMeterImsMediaConvertUsageWithOptions(request: DescribeMeterImsMediaConvertUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterImsMediaConvertUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterImsMediaConvertUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterImsMediaConvertUsage(request: DescribeMeterImsMediaConvertUsageRequest): DescribeMeterImsMediaConvertUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterImsMediaConvertUsageWithOptions(request, runtime);
}

model DescribeMeterImsMpsAiUsageRequest {
  endTs?: long(name='EndTs'),
  interval?: long(name='Interval'),
  region?: string(name='Region'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterImsMpsAiUsageResponseBody = {
  data?: [ 
    {
      duration?: long(name='Duration'),
      time?: long(name='Time'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMeterImsMpsAiUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterImsMpsAiUsageResponseBody(name='body'),
}

async function describeMeterImsMpsAiUsageWithOptions(request: DescribeMeterImsMpsAiUsageRequest, runtime: Util.RuntimeOptions): DescribeMeterImsMpsAiUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterImsMpsAiUsage',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterImsMpsAiUsage(request: DescribeMeterImsMpsAiUsageRequest): DescribeMeterImsMpsAiUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterImsMpsAiUsageWithOptions(request, runtime);
}

model DescribeMeterImsSummaryRequest {
  endTs?: long(name='EndTs'),
  region?: string(name='Region'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterImsSummaryResponseBody = {
  data?: [ 
    {
      editingDuration?: string(name='EditingDuration'),
      liveEditDuration?: string(name='LiveEditDuration'),
      liveRecordDuration?: string(name='LiveRecordDuration'),
      liveSnapshotCount?: string(name='LiveSnapshotCount'),
      liveTranscodeDuration?: long(name='LiveTranscodeDuration'),
      mpsAiDuration?: long(name='MpsAiDuration'),
      mpsTranscodeDuration?: long(name='MpsTranscodeDuration'),
      mpsTranscodeUHDDuration?: long(name='MpsTranscodeUHDDuration'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMeterImsSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterImsSummaryResponseBody(name='body'),
}

async function describeMeterImsSummaryWithOptions(request: DescribeMeterImsSummaryRequest, runtime: Util.RuntimeOptions): DescribeMeterImsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterImsSummary',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterImsSummary(request: DescribeMeterImsSummaryRequest): DescribeMeterImsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterImsSummaryWithOptions(request, runtime);
}

model DescribePlayDetailRequest {
  playTs?: string(name='PlayTs'),
  sessionId?: string(name='SessionId'),
}

model DescribePlayDetailResponseBody = {
  baseInfos?: [ 
    {
      appName?: string(name='AppName'),
      bps?: string(name='Bps'),
      broadcastPace?: string(name='BroadcastPace'),
      clientIP?: string(name='ClientIP'),
      codec?: string(name='Codec'),
      decodeStuckTime?: string(name='DecodeStuckTime'),
      definition?: string(name='Definition'),
      firstFrameDuration?: string(name='FirstFrameDuration'),
      fps?: string(name='Fps'),
      isHardDecode?: string(name='IsHardDecode'),
      mdat?: string(name='Mdat'),
      moov?: string(name='Moov'),
      network?: string(name='Network'),
      networkDuration?: string(name='NetworkDuration'),
      networkStuckTime?: string(name='NetworkStuckTime'),
      os?: string(name='Os'),
      playTs?: string(name='PlayTs'),
      playerLoadDuration?: string(name='PlayerLoadDuration'),
      playerPreDealDuration?: string(name='PlayerPreDealDuration'),
      playerReadyDuration?: string(name='PlayerReadyDuration'),
      sdkVersion?: string(name='SdkVersion'),
      sessionId?: string(name='SessionId'),
      status?: string(name='Status'),
      terminalType?: string(name='TerminalType'),
    }
  ](name='BaseInfos'),
  requestId?: string(name='RequestId'),
}

model DescribePlayDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePlayDetailResponseBody(name='body'),
}

async function describePlayDetailWithOptions(request: DescribePlayDetailRequest, runtime: Util.RuntimeOptions): DescribePlayDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.playTs)) {
    query['PlayTs'] = request.playTs;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePlayDetail',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePlayDetail(request: DescribePlayDetailRequest): DescribePlayDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlayDetailWithOptions(request, runtime);
}

model DescribePlayEventListRequest {
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  playTs?: string(name='PlayTs'),
  sessionId?: string(name='SessionId'),
}

model DescribePlayEventListResponseBody = {
  eventList?: [ 
    {
      description?: string(name='Description'),
      duration?: float(name='Duration'),
      eventName?: string(name='EventName'),
      time?: long(name='Time'),
      topic?: string(name='Topic'),
    }
  ](name='EventList'),
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePlayEventListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePlayEventListResponseBody(name='body'),
}

async function describePlayEventListWithOptions(request: DescribePlayEventListRequest, runtime: Util.RuntimeOptions): DescribePlayEventListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.playTs)) {
    query['PlayTs'] = request.playTs;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePlayEventList',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePlayEventList(request: DescribePlayEventListRequest): DescribePlayEventListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlayEventListWithOptions(request, runtime);
}

model DescribePlayFirstFrameDurationMetricDataRequest {
  beginTs?: string(name='BeginTs'),
  endTs?: string(name='EndTs'),
  traceId?: string(name='TraceId'),
}

model DescribePlayFirstFrameDurationMetricDataResponseBody = {
  nodes?: [ 
    {
      x?: long(name='X'),
      y?: long(name='Y'),
    }
  ](name='Nodes'),
  requestId?: string(name='RequestId'),
}

model DescribePlayFirstFrameDurationMetricDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePlayFirstFrameDurationMetricDataResponseBody(name='body'),
}

async function describePlayFirstFrameDurationMetricDataWithOptions(request: DescribePlayFirstFrameDurationMetricDataRequest, runtime: Util.RuntimeOptions): DescribePlayFirstFrameDurationMetricDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.traceId)) {
    query['TraceId'] = request.traceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePlayFirstFrameDurationMetricData',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePlayFirstFrameDurationMetricData(request: DescribePlayFirstFrameDurationMetricDataRequest): DescribePlayFirstFrameDurationMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlayFirstFrameDurationMetricDataWithOptions(request, runtime);
}

model DescribePlayListRequest {
  beginTs?: string(name='BeginTs'),
  endTs?: string(name='EndTs'),
  orderName?: string(name='OrderName'),
  orderType?: string(name='OrderType'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  playType?: string(name='PlayType'),
  status?: string(name='Status'),
  traceId?: string(name='TraceId'),
}

model DescribePlayListResponseBody = {
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
  playList?: [ 
    {
      firstFrameDuration?: string(name='FirstFrameDuration'),
      playDuration?: string(name='PlayDuration'),
      playTs?: string(name='PlayTs'),
      playType?: string(name='PlayType'),
      sessionId?: string(name='SessionId'),
      status?: string(name='Status'),
      stuckDuration?: string(name='StuckDuration'),
      traceId?: string(name='TraceId'),
      videoDuration?: string(name='VideoDuration'),
      videoId?: string(name='VideoId'),
    }
  ](name='PlayList'),
  requestId?: string(name='RequestId'),
  totalNum?: long(name='TotalNum'),
}

model DescribePlayListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePlayListResponseBody(name='body'),
}

async function describePlayListWithOptions(request: DescribePlayListRequest, runtime: Util.RuntimeOptions): DescribePlayListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.orderName)) {
    query['OrderName'] = request.orderName;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.playType)) {
    query['PlayType'] = request.playType;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.traceId)) {
    query['TraceId'] = request.traceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePlayList',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePlayList(request: DescribePlayListRequest): DescribePlayListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlayListWithOptions(request, runtime);
}

model DescribePlayMetricDataRequest {
  appName?: string(name='AppName'),
  beginTs?: long(name='BeginTs'),
  definition?: string(name='Definition'),
  endTs?: long(name='EndTs'),
  experienceLevel?: string(name='ExperienceLevel'),
  itemConfigs?: string(name='ItemConfigs'),
  metricType?: string(name='MetricType'),
  network?: string(name='Network'),
  os?: string(name='Os'),
  sdkVersion?: string(name='SdkVersion'),
  terminalType?: string(name='TerminalType'),
}

model DescribePlayMetricDataResponseBody = {
  nodes?: [ 
    {
      x?: string(name='X'),
      y?: string(name='Y'),
    }
  ](name='Nodes'),
  requestId?: string(name='RequestId'),
  summaryData?: string(name='SummaryData'),
}

model DescribePlayMetricDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePlayMetricDataResponseBody(name='body'),
}

async function describePlayMetricDataWithOptions(request: DescribePlayMetricDataRequest, runtime: Util.RuntimeOptions): DescribePlayMetricDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.definition)) {
    query['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.experienceLevel)) {
    query['ExperienceLevel'] = request.experienceLevel;
  }
  if (!Util.isUnset(request.itemConfigs)) {
    query['ItemConfigs'] = request.itemConfigs;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.network)) {
    query['Network'] = request.network;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.sdkVersion)) {
    query['SdkVersion'] = request.sdkVersion;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePlayMetricData',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePlayMetricData(request: DescribePlayMetricDataRequest): DescribePlayMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlayMetricDataWithOptions(request, runtime);
}

model DescribePlayQoeListRequest {
  appName?: string(name='AppName'),
  beginTs?: long(name='BeginTs'),
  definition?: string(name='Definition'),
  endTs?: long(name='EndTs'),
  itemConfigs?: string(name='ItemConfigs'),
  metricTypes?: [ string ](name='MetricTypes'),
  network?: string(name='Network'),
  orderName?: string(name='OrderName'),
  orderType?: string(name='OrderType'),
  os?: string(name='Os'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  terminalType?: string(name='TerminalType'),
}

model DescribePlayQoeListShrinkRequest {
  appName?: string(name='AppName'),
  beginTs?: long(name='BeginTs'),
  definition?: string(name='Definition'),
  endTs?: long(name='EndTs'),
  itemConfigs?: string(name='ItemConfigs'),
  metricTypesShrink?: string(name='MetricTypes'),
  network?: string(name='Network'),
  orderName?: string(name='OrderName'),
  orderType?: string(name='OrderType'),
  os?: string(name='Os'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  terminalType?: string(name='TerminalType'),
}

model DescribePlayQoeListResponseBody = {
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  qoeInfoList?: [ 
    {
      qoeFinishedVV?: float(name='QoeFinishedVV'),
      qoeFinishedVVRate?: float(name='QoeFinishedVVRate'),
      qoeUFinishedVVTime?: float(name='QoeUFinishedVVTime'),
      qoeUV?: float(name='QoeUV'),
      qoeUVVDuration?: float(name='QoeUVVDuration'),
      qoeUVVTime?: float(name='QoeUVVTime'),
      qoeVDuration?: float(name='QoeVDuration'),
      qoeVVDuration?: float(name='QoeVVDuration'),
      traceId?: string(name='TraceId'),
    }
  ](name='QoeInfoList'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePlayQoeListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePlayQoeListResponseBody(name='body'),
}

async function describePlayQoeListWithOptions(tmpReq: DescribePlayQoeListRequest, runtime: Util.RuntimeOptions): DescribePlayQoeListResponse {
  Util.validateModel(tmpReq);
  var request = new DescribePlayQoeListShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.metricTypes)) {
    request.metricTypesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.metricTypes, 'MetricTypes', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.definition)) {
    query['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.itemConfigs)) {
    query['ItemConfigs'] = request.itemConfigs;
  }
  if (!Util.isUnset(request.metricTypesShrink)) {
    query['MetricTypes'] = request.metricTypesShrink;
  }
  if (!Util.isUnset(request.network)) {
    query['Network'] = request.network;
  }
  if (!Util.isUnset(request.orderName)) {
    query['OrderName'] = request.orderName;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePlayQoeList',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePlayQoeList(request: DescribePlayQoeListRequest): DescribePlayQoeListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlayQoeListWithOptions(request, runtime);
}

model DescribePlayQosListRequest {
  appName?: string(name='AppName'),
  beginTs?: string(name='BeginTs'),
  definition?: string(name='Definition'),
  endTs?: string(name='EndTs'),
  itemConfigs?: string(name='ItemConfigs'),
  metricTypes?: [ string ](name='MetricTypes'),
  network?: string(name='Network'),
  orderName?: string(name='OrderName'),
  orderType?: string(name='OrderType'),
  os?: string(name='Os'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  terminalType?: string(name='TerminalType'),
}

model DescribePlayQosListShrinkRequest {
  appName?: string(name='AppName'),
  beginTs?: string(name='BeginTs'),
  definition?: string(name='Definition'),
  endTs?: string(name='EndTs'),
  itemConfigs?: string(name='ItemConfigs'),
  metricTypesShrink?: string(name='MetricTypes'),
  network?: string(name='Network'),
  orderName?: string(name='OrderName'),
  orderType?: string(name='OrderType'),
  os?: string(name='Os'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  terminalType?: string(name='TerminalType'),
}

model DescribePlayQosListResponseBody = {
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  qosInfoList?: [ 
    {
      qosFirstFrame?: string(name='QosFirstFrame'),
      qosKbps?: string(name='QosKbps'),
      qosPlay?: string(name='QosPlay'),
      qosPlayFail?: string(name='QosPlayFail'),
      qosRealPlay?: string(name='QosRealPlay'),
      qosSeedFailRate?: string(name='QosSeedFailRate'),
      qosStuckRate?: string(name='QosStuckRate'),
      traceId?: string(name='TraceId'),
    }
  ](name='QosInfoList'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePlayQosListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePlayQosListResponseBody(name='body'),
}

async function describePlayQosListWithOptions(tmpReq: DescribePlayQosListRequest, runtime: Util.RuntimeOptions): DescribePlayQosListResponse {
  Util.validateModel(tmpReq);
  var request = new DescribePlayQosListShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.metricTypes)) {
    request.metricTypesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.metricTypes, 'MetricTypes', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.beginTs)) {
    query['BeginTs'] = request.beginTs;
  }
  if (!Util.isUnset(request.definition)) {
    query['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.itemConfigs)) {
    query['ItemConfigs'] = request.itemConfigs;
  }
  if (!Util.isUnset(request.metricTypesShrink)) {
    query['MetricTypes'] = request.metricTypesShrink;
  }
  if (!Util.isUnset(request.network)) {
    query['Network'] = request.network;
  }
  if (!Util.isUnset(request.orderName)) {
    query['OrderName'] = request.orderName;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.terminalType)) {
    query['TerminalType'] = request.terminalType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePlayQosList',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePlayQosList(request: DescribePlayQosListRequest): DescribePlayQosListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlayQosListWithOptions(request, runtime);
}

model DescribeQueryConfigsRequest {
  type?: string(name='Type'),
}

model DescribeQueryConfigsResponseBody = {
  configs?: [ 
    {
      value?: string(name='Value'),
    }
  ](name='Configs'),
  requestId?: string(name='RequestId'),
}

model DescribeQueryConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeQueryConfigsResponseBody(name='body'),
}

async function describeQueryConfigsWithOptions(request: DescribeQueryConfigsRequest, runtime: Util.RuntimeOptions): DescribeQueryConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeQueryConfigs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeQueryConfigs(request: DescribeQueryConfigsRequest): DescribeQueryConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeQueryConfigsWithOptions(request, runtime);
}

model DownloadResourceByResourceIdsRequest {
  resourceIds?: string(name='ResourceIds'),
}

model DownloadResourceByResourceIdsResponseBody = {
  expireTime?: long(name='ExpireTime'),
  requestId?: string(name='RequestId'),
  resourcePackageUrl?: string(name='ResourcePackageUrl'),
}

model DownloadResourceByResourceIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DownloadResourceByResourceIdsResponseBody(name='body'),
}

async function downloadResourceByResourceIdsWithOptions(request: DownloadResourceByResourceIdsRequest, runtime: Util.RuntimeOptions): DownloadResourceByResourceIdsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DownloadResourceByResourceIds',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function downloadResourceByResourceIds(request: DownloadResourceByResourceIdsRequest): DownloadResourceByResourceIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return downloadResourceByResourceIdsWithOptions(request, runtime);
}

model GetCategoriesRequest {
  cateId?: long(name='CateId'),
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  sortBy?: string(name='SortBy'),
  type?: string(name='Type'),
}

model GetCategoriesResponseBody = {
  category?: {
    cateId?: long(name='CateId'),
    cateName?: string(name='CateName'),
    level?: long(name='Level'),
    parentId?: long(name='ParentId'),
    type?: string(name='Type'),
  }(name='Category'),
  requestId?: string(name='RequestId'),
  subCategories?: {
    category?: [ 
    {
      cateId?: long(name='CateId'),
      cateName?: string(name='CateName'),
      level?: long(name='Level'),
      parentId?: long(name='ParentId'),
      subTotal?: long(name='SubTotal'),
      type?: string(name='Type'),
    }
  ](name='Category')
  }(name='SubCategories'),
  subTotal?: long(name='SubTotal'),
}

model GetCategoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCategoriesResponseBody(name='body'),
}

async function getCategoriesWithOptions(request: GetCategoriesRequest, runtime: Util.RuntimeOptions): GetCategoriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCategories',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCategories(request: GetCategoriesRequest): GetCategoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCategoriesWithOptions(request, runtime);
}

model GetCustomTemplateRequest {
  subtype?: int32(name='Subtype'),
  templateId?: string(name='TemplateId'),
  type?: int32(name='Type'),
}

model GetCustomTemplateResponseBody = {
  customTemplate?: {
    createTime?: string(name='CreateTime'),
    isDefault?: boolean(name='IsDefault'),
    modifiedTime?: string(name='ModifiedTime'),
    status?: string(name='Status'),
    subtype?: int32(name='Subtype'),
    subtypeName?: string(name='SubtypeName'),
    templateConfig?: string(name='TemplateConfig'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    type?: int32(name='Type'),
    typeName?: string(name='TypeName'),
  }(name='CustomTemplate'),
  requestId?: string(name='RequestId'),
}

model GetCustomTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCustomTemplateResponseBody(name='body'),
}

async function getCustomTemplateWithOptions(request: GetCustomTemplateRequest, runtime: Util.RuntimeOptions): GetCustomTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.subtype)) {
    query['Subtype'] = request.subtype;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCustomTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCustomTemplate(request: GetCustomTemplateRequest): GetCustomTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCustomTemplateWithOptions(request, runtime);
}

model GetDefaultStorageLocationResponseBody = {
  bucket?: string(name='Bucket'),
  path?: string(name='Path'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  storageType?: string(name='StorageType'),
}

model GetDefaultStorageLocationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDefaultStorageLocationResponseBody(name='body'),
}

async function getDefaultStorageLocationWithOptions(runtime: Util.RuntimeOptions): GetDefaultStorageLocationResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetDefaultStorageLocation',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDefaultStorageLocation(): GetDefaultStorageLocationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDefaultStorageLocationWithOptions(runtime);
}

model GetDynamicImageJobRequest {
  jobId?: string(name='JobId'),
}

model GetDynamicImageJobResponseBody = {
  dynamicImageJob?: {
    code?: string(name='Code'),
    createTime?: string(name='CreateTime'),
    finishTime?: string(name='FinishTime'),
    input?: {
      media?: string(name='Media'),
      ossFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='OssFile'),
      type?: string(name='Type'),
    }(name='Input'),
    jobId?: string(name='JobId'),
    message?: string(name='Message'),
    modifiedTime?: string(name='ModifiedTime'),
    name?: string(name='Name'),
    output?: {
      media?: string(name='Media'),
      ossFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='OssFile'),
      type?: string(name='Type'),
    }(name='Output'),
    outputUrl?: string(name='OutputUrl'),
    pipelineId?: string(name='PipelineId'),
    status?: string(name='Status'),
    submitTime?: string(name='SubmitTime'),
    templateConfig?: string(name='TemplateConfig'),
    templateId?: string(name='TemplateId'),
    triggerSource?: string(name='TriggerSource'),
    userData?: string(name='UserData'),
  }(name='DynamicImageJob'),
  requestId?: string(name='RequestId'),
}

model GetDynamicImageJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDynamicImageJobResponseBody(name='body'),
}

async function getDynamicImageJobWithOptions(request: GetDynamicImageJobRequest, runtime: Util.RuntimeOptions): GetDynamicImageJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDynamicImageJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDynamicImageJob(request: GetDynamicImageJobRequest): GetDynamicImageJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDynamicImageJobWithOptions(request, runtime);
}

model GetEditingProjectRequest {
  projectId?: string(name='ProjectId'),
  requestSource?: string(name='RequestSource'),
}

model GetEditingProjectResponseBody = {
  project?: {
    businessConfig?: string(name='BusinessConfig'),
    businessStatus?: string(name='BusinessStatus'),
    clipsParam?: string(name='ClipsParam'),
    coverURL?: string(name='CoverURL'),
    createSource?: string(name='CreateSource'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    duration?: long(name='Duration'),
    modifiedSource?: string(name='ModifiedSource'),
    modifiedTime?: string(name='ModifiedTime'),
    projectId?: string(name='ProjectId'),
    projectType?: string(name='ProjectType'),
    status?: string(name='Status'),
    templateId?: string(name='TemplateId'),
    templateType?: string(name='TemplateType'),
    timeline?: string(name='Timeline'),
    title?: string(name='Title'),
  }(name='Project'),
  requestId?: string(name='RequestId'),
}

model GetEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEditingProjectResponseBody(name='body'),
}

async function getEditingProjectWithOptions(request: GetEditingProjectRequest, runtime: Util.RuntimeOptions): GetEditingProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.requestSource)) {
    query['RequestSource'] = request.requestSource;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEditingProject',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEditingProject(request: GetEditingProjectRequest): GetEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEditingProjectWithOptions(request, runtime);
}

model GetEditingProjectMaterialsRequest {
  projectId?: string(name='ProjectId'),
}

model GetEditingProjectMaterialsResponseBody = {
  liveMaterials?: [ 
    {
      appName?: string(name='AppName'),
      domainName?: string(name='DomainName'),
      liveUrl?: string(name='LiveUrl'),
      streamName?: string(name='StreamName'),
    }
  ](name='LiveMaterials'),
  mediaInfos?: [ 
    {
      fileInfoList?: [ 
        {
          fileBasicInfo?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            fileName?: string(name='FileName'),
            fileSize?: string(name='FileSize'),
            fileStatus?: string(name='FileStatus'),
            fileType?: string(name='FileType'),
            fileUrl?: string(name='FileUrl'),
            formatName?: string(name='FormatName'),
            height?: string(name='Height'),
            region?: string(name='Region'),
            width?: string(name='Width'),
          }(name='FileBasicInfo'),
        }
      ](name='FileInfoList'),
      mediaBasicInfo?: {
        businessType?: string(name='BusinessType'),
        category?: string(name='Category'),
        coverURL?: string(name='CoverURL'),
        createTime?: string(name='CreateTime'),
        deletedTime?: string(name='DeletedTime'),
        description?: string(name='Description'),
        inputURL?: string(name='InputURL'),
        mediaId?: string(name='MediaId'),
        mediaTags?: string(name='MediaTags'),
        mediaType?: string(name='MediaType'),
        modifiedTime?: string(name='ModifiedTime'),
        snapshots?: string(name='Snapshots'),
        source?: string(name='Source'),
        spriteImages?: string(name='SpriteImages'),
        status?: string(name='Status'),
        title?: string(name='Title'),
        transcodeStatus?: string(name='TranscodeStatus'),
        userData?: string(name='UserData'),
      }(name='MediaBasicInfo'),
      mediaId?: string(name='MediaId'),
    }
  ](name='MediaInfos'),
  projectId?: string(name='ProjectId'),
  projectMaterials?: [ string ](name='ProjectMaterials'),
  requestId?: string(name='RequestId'),
}

model GetEditingProjectMaterialsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEditingProjectMaterialsResponseBody(name='body'),
}

async function getEditingProjectMaterialsWithOptions(request: GetEditingProjectMaterialsRequest, runtime: Util.RuntimeOptions): GetEditingProjectMaterialsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEditingProjectMaterials',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEditingProjectMaterials(request: GetEditingProjectMaterialsRequest): GetEditingProjectMaterialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEditingProjectMaterialsWithOptions(request, runtime);
}

model GetEventCallbackResponseBody = {
  authKey?: string(name='AuthKey'),
  authSwitch?: string(name='AuthSwitch'),
  callbackQueueName?: string(name='CallbackQueueName'),
  callbackType?: string(name='CallbackType'),
  callbackURL?: string(name='CallbackURL'),
  eventTypeList?: string(name='EventTypeList'),
  requestId?: string(name='RequestId'),
}

model GetEventCallbackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEventCallbackResponseBody(name='body'),
}

async function getEventCallbackWithOptions(runtime: Util.RuntimeOptions): GetEventCallbackResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetEventCallback',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEventCallback(): GetEventCallbackResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEventCallbackWithOptions(runtime);
}

model GetLiveEditingIndexFileRequest {
  appName?: string(name='AppName'),
  domainName?: string(name='DomainName'),
  projectId?: string(name='ProjectId'),
  streamName?: string(name='StreamName'),
}

model GetLiveEditingIndexFileResponseBody = {
  indexFile?: string(name='IndexFile'),
  requestId?: string(name='RequestId'),
}

model GetLiveEditingIndexFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveEditingIndexFileResponseBody(name='body'),
}

async function getLiveEditingIndexFileWithOptions(request: GetLiveEditingIndexFileRequest, runtime: Util.RuntimeOptions): GetLiveEditingIndexFileResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLiveEditingIndexFile',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLiveEditingIndexFile(request: GetLiveEditingIndexFileRequest): GetLiveEditingIndexFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveEditingIndexFileWithOptions(request, runtime);
}

model GetLiveEditingJobRequest {
  jobId?: string(name='JobId'),
}

model GetLiveEditingJobResponseBody = {
  liveEditingJob?: {
    clips?: string(name='Clips'),
    code?: string(name='Code'),
    completeTime?: string(name='CompleteTime'),
    creationTime?: string(name='CreationTime'),
    jobId?: string(name='JobId'),
    liveStreamConfig?: {
      appName?: string(name='AppName'),
      domainName?: string(name='DomainName'),
      streamName?: string(name='StreamName'),
    }(name='LiveStreamConfig'),
    mediaId?: string(name='MediaId'),
    mediaProduceConfig?: {
      mode?: string(name='Mode'),
    }(name='MediaProduceConfig'),
    mediaURL?: string(name='MediaURL'),
    message?: string(name='Message'),
    modifiedTime?: string(name='ModifiedTime'),
    outputMediaConfig?: {
      bitrate?: long(name='Bitrate'),
      fileName?: string(name='FileName'),
      height?: int32(name='Height'),
      mediaURL?: string(name='MediaURL'),
      storageLocation?: string(name='StorageLocation'),
      vodTemplateGroupId?: string(name='VodTemplateGroupId'),
      width?: int32(name='Width'),
    }(name='OutputMediaConfig'),
    projectId?: string(name='ProjectId'),
    status?: string(name='Status'),
    userData?: string(name='UserData'),
  }(name='LiveEditingJob'),
  requestId?: string(name='RequestId'),
}

model GetLiveEditingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveEditingJobResponseBody(name='body'),
}

async function getLiveEditingJobWithOptions(request: GetLiveEditingJobRequest, runtime: Util.RuntimeOptions): GetLiveEditingJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLiveEditingJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLiveEditingJob(request: GetLiveEditingJobRequest): GetLiveEditingJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveEditingJobWithOptions(request, runtime);
}

model GetLiveRecordJobRequest {
  jobId?: string(name='JobId'),
}

model GetLiveRecordJobResponseBody = {
  recordJob?: {
    createTime?: string(name='CreateTime'),
    jobId?: string(name='JobId'),
    name?: string(name='Name'),
    notifyUrl?: string(name='NotifyUrl'),
    recordOutput?: {
      bucket?: string(name='Bucket'),
      endpoint?: string(name='Endpoint'),
      type?: string(name='Type'),
    }(name='RecordOutput'),
    status?: string(name='Status'),
    streamInput?: {
      type?: string(name='Type'),
      url?: string(name='Url'),
    }(name='StreamInput'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
  }(name='RecordJob'),
  requestId?: string(name='RequestId'),
}

model GetLiveRecordJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveRecordJobResponseBody(name='body'),
}

async function getLiveRecordJobWithOptions(request: GetLiveRecordJobRequest, runtime: Util.RuntimeOptions): GetLiveRecordJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLiveRecordJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLiveRecordJob(request: GetLiveRecordJobRequest): GetLiveRecordJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveRecordJobWithOptions(request, runtime);
}

model GetLiveRecordTemplateRequest {
  jobId?: string(name='JobId'),
  templateId?: string(name='TemplateId'),
}

model GetLiveRecordTemplateResponseBody = {
  recordTemplate?: {
    createTime?: string(name='CreateTime'),
    lastModified?: string(name='LastModified'),
    name?: string(name='Name'),
    recordFormatList?: [ 
      {
        cycleDuration?: int32(name='CycleDuration'),
        format?: string(name='Format'),
        ossObjectPrefix?: string(name='OssObjectPrefix'),
        sliceDuration?: int32(name='SliceDuration'),
        sliceOssObjectPrefix?: string(name='SliceOssObjectPrefix'),
      }
    ](name='RecordFormatList'),
    templateId?: string(name='TemplateId'),
    type?: string(name='Type'),
  }(name='RecordTemplate'),
  requestId?: string(name='RequestId'),
}

model GetLiveRecordTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveRecordTemplateResponseBody(name='body'),
}

async function getLiveRecordTemplateWithOptions(request: GetLiveRecordTemplateRequest, runtime: Util.RuntimeOptions): GetLiveRecordTemplateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLiveRecordTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLiveRecordTemplate(request: GetLiveRecordTemplateRequest): GetLiveRecordTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveRecordTemplateWithOptions(request, runtime);
}

model GetLiveSnapshotJobRequest {
  jobId?: string(name='JobId'),
}

model GetLiveSnapshotJobResponseBody = {
  callbackUrl?: string(name='CallbackUrl'),
  createTime?: string(name='CreateTime'),
  jobId?: string(name='JobId'),
  jobName?: string(name='JobName'),
  lastModified?: string(name='LastModified'),
  overwriteFormat?: string(name='OverwriteFormat'),
  requestId?: string(name='RequestId'),
  sequenceFormat?: string(name='SequenceFormat'),
  snapshotOutput?: {
    bucket?: string(name='Bucket'),
    endpoint?: string(name='Endpoint'),
    storageType?: string(name='StorageType'),
  }(name='SnapshotOutput'),
  status?: string(name='Status'),
  streamInput?: {
    type?: string(name='Type'),
    url?: string(name='Url'),
  }(name='StreamInput'),
  templateId?: string(name='TemplateId'),
  templateName?: string(name='TemplateName'),
  timeInterval?: int32(name='TimeInterval'),
}

model GetLiveSnapshotJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveSnapshotJobResponseBody(name='body'),
}

async function getLiveSnapshotJobWithOptions(request: GetLiveSnapshotJobRequest, runtime: Util.RuntimeOptions): GetLiveSnapshotJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLiveSnapshotJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLiveSnapshotJob(request: GetLiveSnapshotJobRequest): GetLiveSnapshotJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveSnapshotJobWithOptions(request, runtime);
}

model GetLiveSnapshotTemplateRequest {
  templateId?: string(name='TemplateId'),
}

model GetLiveSnapshotTemplateResponseBody = {
  createTime?: string(name='CreateTime'),
  lastModified?: string(name='LastModified'),
  overwriteFormat?: string(name='OverwriteFormat'),
  requestId?: string(name='RequestId'),
  sequenceFormat?: string(name='SequenceFormat'),
  templateId?: string(name='TemplateId'),
  templateName?: string(name='TemplateName'),
  timeInterval?: int32(name='TimeInterval'),
  type?: string(name='Type'),
}

model GetLiveSnapshotTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveSnapshotTemplateResponseBody(name='body'),
}

async function getLiveSnapshotTemplateWithOptions(request: GetLiveSnapshotTemplateRequest, runtime: Util.RuntimeOptions): GetLiveSnapshotTemplateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLiveSnapshotTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLiveSnapshotTemplate(request: GetLiveSnapshotTemplateRequest): GetLiveSnapshotTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveSnapshotTemplateWithOptions(request, runtime);
}

model GetLiveTranscodeJobRequest {
  jobId?: string(name='JobId'),
}

model GetLiveTranscodeJobResponseBody = {
  job?: {
    createTime?: string(name='CreateTime'),
    jobId?: string(name='JobId'),
    name?: string(name='Name'),
    outputStream?: {
      streamInfos?: [ 
        {
          outputUrl?: string(name='OutputUrl'),
          type?: string(name='Type'),
        }
      ](name='StreamInfos'),
    }(name='OutputStream'),
    startMode?: int32(name='StartMode'),
    status?: int32(name='Status'),
    streamInput?: {
      inputUrl?: string(name='InputUrl'),
      type?: string(name='Type'),
    }(name='StreamInput'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateType?: string(name='TemplateType'),
  }(name='Job'),
  requestId?: string(name='RequestId'),
}

model GetLiveTranscodeJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveTranscodeJobResponseBody(name='body'),
}

async function getLiveTranscodeJobWithOptions(request: GetLiveTranscodeJobRequest, runtime: Util.RuntimeOptions): GetLiveTranscodeJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLiveTranscodeJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLiveTranscodeJob(request: GetLiveTranscodeJobRequest): GetLiveTranscodeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveTranscodeJobWithOptions(request, runtime);
}

model GetLiveTranscodeTemplateRequest {
  templateId?: string(name='TemplateId'),
}

model GetLiveTranscodeTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateContent?: {
    category?: string(name='Category'),
    createTime?: string(name='CreateTime'),
    name?: string(name='Name'),
    templateConfig?: {
      audioParams?: {
        bitrate?: string(name='Bitrate'),
        channels?: string(name='Channels'),
        codec?: string(name='Codec'),
        profile?: string(name='Profile'),
        samplerate?: string(name='Samplerate'),
      }(name='AudioParams'),
      videoParams?: {
        bitrate?: string(name='Bitrate'),
        codec?: string(name='Codec'),
        fps?: string(name='Fps'),
        gop?: string(name='Gop'),
        height?: string(name='Height'),
        profile?: string(name='Profile'),
        width?: string(name='Width'),
      }(name='VideoParams'),
    }(name='TemplateConfig'),
    templateId?: string(name='TemplateId'),
    type?: string(name='Type'),
  }(name='TemplateContent'),
}

model GetLiveTranscodeTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveTranscodeTemplateResponseBody(name='body'),
}

async function getLiveTranscodeTemplateWithOptions(request: GetLiveTranscodeTemplateRequest, runtime: Util.RuntimeOptions): GetLiveTranscodeTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLiveTranscodeTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLiveTranscodeTemplate(request: GetLiveTranscodeTemplateRequest): GetLiveTranscodeTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveTranscodeTemplateWithOptions(request, runtime);
}

model GetMediaAuditResultRequest {
  appId?: string(name='AppId'),
  mediaId?: string(name='MediaId'),
}

model GetMediaAuditResultResponseBody = {
  audioResult?: {
    label?: string(name='Label'),
    scene?: string(name='Scene'),
    score?: string(name='Score'),
    suggestion?: string(name='Suggestion'),
  }(name='AudioResult'),
  coverResult?: {
    label?: string(name='Label'),
    scene?: string(name='Scene'),
    score?: string(name='Score'),
    suggestion?: string(name='Suggestion'),
  }(name='CoverResult'),
  descResult?: {
    label?: string(name='Label'),
    scene?: string(name='Scene'),
    score?: string(name='Score'),
    suggestion?: string(name='Suggestion'),
  }(name='DescResult'),
  mediaAuditResult?: {
    abnormalModules?: string(name='AbnormalModules'),
    label?: string(name='Label'),
    suggestion?: string(name='Suggestion'),
  }(name='MediaAuditResult'),
  requestId?: string(name='RequestId'),
  titleResult?: {
    label?: string(name='Label'),
    scene?: string(name='Scene'),
    score?: string(name='Score'),
    suggestion?: string(name='Suggestion'),
  }(name='TitleResult'),
  videoResult?: {
    label?: string(name='Label'),
    scene?: string(name='Scene'),
    score?: string(name='Score'),
    suggestion?: string(name='Suggestion'),
  }(name='VideoResult'),
}

model GetMediaAuditResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMediaAuditResultResponseBody(name='body'),
}

async function getMediaAuditResultWithOptions(request: GetMediaAuditResultRequest, runtime: Util.RuntimeOptions): GetMediaAuditResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMediaAuditResult',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMediaAuditResult(request: GetMediaAuditResultRequest): GetMediaAuditResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaAuditResultWithOptions(request, runtime);
}

model GetMediaAuditResultDetailRequest {
  appId?: string(name='AppId'),
  mediaId?: string(name='MediaId'),
}

model GetMediaAuditResultDetailResponseBody = {
  auditResultDetails?: [ 
    {
      adLabel?: string(name='AdLabel'),
      adScore?: string(name='AdScore'),
      liveLabel?: string(name='LiveLabel'),
      liveScore?: string(name='LiveScore'),
      logoLabel?: string(name='LogoLabel'),
      logoScore?: string(name='LogoScore'),
      pornLabel?: string(name='PornLabel'),
      pornScore?: string(name='PornScore'),
      terrorismLabel?: string(name='TerrorismLabel'),
      terrorismScore?: string(name='TerrorismScore'),
      timestamp?: string(name='Timestamp'),
      url?: string(name='Url'),
    }
  ](name='AuditResultDetails'),
  requestId?: string(name='RequestId'),
  total?: string(name='Total'),
}

model GetMediaAuditResultDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMediaAuditResultDetailResponseBody(name='body'),
}

async function getMediaAuditResultDetailWithOptions(request: GetMediaAuditResultDetailRequest, runtime: Util.RuntimeOptions): GetMediaAuditResultDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMediaAuditResultDetail',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMediaAuditResultDetail(request: GetMediaAuditResultDetailRequest): GetMediaAuditResultDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaAuditResultDetailWithOptions(request, runtime);
}

model GetMediaInfoRequest {
  inputURL?: string(name='InputURL'),
  mediaId?: string(name='MediaId'),
  outputType?: string(name='OutputType'),
}

model GetMediaInfoResponseBody = {
  mediaInfo?: {
    fileInfoList?: [ 
      {
        audioStreamInfoList?: [ 
          {
            bitrate?: string(name='Bitrate'),
            channelLayout?: string(name='ChannelLayout'),
            channels?: string(name='Channels'),
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            duration?: string(name='Duration'),
            fps?: string(name='Fps'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            numFrames?: string(name='NumFrames'),
            profile?: string(name='Profile'),
            sampleFmt?: string(name='SampleFmt'),
            sampleRate?: string(name='SampleRate'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
          }
        ](name='AudioStreamInfoList'),
        fileBasicInfo?: {
          bitrate?: string(name='Bitrate'),
          createTime?: string(name='CreateTime'),
          duration?: string(name='Duration'),
          fileName?: string(name='FileName'),
          fileSize?: string(name='FileSize'),
          fileStatus?: string(name='FileStatus'),
          fileType?: string(name='FileType'),
          fileUrl?: string(name='FileUrl'),
          formatName?: string(name='FormatName'),
          height?: string(name='Height'),
          modifiedTime?: string(name='ModifiedTime'),
          region?: string(name='Region'),
          width?: string(name='Width'),
        }(name='FileBasicInfo'),
        subtitleStreamInfoList?: [ 
          {
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            duration?: string(name='Duration'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
          }
        ](name='SubtitleStreamInfoList'),
        videoStreamInfoList?: [ 
          {
            avgFPS?: string(name='AvgFPS'),
            bitrate?: string(name='Bitrate'),
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            dar?: string(name='Dar'),
            duration?: string(name='Duration'),
            fps?: string(name='Fps'),
            hasBFrames?: string(name='HasBFrames'),
            height?: string(name='Height'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            level?: string(name='Level'),
            nbFrames?: string(name='Nb_frames'),
            numFrames?: string(name='NumFrames'),
            pixFmt?: string(name='PixFmt'),
            profile?: string(name='Profile'),
            rotate?: string(name='Rotate'),
            sar?: string(name='Sar'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
            width?: string(name='Width'),
          }
        ](name='VideoStreamInfoList'),
      }
    ](name='FileInfoList'),
    mediaBasicInfo?: {
      biz?: string(name='Biz'),
      businessType?: string(name='BusinessType'),
      cateId?: long(name='CateId'),
      cateName?: string(name='CateName'),
      category?: string(name='Category'),
      coverURL?: string(name='CoverURL'),
      createTime?: string(name='CreateTime'),
      deletedTime?: string(name='DeletedTime'),
      description?: string(name='Description'),
      inputURL?: string(name='InputURL'),
      mediaId?: string(name='MediaId'),
      mediaTags?: string(name='MediaTags'),
      mediaType?: string(name='MediaType'),
      modifiedTime?: string(name='ModifiedTime'),
      referenceId?: string(name='ReferenceId'),
      source?: string(name='Source'),
      spriteImages?: string(name='SpriteImages'),
      status?: string(name='Status'),
      title?: string(name='Title'),
      uploadSource?: string(name='UploadSource'),
      userData?: string(name='UserData'),
    }(name='MediaBasicInfo'),
    mediaId?: string(name='MediaId'),
  }(name='MediaInfo'),
  requestId?: string(name='RequestId'),
}

model GetMediaInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMediaInfoResponseBody(name='body'),
}

async function getMediaInfoWithOptions(request: GetMediaInfoRequest, runtime: Util.RuntimeOptions): GetMediaInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.inputURL)) {
    query['InputURL'] = request.inputURL;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.outputType)) {
    query['OutputType'] = request.outputType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMediaInfo',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMediaInfo(request: GetMediaInfoRequest): GetMediaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaInfoWithOptions(request, runtime);
}

model GetMediaInfoJobRequest {
  jobId?: string(name='JobId'),
}

model GetMediaInfoJobResponseBody = {
  mediaInfoJob?: {
    async?: boolean(name='Async'),
    finishTime?: string(name='FinishTime'),
    input?: {
      media?: string(name='Media'),
      type?: string(name='Type'),
    }(name='Input'),
    jobId?: string(name='JobId'),
    mediaInfoProperty?: {
      audioStreamInfoList?: [ 
        {
          bitrate?: string(name='Bitrate'),
          channelLayout?: string(name='ChannelLayout'),
          channels?: string(name='Channels'),
          codecLongName?: string(name='CodecLongName'),
          codecName?: string(name='CodecName'),
          codecTag?: string(name='CodecTag'),
          codecTagString?: string(name='CodecTagString'),
          codecTimeBase?: string(name='CodecTimeBase'),
          duration?: string(name='Duration'),
          index?: string(name='Index'),
          lang?: string(name='Lang'),
          sampleFmt?: string(name='SampleFmt'),
          sampleRate?: string(name='SampleRate'),
          startTime?: string(name='StartTime'),
          timebase?: string(name='Timebase'),
        }
      ](name='AudioStreamInfoList'),
      fileBasicInfo?: {
        bitrate?: string(name='Bitrate'),
        duration?: string(name='Duration'),
        fileName?: string(name='FileName'),
        fileSize?: string(name='FileSize'),
        fileStatus?: string(name='FileStatus'),
        fileType?: string(name='FileType'),
        fileUrl?: string(name='FileUrl'),
        formatName?: string(name='FormatName'),
        height?: string(name='Height'),
        mediaId?: string(name='MediaId'),
        region?: string(name='Region'),
        width?: string(name='Width'),
      }(name='FileBasicInfo'),
      videoStreamInfoList?: [ 
        {
          avgFps?: string(name='Avg_fps'),
          bitRate?: string(name='Bit_rate'),
          codecLongName?: string(name='Codec_long_name'),
          codecName?: string(name='Codec_name'),
          codecTag?: string(name='Codec_tag'),
          codecTagString?: string(name='Codec_tag_string'),
          codecTimeBase?: string(name='Codec_time_base'),
          dar?: string(name='Dar'),
          duration?: string(name='Duration'),
          fps?: string(name='Fps'),
          hasBFrames?: string(name='Has_b_frames'),
          height?: string(name='Height'),
          index?: string(name='Index'),
          lang?: string(name='Lang'),
          level?: string(name='Level'),
          numFrames?: string(name='NumFrames'),
          pixFmt?: string(name='PixFmt'),
          profile?: string(name='Profile'),
          rotate?: string(name='Rotate'),
          sar?: string(name='Sar'),
          startTime?: string(name='Start_time'),
          timeBase?: string(name='Time_base'),
          width?: string(name='Width'),
        }
      ](name='VideoStreamInfoList'),
    }(name='MediaInfoProperty'),
    name?: string(name='Name'),
    requestId?: string(name='RequestId'),
    scheduleConfig?: {
      pipelineId?: string(name='PipelineId'),
      priority?: int32(name='Priority'),
    }(name='ScheduleConfig'),
    status?: string(name='Status'),
    submitResultJson?: map[string]any(name='SubmitResultJson'),
    submitTime?: string(name='SubmitTime'),
    triggerSource?: string(name='TriggerSource'),
    userData?: string(name='UserData'),
  }(name='MediaInfoJob'),
  requestId?: string(name='RequestId'),
}

model GetMediaInfoJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMediaInfoJobResponseBody(name='body'),
}

async function getMediaInfoJobWithOptions(request: GetMediaInfoJobRequest, runtime: Util.RuntimeOptions): GetMediaInfoJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMediaInfoJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMediaInfoJob(request: GetMediaInfoJobRequest): GetMediaInfoJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaInfoJobWithOptions(request, runtime);
}

model GetMediaMarksRequest {
  mediaId?: string(name='MediaId'),
  mediaMarkIds?: string(name='MediaMarkIds'),
}

model GetMediaMarksResponseBody = {
  mediaId?: string(name='MediaId'),
  mediaMarks?: string(name='MediaMarks'),
  requestId?: string(name='RequestId'),
}

model GetMediaMarksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMediaMarksResponseBody(name='body'),
}

async function getMediaMarksWithOptions(request: GetMediaMarksRequest, runtime: Util.RuntimeOptions): GetMediaMarksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.mediaMarkIds)) {
    query['MediaMarkIds'] = request.mediaMarkIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMediaMarks',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMediaMarks(request: GetMediaMarksRequest): GetMediaMarksResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaMarksWithOptions(request, runtime);
}

model GetMediaProducingJobRequest {
  jobId?: string(name='JobId'),
}

model GetMediaProducingJobResponseBody = {
  mediaProducingJob?: {
    clipsParam?: string(name='ClipsParam'),
    code?: string(name='Code'),
    completeTime?: string(name='CompleteTime'),
    createTime?: string(name='CreateTime'),
    duration?: float(name='Duration'),
    jobId?: string(name='JobId'),
    mediaId?: string(name='MediaId'),
    mediaURL?: string(name='MediaURL'),
    message?: string(name='Message'),
    modifiedTime?: string(name='ModifiedTime'),
    projectId?: string(name='ProjectId'),
    status?: string(name='Status'),
    templateId?: string(name='TemplateId'),
    timeline?: string(name='Timeline'),
    vodMediaId?: string(name='VodMediaId'),
  }(name='MediaProducingJob'),
  requestId?: string(name='RequestId'),
}

model GetMediaProducingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMediaProducingJobResponseBody(name='body'),
}

async function getMediaProducingJobWithOptions(request: GetMediaProducingJobRequest, runtime: Util.RuntimeOptions): GetMediaProducingJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMediaProducingJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMediaProducingJob(request: GetMediaProducingJobRequest): GetMediaProducingJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaProducingJobWithOptions(request, runtime);
}

model GetPackageJobRequest {
  jobId?: string(name='JobId'),
}

model GetPackageJobResponseBody = {
  packageJob?: {
    code?: string(name='Code'),
    createTime?: string(name='CreateTime'),
    finishTime?: string(name='FinishTime'),
    inputs?: [ 
      {
        input?: {
          media?: string(name='Media'),
          type?: string(name='Type'),
        }(name='Input'),
      }
    ](name='Inputs'),
    jobId?: string(name='JobId'),
    message?: string(name='Message'),
    modifiedTime?: string(name='ModifiedTime'),
    name?: string(name='Name'),
    output?: {
      media?: string(name='Media'),
      type?: string(name='Type'),
    }(name='Output'),
    outputUrl?: string(name='OutputUrl'),
    pipelineId?: string(name='PipelineId'),
    priority?: int32(name='Priority'),
    status?: string(name='Status'),
    submitTime?: string(name='SubmitTime'),
    triggerSource?: string(name='TriggerSource'),
    userData?: string(name='UserData'),
  }(name='PackageJob'),
  requestId?: string(name='RequestId'),
}

model GetPackageJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPackageJobResponseBody(name='body'),
}

async function getPackageJobWithOptions(request: GetPackageJobRequest, runtime: Util.RuntimeOptions): GetPackageJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPackageJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPackageJob(request: GetPackageJobRequest): GetPackageJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPackageJobWithOptions(request, runtime);
}

model GetPipelineRequest {
  pipelineId?: string(name='PipelineId'),
}

model GetPipelineResponseBody = {
  pipeline?: {
    createTime?: string(name='CreateTime'),
    modifiedTime?: string(name='ModifiedTime'),
    name?: string(name='Name'),
    pipelineId?: string(name='PipelineId'),
    priority?: int32(name='Priority'),
    speed?: string(name='Speed'),
    status?: string(name='Status'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model GetPipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPipelineResponseBody(name='body'),
}

async function getPipelineWithOptions(request: GetPipelineRequest, runtime: Util.RuntimeOptions): GetPipelineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPipeline',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPipeline(request: GetPipelineRequest): GetPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPipelineWithOptions(request, runtime);
}

model GetPlayInfoRequest {
  mediaId?: string(name='MediaId'),
}

model GetPlayInfoResponseBody = {
  mediaBase?: {
    coverURL?: string(name='CoverURL'),
    creationTime?: string(name='CreationTime'),
    mediaId?: string(name='MediaId'),
    mediaType?: string(name='MediaType'),
    status?: string(name='Status'),
    title?: string(name='Title'),
  }(name='MediaBase'),
  playInfoList?: [ 
    {
      bitDepth?: int32(name='BitDepth'),
      bitrate?: string(name='Bitrate'),
      creationTime?: string(name='CreationTime'),
      definition?: string(name='Definition'),
      duration?: string(name='Duration'),
      encrypt?: long(name='Encrypt'),
      encryptType?: string(name='EncryptType'),
      fileURL?: string(name='FileURL'),
      format?: string(name='Format'),
      fps?: string(name='Fps'),
      HDRType?: string(name='HDRType'),
      height?: long(name='Height'),
      modificationTime?: string(name='ModificationTime'),
      narrowBandType?: string(name='NarrowBandType'),
      playURL?: string(name='PlayURL'),
      size?: long(name='Size'),
      status?: string(name='Status'),
      streamType?: string(name='StreamType'),
      transTemplateType?: string(name='TransTemplateType'),
      watermarkId?: string(name='WatermarkId'),
      width?: long(name='Width'),
    }
  ](name='PlayInfoList'),
  requestId?: string(name='RequestId'),
}

model GetPlayInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPlayInfoResponseBody(name='body'),
}

async function getPlayInfoWithOptions(request: GetPlayInfoRequest, runtime: Util.RuntimeOptions): GetPlayInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPlayInfo',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPlayInfo(request: GetPlayInfoRequest): GetPlayInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPlayInfoWithOptions(request, runtime);
}

model GetPublicMediaInfoRequest {
  mediaId?: string(name='MediaId'),
}

model GetPublicMediaInfoResponseBody = {
  mediaInfo?: {
    dynamicMetaData?: {
      data?: string(name='Data'),
      type?: string(name='Type'),
    }(name='DynamicMetaData'),
    fileInfoList?: [ 
      {
        audioStreamInfoList?: [ 
          {
            bitrate?: string(name='Bitrate'),
            channelLayout?: string(name='ChannelLayout'),
            channels?: string(name='Channels'),
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            duration?: string(name='Duration'),
            fps?: string(name='Fps'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            numFrames?: string(name='NumFrames'),
            profile?: string(name='Profile'),
            sampleFmt?: string(name='SampleFmt'),
            sampleRate?: string(name='SampleRate'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
          }
        ](name='AudioStreamInfoList'),
        fileBasicInfo?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          fileName?: string(name='FileName'),
          fileSize?: string(name='FileSize'),
          fileStatus?: string(name='FileStatus'),
          fileType?: string(name='FileType'),
          fileUrl?: string(name='FileUrl'),
          formatName?: string(name='FormatName'),
          height?: string(name='Height'),
          region?: string(name='Region'),
          width?: string(name='Width'),
        }(name='FileBasicInfo'),
        subtitleStreamInfoList?: [ 
          {
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            duration?: string(name='Duration'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
          }
        ](name='SubtitleStreamInfoList'),
        videoStreamInfoList?: [ 
          {
            avgFPS?: string(name='AvgFPS'),
            bitrate?: string(name='Bitrate'),
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            dar?: string(name='Dar'),
            duration?: string(name='Duration'),
            fps?: string(name='Fps'),
            hasBFrames?: string(name='HasBFrames'),
            height?: string(name='Height'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            level?: string(name='Level'),
            nbFrames?: string(name='Nb_frames'),
            numFrames?: string(name='NumFrames'),
            pixFmt?: string(name='PixFmt'),
            profile?: string(name='Profile'),
            rotate?: string(name='Rotate'),
            sar?: string(name='Sar'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
            width?: string(name='Width'),
          }
        ](name='VideoStreamInfoList'),
      }
    ](name='FileInfoList'),
    mediaBasicInfo?: {
      businessType?: string(name='BusinessType'),
      category?: string(name='Category'),
      coverURL?: string(name='CoverURL'),
      createTime?: string(name='CreateTime'),
      deletedTime?: string(name='DeletedTime'),
      description?: string(name='Description'),
      mediaId?: string(name='MediaId'),
      mediaTags?: string(name='MediaTags'),
      mediaType?: string(name='MediaType'),
      modifiedTime?: string(name='ModifiedTime'),
      source?: string(name='Source'),
      spriteImages?: string(name='SpriteImages'),
      status?: string(name='Status'),
      title?: string(name='Title'),
      userData?: string(name='UserData'),
    }(name='MediaBasicInfo'),
    mediaId?: string(name='MediaId'),
  }(name='MediaInfo'),
  requestId?: string(name='RequestId'),
}

model GetPublicMediaInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPublicMediaInfoResponseBody(name='body'),
}

async function getPublicMediaInfoWithOptions(request: GetPublicMediaInfoRequest, runtime: Util.RuntimeOptions): GetPublicMediaInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPublicMediaInfo',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPublicMediaInfo(request: GetPublicMediaInfoRequest): GetPublicMediaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPublicMediaInfoWithOptions(request, runtime);
}

model GetSmartHandleJobRequest {
  jobId?: string(name='JobId'),
}

model GetSmartHandleJobResponseBody = {
  jobId?: string(name='JobId'),
  output?: string(name='Output'),
  requestId?: string(name='RequestId'),
  smartJobInfo?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    inputConfig?: {
      inputFile?: string(name='InputFile'),
    }(name='InputConfig'),
    jobType?: string(name='JobType'),
    modifiedTime?: string(name='ModifiedTime'),
    outputConfig?: {
      bucket?: string(name='Bucket'),
      object?: string(name='Object'),
    }(name='OutputConfig'),
    title?: string(name='Title'),
    userId?: string(name='UserId'),
  }(name='SmartJobInfo'),
  state?: string(name='State'),
  userData?: string(name='UserData'),
}

model GetSmartHandleJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSmartHandleJobResponseBody(name='body'),
}

async function getSmartHandleJobWithOptions(request: GetSmartHandleJobRequest, runtime: Util.RuntimeOptions): GetSmartHandleJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSmartHandleJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSmartHandleJob(request: GetSmartHandleJobRequest): GetSmartHandleJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSmartHandleJobWithOptions(request, runtime);
}

model GetSnapshotJobRequest {
  jobId?: string(name='JobId'),
}

model GetSnapshotJobResponseBody = {
  requestId?: string(name='RequestId'),
  snapshotJob?: {
    async?: boolean(name='Async'),
    code?: string(name='Code'),
    count?: int32(name='Count'),
    createTime?: string(name='CreateTime'),
    finishTime?: string(name='FinishTime'),
    input?: {
      media?: string(name='Media'),
      ossFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='OssFile'),
      type?: string(name='Type'),
    }(name='Input'),
    jobId?: string(name='JobId'),
    message?: string(name='Message'),
    modifiedTime?: string(name='ModifiedTime'),
    name?: string(name='Name'),
    output?: {
      media?: string(name='Media'),
      ossFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='OssFile'),
      type?: string(name='Type'),
    }(name='Output'),
    pipelineId?: string(name='PipelineId'),
    status?: string(name='Status'),
    submitTime?: string(name='SubmitTime'),
    templateConfig?: string(name='TemplateConfig'),
    templateId?: string(name='TemplateId'),
    triggerSource?: string(name='TriggerSource'),
    type?: string(name='Type'),
    userData?: string(name='UserData'),
  }(name='SnapshotJob'),
}

model GetSnapshotJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSnapshotJobResponseBody(name='body'),
}

async function getSnapshotJobWithOptions(request: GetSnapshotJobRequest, runtime: Util.RuntimeOptions): GetSnapshotJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSnapshotJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSnapshotJob(request: GetSnapshotJobRequest): GetSnapshotJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSnapshotJobWithOptions(request, runtime);
}

model GetSnapshotUrlsRequest {
  jobId?: string(name='JobId'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  timeout?: long(name='Timeout'),
}

model GetSnapshotUrlsResponseBody = {
  requestId?: string(name='RequestId'),
  snapshotUrls?: [ string ](name='SnapshotUrls'),
  total?: int32(name='Total'),
  webVTTUrl?: string(name='WebVTTUrl'),
}

model GetSnapshotUrlsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSnapshotUrlsResponseBody(name='body'),
}

async function getSnapshotUrlsWithOptions(request: GetSnapshotUrlsRequest, runtime: Util.RuntimeOptions): GetSnapshotUrlsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSnapshotUrls',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSnapshotUrls(request: GetSnapshotUrlsRequest): GetSnapshotUrlsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSnapshotUrlsWithOptions(request, runtime);
}

model GetSystemTemplateRequest {
  templateId?: string(name='TemplateId'),
}

model GetSystemTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  systemTemplate?: {
    status?: string(name='Status'),
    subtype?: int32(name='Subtype'),
    subtypeName?: string(name='SubtypeName'),
    templateConfig?: string(name='TemplateConfig'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    type?: int32(name='Type'),
    typeName?: string(name='TypeName'),
  }(name='SystemTemplate'),
}

model GetSystemTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSystemTemplateResponseBody(name='body'),
}

async function getSystemTemplateWithOptions(request: GetSystemTemplateRequest, runtime: Util.RuntimeOptions): GetSystemTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSystemTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSystemTemplate(request: GetSystemTemplateRequest): GetSystemTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSystemTemplateWithOptions(request, runtime);
}

model GetTemplateRequest {
  relatedMediaidFlag?: string(name='RelatedMediaidFlag'),
  templateId?: string(name='TemplateId'),
}

model GetTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    clipsParam?: string(name='ClipsParam'),
    config?: string(name='Config'),
    coverURL?: string(name='CoverURL'),
    createSource?: string(name='CreateSource'),
    creationTime?: string(name='CreationTime'),
    modifiedSource?: string(name='ModifiedSource'),
    modifiedTime?: string(name='ModifiedTime'),
    name?: string(name='Name'),
    previewMedia?: string(name='PreviewMedia'),
    previewMediaStatus?: string(name='PreviewMediaStatus'),
    relatedMediaids?: string(name='RelatedMediaids'),
    status?: string(name='Status'),
    templateId?: string(name='TemplateId'),
    type?: string(name='Type'),
  }(name='Template'),
}

model GetTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTemplateResponseBody(name='body'),
}

async function getTemplateWithOptions(request: GetTemplateRequest, runtime: Util.RuntimeOptions): GetTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.relatedMediaidFlag)) {
    query['RelatedMediaidFlag'] = request.relatedMediaidFlag;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTemplate(request: GetTemplateRequest): GetTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTemplateWithOptions(request, runtime);
}

model GetTemplateMaterialsRequest {
  fileList?: string(name='FileList'),
  templateId?: string(name='TemplateId'),
}

model GetTemplateMaterialsResponseBody = {
  materialUrls?: string(name='MaterialUrls'),
  requestId?: string(name='RequestId'),
}

model GetTemplateMaterialsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTemplateMaterialsResponseBody(name='body'),
}

async function getTemplateMaterialsWithOptions(request: GetTemplateMaterialsRequest, runtime: Util.RuntimeOptions): GetTemplateMaterialsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileList)) {
    query['FileList'] = request.fileList;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTemplateMaterials',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTemplateMaterials(request: GetTemplateMaterialsRequest): GetTemplateMaterialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTemplateMaterialsWithOptions(request, runtime);
}

model GetTranscodeJobRequest {
  jobId?: string(name='JobId'),
}

model GetTranscodeJobResponseBody = {
  requestId?: string(name='RequestId'),
  transcodeParentJob?: {
    createTime?: string(name='CreateTime'),
    finishTime?: string(name='FinishTime'),
    inputGroup?: [ 
      {
        media?: string(name='Media'),
        type?: string(name='Type'),
      }
    ](name='InputGroup'),
    jobCount?: int32(name='JobCount'),
    name?: string(name='Name'),
    outputGroup?: [ 
      {
        output?: {
          media?: string(name='Media'),
          type?: string(name='Type'),
        }(name='Output'),
        processConfig?: {
          combineConfigs?: [ 
            {
              audioIndex?: string(name='AudioIndex'),
              duration?: double(name='Duration'),
              start?: double(name='Start'),
              videoIndex?: string(name='VideoIndex'),
            }
          ](name='CombineConfigs'),
          encryption?: {
            cipherText?: string(name='CipherText'),
            decryptKeyUri?: string(name='DecryptKeyUri'),
            encryptType?: string(name='EncryptType'),
          }(name='Encryption'),
          imageWatermarks?: [ 
            {
              overwriteParams?: {
                dx?: string(name='Dx'),
                dy?: string(name='Dy'),
                file?: {
                  media?: string(name='Media'),
                  type?: string(name='Type'),
                }(name='File'),
                height?: string(name='Height'),
                referPos?: string(name='ReferPos'),
                timeline?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='Timeline'),
                width?: string(name='Width'),
              }(name='OverwriteParams'),
              templateId?: string(name='TemplateId'),
            }
          ](name='ImageWatermarks'),
          subtitles?: [ 
            {
              overwriteParams?: {
                charEnc?: string(name='CharEnc'),
                file?: {
                  media?: string(name='Media'),
                  type?: string(name='Type'),
                }(name='File'),
                format?: string(name='Format'),
              }(name='OverwriteParams'),
              templateId?: string(name='TemplateId'),
            }
          ](name='Subtitles'),
          textWatermarks?: [ 
            {
              overwriteParams?: {
                adaptive?: string(name='Adaptive'),
                borderColor?: string(name='BorderColor'),
                borderWidth?: int32(name='BorderWidth'),
                content?: string(name='Content'),
                fontAlpha?: string(name='FontAlpha'),
                fontColor?: string(name='FontColor'),
                fontName?: string(name='FontName'),
                fontSize?: int32(name='FontSize'),
                left?: string(name='Left'),
                top?: string(name='Top'),
              }(name='OverwriteParams'),
              templateId?: string(name='TemplateId'),
            }
          ](name='TextWatermarks'),
          transcode?: {
            overwriteParams?: {
              audio?: {
                bitrate?: string(name='Bitrate'),
                channels?: string(name='Channels'),
                codec?: string(name='Codec'),
                profile?: string(name='Profile'),
                remove?: string(name='Remove'),
                samplerate?: string(name='Samplerate'),
                volume?: {
                  integratedLoudnessTarget?: string(name='IntegratedLoudnessTarget'),
                  loudnessRangeTarget?: string(name='LoudnessRangeTarget'),
                  method?: string(name='Method'),
                  truePeak?: string(name='TruePeak'),
                }(name='Volume'),
              }(name='Audio'),
              container?: {
                format?: string(name='Format'),
              }(name='Container'),
              muxConfig?: {
                segment?: {
                  duration?: string(name='Duration'),
                  forceSegTime?: string(name='ForceSegTime'),
                }(name='Segment'),
              }(name='MuxConfig'),
              video?: {
                abrMax?: string(name='AbrMax'),
                bitrate?: string(name='Bitrate'),
                bufsize?: string(name='Bufsize'),
                codec?: string(name='Codec'),
                crf?: string(name='Crf'),
                crop?: string(name='Crop'),
                fps?: string(name='Fps'),
                gop?: string(name='Gop'),
                height?: string(name='Height'),
                longShortMode?: string(name='LongShortMode'),
                maxrate?: string(name='Maxrate'),
                pad?: string(name='Pad'),
                pixFmt?: string(name='PixFmt'),
                preset?: string(name='Preset'),
                profile?: string(name='Profile'),
                remove?: string(name='Remove'),
                scanMode?: string(name='ScanMode'),
                width?: string(name='Width'),
              }(name='Video'),
            }(name='OverwriteParams'),
            templateId?: string(name='TemplateId'),
          }(name='Transcode'),
        }(name='ProcessConfig'),
      }
    ](name='OutputGroup'),
    parentJobId?: string(name='ParentJobId'),
    percent?: int32(name='Percent'),
    requestId?: string(name='RequestId'),
    scheduleConfig?: {
      pipelineId?: string(name='PipelineId'),
      priority?: int32(name='Priority'),
    }(name='ScheduleConfig'),
    status?: string(name='Status'),
    submitTime?: string(name='SubmitTime'),
    transcodeJobList?: [ 
      {
        createTime?: string(name='CreateTime'),
        finishTime?: string(name='FinishTime'),
        inputGroup?: [ 
          {
            media?: string(name='Media'),
            type?: string(name='Type'),
          }
        ](name='InputGroup'),
        jobId?: string(name='JobId'),
        jobIndex?: int32(name='JobIndex'),
        name?: string(name='Name'),
        outFileMeta?: {
          audioStreamInfoList?: [ 
            {
              bitrate?: string(name='Bitrate'),
              channelLayout?: string(name='ChannelLayout'),
              channels?: string(name='Channels'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              sampleFmt?: string(name='SampleFmt'),
              sampleRate?: string(name='SampleRate'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='AudioStreamInfoList'),
          fileBasicInfo?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            fileName?: string(name='FileName'),
            fileSize?: string(name='FileSize'),
            fileStatus?: string(name='FileStatus'),
            fileType?: string(name='FileType'),
            fileUrl?: string(name='FileUrl'),
            formatName?: string(name='FormatName'),
            height?: string(name='Height'),
            mediaId?: string(name='MediaId'),
            region?: string(name='Region'),
            width?: string(name='Width'),
          }(name='FileBasicInfo'),
          videoStreamInfoList?: [ 
            {
              avgFps?: string(name='Avg_fps'),
              bitRate?: string(name='Bit_rate'),
              codecLongName?: string(name='Codec_long_name'),
              codecName?: string(name='Codec_name'),
              codecTag?: string(name='Codec_tag'),
              codecTagString?: string(name='Codec_tag_string'),
              codecTimeBase?: string(name='Codec_time_base'),
              dar?: string(name='Dar'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              hasBFrames?: string(name='Has_b_frames'),
              height?: string(name='Height'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              level?: string(name='Level'),
              numFrames?: string(name='NumFrames'),
              pixFmt?: string(name='PixFmt'),
              profile?: string(name='Profile'),
              rotate?: string(name='Rotate'),
              sar?: string(name='Sar'),
              startTime?: string(name='Start_time'),
              timeBase?: string(name='Time_base'),
              width?: string(name='Width'),
            }
          ](name='VideoStreamInfoList'),
        }(name='OutFileMeta'),
        output?: {
          media?: string(name='Media'),
          type?: string(name='Type'),
        }(name='Output'),
        parentJobId?: string(name='ParentJobId'),
        processConfig?: {
          combineConfigs?: [ 
            {
              audioIndex?: string(name='AudioIndex'),
              duration?: double(name='Duration'),
              start?: double(name='Start'),
              videoIndex?: string(name='VideoIndex'),
            }
          ](name='CombineConfigs'),
          encryption?: {
            cipherText?: string(name='CipherText'),
            decryptKeyUri?: string(name='DecryptKeyUri'),
            encryptType?: string(name='EncryptType'),
          }(name='Encryption'),
          imageWatermarks?: [ 
            {
              overwriteParams?: {
                dx?: string(name='Dx'),
                dy?: string(name='Dy'),
                file?: {
                  media?: string(name='Media'),
                  type?: string(name='Type'),
                }(name='File'),
                height?: string(name='Height'),
                referPos?: string(name='ReferPos'),
                timeline?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='Timeline'),
                width?: string(name='Width'),
              }(name='OverwriteParams'),
              templateId?: string(name='TemplateId'),
            }
          ](name='ImageWatermarks'),
          subtitles?: [ 
            {
              overwriteParams?: {
                charEnc?: string(name='CharEnc'),
                file?: {
                  media?: string(name='Media'),
                  type?: string(name='Type'),
                }(name='File'),
                format?: string(name='Format'),
              }(name='OverwriteParams'),
              templateId?: string(name='TemplateId'),
            }
          ](name='Subtitles'),
          textWatermarks?: [ 
            {
              overwriteParams?: {
                adaptive?: string(name='Adaptive'),
                borderColor?: string(name='BorderColor'),
                borderWidth?: int32(name='BorderWidth'),
                content?: string(name='Content'),
                fontAlpha?: string(name='FontAlpha'),
                fontColor?: string(name='FontColor'),
                fontName?: string(name='FontName'),
                fontSize?: int32(name='FontSize'),
                left?: string(name='Left'),
                top?: string(name='Top'),
              }(name='OverwriteParams'),
              templateId?: string(name='TemplateId'),
            }
          ](name='TextWatermarks'),
          transcode?: {
            overwriteParams?: {
              audio?: {
                bitrate?: string(name='Bitrate'),
                channels?: string(name='Channels'),
                codec?: string(name='Codec'),
                profile?: string(name='Profile'),
                remove?: string(name='Remove'),
                samplerate?: string(name='Samplerate'),
                volume?: {
                  integratedLoudnessTarget?: string(name='IntegratedLoudnessTarget'),
                  loudnessRangeTarget?: string(name='LoudnessRangeTarget'),
                  method?: string(name='Method'),
                  truePeak?: string(name='TruePeak'),
                }(name='Volume'),
              }(name='Audio'),
              container?: {
                format?: string(name='Format'),
              }(name='Container'),
              muxConfig?: {
                segment?: {
                  duration?: string(name='Duration'),
                  forceSegTime?: string(name='ForceSegTime'),
                }(name='Segment'),
              }(name='MuxConfig'),
              video?: {
                abrMax?: string(name='AbrMax'),
                bitrate?: string(name='Bitrate'),
                bufsize?: string(name='Bufsize'),
                codec?: string(name='Codec'),
                crf?: string(name='Crf'),
                crop?: string(name='Crop'),
                fps?: string(name='Fps'),
                gop?: string(name='Gop'),
                height?: string(name='Height'),
                longShortMode?: string(name='LongShortMode'),
                maxrate?: string(name='Maxrate'),
                pad?: string(name='Pad'),
                pixFmt?: string(name='PixFmt'),
                preset?: string(name='Preset'),
                profile?: string(name='Profile'),
                remove?: string(name='Remove'),
                scanMode?: string(name='ScanMode'),
                width?: string(name='Width'),
              }(name='Video'),
            }(name='OverwriteParams'),
            templateId?: string(name='TemplateId'),
          }(name='Transcode'),
        }(name='ProcessConfig'),
        requestId?: string(name='RequestId'),
        scheduleConfig?: {
          pipelineId?: string(name='PipelineId'),
          priority?: int32(name='Priority'),
        }(name='ScheduleConfig'),
        status?: string(name='Status'),
        submitResultJson?: map[string]any(name='SubmitResultJson'),
        submitTime?: string(name='SubmitTime'),
        userData?: string(name='UserData'),
      }
    ](name='TranscodeJobList'),
    triggerSource?: string(name='TriggerSource'),
    userData?: string(name='UserData'),
  }(name='TranscodeParentJob'),
}

model GetTranscodeJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTranscodeJobResponseBody(name='body'),
}

async function getTranscodeJobWithOptions(request: GetTranscodeJobRequest, runtime: Util.RuntimeOptions): GetTranscodeJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTranscodeJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTranscodeJob(request: GetTranscodeJobRequest): GetTranscodeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTranscodeJobWithOptions(request, runtime);
}

model GetUrlUploadInfosRequest {
  jobIds?: string(name='JobIds'),
  uploadURLs?: string(name='UploadURLs'),
}

model GetUrlUploadInfosResponseBody = {
  nonExists?: [ string ](name='NonExists'),
  requestId?: string(name='RequestId'),
  URLUploadInfoList?: [ 
    {
      completeTime?: string(name='CompleteTime'),
      creationTime?: string(name='CreationTime'),
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      fileSize?: string(name='FileSize'),
      jobId?: string(name='JobId'),
      mediaId?: string(name='MediaId'),
      status?: string(name='Status'),
      uploadURL?: string(name='UploadURL'),
      userData?: string(name='UserData'),
    }
  ](name='URLUploadInfoList'),
}

model GetUrlUploadInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUrlUploadInfosResponseBody(name='body'),
}

async function getUrlUploadInfosWithOptions(request: GetUrlUploadInfosRequest, runtime: Util.RuntimeOptions): GetUrlUploadInfosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobIds)) {
    query['JobIds'] = request.jobIds;
  }
  if (!Util.isUnset(request.uploadURLs)) {
    query['UploadURLs'] = request.uploadURLs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUrlUploadInfos',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUrlUploadInfos(request: GetUrlUploadInfosRequest): GetUrlUploadInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUrlUploadInfosWithOptions(request, runtime);
}

model ListAllPublicMediaTagsRequest {
  businessType?: string(name='BusinessType'),
  entityId?: string(name='EntityId'),
}

model ListAllPublicMediaTagsResponseBody = {
  mediaTagList?: [ 
    {
      mediaTagId?: string(name='MediaTagId'),
      mediaTagNameChinese?: string(name='MediaTagNameChinese'),
      mediaTagNameEnglish?: string(name='MediaTagNameEnglish'),
      options?: [ 
        {
          optionChineseName?: string(name='OptionChineseName'),
          optionEnglishName?: string(name='OptionEnglishName'),
          optionId?: string(name='OptionId'),
        }
      ](name='Options'),
    }
  ](name='MediaTagList'),
  requestId?: string(name='RequestId'),
}

model ListAllPublicMediaTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAllPublicMediaTagsResponseBody(name='body'),
}

async function listAllPublicMediaTagsWithOptions(request: ListAllPublicMediaTagsRequest, runtime: Util.RuntimeOptions): ListAllPublicMediaTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessType)) {
    query['BusinessType'] = request.businessType;
  }
  if (!Util.isUnset(request.entityId)) {
    query['EntityId'] = request.entityId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAllPublicMediaTags',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAllPublicMediaTags(request: ListAllPublicMediaTagsRequest): ListAllPublicMediaTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAllPublicMediaTagsWithOptions(request, runtime);
}

model ListCustomTemplatesRequest {
  name?: string(name='Name'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  subtype?: string(name='Subtype'),
  templateId?: string(name='TemplateId'),
  type?: string(name='Type'),
}

model ListCustomTemplatesResponseBody = {
  customTemplateList?: [ 
    {
      createTime?: string(name='CreateTime'),
      isDefault?: boolean(name='IsDefault'),
      modifiedTime?: string(name='ModifiedTime'),
      status?: string(name='Status'),
      subtype?: int32(name='Subtype'),
      subtypeName?: string(name='SubtypeName'),
      templateConfig?: string(name='TemplateConfig'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      type?: int32(name='Type'),
      typeName?: string(name='TypeName'),
    }
  ](name='CustomTemplateList'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListCustomTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCustomTemplatesResponseBody(name='body'),
}

async function listCustomTemplatesWithOptions(request: ListCustomTemplatesRequest, runtime: Util.RuntimeOptions): ListCustomTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.subtype)) {
    query['Subtype'] = request.subtype;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCustomTemplates',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCustomTemplates(request: ListCustomTemplatesRequest): ListCustomTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCustomTemplatesWithOptions(request, runtime);
}

model ListDNADBRequest {
  DBIds?: string(name='DBIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListDNADBResponseBody = {
  DBList?: [ 
    {
      DBId?: string(name='DBId'),
      description?: string(name='Description'),
      model?: int32(name='Model'),
      name?: string(name='Name'),
      status?: string(name='Status'),
    }
  ](name='DBList'),
  requestId?: string(name='RequestId'),
}

model ListDNADBResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDNADBResponseBody(name='body'),
}

async function listDNADBWithOptions(request: ListDNADBRequest, runtime: Util.RuntimeOptions): ListDNADBResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBIds)) {
    query['DBIds'] = request.DBIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDNADB',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDNADB(request: ListDNADBRequest): ListDNADBResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDNADBWithOptions(request, runtime);
}

model ListDNAFilesRequest {
  DBId?: string(name='DBId'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListDNAFilesResponseBody = {
  fileList?: [ 
    {
      inputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='InputFile'),
      primaryKey?: string(name='PrimaryKey'),
    }
  ](name='FileList'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListDNAFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDNAFilesResponseBody(name='body'),
}

async function listDNAFilesWithOptions(request: ListDNAFilesRequest, runtime: Util.RuntimeOptions): ListDNAFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBId)) {
    query['DBId'] = request.DBId;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDNAFiles',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDNAFiles(request: ListDNAFilesRequest): ListDNAFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDNAFilesWithOptions(request, runtime);
}

model ListDynamicImageJobsRequest {
  endOfCreateTime?: string(name='EndOfCreateTime'),
  jobId?: string(name='JobId'),
  nextPageToken?: string(name='NextPageToken'),
  orderBy?: string(name='OrderBy'),
  pageSize?: int32(name='PageSize'),
  startOfCreateTime?: string(name='StartOfCreateTime'),
  status?: string(name='Status'),
}

model ListDynamicImageJobsResponseBody = {
  jobs?: [ 
    {
      createTime?: string(name='CreateTime'),
      finishTime?: string(name='FinishTime'),
      input?: {
        media?: string(name='Media'),
        type?: string(name='Type'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      modifiedTime?: string(name='ModifiedTime'),
      name?: string(name='Name'),
      output?: {
        media?: string(name='Media'),
        type?: string(name='Type'),
      }(name='Output'),
      pipelineId?: string(name='PipelineId'),
      status?: string(name='Status'),
      submitTime?: string(name='SubmitTime'),
      templateId?: string(name='TemplateId'),
      triggerSource?: string(name='TriggerSource'),
    }
  ](name='Jobs'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListDynamicImageJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDynamicImageJobsResponseBody(name='body'),
}

async function listDynamicImageJobsWithOptions(request: ListDynamicImageJobsRequest, runtime: Util.RuntimeOptions): ListDynamicImageJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endOfCreateTime)) {
    query['EndOfCreateTime'] = request.endOfCreateTime;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startOfCreateTime)) {
    query['StartOfCreateTime'] = request.startOfCreateTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDynamicImageJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDynamicImageJobs(request: ListDynamicImageJobsRequest): ListDynamicImageJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDynamicImageJobsWithOptions(request, runtime);
}

model ListLiveRecordFilesRequest {
  endTime?: string(name='EndTime'),
  jobIds?: [ string ](name='JobIds'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  recordFormat?: string(name='RecordFormat'),
  sortBy?: string(name='SortBy'),
  startTime?: string(name='StartTime'),
}

model ListLiveRecordFilesResponseBody = {
  files?: [ 
    {
      createTime?: string(name='CreateTime'),
      duration?: float(name='Duration'),
      endTime?: string(name='EndTime'),
      format?: string(name='Format'),
      height?: int32(name='Height'),
      jobId?: string(name='JobId'),
      jobName?: string(name='JobName'),
      recordId?: string(name='RecordId'),
      recordOutput?: string(name='RecordOutput'),
      recordUrl?: string(name='RecordUrl'),
      startTime?: string(name='StartTime'),
      streamUrl?: string(name='StreamUrl'),
      width?: int32(name='Width'),
    }
  ](name='Files'),
  pageNo?: long(name='PageNo'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId'),
  sortBy?: string(name='SortBy'),
  totalCount?: string(name='TotalCount'),
}

model ListLiveRecordFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLiveRecordFilesResponseBody(name='body'),
}

async function listLiveRecordFilesWithOptions(request: ListLiveRecordFilesRequest, runtime: Util.RuntimeOptions): ListLiveRecordFilesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLiveRecordFiles',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLiveRecordFiles(request: ListLiveRecordFilesRequest): ListLiveRecordFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLiveRecordFilesWithOptions(request, runtime);
}

model ListLiveRecordJobsRequest {
  endTime?: string(name='EndTime'),
  keyword?: string(name='Keyword'),
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  sortBy?: string(name='SortBy'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
}

model ListLiveRecordJobsResponseBody = {
  liveRecordJobs?: [ 
    {
      createTime?: string(name='CreateTime'),
      jobId?: string(name='JobId'),
      name?: string(name='Name'),
      notifyUrl?: string(name='NotifyUrl'),
      recordOutput?: {
        bucket?: string(name='Bucket'),
        endpoint?: string(name='Endpoint'),
        type?: string(name='Type'),
      }(name='RecordOutput'),
      status?: string(name='Status'),
      streamInput?: {
        type?: string(name='Type'),
        url?: string(name='Url'),
      }(name='StreamInput'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
    }
  ](name='LiveRecordJobs'),
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  sortBy?: string(name='SortBy'),
  totalCount?: long(name='TotalCount'),
}

model ListLiveRecordJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLiveRecordJobsResponseBody(name='body'),
}

async function listLiveRecordJobsWithOptions(request: ListLiveRecordJobsRequest, runtime: Util.RuntimeOptions): ListLiveRecordJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLiveRecordJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLiveRecordJobs(request: ListLiveRecordJobsRequest): ListLiveRecordJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLiveRecordJobsWithOptions(request, runtime);
}

model ListLiveRecordTemplatesRequest {
  keyword?: string(name='Keyword'),
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  sortBy?: string(name='SortBy'),
  templateIds?: [ string ](name='TemplateIds'),
  type?: string(name='Type'),
}

model ListLiveRecordTemplatesResponseBody = {
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  recordTemplateList?: [ 
    {
      createTime?: string(name='CreateTime'),
      lastModified?: string(name='LastModified'),
      name?: string(name='Name'),
      recordFormatList?: [ 
        {
          cycleDuration?: int32(name='CycleDuration'),
          format?: string(name='Format'),
          ossObjectPrefix?: string(name='OssObjectPrefix'),
          sliceDuration?: int32(name='SliceDuration'),
          sliceOssObjectPrefix?: string(name='SliceOssObjectPrefix'),
        }
      ](name='RecordFormatList'),
      templateId?: string(name='TemplateId'),
      type?: string(name='Type'),
    }
  ](name='RecordTemplateList'),
  requestId?: string(name='RequestId'),
  sortBy?: string(name='SortBy'),
  totalCount?: long(name='TotalCount'),
}

model ListLiveRecordTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLiveRecordTemplatesResponseBody(name='body'),
}

async function listLiveRecordTemplatesWithOptions(request: ListLiveRecordTemplatesRequest, runtime: Util.RuntimeOptions): ListLiveRecordTemplatesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLiveRecordTemplates',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLiveRecordTemplates(request: ListLiveRecordTemplatesRequest): ListLiveRecordTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLiveRecordTemplatesWithOptions(request, runtime);
}

model ListLiveSnapshotFilesRequest {
  endTime?: string(name='EndTime'),
  jobId?: string(name='JobId'),
  limit?: int32(name='Limit'),
  sortBy?: string(name='SortBy'),
  startTime?: string(name='StartTime'),
}

model ListLiveSnapshotFilesResponseBody = {
  fileList?: [ 
    {
      createTime?: string(name='CreateTime'),
      createTimestamp?: long(name='CreateTimestamp'),
      isOverlay?: boolean(name='IsOverlay'),
      ossBucket?: string(name='OssBucket'),
      ossEndpoint?: string(name='OssEndpoint'),
      ossObject?: string(name='OssObject'),
    }
  ](name='FileList'),
  nextStartTime?: string(name='NextStartTime'),
  requestId?: string(name='RequestId'),
}

model ListLiveSnapshotFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLiveSnapshotFilesResponseBody(name='body'),
}

async function listLiveSnapshotFilesWithOptions(request: ListLiveSnapshotFilesRequest, runtime: Util.RuntimeOptions): ListLiveSnapshotFilesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLiveSnapshotFiles',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLiveSnapshotFiles(request: ListLiveSnapshotFilesRequest): ListLiveSnapshotFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLiveSnapshotFilesWithOptions(request, runtime);
}

model ListLiveSnapshotJobsRequest {
  endTime?: string(name='EndTime'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  searchKeyWord?: string(name='SearchKeyWord'),
  sortBy?: string(name='SortBy'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
}

model ListLiveSnapshotJobsResponseBody = {
  jobList?: [ 
    {
      createTime?: string(name='CreateTime'),
      jobId?: string(name='JobId'),
      jobName?: string(name='JobName'),
      snapshotOutput?: {
        bucket?: string(name='Bucket'),
        endpoint?: string(name='Endpoint'),
        storageType?: string(name='StorageType'),
      }(name='SnapshotOutput'),
      status?: string(name='Status'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      timeInterval?: int32(name='TimeInterval'),
    }
  ](name='JobList'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  sortBy?: string(name='SortBy'),
  totalCount?: long(name='TotalCount'),
}

model ListLiveSnapshotJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLiveSnapshotJobsResponseBody(name='body'),
}

async function listLiveSnapshotJobsWithOptions(request: ListLiveSnapshotJobsRequest, runtime: Util.RuntimeOptions): ListLiveSnapshotJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLiveSnapshotJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLiveSnapshotJobs(request: ListLiveSnapshotJobsRequest): ListLiveSnapshotJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLiveSnapshotJobsWithOptions(request, runtime);
}

model ListLiveSnapshotTemplatesRequest {
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  searchKeyWord?: string(name='SearchKeyWord'),
  sortBy?: string(name='SortBy'),
  templateIds?: [ string ](name='TemplateIds'),
  type?: string(name='Type'),
}

model ListLiveSnapshotTemplatesResponseBody = {
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  sortBy?: string(name='SortBy'),
  templateList?: [ 
    {
      createTime?: string(name='CreateTime'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      timeInterval?: int32(name='TimeInterval'),
      type?: string(name='Type'),
    }
  ](name='TemplateList'),
  totalCount?: long(name='TotalCount'),
}

model ListLiveSnapshotTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLiveSnapshotTemplatesResponseBody(name='body'),
}

async function listLiveSnapshotTemplatesWithOptions(request: ListLiveSnapshotTemplatesRequest, runtime: Util.RuntimeOptions): ListLiveSnapshotTemplatesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLiveSnapshotTemplates',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLiveSnapshotTemplates(request: ListLiveSnapshotTemplatesRequest): ListLiveSnapshotTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLiveSnapshotTemplatesWithOptions(request, runtime);
}

model ListLiveTranscodeJobsRequest {
  keyWord?: string(name='KeyWord'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  sortBy?: string(name='SortBy'),
  startMode?: int32(name='StartMode'),
  status?: int32(name='Status'),
  type?: string(name='Type'),
}

model ListLiveTranscodeJobsResponseBody = {
  jobList?: [ 
    {
      createTime?: string(name='CreateTime'),
      jobId?: string(name='JobId'),
      name?: string(name='Name'),
      outputStream?: {
        streamInfos?: [ 
          {
            outputUrl?: string(name='OutputUrl'),
            type?: string(name='Type'),
          }
        ](name='StreamInfos'),
      }(name='OutputStream'),
      startMode?: int32(name='StartMode'),
      status?: int32(name='Status'),
      streamInput?: {
        inputUrl?: string(name='InputUrl'),
        type?: string(name='Type'),
      }(name='StreamInput'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateType?: string(name='TemplateType'),
    }
  ](name='JobList'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListLiveTranscodeJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLiveTranscodeJobsResponseBody(name='body'),
}

async function listLiveTranscodeJobsWithOptions(request: ListLiveTranscodeJobsRequest, runtime: Util.RuntimeOptions): ListLiveTranscodeJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.startMode)) {
    query['StartMode'] = request.startMode;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLiveTranscodeJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLiveTranscodeJobs(request: ListLiveTranscodeJobsRequest): ListLiveTranscodeJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLiveTranscodeJobsWithOptions(request, runtime);
}

model ListLiveTranscodeTemplatesRequest {
  category?: string(name='Category'),
  keyWord?: string(name='KeyWord'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  sortBy?: string(name='SortBy'),
  type?: string(name='Type'),
  videoCodec?: string(name='VideoCodec'),
}

model ListLiveTranscodeTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  templateContentList?: [ 
    {
      category?: string(name='Category'),
      createTime?: string(name='CreateTime'),
      name?: string(name='Name'),
      templateConfig?: {
        audioParams?: {
          bitrate?: string(name='Bitrate'),
          channels?: string(name='Channels'),
          codec?: string(name='Codec'),
          profile?: string(name='Profile'),
          samplerate?: string(name='Samplerate'),
        }(name='AudioParams'),
        videoParams?: {
          bitrate?: string(name='Bitrate'),
          codec?: string(name='Codec'),
          fps?: string(name='Fps'),
          gop?: string(name='Gop'),
          height?: string(name='Height'),
          profile?: string(name='Profile'),
          width?: string(name='Width'),
        }(name='VideoParams'),
      }(name='TemplateConfig'),
      templateId?: string(name='TemplateId'),
      type?: string(name='Type'),
    }
  ](name='TemplateContentList'),
  totalCount?: int32(name='TotalCount'),
}

model ListLiveTranscodeTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLiveTranscodeTemplatesResponseBody(name='body'),
}

async function listLiveTranscodeTemplatesWithOptions(request: ListLiveTranscodeTemplatesRequest, runtime: Util.RuntimeOptions): ListLiveTranscodeTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.videoCodec)) {
    query['VideoCodec'] = request.videoCodec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLiveTranscodeTemplates',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLiveTranscodeTemplates(request: ListLiveTranscodeTemplatesRequest): ListLiveTranscodeTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLiveTranscodeTemplatesWithOptions(request, runtime);
}

model ListMediaBasicInfosRequest {
  businessType?: string(name='BusinessType'),
  endTime?: string(name='EndTime'),
  includeFileBasicInfo?: boolean(name='IncludeFileBasicInfo'),
  maxResults?: int32(name='MaxResults'),
  mediaId?: string(name='MediaId'),
  mediaType?: string(name='MediaType'),
  nextToken?: string(name='NextToken'),
  sortBy?: string(name='SortBy'),
  source?: string(name='Source'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
}

model ListMediaBasicInfosResponseBody = {
  maxResults?: int32(name='MaxResults'),
  mediaInfos?: [ 
    {
      fileInfoList?: [ 
        {
          fileBasicInfo?: {
            bitrate?: string(name='Bitrate'),
            createTime?: string(name='CreateTime'),
            duration?: string(name='Duration'),
            fileName?: string(name='FileName'),
            fileSize?: string(name='FileSize'),
            fileStatus?: string(name='FileStatus'),
            fileType?: string(name='FileType'),
            fileUrl?: string(name='FileUrl'),
            formatName?: string(name='FormatName'),
            height?: string(name='Height'),
            modifiedTime?: string(name='ModifiedTime'),
            region?: string(name='Region'),
            width?: string(name='Width'),
          }(name='FileBasicInfo'),
        }
      ](name='FileInfoList'),
      mediaBasicInfo?: {
        biz?: string(name='Biz'),
        businessType?: string(name='BusinessType'),
        cateId?: long(name='CateId'),
        category?: string(name='Category'),
        coverURL?: string(name='CoverURL'),
        createTime?: string(name='CreateTime'),
        deletedTime?: string(name='DeletedTime'),
        description?: string(name='Description'),
        inputURL?: string(name='InputURL'),
        mediaId?: string(name='MediaId'),
        mediaTags?: string(name='MediaTags'),
        mediaType?: string(name='MediaType'),
        modifiedTime?: string(name='ModifiedTime'),
        referenceId?: string(name='ReferenceId'),
        snapshots?: string(name='Snapshots'),
        source?: string(name='Source'),
        spriteImages?: string(name='SpriteImages'),
        status?: string(name='Status'),
        title?: string(name='Title'),
        transcodeStatus?: string(name='TranscodeStatus'),
        uploadSource?: string(name='UploadSource'),
        userData?: string(name='UserData'),
      }(name='MediaBasicInfo'),
      mediaId?: string(name='MediaId'),
    }
  ](name='MediaInfos'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListMediaBasicInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMediaBasicInfosResponseBody(name='body'),
}

async function listMediaBasicInfosWithOptions(request: ListMediaBasicInfosRequest, runtime: Util.RuntimeOptions): ListMediaBasicInfosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessType)) {
    query['BusinessType'] = request.businessType;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.includeFileBasicInfo)) {
    query['IncludeFileBasicInfo'] = request.includeFileBasicInfo;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.mediaType)) {
    query['MediaType'] = request.mediaType;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMediaBasicInfos',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMediaBasicInfos(request: ListMediaBasicInfosRequest): ListMediaBasicInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMediaBasicInfosWithOptions(request, runtime);
}

model ListMediaInfoJobsRequest {
  endOfCreateTime?: string(name='EndOfCreateTime'),
  jobId?: string(name='JobId'),
  nextPageToken?: string(name='NextPageToken'),
  orderBy?: string(name='OrderBy'),
  pageSize?: int32(name='PageSize'),
  startOfCreateTime?: string(name='StartOfCreateTime'),
  status?: string(name='Status'),
}

model ListMediaInfoJobsResponseBody = {
  jobs?: [ 
    {
      async?: boolean(name='Async'),
      finishTime?: string(name='FinishTime'),
      input?: {
        media?: string(name='Media'),
        type?: string(name='Type'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      mediaInfoProperty?: {
        audioStreamInfoList?: [ 
          {
            bitrate?: string(name='Bitrate'),
            channelLayout?: string(name='ChannelLayout'),
            channels?: string(name='Channels'),
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            duration?: string(name='Duration'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            sampleFmt?: string(name='SampleFmt'),
            sampleRate?: string(name='SampleRate'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
          }
        ](name='AudioStreamInfoList'),
        fileBasicInfo?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          fileName?: string(name='FileName'),
          fileSize?: string(name='FileSize'),
          fileStatus?: string(name='FileStatus'),
          fileType?: string(name='FileType'),
          fileUrl?: string(name='FileUrl'),
          formatName?: string(name='FormatName'),
          height?: string(name='Height'),
          mediaId?: string(name='MediaId'),
          region?: string(name='Region'),
          width?: string(name='Width'),
        }(name='FileBasicInfo'),
        videoStreamInfoList?: [ 
          {
            avgFps?: string(name='Avg_fps'),
            bitRate?: string(name='Bit_rate'),
            codecLongName?: string(name='Codec_long_name'),
            codecName?: string(name='Codec_name'),
            codecTag?: string(name='Codec_tag'),
            codecTagString?: string(name='Codec_tag_string'),
            codecTimeBase?: string(name='Codec_time_base'),
            dar?: string(name='Dar'),
            duration?: string(name='Duration'),
            fps?: string(name='Fps'),
            hasBFrames?: string(name='Has_b_frames'),
            height?: string(name='Height'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            level?: string(name='Level'),
            numFrames?: string(name='NumFrames'),
            pixFmt?: string(name='PixFmt'),
            profile?: string(name='Profile'),
            rotate?: string(name='Rotate'),
            sar?: string(name='Sar'),
            startTime?: string(name='Start_time'),
            timeBase?: string(name='Time_base'),
            width?: string(name='Width'),
          }
        ](name='VideoStreamInfoList'),
      }(name='MediaInfoProperty'),
      name?: string(name='Name'),
      requestId?: string(name='RequestId'),
      scheduleConfig?: {
        pipelineId?: string(name='PipelineId'),
        priority?: int32(name='Priority'),
      }(name='ScheduleConfig'),
      status?: string(name='Status'),
      submitResultJson?: map[string]any(name='SubmitResultJson'),
      submitTime?: string(name='SubmitTime'),
      triggerSource?: string(name='TriggerSource'),
      userData?: string(name='UserData'),
    }
  ](name='Jobs'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListMediaInfoJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMediaInfoJobsResponseBody(name='body'),
}

async function listMediaInfoJobsWithOptions(request: ListMediaInfoJobsRequest, runtime: Util.RuntimeOptions): ListMediaInfoJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endOfCreateTime)) {
    query['EndOfCreateTime'] = request.endOfCreateTime;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startOfCreateTime)) {
    query['StartOfCreateTime'] = request.startOfCreateTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMediaInfoJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMediaInfoJobs(request: ListMediaInfoJobsRequest): ListMediaInfoJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMediaInfoJobsWithOptions(request, runtime);
}

model ListMediaMarksRequest {
  mediaId?: string(name='MediaId'),
  mediaMarkIds?: string(name='MediaMarkIds'),
}

model ListMediaMarksResponseBody = {
  mediaId?: string(name='MediaId'),
  mediaMarks?: string(name='MediaMarks'),
  requestId?: string(name='RequestId'),
}

model ListMediaMarksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMediaMarksResponseBody(name='body'),
}

async function listMediaMarksWithOptions(request: ListMediaMarksRequest, runtime: Util.RuntimeOptions): ListMediaMarksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.mediaMarkIds)) {
    query['MediaMarkIds'] = request.mediaMarkIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMediaMarks',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMediaMarks(request: ListMediaMarksRequest): ListMediaMarksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMediaMarksWithOptions(request, runtime);
}

model ListPackageJobsRequest {
  endOfCreateTime?: string(name='EndOfCreateTime'),
  jobId?: string(name='JobId'),
  nextPageToken?: string(name='NextPageToken'),
  orderBy?: string(name='OrderBy'),
  pageSize?: int32(name='PageSize'),
  startOfCreateTime?: string(name='StartOfCreateTime'),
  status?: string(name='Status'),
}

model ListPackageJobsResponseBody = {
  packageJobList?: {
    nextPageToken?: string(name='NextPageToken'),
    packageJobs?: [ 
      {
        code?: string(name='Code'),
        createTime?: string(name='CreateTime'),
        finishTime?: string(name='FinishTime'),
        inputs?: [ 
          {
            input?: {
              media?: string(name='Media'),
              type?: string(name='Type'),
            }(name='Input'),
          }
        ](name='Inputs'),
        jobId?: string(name='JobId'),
        message?: string(name='Message'),
        modifiedTime?: string(name='ModifiedTime'),
        name?: string(name='Name'),
        output?: {
          media?: string(name='Media'),
          type?: string(name='Type'),
        }(name='Output'),
        pipelineId?: string(name='PipelineId'),
        priority?: int32(name='Priority'),
        status?: string(name='Status'),
        submitTime?: string(name='SubmitTime'),
        triggerSource?: string(name='TriggerSource'),
        userData?: string(name='UserData'),
      }
    ](name='PackageJobs'),
  }(name='PackageJobList'),
  requestId?: string(name='RequestId'),
}

model ListPackageJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPackageJobsResponseBody(name='body'),
}

async function listPackageJobsWithOptions(request: ListPackageJobsRequest, runtime: Util.RuntimeOptions): ListPackageJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endOfCreateTime)) {
    query['EndOfCreateTime'] = request.endOfCreateTime;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startOfCreateTime)) {
    query['StartOfCreateTime'] = request.startOfCreateTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPackageJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPackageJobs(request: ListPackageJobsRequest): ListPackageJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPackageJobsWithOptions(request, runtime);
}

model ListPipelinesRequest {
  speed?: string(name='Speed'),
}

model ListPipelinesResponseBody = {
  pipelineList?: [ 
    {
      createTime?: string(name='CreateTime'),
      modifiedTime?: string(name='ModifiedTime'),
      name?: string(name='Name'),
      pipelineId?: string(name='PipelineId'),
      priority?: int32(name='Priority'),
      speed?: string(name='Speed'),
      status?: string(name='Status'),
    }
  ](name='PipelineList'),
  requestId?: string(name='RequestId'),
}

model ListPipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPipelinesResponseBody(name='body'),
}

async function listPipelinesWithOptions(request: ListPipelinesRequest, runtime: Util.RuntimeOptions): ListPipelinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.speed)) {
    query['Speed'] = request.speed;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPipelines',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPipelines(request: ListPipelinesRequest): ListPipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPipelinesWithOptions(request, runtime);
}

model ListPublicMediaBasicInfosRequest {
  includeFileBasicInfo?: boolean(name='IncludeFileBasicInfo'),
  maxResults?: int32(name='MaxResults'),
  mediaTagId?: string(name='MediaTagId'),
  nextToken?: string(name='NextToken'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
}

model ListPublicMediaBasicInfosResponseBody = {
  maxResults?: int32(name='MaxResults'),
  mediaInfos?: [ 
    {
      fileInfoList?: [ 
        {
          fileBasicInfo?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            fileName?: string(name='FileName'),
            fileSize?: string(name='FileSize'),
            fileStatus?: string(name='FileStatus'),
            fileType?: string(name='FileType'),
            fileUrl?: string(name='FileUrl'),
            formatName?: string(name='FormatName'),
            height?: string(name='Height'),
            region?: string(name='Region'),
            width?: string(name='Width'),
          }(name='FileBasicInfo'),
        }
      ](name='FileInfoList'),
      mediaBasicInfo?: {
        businessType?: string(name='BusinessType'),
        category?: string(name='Category'),
        coverURL?: string(name='CoverURL'),
        createTime?: string(name='CreateTime'),
        deletedTime?: string(name='DeletedTime'),
        description?: string(name='Description'),
        inputURL?: string(name='InputURL'),
        mediaId?: string(name='MediaId'),
        mediaTags?: string(name='MediaTags'),
        mediaType?: string(name='MediaType'),
        modifiedTime?: string(name='ModifiedTime'),
        snapshots?: string(name='Snapshots'),
        source?: string(name='Source'),
        status?: string(name='Status'),
        title?: string(name='Title'),
        transcodeStatus?: string(name='TranscodeStatus'),
        userData?: string(name='UserData'),
      }(name='MediaBasicInfo'),
      mediaId?: string(name='MediaId'),
    }
  ](name='MediaInfos'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListPublicMediaBasicInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPublicMediaBasicInfosResponseBody(name='body'),
}

async function listPublicMediaBasicInfosWithOptions(request: ListPublicMediaBasicInfosRequest, runtime: Util.RuntimeOptions): ListPublicMediaBasicInfosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.includeFileBasicInfo)) {
    query['IncludeFileBasicInfo'] = request.includeFileBasicInfo;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.mediaTagId)) {
    query['MediaTagId'] = request.mediaTagId;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPublicMediaBasicInfos',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPublicMediaBasicInfos(request: ListPublicMediaBasicInfosRequest): ListPublicMediaBasicInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPublicMediaBasicInfosWithOptions(request, runtime);
}

model ListSmartJobsRequest {
  jobState?: string(name='JobState'),
  jobType?: string(name='JobType'),
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  sortBy?: string(name='SortBy'),
}

model ListSmartJobsResponseBody = {
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  smartJobList?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      editingConfig?: string(name='EditingConfig'),
      inputConfig?: {
        inputFile?: string(name='InputFile'),
        keyword?: string(name='Keyword'),
      }(name='InputConfig'),
      jobId?: string(name='JobId'),
      jobState?: string(name='JobState'),
      jobType?: string(name='JobType'),
      modifiedTime?: string(name='ModifiedTime'),
      outputConfig?: {
        bucket?: string(name='Bucket'),
        object?: string(name='Object'),
      }(name='OutputConfig'),
      title?: string(name='Title'),
      userData?: string(name='UserData'),
      userId?: long(name='UserId'),
    }
  ](name='SmartJobList'),
  totalCount?: string(name='TotalCount'),
}

model ListSmartJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSmartJobsResponseBody(name='body'),
}

async function listSmartJobsWithOptions(request: ListSmartJobsRequest, runtime: Util.RuntimeOptions): ListSmartJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSmartJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSmartJobs(request: ListSmartJobsRequest): ListSmartJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSmartJobsWithOptions(request, runtime);
}

model ListSnapshotJobsRequest {
  endOfCreateTime?: string(name='EndOfCreateTime'),
  jobId?: string(name='JobId'),
  nextPageToken?: string(name='NextPageToken'),
  orderBy?: string(name='OrderBy'),
  pageSize?: int32(name='PageSize'),
  startOfCreateTime?: string(name='StartOfCreateTime'),
  status?: string(name='Status'),
}

model ListSnapshotJobsResponseBody = {
  jobs?: [ 
    {
      async?: boolean(name='Async'),
      count?: int32(name='Count'),
      createTime?: string(name='CreateTime'),
      finishTime?: string(name='FinishTime'),
      input?: {
        media?: string(name='Media'),
        type?: string(name='Type'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      modifiedTime?: string(name='ModifiedTime'),
      name?: string(name='Name'),
      output?: {
        media?: string(name='Media'),
        type?: string(name='Type'),
      }(name='Output'),
      pipelineId?: string(name='PipelineId'),
      status?: string(name='Status'),
      submitTime?: string(name='SubmitTime'),
      templateId?: string(name='TemplateId'),
      triggerSource?: string(name='TriggerSource'),
      type?: string(name='Type'),
    }
  ](name='Jobs'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListSnapshotJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSnapshotJobsResponseBody(name='body'),
}

async function listSnapshotJobsWithOptions(request: ListSnapshotJobsRequest, runtime: Util.RuntimeOptions): ListSnapshotJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endOfCreateTime)) {
    query['EndOfCreateTime'] = request.endOfCreateTime;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startOfCreateTime)) {
    query['StartOfCreateTime'] = request.startOfCreateTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSnapshotJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSnapshotJobs(request: ListSnapshotJobsRequest): ListSnapshotJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSnapshotJobsWithOptions(request, runtime);
}

model ListSystemTemplatesRequest {
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
  subtype?: string(name='Subtype'),
  templateId?: string(name='TemplateId'),
  type?: string(name='Type'),
}

model ListSystemTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  systemTemplateList?: [ 
    {
      status?: string(name='Status'),
      subtype?: int32(name='Subtype'),
      subtypeName?: string(name='SubtypeName'),
      templateConfig?: string(name='TemplateConfig'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      type?: int32(name='Type'),
      typeName?: string(name='TypeName'),
    }
  ](name='SystemTemplateList'),
  total?: int32(name='Total'),
}

model ListSystemTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSystemTemplatesResponseBody(name='body'),
}

async function listSystemTemplatesWithOptions(request: ListSystemTemplatesRequest, runtime: Util.RuntimeOptions): ListSystemTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.subtype)) {
    query['Subtype'] = request.subtype;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSystemTemplates',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSystemTemplates(request: ListSystemTemplatesRequest): ListSystemTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSystemTemplatesWithOptions(request, runtime);
}

model ListTemplatesRequest {
  createSource?: string(name='CreateSource'),
  keyword?: string(name='Keyword'),
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  sortType?: string(name='SortType'),
  status?: string(name='Status'),
  type?: string(name='Type'),
}

model ListTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  templates?: [ 
    {
      clipsParam?: string(name='ClipsParam'),
      config?: string(name='Config'),
      coverURL?: string(name='CoverURL'),
      createSource?: string(name='CreateSource'),
      creationTime?: string(name='CreationTime'),
      modifiedSource?: string(name='ModifiedSource'),
      modifiedTime?: string(name='ModifiedTime'),
      name?: string(name='Name'),
      previewMedia?: string(name='PreviewMedia'),
      previewMediaStatus?: string(name='PreviewMediaStatus'),
      status?: string(name='Status'),
      templateId?: string(name='TemplateId'),
      type?: string(name='Type'),
    }
  ](name='Templates'),
  totalCount?: int32(name='TotalCount'),
}

model ListTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTemplatesResponseBody(name='body'),
}

async function listTemplatesWithOptions(request: ListTemplatesRequest, runtime: Util.RuntimeOptions): ListTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createSource)) {
    query['CreateSource'] = request.createSource;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortType)) {
    query['SortType'] = request.sortType;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTemplates',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTemplates(request: ListTemplatesRequest): ListTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTemplatesWithOptions(request, runtime);
}

model ListTranscodeJobsRequest {
  endOfCreateTime?: string(name='EndOfCreateTime'),
  jobId?: string(name='JobId'),
  nextPageToken?: string(name='NextPageToken'),
  orderBy?: string(name='OrderBy'),
  pageSize?: int32(name='PageSize'),
  startOfCreateTime?: string(name='StartOfCreateTime'),
  status?: string(name='Status'),
}

model ListTranscodeJobsResponseBody = {
  jobs?: [ 
    {
      createTime?: string(name='CreateTime'),
      finishTime?: string(name='FinishTime'),
      inputGroup?: [ 
        {
          media?: string(name='Media'),
          type?: string(name='Type'),
        }
      ](name='InputGroup'),
      jobCount?: int32(name='JobCount'),
      name?: string(name='Name'),
      outputGroup?: [ 
        {
          output?: {
            media?: string(name='Media'),
            type?: string(name='Type'),
          }(name='Output'),
          processConfig?: {
            combineConfigs?: [ 
              {
                audioIndex?: string(name='AudioIndex'),
                duration?: double(name='Duration'),
                start?: double(name='Start'),
                videoIndex?: string(name='VideoIndex'),
              }
            ](name='CombineConfigs'),
            encryption?: {
              cipherText?: string(name='CipherText'),
              decryptKeyUri?: string(name='DecryptKeyUri'),
              encryptType?: string(name='EncryptType'),
            }(name='Encryption'),
            imageWatermarks?: [ 
              {
                overwriteParams?: {
                  dx?: string(name='Dx'),
                  dy?: string(name='Dy'),
                  file?: {
                    media?: string(name='Media'),
                    type?: string(name='Type'),
                  }(name='File'),
                  height?: string(name='Height'),
                  referPos?: string(name='ReferPos'),
                  timeline?: {
                    duration?: string(name='Duration'),
                    start?: string(name='Start'),
                  }(name='Timeline'),
                  width?: string(name='Width'),
                }(name='OverwriteParams'),
                templateId?: string(name='TemplateId'),
              }
            ](name='ImageWatermarks'),
            subtitles?: [ 
              {
                overwriteParams?: {
                  charEnc?: string(name='CharEnc'),
                  file?: {
                    media?: string(name='Media'),
                    type?: string(name='Type'),
                  }(name='File'),
                  format?: string(name='Format'),
                }(name='OverwriteParams'),
                templateId?: string(name='TemplateId'),
              }
            ](name='Subtitles'),
            textWatermarks?: [ 
              {
                overwriteParams?: {
                  adaptive?: string(name='Adaptive'),
                  borderColor?: string(name='BorderColor'),
                  borderWidth?: int32(name='BorderWidth'),
                  content?: string(name='Content'),
                  fontAlpha?: string(name='FontAlpha'),
                  fontColor?: string(name='FontColor'),
                  fontName?: string(name='FontName'),
                  fontSize?: int32(name='FontSize'),
                  left?: string(name='Left'),
                  top?: string(name='Top'),
                }(name='OverwriteParams'),
                templateId?: string(name='TemplateId'),
              }
            ](name='TextWatermarks'),
            transcode?: {
              overwriteParams?: {
                audio?: {
                  bitrate?: string(name='Bitrate'),
                  channels?: string(name='Channels'),
                  codec?: string(name='Codec'),
                  profile?: string(name='Profile'),
                  remove?: string(name='Remove'),
                  samplerate?: string(name='Samplerate'),
                  volume?: {
                    integratedLoudnessTarget?: string(name='IntegratedLoudnessTarget'),
                    loudnessRangeTarget?: string(name='LoudnessRangeTarget'),
                    method?: string(name='Method'),
                    truePeak?: string(name='TruePeak'),
                  }(name='Volume'),
                }(name='Audio'),
                container?: {
                  format?: string(name='Format'),
                }(name='Container'),
                muxConfig?: {
                  segment?: {
                    duration?: string(name='Duration'),
                    forceSegTime?: string(name='ForceSegTime'),
                  }(name='Segment'),
                }(name='MuxConfig'),
                video?: {
                  abrMax?: string(name='AbrMax'),
                  bitrate?: string(name='Bitrate'),
                  bufsize?: string(name='Bufsize'),
                  codec?: string(name='Codec'),
                  crf?: string(name='Crf'),
                  crop?: string(name='Crop'),
                  fps?: string(name='Fps'),
                  gop?: string(name='Gop'),
                  height?: string(name='Height'),
                  longShortMode?: string(name='LongShortMode'),
                  maxrate?: string(name='Maxrate'),
                  pad?: string(name='Pad'),
                  pixFmt?: string(name='PixFmt'),
                  preset?: string(name='Preset'),
                  profile?: string(name='Profile'),
                  remove?: string(name='Remove'),
                  scanMode?: string(name='ScanMode'),
                  width?: string(name='Width'),
                }(name='Video'),
              }(name='OverwriteParams'),
              templateId?: string(name='TemplateId'),
            }(name='Transcode'),
          }(name='ProcessConfig'),
        }
      ](name='OutputGroup'),
      parentJobId?: string(name='ParentJobId'),
      percent?: int32(name='Percent'),
      requestId?: string(name='RequestId'),
      scheduleConfig?: {
        pipelineId?: string(name='PipelineId'),
        priority?: int32(name='Priority'),
      }(name='ScheduleConfig'),
      status?: string(name='Status'),
      submitTime?: string(name='SubmitTime'),
      triggerSource?: string(name='TriggerSource'),
      userData?: string(name='UserData'),
    }
  ](name='Jobs'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListTranscodeJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTranscodeJobsResponseBody(name='body'),
}

async function listTranscodeJobsWithOptions(request: ListTranscodeJobsRequest, runtime: Util.RuntimeOptions): ListTranscodeJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endOfCreateTime)) {
    query['EndOfCreateTime'] = request.endOfCreateTime;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startOfCreateTime)) {
    query['StartOfCreateTime'] = request.startOfCreateTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTranscodeJobs',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTranscodeJobs(request: ListTranscodeJobsRequest): ListTranscodeJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTranscodeJobsWithOptions(request, runtime);
}

model NotifyPreOssUploadCompleteRequest {
  fileName?: string(name='FileName'),
}

model NotifyPreOssUploadCompleteResponseBody = {
  requestId?: string(name='RequestId'),
}

model NotifyPreOssUploadCompleteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: NotifyPreOssUploadCompleteResponseBody(name='body'),
}

async function notifyPreOssUploadCompleteWithOptions(request: NotifyPreOssUploadCompleteRequest, runtime: Util.RuntimeOptions): NotifyPreOssUploadCompleteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'NotifyPreOssUploadComplete',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function notifyPreOssUploadComplete(request: NotifyPreOssUploadCompleteRequest): NotifyPreOssUploadCompleteResponse {
  var runtime = new Util.RuntimeOptions{};
  return notifyPreOssUploadCompleteWithOptions(request, runtime);
}

model QueryCensorJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryCensorJobListResponseBody = {
  jobs?: {
    censorJob?: [ 
    {
      barrageCensorResult?: string(name='BarrageCensorResult'),
      censorConfig?: {
        bizType?: string(name='BizType'),
        interval?: string(name='Interval'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='OutputFile'),
        saveType?: string(name='SaveType'),
        scenes?: string(name='Scenes'),
      }(name='CensorConfig'),
      censorPornResult?: {
        averageScore?: string(name='AverageScore'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
        pornCounterList?: {
          counter?: [ 
          {
            count?: int32(name='Count'),
            label?: string(name='Label'),
          }
        ](name='Counter')
        }(name='PornCounterList'),
        pornTopList?: {
          top?: [ 
          {
            index?: string(name='Index'),
            label?: string(name='Label'),
            object?: string(name='Object'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
          }
        ](name='Top')
        }(name='PornTopList'),
        suggestion?: string(name='Suggestion'),
      }(name='CensorPornResult'),
      censorTerrorismResult?: {
        averageScore?: string(name='AverageScore'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
        suggestion?: string(name='Suggestion'),
        terrorismCounterList?: {
          counter?: [ 
          {
            count?: int32(name='Count'),
            label?: string(name='Label'),
          }
        ](name='Counter')
        }(name='TerrorismCounterList'),
        terrorismTopList?: {
          top?: [ 
          {
            index?: string(name='Index'),
            label?: string(name='Label'),
            object?: string(name='Object'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
          }
        ](name='Top')
        }(name='TerrorismTopList'),
      }(name='CensorTerrorismResult'),
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      descCensorResult?: string(name='DescCensorResult'),
      id?: string(name='Id'),
      imageCensorResults?: {
        imageCensorResult?: [ 
        {
          imageBucket?: string(name='ImageBucket'),
          imageLocation?: string(name='ImageLocation'),
          imageObject?: string(name='ImageObject'),
          result?: string(name='Result'),
        }
      ](name='ImageCensorResult')
      }(name='ImageCensorResults'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      resultSaveObject?: string(name='ResultSaveObject'),
      state?: string(name='State'),
      titleCensorResult?: string(name='TitleCensorResult'),
      userData?: string(name='UserData'),
    }
  ](name='CensorJob')
  }(name='Jobs'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryCensorJobListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryCensorJobListResponseBody(name='body'),
}

async function queryCensorJobListWithOptions(request: QueryCensorJobListRequest, runtime: Util.RuntimeOptions): QueryCensorJobListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobIds)) {
    query['JobIds'] = request.jobIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryCensorJobList',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryCensorJobList(request: QueryCensorJobListRequest): QueryCensorJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCensorJobListWithOptions(request, runtime);
}

model QueryDNAJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryDNAJobListResponseBody = {
  jobList?: [ 
    {
      code?: string(name='Code'),
      config?: string(name='Config'),
      creationTime?: string(name='CreationTime'),
      DBId?: string(name='DBId'),
      DNAResult?: string(name='DNAResult'),
      finishTime?: string(name='FinishTime'),
      id?: string(name='Id'),
      input?: {
        media?: string(name='Media'),
        type?: string(name='Type'),
      }(name='Input'),
      message?: string(name='Message'),
      primaryKey?: string(name='PrimaryKey'),
      status?: string(name='Status'),
      userData?: string(name='UserData'),
    }
  ](name='JobList'),
  requestId?: string(name='RequestId'),
}

model QueryDNAJobListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDNAJobListResponseBody(name='body'),
}

async function queryDNAJobListWithOptions(request: QueryDNAJobListRequest, runtime: Util.RuntimeOptions): QueryDNAJobListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobIds)) {
    query['JobIds'] = request.jobIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDNAJobList',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDNAJobList(request: QueryDNAJobListRequest): QueryDNAJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDNAJobListWithOptions(request, runtime);
}

model QueryIProductionJobRequest {
  clientToken?: string(name='ClientToken'),
  jobId?: string(name='JobId'),
}

model QueryIProductionJobResponseBody = {
  createTime?: string(name='CreateTime'),
  finishTime?: string(name='FinishTime'),
  functionName?: string(name='FunctionName'),
  input?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Input'),
  jobId?: string(name='JobId'),
  jobParams?: string(name='JobParams'),
  name?: string(name='Name'),
  output?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Output'),
  outputFiles?: [ string ](name='OutputFiles'),
  outputUrls?: [ string ](name='OutputUrls'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId'),
    priority?: int32(name='Priority'),
  }(name='ScheduleConfig'),
  status?: string(name='Status'),
  templateId?: string(name='TemplateId'),
  userData?: string(name='UserData'),
}

model QueryIProductionJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryIProductionJobResponseBody(name='body'),
}

async function queryIProductionJobWithOptions(request: QueryIProductionJobRequest, runtime: Util.RuntimeOptions): QueryIProductionJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryIProductionJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryIProductionJob(request: QueryIProductionJobRequest): QueryIProductionJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIProductionJobWithOptions(request, runtime);
}

model QueryMediaCensorJobDetailRequest {
  jobId?: string(name='JobId'),
  maximumPageSize?: long(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryMediaCensorJobDetailResponseBody = {
  mediaCensorJobDetail?: {
    barrageCensorResult?: {
      label?: string(name='Label'),
      rate?: string(name='Rate'),
      scene?: string(name='Scene'),
      suggestion?: string(name='Suggestion'),
    }(name='BarrageCensorResult'),
    code?: string(name='Code'),
    coverImageCensorResults?: {
      coverImageCensorResult?: [ 
      {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        results?: {
          result?: [ 
          {
            label?: string(name='Label'),
            rate?: string(name='Rate'),
            scene?: string(name='Scene'),
            suggestion?: string(name='Suggestion'),
          }
        ](name='Result')
        }(name='Results'),
      }
    ](name='CoverImageCensorResult')
    }(name='CoverImageCensorResults'),
    creationTime?: string(name='CreationTime'),
    descCensorResult?: {
      label?: string(name='Label'),
      rate?: string(name='Rate'),
      scene?: string(name='Scene'),
      suggestion?: string(name='Suggestion'),
    }(name='DescCensorResult'),
    finishTime?: string(name='FinishTime'),
    input?: {
      bucket?: string(name='Bucket'),
      location?: string(name='Location'),
      object?: string(name='Object'),
    }(name='Input'),
    jobId?: string(name='JobId'),
    message?: string(name='Message'),
    pipelineId?: string(name='PipelineId'),
    state?: string(name='State'),
    suggestion?: string(name='Suggestion'),
    titleCensorResult?: {
      label?: string(name='Label'),
      rate?: string(name='Rate'),
      scene?: string(name='Scene'),
      suggestion?: string(name='Suggestion'),
    }(name='TitleCensorResult'),
    userData?: string(name='UserData'),
    vensorCensorResult?: {
      censorResults?: {
        censorResult?: [ 
        {
          label?: string(name='Label'),
          rate?: string(name='Rate'),
          scene?: string(name='Scene'),
          suggestion?: string(name='Suggestion'),
        }
      ](name='CensorResult')
      }(name='CensorResults'),
      nextPageToken?: string(name='NextPageToken'),
      videoTimelines?: {
        videoTimeline?: [ 
        {
          censorResults?: {
            censorResult?: [ 
            {
              label?: string(name='Label'),
              rate?: string(name='Rate'),
              scene?: string(name='Scene'),
              suggestion?: string(name='Suggestion'),
            }
          ](name='CensorResult')
          }(name='CensorResults'),
          object?: string(name='Object'),
          timestamp?: string(name='Timestamp'),
        }
      ](name='VideoTimeline')
      }(name='VideoTimelines'),
    }(name='VensorCensorResult'),
    videoCensorConfig?: {
      bizType?: string(name='BizType'),
      outputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='OutputFile'),
      videoCensor?: string(name='VideoCensor'),
    }(name='VideoCensorConfig'),
  }(name='MediaCensorJobDetail'),
  requestId?: string(name='RequestId'),
}

model QueryMediaCensorJobDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMediaCensorJobDetailResponseBody(name='body'),
}

async function queryMediaCensorJobDetailWithOptions(request: QueryMediaCensorJobDetailRequest, runtime: Util.RuntimeOptions): QueryMediaCensorJobDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.maximumPageSize)) {
    query['MaximumPageSize'] = request.maximumPageSize;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaCensorJobDetail',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaCensorJobDetail(request: QueryMediaCensorJobDetailRequest): QueryMediaCensorJobDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaCensorJobDetailWithOptions(request, runtime);
}

model QuerySmarttagJobRequest {
  jobId?: string(name='JobId'),
  params?: string(name='Params'),
}

model QuerySmarttagJobResponseBody = {
  jobStatus?: string(name='JobStatus'),
  requestId?: string(name='RequestId'),
  results?: {
    result?: [ 
    {
      data?: string(name='Data'),
      type?: string(name='Type'),
    }
  ](name='Result')
  }(name='Results'),
  userData?: string(name='UserData'),
}

model QuerySmarttagJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySmarttagJobResponseBody(name='body'),
}

async function querySmarttagJobWithOptions(request: QuerySmarttagJobRequest, runtime: Util.RuntimeOptions): QuerySmarttagJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.params)) {
    query['Params'] = request.params;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySmarttagJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySmarttagJob(request: QuerySmarttagJobRequest): QuerySmarttagJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySmarttagJobWithOptions(request, runtime);
}

model RefreshUploadMediaRequest {
  mediaId?: string(name='MediaId'),
}

model RefreshUploadMediaResponseBody = {
  mediaId?: string(name='MediaId'),
  requestId?: string(name='RequestId'),
  uploadAddress?: string(name='UploadAddress'),
  uploadAuth?: string(name='UploadAuth'),
}

model RefreshUploadMediaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefreshUploadMediaResponseBody(name='body'),
}

async function refreshUploadMediaWithOptions(request: RefreshUploadMediaRequest, runtime: Util.RuntimeOptions): RefreshUploadMediaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshUploadMedia',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshUploadMedia(request: RefreshUploadMediaRequest): RefreshUploadMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshUploadMediaWithOptions(request, runtime);
}

model RegisterMediaInfoRequest {
  businessType?: string(name='BusinessType'),
  cateId?: long(name='CateId'),
  clientToken?: string(name='ClientToken'),
  coverURL?: string(name='CoverURL'),
  description?: string(name='Description'),
  inputURL?: string(name='InputURL'),
  mediaTags?: string(name='MediaTags'),
  mediaType?: string(name='MediaType'),
  overwrite?: boolean(name='Overwrite'),
  referenceId?: string(name='ReferenceId'),
  registerConfig?: string(name='RegisterConfig'),
  title?: string(name='Title'),
  userData?: string(name='UserData'),
  workflowId?: string(name='WorkflowId'),
}

model RegisterMediaInfoResponseBody = {
  mediaId?: string(name='MediaId'),
  requestId?: string(name='RequestId'),
}

model RegisterMediaInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterMediaInfoResponseBody(name='body'),
}

async function registerMediaInfoWithOptions(request: RegisterMediaInfoRequest, runtime: Util.RuntimeOptions): RegisterMediaInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessType)) {
    query['BusinessType'] = request.businessType;
  }
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.coverURL)) {
    query['CoverURL'] = request.coverURL;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.inputURL)) {
    query['InputURL'] = request.inputURL;
  }
  if (!Util.isUnset(request.mediaTags)) {
    query['MediaTags'] = request.mediaTags;
  }
  if (!Util.isUnset(request.mediaType)) {
    query['MediaType'] = request.mediaType;
  }
  if (!Util.isUnset(request.overwrite)) {
    query['Overwrite'] = request.overwrite;
  }
  if (!Util.isUnset(request.referenceId)) {
    query['ReferenceId'] = request.referenceId;
  }
  if (!Util.isUnset(request.registerConfig)) {
    query['RegisterConfig'] = request.registerConfig;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  if (!Util.isUnset(request.workflowId)) {
    query['WorkflowId'] = request.workflowId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RegisterMediaInfo',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerMediaInfo(request: RegisterMediaInfoRequest): RegisterMediaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerMediaInfoWithOptions(request, runtime);
}

model RegisterMediaStreamRequest {
  inputURL?: string(name='InputURL'),
  mediaId?: string(name='MediaId'),
  userData?: string(name='UserData'),
}

model RegisterMediaStreamResponseBody = {
  mediaId?: string(name='MediaId'),
  requestId?: string(name='RequestId'),
}

model RegisterMediaStreamResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterMediaStreamResponseBody(name='body'),
}

async function registerMediaStreamWithOptions(request: RegisterMediaStreamRequest, runtime: Util.RuntimeOptions): RegisterMediaStreamResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.inputURL)) {
    query['InputURL'] = request.inputURL;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RegisterMediaStream',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerMediaStream(request: RegisterMediaStreamRequest): RegisterMediaStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerMediaStreamWithOptions(request, runtime);
}

model SearchEditingProjectRequest {
  createSource?: string(name='CreateSource'),
  endTime?: string(name='EndTime'),
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  projectType?: string(name='ProjectType'),
  sortBy?: string(name='SortBy'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
  templateType?: string(name='TemplateType'),
}

model SearchEditingProjectResponseBody = {
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  projectList?: [ 
    {
      businessConfig?: string(name='BusinessConfig'),
      businessStatus?: string(name='BusinessStatus'),
      coverURL?: string(name='CoverURL'),
      createSource?: string(name='CreateSource'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      duration?: long(name='Duration'),
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      modifiedSource?: string(name='ModifiedSource'),
      modifiedTime?: string(name='ModifiedTime'),
      projectId?: string(name='ProjectId'),
      projectType?: string(name='ProjectType'),
      status?: string(name='Status'),
      templateType?: string(name='TemplateType'),
      timeline?: string(name='Timeline'),
      title?: string(name='Title'),
    }
  ](name='ProjectList'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model SearchEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchEditingProjectResponseBody(name='body'),
}

async function searchEditingProjectWithOptions(request: SearchEditingProjectRequest, runtime: Util.RuntimeOptions): SearchEditingProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createSource)) {
    query['CreateSource'] = request.createSource;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.projectType)) {
    query['ProjectType'] = request.projectType;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.templateType)) {
    query['TemplateType'] = request.templateType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchEditingProject',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchEditingProject(request: SearchEditingProjectRequest): SearchEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchEditingProjectWithOptions(request, runtime);
}

model SearchMediaRequest {
  entityId?: string(name='EntityId'),
  match?: string(name='Match'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  sortBy?: string(name='SortBy'),
}

model SearchMediaResponseBody = {
  code?: string(name='Code'),
  mediaInfoList?: [ 
    {
      fileInfoList?: [ 
        {
          fileBasicInfo?: {
            bitrate?: string(name='Bitrate'),
            createTime?: string(name='CreateTime'),
            duration?: string(name='Duration'),
            fileName?: string(name='FileName'),
            fileSize?: string(name='FileSize'),
            fileStatus?: string(name='FileStatus'),
            fileType?: string(name='FileType'),
            fileUrl?: string(name='FileUrl'),
            formatName?: string(name='FormatName'),
            height?: string(name='Height'),
            modifiedTime?: string(name='ModifiedTime'),
            region?: string(name='Region'),
            width?: string(name='Width'),
          }(name='FileBasicInfo'),
        }
      ](name='FileInfoList'),
      mediaBasicInfo?: {
        biz?: string(name='Biz'),
        businessType?: string(name='BusinessType'),
        cateId?: long(name='CateId'),
        cateName?: string(name='CateName'),
        category?: string(name='Category'),
        coverURL?: string(name='CoverURL'),
        createTime?: string(name='CreateTime'),
        deletedTime?: string(name='DeletedTime'),
        description?: string(name='Description'),
        inputURL?: string(name='InputURL'),
        mediaId?: string(name='MediaId'),
        mediaTags?: string(name='MediaTags'),
        mediaType?: string(name='MediaType'),
        modifiedTime?: string(name='ModifiedTime'),
        referenceId?: string(name='ReferenceId'),
        snapshots?: string(name='Snapshots'),
        source?: string(name='Source'),
        spriteImages?: string(name='SpriteImages'),
        status?: string(name='Status'),
        title?: string(name='Title'),
        transcodeStatus?: string(name='TranscodeStatus'),
        uploadSource?: string(name='UploadSource'),
        userData?: string(name='UserData'),
      }(name='MediaBasicInfo'),
      mediaId?: string(name='MediaId'),
    }
  ](name='MediaInfoList'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  total?: long(name='Total'),
}

model SearchMediaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchMediaResponseBody(name='body'),
}

async function searchMediaWithOptions(request: SearchMediaRequest, runtime: Util.RuntimeOptions): SearchMediaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.entityId)) {
    query['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.match)) {
    query['Match'] = request.match;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchMedia',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchMedia(request: SearchMediaRequest): SearchMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchMediaWithOptions(request, runtime);
}

model SearchPublicMediaInfoRequest {
  authorized?: boolean(name='Authorized'),
  dynamicMetaDataMatchFields?: string(name='DynamicMetaDataMatchFields'),
  entityId?: string(name='EntityId'),
  favorite?: boolean(name='Favorite'),
  mediaIds?: string(name='MediaIds'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  sortBy?: string(name='SortBy'),
}

model SearchPublicMediaInfoResponseBody = {
  publicMediaInfos?: [ 
    {
      authorized?: boolean(name='Authorized'),
      favorite?: boolean(name='Favorite'),
      mediaInfo?: {
        dynamicMetaData?: {
          data?: string(name='Data'),
          type?: string(name='Type'),
        }(name='DynamicMetaData'),
        mediaBasicInfo?: {
          businessType?: string(name='BusinessType'),
          category?: string(name='Category'),
          coverURL?: string(name='CoverURL'),
          createTime?: string(name='CreateTime'),
          deletedTime?: string(name='DeletedTime'),
          description?: string(name='Description'),
          mediaId?: string(name='MediaId'),
          mediaTags?: string(name='MediaTags'),
          mediaType?: string(name='MediaType'),
          modifiedTime?: string(name='ModifiedTime'),
          source?: string(name='Source'),
          spriteImages?: string(name='SpriteImages'),
          status?: string(name='Status'),
          title?: string(name='Title'),
          userData?: string(name='UserData'),
        }(name='MediaBasicInfo'),
        mediaId?: string(name='MediaId'),
      }(name='MediaInfo'),
      remainingAuthTime?: string(name='RemainingAuthTime'),
    }
  ](name='PublicMediaInfos'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model SearchPublicMediaInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchPublicMediaInfoResponseBody(name='body'),
}

async function searchPublicMediaInfoWithOptions(request: SearchPublicMediaInfoRequest, runtime: Util.RuntimeOptions): SearchPublicMediaInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authorized)) {
    query['Authorized'] = request.authorized;
  }
  if (!Util.isUnset(request.dynamicMetaDataMatchFields)) {
    query['DynamicMetaDataMatchFields'] = request.dynamicMetaDataMatchFields;
  }
  if (!Util.isUnset(request.entityId)) {
    query['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.favorite)) {
    query['Favorite'] = request.favorite;
  }
  if (!Util.isUnset(request.mediaIds)) {
    query['MediaIds'] = request.mediaIds;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchPublicMediaInfo',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchPublicMediaInfo(request: SearchPublicMediaInfoRequest): SearchPublicMediaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchPublicMediaInfoWithOptions(request, runtime);
}

model SendLiveSnapshotJobCommandRequest {
  command?: string(name='Command'),
  jobId?: string(name='JobId'),
}

model SendLiveSnapshotJobCommandResponseBody = {
  requestId?: string(name='RequestId'),
}

model SendLiveSnapshotJobCommandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SendLiveSnapshotJobCommandResponseBody(name='body'),
}

async function sendLiveSnapshotJobCommandWithOptions(request: SendLiveSnapshotJobCommandRequest, runtime: Util.RuntimeOptions): SendLiveSnapshotJobCommandResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.command)) {
    body['Command'] = request.command;
  }
  if (!Util.isUnset(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SendLiveSnapshotJobCommand',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendLiveSnapshotJobCommand(request: SendLiveSnapshotJobCommandRequest): SendLiveSnapshotJobCommandResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendLiveSnapshotJobCommandWithOptions(request, runtime);
}

model SendLiveTranscodeJobCommandRequest {
  command?: string(name='Command'),
  jobId?: string(name='JobId'),
}

model SendLiveTranscodeJobCommandResponseBody = {
  requestId?: string(name='RequestId'),
}

model SendLiveTranscodeJobCommandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SendLiveTranscodeJobCommandResponseBody(name='body'),
}

async function sendLiveTranscodeJobCommandWithOptions(request: SendLiveTranscodeJobCommandRequest, runtime: Util.RuntimeOptions): SendLiveTranscodeJobCommandResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.command)) {
    query['Command'] = request.command;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SendLiveTranscodeJobCommand',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendLiveTranscodeJobCommand(request: SendLiveTranscodeJobCommandRequest): SendLiveTranscodeJobCommandResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendLiveTranscodeJobCommandWithOptions(request, runtime);
}

model SetDefaultCustomTemplateRequest {
  templateId?: string(name='TemplateId'),
}

model SetDefaultCustomTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetDefaultCustomTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDefaultCustomTemplateResponseBody(name='body'),
}

async function setDefaultCustomTemplateWithOptions(request: SetDefaultCustomTemplateRequest, runtime: Util.RuntimeOptions): SetDefaultCustomTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDefaultCustomTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDefaultCustomTemplate(request: SetDefaultCustomTemplateRequest): SetDefaultCustomTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultCustomTemplateWithOptions(request, runtime);
}

model SetDefaultStorageLocationRequest {
  bucket?: string(name='Bucket'),
  path?: string(name='Path'),
  storageType?: string(name='StorageType'),
}

model SetDefaultStorageLocationResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetDefaultStorageLocationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDefaultStorageLocationResponseBody(name='body'),
}

async function setDefaultStorageLocationWithOptions(request: SetDefaultStorageLocationRequest, runtime: Util.RuntimeOptions): SetDefaultStorageLocationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bucket)) {
    query['Bucket'] = request.bucket;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDefaultStorageLocation',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDefaultStorageLocation(request: SetDefaultStorageLocationRequest): SetDefaultStorageLocationResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultStorageLocationWithOptions(request, runtime);
}

model SetEventCallbackRequest {
  authKey?: string(name='AuthKey'),
  authSwitch?: string(name='AuthSwitch'),
  callbackQueueName?: string(name='CallbackQueueName'),
  callbackType?: string(name='CallbackType'),
  callbackURL?: string(name='CallbackURL'),
  eventTypeList?: string(name='EventTypeList'),
}

model SetEventCallbackResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetEventCallbackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetEventCallbackResponseBody(name='body'),
}

async function setEventCallbackWithOptions(request: SetEventCallbackRequest, runtime: Util.RuntimeOptions): SetEventCallbackResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authKey)) {
    query['AuthKey'] = request.authKey;
  }
  if (!Util.isUnset(request.authSwitch)) {
    query['AuthSwitch'] = request.authSwitch;
  }
  if (!Util.isUnset(request.callbackQueueName)) {
    query['CallbackQueueName'] = request.callbackQueueName;
  }
  if (!Util.isUnset(request.callbackType)) {
    query['CallbackType'] = request.callbackType;
  }
  if (!Util.isUnset(request.callbackURL)) {
    query['CallbackURL'] = request.callbackURL;
  }
  if (!Util.isUnset(request.eventTypeList)) {
    query['EventTypeList'] = request.eventTypeList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetEventCallback',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setEventCallback(request: SetEventCallbackRequest): SetEventCallbackResponse {
  var runtime = new Util.RuntimeOptions{};
  return setEventCallbackWithOptions(request, runtime);
}

model SubmitASRJobRequest {
  description?: string(name='Description'),
  duration?: string(name='Duration'),
  inputFile?: string(name='InputFile'),
  startTime?: string(name='StartTime'),
  title?: string(name='Title'),
  userData?: string(name='UserData'),
}

model SubmitASRJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
  state?: string(name='State'),
}

model SubmitASRJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitASRJobResponseBody(name='body'),
}

async function submitASRJobWithOptions(request: SubmitASRJobRequest, runtime: Util.RuntimeOptions): SubmitASRJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.inputFile)) {
    query['InputFile'] = request.inputFile;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitASRJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitASRJob(request: SubmitASRJobRequest): SubmitASRJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitASRJobWithOptions(request, runtime);
}

model SubmitAudioProduceJobRequest {
  description?: string(name='Description'),
  editingConfig?: string(name='EditingConfig'),
  inputConfig?: string(name='InputConfig'),
  outputConfig?: string(name='OutputConfig'),
  overwrite?: boolean(name='Overwrite'),
  title?: string(name='Title'),
  userData?: string(name='UserData'),
}

model SubmitAudioProduceJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
  state?: string(name='State'),
}

model SubmitAudioProduceJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitAudioProduceJobResponseBody(name='body'),
}

async function submitAudioProduceJobWithOptions(request: SubmitAudioProduceJobRequest, runtime: Util.RuntimeOptions): SubmitAudioProduceJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.editingConfig)) {
    query['EditingConfig'] = request.editingConfig;
  }
  if (!Util.isUnset(request.inputConfig)) {
    query['InputConfig'] = request.inputConfig;
  }
  if (!Util.isUnset(request.outputConfig)) {
    query['OutputConfig'] = request.outputConfig;
  }
  if (!Util.isUnset(request.overwrite)) {
    query['Overwrite'] = request.overwrite;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitAudioProduceJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitAudioProduceJob(request: SubmitAudioProduceJobRequest): SubmitAudioProduceJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAudioProduceJobWithOptions(request, runtime);
}

model SubmitBatchMediaProducingJobRequest {
  clientToken?: string(name='ClientToken'),
  clipsParam?: string(name='ClipsParam'),
  editingProduceConfig?: string(name='EditingProduceConfig'),
  jobTitle?: string(name='JobTitle'),
  outputMediaConfig?: string(name='OutputMediaConfig'),
  outputMediaTarget?: string(name='OutputMediaTarget'),
  outputNum?: int32(name='OutputNum'),
  projectMetadata?: string(name='ProjectMetadata'),
  source?: string(name='Source'),
  submitBy?: string(name='SubmitBy'),
  templateId?: string(name='TemplateId'),
  userData?: string(name='UserData'),
}

model SubmitBatchMediaProducingJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitBatchMediaProducingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitBatchMediaProducingJobResponseBody(name='body'),
}

async function submitBatchMediaProducingJobWithOptions(request: SubmitBatchMediaProducingJobRequest, runtime: Util.RuntimeOptions): SubmitBatchMediaProducingJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clipsParam)) {
    query['ClipsParam'] = request.clipsParam;
  }
  if (!Util.isUnset(request.editingProduceConfig)) {
    query['EditingProduceConfig'] = request.editingProduceConfig;
  }
  if (!Util.isUnset(request.jobTitle)) {
    query['JobTitle'] = request.jobTitle;
  }
  if (!Util.isUnset(request.outputMediaConfig)) {
    query['OutputMediaConfig'] = request.outputMediaConfig;
  }
  if (!Util.isUnset(request.outputMediaTarget)) {
    query['OutputMediaTarget'] = request.outputMediaTarget;
  }
  if (!Util.isUnset(request.outputNum)) {
    query['OutputNum'] = request.outputNum;
  }
  if (!Util.isUnset(request.projectMetadata)) {
    query['ProjectMetadata'] = request.projectMetadata;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.submitBy)) {
    query['SubmitBy'] = request.submitBy;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitBatchMediaProducingJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitBatchMediaProducingJob(request: SubmitBatchMediaProducingJobRequest): SubmitBatchMediaProducingJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitBatchMediaProducingJobWithOptions(request, runtime);
}

model SubmitDNAJobRequest {
  config?: string(name='Config'),
  DBId?: string(name='DBId'),
  input?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  primaryKey?: string(name='PrimaryKey'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
  userData?: string(name='UserData'),
}

model SubmitDNAJobShrinkRequest {
  config?: string(name='Config'),
  DBId?: string(name='DBId'),
  inputShrink?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  primaryKey?: string(name='PrimaryKey'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
  userData?: string(name='UserData'),
}

model SubmitDNAJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitDNAJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitDNAJobResponseBody(name='body'),
}

async function submitDNAJobWithOptions(tmpReq: SubmitDNAJobRequest, runtime: Util.RuntimeOptions): SubmitDNAJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitDNAJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.input)) {
    request.inputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.input, 'Input', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.DBId)) {
    query['DBId'] = request.DBId;
  }
  if (!Util.isUnset(request.inputShrink)) {
    query['Input'] = request.inputShrink;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.primaryKey)) {
    query['PrimaryKey'] = request.primaryKey;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitDNAJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitDNAJob(request: SubmitDNAJobRequest): SubmitDNAJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitDNAJobWithOptions(request, runtime);
}

model SubmitDynamicChartJobRequest {
  axisParams?: string(name='AxisParams'),
  background?: string(name='Background'),
  chartConfig?: string(name='ChartConfig'),
  chartTitle?: string(name='ChartTitle'),
  chartType?: string(name='ChartType'),
  dataSource?: string(name='DataSource'),
  description?: string(name='Description'),
  input?: string(name='Input'),
  outputConfig?: string(name='OutputConfig'),
  subtitle?: string(name='Subtitle'),
  title?: string(name='Title'),
  unit?: string(name='Unit'),
  userData?: string(name='UserData'),
}

model SubmitDynamicChartJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitDynamicChartJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitDynamicChartJobResponseBody(name='body'),
}

async function submitDynamicChartJobWithOptions(request: SubmitDynamicChartJobRequest, runtime: Util.RuntimeOptions): SubmitDynamicChartJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.axisParams)) {
    query['AxisParams'] = request.axisParams;
  }
  if (!Util.isUnset(request.background)) {
    query['Background'] = request.background;
  }
  if (!Util.isUnset(request.chartConfig)) {
    query['ChartConfig'] = request.chartConfig;
  }
  if (!Util.isUnset(request.chartTitle)) {
    query['ChartTitle'] = request.chartTitle;
  }
  if (!Util.isUnset(request.chartType)) {
    query['ChartType'] = request.chartType;
  }
  if (!Util.isUnset(request.dataSource)) {
    query['DataSource'] = request.dataSource;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.input)) {
    query['Input'] = request.input;
  }
  if (!Util.isUnset(request.outputConfig)) {
    query['OutputConfig'] = request.outputConfig;
  }
  if (!Util.isUnset(request.subtitle)) {
    query['Subtitle'] = request.subtitle;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.unit)) {
    query['Unit'] = request.unit;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitDynamicChartJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitDynamicChartJob(request: SubmitDynamicChartJobRequest): SubmitDynamicChartJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitDynamicChartJobWithOptions(request, runtime);
}

model SubmitDynamicImageJobRequest {
  input?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Input'),
  name?: string(name='Name'),
  output?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Output'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId'),
    priority?: int32(name='Priority'),
  }(name='ScheduleConfig'),
  templateConfig?: {
    overwriteParams?: {
      format?: string(name='Format'),
      fps?: int32(name='Fps'),
      height?: int32(name='Height'),
      longShortMode?: boolean(name='LongShortMode'),
      scanMode?: string(name='ScanMode'),
      timeSpan?: {
        duration?: string(name='Duration'),
        end?: string(name='End'),
        seek?: string(name='Seek'),
      }(name='TimeSpan'),
      width?: int32(name='Width'),
    }(name='OverwriteParams'),
    templateId?: string(name='TemplateId'),
  }(name='TemplateConfig'),
  userData?: string(name='UserData'),
}

model SubmitDynamicImageJobShrinkRequest {
  inputShrink?: string(name='Input'),
  name?: string(name='Name'),
  outputShrink?: string(name='Output'),
  scheduleConfigShrink?: string(name='ScheduleConfig'),
  templateConfigShrink?: string(name='TemplateConfig'),
  userData?: string(name='UserData'),
}

model SubmitDynamicImageJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitDynamicImageJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitDynamicImageJobResponseBody(name='body'),
}

async function submitDynamicImageJobWithOptions(tmpReq: SubmitDynamicImageJobRequest, runtime: Util.RuntimeOptions): SubmitDynamicImageJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitDynamicImageJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.input)) {
    request.inputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.input, 'Input', 'json');
  }
  if (!Util.isUnset(tmpReq.output)) {
    request.outputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.output, 'Output', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleConfig)) {
    request.scheduleConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleConfig, 'ScheduleConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.templateConfig)) {
    request.templateConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.templateConfig, 'TemplateConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.inputShrink)) {
    query['Input'] = request.inputShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.outputShrink)) {
    query['Output'] = request.outputShrink;
  }
  if (!Util.isUnset(request.scheduleConfigShrink)) {
    query['ScheduleConfig'] = request.scheduleConfigShrink;
  }
  if (!Util.isUnset(request.templateConfigShrink)) {
    query['TemplateConfig'] = request.templateConfigShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitDynamicImageJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitDynamicImageJob(request: SubmitDynamicImageJobRequest): SubmitDynamicImageJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitDynamicImageJobWithOptions(request, runtime);
}

model SubmitIProductionJobRequest {
  functionName?: string(name='FunctionName'),
  input?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Input'),
  jobParams?: string(name='JobParams'),
  name?: string(name='Name'),
  output?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Output'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId'),
    priority?: int32(name='Priority'),
  }(name='ScheduleConfig'),
  templateId?: string(name='TemplateId'),
  userData?: string(name='UserData'),
}

model SubmitIProductionJobShrinkRequest {
  functionName?: string(name='FunctionName'),
  inputShrink?: string(name='Input'),
  jobParams?: string(name='JobParams'),
  name?: string(name='Name'),
  outputShrink?: string(name='Output'),
  scheduleConfigShrink?: string(name='ScheduleConfig'),
  templateId?: string(name='TemplateId'),
  userData?: string(name='UserData'),
}

model SubmitIProductionJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitIProductionJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitIProductionJobResponseBody(name='body'),
}

async function submitIProductionJobWithOptions(tmpReq: SubmitIProductionJobRequest, runtime: Util.RuntimeOptions): SubmitIProductionJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitIProductionJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.input)) {
    request.inputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.input, 'Input', 'json');
  }
  if (!Util.isUnset(tmpReq.output)) {
    request.outputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.output, 'Output', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleConfig)) {
    request.scheduleConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleConfig, 'ScheduleConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }
  if (!Util.isUnset(request.inputShrink)) {
    query['Input'] = request.inputShrink;
  }
  if (!Util.isUnset(request.jobParams)) {
    query['JobParams'] = request.jobParams;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.outputShrink)) {
    query['Output'] = request.outputShrink;
  }
  if (!Util.isUnset(request.scheduleConfigShrink)) {
    query['ScheduleConfig'] = request.scheduleConfigShrink;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitIProductionJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitIProductionJob(request: SubmitIProductionJobRequest): SubmitIProductionJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitIProductionJobWithOptions(request, runtime);
}

model SubmitLiveEditingJobRequest {
  clips?: string(name='Clips'),
  liveStreamConfig?: string(name='LiveStreamConfig'),
  mediaProduceConfig?: string(name='MediaProduceConfig'),
  outputMediaConfig?: string(name='OutputMediaConfig'),
  outputMediaTarget?: string(name='OutputMediaTarget'),
  projectId?: string(name='ProjectId'),
  userData?: string(name='UserData'),
}

model SubmitLiveEditingJobResponseBody = {
  jobId?: string(name='JobId'),
  mediaId?: string(name='MediaId'),
  mediaURL?: string(name='MediaURL'),
  projectId?: string(name='ProjectId'),
  requestId?: string(name='RequestId'),
  vodMediaId?: string(name='VodMediaId'),
}

model SubmitLiveEditingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitLiveEditingJobResponseBody(name='body'),
}

async function submitLiveEditingJobWithOptions(request: SubmitLiveEditingJobRequest, runtime: Util.RuntimeOptions): SubmitLiveEditingJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clips)) {
    query['Clips'] = request.clips;
  }
  if (!Util.isUnset(request.liveStreamConfig)) {
    query['LiveStreamConfig'] = request.liveStreamConfig;
  }
  if (!Util.isUnset(request.mediaProduceConfig)) {
    query['MediaProduceConfig'] = request.mediaProduceConfig;
  }
  if (!Util.isUnset(request.outputMediaConfig)) {
    query['OutputMediaConfig'] = request.outputMediaConfig;
  }
  if (!Util.isUnset(request.outputMediaTarget)) {
    query['OutputMediaTarget'] = request.outputMediaTarget;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitLiveEditingJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitLiveEditingJob(request: SubmitLiveEditingJobRequest): SubmitLiveEditingJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitLiveEditingJobWithOptions(request, runtime);
}

model SubmitLiveRecordJobRequest {
  name?: string(name='Name'),
  notifyUrl?: string(name='NotifyUrl'),
  recordOutput?: {
    bucket?: string(name='Bucket'),
    endpoint?: string(name='Endpoint'),
    type?: string(name='Type'),
  }(name='RecordOutput'),
  streamInput?: {
    type?: string(name='Type'),
    url?: string(name='Url'),
  }(name='StreamInput'),
  templateId?: string(name='TemplateId'),
}

model SubmitLiveRecordJobShrinkRequest {
  name?: string(name='Name'),
  notifyUrl?: string(name='NotifyUrl'),
  recordOutputShrink?: string(name='RecordOutput'),
  streamInputShrink?: string(name='StreamInput'),
  templateId?: string(name='TemplateId'),
}

model SubmitLiveRecordJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitLiveRecordJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitLiveRecordJobResponseBody(name='body'),
}

async function submitLiveRecordJobWithOptions(tmpReq: SubmitLiveRecordJobRequest, runtime: Util.RuntimeOptions): SubmitLiveRecordJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitLiveRecordJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.recordOutput)) {
    request.recordOutputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.recordOutput, 'RecordOutput', 'json');
  }
  if (!Util.isUnset(tmpReq.streamInput)) {
    request.streamInputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.streamInput, 'StreamInput', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.notifyUrl)) {
    body['NotifyUrl'] = request.notifyUrl;
  }
  if (!Util.isUnset(request.recordOutputShrink)) {
    body['RecordOutput'] = request.recordOutputShrink;
  }
  if (!Util.isUnset(request.streamInputShrink)) {
    body['StreamInput'] = request.streamInputShrink;
  }
  if (!Util.isUnset(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SubmitLiveRecordJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitLiveRecordJob(request: SubmitLiveRecordJobRequest): SubmitLiveRecordJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitLiveRecordJobWithOptions(request, runtime);
}

model SubmitLiveSnapshotJobRequest {
  callbackUrl?: string(name='CallbackUrl'),
  jobName?: string(name='JobName'),
  snapshotOutput?: {
    bucket?: string(name='Bucket'),
    endpoint?: string(name='Endpoint'),
    storageType?: string(name='StorageType'),
  }(name='SnapshotOutput'),
  streamInput?: {
    type?: string(name='Type'),
    url?: string(name='Url'),
  }(name='StreamInput'),
  templateId?: string(name='TemplateId'),
}

model SubmitLiveSnapshotJobShrinkRequest {
  callbackUrl?: string(name='CallbackUrl'),
  jobName?: string(name='JobName'),
  snapshotOutputShrink?: string(name='SnapshotOutput'),
  streamInputShrink?: string(name='StreamInput'),
  templateId?: string(name='TemplateId'),
}

model SubmitLiveSnapshotJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitLiveSnapshotJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitLiveSnapshotJobResponseBody(name='body'),
}

async function submitLiveSnapshotJobWithOptions(tmpReq: SubmitLiveSnapshotJobRequest, runtime: Util.RuntimeOptions): SubmitLiveSnapshotJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitLiveSnapshotJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.snapshotOutput)) {
    request.snapshotOutputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.snapshotOutput, 'SnapshotOutput', 'json');
  }
  if (!Util.isUnset(tmpReq.streamInput)) {
    request.streamInputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.streamInput, 'StreamInput', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.callbackUrl)) {
    body['CallbackUrl'] = request.callbackUrl;
  }
  if (!Util.isUnset(request.jobName)) {
    body['JobName'] = request.jobName;
  }
  if (!Util.isUnset(request.snapshotOutputShrink)) {
    body['SnapshotOutput'] = request.snapshotOutputShrink;
  }
  if (!Util.isUnset(request.streamInputShrink)) {
    body['StreamInput'] = request.streamInputShrink;
  }
  if (!Util.isUnset(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SubmitLiveSnapshotJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitLiveSnapshotJob(request: SubmitLiveSnapshotJobRequest): SubmitLiveSnapshotJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitLiveSnapshotJobWithOptions(request, runtime);
}

model SubmitLiveTranscodeJobRequest {
  name?: string(name='Name'),
  startMode?: int32(name='StartMode'),
  streamInput?: {
    inputUrl?: string(name='InputUrl'),
    type?: string(name='Type'),
  }(name='StreamInput'),
  templateId?: string(name='TemplateId'),
  timedConfig?: {
    endTime?: string(name='EndTime'),
    startTime?: string(name='StartTime'),
  }(name='TimedConfig'),
  transcodeOutput?: {
    domainName?: string(name='DomainName'),
    type?: string(name='Type'),
  }(name='TranscodeOutput'),
}

model SubmitLiveTranscodeJobShrinkRequest {
  name?: string(name='Name'),
  startMode?: int32(name='StartMode'),
  streamInputShrink?: string(name='StreamInput'),
  templateId?: string(name='TemplateId'),
  timedConfigShrink?: string(name='TimedConfig'),
  transcodeOutputShrink?: string(name='TranscodeOutput'),
}

model SubmitLiveTranscodeJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitLiveTranscodeJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitLiveTranscodeJobResponseBody(name='body'),
}

async function submitLiveTranscodeJobWithOptions(tmpReq: SubmitLiveTranscodeJobRequest, runtime: Util.RuntimeOptions): SubmitLiveTranscodeJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitLiveTranscodeJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.streamInput)) {
    request.streamInputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.streamInput, 'StreamInput', 'json');
  }
  if (!Util.isUnset(tmpReq.timedConfig)) {
    request.timedConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.timedConfig, 'TimedConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.transcodeOutput)) {
    request.transcodeOutputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.transcodeOutput, 'TranscodeOutput', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.startMode)) {
    query['StartMode'] = request.startMode;
  }
  if (!Util.isUnset(request.streamInputShrink)) {
    query['StreamInput'] = request.streamInputShrink;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.timedConfigShrink)) {
    query['TimedConfig'] = request.timedConfigShrink;
  }
  if (!Util.isUnset(request.transcodeOutputShrink)) {
    query['TranscodeOutput'] = request.transcodeOutputShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitLiveTranscodeJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitLiveTranscodeJob(request: SubmitLiveTranscodeJobRequest): SubmitLiveTranscodeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitLiveTranscodeJobWithOptions(request, runtime);
}

model SubmitMediaCensorJobRequest {
  barrages?: string(name='Barrages'),
  coverImages?: string(name='CoverImages'),
  description?: string(name='Description'),
  input?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Input'),
  notifyUrl?: string(name='NotifyUrl'),
  output?: string(name='Output'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId'),
    priority?: int32(name='Priority'),
  }(name='ScheduleConfig'),
  templateId?: string(name='TemplateId'),
  title?: string(name='Title'),
  userData?: string(name='UserData'),
}

model SubmitMediaCensorJobShrinkRequest {
  barrages?: string(name='Barrages'),
  coverImages?: string(name='CoverImages'),
  description?: string(name='Description'),
  inputShrink?: string(name='Input'),
  notifyUrl?: string(name='NotifyUrl'),
  output?: string(name='Output'),
  scheduleConfigShrink?: string(name='ScheduleConfig'),
  templateId?: string(name='TemplateId'),
  title?: string(name='Title'),
  userData?: string(name='UserData'),
}

model SubmitMediaCensorJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitMediaCensorJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitMediaCensorJobResponseBody(name='body'),
}

async function submitMediaCensorJobWithOptions(tmpReq: SubmitMediaCensorJobRequest, runtime: Util.RuntimeOptions): SubmitMediaCensorJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitMediaCensorJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.input)) {
    request.inputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.input, 'Input', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleConfig)) {
    request.scheduleConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleConfig, 'ScheduleConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.barrages)) {
    query['Barrages'] = request.barrages;
  }
  if (!Util.isUnset(request.coverImages)) {
    query['CoverImages'] = request.coverImages;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.inputShrink)) {
    query['Input'] = request.inputShrink;
  }
  if (!Util.isUnset(request.notifyUrl)) {
    query['NotifyUrl'] = request.notifyUrl;
  }
  if (!Util.isUnset(request.output)) {
    query['Output'] = request.output;
  }
  if (!Util.isUnset(request.scheduleConfigShrink)) {
    query['ScheduleConfig'] = request.scheduleConfigShrink;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitMediaCensorJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitMediaCensorJob(request: SubmitMediaCensorJobRequest): SubmitMediaCensorJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMediaCensorJobWithOptions(request, runtime);
}

model SubmitMediaInfoJobRequest {
  input?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Input'),
  name?: string(name='Name'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId'),
    priority?: int32(name='Priority'),
  }(name='ScheduleConfig'),
  userData?: string(name='UserData'),
}

model SubmitMediaInfoJobShrinkRequest {
  inputShrink?: string(name='Input'),
  name?: string(name='Name'),
  scheduleConfigShrink?: string(name='ScheduleConfig'),
  userData?: string(name='UserData'),
}

model SubmitMediaInfoJobResponseBody = {
  mediaInfoJob?: {
    async?: boolean(name='Async'),
    finishTime?: string(name='FinishTime'),
    input?: {
      media?: string(name='Media'),
      type?: string(name='Type'),
    }(name='Input'),
    jobId?: string(name='JobId'),
    mediaInfoProperty?: {
      audioStreamInfoList?: [ 
        {
          bitrate?: string(name='Bitrate'),
          channelLayout?: string(name='ChannelLayout'),
          channels?: string(name='Channels'),
          codecLongName?: string(name='CodecLongName'),
          codecName?: string(name='CodecName'),
          codecTag?: string(name='CodecTag'),
          codecTagString?: string(name='CodecTagString'),
          codecTimeBase?: string(name='CodecTimeBase'),
          duration?: string(name='Duration'),
          index?: string(name='Index'),
          lang?: string(name='Lang'),
          sampleFmt?: string(name='SampleFmt'),
          sampleRate?: string(name='SampleRate'),
          startTime?: string(name='StartTime'),
          timebase?: string(name='Timebase'),
        }
      ](name='AudioStreamInfoList'),
      fileBasicInfo?: {
        bitrate?: string(name='Bitrate'),
        duration?: string(name='Duration'),
        fileName?: string(name='FileName'),
        fileSize?: string(name='FileSize'),
        fileStatus?: string(name='FileStatus'),
        fileType?: string(name='FileType'),
        fileUrl?: string(name='FileUrl'),
        formatName?: string(name='FormatName'),
        height?: string(name='Height'),
        mediaId?: string(name='MediaId'),
        region?: string(name='Region'),
        width?: string(name='Width'),
      }(name='FileBasicInfo'),
      videoStreamInfoList?: [ 
        {
          avgFps?: string(name='Avg_fps'),
          bitRate?: string(name='Bit_rate'),
          codecLongName?: string(name='Codec_long_name'),
          codecName?: string(name='Codec_name'),
          codecTag?: string(name='Codec_tag'),
          codecTagString?: string(name='Codec_tag_string'),
          codecTimeBase?: string(name='Codec_time_base'),
          dar?: string(name='Dar'),
          duration?: string(name='Duration'),
          fps?: string(name='Fps'),
          hasBFrames?: string(name='Has_b_frames'),
          height?: string(name='Height'),
          index?: string(name='Index'),
          lang?: string(name='Lang'),
          level?: string(name='Level'),
          numFrames?: string(name='NumFrames'),
          pixFmt?: string(name='PixFmt'),
          profile?: string(name='Profile'),
          rotate?: string(name='Rotate'),
          sar?: string(name='Sar'),
          startTime?: string(name='Start_time'),
          timeBase?: string(name='Time_base'),
          width?: string(name='Width'),
        }
      ](name='VideoStreamInfoList'),
    }(name='MediaInfoProperty'),
    name?: string(name='Name'),
    requestId?: string(name='RequestId'),
    scheduleConfig?: {
      pipelineId?: string(name='PipelineId'),
      priority?: int32(name='Priority'),
    }(name='ScheduleConfig'),
    status?: string(name='Status'),
    submitResultJson?: map[string]any(name='SubmitResultJson'),
    submitTime?: string(name='SubmitTime'),
    triggerSource?: string(name='TriggerSource'),
    userData?: string(name='UserData'),
  }(name='MediaInfoJob'),
  requestId?: string(name='RequestId'),
}

model SubmitMediaInfoJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitMediaInfoJobResponseBody(name='body'),
}

async function submitMediaInfoJobWithOptions(tmpReq: SubmitMediaInfoJobRequest, runtime: Util.RuntimeOptions): SubmitMediaInfoJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitMediaInfoJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.input)) {
    request.inputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.input, 'Input', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleConfig)) {
    request.scheduleConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleConfig, 'ScheduleConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.inputShrink)) {
    query['Input'] = request.inputShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.scheduleConfigShrink)) {
    query['ScheduleConfig'] = request.scheduleConfigShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitMediaInfoJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitMediaInfoJob(request: SubmitMediaInfoJobRequest): SubmitMediaInfoJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMediaInfoJobWithOptions(request, runtime);
}

model SubmitMediaProducingJobRequest {
  clientToken?: string(name='ClientToken'),
  clipsParam?: string(name='ClipsParam'),
  editingProduceConfig?: string(name='EditingProduceConfig'),
  outputMediaConfig?: string(name='OutputMediaConfig'),
  outputMediaTarget?: string(name='OutputMediaTarget'),
  projectId?: string(name='ProjectId'),
  projectMetadata?: string(name='ProjectMetadata'),
  source?: string(name='Source'),
  templateId?: string(name='TemplateId'),
  timeline?: string(name='Timeline'),
  userData?: string(name='UserData'),
}

model SubmitMediaProducingJobResponseBody = {
  jobId?: string(name='JobId'),
  mediaId?: string(name='MediaId'),
  projectId?: string(name='ProjectId'),
  requestId?: string(name='RequestId'),
  vodMediaId?: string(name='VodMediaId'),
}

model SubmitMediaProducingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitMediaProducingJobResponseBody(name='body'),
}

async function submitMediaProducingJobWithOptions(request: SubmitMediaProducingJobRequest, runtime: Util.RuntimeOptions): SubmitMediaProducingJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clipsParam)) {
    query['ClipsParam'] = request.clipsParam;
  }
  if (!Util.isUnset(request.editingProduceConfig)) {
    query['EditingProduceConfig'] = request.editingProduceConfig;
  }
  if (!Util.isUnset(request.outputMediaConfig)) {
    query['OutputMediaConfig'] = request.outputMediaConfig;
  }
  if (!Util.isUnset(request.outputMediaTarget)) {
    query['OutputMediaTarget'] = request.outputMediaTarget;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectMetadata)) {
    query['ProjectMetadata'] = request.projectMetadata;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.timeline)) {
    query['Timeline'] = request.timeline;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitMediaProducingJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitMediaProducingJob(request: SubmitMediaProducingJobRequest): SubmitMediaProducingJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMediaProducingJobWithOptions(request, runtime);
}

model SubmitPackageJobRequest {
  inputs?: [ 
    {
      input?: {
        media?: string(name='Media'),
        type?: string(name='Type'),
      }(name='Input'),
    }
  ](name='Inputs'),
  name?: string(name='Name'),
  output?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Output'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId'),
    priority?: int32(name='Priority'),
  }(name='ScheduleConfig'),
  userData?: string(name='UserData'),
}

model SubmitPackageJobShrinkRequest {
  inputsShrink?: string(name='Inputs'),
  name?: string(name='Name'),
  outputShrink?: string(name='Output'),
  scheduleConfigShrink?: string(name='ScheduleConfig'),
  userData?: string(name='UserData'),
}

model SubmitPackageJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitPackageJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitPackageJobResponseBody(name='body'),
}

async function submitPackageJobWithOptions(tmpReq: SubmitPackageJobRequest, runtime: Util.RuntimeOptions): SubmitPackageJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitPackageJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.inputs)) {
    request.inputsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.inputs, 'Inputs', 'json');
  }
  if (!Util.isUnset(tmpReq.output)) {
    request.outputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.output, 'Output', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleConfig)) {
    request.scheduleConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleConfig, 'ScheduleConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.inputsShrink)) {
    query['Inputs'] = request.inputsShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.outputShrink)) {
    query['Output'] = request.outputShrink;
  }
  if (!Util.isUnset(request.scheduleConfigShrink)) {
    query['ScheduleConfig'] = request.scheduleConfigShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitPackageJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitPackageJob(request: SubmitPackageJobRequest): SubmitPackageJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitPackageJobWithOptions(request, runtime);
}

model SubmitSmarttagJobRequest {
  content?: string(name='Content'),
  contentAddr?: string(name='ContentAddr'),
  contentType?: string(name='ContentType'),
  input?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Input'),
  notifyUrl?: string(name='NotifyUrl'),
  params?: string(name='Params'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId'),
    priority?: string(name='Priority'),
  }(name='ScheduleConfig'),
  templateId?: string(name='TemplateId'),
  title?: string(name='Title'),
  userData?: string(name='UserData'),
}

model SubmitSmarttagJobShrinkRequest {
  content?: string(name='Content'),
  contentAddr?: string(name='ContentAddr'),
  contentType?: string(name='ContentType'),
  inputShrink?: string(name='Input'),
  notifyUrl?: string(name='NotifyUrl'),
  params?: string(name='Params'),
  scheduleConfigShrink?: string(name='ScheduleConfig'),
  templateId?: string(name='TemplateId'),
  title?: string(name='Title'),
  userData?: string(name='UserData'),
}

model SubmitSmarttagJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitSmarttagJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitSmarttagJobResponseBody(name='body'),
}

async function submitSmarttagJobWithOptions(tmpReq: SubmitSmarttagJobRequest, runtime: Util.RuntimeOptions): SubmitSmarttagJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitSmarttagJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.input)) {
    request.inputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.input, 'Input', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleConfig)) {
    request.scheduleConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleConfig, 'ScheduleConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.contentAddr)) {
    query['ContentAddr'] = request.contentAddr;
  }
  if (!Util.isUnset(request.contentType)) {
    query['ContentType'] = request.contentType;
  }
  if (!Util.isUnset(request.inputShrink)) {
    query['Input'] = request.inputShrink;
  }
  if (!Util.isUnset(request.notifyUrl)) {
    query['NotifyUrl'] = request.notifyUrl;
  }
  if (!Util.isUnset(request.params)) {
    query['Params'] = request.params;
  }
  if (!Util.isUnset(request.scheduleConfigShrink)) {
    query['ScheduleConfig'] = request.scheduleConfigShrink;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitSmarttagJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitSmarttagJob(request: SubmitSmarttagJobRequest): SubmitSmarttagJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSmarttagJobWithOptions(request, runtime);
}

model SubmitSnapshotJobRequest {
  input?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Input'),
  name?: string(name='Name'),
  output?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Output'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId'),
  }(name='ScheduleConfig'),
  templateConfig?: {
    overwriteParams?: {
      blackLevel?: int32(name='BlackLevel'),
      count?: long(name='Count'),
      frameType?: string(name='FrameType'),
      height?: int32(name='Height'),
      interval?: long(name='Interval'),
      isSptFrag?: boolean(name='IsSptFrag'),
      pixelBlackThreshold?: int32(name='PixelBlackThreshold'),
      spriteSnapshotConfig?: {
        cellHeight?: int32(name='CellHeight'),
        cellWidth?: int32(name='CellWidth'),
        color?: string(name='Color'),
        columns?: int32(name='Columns'),
        lines?: int32(name='Lines'),
        margin?: int32(name='Margin'),
        padding?: int32(name='Padding'),
      }(name='SpriteSnapshotConfig'),
      time?: long(name='Time'),
      type?: string(name='Type'),
      width?: int32(name='Width'),
    }(name='OverwriteParams'),
    templateId?: string(name='TemplateId'),
  }(name='TemplateConfig'),
  userData?: string(name='UserData'),
}

model SubmitSnapshotJobShrinkRequest {
  inputShrink?: string(name='Input'),
  name?: string(name='Name'),
  outputShrink?: string(name='Output'),
  scheduleConfigShrink?: string(name='ScheduleConfig'),
  templateConfigShrink?: string(name='TemplateConfig'),
  userData?: string(name='UserData'),
}

model SubmitSnapshotJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitSnapshotJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitSnapshotJobResponseBody(name='body'),
}

async function submitSnapshotJobWithOptions(tmpReq: SubmitSnapshotJobRequest, runtime: Util.RuntimeOptions): SubmitSnapshotJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitSnapshotJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.input)) {
    request.inputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.input, 'Input', 'json');
  }
  if (!Util.isUnset(tmpReq.output)) {
    request.outputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.output, 'Output', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleConfig)) {
    request.scheduleConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleConfig, 'ScheduleConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.templateConfig)) {
    request.templateConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.templateConfig, 'TemplateConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.inputShrink)) {
    query['Input'] = request.inputShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.outputShrink)) {
    query['Output'] = request.outputShrink;
  }
  if (!Util.isUnset(request.scheduleConfigShrink)) {
    query['ScheduleConfig'] = request.scheduleConfigShrink;
  }
  if (!Util.isUnset(request.templateConfigShrink)) {
    query['TemplateConfig'] = request.templateConfigShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitSnapshotJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitSnapshotJob(request: SubmitSnapshotJobRequest): SubmitSnapshotJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSnapshotJobWithOptions(request, runtime);
}

model SubmitSubtitleProduceJobRequest {
  description?: string(name='Description'),
  editingConfig?: string(name='EditingConfig'),
  inputConfig?: string(name='InputConfig'),
  isAsync?: long(name='IsAsync'),
  outputConfig?: string(name='OutputConfig'),
  title?: string(name='Title'),
  type?: string(name='Type'),
  userData?: string(name='UserData'),
}

model SubmitSubtitleProduceJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitSubtitleProduceJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitSubtitleProduceJobResponseBody(name='body'),
}

async function submitSubtitleProduceJobWithOptions(request: SubmitSubtitleProduceJobRequest, runtime: Util.RuntimeOptions): SubmitSubtitleProduceJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.editingConfig)) {
    query['EditingConfig'] = request.editingConfig;
  }
  if (!Util.isUnset(request.inputConfig)) {
    query['InputConfig'] = request.inputConfig;
  }
  if (!Util.isUnset(request.isAsync)) {
    query['IsAsync'] = request.isAsync;
  }
  if (!Util.isUnset(request.outputConfig)) {
    query['OutputConfig'] = request.outputConfig;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitSubtitleProduceJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitSubtitleProduceJob(request: SubmitSubtitleProduceJobRequest): SubmitSubtitleProduceJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSubtitleProduceJobWithOptions(request, runtime);
}

model SubmitSyncMediaInfoJobRequest {
  input?: {
    media?: string(name='Media'),
    type?: string(name='Type'),
  }(name='Input'),
  name?: string(name='Name'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId'),
    priority?: int32(name='Priority'),
  }(name='ScheduleConfig'),
  userData?: string(name='UserData'),
}

model SubmitSyncMediaInfoJobShrinkRequest {
  inputShrink?: string(name='Input'),
  name?: string(name='Name'),
  scheduleConfigShrink?: string(name='ScheduleConfig'),
  userData?: string(name='UserData'),
}

model SubmitSyncMediaInfoJobResponseBody = {
  mediaInfoJob?: {
    async?: boolean(name='Async'),
    finishTime?: string(name='FinishTime'),
    input?: {
      media?: string(name='Media'),
      type?: string(name='Type'),
    }(name='Input'),
    jobId?: string(name='JobId'),
    mediaInfoProperty?: {
      audioStreamInfoList?: [ 
        {
          bitrate?: string(name='Bitrate'),
          channelLayout?: string(name='ChannelLayout'),
          channels?: string(name='Channels'),
          codecLongName?: string(name='CodecLongName'),
          codecName?: string(name='CodecName'),
          codecTag?: string(name='CodecTag'),
          codecTagString?: string(name='CodecTagString'),
          codecTimeBase?: string(name='CodecTimeBase'),
          duration?: string(name='Duration'),
          index?: string(name='Index'),
          lang?: string(name='Lang'),
          sampleFmt?: string(name='SampleFmt'),
          sampleRate?: string(name='SampleRate'),
          startTime?: string(name='StartTime'),
          timebase?: string(name='Timebase'),
        }
      ](name='AudioStreamInfoList'),
      fileBasicInfo?: {
        bitrate?: string(name='Bitrate'),
        duration?: string(name='Duration'),
        fileName?: string(name='FileName'),
        fileSize?: string(name='FileSize'),
        fileStatus?: string(name='FileStatus'),
        fileType?: string(name='FileType'),
        fileUrl?: string(name='FileUrl'),
        formatName?: string(name='FormatName'),
        height?: string(name='Height'),
        mediaId?: string(name='MediaId'),
        region?: string(name='Region'),
        width?: string(name='Width'),
      }(name='FileBasicInfo'),
      videoStreamInfoList?: [ 
        {
          avgFps?: string(name='Avg_fps'),
          bitRate?: string(name='Bit_rate'),
          codecLongName?: string(name='Codec_long_name'),
          codecName?: string(name='Codec_name'),
          codecTag?: string(name='Codec_tag'),
          codecTagString?: string(name='Codec_tag_string'),
          codecTimeBase?: string(name='Codec_time_base'),
          dar?: string(name='Dar'),
          duration?: string(name='Duration'),
          fps?: string(name='Fps'),
          hasBFrames?: string(name='Has_b_frames'),
          height?: string(name='Height'),
          index?: string(name='Index'),
          lang?: string(name='Lang'),
          level?: string(name='Level'),
          numFrames?: string(name='NumFrames'),
          pixFmt?: string(name='PixFmt'),
          profile?: string(name='Profile'),
          rotate?: string(name='Rotate'),
          sar?: string(name='Sar'),
          startTime?: string(name='Start_time'),
          timeBase?: string(name='Time_base'),
          width?: string(name='Width'),
        }
      ](name='VideoStreamInfoList'),
    }(name='MediaInfoProperty'),
    name?: string(name='Name'),
    requestId?: string(name='RequestId'),
    scheduleConfig?: {
      pipelineId?: string(name='PipelineId'),
      priority?: int32(name='Priority'),
    }(name='ScheduleConfig'),
    status?: string(name='Status'),
    submitResultJson?: map[string]any(name='SubmitResultJson'),
    submitTime?: string(name='SubmitTime'),
    triggerSource?: string(name='TriggerSource'),
    userData?: string(name='UserData'),
  }(name='MediaInfoJob'),
  requestId?: string(name='RequestId'),
}

model SubmitSyncMediaInfoJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitSyncMediaInfoJobResponseBody(name='body'),
}

async function submitSyncMediaInfoJobWithOptions(tmpReq: SubmitSyncMediaInfoJobRequest, runtime: Util.RuntimeOptions): SubmitSyncMediaInfoJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitSyncMediaInfoJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.input)) {
    request.inputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.input, 'Input', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleConfig)) {
    request.scheduleConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleConfig, 'ScheduleConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.inputShrink)) {
    query['Input'] = request.inputShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.scheduleConfigShrink)) {
    query['ScheduleConfig'] = request.scheduleConfigShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitSyncMediaInfoJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitSyncMediaInfoJob(request: SubmitSyncMediaInfoJobRequest): SubmitSyncMediaInfoJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSyncMediaInfoJobWithOptions(request, runtime);
}

model SubmitTranscodeJobRequest {
  inputGroup?: [ 
    {
      media?: string(name='Media'),
      type?: string(name='Type'),
    }
  ](name='InputGroup'),
  name?: string(name='Name'),
  outputGroup?: [ 
    {
      output?: {
        media?: string(name='Media'),
        type?: string(name='Type'),
      }(name='Output'),
      processConfig?: {
        combineConfigs?: [ 
          {
            audioIndex?: string(name='AudioIndex'),
            duration?: double(name='Duration'),
            start?: double(name='Start'),
            videoIndex?: string(name='VideoIndex'),
          }
        ](name='CombineConfigs'),
        encryption?: {
          cipherText?: string(name='CipherText'),
          decryptKeyUri?: string(name='DecryptKeyUri'),
          encryptType?: string(name='EncryptType'),
        }(name='Encryption'),
        imageWatermarks?: [ 
          {
            overwriteParams?: {
              dx?: string(name='Dx'),
              dy?: string(name='Dy'),
              file?: {
                media?: string(name='Media'),
                type?: string(name='Type'),
              }(name='File'),
              height?: string(name='Height'),
              referPos?: string(name='ReferPos'),
              timeline?: {
                duration?: string(name='Duration'),
                start?: string(name='Start'),
              }(name='Timeline'),
              width?: string(name='Width'),
            }(name='OverwriteParams'),
            templateId?: string(name='TemplateId'),
          }
        ](name='ImageWatermarks'),
        subtitles?: [ 
          {
            overwriteParams?: {
              charEnc?: string(name='CharEnc'),
              file?: {
                media?: string(name='Media'),
                type?: string(name='Type'),
              }(name='File'),
              format?: string(name='Format'),
            }(name='OverwriteParams'),
            templateId?: string(name='TemplateId'),
          }
        ](name='Subtitles'),
        textWatermarks?: [ 
          {
            overwriteParams?: {
              adaptive?: string(name='Adaptive'),
              borderColor?: string(name='BorderColor'),
              borderWidth?: int32(name='BorderWidth'),
              content?: string(name='Content'),
              fontAlpha?: string(name='FontAlpha'),
              fontColor?: string(name='FontColor'),
              fontName?: string(name='FontName'),
              fontSize?: int32(name='FontSize'),
              left?: string(name='Left'),
              top?: string(name='Top'),
            }(name='OverwriteParams'),
            templateId?: string(name='TemplateId'),
          }
        ](name='TextWatermarks'),
        transcode?: {
          overwriteParams?: {
            audio?: {
              bitrate?: string(name='Bitrate'),
              channels?: string(name='Channels'),
              codec?: string(name='Codec'),
              profile?: string(name='Profile'),
              remove?: string(name='Remove'),
              samplerate?: string(name='Samplerate'),
              volume?: {
                integratedLoudnessTarget?: string(name='IntegratedLoudnessTarget'),
                loudnessRangeTarget?: string(name='LoudnessRangeTarget'),
                method?: string(name='Method'),
                truePeak?: string(name='TruePeak'),
              }(name='Volume'),
            }(name='Audio'),
            container?: {
              format?: string(name='Format'),
            }(name='Container'),
            muxConfig?: {
              segment?: {
                duration?: string(name='Duration'),
                forceSegTime?: string(name='ForceSegTime'),
              }(name='Segment'),
            }(name='MuxConfig'),
            video?: {
              abrMax?: string(name='AbrMax'),
              bitrate?: string(name='Bitrate'),
              bufsize?: string(name='Bufsize'),
              codec?: string(name='Codec'),
              crf?: string(name='Crf'),
              crop?: string(name='Crop'),
              fps?: string(name='Fps'),
              gop?: string(name='Gop'),
              height?: string(name='Height'),
              longShortMode?: string(name='LongShortMode'),
              maxrate?: string(name='Maxrate'),
              pad?: string(name='Pad'),
              pixFmt?: string(name='PixFmt'),
              preset?: string(name='Preset'),
              profile?: string(name='Profile'),
              remove?: string(name='Remove'),
              scanMode?: string(name='ScanMode'),
              width?: string(name='Width'),
            }(name='Video'),
          }(name='OverwriteParams'),
          templateId?: string(name='TemplateId'),
        }(name='Transcode'),
      }(name='ProcessConfig'),
    }
  ](name='OutputGroup'),
  scheduleConfig?: {
    pipelineId?: string(name='PipelineId'),
    priority?: int32(name='Priority'),
  }(name='ScheduleConfig'),
  userData?: string(name='UserData'),
}

model SubmitTranscodeJobShrinkRequest {
  inputGroupShrink?: string(name='InputGroup'),
  name?: string(name='Name'),
  outputGroupShrink?: string(name='OutputGroup'),
  scheduleConfigShrink?: string(name='ScheduleConfig'),
  userData?: string(name='UserData'),
}

model SubmitTranscodeJobResponseBody = {
  requestId?: string(name='RequestId'),
  transcodeParentJob?: {
    createTime?: string(name='CreateTime'),
    finishTime?: string(name='FinishTime'),
    inputGroup?: [ 
      {
        media?: string(name='Media'),
        type?: string(name='Type'),
      }
    ](name='InputGroup'),
    jobCount?: int32(name='JobCount'),
    name?: string(name='Name'),
    outputGroup?: [ 
      {
        output?: {
          media?: string(name='Media'),
          type?: string(name='Type'),
        }(name='Output'),
        processConfig?: {
          combineConfigs?: [ 
            {
              audioIndex?: string(name='AudioIndex'),
              duration?: double(name='Duration'),
              start?: double(name='Start'),
              videoIndex?: string(name='VideoIndex'),
            }
          ](name='CombineConfigs'),
          encryption?: {
            cipherText?: string(name='CipherText'),
            decryptKeyUri?: string(name='DecryptKeyUri'),
            encryptType?: string(name='EncryptType'),
          }(name='Encryption'),
          imageWatermarks?: [ 
            {
              overwriteParams?: {
                dx?: string(name='Dx'),
                dy?: string(name='Dy'),
                file?: {
                  media?: string(name='Media'),
                  type?: string(name='Type'),
                }(name='File'),
                height?: string(name='Height'),
                referPos?: string(name='ReferPos'),
                timeline?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='Timeline'),
                width?: string(name='Width'),
              }(name='OverwriteParams'),
              templateId?: string(name='TemplateId'),
            }
          ](name='ImageWatermarks'),
          subtitles?: [ 
            {
              overwriteParams?: {
                charEnc?: string(name='CharEnc'),
                file?: {
                  media?: string(name='Media'),
                  type?: string(name='Type'),
                }(name='File'),
                format?: string(name='Format'),
              }(name='OverwriteParams'),
              templateId?: string(name='TemplateId'),
            }
          ](name='Subtitles'),
          textWatermarks?: [ 
            {
              overwriteParams?: {
                adaptive?: string(name='Adaptive'),
                borderColor?: string(name='BorderColor'),
                borderWidth?: int32(name='BorderWidth'),
                content?: string(name='Content'),
                fontAlpha?: string(name='FontAlpha'),
                fontColor?: string(name='FontColor'),
                fontName?: string(name='FontName'),
                fontSize?: int32(name='FontSize'),
                left?: string(name='Left'),
                top?: string(name='Top'),
              }(name='OverwriteParams'),
              templateId?: string(name='TemplateId'),
            }
          ](name='TextWatermarks'),
          transcode?: {
            overwriteParams?: {
              audio?: {
                bitrate?: string(name='Bitrate'),
                channels?: string(name='Channels'),
                codec?: string(name='Codec'),
                profile?: string(name='Profile'),
                remove?: string(name='Remove'),
                samplerate?: string(name='Samplerate'),
                volume?: {
                  integratedLoudnessTarget?: string(name='IntegratedLoudnessTarget'),
                  loudnessRangeTarget?: string(name='LoudnessRangeTarget'),
                  method?: string(name='Method'),
                  truePeak?: string(name='TruePeak'),
                }(name='Volume'),
              }(name='Audio'),
              container?: {
                format?: string(name='Format'),
              }(name='Container'),
              muxConfig?: {
                segment?: {
                  duration?: string(name='Duration'),
                  forceSegTime?: string(name='ForceSegTime'),
                }(name='Segment'),
              }(name='MuxConfig'),
              video?: {
                abrMax?: string(name='AbrMax'),
                bitrate?: string(name='Bitrate'),
                bufsize?: string(name='Bufsize'),
                codec?: string(name='Codec'),
                crf?: string(name='Crf'),
                crop?: string(name='Crop'),
                fps?: string(name='Fps'),
                gop?: string(name='Gop'),
                height?: string(name='Height'),
                longShortMode?: string(name='LongShortMode'),
                maxrate?: string(name='Maxrate'),
                pad?: string(name='Pad'),
                pixFmt?: string(name='PixFmt'),
                preset?: string(name='Preset'),
                profile?: string(name='Profile'),
                remove?: string(name='Remove'),
                scanMode?: string(name='ScanMode'),
                width?: string(name='Width'),
              }(name='Video'),
            }(name='OverwriteParams'),
            templateId?: string(name='TemplateId'),
          }(name='Transcode'),
        }(name='ProcessConfig'),
      }
    ](name='OutputGroup'),
    parentJobId?: string(name='ParentJobId'),
    percent?: int32(name='Percent'),
    requestId?: string(name='RequestId'),
    scheduleConfig?: {
      pipelineId?: string(name='PipelineId'),
      priority?: int32(name='Priority'),
    }(name='ScheduleConfig'),
    status?: string(name='Status'),
    submitTime?: string(name='SubmitTime'),
    transcodeJobList?: [ 
      {
        createTime?: string(name='CreateTime'),
        finishTime?: string(name='FinishTime'),
        inputGroup?: [ 
          {
            media?: string(name='Media'),
            type?: string(name='Type'),
          }
        ](name='InputGroup'),
        jobId?: string(name='JobId'),
        jobIndex?: int32(name='JobIndex'),
        name?: string(name='Name'),
        outFileMeta?: {
          audioStreamInfoList?: [ 
            {
              bitrate?: string(name='Bitrate'),
              channelLayout?: string(name='ChannelLayout'),
              channels?: string(name='Channels'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              sampleFmt?: string(name='SampleFmt'),
              sampleRate?: string(name='SampleRate'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='AudioStreamInfoList'),
          fileBasicInfo?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            fileName?: string(name='FileName'),
            fileSize?: string(name='FileSize'),
            fileStatus?: string(name='FileStatus'),
            fileType?: string(name='FileType'),
            fileUrl?: string(name='FileUrl'),
            formatName?: string(name='FormatName'),
            height?: string(name='Height'),
            mediaId?: string(name='MediaId'),
            region?: string(name='Region'),
            width?: string(name='Width'),
          }(name='FileBasicInfo'),
          videoStreamInfoList?: [ 
            {
              avgFps?: string(name='Avg_fps'),
              bitRate?: string(name='Bit_rate'),
              codecLongName?: string(name='Codec_long_name'),
              codecName?: string(name='Codec_name'),
              codecTag?: string(name='Codec_tag'),
              codecTagString?: string(name='Codec_tag_string'),
              codecTimeBase?: string(name='Codec_time_base'),
              dar?: string(name='Dar'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              hasBFrames?: string(name='Has_b_frames'),
              height?: string(name='Height'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              level?: string(name='Level'),
              numFrames?: string(name='NumFrames'),
              pixFmt?: string(name='PixFmt'),
              profile?: string(name='Profile'),
              rotate?: string(name='Rotate'),
              sar?: string(name='Sar'),
              startTime?: string(name='Start_time'),
              timeBase?: string(name='Time_base'),
              width?: string(name='Width'),
            }
          ](name='VideoStreamInfoList'),
        }(name='OutFileMeta'),
        output?: {
          media?: string(name='Media'),
          type?: string(name='Type'),
        }(name='Output'),
        parentJobId?: string(name='ParentJobId'),
        processConfig?: {
          combineConfigs?: [ 
            {
              audioIndex?: string(name='AudioIndex'),
              duration?: double(name='Duration'),
              start?: double(name='Start'),
              videoIndex?: string(name='VideoIndex'),
            }
          ](name='CombineConfigs'),
          encryption?: {
            cipherText?: string(name='CipherText'),
            decryptKeyUri?: string(name='DecryptKeyUri'),
            encryptType?: string(name='EncryptType'),
          }(name='Encryption'),
          imageWatermarks?: [ 
            {
              overwriteParams?: {
                dx?: string(name='Dx'),
                dy?: string(name='Dy'),
                file?: {
                  media?: string(name='Media'),
                  type?: string(name='Type'),
                }(name='File'),
                height?: string(name='Height'),
                referPos?: string(name='ReferPos'),
                timeline?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='Timeline'),
                width?: string(name='Width'),
              }(name='OverwriteParams'),
              templateId?: string(name='TemplateId'),
            }
          ](name='ImageWatermarks'),
          subtitles?: [ 
            {
              overwriteParams?: {
                charEnc?: string(name='CharEnc'),
                file?: {
                  media?: string(name='Media'),
                  type?: string(name='Type'),
                }(name='File'),
                format?: string(name='Format'),
              }(name='OverwriteParams'),
              templateId?: string(name='TemplateId'),
            }
          ](name='Subtitles'),
          textWatermarks?: [ 
            {
              overwriteParams?: {
                adaptive?: string(name='Adaptive'),
                borderColor?: string(name='BorderColor'),
                borderWidth?: int32(name='BorderWidth'),
                content?: string(name='Content'),
                fontAlpha?: string(name='FontAlpha'),
                fontColor?: string(name='FontColor'),
                fontName?: string(name='FontName'),
                fontSize?: int32(name='FontSize'),
                left?: string(name='Left'),
                top?: string(name='Top'),
              }(name='OverwriteParams'),
              templateId?: string(name='TemplateId'),
            }
          ](name='TextWatermarks'),
          transcode?: {
            overwriteParams?: {
              audio?: {
                bitrate?: string(name='Bitrate'),
                channels?: string(name='Channels'),
                codec?: string(name='Codec'),
                profile?: string(name='Profile'),
                remove?: string(name='Remove'),
                samplerate?: string(name='Samplerate'),
                volume?: {
                  integratedLoudnessTarget?: string(name='IntegratedLoudnessTarget'),
                  loudnessRangeTarget?: string(name='LoudnessRangeTarget'),
                  method?: string(name='Method'),
                  truePeak?: string(name='TruePeak'),
                }(name='Volume'),
              }(name='Audio'),
              container?: {
                format?: string(name='Format'),
              }(name='Container'),
              muxConfig?: {
                segment?: {
                  duration?: string(name='Duration'),
                  forceSegTime?: string(name='ForceSegTime'),
                }(name='Segment'),
              }(name='MuxConfig'),
              video?: {
                abrMax?: string(name='AbrMax'),
                bitrate?: string(name='Bitrate'),
                bufsize?: string(name='Bufsize'),
                codec?: string(name='Codec'),
                crf?: string(name='Crf'),
                crop?: string(name='Crop'),
                fps?: string(name='Fps'),
                gop?: string(name='Gop'),
                height?: string(name='Height'),
                longShortMode?: string(name='LongShortMode'),
                maxrate?: string(name='Maxrate'),
                pad?: string(name='Pad'),
                pixFmt?: string(name='PixFmt'),
                preset?: string(name='Preset'),
                profile?: string(name='Profile'),
                remove?: string(name='Remove'),
                scanMode?: string(name='ScanMode'),
                width?: string(name='Width'),
              }(name='Video'),
            }(name='OverwriteParams'),
            templateId?: string(name='TemplateId'),
          }(name='Transcode'),
        }(name='ProcessConfig'),
        requestId?: string(name='RequestId'),
        scheduleConfig?: {
          pipelineId?: string(name='PipelineId'),
          priority?: int32(name='Priority'),
        }(name='ScheduleConfig'),
        status?: string(name='Status'),
        submitResultJson?: map[string]any(name='SubmitResultJson'),
        submitTime?: string(name='SubmitTime'),
        userData?: string(name='UserData'),
      }
    ](name='TranscodeJobList'),
    triggerSource?: string(name='TriggerSource'),
    userData?: string(name='UserData'),
  }(name='TranscodeParentJob'),
}

model SubmitTranscodeJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitTranscodeJobResponseBody(name='body'),
}

async function submitTranscodeJobWithOptions(tmpReq: SubmitTranscodeJobRequest, runtime: Util.RuntimeOptions): SubmitTranscodeJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitTranscodeJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.inputGroup)) {
    request.inputGroupShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.inputGroup, 'InputGroup', 'json');
  }
  if (!Util.isUnset(tmpReq.outputGroup)) {
    request.outputGroupShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.outputGroup, 'OutputGroup', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleConfig)) {
    request.scheduleConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleConfig, 'ScheduleConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.inputGroupShrink)) {
    query['InputGroup'] = request.inputGroupShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.outputGroupShrink)) {
    query['OutputGroup'] = request.outputGroupShrink;
  }
  if (!Util.isUnset(request.scheduleConfigShrink)) {
    query['ScheduleConfig'] = request.scheduleConfigShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitTranscodeJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitTranscodeJob(request: SubmitTranscodeJobRequest): SubmitTranscodeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitTranscodeJobWithOptions(request, runtime);
}

model UpdateCategoryRequest {
  cateId?: long(name='CateId'),
  cateName?: string(name='CateName'),
}

model UpdateCategoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateCategoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCategoryResponseBody(name='body'),
}

async function updateCategoryWithOptions(request: UpdateCategoryRequest, runtime: Util.RuntimeOptions): UpdateCategoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.cateName)) {
    query['CateName'] = request.cateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCategory',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCategory(request: UpdateCategoryRequest): UpdateCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCategoryWithOptions(request, runtime);
}

model UpdateCustomTemplateRequest {
  name?: string(name='Name'),
  templateConfig?: string(name='TemplateConfig'),
  templateId?: string(name='TemplateId'),
}

model UpdateCustomTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateCustomTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCustomTemplateResponseBody(name='body'),
}

async function updateCustomTemplateWithOptions(request: UpdateCustomTemplateRequest, runtime: Util.RuntimeOptions): UpdateCustomTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.templateConfig)) {
    query['TemplateConfig'] = request.templateConfig;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCustomTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCustomTemplate(request: UpdateCustomTemplateRequest): UpdateCustomTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCustomTemplateWithOptions(request, runtime);
}

model UpdateEditingProjectRequest {
  businessStatus?: string(name='BusinessStatus'),
  clipsParam?: string(name='ClipsParam'),
  coverURL?: string(name='CoverURL'),
  description?: string(name='Description'),
  projectId?: string(name='ProjectId'),
  templateId?: string(name='TemplateId'),
  timeline?: string(name='Timeline'),
  title?: string(name='Title'),
}

model UpdateEditingProjectResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEditingProjectResponseBody(name='body'),
}

async function updateEditingProjectWithOptions(request: UpdateEditingProjectRequest, runtime: Util.RuntimeOptions): UpdateEditingProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessStatus)) {
    query['BusinessStatus'] = request.businessStatus;
  }
  if (!Util.isUnset(request.clipsParam)) {
    query['ClipsParam'] = request.clipsParam;
  }
  if (!Util.isUnset(request.coverURL)) {
    query['CoverURL'] = request.coverURL;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.timeline)) {
    query['Timeline'] = request.timeline;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEditingProject',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateEditingProject(request: UpdateEditingProjectRequest): UpdateEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEditingProjectWithOptions(request, runtime);
}

model UpdateLiveRecordTemplateRequest {
  name?: string(name='Name'),
  recordFormat?: [ 
    {
      cycleDuration?: int32(name='CycleDuration'),
      format?: string(name='Format'),
      ossObjectPrefix?: string(name='OssObjectPrefix'),
      sliceDuration?: int32(name='SliceDuration'),
      sliceOssObjectPrefix?: string(name='SliceOssObjectPrefix'),
    }
  ](name='RecordFormat'),
  templateId?: string(name='TemplateId'),
}

model UpdateLiveRecordTemplateShrinkRequest {
  name?: string(name='Name'),
  recordFormatShrink?: string(name='RecordFormat'),
  templateId?: string(name='TemplateId'),
}

model UpdateLiveRecordTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateLiveRecordTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLiveRecordTemplateResponseBody(name='body'),
}

async function updateLiveRecordTemplateWithOptions(tmpReq: UpdateLiveRecordTemplateRequest, runtime: Util.RuntimeOptions): UpdateLiveRecordTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateLiveRecordTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.recordFormat)) {
    request.recordFormatShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.recordFormat, 'RecordFormat', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.recordFormatShrink)) {
    body['RecordFormat'] = request.recordFormatShrink;
  }
  if (!Util.isUnset(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLiveRecordTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLiveRecordTemplate(request: UpdateLiveRecordTemplateRequest): UpdateLiveRecordTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLiveRecordTemplateWithOptions(request, runtime);
}

model UpdateLiveSnapshotTemplateRequest {
  overwriteFormat?: string(name='OverwriteFormat'),
  sequenceFormat?: string(name='SequenceFormat'),
  templateId?: string(name='TemplateId'),
  templateName?: string(name='TemplateName'),
  timeInterval?: int32(name='TimeInterval'),
}

model UpdateLiveSnapshotTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateLiveSnapshotTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLiveSnapshotTemplateResponseBody(name='body'),
}

async function updateLiveSnapshotTemplateWithOptions(request: UpdateLiveSnapshotTemplateRequest, runtime: Util.RuntimeOptions): UpdateLiveSnapshotTemplateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.overwriteFormat)) {
    body['OverwriteFormat'] = request.overwriteFormat;
  }
  if (!Util.isUnset(request.sequenceFormat)) {
    body['SequenceFormat'] = request.sequenceFormat;
  }
  if (!Util.isUnset(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.templateName)) {
    body['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.timeInterval)) {
    body['TimeInterval'] = request.timeInterval;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLiveSnapshotTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLiveSnapshotTemplate(request: UpdateLiveSnapshotTemplateRequest): UpdateLiveSnapshotTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLiveSnapshotTemplateWithOptions(request, runtime);
}

model UpdateLiveTranscodeJobRequest {
  jobId?: string(name='JobId'),
  name?: string(name='Name'),
  streamInput?: {
    inputUrl?: string(name='InputUrl'),
    type?: string(name='Type'),
  }(name='StreamInput'),
  timedConfig?: {
    endTime?: string(name='EndTime'),
    startTime?: string(name='StartTime'),
  }(name='TimedConfig'),
  transcodeOutput?: {
    domainName?: string(name='DomainName'),
    type?: string(name='Type'),
  }(name='TranscodeOutput'),
}

model UpdateLiveTranscodeJobShrinkRequest {
  jobId?: string(name='JobId'),
  name?: string(name='Name'),
  streamInputShrink?: string(name='StreamInput'),
  timedConfigShrink?: string(name='TimedConfig'),
  transcodeOutputShrink?: string(name='TranscodeOutput'),
}

model UpdateLiveTranscodeJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateLiveTranscodeJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLiveTranscodeJobResponseBody(name='body'),
}

async function updateLiveTranscodeJobWithOptions(tmpReq: UpdateLiveTranscodeJobRequest, runtime: Util.RuntimeOptions): UpdateLiveTranscodeJobResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateLiveTranscodeJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.streamInput)) {
    request.streamInputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.streamInput, 'StreamInput', 'json');
  }
  if (!Util.isUnset(tmpReq.timedConfig)) {
    request.timedConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.timedConfig, 'TimedConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.transcodeOutput)) {
    request.transcodeOutputShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.transcodeOutput, 'TranscodeOutput', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.streamInputShrink)) {
    query['StreamInput'] = request.streamInputShrink;
  }
  if (!Util.isUnset(request.timedConfigShrink)) {
    query['TimedConfig'] = request.timedConfigShrink;
  }
  if (!Util.isUnset(request.transcodeOutputShrink)) {
    query['TranscodeOutput'] = request.transcodeOutputShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLiveTranscodeJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLiveTranscodeJob(request: UpdateLiveTranscodeJobRequest): UpdateLiveTranscodeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLiveTranscodeJobWithOptions(request, runtime);
}

model UpdateLiveTranscodeTemplateRequest {
  name?: string(name='Name'),
  templateConfig?: {
    audioParams?: {
      bitrate?: string(name='Bitrate'),
      channels?: string(name='Channels'),
      codec?: string(name='Codec'),
      profile?: string(name='Profile'),
      samplerate?: string(name='Samplerate'),
    }(name='AudioParams'),
    videoParams?: {
      bitrate?: string(name='Bitrate'),
      codec?: string(name='Codec'),
      fps?: string(name='Fps'),
      gop?: string(name='Gop'),
      height?: string(name='Height'),
      profile?: string(name='Profile'),
      width?: string(name='Width'),
    }(name='VideoParams'),
  }(name='TemplateConfig'),
  templateId?: string(name='TemplateId'),
}

model UpdateLiveTranscodeTemplateShrinkRequest {
  name?: string(name='Name'),
  templateConfigShrink?: string(name='TemplateConfig'),
  templateId?: string(name='TemplateId'),
}

model UpdateLiveTranscodeTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateLiveTranscodeTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLiveTranscodeTemplateResponseBody(name='body'),
}

async function updateLiveTranscodeTemplateWithOptions(tmpReq: UpdateLiveTranscodeTemplateRequest, runtime: Util.RuntimeOptions): UpdateLiveTranscodeTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateLiveTranscodeTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.templateConfig)) {
    request.templateConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.templateConfig, 'TemplateConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.templateConfigShrink)) {
    query['TemplateConfig'] = request.templateConfigShrink;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLiveTranscodeTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLiveTranscodeTemplate(request: UpdateLiveTranscodeTemplateRequest): UpdateLiveTranscodeTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLiveTranscodeTemplateWithOptions(request, runtime);
}

model UpdateMediaInfoRequest {
  appendTags?: boolean(name='AppendTags'),
  businessType?: string(name='BusinessType'),
  cateId?: long(name='CateId'),
  category?: string(name='Category'),
  coverURL?: string(name='CoverURL'),
  description?: string(name='Description'),
  inputURL?: string(name='InputURL'),
  mediaId?: string(name='MediaId'),
  mediaTags?: string(name='MediaTags'),
  referenceId?: string(name='ReferenceId'),
  title?: string(name='Title'),
  userData?: string(name='UserData'),
}

model UpdateMediaInfoResponseBody = {
  mediaId?: string(name='MediaId'),
  requestId?: string(name='RequestId'),
}

model UpdateMediaInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMediaInfoResponseBody(name='body'),
}

async function updateMediaInfoWithOptions(request: UpdateMediaInfoRequest, runtime: Util.RuntimeOptions): UpdateMediaInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appendTags)) {
    query['AppendTags'] = request.appendTags;
  }
  if (!Util.isUnset(request.businessType)) {
    query['BusinessType'] = request.businessType;
  }
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.coverURL)) {
    query['CoverURL'] = request.coverURL;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.inputURL)) {
    query['InputURL'] = request.inputURL;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.mediaTags)) {
    query['MediaTags'] = request.mediaTags;
  }
  if (!Util.isUnset(request.referenceId)) {
    query['ReferenceId'] = request.referenceId;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMediaInfo',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMediaInfo(request: UpdateMediaInfoRequest): UpdateMediaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaInfoWithOptions(request, runtime);
}

model UpdateMediaMarksRequest {
  mediaId?: string(name='MediaId'),
  mediaMarks?: string(name='MediaMarks'),
}

model UpdateMediaMarksResponseBody = {
  mediaId?: string(name='MediaId'),
  mediaMarkIds?: string(name='MediaMarkIds'),
  requestId?: string(name='RequestId'),
}

model UpdateMediaMarksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMediaMarksResponseBody(name='body'),
}

async function updateMediaMarksWithOptions(request: UpdateMediaMarksRequest, runtime: Util.RuntimeOptions): UpdateMediaMarksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.mediaMarks)) {
    query['MediaMarks'] = request.mediaMarks;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMediaMarks',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMediaMarks(request: UpdateMediaMarksRequest): UpdateMediaMarksResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaMarksWithOptions(request, runtime);
}

model UpdatePipelineRequest {
  name?: string(name='Name'),
  pipelineId?: string(name='PipelineId'),
  priority?: int32(name='Priority'),
  status?: string(name='Status'),
}

model UpdatePipelineResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdatePipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePipelineResponseBody(name='body'),
}

async function updatePipelineWithOptions(request: UpdatePipelineRequest, runtime: Util.RuntimeOptions): UpdatePipelineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePipeline',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePipeline(request: UpdatePipelineRequest): UpdatePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePipelineWithOptions(request, runtime);
}

model UpdateSmartJobRequest {
  FEExtend?: string(name='FEExtend'),
  jobId?: string(name='JobId'),
}

model UpdateSmartJobResponseBody = {
  FEExtend?: string(name='FEExtend'),
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model UpdateSmartJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSmartJobResponseBody(name='body'),
}

async function updateSmartJobWithOptions(request: UpdateSmartJobRequest, runtime: Util.RuntimeOptions): UpdateSmartJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.FEExtend)) {
    query['FEExtend'] = request.FEExtend;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSmartJob',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSmartJob(request: UpdateSmartJobRequest): UpdateSmartJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSmartJobWithOptions(request, runtime);
}

model UpdateTemplateRequest {
  config?: string(name='Config'),
  coverUrl?: string(name='CoverUrl'),
  name?: string(name='Name'),
  previewMedia?: string(name='PreviewMedia'),
  relatedMediaids?: string(name='RelatedMediaids'),
  source?: string(name='Source'),
  status?: string(name='Status'),
  templateId?: string(name='TemplateId'),
}

model UpdateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTemplateResponseBody(name='body'),
}

async function updateTemplateWithOptions(request: UpdateTemplateRequest, runtime: Util.RuntimeOptions): UpdateTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.coverUrl)) {
    query['CoverUrl'] = request.coverUrl;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.previewMedia)) {
    query['PreviewMedia'] = request.previewMedia;
  }
  if (!Util.isUnset(request.relatedMediaids)) {
    query['RelatedMediaids'] = request.relatedMediaids;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTemplate',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTemplate(request: UpdateTemplateRequest): UpdateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTemplateWithOptions(request, runtime);
}

model UploadMediaByURLRequest {
  appId?: string(name='AppId'),
  entityId?: string(name='EntityId'),
  mediaMetaData?: string(name='MediaMetaData'),
  postProcessConfig?: string(name='PostProcessConfig'),
  uploadTargetConfig?: string(name='UploadTargetConfig'),
  uploadURLs?: string(name='UploadURLs'),
  userData?: string(name='UserData'),
}

model UploadMediaByURLResponseBody = {
  requestId?: string(name='RequestId'),
  uploadJobs?: [ 
    {
      jobId?: string(name='JobId'),
      mediaId?: string(name='MediaId'),
      sourceURL?: string(name='SourceURL'),
    }
  ](name='UploadJobs'),
}

model UploadMediaByURLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadMediaByURLResponseBody(name='body'),
}

async function uploadMediaByURLWithOptions(request: UploadMediaByURLRequest, runtime: Util.RuntimeOptions): UploadMediaByURLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.entityId)) {
    query['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.mediaMetaData)) {
    query['MediaMetaData'] = request.mediaMetaData;
  }
  if (!Util.isUnset(request.postProcessConfig)) {
    query['PostProcessConfig'] = request.postProcessConfig;
  }
  if (!Util.isUnset(request.uploadTargetConfig)) {
    query['UploadTargetConfig'] = request.uploadTargetConfig;
  }
  if (!Util.isUnset(request.uploadURLs)) {
    query['UploadURLs'] = request.uploadURLs;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadMediaByURL',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadMediaByURL(request: UploadMediaByURLRequest): UploadMediaByURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadMediaByURLWithOptions(request, runtime);
}

model UploadStreamByURLRequest {
  definition?: string(name='Definition'),
  fileExtension?: string(name='FileExtension'),
  HDRType?: string(name='HDRType'),
  mediaId?: string(name='MediaId'),
  streamURL?: string(name='StreamURL'),
  userData?: string(name='UserData'),
}

model UploadStreamByURLResponseBody = {
  fileURL?: string(name='FileURL'),
  jobId?: string(name='JobId'),
  mediaId?: string(name='MediaId'),
  requestId?: string(name='RequestId'),
  sourceURL?: string(name='SourceURL'),
}

model UploadStreamByURLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadStreamByURLResponseBody(name='body'),
}

async function uploadStreamByURLWithOptions(request: UploadStreamByURLRequest, runtime: Util.RuntimeOptions): UploadStreamByURLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.definition)) {
    query['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.fileExtension)) {
    query['FileExtension'] = request.fileExtension;
  }
  if (!Util.isUnset(request.HDRType)) {
    query['HDRType'] = request.HDRType;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.streamURL)) {
    query['StreamURL'] = request.streamURL;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadStreamByURL',
    version = '2020-11-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadStreamByURL(request: UploadStreamByURLRequest): UploadStreamByURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadStreamByURLWithOptions(request, runtime);
}

