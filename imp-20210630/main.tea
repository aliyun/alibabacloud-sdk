/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('imp', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AssetsAuditAssetResponse {
  requestId?: string(name='RequestId'),
  status?: RpcStatus(name='Status'),
}

model AssetsCreateAssetResponse {
  asset?: CommonAsset(name='Asset'),
  requestId?: string(name='RequestId'),
  status?: RpcStatus(name='Status'),
}

model AssetsDeleteAssetResponse {
  asset?: CommonAsset(name='Asset'),
  requestId?: string(name='RequestId'),
  status?: RpcStatus(name='Status'),
}

model AssetsGetAssetResponse {
  asset?: CommonAsset(name='Asset'),
  requestId?: string(name='RequestId'),
  status?: RpcStatus(name='Status'),
}

model AssetsListAssetsRequest {
  appId?: string(name='AppId'),
  fieldMask?: string(name='FieldMask'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  params?: string(name='Params'),
  topic?: string(name='Topic'),
}

model AssetsListAssetsResponse {
  assets?: [
    CommonAsset
  ](name='Assets'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  status?: RpcStatus(name='Status'),
}

model AssetsUpdateAssetResponse {
  asset?: CommonAsset(name='Asset'),
  requestId?: string(name='RequestId'),
  status?: RpcStatus(name='Status'),
}

model CommonAddress {
  address?: string(name='Address'),
  city?: string(name='City'),
  country?: string(name='Country'),
  state?: string(name='State'),
  zip?: string(name='Zip'),
}

model CommonAsset {
  address?: CommonAddress(name='Address'),
  appId?: string(name='AppId'),
  audios?: [
    CommonMediaResource
  ](name='Audios'),
  auditStatus?: string(name='AuditStatus'),
  author?: string(name='Author'),
  createdAt?: string(name='CreatedAt'),
  description?: string(name='Description'),
  extends?: map[string]any(name='Extends'),
  id?: string(name='Id'),
  images?: [
    CommonMediaResource
  ](name='Images'),
  labels?: map[string]any(name='Labels'),
  location?: TypeLatLng(name='Location'),
  source?: string(name='Source'),
  status?: string(name='Status'),
  synopsis?: string(name='Synopsis'),
  tags?: [ string ](name='Tags'),
  title?: string(name='Title'),
  updatedAt?: string(name='UpdatedAt'),
  videos?: [
    CommonMediaResource
  ](name='Videos'),
}

model CommonMediaResource {
  format?: string(name='Format'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  sha1?: string(name='Sha1'),
  size?: long(name='Size'),
  url?: string(name='Url'),
}

model CommonSimpleAsset {
  address?: CommonAddress(name='Address'),
  appId?: string(name='AppId'),
  audio?: CommonMediaResource(name='Audio'),
  auditStatus?: string(name='AuditStatus'),
  author?: string(name='Author'),
  createdAt?: string(name='CreatedAt'),
  description?: string(name='Description'),
  extends?: map[string]any(name='Extends'),
  id?: string(name='Id'),
  image?: CommonMediaResource(name='Image'),
  labels?: map[string]any(name='Labels'),
  location?: TypeLatLng(name='Location'),
  source?: string(name='Source'),
  status?: string(name='Status'),
  synopsis?: string(name='Synopsis'),
  tags?: [ string ](name='Tags'),
  title?: string(name='Title'),
  updatedAt?: string(name='UpdatedAt'),
  video?: CommonMediaResource(name='Video'),
}

model RpcStatus {
  code?: int32(name='Code'),
  detail?: string(name='Detail'),
  message?: string(name='Message'),
}

model TypeLatLng {
  latitude?: double(name='Latitude'),
  longitude?: double(name='Longitude'),
}

model AddMemberRequest {
  conferenceId?: string(name='ConferenceId'),
  fromUserId?: string(name='FromUserId'),
  toUserId?: string(name='ToUserId'),
}

model AddMemberResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddMemberResponseBody(name='body'),
}

async function addMemberWithOptions(request: AddMemberRequest, runtime: Util.RuntimeOptions): AddMemberResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.conferenceId)) {
    body['ConferenceId'] = request.conferenceId;
  }
  if (!Util.isUnset(request.fromUserId)) {
    body['FromUserId'] = request.fromUserId;
  }
  if (!Util.isUnset(request.toUserId)) {
    body['ToUserId'] = request.toUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddMember',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addMember(request: AddMemberRequest): AddMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMemberWithOptions(request, runtime);
}

model AgreeLinkMicRequest {
  conferenceId?: string(name='ConferenceId'),
  fromUserId?: string(name='FromUserId'),
  toUserId?: string(name='ToUserId'),
}

model AgreeLinkMicResponseBody = {
  requestId?: string(name='RequestId'),
}

model AgreeLinkMicResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AgreeLinkMicResponseBody(name='body'),
}

async function agreeLinkMicWithOptions(request: AgreeLinkMicRequest, runtime: Util.RuntimeOptions): AgreeLinkMicResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.conferenceId)) {
    body['ConferenceId'] = request.conferenceId;
  }
  if (!Util.isUnset(request.fromUserId)) {
    body['FromUserId'] = request.fromUserId;
  }
  if (!Util.isUnset(request.toUserId)) {
    body['ToUserId'] = request.toUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AgreeLinkMic',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function agreeLinkMic(request: AgreeLinkMicRequest): AgreeLinkMicResponse {
  var runtime = new Util.RuntimeOptions{};
  return agreeLinkMicWithOptions(request, runtime);
}

model ApplyLinkMicRequest {
  conferenceId?: string(name='ConferenceId'),
  userId?: string(name='UserId'),
}

model ApplyLinkMicResponseBody = {
  requestId?: string(name='RequestId'),
}

model ApplyLinkMicResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyLinkMicResponseBody(name='body'),
}

async function applyLinkMicWithOptions(request: ApplyLinkMicRequest, runtime: Util.RuntimeOptions): ApplyLinkMicResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.conferenceId)) {
    body['ConferenceId'] = request.conferenceId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ApplyLinkMic',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyLinkMic(request: ApplyLinkMicRequest): ApplyLinkMicResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyLinkMicWithOptions(request, runtime);
}

model AttachStandardRoomHttpsCertificateRequest {
  appId?: string(name='AppId'),
  certificatePrivateKey?: string(name='CertificatePrivateKey'),
  certificatePublicKey?: string(name='CertificatePublicKey'),
  domainName?: string(name='DomainName'),
}

model AttachStandardRoomHttpsCertificateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    certificateId?: string(name='CertificateId'),
  }(name='Result'),
}

model AttachStandardRoomHttpsCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachStandardRoomHttpsCertificateResponseBody(name='body'),
}

async function attachStandardRoomHttpsCertificateWithOptions(request: AttachStandardRoomHttpsCertificateRequest, runtime: Util.RuntimeOptions): AttachStandardRoomHttpsCertificateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.certificatePrivateKey)) {
    body['CertificatePrivateKey'] = request.certificatePrivateKey;
  }
  if (!Util.isUnset(request.certificatePublicKey)) {
    body['CertificatePublicKey'] = request.certificatePublicKey;
  }
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AttachStandardRoomHttpsCertificate',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachStandardRoomHttpsCertificate(request: AttachStandardRoomHttpsCertificateRequest): AttachStandardRoomHttpsCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachStandardRoomHttpsCertificateWithOptions(request, runtime);
}

model BanAllCommentRequest {
  appId?: string(name='AppId'),
  roomId?: string(name='RoomId'),
  userId?: string(name='UserId'),
}

model BanAllCommentResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model BanAllCommentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BanAllCommentResponseBody(name='body'),
}

async function banAllCommentWithOptions(request: BanAllCommentRequest, runtime: Util.RuntimeOptions): BanAllCommentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BanAllComment',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function banAllComment(request: BanAllCommentRequest): BanAllCommentResponse {
  var runtime = new Util.RuntimeOptions{};
  return banAllCommentWithOptions(request, runtime);
}

model BanCommentRequest {
  appId?: string(name='AppId'),
  banCommentTime?: long(name='BanCommentTime'),
  banCommentUser?: string(name='BanCommentUser'),
  roomId?: string(name='RoomId'),
  userId?: string(name='UserId'),
}

model BanCommentResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model BanCommentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BanCommentResponseBody(name='body'),
}

async function banCommentWithOptions(request: BanCommentRequest, runtime: Util.RuntimeOptions): BanCommentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.banCommentTime)) {
    body['BanCommentTime'] = request.banCommentTime;
  }
  if (!Util.isUnset(request.banCommentUser)) {
    body['BanCommentUser'] = request.banCommentUser;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BanComment',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function banComment(request: BanCommentRequest): BanCommentResponse {
  var runtime = new Util.RuntimeOptions{};
  return banCommentWithOptions(request, runtime);
}

model BindProductShelfRequest {
  appId?: string(name='AppId'),
  shelfId?: string(name='ShelfId'),
  uuid?: [ string ](name='Uuid'),
}

model BindProductShelfShrinkRequest {
  appId?: string(name='AppId'),
  shelfId?: string(name='ShelfId'),
  uuidShrink?: string(name='Uuid'),
}

model BindProductShelfResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BindProductShelfResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindProductShelfResponseBody(name='body'),
}

async function bindProductShelfWithOptions(tmpReq: BindProductShelfRequest, runtime: Util.RuntimeOptions): BindProductShelfResponse {
  Util.validateModel(tmpReq);
  var request = new BindProductShelfShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.uuid)) {
    request.uuidShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.uuid, 'Uuid', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.shelfId)) {
    body['ShelfId'] = request.shelfId;
  }
  if (!Util.isUnset(request.uuidShrink)) {
    body['Uuid'] = request.uuidShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BindProductShelf',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bindProductShelf(request: BindProductShelfRequest): BindProductShelfResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindProductShelfWithOptions(request, runtime);
}

model CancelApplyLinkMicRequest {
  conferenceId?: string(name='ConferenceId'),
  userId?: string(name='UserId'),
}

model CancelApplyLinkMicResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelApplyLinkMicResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelApplyLinkMicResponseBody(name='body'),
}

async function cancelApplyLinkMicWithOptions(request: CancelApplyLinkMicRequest, runtime: Util.RuntimeOptions): CancelApplyLinkMicResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.conferenceId)) {
    body['ConferenceId'] = request.conferenceId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CancelApplyLinkMic',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelApplyLinkMic(request: CancelApplyLinkMicRequest): CancelApplyLinkMicResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelApplyLinkMicWithOptions(request, runtime);
}

model CancelBanAllCommentRequest {
  appId?: string(name='AppId'),
  roomId?: string(name='RoomId'),
  userId?: string(name='UserId'),
}

model CancelBanAllCommentResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CancelBanAllCommentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelBanAllCommentResponseBody(name='body'),
}

async function cancelBanAllCommentWithOptions(request: CancelBanAllCommentRequest, runtime: Util.RuntimeOptions): CancelBanAllCommentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CancelBanAllComment',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelBanAllComment(request: CancelBanAllCommentRequest): CancelBanAllCommentResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelBanAllCommentWithOptions(request, runtime);
}

model CancelBanCommentRequest {
  appId?: string(name='AppId'),
  banCommentUser?: string(name='BanCommentUser'),
  roomId?: string(name='RoomId'),
  userId?: string(name='UserId'),
}

model CancelBanCommentResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CancelBanCommentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelBanCommentResponseBody(name='body'),
}

async function cancelBanCommentWithOptions(request: CancelBanCommentRequest, runtime: Util.RuntimeOptions): CancelBanCommentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.banCommentUser)) {
    body['BanCommentUser'] = request.banCommentUser;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CancelBanComment',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelBanComment(request: CancelBanCommentRequest): CancelBanCommentResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelBanCommentWithOptions(request, runtime);
}

model CancelUserAdminRequest {
  appId?: string(name='AppId'),
  roomId?: string(name='RoomId'),
  userId?: string(name='UserId'),
}

model CancelUserAdminResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelUserAdminResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelUserAdminResponseBody(name='body'),
}

async function cancelUserAdminWithOptions(request: CancelUserAdminRequest, runtime: Util.RuntimeOptions): CancelUserAdminResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CancelUserAdmin',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelUserAdmin(request: CancelUserAdminRequest): CancelUserAdminResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelUserAdminWithOptions(request, runtime);
}

model CasterApiRequest {
  actionName?: string(name='ActionName'),
  appId?: string(name='AppId'),
  parameter?: string(name='Parameter'),
}

model CasterApiResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    response?: string(name='Response'),
  }(name='Result'),
}

model CasterApiResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CasterApiResponseBody(name='body'),
}

async function casterApiWithOptions(request: CasterApiRequest, runtime: Util.RuntimeOptions): CasterApiResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.actionName)) {
    body['ActionName'] = request.actionName;
  }
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.parameter)) {
    body['Parameter'] = request.parameter;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CasterApi',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function casterApi(request: CasterApiRequest): CasterApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return casterApiWithOptions(request, runtime);
}

model CreateAppRequest {
  appName?: string(name='AppName'),
  appTemplateId?: string(name='AppTemplateId'),
}

model CreateAppResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    appId?: string(name='AppId'),
  }(name='Result'),
}

model CreateAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAppResponseBody(name='body'),
}

async function createAppWithOptions(request: CreateAppRequest, runtime: Util.RuntimeOptions): CreateAppResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appName)) {
    body['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.appTemplateId)) {
    body['AppTemplateId'] = request.appTemplateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateApp',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createApp(request: CreateAppRequest): CreateAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAppWithOptions(request, runtime);
}

model CreateAppTemplateRequest {
  appTemplateName?: string(name='AppTemplateName'),
  componentList?: [ string ](name='ComponentList'),
  integrationMode?: string(name='IntegrationMode'),
  scene?: string(name='Scene'),
}

model CreateAppTemplateShrinkRequest {
  appTemplateName?: string(name='AppTemplateName'),
  componentListShrink?: string(name='ComponentList'),
  integrationMode?: string(name='IntegrationMode'),
  scene?: string(name='Scene'),
}

model CreateAppTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    appTemplateId?: string(name='AppTemplateId'),
  }(name='Result'),
}

model CreateAppTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAppTemplateResponseBody(name='body'),
}

async function createAppTemplateWithOptions(tmpReq: CreateAppTemplateRequest, runtime: Util.RuntimeOptions): CreateAppTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new CreateAppTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.componentList)) {
    request.componentListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.componentList, 'ComponentList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appTemplateName)) {
    body['AppTemplateName'] = request.appTemplateName;
  }
  if (!Util.isUnset(request.componentListShrink)) {
    body['ComponentList'] = request.componentListShrink;
  }
  if (!Util.isUnset(request.integrationMode)) {
    body['IntegrationMode'] = request.integrationMode;
  }
  if (!Util.isUnset(request.scene)) {
    body['Scene'] = request.scene;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAppTemplate',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAppTemplate(request: CreateAppTemplateRequest): CreateAppTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAppTemplateWithOptions(request, runtime);
}

model CreateAssetRequest {
  appId?: string(name='AppId'),
  asset?: CommonSimpleAsset(name='Asset'),
}

model CreateAssetShrinkRequest {
  appId?: string(name='AppId'),
  assetShrink?: string(name='Asset'),
}

model CreateAssetResponseBody = {
  asset?: CommonAsset(name='Asset'),
  requestId?: string(name='RequestId'),
}

model CreateAssetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAssetResponseBody(name='body'),
}

async function createAssetWithOptions(tmpReq: CreateAssetRequest, runtime: Util.RuntimeOptions): CreateAssetResponse {
  Util.validateModel(tmpReq);
  var request = new CreateAssetShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.asset)) {
    request.assetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.asset, 'Asset', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.assetShrink)) {
    body['Asset'] = request.assetShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAsset',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAsset(request: CreateAssetRequest): CreateAssetResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAssetWithOptions(request, runtime);
}

model CreateClassRequest {
  appId?: string(name='AppId'),
  createNickname?: string(name='CreateNickname'),
  createUserId?: string(name='CreateUserId'),
  title?: string(name='Title'),
}

model CreateClassResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    classId?: string(name='ClassId'),
    confId?: string(name='ConfId'),
    createNickname?: string(name='CreateNickname'),
    createUserId?: string(name='CreateUserId'),
    liveId?: string(name='LiveId'),
    roomId?: string(name='RoomId'),
    status?: int32(name='Status'),
    title?: string(name='Title'),
    whiteboardId?: string(name='WhiteboardId'),
    whiteboardRecordId?: string(name='WhiteboardRecordId'),
  }(name='Result'),
}

model CreateClassResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateClassResponseBody(name='body'),
}

async function createClassWithOptions(request: CreateClassRequest, runtime: Util.RuntimeOptions): CreateClassResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.createNickname)) {
    body['CreateNickname'] = request.createNickname;
  }
  if (!Util.isUnset(request.createUserId)) {
    body['CreateUserId'] = request.createUserId;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateClass',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createClass(request: CreateClassRequest): CreateClassResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClassWithOptions(request, runtime);
}

model CreateConferenceRequest {
  appId?: string(name='AppId'),
  roomId?: string(name='RoomId'),
  title?: string(name='Title'),
  userId?: string(name='UserId'),
}

model CreateConferenceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    conferenceId?: string(name='ConferenceId'),
  }(name='Result'),
}

model CreateConferenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateConferenceResponseBody(name='body'),
}

async function createConferenceWithOptions(request: CreateConferenceRequest, runtime: Util.RuntimeOptions): CreateConferenceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConference',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createConference(request: CreateConferenceRequest): CreateConferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConferenceWithOptions(request, runtime);
}

model CreateIceProjectRequest {
  appId?: string(name='AppId'),
  coverURL?: string(name='CoverURL'),
  liveId?: string(name='LiveId'),
  projectTitle?: string(name='ProjectTitle'),
  urlRegionId?: string(name='UrlRegionId'),
}

model CreateIceProjectResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    projectId?: string(name='ProjectId'),
  }(name='Result'),
}

model CreateIceProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIceProjectResponseBody(name='body'),
}

async function createIceProjectWithOptions(request: CreateIceProjectRequest, runtime: Util.RuntimeOptions): CreateIceProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.coverURL)) {
    body['CoverURL'] = request.coverURL;
  }
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  if (!Util.isUnset(request.projectTitle)) {
    body['ProjectTitle'] = request.projectTitle;
  }
  if (!Util.isUnset(request.urlRegionId)) {
    body['UrlRegionId'] = request.urlRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIceProject',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIceProject(request: CreateIceProjectRequest): CreateIceProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIceProjectWithOptions(request, runtime);
}

model CreateLiveRequest {
  anchorId?: string(name='AnchorId'),
  appId?: string(name='AppId'),
  codeLevel?: int32(name='CodeLevel'),
  introduction?: string(name='Introduction'),
  liveId?: string(name='LiveId'),
  roomId?: string(name='RoomId'),
  title?: string(name='Title'),
  userId?: string(name='UserId'),
}

model CreateLiveResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    liveId?: string(name='LiveId'),
  }(name='Result'),
}

model CreateLiveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLiveResponseBody(name='body'),
}

async function createLiveWithOptions(request: CreateLiveRequest, runtime: Util.RuntimeOptions): CreateLiveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.anchorId)) {
    body['AnchorId'] = request.anchorId;
  }
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.codeLevel)) {
    body['CodeLevel'] = request.codeLevel;
  }
  if (!Util.isUnset(request.introduction)) {
    body['Introduction'] = request.introduction;
  }
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLive',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLive(request: CreateLiveRequest): CreateLiveResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLiveWithOptions(request, runtime);
}

model CreateLiveRecordSliceFileRequest {
  appId?: string(name='AppId'),
  endTime?: long(name='EndTime'),
  fileName?: string(name='FileName'),
  liveId?: string(name='LiveId'),
  startTime?: long(name='StartTime'),
}

model CreateLiveRecordSliceFileResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    sliceRecordUrl?: string(name='SliceRecordUrl'),
  }(name='Result'),
}

model CreateLiveRecordSliceFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLiveRecordSliceFileResponseBody(name='body'),
}

async function createLiveRecordSliceFileWithOptions(request: CreateLiveRecordSliceFileRequest, runtime: Util.RuntimeOptions): CreateLiveRecordSliceFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLiveRecordSliceFile',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLiveRecordSliceFile(request: CreateLiveRecordSliceFileRequest): CreateLiveRecordSliceFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLiveRecordSliceFileWithOptions(request, runtime);
}

model CreateLiveRoomRequest {
  anchorId?: string(name='AnchorId'),
  anchorNick?: string(name='AnchorNick'),
  appId?: string(name='AppId'),
  coverUrl?: string(name='CoverUrl'),
  enableLinkMic?: boolean(name='EnableLinkMic'),
  extension?: map[string]string(name='Extension'),
  notice?: string(name='Notice'),
  title?: string(name='Title'),
  userId?: string(name='UserId'),
}

model CreateLiveRoomShrinkRequest {
  anchorId?: string(name='AnchorId'),
  anchorNick?: string(name='AnchorNick'),
  appId?: string(name='AppId'),
  coverUrl?: string(name='CoverUrl'),
  enableLinkMic?: boolean(name='EnableLinkMic'),
  extensionShrink?: string(name='Extension'),
  notice?: string(name='Notice'),
  title?: string(name='Title'),
  userId?: string(name='UserId'),
}

model CreateLiveRoomResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    anchorId?: string(name='AnchorId'),
    anchorNick?: string(name='AnchorNick'),
    appId?: string(name='AppId'),
    artcInfo?: {
      artcH5Url?: string(name='ArtcH5Url'),
      artcUrl?: string(name='ArtcUrl'),
    }(name='ArtcInfo'),
    chatId?: string(name='ChatId'),
    coverUrl?: string(name='CoverUrl'),
    extension?: map[string]string(name='Extension'),
    hlsUrl?: string(name='HlsUrl'),
    liveId?: string(name='LiveId'),
    liveUrl?: string(name='LiveUrl'),
    notice?: string(name='Notice'),
    playbackUrl?: string(name='PlaybackUrl'),
    pluginInstanceInfoList?: [ 
      {
        createTime?: long(name='CreateTime'),
        extension?: map[string]string(name='Extension'),
        pluginId?: string(name='PluginId'),
        pluginType?: string(name='PluginType'),
      }
    ](name='PluginInstanceInfoList'),
    pushUrl?: string(name='PushUrl'),
    roomId?: string(name='RoomId'),
    title?: string(name='Title'),
  }(name='Result'),
}

model CreateLiveRoomResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLiveRoomResponseBody(name='body'),
}

async function createLiveRoomWithOptions(tmpReq: CreateLiveRoomRequest, runtime: Util.RuntimeOptions): CreateLiveRoomResponse {
  Util.validateModel(tmpReq);
  var request = new CreateLiveRoomShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.extension)) {
    request.extensionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extension, 'Extension', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.anchorId)) {
    body['AnchorId'] = request.anchorId;
  }
  if (!Util.isUnset(request.anchorNick)) {
    body['AnchorNick'] = request.anchorNick;
  }
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.coverUrl)) {
    body['CoverUrl'] = request.coverUrl;
  }
  if (!Util.isUnset(request.enableLinkMic)) {
    body['EnableLinkMic'] = request.enableLinkMic;
  }
  if (!Util.isUnset(request.extensionShrink)) {
    body['Extension'] = request.extensionShrink;
  }
  if (!Util.isUnset(request.notice)) {
    body['Notice'] = request.notice;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLiveRoom',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLiveRoom(request: CreateLiveRoomRequest): CreateLiveRoomResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLiveRoomWithOptions(request, runtime);
}

model CreateProductShelfRequest {
  appId?: string(name='AppId'),
}

model CreateProductShelfResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    shelfId?: string(name='ShelfId'),
  }(name='Result'),
}

model CreateProductShelfResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProductShelfResponseBody(name='body'),
}

async function createProductShelfWithOptions(request: CreateProductShelfRequest, runtime: Util.RuntimeOptions): CreateProductShelfResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProductShelf',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createProductShelf(request: CreateProductShelfRequest): CreateProductShelfResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProductShelfWithOptions(request, runtime);
}

model CreateRoomRequest {
  appId?: string(name='AppId'),
  extension?: map[string]string(name='Extension'),
  notice?: string(name='Notice'),
  roomId?: string(name='RoomId'),
  roomOwnerId?: string(name='RoomOwnerId'),
  templateId?: string(name='TemplateId'),
  title?: string(name='Title'),
}

model CreateRoomShrinkRequest {
  appId?: string(name='AppId'),
  extensionShrink?: string(name='Extension'),
  notice?: string(name='Notice'),
  roomId?: string(name='RoomId'),
  roomOwnerId?: string(name='RoomOwnerId'),
  templateId?: string(name='TemplateId'),
  title?: string(name='Title'),
}

model CreateRoomResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    roomId?: string(name='RoomId'),
  }(name='Result'),
}

model CreateRoomResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRoomResponseBody(name='body'),
}

async function createRoomWithOptions(tmpReq: CreateRoomRequest, runtime: Util.RuntimeOptions): CreateRoomResponse {
  Util.validateModel(tmpReq);
  var request = new CreateRoomShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.extension)) {
    request.extensionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extension, 'Extension', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.extensionShrink)) {
    body['Extension'] = request.extensionShrink;
  }
  if (!Util.isUnset(request.notice)) {
    body['Notice'] = request.notice;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.roomOwnerId)) {
    body['RoomOwnerId'] = request.roomOwnerId;
  }
  if (!Util.isUnset(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRoom',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRoom(request: CreateRoomRequest): CreateRoomResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRoomWithOptions(request, runtime);
}

model CreateSensitiveWordRequest {
  appId?: string(name='AppId'),
  wordList?: [ string ](name='WordList'),
}

model CreateSensitiveWordShrinkRequest {
  appId?: string(name='AppId'),
  wordListShrink?: string(name='WordList'),
}

model CreateSensitiveWordResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    success?: boolean(name='Success'),
  }(name='Result'),
}

model CreateSensitiveWordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSensitiveWordResponseBody(name='body'),
}

async function createSensitiveWordWithOptions(tmpReq: CreateSensitiveWordRequest, runtime: Util.RuntimeOptions): CreateSensitiveWordResponse {
  Util.validateModel(tmpReq);
  var request = new CreateSensitiveWordShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.wordList)) {
    request.wordListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.wordList, 'WordList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.wordListShrink)) {
    body['WordList'] = request.wordListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSensitiveWord',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSensitiveWord(request: CreateSensitiveWordRequest): CreateSensitiveWordResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSensitiveWordWithOptions(request, runtime);
}

model CreateShelfRequest {
  appId?: string(name='AppId'),
  roomId?: string(name='RoomId'),
  userId?: string(name='UserId'),
}

model CreateShelfResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    shelfId?: string(name='ShelfId'),
  }(name='Result'),
}

model CreateShelfResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateShelfResponseBody(name='body'),
}

async function createShelfWithOptions(request: CreateShelfRequest, runtime: Util.RuntimeOptions): CreateShelfResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateShelf',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createShelf(request: CreateShelfRequest): CreateShelfResponse {
  var runtime = new Util.RuntimeOptions{};
  return createShelfWithOptions(request, runtime);
}

model DeleteAppRequest {
  appId?: string(name='AppId'),
}

model DeleteAppResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAppResponseBody(name='body'),
}

async function deleteAppWithOptions(request: DeleteAppRequest, runtime: Util.RuntimeOptions): DeleteAppResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteApp',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteApp(request: DeleteAppRequest): DeleteAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAppWithOptions(request, runtime);
}

model DeleteAppTemplateRequest {
  appTemplateId?: string(name='AppTemplateId'),
}

model DeleteAppTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAppTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAppTemplateResponseBody(name='body'),
}

async function deleteAppTemplateWithOptions(request: DeleteAppTemplateRequest, runtime: Util.RuntimeOptions): DeleteAppTemplateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appTemplateId)) {
    body['AppTemplateId'] = request.appTemplateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAppTemplate',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAppTemplate(request: DeleteAppTemplateRequest): DeleteAppTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAppTemplateWithOptions(request, runtime);
}

model DeleteClassRequest {
  appId?: string(name='AppId'),
  classId?: string(name='ClassId'),
  userId?: string(name='UserId'),
}

model DeleteClassResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteClassResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteClassResponseBody(name='body'),
}

async function deleteClassWithOptions(request: DeleteClassRequest, runtime: Util.RuntimeOptions): DeleteClassResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.classId)) {
    body['ClassId'] = request.classId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteClass',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteClass(request: DeleteClassRequest): DeleteClassResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClassWithOptions(request, runtime);
}

model DeleteCommentRequest {
  appId?: string(name='AppId'),
  commentIdList?: [ string ](name='CommentIdList'),
  roomId?: string(name='RoomId'),
  userId?: string(name='UserId'),
}

model DeleteCommentResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    deleteResult?: boolean(name='DeleteResult'),
  }(name='Result'),
}

model DeleteCommentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCommentResponseBody(name='body'),
}

async function deleteCommentWithOptions(request: DeleteCommentRequest, runtime: Util.RuntimeOptions): DeleteCommentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.commentIdList)) {
    bodyFlat['CommentIdList'] = request.commentIdList;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteComment',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteComment(request: DeleteCommentRequest): DeleteCommentResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCommentWithOptions(request, runtime);
}

model DeleteCommentByCreatorIdRequest {
  appId?: string(name='AppId'),
  commentIdList?: [ string ](name='CommentIdList'),
  creatorId?: string(name='CreatorId'),
  roomId?: string(name='RoomId'),
  userId?: string(name='UserId'),
}

model DeleteCommentByCreatorIdResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    deleteResult?: boolean(name='DeleteResult'),
  }(name='Result'),
}

model DeleteCommentByCreatorIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCommentByCreatorIdResponseBody(name='body'),
}

async function deleteCommentByCreatorIdWithOptions(request: DeleteCommentByCreatorIdRequest, runtime: Util.RuntimeOptions): DeleteCommentByCreatorIdResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.commentIdList)) {
    bodyFlat['CommentIdList'] = request.commentIdList;
  }
  if (!Util.isUnset(request.creatorId)) {
    body['CreatorId'] = request.creatorId;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCommentByCreatorId',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCommentByCreatorId(request: DeleteCommentByCreatorIdRequest): DeleteCommentByCreatorIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCommentByCreatorIdWithOptions(request, runtime);
}

model DeleteConferenceRequest {
  appId?: string(name='AppId'),
  conferenceId?: string(name='ConferenceId'),
  roomId?: string(name='RoomId'),
  userId?: string(name='UserId'),
}

model DeleteConferenceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteConferenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteConferenceResponseBody(name='body'),
}

async function deleteConferenceWithOptions(request: DeleteConferenceRequest, runtime: Util.RuntimeOptions): DeleteConferenceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.conferenceId)) {
    body['ConferenceId'] = request.conferenceId;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteConference',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteConference(request: DeleteConferenceRequest): DeleteConferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteConferenceWithOptions(request, runtime);
}

model DeleteLiveRequest {
  liveId?: string(name='LiveId'),
}

model DeleteLiveResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLiveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLiveResponseBody(name='body'),
}

async function deleteLiveWithOptions(request: DeleteLiveRequest, runtime: Util.RuntimeOptions): DeleteLiveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLive',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLive(request: DeleteLiveRequest): DeleteLiveResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLiveWithOptions(request, runtime);
}

model DeleteLiveFilesByIdRequest {
  appId?: string(name='AppId'),
  liveId?: string(name='LiveId'),
}

model DeleteLiveFilesByIdResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteLiveFilesByIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLiveFilesByIdResponseBody(name='body'),
}

async function deleteLiveFilesByIdWithOptions(request: DeleteLiveFilesByIdRequest, runtime: Util.RuntimeOptions): DeleteLiveFilesByIdResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLiveFilesById',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLiveFilesById(request: DeleteLiveFilesByIdRequest): DeleteLiveFilesByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLiveFilesByIdWithOptions(request, runtime);
}

model DeleteLiveRoomRequest {
  appId?: string(name='AppId'),
  liveId?: string(name='LiveId'),
  userId?: string(name='UserId'),
}

model DeleteLiveRoomResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLiveRoomResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLiveRoomResponseBody(name='body'),
}

async function deleteLiveRoomWithOptions(request: DeleteLiveRoomRequest, runtime: Util.RuntimeOptions): DeleteLiveRoomResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLiveRoom',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLiveRoom(request: DeleteLiveRoomRequest): DeleteLiveRoomResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLiveRoomWithOptions(request, runtime);
}

model DeleteProductModelRequest {
  appId?: string(name='AppId'),
  uuid?: string(name='Uuid'),
}

model DeleteProductModelResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteProductModelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProductModelResponseBody(name='body'),
}

async function deleteProductModelWithOptions(request: DeleteProductModelRequest, runtime: Util.RuntimeOptions): DeleteProductModelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.uuid)) {
    body['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProductModel',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProductModel(request: DeleteProductModelRequest): DeleteProductModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProductModelWithOptions(request, runtime);
}

model DeleteRoomRequest {
  appId?: string(name='AppId'),
  roomId?: string(name='RoomId'),
}

model DeleteRoomResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRoomResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRoomResponseBody(name='body'),
}

async function deleteRoomWithOptions(request: DeleteRoomRequest, runtime: Util.RuntimeOptions): DeleteRoomResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRoom',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRoom(request: DeleteRoomRequest): DeleteRoomResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRoomWithOptions(request, runtime);
}

model DeleteSensitiveWordRequest {
  appId?: string(name='AppId'),
  wordList?: [ string ](name='WordList'),
}

model DeleteSensitiveWordShrinkRequest {
  appId?: string(name='AppId'),
  wordListShrink?: string(name='WordList'),
}

model DeleteSensitiveWordResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    success?: boolean(name='Success'),
  }(name='Result'),
}

model DeleteSensitiveWordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSensitiveWordResponseBody(name='body'),
}

async function deleteSensitiveWordWithOptions(tmpReq: DeleteSensitiveWordRequest, runtime: Util.RuntimeOptions): DeleteSensitiveWordResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteSensitiveWordShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.wordList)) {
    request.wordListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.wordList, 'WordList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.wordListShrink)) {
    body['WordList'] = request.wordListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSensitiveWord',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSensitiveWord(request: DeleteSensitiveWordRequest): DeleteSensitiveWordResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSensitiveWordWithOptions(request, runtime);
}

model DescribeMeterImpPlayBackTimeByLiveIdRequest {
  appId?: string(name='AppId'),
  endTs?: long(name='EndTs'),
  liveId?: string(name='LiveId'),
  startTs?: long(name='StartTs'),
}

model DescribeMeterImpPlayBackTimeByLiveIdResponseBody = {
  data?: [ 
    {
      watchTime?: long(name='WatchTime'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMeterImpPlayBackTimeByLiveIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterImpPlayBackTimeByLiveIdResponseBody(name='body'),
}

async function describeMeterImpPlayBackTimeByLiveIdWithOptions(request: DescribeMeterImpPlayBackTimeByLiveIdRequest, runtime: Util.RuntimeOptions): DescribeMeterImpPlayBackTimeByLiveIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.endTs)) {
    query['EndTs'] = request.endTs;
  }
  if (!Util.isUnset(request.liveId)) {
    query['LiveId'] = request.liveId;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterImpPlayBackTimeByLiveId',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterImpPlayBackTimeByLiveId(request: DescribeMeterImpPlayBackTimeByLiveIdRequest): DescribeMeterImpPlayBackTimeByLiveIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterImpPlayBackTimeByLiveIdWithOptions(request, runtime);
}

model DescribeMeterImpWatchLiveTimeByLiveIdRequest {
  appId?: string(name='AppId'),
  liveId?: string(name='LiveId'),
}

model DescribeMeterImpWatchLiveTimeByLiveIdResponseBody = {
  data?: [ 
    {
      watchTimeInLatency?: long(name='WatchTimeInLatency'),
      watchTimeInLowLatency?: long(name='WatchTimeInLowLatency'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMeterImpWatchLiveTimeByLiveIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterImpWatchLiveTimeByLiveIdResponseBody(name='body'),
}

async function describeMeterImpWatchLiveTimeByLiveIdWithOptions(request: DescribeMeterImpWatchLiveTimeByLiveIdRequest, runtime: Util.RuntimeOptions): DescribeMeterImpWatchLiveTimeByLiveIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.liveId)) {
    query['LiveId'] = request.liveId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterImpWatchLiveTimeByLiveId',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterImpWatchLiveTimeByLiveId(request: DescribeMeterImpWatchLiveTimeByLiveIdRequest): DescribeMeterImpWatchLiveTimeByLiveIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterImpWatchLiveTimeByLiveIdWithOptions(request, runtime);
}

model DescribeMeterImpWatchTimeRequest {
  appId?: string(name='AppId'),
  endTime?: long(name='EndTime'),
  interval?: string(name='Interval'),
  sceneType?: string(name='SceneType'),
  startTime?: long(name='StartTime'),
}

model DescribeMeterImpWatchTimeResponseBody = {
  data?: [ 
    {
      liveRtcDuration?: long(name='LiveRtcDuration'),
      liveRtmpDuration?: long(name='LiveRtmpDuration'),
      liveRtsDuration?: long(name='LiveRtsDuration'),
      taskProfile?: string(name='TaskProfile'),
      time?: long(name='Time'),
      vodDuration?: long(name='VodDuration'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeMeterImpWatchTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMeterImpWatchTimeResponseBody(name='body'),
}

async function describeMeterImpWatchTimeWithOptions(request: DescribeMeterImpWatchTimeRequest, runtime: Util.RuntimeOptions): DescribeMeterImpWatchTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.sceneType)) {
    query['SceneType'] = request.sceneType;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMeterImpWatchTime',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMeterImpWatchTime(request: DescribeMeterImpWatchTimeRequest): DescribeMeterImpWatchTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMeterImpWatchTimeWithOptions(request, runtime);
}

model GetAppRequest {
  appId?: string(name='AppId'),
}

model GetAppResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    appConfigStatus?: string(name='AppConfigStatus'),
    appKey?: string(name='AppKey'),
    appName?: string(name='AppName'),
    appStatus?: string(name='AppStatus'),
    appTemplateId?: string(name='AppTemplateId'),
    appTemplateName?: string(name='AppTemplateName'),
    componentList?: [ string ](name='ComponentList'),
    createTime?: string(name='CreateTime'),
    integrationMode?: string(name='IntegrationMode'),
    standardRoomInfo?: string(name='StandardRoomInfo'),
  }(name='Result'),
}

model GetAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAppResponseBody(name='body'),
}

async function getAppWithOptions(request: GetAppRequest, runtime: Util.RuntimeOptions): GetAppResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetApp',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getApp(request: GetAppRequest): GetAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppWithOptions(request, runtime);
}

model GetAppTemplateRequest {
  appTemplateId?: string(name='AppTemplateId'),
}

model GetAppTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    appTemplateCreator?: string(name='AppTemplateCreator'),
    appTemplateName?: string(name='AppTemplateName'),
    apps?: [ 
      {
        appId?: string(name='AppId'),
        appKey?: string(name='AppKey'),
        appName?: string(name='AppName'),
        appStatus?: string(name='AppStatus'),
      }
    ](name='Apps'),
    componentList?: [ string ](name='ComponentList'),
    configList?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='ConfigList'),
    createTime?: string(name='CreateTime'),
    integrationMode?: string(name='IntegrationMode'),
    scene?: string(name='Scene'),
    sdkInfo?: string(name='SdkInfo'),
    standardRoomInfo?: string(name='StandardRoomInfo'),
    status?: string(name='Status'),
  }(name='Result'),
}

model GetAppTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAppTemplateResponseBody(name='body'),
}

async function getAppTemplateWithOptions(request: GetAppTemplateRequest, runtime: Util.RuntimeOptions): GetAppTemplateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appTemplateId)) {
    body['AppTemplateId'] = request.appTemplateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetAppTemplate',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAppTemplate(request: GetAppTemplateRequest): GetAppTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppTemplateWithOptions(request, runtime);
}

model GetAuthTokenRequest {
  appId?: string(name='AppId'),
  appKey?: string(name='AppKey'),
  deviceId?: string(name='DeviceId'),
  userId?: string(name='UserId'),
}

model GetAuthTokenResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    accessToken?: string(name='AccessToken'),
    accessTokenExpiredTime?: long(name='AccessTokenExpiredTime'),
    refreshToken?: string(name='RefreshToken'),
  }(name='Result'),
}

model GetAuthTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAuthTokenResponseBody(name='body'),
}

async function getAuthTokenWithOptions(request: GetAuthTokenRequest, runtime: Util.RuntimeOptions): GetAuthTokenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appKey)) {
    body['AppKey'] = request.appKey;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetAuthToken',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAuthToken(request: GetAuthTokenRequest): GetAuthTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuthTokenWithOptions(request, runtime);
}

model GetClassDetailRequest {
  appId?: string(name='AppId'),
  classId?: string(name='ClassId'),
  userId?: string(name='UserId'),
}

model GetClassDetailResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    classId?: string(name='ClassId'),
    confId?: string(name='ConfId'),
    createNickname?: string(name='CreateNickname'),
    createUserId?: string(name='CreateUserId'),
    endTime?: long(name='EndTime'),
    liveId?: string(name='LiveId'),
    roomId?: string(name='RoomId'),
    startTime?: long(name='StartTime'),
    status?: int32(name='Status'),
    title?: string(name='Title'),
    whiteboardId?: string(name='WhiteboardId'),
    whiteboardRecordId?: string(name='WhiteboardRecordId'),
  }(name='Result'),
}

model GetClassDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClassDetailResponseBody(name='body'),
}

async function getClassDetailWithOptions(request: GetClassDetailRequest, runtime: Util.RuntimeOptions): GetClassDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.classId)) {
    body['ClassId'] = request.classId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetClassDetail',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getClassDetail(request: GetClassDetailRequest): GetClassDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClassDetailWithOptions(request, runtime);
}

model GetClassRecordRequest {
  appId?: string(name='AppId'),
  classId?: string(name='ClassId'),
  userId?: string(name='UserId'),
}

model GetClassRecordResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    playbackUrlMap?: map[string][ string ](name='PlaybackUrlMap'),
  }(name='Result'),
}

model GetClassRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClassRecordResponseBody(name='body'),
}

async function getClassRecordWithOptions(request: GetClassRecordRequest, runtime: Util.RuntimeOptions): GetClassRecordResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.classId)) {
    body['ClassId'] = request.classId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetClassRecord',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getClassRecord(request: GetClassRecordRequest): GetClassRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClassRecordWithOptions(request, runtime);
}

model GetCnameDetailRequest {
  appId?: string(name='AppId'),
  domainName?: string(name='DomainName'),
  productCode?: string(name='ProductCode'),
}

model GetCnameDetailResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        cname?: string(name='Cname'),
        domainName?: string(name='DomainName'),
        status?: int32(name='Status'),
      }
    ](name='Data'),
  }(name='Result'),
}

model GetCnameDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCnameDetailResponseBody(name='body'),
}

async function getCnameDetailWithOptions(request: GetCnameDetailRequest, runtime: Util.RuntimeOptions): GetCnameDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCnameDetail',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCnameDetail(request: GetCnameDetailRequest): GetCnameDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCnameDetailWithOptions(request, runtime);
}

model GetConferenceRequest {
  conferenceId?: string(name='ConferenceId'),
}

model GetConferenceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    appId?: string(name='AppId'),
    conferenceId?: string(name='ConferenceId'),
    createTime?: long(name='CreateTime'),
    playbackUrl?: string(name='PlaybackUrl'),
    roomId?: string(name='RoomId'),
    status?: string(name='Status'),
    title?: string(name='Title'),
    userId?: string(name='UserId'),
  }(name='Result'),
}

model GetConferenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConferenceResponseBody(name='body'),
}

async function getConferenceWithOptions(request: GetConferenceRequest, runtime: Util.RuntimeOptions): GetConferenceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.conferenceId)) {
    body['ConferenceId'] = request.conferenceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetConference',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConference(request: GetConferenceRequest): GetConferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConferenceWithOptions(request, runtime);
}

model GetDomainCertificateInfoRequest {
  appId?: string(name='AppId'),
  domainName?: string(name='DomainName'),
  productCode?: string(name='ProductCode'),
}

model GetDomainCertificateInfoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    certInfos?: [ 
      {
        certDomainName?: string(name='CertDomainName'),
        certExpireTime?: long(name='CertExpireTime'),
        certLife?: string(name='CertLife'),
        certName?: string(name='CertName'),
        domainName?: string(name='DomainName'),
        SSLProtocol?: string(name='SSLProtocol'),
        SSLPub?: string(name='SSLPub'),
        status?: string(name='Status'),
      }
    ](name='CertInfos'),
  }(name='Result'),
}

model GetDomainCertificateInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDomainCertificateInfoResponseBody(name='body'),
}

async function getDomainCertificateInfoWithOptions(request: GetDomainCertificateInfoRequest, runtime: Util.RuntimeOptions): GetDomainCertificateInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDomainCertificateInfo',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDomainCertificateInfo(request: GetDomainCertificateInfoRequest): GetDomainCertificateInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDomainCertificateInfoWithOptions(request, runtime);
}

model GetDomainOwnerVerifyContentRequest {
  liveDomainName?: string(name='LiveDomainName'),
}

model GetDomainOwnerVerifyContentResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    content?: string(name='Content'),
  }(name='Result'),
}

model GetDomainOwnerVerifyContentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDomainOwnerVerifyContentResponseBody(name='body'),
}

async function getDomainOwnerVerifyContentWithOptions(request: GetDomainOwnerVerifyContentRequest, runtime: Util.RuntimeOptions): GetDomainOwnerVerifyContentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.liveDomainName)) {
    body['LiveDomainName'] = request.liveDomainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDomainOwnerVerifyContent',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDomainOwnerVerifyContent(request: GetDomainOwnerVerifyContentRequest): GetDomainOwnerVerifyContentResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDomainOwnerVerifyContentWithOptions(request, runtime);
}

model GetImpProductStatusResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model GetImpProductStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetImpProductStatusResponseBody(name='body'),
}

async function getImpProductStatusWithOptions(runtime: Util.RuntimeOptions): GetImpProductStatusResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetImpProductStatus',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getImpProductStatus(): GetImpProductStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImpProductStatusWithOptions(runtime);
}

model GetLiveRequest {
  liveId?: string(name='LiveId'),
}

model GetLiveResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    anchorId?: string(name='AnchorId'),
    appId?: string(name='AppId'),
    artcInfo?: {
      artcH5Url?: string(name='ArtcH5Url'),
      artcUrl?: string(name='ArtcUrl'),
    }(name='ArtcInfo'),
    codeLevel?: int32(name='CodeLevel'),
    coverUrl?: string(name='CoverUrl'),
    createTime?: long(name='CreateTime'),
    duration?: long(name='Duration'),
    endTime?: long(name='EndTime'),
    hlsUrl?: string(name='HlsUrl'),
    introduction?: string(name='Introduction'),
    liveId?: string(name='LiveId'),
    liveUrl?: string(name='LiveUrl'),
    playUrlInfoList?: [ 
      {
        codeLevel?: int32(name='CodeLevel'),
        flvUrl?: string(name='FlvUrl'),
        hlsUrl?: string(name='HlsUrl'),
        rtmpUrl?: string(name='RtmpUrl'),
      }
    ](name='PlayUrlInfoList'),
    playbackUrl?: string(name='PlaybackUrl'),
    pushUrl?: string(name='PushUrl'),
    roomId?: string(name='RoomId'),
    status?: string(name='Status'),
    title?: string(name='Title'),
    userDefineField?: string(name='UserDefineField'),
    userId?: string(name='UserId'),
  }(name='Result'),
}

model GetLiveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveResponseBody(name='body'),
}

async function getLiveWithOptions(request: GetLiveRequest, runtime: Util.RuntimeOptions): GetLiveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetLive',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLive(request: GetLiveRequest): GetLiveResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveWithOptions(request, runtime);
}

model GetLiveDomainStatusRequest {
  appId?: string(name='AppId'),
  liveDomainList?: [ string ](name='LiveDomainList'),
  liveDomainType?: string(name='LiveDomainType'),
}

model GetLiveDomainStatusShrinkRequest {
  appId?: string(name='AppId'),
  liveDomainListShrink?: string(name='LiveDomainList'),
  liveDomainType?: string(name='LiveDomainType'),
}

model GetLiveDomainStatusResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    liveDomainInfoList?: [ 
      {
        cname?: string(name='Cname'),
        domain?: string(name='Domain'),
        status?: string(name='Status'),
      }
    ](name='LiveDomainInfoList'),
  }(name='Result'),
}

model GetLiveDomainStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveDomainStatusResponseBody(name='body'),
}

async function getLiveDomainStatusWithOptions(tmpReq: GetLiveDomainStatusRequest, runtime: Util.RuntimeOptions): GetLiveDomainStatusResponse {
  Util.validateModel(tmpReq);
  var request = new GetLiveDomainStatusShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.liveDomainList)) {
    request.liveDomainListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.liveDomainList, 'LiveDomainList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.liveDomainListShrink)) {
    body['LiveDomainList'] = request.liveDomainListShrink;
  }
  if (!Util.isUnset(request.liveDomainType)) {
    body['LiveDomainType'] = request.liveDomainType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetLiveDomainStatus',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLiveDomainStatus(request: GetLiveDomainStatusRequest): GetLiveDomainStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveDomainStatusWithOptions(request, runtime);
}

model GetLiveRecordRequest {
  appId?: string(name='AppId'),
  liveId?: string(name='LiveId'),
  userId?: string(name='UserId'),
}

model GetLiveRecordResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    playbackUrlMap?: map[string][ string ](name='PlaybackUrlMap'),
  }(name='Result'),
}

model GetLiveRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveRecordResponseBody(name='body'),
}

async function getLiveRecordWithOptions(request: GetLiveRecordRequest, runtime: Util.RuntimeOptions): GetLiveRecordResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetLiveRecord',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLiveRecord(request: GetLiveRecordRequest): GetLiveRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveRecordWithOptions(request, runtime);
}

model GetLiveRoomRequest {
  appId?: string(name='AppId'),
  liveId?: string(name='LiveId'),
}

model GetLiveRoomResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    anchorId?: string(name='AnchorId'),
    anchorNick?: string(name='AnchorNick'),
    appId?: string(name='AppId'),
    artcInfo?: {
      artcH5Url?: string(name='ArtcH5Url'),
      artcUrl?: string(name='ArtcUrl'),
    }(name='ArtcInfo'),
    chatId?: string(name='ChatId'),
    confId?: string(name='ConfId'),
    coverUrl?: string(name='CoverUrl'),
    createTime?: long(name='CreateTime'),
    enableLinkMic?: boolean(name='EnableLinkMic'),
    endTime?: long(name='EndTime'),
    extension?: map[string]string(name='Extension'),
    hlsUrl?: string(name='HlsUrl'),
    hlsUrlHttps?: string(name='HlsUrlHttps'),
    liveId?: string(name='LiveId'),
    liveUrl?: string(name='LiveUrl'),
    liveUrlHttps?: string(name='LiveUrlHttps'),
    notice?: string(name='Notice'),
    onlineCount?: long(name='OnlineCount'),
    playbackUrl?: string(name='PlaybackUrl'),
    playbackUrlHttps?: string(name='PlaybackUrlHttps'),
    pluginInstanceInfoList?: [ 
      {
        createTime?: long(name='CreateTime'),
        extension?: map[string]string(name='Extension'),
        pluginId?: string(name='PluginId'),
        pluginType?: string(name='PluginType'),
      }
    ](name='PluginInstanceInfoList'),
    pushUrl?: string(name='PushUrl'),
    pv?: long(name='Pv'),
    roomId?: string(name='RoomId'),
    rtmpUrl?: string(name='RtmpUrl'),
    startTime?: long(name='StartTime'),
    status?: int32(name='Status'),
    title?: string(name='Title'),
    uv?: long(name='Uv'),
  }(name='Result'),
}

model GetLiveRoomResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveRoomResponseBody(name='body'),
}

async function getLiveRoomWithOptions(request: GetLiveRoomRequest, runtime: Util.RuntimeOptions): GetLiveRoomResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetLiveRoom',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLiveRoom(request: GetLiveRoomRequest): GetLiveRoomResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveRoomWithOptions(request, runtime);
}

model GetLiveRoomStatisticsRequest {
  appId?: string(name='AppId'),
  liveId?: string(name='LiveId'),
}

model GetLiveRoomStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    endTime?: long(name='EndTime'),
    likeCount?: long(name='LikeCount'),
    liveId?: string(name='LiveId'),
    messageCount?: long(name='MessageCount'),
    onlineCount?: long(name='OnlineCount'),
    pv?: long(name='Pv'),
    startTime?: long(name='StartTime'),
    status?: int32(name='Status'),
    uv?: long(name='Uv'),
    watchLiveTime?: long(name='WatchLiveTime'),
  }(name='Result'),
}

model GetLiveRoomStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveRoomStatisticsResponseBody(name='body'),
}

async function getLiveRoomStatisticsWithOptions(request: GetLiveRoomStatisticsRequest, runtime: Util.RuntimeOptions): GetLiveRoomStatisticsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetLiveRoomStatistics',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLiveRoomStatistics(request: GetLiveRoomStatisticsRequest): GetLiveRoomStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveRoomStatisticsWithOptions(request, runtime);
}

model GetLiveRoomUserStatisticsRequest {
  appId?: string(name='AppId'),
  liveId?: string(name='LiveId'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
}

model GetLiveRoomUserStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    hasMore?: boolean(name='HasMore'),
    liveId?: string(name='LiveId'),
    pageTotal?: int32(name='PageTotal'),
    totalCount?: int32(name='TotalCount'),
    userStatisticsList?: [ 
      {
        commentCount?: int32(name='CommentCount'),
        likeCount?: int32(name='LikeCount'),
        userId?: string(name='UserId'),
        watchLiveTime?: long(name='WatchLiveTime'),
      }
    ](name='UserStatisticsList'),
  }(name='Result'),
}

model GetLiveRoomUserStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveRoomUserStatisticsResponseBody(name='body'),
}

async function getLiveRoomUserStatisticsWithOptions(request: GetLiveRoomUserStatisticsRequest, runtime: Util.RuntimeOptions): GetLiveRoomUserStatisticsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetLiveRoomUserStatistics',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLiveRoomUserStatistics(request: GetLiveRoomUserStatisticsRequest): GetLiveRoomUserStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLiveRoomUserStatisticsWithOptions(request, runtime);
}

model GetPageConfigRequest {
  cloudUid?: string(name='CloudUid'),
}

model GetPageConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    adList?: [ 
      {
        canNotBeenBought?: boolean(name='CanNotBeenBought'),
        detail?: string(name='Detail'),
        icon?: string(name='Icon'),
        jumpBuyLink?: string(name='JumpBuyLink'),
        subTitle?: string(name='SubTitle'),
        title?: string(name='Title'),
      }
    ](name='AdList'),
  }(name='Result'),
}

model GetPageConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPageConfigResponseBody(name='body'),
}

async function getPageConfigWithOptions(request: GetPageConfigRequest, runtime: Util.RuntimeOptions): GetPageConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cloudUid)) {
    query['CloudUid'] = request.cloudUid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPageConfig',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPageConfig(request: GetPageConfigRequest): GetPageConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPageConfigWithOptions(request, runtime);
}

model GetRoomRequest {
  appId?: string(name='AppId'),
  roomId?: string(name='RoomId'),
}

model GetRoomResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    roomInfo?: {
      adminIdList?: [ string ](name='AdminIdList'),
      appId?: string(name='AppId'),
      createTime?: long(name='CreateTime'),
      extension?: map[string]string(name='Extension'),
      notice?: string(name='Notice'),
      onlineCount?: long(name='OnlineCount'),
      pluginInstanceInfoList?: [ 
        {
          createTime?: long(name='CreateTime'),
          extension?: map[string]string(name='Extension'),
          pluginId?: string(name='PluginId'),
          pluginType?: string(name='PluginType'),
        }
      ](name='PluginInstanceInfoList'),
      pv?: long(name='Pv'),
      roomId?: string(name='RoomId'),
      roomOwnerId?: string(name='RoomOwnerId'),
      templateId?: string(name='TemplateId'),
      title?: string(name='Title'),
      uv?: long(name='Uv'),
    }(name='RoomInfo'),
  }(name='Result'),
}

model GetRoomResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRoomResponseBody(name='body'),
}

async function getRoomWithOptions(request: GetRoomRequest, runtime: Util.RuntimeOptions): GetRoomResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetRoom',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRoom(request: GetRoomRequest): GetRoomResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRoomWithOptions(request, runtime);
}

model GetStandardRoomDomainStatusRequest {
  appId?: string(name='AppId'),
  domain?: string(name='Domain'),
}

model GetStandardRoomDomainStatusResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    domain?: string(name='Domain'),
    status?: int32(name='Status'),
  }(name='Result'),
}

model GetStandardRoomDomainStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetStandardRoomDomainStatusResponseBody(name='body'),
}

async function getStandardRoomDomainStatusWithOptions(request: GetStandardRoomDomainStatusRequest, runtime: Util.RuntimeOptions): GetStandardRoomDomainStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.domain)) {
    body['Domain'] = request.domain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetStandardRoomDomainStatus',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getStandardRoomDomainStatus(request: GetStandardRoomDomainStatusRequest): GetStandardRoomDomainStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStandardRoomDomainStatusWithOptions(request, runtime);
}

model GetStandardRoomHttpsCertificateRequest {
  certificateId?: string(name='CertificateId'),
}

model GetStandardRoomHttpsCertificateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    certificateName?: string(name='CertificateName'),
    createTime?: string(name='CreateTime'),
    domainName?: string(name='DomainName'),
    expireTime?: string(name='ExpireTime'),
  }(name='Result'),
}

model GetStandardRoomHttpsCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetStandardRoomHttpsCertificateResponseBody(name='body'),
}

async function getStandardRoomHttpsCertificateWithOptions(request: GetStandardRoomHttpsCertificateRequest, runtime: Util.RuntimeOptions): GetStandardRoomHttpsCertificateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.certificateId)) {
    body['CertificateId'] = request.certificateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetStandardRoomHttpsCertificate',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getStandardRoomHttpsCertificate(request: GetStandardRoomHttpsCertificateRequest): GetStandardRoomHttpsCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStandardRoomHttpsCertificateWithOptions(request, runtime);
}

model GetStandardRoomJumpUrlRequest {
  appId?: string(name='AppId'),
  appKey?: string(name='AppKey'),
  bizId?: string(name='BizId'),
  bizType?: string(name='BizType'),
  platform?: string(name='Platform'),
  userId?: string(name='UserId'),
  userNick?: string(name='UserNick'),
}

model GetStandardRoomJumpUrlResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    standardRoomJumpUrl?: string(name='StandardRoomJumpUrl'),
  }(name='Result'),
}

model GetStandardRoomJumpUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetStandardRoomJumpUrlResponseBody(name='body'),
}

async function getStandardRoomJumpUrlWithOptions(request: GetStandardRoomJumpUrlRequest, runtime: Util.RuntimeOptions): GetStandardRoomJumpUrlResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appKey)) {
    body['AppKey'] = request.appKey;
  }
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userNick)) {
    body['UserNick'] = request.userNick;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetStandardRoomJumpUrl',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getStandardRoomJumpUrl(request: GetStandardRoomJumpUrlRequest): GetStandardRoomJumpUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStandardRoomJumpUrlWithOptions(request, runtime);
}

model GetUserInfoRequest {
  cloudUid?: string(name='CloudUid'),
}

model GetUserInfoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    enableCreateAppLimit?: boolean(name='EnableCreateAppLimit'),
    hasOrderedImp?: boolean(name='HasOrderedImp'),
    isOverdue?: boolean(name='IsOverdue'),
    isPayByWatchTimeLengthUser?: boolean(name='IsPayByWatchTimeLengthUser'),
    maxCreateAppCount?: long(name='MaxCreateAppCount'),
  }(name='Result'),
}

model GetUserInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserInfoResponseBody(name='body'),
}

async function getUserInfoWithOptions(request: GetUserInfoRequest, runtime: Util.RuntimeOptions): GetUserInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cloudUid)) {
    query['CloudUid'] = request.cloudUid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserInfo',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserInfo(request: GetUserInfoRequest): GetUserInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserInfoWithOptions(request, runtime);
}

model KickRoomUserRequest {
  appId?: string(name='AppId'),
  blockTime?: long(name='BlockTime'),
  kickUser?: string(name='KickUser'),
  roomId?: string(name='RoomId'),
  userId?: string(name='UserId'),
}

model KickRoomUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model KickRoomUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: KickRoomUserResponseBody(name='body'),
}

async function kickRoomUserWithOptions(request: KickRoomUserRequest, runtime: Util.RuntimeOptions): KickRoomUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.blockTime)) {
    body['BlockTime'] = request.blockTime;
  }
  if (!Util.isUnset(request.kickUser)) {
    body['KickUser'] = request.kickUser;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'KickRoomUser',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function kickRoomUser(request: KickRoomUserRequest): KickRoomUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return kickRoomUserWithOptions(request, runtime);
}

model ListAccountsRequest {
  flag?: string(name='Flag'),
}

model ListAccountsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    uidList?: [ string ](name='UidList'),
  }(name='Result'),
}

model ListAccountsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAccountsResponseBody(name='body'),
}

async function listAccountsWithOptions(request: ListAccountsRequest, runtime: Util.RuntimeOptions): ListAccountsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.flag)) {
    body['Flag'] = request.flag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListAccounts',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAccounts(request: ListAccountsRequest): ListAccountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccountsWithOptions(request, runtime);
}

model ListAllCloudUidsRequest {
  flag?: string(name='Flag'),
  productAccountId?: string(name='ProductAccountId'),
}

model ListAllCloudUidsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    cloudUidList?: [ string ](name='CloudUidList'),
  }(name='Result'),
}

model ListAllCloudUidsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAllCloudUidsResponseBody(name='body'),
}

async function listAllCloudUidsWithOptions(request: ListAllCloudUidsRequest, runtime: Util.RuntimeOptions): ListAllCloudUidsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.flag)) {
    body['Flag'] = request.flag;
  }
  if (!Util.isUnset(request.productAccountId)) {
    body['ProductAccountId'] = request.productAccountId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListAllCloudUids',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAllCloudUids(request: ListAllCloudUidsRequest): ListAllCloudUidsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAllCloudUidsWithOptions(request, runtime);
}

model ListAppTemplatesRequest {
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
}

model ListAppTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    appTemplateInfoList?: [ 
      {
        appTemplateCreator?: string(name='AppTemplateCreator'),
        appTemplateId?: string(name='AppTemplateId'),
        appTemplateName?: string(name='AppTemplateName'),
        componentList?: [ string ](name='ComponentList'),
        configList?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='ConfigList'),
        createTime?: string(name='CreateTime'),
        integrationMode?: string(name='IntegrationMode'),
        scene?: string(name='Scene'),
        sdkInfo?: string(name='SdkInfo'),
        standardRoomInfo?: string(name='StandardRoomInfo'),
        status?: string(name='Status'),
      }
    ](name='AppTemplateInfoList'),
    pageTotal?: int32(name='PageTotal'),
    totalCount?: int32(name='TotalCount'),
  }(name='Result'),
}

model ListAppTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAppTemplatesResponseBody(name='body'),
}

async function listAppTemplatesWithOptions(request: ListAppTemplatesRequest, runtime: Util.RuntimeOptions): ListAppTemplatesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListAppTemplates',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAppTemplates(request: ListAppTemplatesRequest): ListAppTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppTemplatesWithOptions(request, runtime);
}

model ListApplyLinkMicUsersRequest {
  conferenceId?: string(name='ConferenceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListApplyLinkMicUsersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    applyLinkMicUserList?: [ string ](name='ApplyLinkMicUserList'),
    hasMore?: boolean(name='HasMore'),
    pageTotal?: int32(name='PageTotal'),
    totalCount?: int32(name='TotalCount'),
  }(name='Result'),
}

model ListApplyLinkMicUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListApplyLinkMicUsersResponseBody(name='body'),
}

async function listApplyLinkMicUsersWithOptions(request: ListApplyLinkMicUsersRequest, runtime: Util.RuntimeOptions): ListApplyLinkMicUsersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.conferenceId)) {
    body['ConferenceId'] = request.conferenceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListApplyLinkMicUsers',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listApplyLinkMicUsers(request: ListApplyLinkMicUsersRequest): ListApplyLinkMicUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApplyLinkMicUsersWithOptions(request, runtime);
}

model ListAppsRequest {
  appIds?: string(name='AppIds'),
  integrationMode?: string(name='IntegrationMode'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model ListAppsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    appInfoList?: [ 
      {
        appConfigStatus?: string(name='AppConfigStatus'),
        appId?: string(name='AppId'),
        appKey?: string(name='AppKey'),
        appName?: string(name='AppName'),
        appStatus?: string(name='AppStatus'),
        appTemplateId?: string(name='AppTemplateId'),
        appTemplateName?: string(name='AppTemplateName'),
        componentList?: [ string ](name='ComponentList'),
        createTime?: string(name='CreateTime'),
        integrationMode?: string(name='IntegrationMode'),
        standardRoomInfo?: string(name='StandardRoomInfo'),
      }
    ](name='AppInfoList'),
    pageTotal?: int32(name='PageTotal'),
    totalCount?: int32(name='TotalCount'),
  }(name='Result'),
}

model ListAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAppsResponseBody(name='body'),
}

async function listAppsWithOptions(request: ListAppsRequest, runtime: Util.RuntimeOptions): ListAppsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appIds)) {
    body['AppIds'] = request.appIds;
  }
  if (!Util.isUnset(request.integrationMode)) {
    body['IntegrationMode'] = request.integrationMode;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListApps',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listApps(request: ListAppsRequest): ListAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppsWithOptions(request, runtime);
}

model ListAssetsRequest {
  appId?: string(name='AppId'),
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  topic?: string(name='Topic'),
}

model ListAssetsResponseBody = {
  assets?: [
    CommonAsset
  ](name='Assets'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListAssetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAssetsResponseBody(name='body'),
}

async function listAssetsWithOptions(request: ListAssetsRequest, runtime: Util.RuntimeOptions): ListAssetsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.topic)) {
    body['Topic'] = request.topic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListAssets',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAssets(request: ListAssetsRequest): ListAssetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAssetsWithOptions(request, runtime);
}

model ListClassesRequest {
  appId?: string(name='AppId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  status?: int32(name='Status'),
}

model ListClassesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    classList?: [ 
      {
        classId?: string(name='ClassId'),
        confId?: string(name='ConfId'),
        createNickname?: string(name='CreateNickname'),
        createUserId?: string(name='CreateUserId'),
        endTime?: long(name='EndTime'),
        liveId?: string(name='LiveId'),
        roomId?: string(name='RoomId'),
        startTime?: long(name='StartTime'),
        status?: int32(name='Status'),
        title?: string(name='Title'),
        whiteboardId?: string(name='WhiteboardId'),
        whiteboardRecordId?: string(name='WhiteboardRecordId'),
      }
    ](name='ClassList'),
    hasMore?: boolean(name='HasMore'),
    pageTotal?: int32(name='PageTotal'),
    totalCount?: int32(name='TotalCount'),
  }(name='Result'),
}

model ListClassesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClassesResponseBody(name='body'),
}

async function listClassesWithOptions(request: ListClassesRequest, runtime: Util.RuntimeOptions): ListClassesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListClasses',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClasses(request: ListClassesRequest): ListClassesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClassesWithOptions(request, runtime);
}

model ListCommentsRequest {
  appId?: string(name='AppId'),
  creatorId?: string(name='CreatorId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  roomId?: string(name='RoomId'),
  sortType?: int32(name='SortType'),
  userId?: string(name='UserId'),
}

model ListCommentsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    commentVOList?: [ 
      {
        appId?: string(name='AppId'),
        commentId?: string(name='CommentId'),
        content?: string(name='Content'),
        createAt?: long(name='CreateAt'),
        extension?: map[string]string(name='Extension'),
        roomId?: string(name='RoomId'),
        senderId?: string(name='SenderId'),
        senderNick?: string(name='SenderNick'),
      }
    ](name='CommentVOList'),
    hasMore?: boolean(name='HasMore'),
    pageTotal?: int32(name='PageTotal'),
    totalCount?: int32(name='TotalCount'),
  }(name='Result'),
}

model ListCommentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCommentsResponseBody(name='body'),
}

async function listCommentsWithOptions(request: ListCommentsRequest, runtime: Util.RuntimeOptions): ListCommentsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.creatorId)) {
    body['CreatorId'] = request.creatorId;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.sortType)) {
    body['SortType'] = request.sortType;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListComments',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listComments(request: ListCommentsRequest): ListCommentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCommentsWithOptions(request, runtime);
}

model ListComponentsRequest {
  appId?: string(name='AppId'),
  appTemplateId?: string(name='AppTemplateId'),
}

model ListComponentsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    componentCategory?: [ 
      {
        list?: [ 
          {
            componentName?: string(name='ComponentName'),
            componentType?: string(name='ComponentType'),
            inUse?: string(name='InUse'),
          }
        ](name='List'),
        type?: string(name='Type'),
      }
    ](name='ComponentCategory'),
    configGroup?: [ 
      {
        category?: string(name='Category'),
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='ConfigGroup'),
    sceneList?: [ 
      {
        componentCategory?: [ 
          {
            list?: [ 
              {
                componentName?: string(name='ComponentName'),
                componentType?: string(name='ComponentType'),
                inUse?: string(name='InUse'),
              }
            ](name='List'),
            type?: string(name='Type'),
          }
        ](name='ComponentCategory'),
        scene?: string(name='Scene'),
      }
    ](name='SceneList'),
  }(name='Result'),
}

model ListComponentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListComponentsResponseBody(name='body'),
}

async function listComponentsWithOptions(request: ListComponentsRequest, runtime: Util.RuntimeOptions): ListComponentsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appTemplateId)) {
    body['AppTemplateId'] = request.appTemplateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListComponents',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listComponents(request: ListComponentsRequest): ListComponentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listComponentsWithOptions(request, runtime);
}

model ListConferenceUsersRequest {
  conferenceId?: string(name='ConferenceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListConferenceUsersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    conferenceUserList?: [ 
      {
        status?: string(name='Status'),
        userId?: string(name='UserId'),
      }
    ](name='ConferenceUserList'),
    hasMore?: boolean(name='HasMore'),
    pageTotal?: int32(name='PageTotal'),
    totalCount?: int32(name='TotalCount'),
  }(name='Result'),
}

model ListConferenceUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConferenceUsersResponseBody(name='body'),
}

async function listConferenceUsersWithOptions(request: ListConferenceUsersRequest, runtime: Util.RuntimeOptions): ListConferenceUsersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.conferenceId)) {
    body['ConferenceId'] = request.conferenceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListConferenceUsers',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listConferenceUsers(request: ListConferenceUsersRequest): ListConferenceUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConferenceUsersWithOptions(request, runtime);
}

model ListLiveFilesRequest {
  appId?: string(name='AppId'),
  liveId?: string(name='LiveId'),
}

model ListLiveFilesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    fileList?: [ 
      {
        fileName?: string(name='FileName'),
        url?: string(name='Url'),
      }
    ](name='FileList'),
  }(name='Result'),
}

model ListLiveFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLiveFilesResponseBody(name='body'),
}

async function listLiveFilesWithOptions(request: ListLiveFilesRequest, runtime: Util.RuntimeOptions): ListLiveFilesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListLiveFiles',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLiveFiles(request: ListLiveFilesRequest): ListLiveFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLiveFilesWithOptions(request, runtime);
}

model ListLiveRoomsRequest {
  appId?: string(name='AppId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  status?: int32(name='Status'),
}

model ListLiveRoomsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    hasMore?: boolean(name='HasMore'),
    liveList?: [ 
      {
        anchorId?: string(name='AnchorId'),
        anchorNick?: string(name='AnchorNick'),
        appId?: string(name='AppId'),
        chatId?: string(name='ChatId'),
        coverUrl?: string(name='CoverUrl'),
        createTime?: long(name='CreateTime'),
        endTime?: long(name='EndTime'),
        extension?: map[string]string(name='Extension'),
        liveId?: string(name='LiveId'),
        notice?: string(name='Notice'),
        onlineCount?: long(name='OnlineCount'),
        pv?: long(name='Pv'),
        roomId?: string(name='RoomId'),
        startTime?: long(name='StartTime'),
        status?: int32(name='Status'),
        title?: string(name='Title'),
        uv?: long(name='Uv'),
      }
    ](name='LiveList'),
    pageTotal?: int32(name='PageTotal'),
    totalCount?: int32(name='TotalCount'),
  }(name='Result'),
}

model ListLiveRoomsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLiveRoomsResponseBody(name='body'),
}

async function listLiveRoomsWithOptions(request: ListLiveRoomsRequest, runtime: Util.RuntimeOptions): ListLiveRoomsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListLiveRooms',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLiveRooms(request: ListLiveRoomsRequest): ListLiveRoomsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLiveRoomsWithOptions(request, runtime);
}

model ListLiveRoomsByIdRequest {
  appId?: string(name='AppId'),
  liveIdList?: [ string ](name='LiveIdList'),
}

model ListLiveRoomsByIdShrinkRequest {
  appId?: string(name='AppId'),
  liveIdListShrink?: string(name='LiveIdList'),
}

model ListLiveRoomsByIdResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    liveList?: [ 
      {
        anchorId?: string(name='AnchorId'),
        anchorNick?: string(name='AnchorNick'),
        appId?: string(name='AppId'),
        chatId?: string(name='ChatId'),
        coverUrl?: string(name='CoverUrl'),
        createTime?: long(name='CreateTime'),
        endTime?: long(name='EndTime'),
        extension?: map[string]string(name='Extension'),
        liveId?: string(name='LiveId'),
        notice?: string(name='Notice'),
        onlineCount?: long(name='OnlineCount'),
        pv?: long(name='Pv'),
        roomId?: string(name='RoomId'),
        startTime?: long(name='StartTime'),
        status?: int32(name='Status'),
        title?: string(name='Title'),
        uv?: long(name='Uv'),
      }
    ](name='LiveList'),
  }(name='Result'),
}

model ListLiveRoomsByIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLiveRoomsByIdResponseBody(name='body'),
}

async function listLiveRoomsByIdWithOptions(tmpReq: ListLiveRoomsByIdRequest, runtime: Util.RuntimeOptions): ListLiveRoomsByIdResponse {
  Util.validateModel(tmpReq);
  var request = new ListLiveRoomsByIdShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.liveIdList)) {
    request.liveIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.liveIdList, 'LiveIdList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.liveIdListShrink)) {
    body['LiveIdList'] = request.liveIdListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListLiveRoomsById',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLiveRoomsById(request: ListLiveRoomsByIdRequest): ListLiveRoomsByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLiveRoomsByIdWithOptions(request, runtime);
}

model ListProductModelRequest {
  appId?: string(name='AppId'),
  shelfIds?: [ string ](name='ShelfIds'),
}

model ListProductModelShrinkRequest {
  appId?: string(name='AppId'),
  shelfIdsShrink?: string(name='ShelfIds'),
}

model ListProductModelResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    productList?: [ 
      {
        createTime?: long(name='CreateTime'),
        productDescription?: string(name='ProductDescription'),
        productName?: string(name='ProductName'),
        updateTime?: long(name='UpdateTime'),
        uuid?: string(name='Uuid'),
      }
    ](name='ProductList'),
  }(name='Result'),
}

model ListProductModelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProductModelResponseBody(name='body'),
}

async function listProductModelWithOptions(tmpReq: ListProductModelRequest, runtime: Util.RuntimeOptions): ListProductModelResponse {
  Util.validateModel(tmpReq);
  var request = new ListProductModelShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.shelfIds)) {
    request.shelfIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.shelfIds, 'ShelfIds', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.shelfIdsShrink)) {
    body['ShelfIds'] = request.shelfIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListProductModel',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProductModel(request: ListProductModelRequest): ListProductModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProductModelWithOptions(request, runtime);
}

model ListProductShelfRequest {
  appId?: string(name='AppId'),
}

model ListProductShelfResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    shelfIds?: [ string ](name='ShelfIds'),
  }(name='Result'),
}

model ListProductShelfResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProductShelfResponseBody(name='body'),
}

async function listProductShelfWithOptions(request: ListProductShelfRequest, runtime: Util.RuntimeOptions): ListProductShelfResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListProductShelf',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProductShelf(request: ListProductShelfRequest): ListProductShelfResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProductShelfWithOptions(request, runtime);
}

model ListRoomLivesRequest {
  appId?: string(name='AppId'),
  queryTimestamp?: long(name='QueryTimestamp'),
  roomId?: string(name='RoomId'),
  roomIdList?: [ string ](name='RoomIdList'),
  size?: int32(name='Size'),
  status?: int32(name='Status'),
}

model ListRoomLivesShrinkRequest {
  appId?: string(name='AppId'),
  queryTimestamp?: long(name='QueryTimestamp'),
  roomId?: string(name='RoomId'),
  roomIdListShrink?: string(name='RoomIdList'),
  size?: int32(name='Size'),
  status?: int32(name='Status'),
}

model ListRoomLivesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    hasMore?: boolean(name='HasMore'),
    liveList?: [ 
      {
        appId?: string(name='AppId'),
        extension?: map[string]string(name='Extension'),
        liveId?: string(name='LiveId'),
        notice?: string(name='Notice'),
        onlineCount?: long(name='OnlineCount'),
        pv?: long(name='Pv'),
        roomId?: string(name='RoomId'),
        roomOwnerId?: string(name='RoomOwnerId'),
        status?: int32(name='Status'),
        title?: string(name='Title'),
        uv?: long(name='Uv'),
      }
    ](name='LiveList'),
    nextQueryTimestamp?: long(name='NextQueryTimestamp'),
  }(name='Result'),
}

model ListRoomLivesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRoomLivesResponseBody(name='body'),
}

async function listRoomLivesWithOptions(tmpReq: ListRoomLivesRequest, runtime: Util.RuntimeOptions): ListRoomLivesResponse {
  Util.validateModel(tmpReq);
  var request = new ListRoomLivesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.roomIdList)) {
    request.roomIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.roomIdList, 'RoomIdList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.queryTimestamp)) {
    body['QueryTimestamp'] = request.queryTimestamp;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.roomIdListShrink)) {
    body['RoomIdList'] = request.roomIdListShrink;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListRoomLives',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRoomLives(request: ListRoomLivesRequest): ListRoomLivesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRoomLivesWithOptions(request, runtime);
}

model ListRoomUsersRequest {
  appId?: string(name='AppId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  roomId?: string(name='RoomId'),
}

model ListRoomUsersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    hasMore?: boolean(name='HasMore'),
    pageTotal?: int32(name='PageTotal'),
    roomUserList?: [ 
      {
        extension?: map[string]string(name='Extension'),
        nick?: string(name='Nick'),
        userId?: string(name='UserId'),
      }
    ](name='RoomUserList'),
    totalCount?: int32(name='TotalCount'),
  }(name='Result'),
}

model ListRoomUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRoomUsersResponseBody(name='body'),
}

async function listRoomUsersWithOptions(request: ListRoomUsersRequest, runtime: Util.RuntimeOptions): ListRoomUsersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListRoomUsers',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRoomUsers(request: ListRoomUsersRequest): ListRoomUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRoomUsersWithOptions(request, runtime);
}

model ListRoomsRequest {
  appId?: string(name='AppId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListRoomsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    hasMore?: boolean(name='HasMore'),
    pageTotal?: int32(name='PageTotal'),
    roomInfoList?: [ 
      {
        appId?: string(name='AppId'),
        createTime?: string(name='CreateTime'),
        extension?: map[string]string(name='Extension'),
        notice?: string(name='Notice'),
        onlineCount?: long(name='OnlineCount'),
        pluginInstanceInfoList?: [ 
          {
            createTime?: long(name='CreateTime'),
            extension?: map[string]string(name='Extension'),
            pluginId?: string(name='PluginId'),
            pluginType?: string(name='PluginType'),
          }
        ](name='PluginInstanceInfoList'),
        roomId?: string(name='RoomId'),
        roomOwnerId?: string(name='RoomOwnerId'),
        templateId?: string(name='TemplateId'),
        title?: string(name='Title'),
        uv?: long(name='Uv'),
      }
    ](name='RoomInfoList'),
    totalCount?: int32(name='TotalCount'),
  }(name='Result'),
}

model ListRoomsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRoomsResponseBody(name='body'),
}

async function listRoomsWithOptions(request: ListRoomsRequest, runtime: Util.RuntimeOptions): ListRoomsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListRooms',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRooms(request: ListRoomsRequest): ListRoomsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRoomsWithOptions(request, runtime);
}

model ListSensitiveWordRequest {
  appId?: string(name='AppId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model ListSensitiveWordResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    totalCount?: int32(name='TotalCount'),
    wordList?: [ string ](name='WordList'),
  }(name='Result'),
}

model ListSensitiveWordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSensitiveWordResponseBody(name='body'),
}

async function listSensitiveWordWithOptions(request: ListSensitiveWordRequest, runtime: Util.RuntimeOptions): ListSensitiveWordResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListSensitiveWord',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSensitiveWord(request: ListSensitiveWordRequest): ListSensitiveWordResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSensitiveWordWithOptions(request, runtime);
}

model PublishLiveRequest {
  liveId?: string(name='LiveId'),
  userId?: string(name='UserId'),
}

model PublishLiveResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    anchorId?: string(name='AnchorId'),
    liveId?: string(name='LiveId'),
    liveUrl?: string(name='LiveUrl'),
    pushUrl?: string(name='PushUrl'),
    status?: string(name='Status'),
  }(name='Result'),
}

model PublishLiveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishLiveResponseBody(name='body'),
}

async function publishLiveWithOptions(request: PublishLiveRequest, runtime: Util.RuntimeOptions): PublishLiveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PublishLive',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function publishLive(request: PublishLiveRequest): PublishLiveResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishLiveWithOptions(request, runtime);
}

model PublishLiveRoomRequest {
  appId?: string(name='AppId'),
  liveId?: string(name='LiveId'),
  userId?: string(name='UserId'),
}

model PublishLiveRoomResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    liveId?: string(name='LiveId'),
    liveUrl?: string(name='LiveUrl'),
    pushUrl?: string(name='PushUrl'),
  }(name='Result'),
}

model PublishLiveRoomResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishLiveRoomResponseBody(name='body'),
}

async function publishLiveRoomWithOptions(request: PublishLiveRoomRequest, runtime: Util.RuntimeOptions): PublishLiveRoomResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PublishLiveRoom',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function publishLiveRoom(request: PublishLiveRoomRequest): PublishLiveRoomResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishLiveRoomWithOptions(request, runtime);
}

model RegisterIceOssMediaRequest {
  appId?: string(name='AppId'),
  fromType?: string(name='FromType'),
  liveId?: string(name='LiveId'),
  mediaTitle?: string(name='MediaTitle'),
  mediaUrl?: string(name='MediaUrl'),
  ossBucket?: string(name='OssBucket'),
  ossEndpoint?: string(name='OssEndpoint'),
  playbackUrlDomain?: string(name='PlaybackUrlDomain'),
  projectId?: string(name='ProjectId'),
  urlRegionId?: string(name='UrlRegionId'),
}

model RegisterIceOssMediaResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    mediaId?: string(name='MediaId'),
  }(name='Result'),
}

model RegisterIceOssMediaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterIceOssMediaResponseBody(name='body'),
}

async function registerIceOssMediaWithOptions(request: RegisterIceOssMediaRequest, runtime: Util.RuntimeOptions): RegisterIceOssMediaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.fromType)) {
    body['FromType'] = request.fromType;
  }
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  if (!Util.isUnset(request.mediaTitle)) {
    body['MediaTitle'] = request.mediaTitle;
  }
  if (!Util.isUnset(request.mediaUrl)) {
    body['MediaUrl'] = request.mediaUrl;
  }
  if (!Util.isUnset(request.ossBucket)) {
    body['OssBucket'] = request.ossBucket;
  }
  if (!Util.isUnset(request.ossEndpoint)) {
    body['OssEndpoint'] = request.ossEndpoint;
  }
  if (!Util.isUnset(request.playbackUrlDomain)) {
    body['PlaybackUrlDomain'] = request.playbackUrlDomain;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.urlRegionId)) {
    body['UrlRegionId'] = request.urlRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RegisterIceOssMedia',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerIceOssMedia(request: RegisterIceOssMediaRequest): RegisterIceOssMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerIceOssMediaWithOptions(request, runtime);
}

model RejectLinkMicRequest {
  conferenceId?: string(name='ConferenceId'),
  fromUserId?: string(name='FromUserId'),
  toUserId?: string(name='ToUserId'),
}

model RejectLinkMicResponseBody = {
  requestId?: string(name='RequestId'),
}

model RejectLinkMicResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RejectLinkMicResponseBody(name='body'),
}

async function rejectLinkMicWithOptions(request: RejectLinkMicRequest, runtime: Util.RuntimeOptions): RejectLinkMicResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.conferenceId)) {
    body['ConferenceId'] = request.conferenceId;
  }
  if (!Util.isUnset(request.fromUserId)) {
    body['FromUserId'] = request.fromUserId;
  }
  if (!Util.isUnset(request.toUserId)) {
    body['ToUserId'] = request.toUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RejectLinkMic',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rejectLinkMic(request: RejectLinkMicRequest): RejectLinkMicResponse {
  var runtime = new Util.RuntimeOptions{};
  return rejectLinkMicWithOptions(request, runtime);
}

model RemoveMemberRequest {
  conferenceId?: string(name='ConferenceId'),
  fromUserId?: string(name='FromUserId'),
  toUserId?: string(name='ToUserId'),
}

model RemoveMemberResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveMemberResponseBody(name='body'),
}

async function removeMemberWithOptions(request: RemoveMemberRequest, runtime: Util.RuntimeOptions): RemoveMemberResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.conferenceId)) {
    body['ConferenceId'] = request.conferenceId;
  }
  if (!Util.isUnset(request.fromUserId)) {
    body['FromUserId'] = request.fromUserId;
  }
  if (!Util.isUnset(request.toUserId)) {
    body['ToUserId'] = request.toUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveMember',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeMember(request: RemoveMemberRequest): RemoveMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeMemberWithOptions(request, runtime);
}

model SendCommentRequest {
  appId?: string(name='AppId'),
  content?: string(name='Content'),
  extension?: map[string]string(name='Extension'),
  roomId?: string(name='RoomId'),
  senderId?: string(name='SenderId'),
  senderNick?: string(name='SenderNick'),
}

model SendCommentShrinkRequest {
  appId?: string(name='AppId'),
  content?: string(name='Content'),
  extensionShrink?: string(name='Extension'),
  roomId?: string(name='RoomId'),
  senderId?: string(name='SenderId'),
  senderNick?: string(name='SenderNick'),
}

model SendCommentResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    commentVO?: {
      commentId?: string(name='CommentId'),
      content?: string(name='Content'),
      createAt?: long(name='CreateAt'),
      extension?: map[string]string(name='Extension'),
      senderId?: string(name='SenderId'),
      senderNick?: string(name='SenderNick'),
    }(name='CommentVO'),
  }(name='Result'),
}

model SendCommentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SendCommentResponseBody(name='body'),
}

async function sendCommentWithOptions(tmpReq: SendCommentRequest, runtime: Util.RuntimeOptions): SendCommentResponse {
  Util.validateModel(tmpReq);
  var request = new SendCommentShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.extension)) {
    request.extensionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extension, 'Extension', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.extensionShrink)) {
    body['Extension'] = request.extensionShrink;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.senderId)) {
    body['SenderId'] = request.senderId;
  }
  if (!Util.isUnset(request.senderNick)) {
    body['SenderNick'] = request.senderNick;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SendComment',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendComment(request: SendCommentRequest): SendCommentResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendCommentWithOptions(request, runtime);
}

model SendCustomMessageToAllRequest {
  appId?: string(name='AppId'),
  body?: string(name='Body'),
  roomId?: string(name='RoomId'),
}

model SendCustomMessageToAllResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    messageId?: string(name='MessageId'),
  }(name='Result'),
}

model SendCustomMessageToAllResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SendCustomMessageToAllResponseBody(name='body'),
}

async function sendCustomMessageToAllWithOptions(request: SendCustomMessageToAllRequest, runtime: Util.RuntimeOptions): SendCustomMessageToAllResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.body)) {
    body['Body'] = request.body;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SendCustomMessageToAll',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendCustomMessageToAll(request: SendCustomMessageToAllRequest): SendCustomMessageToAllResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendCustomMessageToAllWithOptions(request, runtime);
}

model SendCustomMessageToUsersRequest {
  appId?: string(name='AppId'),
  body?: string(name='Body'),
  receiverList?: [ string ](name='ReceiverList'),
  roomId?: string(name='RoomId'),
}

model SendCustomMessageToUsersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    messageId?: string(name='MessageId'),
  }(name='Result'),
}

model SendCustomMessageToUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SendCustomMessageToUsersResponseBody(name='body'),
}

async function sendCustomMessageToUsersWithOptions(request: SendCustomMessageToUsersRequest, runtime: Util.RuntimeOptions): SendCustomMessageToUsersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.body)) {
    body['Body'] = request.body;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.receiverList)) {
    bodyFlat['ReceiverList'] = request.receiverList;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SendCustomMessageToUsers',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendCustomMessageToUsers(request: SendCustomMessageToUsersRequest): SendCustomMessageToUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendCustomMessageToUsersWithOptions(request, runtime);
}

model SetDomainCertificateRequest {
  appId?: string(name='AppId'),
  certType?: string(name='CertType'),
  domainName?: string(name='DomainName'),
  productCode?: string(name='ProductCode'),
  SSLPri?: string(name='SSLPri'),
  SSLProtocol?: string(name='SSLProtocol'),
  SSLPub?: string(name='SSLPub'),
}

model SetDomainCertificateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    certificateId?: string(name='CertificateId'),
  }(name='Result'),
}

model SetDomainCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDomainCertificateResponseBody(name='body'),
}

async function setDomainCertificateWithOptions(request: SetDomainCertificateRequest, runtime: Util.RuntimeOptions): SetDomainCertificateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.certType)) {
    body['CertType'] = request.certType;
  }
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.productCode)) {
    body['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.SSLPri)) {
    body['SSLPri'] = request.SSLPri;
  }
  if (!Util.isUnset(request.SSLProtocol)) {
    body['SSLProtocol'] = request.SSLProtocol;
  }
  if (!Util.isUnset(request.SSLPub)) {
    body['SSLPub'] = request.SSLPub;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SetDomainCertificate',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDomainCertificate(request: SetDomainCertificateRequest): SetDomainCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDomainCertificateWithOptions(request, runtime);
}

model SetUserAdminRequest {
  appId?: string(name='AppId'),
  roomId?: string(name='RoomId'),
  userId?: string(name='UserId'),
}

model SetUserAdminResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetUserAdminResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetUserAdminResponseBody(name='body'),
}

async function setUserAdminWithOptions(request: SetUserAdminRequest, runtime: Util.RuntimeOptions): SetUserAdminResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SetUserAdmin',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setUserAdmin(request: SetUserAdminRequest): SetUserAdminResponse {
  var runtime = new Util.RuntimeOptions{};
  return setUserAdminWithOptions(request, runtime);
}

model StopClassRequest {
  appId?: string(name='AppId'),
  classId?: string(name='ClassId'),
  userId?: string(name='UserId'),
}

model StopClassResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopClassResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopClassResponseBody(name='body'),
}

async function stopClassWithOptions(request: StopClassRequest, runtime: Util.RuntimeOptions): StopClassResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.classId)) {
    body['ClassId'] = request.classId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopClass',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopClass(request: StopClassRequest): StopClassResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopClassWithOptions(request, runtime);
}

model StopLiveRequest {
  appId?: string(name='AppId'),
  liveId?: string(name='LiveId'),
  roomId?: string(name='RoomId'),
  userId?: string(name='UserId'),
}

model StopLiveResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopLiveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopLiveResponseBody(name='body'),
}

async function stopLiveWithOptions(request: StopLiveRequest, runtime: Util.RuntimeOptions): StopLiveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopLive',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopLive(request: StopLiveRequest): StopLiveResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopLiveWithOptions(request, runtime);
}

model StopLiveRoomRequest {
  appId?: string(name='AppId'),
  liveId?: string(name='LiveId'),
  userId?: string(name='UserId'),
}

model StopLiveRoomResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopLiveRoomResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopLiveRoomResponseBody(name='body'),
}

async function stopLiveRoomWithOptions(request: StopLiveRoomRequest, runtime: Util.RuntimeOptions): StopLiveRoomResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopLiveRoom',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopLiveRoom(request: StopLiveRoomRequest): StopLiveRoomResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopLiveRoomWithOptions(request, runtime);
}

model UnbindProductShelfRequest {
  appId?: string(name='AppId'),
  shelfId?: string(name='ShelfId'),
  uuid?: [ string ](name='Uuid'),
}

model UnbindProductShelfShrinkRequest {
  appId?: string(name='AppId'),
  shelfId?: string(name='ShelfId'),
  uuidShrink?: string(name='Uuid'),
}

model UnbindProductShelfResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UnbindProductShelfResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindProductShelfResponseBody(name='body'),
}

async function unbindProductShelfWithOptions(tmpReq: UnbindProductShelfRequest, runtime: Util.RuntimeOptions): UnbindProductShelfResponse {
  Util.validateModel(tmpReq);
  var request = new UnbindProductShelfShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.uuid)) {
    request.uuidShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.uuid, 'Uuid', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.shelfId)) {
    body['ShelfId'] = request.shelfId;
  }
  if (!Util.isUnset(request.uuidShrink)) {
    body['Uuid'] = request.uuidShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UnbindProductShelf',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindProductShelf(request: UnbindProductShelfRequest): UnbindProductShelfResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindProductShelfWithOptions(request, runtime);
}

model UpdateAppRequest {
  appId?: string(name='AppId'),
  appName?: string(name='AppName'),
  appStatus?: string(name='AppStatus'),
}

model UpdateAppResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppResponseBody(name='body'),
}

async function updateAppWithOptions(request: UpdateAppRequest, runtime: Util.RuntimeOptions): UpdateAppResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appName)) {
    body['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.appStatus)) {
    body['AppStatus'] = request.appStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApp',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateApp(request: UpdateAppRequest): UpdateAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppWithOptions(request, runtime);
}

model UpdateAppTemplateRequest {
  appTemplateId?: string(name='AppTemplateId'),
  appTemplateName?: string(name='AppTemplateName'),
  componentList?: [ string ](name='ComponentList'),
}

model UpdateAppTemplateShrinkRequest {
  appTemplateId?: string(name='AppTemplateId'),
  appTemplateName?: string(name='AppTemplateName'),
  componentListShrink?: string(name='ComponentList'),
}

model UpdateAppTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAppTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppTemplateResponseBody(name='body'),
}

async function updateAppTemplateWithOptions(tmpReq: UpdateAppTemplateRequest, runtime: Util.RuntimeOptions): UpdateAppTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateAppTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.componentList)) {
    request.componentListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.componentList, 'ComponentList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appTemplateId)) {
    body['AppTemplateId'] = request.appTemplateId;
  }
  if (!Util.isUnset(request.appTemplateName)) {
    body['AppTemplateName'] = request.appTemplateName;
  }
  if (!Util.isUnset(request.componentListShrink)) {
    body['ComponentList'] = request.componentListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppTemplate',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAppTemplate(request: UpdateAppTemplateRequest): UpdateAppTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppTemplateWithOptions(request, runtime);
}

model UpdateAppTemplateConfigRequest {
  appTemplateId?: string(name='AppTemplateId'),
  configList?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='ConfigList'),
}

model UpdateAppTemplateConfigShrinkRequest {
  appTemplateId?: string(name='AppTemplateId'),
  configListShrink?: string(name='ConfigList'),
}

model UpdateAppTemplateConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    configLogs?: [ 
      {
        code?: string(name='Code'),
        message?: string(name='Message'),
      }
    ](name='ConfigLogs'),
  }(name='Result'),
}

model UpdateAppTemplateConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppTemplateConfigResponseBody(name='body'),
}

async function updateAppTemplateConfigWithOptions(tmpReq: UpdateAppTemplateConfigRequest, runtime: Util.RuntimeOptions): UpdateAppTemplateConfigResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateAppTemplateConfigShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.configList)) {
    request.configListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.configList, 'ConfigList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appTemplateId)) {
    body['AppTemplateId'] = request.appTemplateId;
  }
  if (!Util.isUnset(request.configListShrink)) {
    body['ConfigList'] = request.configListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppTemplateConfig',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAppTemplateConfig(request: UpdateAppTemplateConfigRequest): UpdateAppTemplateConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppTemplateConfigWithOptions(request, runtime);
}

model UpdateClassRequest {
  appId?: string(name='AppId'),
  classId?: string(name='ClassId'),
  createNickname?: string(name='CreateNickname'),
  createUserId?: string(name='CreateUserId'),
  title?: string(name='Title'),
}

model UpdateClassResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateClassResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateClassResponseBody(name='body'),
}

async function updateClassWithOptions(request: UpdateClassRequest, runtime: Util.RuntimeOptions): UpdateClassResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.classId)) {
    body['ClassId'] = request.classId;
  }
  if (!Util.isUnset(request.createNickname)) {
    body['CreateNickname'] = request.createNickname;
  }
  if (!Util.isUnset(request.createUserId)) {
    body['CreateUserId'] = request.createUserId;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateClass',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateClass(request: UpdateClassRequest): UpdateClassResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateClassWithOptions(request, runtime);
}

model UpdateConferenceRequest {
  conferenceId?: string(name='ConferenceId'),
  title?: string(name='Title'),
}

model UpdateConferenceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateConferenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateConferenceResponseBody(name='body'),
}

async function updateConferenceWithOptions(request: UpdateConferenceRequest, runtime: Util.RuntimeOptions): UpdateConferenceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.conferenceId)) {
    body['ConferenceId'] = request.conferenceId;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConference',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateConference(request: UpdateConferenceRequest): UpdateConferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConferenceWithOptions(request, runtime);
}

model UpdateLiveRequest {
  introduction?: string(name='Introduction'),
  liveId?: string(name='LiveId'),
  title?: string(name='Title'),
}

model UpdateLiveResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateLiveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLiveResponseBody(name='body'),
}

async function updateLiveWithOptions(request: UpdateLiveRequest, runtime: Util.RuntimeOptions): UpdateLiveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.introduction)) {
    body['Introduction'] = request.introduction;
  }
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLive',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLive(request: UpdateLiveRequest): UpdateLiveResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLiveWithOptions(request, runtime);
}

model UpdateLiveRoomRequest {
  anchorId?: string(name='AnchorId'),
  anchorNick?: string(name='AnchorNick'),
  appId?: string(name='AppId'),
  coverUrl?: string(name='CoverUrl'),
  extension?: map[string]string(name='Extension'),
  liveId?: string(name='LiveId'),
  notice?: string(name='Notice'),
  title?: string(name='Title'),
  userId?: string(name='UserId'),
}

model UpdateLiveRoomShrinkRequest {
  anchorId?: string(name='AnchorId'),
  anchorNick?: string(name='AnchorNick'),
  appId?: string(name='AppId'),
  coverUrl?: string(name='CoverUrl'),
  extensionShrink?: string(name='Extension'),
  liveId?: string(name='LiveId'),
  notice?: string(name='Notice'),
  title?: string(name='Title'),
  userId?: string(name='UserId'),
}

model UpdateLiveRoomResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateLiveRoomResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLiveRoomResponseBody(name='body'),
}

async function updateLiveRoomWithOptions(tmpReq: UpdateLiveRoomRequest, runtime: Util.RuntimeOptions): UpdateLiveRoomResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateLiveRoomShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.extension)) {
    request.extensionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extension, 'Extension', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.anchorId)) {
    body['AnchorId'] = request.anchorId;
  }
  if (!Util.isUnset(request.anchorNick)) {
    body['AnchorNick'] = request.anchorNick;
  }
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.coverUrl)) {
    body['CoverUrl'] = request.coverUrl;
  }
  if (!Util.isUnset(request.extensionShrink)) {
    body['Extension'] = request.extensionShrink;
  }
  if (!Util.isUnset(request.liveId)) {
    body['LiveId'] = request.liveId;
  }
  if (!Util.isUnset(request.notice)) {
    body['Notice'] = request.notice;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLiveRoom',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLiveRoom(request: UpdateLiveRoomRequest): UpdateLiveRoomResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLiveRoomWithOptions(request, runtime);
}

model UpdateRoomRequest {
  appId?: string(name='AppId'),
  extension?: map[string]string(name='Extension'),
  notice?: string(name='Notice'),
  roomId?: string(name='RoomId'),
  roomOwnerId?: string(name='RoomOwnerId'),
  title?: string(name='Title'),
}

model UpdateRoomShrinkRequest {
  appId?: string(name='AppId'),
  extensionShrink?: string(name='Extension'),
  notice?: string(name='Notice'),
  roomId?: string(name='RoomId'),
  roomOwnerId?: string(name='RoomOwnerId'),
  title?: string(name='Title'),
}

model UpdateRoomResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateRoomResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRoomResponseBody(name='body'),
}

async function updateRoomWithOptions(tmpReq: UpdateRoomRequest, runtime: Util.RuntimeOptions): UpdateRoomResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateRoomShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.extension)) {
    request.extensionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extension, 'Extension', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.extensionShrink)) {
    body['Extension'] = request.extensionShrink;
  }
  if (!Util.isUnset(request.notice)) {
    body['Notice'] = request.notice;
  }
  if (!Util.isUnset(request.roomId)) {
    body['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.roomOwnerId)) {
    body['RoomOwnerId'] = request.roomOwnerId;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRoom',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRoom(request: UpdateRoomRequest): UpdateRoomResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRoomWithOptions(request, runtime);
}

model UpdateShareScreenLayoutRequest {
  appId?: string(name='AppId'),
  classId?: string(name='ClassId'),
  enableOverlay?: boolean(name='EnableOverlay'),
  overlayHeight?: float(name='OverlayHeight'),
  overlayWidth?: float(name='OverlayWidth'),
  overlayX?: float(name='OverlayX'),
  overlayY?: float(name='OverlayY'),
}

model UpdateShareScreenLayoutResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateShareScreenLayoutResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateShareScreenLayoutResponseBody(name='body'),
}

async function updateShareScreenLayoutWithOptions(request: UpdateShareScreenLayoutRequest, runtime: Util.RuntimeOptions): UpdateShareScreenLayoutResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.classId)) {
    body['ClassId'] = request.classId;
  }
  if (!Util.isUnset(request.enableOverlay)) {
    body['EnableOverlay'] = request.enableOverlay;
  }
  if (!Util.isUnset(request.overlayHeight)) {
    body['OverlayHeight'] = request.overlayHeight;
  }
  if (!Util.isUnset(request.overlayWidth)) {
    body['OverlayWidth'] = request.overlayWidth;
  }
  if (!Util.isUnset(request.overlayX)) {
    body['OverlayX'] = request.overlayX;
  }
  if (!Util.isUnset(request.overlayY)) {
    body['OverlayY'] = request.overlayY;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateShareScreenLayout',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateShareScreenLayout(request: UpdateShareScreenLayoutRequest): UpdateShareScreenLayoutResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateShareScreenLayoutWithOptions(request, runtime);
}

model VerifyDomainOwnerRequest {
  liveDomainName?: string(name='LiveDomainName'),
}

model VerifyDomainOwnerResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model VerifyDomainOwnerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyDomainOwnerResponseBody(name='body'),
}

async function verifyDomainOwnerWithOptions(request: VerifyDomainOwnerRequest, runtime: Util.RuntimeOptions): VerifyDomainOwnerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.liveDomainName)) {
    body['LiveDomainName'] = request.liveDomainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'VerifyDomainOwner',
    version = '2021-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyDomainOwner(request: VerifyDomainOwnerRequest): VerifyDomainOwnerResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyDomainOwnerWithOptions(request, runtime);
}

