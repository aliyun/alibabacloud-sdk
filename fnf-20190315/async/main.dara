/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'fnf';
  @version = '2019-03-15';
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'cn-beijing.fnf.aliyuncs.com',
    cn-hangzhou = 'cn-hangzhou.fnf.aliyuncs.com',
    cn-shanghai = 'cn-shanghai.fnf.aliyuncs.com',
    cn-shenzhen = 'cn-shenzhen.fnf.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model CreateFlowRequest {
  definition: string(name='Definition', position='Body'),
  description: string(name='Description', position='Body'),
  externalStorageLocation?: string(name='ExternalStorageLocation', position='Body'),
  name: string(name='Name', position='Body'),
  requestId?: string(name='RequestId', position='Query'),
  roleArn?: string(name='RoleArn', position='Body'),
  type: string(name='Type', position='Body'),
}

model CreateFlowResponseBody = {
  createdTime?: string(name='CreatedTime'),
  definition?: string(name='Definition'),
  description?: string(name='Description'),
  externalStorageLocation?: string(name='ExternalStorageLocation'),
  id?: string(name='Id'),
  lastModifiedTime?: string(name='LastModifiedTime'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  roleArn?: string(name='RoleArn'),
  type?: string(name='Type'),
}

model CreateFlowResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowResponseBody(name='body'),
}

async function createFlow(request: CreateFlowRequest): CreateFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFlow', 'POST', '/', 'json', true, 'form', request);
}

model CreateScheduleRequest {
  cronExpression: string(name='CronExpression', position='Body'),
  description?: string(name='Description', position='Body'),
  enable?: boolean(name='Enable', position='Body'),
  flowName: string(name='FlowName', position='Body'),
  payload?: string(name='Payload', position='Body'),
  requestId?: string(name='RequestId', position='Query'),
  scheduleName: string(name='ScheduleName', position='Body'),
}

model CreateScheduleResponseBody = {
  createdTime?: string(name='CreatedTime'),
  cronExpression?: string(name='CronExpression'),
  description?: string(name='Description'),
  enable?: boolean(name='Enable'),
  lastModifiedTime?: string(name='LastModifiedTime'),
  payload?: string(name='Payload'),
  requestId?: string(name='RequestId'),
  scheduleId?: string(name='ScheduleId'),
  scheduleName?: string(name='ScheduleName'),
}

model CreateScheduleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateScheduleResponseBody(name='body'),
}

async function createSchedule(request: CreateScheduleRequest): CreateScheduleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSchedule', 'POST', '/', 'json', true, 'form', request);
}

model DeleteFlowRequest {
  name: string(name='Name', position='Query'),
  requestId?: string(name='RequestId', position='Query'),
}

model DeleteFlowResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFlowResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowResponseBody(name='body'),
}

async function deleteFlow(request: DeleteFlowRequest): DeleteFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFlow', 'GET', '/', 'json', false, 'json', request);
}

model DeleteScheduleRequest {
  flowName: string(name='FlowName', position='Query'),
  requestId?: string(name='RequestId', position='Query'),
  scheduleName: string(name='ScheduleName', position='Query'),
}

model DeleteScheduleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteScheduleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteScheduleResponseBody(name='body'),
}

async function deleteSchedule(request: DeleteScheduleRequest): DeleteScheduleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSchedule', 'GET', '/', 'json', false, 'json', request);
}

model DescribeExecutionRequest {
  executionName: string(name='ExecutionName', position='Query'),
  flowName: string(name='FlowName', position='Query'),
  requestId?: string(name='RequestId', position='Query'),
  waitTimeSeconds?: int32(name='WaitTimeSeconds', position='Query'),
}

model DescribeExecutionResponseBody = {
  externalInputUri?: string(name='ExternalInputUri'),
  externalOutputUri?: string(name='ExternalOutputUri'),
  flowDefinition?: string(name='FlowDefinition'),
  flowName?: string(name='FlowName'),
  input?: string(name='Input'),
  name?: string(name='Name'),
  output?: string(name='Output'),
  requestId?: string(name='RequestId'),
  startedTime?: string(name='StartedTime'),
  status?: string(name='Status'),
  stoppedTime?: string(name='StoppedTime'),
}

model DescribeExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeExecutionResponseBody(name='body'),
}

async function describeExecution(request: DescribeExecutionRequest): DescribeExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeExecution', 'GET', '/', 'json', false, 'json', request);
}

model DescribeFlowRequest {
  name: string(name='Name', position='Query'),
  requestId?: string(name='RequestId', position='Query'),
}

model DescribeFlowResponseBody = {
  createdTime?: string(name='CreatedTime'),
  definition?: string(name='Definition'),
  description?: string(name='Description'),
  externalStorageLocation?: string(name='ExternalStorageLocation'),
  id?: string(name='Id'),
  lastModifiedTime?: string(name='LastModifiedTime'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  roleArn?: string(name='RoleArn'),
  type?: string(name='Type'),
}

model DescribeFlowResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowResponseBody(name='body'),
}

async function describeFlow(request: DescribeFlowRequest): DescribeFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFlow', 'GET', '/', 'json', false, 'json', request);
}

model DescribeScheduleRequest {
  flowName: string(name='FlowName', position='Query'),
  requestId?: string(name='RequestId', position='Query'),
  scheduleName: string(name='ScheduleName', position='Query'),
}

model DescribeScheduleResponseBody = {
  createdTime?: string(name='CreatedTime'),
  cronExpression?: string(name='CronExpression'),
  description?: string(name='Description'),
  enable?: boolean(name='Enable'),
  lastModifiedTime?: string(name='LastModifiedTime'),
  payload?: string(name='Payload'),
  requestId?: string(name='RequestId'),
  scheduleId?: string(name='ScheduleId'),
  scheduleName?: string(name='ScheduleName'),
}

model DescribeScheduleResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeScheduleResponseBody(name='body'),
}

async function describeSchedule(request: DescribeScheduleRequest): DescribeScheduleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSchedule', 'GET', '/', 'json', false, 'json', request);
}

model GetExecutionHistoryRequest {
  executionName: string(name='ExecutionName', position='Query'),
  flowName: string(name='FlowName', position='Query'),
  limit?: int32(name='Limit', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  requestId?: string(name='RequestId', position='Query'),
}

model GetExecutionHistoryResponseBody = {
  events?: [ 
    {
      eventDetail?: string(name='EventDetail'),
      eventId?: long(name='EventId'),
      scheduleEventId?: long(name='ScheduleEventId'),
      stepName?: string(name='StepName'),
      time?: string(name='Time'),
      type?: string(name='Type'),
    }
  ](name='Events'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model GetExecutionHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: GetExecutionHistoryResponseBody(name='body'),
}

async function getExecutionHistory(request: GetExecutionHistoryRequest): GetExecutionHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetExecutionHistory', 'GET', '/', 'json', false, 'json', request);
}

model ListExecutionsRequest {
  executionNamePrefix?: string(name='ExecutionNamePrefix', position='Query'),
  flowName: string(name='FlowName', position='Query'),
  limit?: int32(name='Limit', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  requestId?: string(name='RequestId', position='Query'),
  startedTimeBegin?: string(name='StartedTimeBegin', position='Query'),
  startedTimeEnd?: string(name='StartedTimeEnd', position='Query'),
  status?: string(name='Status', position='Query'),
}

model ListExecutionsResponseBody = {
  executions?: [ 
    {
      externalInputUri?: string(name='ExternalInputUri'),
      externalOutputUri?: string(name='ExternalOutputUri'),
      flowDefinition?: string(name='FlowDefinition'),
      flowName?: string(name='FlowName'),
      input?: string(name='Input'),
      name?: string(name='Name'),
      output?: string(name='Output'),
      startedTime?: string(name='StartedTime'),
      status?: string(name='Status'),
      stoppedTime?: string(name='StoppedTime'),
    }
  ](name='Executions'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListExecutionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListExecutionsResponseBody(name='body'),
}

async function listExecutions(request: ListExecutionsRequest): ListExecutionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListExecutions', 'GET', '/', 'json', false, 'json', request);
}

model ListFlowsRequest {
  limit?: int32(name='Limit', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  requestId?: string(name='RequestId', position='Query'),
}

model ListFlowsResponseBody = {
  flows?: [ 
    {
      createdTime?: string(name='CreatedTime'),
      definition?: string(name='Definition'),
      description?: string(name='Description'),
      externalStorageLocation?: string(name='ExternalStorageLocation'),
      id?: string(name='Id'),
      lastModifiedTime?: string(name='LastModifiedTime'),
      name?: string(name='Name'),
      roleArn?: string(name='RoleArn'),
      type?: string(name='Type'),
    }
  ](name='Flows'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListFlowsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowsResponseBody(name='body'),
}

async function listFlows(request: ListFlowsRequest): ListFlowsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlows', 'GET', '/', 'json', false, 'json', request);
}

model ListSchedulesRequest {
  flowName: string(name='FlowName', position='Query'),
  limit?: int32(name='Limit', minimum=1, maximum=1000, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  requestId?: string(name='RequestId', position='Query'),
}

model ListSchedulesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  schedules?: [ 
    {
      createdTime?: string(name='CreatedTime'),
      cronExpression?: string(name='CronExpression'),
      description?: string(name='Description'),
      enable?: boolean(name='Enable'),
      lastModifiedTime?: string(name='LastModifiedTime'),
      payload?: string(name='Payload'),
      scheduleId?: string(name='ScheduleId'),
      scheduleName?: string(name='ScheduleName'),
    }
  ](name='Schedules'),
}

model ListSchedulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListSchedulesResponseBody(name='body'),
}

async function listSchedules(request: ListSchedulesRequest): ListSchedulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSchedules', 'GET', '/', 'json', false, 'json', request);
}

model ReportTaskFailedRequest {
  cause?: string(name='Cause', position='Body'),
  error: string(name='Error', position='Body'),
  requestId?: string(name='RequestId', position='Query'),
  taskToken: string(name='TaskToken', position='Query'),
}

model ReportTaskFailedResponseBody = {
  eventId?: long(name='EventId'),
  requestId?: string(name='RequestId'),
}

model ReportTaskFailedResponse = {
  headers: map[string]string(name='headers'),
  body: ReportTaskFailedResponseBody(name='body'),
}

async function reportTaskFailed(request: ReportTaskFailedRequest): ReportTaskFailedResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReportTaskFailed', 'POST', '/', 'json', true, 'form', request);
}

model ReportTaskSucceededRequest {
  output: string(name='Output', position='Body'),
  requestId?: string(name='RequestId', position='Query'),
  taskToken: string(name='TaskToken', position='Query'),
}

model ReportTaskSucceededResponseBody = {
  eventId?: long(name='EventId'),
  requestId?: string(name='RequestId'),
}

model ReportTaskSucceededResponse = {
  headers: map[string]string(name='headers'),
  body: ReportTaskSucceededResponseBody(name='body'),
}

async function reportTaskSucceeded(request: ReportTaskSucceededRequest): ReportTaskSucceededResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReportTaskSucceeded', 'POST', '/', 'json', true, 'form', request);
}

model StartExecutionRequest {
  callbackFnFTaskToken?: string(name='CallbackFnFTaskToken', position='Body'),
  executionName?: string(name='ExecutionName', position='Body'),
  flowName: string(name='FlowName', position='Body'),
  input?: string(name='Input', position='Body'),
  requestId?: string(name='RequestId', position='Query'),
}

model StartExecutionResponseBody = {
  externalInputUri?: string(name='ExternalInputUri'),
  externalOutputUri?: string(name='ExternalOutputUri'),
  flowDefinition?: string(name='FlowDefinition'),
  flowName?: string(name='FlowName'),
  input?: string(name='Input'),
  name?: string(name='Name'),
  output?: string(name='Output'),
  requestId?: string(name='RequestId'),
  startedTime?: string(name='StartedTime'),
  status?: string(name='Status'),
  stoppedTime?: string(name='StoppedTime'),
}

model StartExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: StartExecutionResponseBody(name='body'),
}

async function startExecution(request: StartExecutionRequest): StartExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartExecution', 'POST', '/', 'json', true, 'form', request);
}

model StopExecutionRequest {
  cause?: string(name='Cause', position='Body'),
  error?: string(name='Error', position='Body'),
  executionName: string(name='ExecutionName', position='Body'),
  flowName: string(name='FlowName', position='Body'),
  requestId?: string(name='RequestId', position='Query'),
}

model StopExecutionResponseBody = {
  externalInputUri?: string(name='ExternalInputUri'),
  externalOutputUri?: string(name='ExternalOutputUri'),
  flowDefinition?: string(name='FlowDefinition'),
  flowName?: string(name='FlowName'),
  input?: string(name='Input'),
  name?: string(name='Name'),
  output?: string(name='Output'),
  requestId?: string(name='RequestId'),
  startedTime?: string(name='StartedTime'),
  status?: string(name='Status'),
  stoppedTime?: string(name='StoppedTime'),
}

model StopExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: StopExecutionResponseBody(name='body'),
}

async function stopExecution(request: StopExecutionRequest): StopExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopExecution', 'POST', '/', 'json', true, 'form', request);
}

model UpdateFlowRequest {
  definition?: string(name='Definition', position='Body'),
  description?: string(name='Description', position='Body'),
  externalStorageLocation?: string(name='ExternalStorageLocation', position='Body'),
  name: string(name='Name', position='Body'),
  requestId?: string(name='RequestId', position='Query'),
  roleArn?: string(name='RoleArn', position='Body'),
  type?: string(name='Type', position='Body'),
}

model UpdateFlowResponseBody = {
  createdTime?: string(name='CreatedTime'),
  definition?: string(name='Definition'),
  description?: string(name='Description'),
  externalStorageLocation?: string(name='ExternalStorageLocation'),
  id?: string(name='Id'),
  lastModifiedTime?: string(name='LastModifiedTime'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  roleArn?: string(name='RoleArn'),
  type?: string(name='Type'),
}

model UpdateFlowResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFlowResponseBody(name='body'),
}

async function updateFlow(request: UpdateFlowRequest): UpdateFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateFlow', 'POST', '/', 'json', true, 'form', request);
}

model UpdateScheduleRequest {
  cronExpression?: string(name='CronExpression', position='Body'),
  description?: string(name='Description', position='Body'),
  enable?: boolean(name='Enable', position='Body'),
  flowName: string(name='FlowName', position='Body'),
  payload?: string(name='Payload', position='Body'),
  requestId?: string(name='RequestId', position='Query'),
  scheduleName: string(name='ScheduleName', position='Body'),
}

model UpdateScheduleResponseBody = {
  createdTime?: string(name='CreatedTime'),
  cronExpression?: string(name='CronExpression'),
  description?: string(name='Description'),
  enable?: boolean(name='Enable'),
  lastModifiedTime?: string(name='LastModifiedTime'),
  payload?: string(name='Payload'),
  requestId?: string(name='RequestId'),
  scheduleId?: string(name='ScheduleId'),
  scheduleName?: string(name='ScheduleName'),
}

model UpdateScheduleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateScheduleResponseBody(name='body'),
}

async function updateSchedule(request: UpdateScheduleRequest): UpdateScheduleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSchedule', 'POST', '/', 'json', true, 'form', request);
}

