/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'regional';
  @endpointMap = {
    'cn-beijing' = 'cn-beijing.fnf.aliyuncs.com',
    'cn-hangzhou' = 'cn-hangzhou.fnf.aliyuncs.com',
    'cn-shanghai' = 'cn-shanghai.fnf.aliyuncs.com',
    'cn-shenzhen' = 'cn-shenzhen.fnf.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('fnf', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateFlowRequest {
  definition?: string(name='Definition', description='The definition of the workflow. The definition must comply with the flow definition language (FDL) syntax. Considering compatibility, the system supports two flow definition specifications.

>  In the preceding flow definition example, Name:my_flow_name is the workflow name, which must be consistent with the input parameter Name

This parameter is required.', example='version:&nbsp;v1.0<br/>type:&nbsp;flow<br/>steps:<br/>&nbsp;-&nbsp;type:&nbsp;pass<br/>&nbsp;name:&nbsp;mypass'),
  description?: string(name='Description', description='The description of the flow.

This parameter is required.', example='test flow'),
  environment?: {
    variables?: [ 
      {
        description?: string(name='Description', example='description'),
        name?: string(name='Name', example='key'),
        value?: string(name='Value', example='value'),
      }
    ](name='Variables'),
  }(name='Environment'),
  executionMode?: string(name='ExecutionMode', description='The execution mode. Valid values: Express and Standard. Considering compatibility, an empty string is equivalent to the Standard execution mode.', example='Standard'),
  externalStorageLocation?: string(name='ExternalStorageLocation', description='The path of the external storage.', example='/path'),
  name?: string(name='Name', description='The name of the flow. The name is unique within the same region and cannot be modified after the flow is created. Set this parameter based on the following rules:

*   The name can contain letters, digits, underscores (_), and hyphens (-).
*   The name must start with a letter or an underscore (_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.

This parameter is required.', example='flow'),
  roleArn?: string(name='RoleArn', description='The Alibaba Cloud resource name (ARN) of the authorized role on which the execution of the flow relies. During the execution of the flow, CloudFlow assumes the role to call API operations of relevant services.', example='acs:ram:${region}:${accountID}:${role}'),
  type?: string(name='Type', description='The type of the flow. Set this parameter to **FDL**.

This parameter is required.', example='FDL'),
}

model CreateFlowShrinkRequest {
  definition?: string(name='Definition', description='The definition of the workflow. The definition must comply with the flow definition language (FDL) syntax. Considering compatibility, the system supports two flow definition specifications.

>  In the preceding flow definition example, Name:my_flow_name is the workflow name, which must be consistent with the input parameter Name

This parameter is required.', example='version:&nbsp;v1.0<br/>type:&nbsp;flow<br/>steps:<br/>&nbsp;-&nbsp;type:&nbsp;pass<br/>&nbsp;name:&nbsp;mypass'),
  description?: string(name='Description', description='The description of the flow.

This parameter is required.', example='test flow'),
  environmentShrink?: string(name='Environment'),
  executionMode?: string(name='ExecutionMode', description='The execution mode. Valid values: Express and Standard. Considering compatibility, an empty string is equivalent to the Standard execution mode.', example='Standard'),
  externalStorageLocation?: string(name='ExternalStorageLocation', description='The path of the external storage.', example='/path'),
  name?: string(name='Name', description='The name of the flow. The name is unique within the same region and cannot be modified after the flow is created. Set this parameter based on the following rules:

*   The name can contain letters, digits, underscores (_), and hyphens (-).
*   The name must start with a letter or an underscore (_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.

This parameter is required.', example='flow'),
  roleArn?: string(name='RoleArn', description='The Alibaba Cloud resource name (ARN) of the authorized role on which the execution of the flow relies. During the execution of the flow, CloudFlow assumes the role to call API operations of relevant services.', example='acs:ram:${region}:${accountID}:${role}'),
  type?: string(name='Type', description='The type of the flow. Set this parameter to **FDL**.

This parameter is required.', example='FDL'),
}

model CreateFlowResponseBody = {
  createdTime?: string(name='CreatedTime', description='The time when the flow was created.', example='2019-01-01T01:01:01.001Z'),
  definition?: string(name='Definition', description='Considering compatibility, the system supports two flow definition specifications.', example='version: v1.0\\\\ntype: flow\\\\nname: test\\\\nsteps:\\\\n - type: pass\\\\n name: mypass'),
  description?: string(name='Description', description='The description of the flow.', example='test flow'),
  environment?: {
    variables?: [ 
      {
        description?: string(name='Description', example='description'),
        name?: string(name='Name', example='key'),
        value?: string(name='Value', example='value'),
      }
    ](name='Variables'),
  }(name='Environment'),
  executionMode?: string(name='ExecutionMode', description='The execution mode. Valid values: Express and Standard. Considering compatibility, an empty string is equivalent to the Standard execution mode.', example='Standard'),
  id?: string(name='Id', description='The unique ID of the flow.', example='e589e092-e2c0-4dee-b306-3574ddfdddf5****'),
  lastModifiedTime?: string(name='LastModifiedTime', description='The time when the flow was last modified.', example='2019-01-01T01:01:01.001Z'),
  name?: string(name='Name', description='The name of the flow.', example='flow'),
  requestId?: string(name='RequestId', description='The request ID. Each time an `HTTP status code` is returned, Serverless Workflow returns a value for the parameter.', example='testRequestID'),
  roleArn?: string(name='RoleArn', description='The Alibaba Cloud resource name (ARN) of the authorized role on which the execution of the flow relies. During the execution of the flow, CloudFlow assumes the role to call API operations of relevant services.', example='acs:ram:${region}:${accountID}:${role}'),
  type?: string(name='Type', description='The type of the flow.

Valid value:

*   FDL

    <!-- -->

    <!-- -->

    <!-- -->', example='FDL'),
}

model CreateFlowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFlowResponseBody(name='body'),
}

/**
 * @summary Creates a flow.
 *
 * @description ## [](#)Usage notes
 * *   The number of flows that each user can create is restricted by resources. For more information, see [Limits](https://help.aliyun.com/document_detail/122093.html). If you want to create more flows, submit a ticket.
 * *   At the user level, flows are distinguished by name. The name of a flow within one account must be unique.
 *
 * @param tmpReq CreateFlowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFlowResponse
 */
async function createFlowWithOptions(tmpReq: CreateFlowRequest, runtime: Util.RuntimeOptions): CreateFlowResponse {
  Util.validateModel(tmpReq);
  var request = new CreateFlowShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.environment)) {
    request.environmentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.environment, 'Environment', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.definition)) {
    body['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.environmentShrink)) {
    body['Environment'] = request.environmentShrink;
  }
  if (!Util.isUnset(request.executionMode)) {
    body['ExecutionMode'] = request.executionMode;
  }
  if (!Util.isUnset(request.externalStorageLocation)) {
    body['ExternalStorageLocation'] = request.externalStorageLocation;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.roleArn)) {
    body['RoleArn'] = request.roleArn;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlow',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a flow.
 *
 * @description ## [](#)Usage notes
 * *   The number of flows that each user can create is restricted by resources. For more information, see [Limits](https://help.aliyun.com/document_detail/122093.html). If you want to create more flows, submit a ticket.
 * *   At the user level, flows are distinguished by name. The name of a flow within one account must be unique.
 *
 * @param request CreateFlowRequest
 * @return CreateFlowResponse
 */
async function createFlow(request: CreateFlowRequest): CreateFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowWithOptions(request, runtime);
}

model CreateFlowAliasRequest {
  description?: string(name='Description', example='example description'),
  flowName?: string(name='FlowName', description='This parameter is required.', example='example-flow-name'),
  name?: string(name='Name', description='This parameter is required.', example='example-alias-name'),
  routingConfigurations?: [ 
    {
      version?: string(name='Version', description='This parameter is required.', example='1'),
      weight?: int32(name='Weight', description='This parameter is required.', example='30'),
    }
  ](name='RoutingConfigurations', description='This parameter is required.'),
}

model CreateFlowAliasShrinkRequest {
  description?: string(name='Description', example='example description'),
  flowName?: string(name='FlowName', description='This parameter is required.', example='example-flow-name'),
  name?: string(name='Name', description='This parameter is required.', example='example-alias-name'),
  routingConfigurationsShrink?: string(name='RoutingConfigurations', description='This parameter is required.'),
}

model CreateFlowAliasResponseBody = {
  createdTime?: string(name='CreatedTime', example='2020-01-01T01:01:01.001Z'),
  description?: string(name='Description', example='example description'),
  flowName?: string(name='FlowName', example='example-flow-name'),
  name?: string(name='Name', example='exampe-alias-name'),
  requestId?: string(name='RequestId', description='Id of the request', example='testRequestID'),
  routingConfigurations?: [ 
    {
      version?: string(name='Version', example='1'),
      weight?: int32(name='Weight', example='30'),
    }
  ](name='RoutingConfigurations'),
}

model CreateFlowAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFlowAliasResponseBody(name='body'),
}

/**
 * @summary 创建流程版本别名
 *
 * @param tmpReq CreateFlowAliasRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFlowAliasResponse
 */
async function createFlowAliasWithOptions(tmpReq: CreateFlowAliasRequest, runtime: Util.RuntimeOptions): CreateFlowAliasResponse {
  Util.validateModel(tmpReq);
  var request = new CreateFlowAliasShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.routingConfigurations)) {
    request.routingConfigurationsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.routingConfigurations, 'RoutingConfigurations', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.routingConfigurationsShrink)) {
    body['RoutingConfigurations'] = request.routingConfigurationsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlowAlias',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建流程版本别名
 *
 * @param request CreateFlowAliasRequest
 * @return CreateFlowAliasResponse
 */
async function createFlowAlias(request: CreateFlowAliasRequest): CreateFlowAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowAliasWithOptions(request, runtime);
}

model CreateScheduleRequest {
  cronExpression?: string(name='CronExpression', description='The CRON expression.

This parameter is required.', example='0 * * * * *'),
  description?: string(name='Description', description='The description of the time-based schedule.', example='test description'),
  enable?: boolean(name='Enable', description='Specifies whether to enable the time-based schedule. Valid values:

*   **true**
*   **false**', example='true'),
  flowName?: string(name='FlowName', description='The name of the workflow that is associated with the time-based schedule.

This parameter is required.', example='flow'),
  payload?: string(name='Payload', description='The trigger message of the time-based schedule. Specify the value in the JSON format.', example='{"key": "value"}'),
  scheduleName?: string(name='ScheduleName', description='The name of the time-based schedule. The name must meet the following conventions:

*   The name can contain letters, digits, underscores (_), and hyphens (-).
*   The name must start with a letter or an underscore (_).
*   It is case-sensitive.
*   The name must be 1 to 128 characters in length.

This parameter is required.', example='testScheduleName'),
  signatureVersion?: string(name='SignatureVersion'),
}

model CreateScheduleResponseBody = {
  createdTime?: string(name='CreatedTime', description='The time when the time-based schedule was created.', example='2020-01-01T01:01:01.001Z'),
  cronExpression?: string(name='CronExpression', description='The CRON expression.', example='0 * * * * *'),
  description?: string(name='Description', description='The description of the time-based schedule.', example='test description'),
  enable?: boolean(name='Enable', description='Indicates whether the time-based schedule is enabled.', example='true'),
  lastModifiedTime?: string(name='LastModifiedTime', description='The time when the time-based schedule was last modified.', example='2020-01-01T01:01:01.001Z'),
  payload?: string(name='Payload', description='The trigger message of the time-based schedule.', example='{"key": "value"}'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
  scheduleId?: string(name='ScheduleId', description='The ID of the time-based schedule.', example='testScheduleId'),
  scheduleName?: string(name='ScheduleName', description='The name of the time-based schedule.', example='testScheduleName'),
}

model CreateScheduleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateScheduleResponseBody(name='body'),
}

/**
 * @summary Creates a time-based schedule.
 *
 * @param request CreateScheduleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateScheduleResponse
 */
async function createScheduleWithOptions(request: CreateScheduleRequest, runtime: Util.RuntimeOptions): CreateScheduleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.signatureVersion)) {
    query['SignatureVersion'] = request.signatureVersion;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.cronExpression)) {
    body['CronExpression'] = request.cronExpression;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.enable)) {
    body['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.payload)) {
    body['Payload'] = request.payload;
  }
  if (!Util.isUnset(request.scheduleName)) {
    body['ScheduleName'] = request.scheduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSchedule',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a time-based schedule.
 *
 * @param request CreateScheduleRequest
 * @return CreateScheduleResponse
 */
async function createSchedule(request: CreateScheduleRequest): CreateScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createScheduleWithOptions(request, runtime);
}

model DeleteFlowRequest {
  name?: string(name='Name', description='This parameter is required.'),
}

model DeleteFlowResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
}

model DeleteFlowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFlowResponseBody(name='body'),
}

/**
 * @summary Deletes an existing flow.
 *
 * @description ## [](#)Usage notes
 * A delete operation is asynchronous. If this operation is successful, the system returns a successful response. If an existing flow is pending to be deleted, a new flow of the same name will not be affected by the existing one. After you delete a flow, you cannot query its historical executions. All executions in progress will stop after their most recent steps are complete.
 *
 * @param request DeleteFlowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFlowResponse
 */
async function deleteFlowWithOptions(request: DeleteFlowRequest, runtime: Util.RuntimeOptions): DeleteFlowResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlow',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an existing flow.
 *
 * @description ## [](#)Usage notes
 * A delete operation is asynchronous. If this operation is successful, the system returns a successful response. If an existing flow is pending to be deleted, a new flow of the same name will not be affected by the existing one. After you delete a flow, you cannot query its historical executions. All executions in progress will stop after their most recent steps are complete.
 *
 * @param request DeleteFlowRequest
 * @return DeleteFlowResponse
 */
async function deleteFlow(request: DeleteFlowRequest): DeleteFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowWithOptions(request, runtime);
}

model DeleteFlowAliasRequest {
  flowName?: string(name='FlowName', description='This parameter is required.', example='my_flow_name'),
  name?: string(name='Name', description='This parameter is required.', example='alias_name'),
}

model DeleteFlowAliasResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='3A44E113-9962-5B0B-AB92-14060EFE3164'),
}

model DeleteFlowAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFlowAliasResponseBody(name='body'),
}

/**
 * @summary 删除流程别名
 *
 * @param request DeleteFlowAliasRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFlowAliasResponse
 */
async function deleteFlowAliasWithOptions(request: DeleteFlowAliasRequest, runtime: Util.RuntimeOptions): DeleteFlowAliasResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlowAlias',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除流程别名
 *
 * @param request DeleteFlowAliasRequest
 * @return DeleteFlowAliasResponse
 */
async function deleteFlowAlias(request: DeleteFlowAliasRequest): DeleteFlowAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowAliasWithOptions(request, runtime);
}

model DeleteFlowVersionRequest {
  flowName?: string(name='FlowName', description='This parameter is required.', example='example-flow'),
  flowVersion?: string(name='FlowVersion', description='This parameter is required.', example='1'),
}

model DeleteFlowVersionResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='3A44E113-9962-5B0B-AB92-14060EFE3164'),
}

model DeleteFlowVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFlowVersionResponseBody(name='body'),
}

/**
 * @summary 删除流程版本
 *
 * @param request DeleteFlowVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFlowVersionResponse
 */
async function deleteFlowVersionWithOptions(request: DeleteFlowVersionRequest, runtime: Util.RuntimeOptions): DeleteFlowVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.flowVersion)) {
    body['FlowVersion'] = request.flowVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlowVersion',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除流程版本
 *
 * @param request DeleteFlowVersionRequest
 * @return DeleteFlowVersionResponse
 */
async function deleteFlowVersion(request: DeleteFlowVersionRequest): DeleteFlowVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowVersionWithOptions(request, runtime);
}

model DeleteScheduleRequest {
  flowName?: string(name='FlowName', description='This parameter is required.'),
  scheduleName?: string(name='ScheduleName', description='This parameter is required.'),
}

model DeleteScheduleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
}

model DeleteScheduleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteScheduleResponseBody(name='body'),
}

/**
 * @summary Deletes a time-based scheduling task.
 *
 * @param request DeleteScheduleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteScheduleResponse
 */
async function deleteScheduleWithOptions(request: DeleteScheduleRequest, runtime: Util.RuntimeOptions): DeleteScheduleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.scheduleName)) {
    body['ScheduleName'] = request.scheduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSchedule',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a time-based scheduling task.
 *
 * @param request DeleteScheduleRequest
 * @return DeleteScheduleResponse
 */
async function deleteSchedule(request: DeleteScheduleRequest): DeleteScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteScheduleWithOptions(request, runtime);
}

model DescribeExecutionRequest {
  executionName?: string(name='ExecutionName', description='The name of the execution.

This parameter is required.', example='exec'),
  flowName?: string(name='FlowName', description='The name of the workflow.

This parameter is required.', example='flow'),
  waitTimeSeconds?: int32(name='WaitTimeSeconds', description='The maximum period of time for long polling waits. Valid values: 0 to 60. Unit: seconds. Configure this parameter based on the following rules:

*   If the value is 0, the system immediately returns the current execution status.
*   If the value is greater than 0, the long polling request waits until the execution ends or the specified period elapses.', example='20'),
}

model DescribeExecutionResponseBody = {
  environment?: {
    variables?: [ 
      {
        name?: string(name='Name', example='key'),
        value?: string(name='Value', example='value'),
      }
    ](name='Variables'),
  }(name='Environment'),
  flowDefinition?: string(name='FlowDefinition', description='The definition of the flow.', example='version: v1.0\\\\ntype: flow\\\\nname: test\\\\nsteps:\\\\n - type: pass\\\\n name: mypass'),
  flowName?: string(name='FlowName', description='The name of the flow.', example='flow'),
  input?: string(name='Input', description='The input of the execution, which is in the JSON format.', example='{"key":"value"}'),
  name?: string(name='Name', description='The name of the execution.', example='exec'),
  output?: string(name='Output', description='The execution result, which is in the JSON format.', example='{"key":"value"}'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
  startedTime?: string(name='StartedTime', description='The time when the execution started.', example='2019-01-01T01:01:01.001Z'),
  status?: string(name='Status', description='The execution status. Valid values:

*   **Starting**
*   **Running**
*   **Stopped**
*   **Succeeded**
*   **Failed**
*   **TimedOut**', example='Succeeded'),
  stoppedTime?: string(name='StoppedTime', description='The time when the execution stopped.', example='2019-01-01T01:01:01.001Z'),
}

model DescribeExecutionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeExecutionResponseBody(name='body'),
}

/**
 * @summary Queries an execution in a flow. The long polling mode is supported. The maximum waiting period for long polling depends on the value of the WaitTimeSeconds parameter.
 *
 * @param request DescribeExecutionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExecutionResponse
 */
async function describeExecutionWithOptions(request: DescribeExecutionRequest, runtime: Util.RuntimeOptions): DescribeExecutionResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExecution',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries an execution in a flow. The long polling mode is supported. The maximum waiting period for long polling depends on the value of the WaitTimeSeconds parameter.
 *
 * @param request DescribeExecutionRequest
 * @return DescribeExecutionResponse
 */
async function describeExecution(request: DescribeExecutionRequest): DescribeExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExecutionWithOptions(request, runtime);
}

model DescribeFlowRequest {
  flowVersion?: string(name='FlowVersion', example='1'),
  name?: string(name='Name', description='The name of the flow.

This parameter is required.', example='flow'),
}

model DescribeFlowResponseBody = {
  createdTime?: string(name='CreatedTime', description='The time when the flow was created.', example='2019-01-01T01:01:01.001Z'),
  definition?: string(name='Definition', description='The definition of the workflow. The definition must comply with the flow definition language (FDL) syntax. Considering compatibility, the system supports the flow definition specifications of the old version and new version.', example='version: v1.0\\\\ntype: flow\\\\nname: test\\\\nsteps:\\\\n - type: pass\\\\n name: mypass'),
  description?: string(name='Description', description='The description of the flow.', example='test flow'),
  environment?: {
    variables?: [ 
      {
        description?: string(name='Description', example='description'),
        name?: string(name='Name', example='key'),
        value?: string(name='Value', example='value'),
      }
    ](name='Variables'),
  }(name='Environment'),
  executionMode?: string(name='ExecutionMode', description='The execution mode or the enumeration type. Valid values: Express and Standard. A value of Standard indicates an empty string.', example='Standard'),
  id?: string(name='Id', description='The unique ID of the flow.', example='e589e092-e2c0-4dee-b306-3574ddfdddf5****'),
  lastModifiedTime?: string(name='LastModifiedTime', description='The time when the flow was last modified.', example='2019-01-01T01:01:01.001Z'),
  name?: string(name='Name', description='The name of the flow.', example='flow'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
  roleArn?: string(name='RoleArn', description='The Alibaba Cloud resource name (ARN) of the authorized role on which the execution of the flow relies. During the execution of the flow, CloudFlow assumes the role to call API operations of relevant services.', example='acs:ram::${accountID}:${role}'),
  type?: string(name='Type', description='The type of the workflow.', example='FDL'),
}

model DescribeFlowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFlowResponseBody(name='body'),
}

/**
 * @summary Queries the information about a flow.
 *
 * @param request DescribeFlowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFlowResponse
 */
async function describeFlowWithOptions(request: DescribeFlowRequest, runtime: Util.RuntimeOptions): DescribeFlowResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlow',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about a flow.
 *
 * @param request DescribeFlowRequest
 * @return DescribeFlowResponse
 */
async function describeFlow(request: DescribeFlowRequest): DescribeFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowWithOptions(request, runtime);
}

model DescribeFlowAliasRequest {
  flowName?: string(name='FlowName', description='This parameter is required.', example='example-flow-name'),
  name?: string(name='Name', description='This parameter is required.', example='example-alias-name'),
}

model DescribeFlowAliasResponseBody = {
  alias?: {
    createdTime?: string(name='CreatedTime', example='2024-04-22T06:09:39.907Z'),
    description?: string(name='Description', example='alias description'),
    name?: string(name='Name', example='alias-name'),
    routingConfigurations?: [ 
      {
        version?: string(name='Version', example='1'),
        weight?: int32(name='Weight', example='10'),
      }
    ](name='RoutingConfigurations'),
  }(name='Alias'),
  requestId?: string(name='RequestId', description='Id of the request', example='294D68C1-5108-5971-853A-1A9CC87B4816'),
}

model DescribeFlowAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFlowAliasResponseBody(name='body'),
}

/**
 * @summary 查询流程版本别名详情
 *
 * @param request DescribeFlowAliasRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFlowAliasResponse
 */
async function describeFlowAliasWithOptions(request: DescribeFlowAliasRequest, runtime: Util.RuntimeOptions): DescribeFlowAliasResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlowAlias',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询流程版本别名详情
 *
 * @param request DescribeFlowAliasRequest
 * @return DescribeFlowAliasResponse
 */
async function describeFlowAlias(request: DescribeFlowAliasRequest): DescribeFlowAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowAliasWithOptions(request, runtime);
}

model DescribeMapRunRequest {
  executionName?: string(name='ExecutionName', description='This parameter is required.', example='my_exec_name'),
  flowName?: string(name='FlowName', description='This parameter is required.', example='my_flow_name'),
  mapRunName?: string(name='MapRunName', description='This parameter is required.', example='c39142f1345b196d678333c41f113200'),
  requestId?: string(name='RequestId', example='3A44E113-9962-5B0B-AB92-14060EFE3164'),
}

model DescribeMapRunResponseBody = {
  concurrency?: long(name='Concurrency', example='1'),
  executionName?: string(name='ExecutionName', example='my_exec_name'),
  itemCounts?: {
    aborted?: long(name='Aborted', example='100'),
    failed?: long(name='Failed', example='100'),
    pending?: long(name='Pending', example='100'),
    running?: long(name='Running', example='100'),
    succeed?: long(name='Succeed', example='100'),
    total?: long(name='Total', example='500'),
  }(name='ItemCounts'),
  mapRunName?: string(name='MapRunName', example='c39142f1345b196d678333c41f113000'),
  requestId?: string(name='RequestId', example='3A44E113-9962-5B0B-AB92-14060EFE3164'),
  startedTime?: string(name='StartedTime', example='2025-10-24T14:11:26+08:00'),
  status?: string(name='Status', example='Succeeded'),
  stoppedTime?: string(name='StoppedTime', example='2025-10-24T14:11:28+08:00'),
  toleratedFailedCount?: long(name='ToleratedFailedCount', example='100'),
  toleratedFailedPercentage?: float(name='ToleratedFailedPercentage', example='20'),
}

model DescribeMapRunResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMapRunResponseBody(name='body'),
}

/**
 * @summary 查询 MapRun 详情
 *
 * @param request DescribeMapRunRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMapRunResponse
 */
async function describeMapRunWithOptions(request: DescribeMapRunRequest, runtime: Util.RuntimeOptions): DescribeMapRunResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMapRun',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询 MapRun 详情
 *
 * @param request DescribeMapRunRequest
 * @return DescribeMapRunResponse
 */
async function describeMapRun(request: DescribeMapRunRequest): DescribeMapRunResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMapRunWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', example='zh-CN'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
      {
        localName?: string(name='LocalName'),
        regionEndpoint?: string(name='RegionEndpoint', example='cn-qingdao.fnf.aliyuncs.com'),
        regionId?: string(name='RegionId', example='cn-qingdao'),
      }
    ](name='Region'),
  }(name='Regions'),
  requestId?: string(name='RequestId', example='0aa3f793-6e5f-8472-c7a2-70d2b84c04ac'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @summary 查询地域信息列表
 *
 * @param request DescribeRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    body['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询地域信息列表
 *
 * @param request DescribeRegionsRequest
 * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeScheduleRequest {
  flowName?: string(name='FlowName', description='The name of the flow that is associated with the time-based schedule. The name must be unique within the region and cannot be modified after the time-based schedule is created. The name must meet the following conventions:

*   The name can contain letters, digits, underscores (_), and hyphens (-).
*   The name must start with a letter or an underscore (_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.

This parameter is required.', example='testFlowName'),
  scheduleName?: string(name='ScheduleName', description='The name of the time-based schedule. The name must meet the following conventions:

*   The name can contain letters, digits, underscores (_), and hyphens (-).
*   The name must start with a letter or an underscore (_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.

This parameter is required.', example='testScheduleName'),
}

model DescribeScheduleResponseBody = {
  createdTime?: string(name='CreatedTime', description='The time when the time-based schedule was created.', example='2020-01-01T01:01:01.001Z'),
  cronExpression?: string(name='CronExpression', description='The CRON expression.', example='0 * * * * *'),
  description?: string(name='Description', description='The description of the time-based schedule.', example='test description'),
  enable?: boolean(name='Enable', description='Indicates whether the time-based schedule is enabled. Valid values:

*   **true**
*   **false**', example='true'),
  lastModifiedTime?: string(name='LastModifiedTime', description='The time when the time-based schedule was last modified.', example='2020-01-01T01:01:01.001Z'),
  payload?: string(name='Payload', description='The trigger message of the time-based schedule.', example='{"key": "value"}'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
  scheduleId?: string(name='ScheduleId', description='The ID of the time-based schedule.', example='testScheduleId'),
  scheduleName?: string(name='ScheduleName', description='The name of the time-based schedule.', example='testScheduleName'),
}

model DescribeScheduleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeScheduleResponseBody(name='body'),
}

/**
 * @summary Queries the detailed information about a time-based schedule.
 *
 * @param request DescribeScheduleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeScheduleResponse
 */
async function describeScheduleWithOptions(request: DescribeScheduleRequest, runtime: Util.RuntimeOptions): DescribeScheduleResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSchedule',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the detailed information about a time-based schedule.
 *
 * @param request DescribeScheduleRequest
 * @return DescribeScheduleResponse
 */
async function describeSchedule(request: DescribeScheduleRequest): DescribeScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScheduleWithOptions(request, runtime);
}

model GetExecutionHistoryRequest {
  executionName?: string(name='ExecutionName', description='The name of the execution.

This parameter is required.', example='exec'),
  flowName?: string(name='FlowName', description='The name of the workflow.

This parameter is required.', example='flow'),
  limit?: int32(name='Limit', description='The number of workflows that you want to query. Valid values: 1-999. Default value: 60.', example='1'),
  nextToken?: string(name='NextToken', description='The name of the event to start the query. You can obtain the value from the response data.', example='flow_xxx'),
}

model GetExecutionHistoryResponseBody = {
  events?: [ 
    {
      eventDetail?: string(name='EventDetail', description='The details about the execution step.', example='{}'),
      eventId?: long(name='EventId', description='The ID of the execution step.', example='2'),
      scheduleEventId?: long(name='ScheduleEventId', description='The ID of the scheduling step.', example='1'),
      stepName?: string(name='StepName', description='The name of the execution step.', example='passStep'),
      time?: string(name='Time', description='The time when the event was updated.', example='2019-01-01T01:01:01.001Z'),
      type?: string(name='Type', description='The type of the execution step. Valid values:

*   **StepEntered**
*   **StepStarted**
*   **StepSucceeded**
*   **StepFailed**
*   **StepExited**
*   **BranchEntered**
*   **BranchExited**
*   **IterationEntered**
*   **IterationExited**
*   **TaskScheduled**
*   **TaskStarted**
*   **TaskSubmitted**
*   **TaskSubmitFailed**
*   **TaskSucceeded**
*   **TaskFailed**
*   **TaskTimedOut**
*   **ExecutionStarted**
*   **ExecutionStopped**
*   **ExecutionSucceeded**
*   **ExecutionFailed**
*   **ExecutionTimedOut**', example='TaskSucceeded'),
    }
  ](name='Events', description='The events.'),
  nextToken?: string(name='NextToken', description='You do not need to specify this parameter for the first request. The returned value of **ScheduleEventId** is used as the token for the next query. No value is returned for the last query.', example='3'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
}

model GetExecutionHistoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetExecutionHistoryResponseBody(name='body'),
}

/**
 * @summary Queries the details about each step in an execution process.
 *
 * @param request GetExecutionHistoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetExecutionHistoryResponse
 */
async function getExecutionHistoryWithOptions(request: GetExecutionHistoryRequest, runtime: Util.RuntimeOptions): GetExecutionHistoryResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExecutionHistory',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details about each step in an execution process.
 *
 * @param request GetExecutionHistoryRequest
 * @return GetExecutionHistoryResponse
 */
async function getExecutionHistory(request: GetExecutionHistoryRequest): GetExecutionHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getExecutionHistoryWithOptions(request, runtime);
}

model ListExecutionsRequest {
  executionNamePrefix?: string(name='ExecutionNamePrefix', description='The name prefix of the execution.', example='run'),
  flowName?: string(name='FlowName', description='The name of the flow. The name must be unique within the region and cannot be modified after the flow is created. The name must meet the following conventions:

*   The name can contain letters, digits, underscores (_), and hyphens (-).
*   The name must start with a letter or an underscore (_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.

This parameter is required.', example='flow'),
  limit?: int32(name='Limit', description='The number of executions that you want to query. Valid values: 1-99. Default value: 60.', example='1'),
  mapRunName?: string(name='MapRunName'),
  metadataOnly?: boolean(name='MetadataOnly'),
  nextToken?: string(name='NextToken', description='The name of the execution to start the query. You can obtain the value from the response data. You do not need to specify this parameter for the first request.', example='flow_xxx'),
  qualifier?: string(name='Qualifier', example='1'),
  startedTimeBegin?: string(name='StartedTimeBegin', description='The beginning of the time range to query executions. Specify the value in the UTC RFC3339 format.', example='2020-12-02T02:39:20.402Z'),
  startedTimeEnd?: string(name='StartedTimeEnd', description='The end of the time range to query executions. Specify the value in the UTC RFC3339 format.', example='2020-12-02T02:23:54.817Z'),
  status?: string(name='Status', description='The status of the execution that you want to filter. Valid values:

*   **Starting**
*   **Running**
*   **Stopped**
*   **Succeeded**
*   **Failed**
*   **TimedOut**', example='Succeeded'),
}

model ListExecutionsResponseBody = {
  executions?: [ 
    {
      environment?: {
        variables?: [ 
          {
            name?: string(name='Name', example='key'),
            value?: string(name='Value', example='value'),
          }
        ](name='Variables'),
      }(name='Environment'),
      flowDefinition?: string(name='FlowDefinition', description='The definition of the flow.', example='version: v1.0\\\\ntype: flow\\\\nname: test\\\\nsteps:\\\\n  - type: pass\\\\n    name: mypass'),
      flowName?: string(name='FlowName', description='The name of the flow.', example='flow'),
      input?: string(name='Input', description='The input of the execution, which is in the JSON format.', example='{"key":"value"}'),
      name?: string(name='Name', description='The name of the execution.', example='exec'),
      output?: string(name='Output', description='The output of the execution, which is in the JSON format', example='{"key":"value"}'),
      startedTime?: string(name='StartedTime', description='The time when the execution started.', example='2019-01-01T01:01:01.001Z'),
      status?: string(name='Status', description='The status of the execution.', example='Succeeded'),
      stoppedTime?: string(name='StoppedTime', description='The time when the execution stopped.', example='2019-01-01T01:01:01.001Z'),
    }
  ](name='Executions', description='The information about executions.'),
  nextToken?: string(name='NextToken', description='The start key for the next query. This parameter is not returned if this is the last query.

>  This parameter may not be displayed in the response because no next page exists.', example='exec2'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
}

model ListExecutionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListExecutionsResponseBody(name='body'),
}

/**
 * @summary Queries all historical executions of a flow.
 *
 * @description ## [](#)Usage notes
 * After you delete a flow, you cannot query its historical executions, even if you create a flow of the same name.
 *
 * @param request ListExecutionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListExecutionsResponse
 */
async function listExecutionsWithOptions(request: ListExecutionsRequest, runtime: Util.RuntimeOptions): ListExecutionsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListExecutions',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all historical executions of a flow.
 *
 * @description ## [](#)Usage notes
 * After you delete a flow, you cannot query its historical executions, even if you create a flow of the same name.
 *
 * @param request ListExecutionsRequest
 * @return ListExecutionsResponse
 */
async function listExecutions(request: ListExecutionsRequest): ListExecutionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExecutionsWithOptions(request, runtime);
}

model ListFlowAliasesRequest {
  flowName?: string(name='FlowName', description='This parameter is required.', example='example-flow-name'),
  limit?: int32(name='Limit', example='10'),
  nextToken?: string(name='NextToken', description='list token', example='token'),
}

model ListFlowAliasesResponseBody = {
  aliases?: [ 
    {
      createdTime?: string(name='CreatedTime', example='2025-10-24T14:11:26+08:00'),
      description?: string(name='Description', example='my alias description'),
      name?: string(name='Name', example='my-alias-name'),
      routingConfigurations?: [ 
        {
          version?: string(name='Version', example='1'),
          weight?: string(name='Weight', example='20'),
        }
      ](name='RoutingConfigurations'),
    }
  ](name='Aliases'),
  nextToken?: string(name='NextToken', description='list token', example='testNextToken'),
  requestId?: string(name='RequestId', description='Id of the request', example='3A44E113-9962-5B0B-AB92-14060EFE3164'),
}

model ListFlowAliasesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFlowAliasesResponseBody(name='body'),
}

/**
 * @summary 查询流程版本别名列表
 *
 * @param request ListFlowAliasesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFlowAliasesResponse
 */
async function listFlowAliasesWithOptions(request: ListFlowAliasesRequest, runtime: Util.RuntimeOptions): ListFlowAliasesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowAliases',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询流程版本别名列表
 *
 * @param request ListFlowAliasesRequest
 * @return ListFlowAliasesResponse
 */
async function listFlowAliases(request: ListFlowAliasesRequest): ListFlowAliasesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowAliasesWithOptions(request, runtime);
}

model ListFlowVersionsRequest {
  flowName?: string(name='FlowName', description='This parameter is required.', example='example-flow-name'),
  limit?: string(name='Limit', example='10'),
  nextToken?: string(name='NextToken', description='list token', example='token'),
}

model ListFlowVersionsResponseBody = {
  flowVersions?: [ 
    {
      createdTime?: string(name='CreatedTime', example='2025-10-24T14:11:26+08:00'),
      description?: string(name='Description', example='version description'),
      version?: string(name='Version', example='1'),
    }
  ](name='FlowVersions'),
  nextToken?: string(name='NextToken', description='list token', example='token'),
  requestId?: string(name='RequestId', description='Id of the request', example='294D68C1-5108-5971-853A-1A9CC87B4816'),
}

model ListFlowVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFlowVersionsResponseBody(name='body'),
}

/**
 * @summary 查询流程版本列表
 *
 * @param request ListFlowVersionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFlowVersionsResponse
 */
async function listFlowVersionsWithOptions(request: ListFlowVersionsRequest, runtime: Util.RuntimeOptions): ListFlowVersionsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowVersions',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询流程版本列表
 *
 * @param request ListFlowVersionsRequest
 * @return ListFlowVersionsResponse
 */
async function listFlowVersions(request: ListFlowVersionsRequest): ListFlowVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowVersionsWithOptions(request, runtime);
}

model ListFlowsRequest {
  limit?: int32(name='Limit', description='The number of workflows that you want to query. Valid values: 1 - 999. Default value: 60.', example='1'),
  nextToken?: string(name='NextToken', description='The token to start the query.', example='flow_nextxxx'),
}

model ListFlowsResponseBody = {
  flows?: [ 
    {
      createdTime?: string(name='CreatedTime', description='The time when the flow was created.', example='2019-01-01T01:01:01.001Z'),
      definition?: string(name='Definition', description='The definition of the flow. The definition must comply with the Flow Definition Language (FDL) syntax.', example='version: v1.0\\\\ntype: flow\\\\nname: test\\\\nsteps:\\\\n - type: pass\\\\n name: mypass'),
      description?: string(name='Description', description='The description of the flow.', example='test flow'),
      environment?: {
        variables?: [ 
          {
            description?: string(name='Description', example='description'),
            name?: string(name='Name', example='key'),
            value?: string(name='Value', example='value'),
          }
        ](name='Variables'),
      }(name='Environment'),
      executionMode?: string(name='ExecutionMode', description='The execution mode or the enumeration type. Valid values: Express and Standard. A value of Standard indicates an empty string.', example='Standard'),
      id?: string(name='Id', description='The unique ID of the flow.', example='e589e092-e2c0-4dee-b306-3574ddf5****'),
      lastModifiedTime?: string(name='LastModifiedTime', description='The time when the flow was last modified.', example='2019-01-01T01:01:01.001Z'),
      name?: string(name='Name', description='The name of the flow.', example='flow'),
      roleArn?: string(name='RoleArn', description='The Alibaba Cloud resource name (ARN) of the specified Resource Access Management (RAM) role that Serverless Workflow assumes to invoke resources when the flow is executed.', example='acs:ram::${accountID}:${role}'),
      type?: string(name='Type', description='The type of the flow.', example='FDL'),
    }
  ](name='Flows', description='The details of flows.'),
  nextToken?: string(name='NextToken', description='The start key for the next query. This parameter is not returned if all results have been returned.', example='flow_nextxxx'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
}

model ListFlowsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFlowsResponseBody(name='body'),
}

/**
 * @summary Queries a list of flows.
 *
 * @param request ListFlowsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFlowsResponse
 */
async function listFlowsWithOptions(request: ListFlowsRequest, runtime: Util.RuntimeOptions): ListFlowsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFlows',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of flows.
 *
 * @param request ListFlowsRequest
 * @return ListFlowsResponse
 */
async function listFlows(request: ListFlowsRequest): ListFlowsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowsWithOptions(request, runtime);
}

model ListSchedulesRequest {
  flowName?: string(name='FlowName', description='The name of the flow that is associated with the time-based schedules. The name is unique within the region and cannot be modified after the flow is created. The name must meet the following conventions:

*   The name can contain letters, digits, underscores (_), and hyphens (-).
*   The name must start with a letter or an underscore (_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.

This parameter is required.', example='testFlowName'),
  limit?: int32(name='Limit', description='The number of schedules that you want to query. Valid values: 1 to 1000.', example='1'),
  nextToken?: string(name='NextToken', description='For the first query, you do not need to specify this parameter. The system uses the value of the **FlowName** parameter as the value of the **NextToken** parameter. When the query ends, no value is returned for this parameter.', example='testNextToken'),
}

model ListSchedulesResponseBody = {
  nextToken?: string(name='NextToken', description='The token for the next query.', example='testNextToken'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
  schedules?: [ 
    {
      createdTime?: string(name='CreatedTime', description='The time when the time-based schedule was created.', example='2020-01-01T01:01:01.001Z'),
      cronExpression?: string(name='CronExpression', description='The cron expression of the scheduled task.', example='0 * * * * *'),
      description?: string(name='Description', description='The description of the time-based schedule.', example='test description'),
      enable?: boolean(name='Enable', description='Indicates whether the time-based schedule is enabled. Valid values:

*   **true**
*   **false**', example='true'),
      lastModifiedTime?: string(name='LastModifiedTime', description='The time when the time-based schedule was last modified.', example='2020-01-01T01:01:01.001Z'),
      payload?: string(name='Payload', description='The trigger message of the time-based schedule.', example='{"key": "value"}'),
      scheduleId?: string(name='ScheduleId', description='The ID of the time-based schedule.', example='testScheduleId'),
      scheduleName?: string(name='ScheduleName', description='The name of the time-based schedule.', example='testScheduleName'),
    }
  ](name='Schedules', description='The time-based schedules that are queried.'),
}

model ListSchedulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSchedulesResponseBody(name='body'),
}

/**
 * @summary Queries time-based schedules in a flow.
 *
 * @param request ListSchedulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSchedulesResponse
 */
async function listSchedulesWithOptions(request: ListSchedulesRequest, runtime: Util.RuntimeOptions): ListSchedulesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSchedules',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries time-based schedules in a flow.
 *
 * @param request ListSchedulesRequest
 * @return ListSchedulesResponse
 */
async function listSchedules(request: ListSchedulesRequest): ListSchedulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSchedulesWithOptions(request, runtime);
}

model PublishFlowVersionRequest {
  description?: string(name='Description', example='example flow description'),
  flowName?: string(name='FlowName', description='This parameter is required.', example='example-flow-name'),
}

model PublishFlowVersionResponseBody = {
  createdTime?: string(name='CreatedTime', example='2025-10-24T14:11:26+08:00'),
  description?: string(name='Description', example='my flow description'),
  flowName?: string(name='FlowName', example='my-flow-name'),
  requestId?: string(name='RequestId', description='Id of the request', example='294D68C1-5108-5971-853A-1A9CC87B4816'),
  version?: string(name='Version', example='1'),
}

model PublishFlowVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PublishFlowVersionResponseBody(name='body'),
}

/**
 * @summary 发布流程版本
 *
 * @param request PublishFlowVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishFlowVersionResponse
 */
async function publishFlowVersionWithOptions(request: PublishFlowVersionRequest, runtime: Util.RuntimeOptions): PublishFlowVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PublishFlowVersion',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 发布流程版本
 *
 * @param request PublishFlowVersionRequest
 * @return PublishFlowVersionResponse
 */
async function publishFlowVersion(request: PublishFlowVersionRequest): PublishFlowVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishFlowVersionWithOptions(request, runtime);
}

model ReportTaskFailedRequest {
  cause?: string(name='Cause', description='The cause of the failure. The value must be 1 to 4,096 characters in length.', example='emptyString'),
  error?: string(name='Error', description='The error code for the failed task. The error code must be 1 to 128 characters in length.

This parameter is required.', example='nill'),
  taskToken?: string(name='TaskToken', description='The token of the task whose execution you want to report. The task token is passed to the called service, such as Message Service (MNS) or Function Compute. For MNS, the value of this parameter can be obtained from a message. For Function Compute, the value of this parameter can be obtained from an event. For more information, see [Service integration modes](https://help.aliyun.com/document_detail/2592915.html).

This parameter is required.', example='emptyString'),
}

model ReportTaskFailedResponseBody = {
  eventId?: long(name='EventId', description='The ID of the event.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
}

model ReportTaskFailedResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReportTaskFailedResponseBody(name='body'),
}

/**
 * @summary Reports a failed task.
 *
 * @description ## [](#)Usage notes
 * In the previous service (Serverless Workflow), the task step that ReportTaskFailed is used to call back `pattern: waitForCallback` indicates that the current task fails to be executed.
 * In the new service (CloudFlow), the task step that ReportTaskFailed is used to call back `TaskMode: WaitForCustomCallback` indicates that the current task fails to be executed.
 *
 * @param request ReportTaskFailedRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReportTaskFailedResponse
 */
async function reportTaskFailedWithOptions(request: ReportTaskFailedRequest, runtime: Util.RuntimeOptions): ReportTaskFailedResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskToken)) {
    query['TaskToken'] = request.taskToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.cause)) {
    body['Cause'] = request.cause;
  }
  if (!Util.isUnset(request.error)) {
    body['Error'] = request.error;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReportTaskFailed',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Reports a failed task.
 *
 * @description ## [](#)Usage notes
 * In the previous service (Serverless Workflow), the task step that ReportTaskFailed is used to call back `pattern: waitForCallback` indicates that the current task fails to be executed.
 * In the new service (CloudFlow), the task step that ReportTaskFailed is used to call back `TaskMode: WaitForCustomCallback` indicates that the current task fails to be executed.
 *
 * @param request ReportTaskFailedRequest
 * @return ReportTaskFailedResponse
 */
async function reportTaskFailed(request: ReportTaskFailedRequest): ReportTaskFailedResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportTaskFailedWithOptions(request, runtime);
}

model ReportTaskSucceededRequest {
  output?: string(name='Output', description='The output information of the task whose execution success you want to report.

This parameter is required.', example='{"key":"value"}'),
  taskToken?: string(name='TaskToken', description='The token of the task whose execution you want to report. The task token is passed to the called service, such as Message Service (MNS) or Function Compute. For MNS, the value of this parameter can be obtained from a message. For Function Compute, the value of this parameter can be obtained from an event. For more information, see [Service integration modes](https://help.aliyun.com/document_detail/2592915.html).

This parameter is required.', example='emptyString'),
}

model ReportTaskSucceededResponseBody = {
  eventId?: long(name='EventId', description='The ID of the event.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
}

model ReportTaskSucceededResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReportTaskSucceededResponseBody(name='body'),
}

/**
 * @summary Reports a successful task.
 *
 * @description ## [](#)Usage notes
 * In the previous service (Serverless Workflow), the task step that ReportTaskSucceeded is used to call back pattern: waitForCallback indicates that the current task is successfully executed.
 * In the new service (CloudFlow), the task step that ReportTaskSucceeded is used to call back TaskMode: WaitForCustomCallback indicates that the current task is successfully executed.
 *
 * @param request ReportTaskSucceededRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReportTaskSucceededResponse
 */
async function reportTaskSucceededWithOptions(request: ReportTaskSucceededRequest, runtime: Util.RuntimeOptions): ReportTaskSucceededResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskToken)) {
    query['TaskToken'] = request.taskToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.output)) {
    body['Output'] = request.output;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReportTaskSucceeded',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Reports a successful task.
 *
 * @description ## [](#)Usage notes
 * In the previous service (Serverless Workflow), the task step that ReportTaskSucceeded is used to call back pattern: waitForCallback indicates that the current task is successfully executed.
 * In the new service (CloudFlow), the task step that ReportTaskSucceeded is used to call back TaskMode: WaitForCustomCallback indicates that the current task is successfully executed.
 *
 * @param request ReportTaskSucceededRequest
 * @return ReportTaskSucceededResponse
 */
async function reportTaskSucceeded(request: ReportTaskSucceededRequest): ReportTaskSucceededResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportTaskSucceededWithOptions(request, runtime);
}

model StartExecutionRequest {
  callbackFnFTaskToken?: string(name='CallbackFnFTaskToken', description='Specifies that the **TaskToken**-related tasks are called back after the execution in the flow ends.', example='12'),
  executionName?: string(name='ExecutionName', description='The name of the execution. The execution name is unique within a workflow. Configure this parameter based on the following rules:

*   The name must start with a letter or an underscore (_).
*   The name can contain letters, digits, underscores (_), and hyphens (-).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='exec'),
  flowName?: string(name='FlowName', description='The name of the workflow to be executed.

This parameter is required.', example='flow'),
  input?: string(name='Input', description='The input of the execution, which is in the JSON format.', example='{"key":"value"}'),
  qualifier?: string(name='Qualifier', example='1'),
}

model StartExecutionResponseBody = {
  flowDefinition?: string(name='FlowDefinition', description='The definition of the flow.', example='version: v1.0\\\\ntype: flow\\\\nname: test\\\\nsteps:\\\\n - type: pass\\\\n name: mypass'),
  flowName?: string(name='FlowName', description='The name of the workflow.', example='flow'),
  input?: string(name='Input', description='The input of the execution, which is in the JSON format.', example='{"key":"value"}'),
  name?: string(name='Name', description='The name of the execution.', example='exec1'),
  output?: string(name='Output', description='The execution result, which is in the JSON format.', example='{"key":"value"}'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
  startedTime?: string(name='StartedTime', description='The time when the execution started.', example='2019-01-01T01:01:01.001Z'),
  status?: string(name='Status', description='The execution status. Valid values:

*   **Starting**
*   **Running**
*   **Stopped**
*   **Succeeded**
*   **Failed**
*   **TimedOut**', example='Succeeded'),
  stoppedTime?: string(name='StoppedTime', description='The time when the execution stopped.', example='2019-01-01T01:01:01.001Z'),
}

model StartExecutionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartExecutionResponseBody(name='body'),
}

/**
 * @summary Starts the execution of a workflow.
 *
 * @description ## [](#)Usage notes
 * *   The flow is created. A flow only in standard mode is supported.
 * *   If you do not specify an execution, the system automatically generates an execution and starts the execution.
 * *   If an ongoing execution has the same name as that of the execution to be started, the system directly returns the ongoing execution.
 * *   If the ongoing execution with the same name has ended (succeeded or failed), `ExecutionAlreadyExists` is returned.
 * *   If no execution with the same name exists, the system starts a new execution.
 *
 * @param request StartExecutionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartExecutionResponse
 */
async function startExecutionWithOptions(request: StartExecutionRequest, runtime: Util.RuntimeOptions): StartExecutionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.callbackFnFTaskToken)) {
    body['CallbackFnFTaskToken'] = request.callbackFnFTaskToken;
  }
  if (!Util.isUnset(request.executionName)) {
    body['ExecutionName'] = request.executionName;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.input)) {
    body['Input'] = request.input;
  }
  if (!Util.isUnset(request.qualifier)) {
    body['Qualifier'] = request.qualifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartExecution',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Starts the execution of a workflow.
 *
 * @description ## [](#)Usage notes
 * *   The flow is created. A flow only in standard mode is supported.
 * *   If you do not specify an execution, the system automatically generates an execution and starts the execution.
 * *   If an ongoing execution has the same name as that of the execution to be started, the system directly returns the ongoing execution.
 * *   If the ongoing execution with the same name has ended (succeeded or failed), `ExecutionAlreadyExists` is returned.
 * *   If no execution with the same name exists, the system starts a new execution.
 *
 * @param request StartExecutionRequest
 * @return StartExecutionResponse
 */
async function startExecution(request: StartExecutionRequest): StartExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return startExecutionWithOptions(request, runtime);
}

model StartSyncExecutionRequest {
  executionName?: string(name='ExecutionName', description='The name of the execution that you want to start. The name must meet the following conventions:

*   The name can contain letters, digits, underscores (_), and hyphens (-).
*   The name must start with a letter or an underscore (_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.

Different from the StartExecution operation, in the synchronous execution mode, the execution name is no longer required to be unique within a flow. You can choose to provide an execution name to identify the current execution. In this case, the system adds a UUID to the current execution name. The used format is {ExecutionName}:{UUID}. If you do not specify the execution name, the system automatically generates an execution name.', example='my_exec_name'),
  flowName?: string(name='FlowName', description='The name of the workflow to be executed.

This parameter is required.', example='my_flow_name'),
  input?: string(name='Input', description='The input of the execution, which is in the JSON format.', example='{"key":"value"}'),
  qualifier?: string(name='Qualifier', example='1'),
}

model StartSyncExecutionResponseBody = {
  environment?: {
    variables?: [ 
      {
        name?: string(name='Name', example='key'),
        value?: string(name='Value', example='value'),
      }
    ](name='Variables'),
  }(name='Environment'),
  errorCode?: string(name='ErrorCode', description='The error code that is returned if the execution failed.', example='ActionNotSupported'),
  errorMessage?: string(name='ErrorMessage', description='The error message that indicates the execution timed out.', example='Standard execution is not supported'),
  flowName?: string(name='FlowName', description='The name of the flow.', example='my_flow_name'),
  name?: string(name='Name', description='The name of the execution.', example='my_exec_name:{UUID}'),
  output?: string(name='Output', description='The output of the execution, which is in the JSON format.', example='{"key":"value"}'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
  startedTime?: string(name='StartedTime', description='The time when the execution started.', example='2019-01-01T01:01:01.001Z'),
  status?: string(name='Status', description='The status of the execution. Valid values:

*   **Starting**
*   **Running**
*   **Stopped**
*   **Succeeded**
*   **Failed**
*   **TimedOut**', example='Succeeded'),
  stoppedTime?: string(name='StoppedTime', description='The time when the execution stopped.', example='2019-01-01T01:01:01.001Z'),
}

model StartSyncExecutionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartSyncExecutionResponseBody(name='body'),
}

/**
 * @summary Synchronously starts an execution in a flow.
 *
 * @description *   Only flows of the express execution mode are supported.
 *
 * @param request StartSyncExecutionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartSyncExecutionResponse
 */
async function startSyncExecutionWithOptions(request: StartSyncExecutionRequest, runtime: Util.RuntimeOptions): StartSyncExecutionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.executionName)) {
    body['ExecutionName'] = request.executionName;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.input)) {
    body['Input'] = request.input;
  }
  if (!Util.isUnset(request.qualifier)) {
    body['Qualifier'] = request.qualifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartSyncExecution',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Synchronously starts an execution in a flow.
 *
 * @description *   Only flows of the express execution mode are supported.
 *
 * @param request StartSyncExecutionRequest
 * @return StartSyncExecutionResponse
 */
async function startSyncExecution(request: StartSyncExecutionRequest): StartSyncExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return startSyncExecutionWithOptions(request, runtime);
}

model StopExecutionRequest {
  cause?: string(name='Cause', description='The reason for stopping the execution. The value must be 1 to 4,096 characters in length.', example='for test'),
  error?: string(name='Error', description='The error code for stopping the execution. The error code must be 1 to 128 characters in length.', example='nill'),
  executionName?: string(name='ExecutionName', description='The name of the execution to be stopped. You can call the **ListExecutions** operation to obtain the value of this parameter.

This parameter is required.', example='exec'),
  flowName?: string(name='FlowName', description='The name of the workflow to be stopped. You can call the **ListFlows** operation to obtain the value of this parameter.

This parameter is required.', example='flow'),
}

model StopExecutionResponseBody = {
  flowDefinition?: string(name='FlowDefinition', description='The definition of the flow.', example='version: v1.0\\\\ntype: flow\\\\nname: test\\\\nsteps:\\\\n - type: pass\\\\n name: mypass'),
  flowName?: string(name='FlowName', description='The name of the flow.', example='flow'),
  input?: string(name='Input', description='The input of the execution, which is in the JSON format.', example='{"key":"value"}'),
  name?: string(name='Name', description='The name of the execution.', example='exec'),
  output?: string(name='Output', description='The execution result, which is in the JSON format.', example='{"key":"value"}'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
  roleArn?: string(name='RoleArn', description='The Alibaba Cloud resource name (ARN) of the role that executed the flow. If the RoleArn in the flow definition is changed during the execution of the flow, the system records and returns a snapshot of the original RoleArn.

>  If you do not specify the RoleArn parameter in the request parameters, the response parameters do not contain the RoleArn parameter.', example='acs:ram:${region}:${accountID}:${role}'),
  startedTime?: string(name='StartedTime', description='The time when the execution started.', example='2019-01-01T01:01:01.001Z'),
  status?: string(name='Status', description='The execution status. Valid values:

*   **Starting**
*   **Running**
*   **Stopped**
*   **Succeeded**
*   **Failed**
*   **TimedOut**', example='Running'),
  stoppedTime?: string(name='StoppedTime', description='The time when the execution stopped.', example='2019-01-01T01:01:01.001Z'),
}

model StopExecutionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopExecutionResponseBody(name='body'),
}

/**
 * @summary Stops an execution that is in progress in a flow.
 *
 * @description ## [](#)Usage notes
 * The flow must be in progress.
 *
 * @param request StopExecutionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopExecutionResponse
 */
async function stopExecutionWithOptions(request: StopExecutionRequest, runtime: Util.RuntimeOptions): StopExecutionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.cause)) {
    body['Cause'] = request.cause;
  }
  if (!Util.isUnset(request.error)) {
    body['Error'] = request.error;
  }
  if (!Util.isUnset(request.executionName)) {
    body['ExecutionName'] = request.executionName;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopExecution',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Stops an execution that is in progress in a flow.
 *
 * @description ## [](#)Usage notes
 * The flow must be in progress.
 *
 * @param request StopExecutionRequest
 * @return StopExecutionResponse
 */
async function stopExecution(request: StopExecutionRequest): StopExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopExecutionWithOptions(request, runtime);
}

model UpdateFlowRequest {
  definition?: string(name='Definition', description='The definition of the workflow. The definition must comply with the flow definition language (FDL) syntax. Considering compatibility, the system supports the two workflow definition specifications.

>  In the preceding workflow definition example, Name:my_flow_name is the workflow name, which must be consistent with the input parameter Name', example='version: v1.0\\\\ntype: flow\\\\nname: test\\\\nsteps:\\\\n  - type: pass\\\\n    name: mypass'),
  description?: string(name='Description', description='The description of the flow.', example='test definition'),
  environment?: {
    variables?: [ 
      {
        description?: string(name='Description', example='description'),
        name?: string(name='Name', example='key'),
        value?: string(name='Value', example='value'),
      }
    ](name='Variables'),
  }(name='Environment'),
  name?: string(name='Name', description='The name of the workflow.

This parameter is required.', example='flow'),
  roleArn?: string(name='RoleArn', description='The Alibaba Cloud resource name (ARN) of the authorized role on which the execution of the flow relies. During the execution of the flow, the flow execution engine assumes the role to call API operations of relevant services.', example='acs:ram::${accountID}:${role}'),
  type?: string(name='Type', description='The type of the flow. Valid value: **FDL**.', example='FDL'),
}

model UpdateFlowShrinkRequest {
  definition?: string(name='Definition', description='The definition of the workflow. The definition must comply with the flow definition language (FDL) syntax. Considering compatibility, the system supports the two workflow definition specifications.

>  In the preceding workflow definition example, Name:my_flow_name is the workflow name, which must be consistent with the input parameter Name', example='version: v1.0\\\\ntype: flow\\\\nname: test\\\\nsteps:\\\\n  - type: pass\\\\n    name: mypass'),
  description?: string(name='Description', description='The description of the flow.', example='test definition'),
  environmentShrink?: string(name='Environment'),
  name?: string(name='Name', description='The name of the workflow.

This parameter is required.', example='flow'),
  roleArn?: string(name='RoleArn', description='The Alibaba Cloud resource name (ARN) of the authorized role on which the execution of the flow relies. During the execution of the flow, the flow execution engine assumes the role to call API operations of relevant services.', example='acs:ram::${accountID}:${role}'),
  type?: string(name='Type', description='The type of the flow. Valid value: **FDL**.', example='FDL'),
}

model UpdateFlowResponseBody = {
  createdTime?: string(name='CreatedTime', description='The time when the flow was created.', example='2019-01-01T01:01:01.001Z'),
  definition?: string(name='Definition', description='The flow definition, which follows the FDL syntax standard. Considering compatibility, the system supports the two flow definition specifications.', example='version: v1.0\\\\ntype: flow\\\\nname: test\\\\nsteps:\\\\n  - type: pass\\\\n    name: mypass'),
  description?: string(name='Description', description='The description of the flow.', example='test definition'),
  environment?: {
    variables?: [ 
      {
        description?: string(name='Description', example='description'),
        name?: string(name='Name', example='key'),
        value?: string(name='Value', example='value'),
      }
    ](name='Variables'),
  }(name='Environment'),
  externalStorageLocation?: string(name='ExternalStorageLocation', description='The path of the external storage.', example='/path'),
  id?: string(name='Id', description='The unique ID of the flow.', example='e589e092-e2c0-4dee-b306-3574ddfdddf5****'),
  lastModifiedTime?: string(name='LastModifiedTime', description='The time when the flow was last modified.', example='2019-01-01T01:01:01.001Z'),
  name?: string(name='Name', description='The name of the flow.', example='flow'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestID'),
  roleArn?: string(name='RoleArn', description='The Alibaba Cloud resource name (ARN) of the authorized role on which the execution of the flow relies. During the execution of the flow, the flow execution engine assumes the role to call API operations of relevant services.', example='acs:ram::${accountID}:${role}'),
  type?: string(name='Type', description='The type of the flow.', example='FDL'),
}

model UpdateFlowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFlowResponseBody(name='body'),
}

/**
 * @summary Updates a flow.
 *
 * @param tmpReq UpdateFlowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFlowResponse
 */
async function updateFlowWithOptions(tmpReq: UpdateFlowRequest, runtime: Util.RuntimeOptions): UpdateFlowResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateFlowShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.environment)) {
    request.environmentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.environment, 'Environment', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.definition)) {
    body['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.environmentShrink)) {
    body['Environment'] = request.environmentShrink;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.roleArn)) {
    body['RoleArn'] = request.roleArn;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFlow',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a flow.
 *
 * @param request UpdateFlowRequest
 * @return UpdateFlowResponse
 */
async function updateFlow(request: UpdateFlowRequest): UpdateFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFlowWithOptions(request, runtime);
}

model UpdateFlowAliasRequest {
  description?: string(name='Description', example='example description'),
  flowName?: string(name='FlowName', description='This parameter is required.', example='example-flow-name'),
  name?: string(name='Name', description='This parameter is required.', example='alias name'),
  routingConfigurations?: [ 
    {
      version?: string(name='Version', example='1'),
      weight?: int32(name='Weight', example='20'),
    }
  ](name='RoutingConfigurations'),
}

model UpdateFlowAliasShrinkRequest {
  description?: string(name='Description', example='example description'),
  flowName?: string(name='FlowName', description='This parameter is required.', example='example-flow-name'),
  name?: string(name='Name', description='This parameter is required.', example='alias name'),
  routingConfigurationsShrink?: string(name='RoutingConfigurations'),
}

model UpdateFlowAliasResponseBody = {
  alias?: {
    createdTime?: string(name='CreatedTime', example='2025-10-24T14:11:26+08:00'),
    description?: string(name='Description', example='my alias description'),
    name?: string(name='Name', example='my-alias-name'),
    routingConfigurations?: [ 
      {
        version?: string(name='Version', example='1'),
        weight?: int32(name='Weight', example='20'),
      }
    ](name='RoutingConfigurations'),
  }(name='Alias'),
  requestId?: string(name='RequestId', description='Id of the request', example='294D68C1-5108-5971-853A-1A9CC87B4816'),
}

model UpdateFlowAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFlowAliasResponseBody(name='body'),
}

/**
 * @summary 更新流程版本别名配置
 *
 * @param tmpReq UpdateFlowAliasRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFlowAliasResponse
 */
async function updateFlowAliasWithOptions(tmpReq: UpdateFlowAliasRequest, runtime: Util.RuntimeOptions): UpdateFlowAliasResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateFlowAliasShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.routingConfigurations)) {
    request.routingConfigurationsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.routingConfigurations, 'RoutingConfigurations', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.routingConfigurationsShrink)) {
    body['RoutingConfigurations'] = request.routingConfigurationsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFlowAlias',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新流程版本别名配置
 *
 * @param request UpdateFlowAliasRequest
 * @return UpdateFlowAliasResponse
 */
async function updateFlowAlias(request: UpdateFlowAliasRequest): UpdateFlowAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFlowAliasWithOptions(request, runtime);
}

model UpdateMapRunRequest {
  concurrency?: long(name='Concurrency', example='1'),
  executionName?: string(name='ExecutionName', description='This parameter is required.', example='my_exec_name'),
  flowName?: string(name='FlowName', description='This parameter is required.', example='my_flow_name'),
  mapRunName?: string(name='MapRunName', description='This parameter is required.', example='c39142f1345b196d678333c41f113100'),
  requestId?: string(name='RequestId', example='3A44E113-9962-5B0B-AB92-14060EFE3164'),
  toleratedFailedCount?: long(name='ToleratedFailedCount', example='100'),
  toleratedFailedPercentage?: float(name='ToleratedFailedPercentage', example='20'),
}

model UpdateMapRunResponseBody = {
  concurrency?: long(name='Concurrency', example='1'),
  executionName?: string(name='ExecutionName', example='my_exec_name'),
  flowName?: string(name='FlowName', example='my_flow_name'),
  mapRunName?: string(name='MapRunName', example='c39142f1345b196d678333c41f113000'),
  requestId?: string(name='RequestId', description='Id of the request', example='3A44E113-9962-5B0B-AB92-14060EFE3164'),
  toleratedFailedCount?: long(name='ToleratedFailedCount', example='100'),
  toleratedFailedPercentage?: float(name='ToleratedFailedPercentage', example='20'),
}

model UpdateMapRunResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMapRunResponseBody(name='body'),
}

/**
 * @summary 更新 MapRun 配置
 *
 * @param request UpdateMapRunRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMapRunResponse
 */
async function updateMapRunWithOptions(request: UpdateMapRunRequest, runtime: Util.RuntimeOptions): UpdateMapRunResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMapRun',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新 MapRun 配置
 *
 * @param request UpdateMapRunRequest
 * @return UpdateMapRunResponse
 */
async function updateMapRun(request: UpdateMapRunRequest): UpdateMapRunResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMapRunWithOptions(request, runtime);
}

model UpdateScheduleRequest {
  cronExpression?: string(name='CronExpression', description='The CRON expression.', example='0 * * * * *'),
  description?: string(name='Description', description='The description of the time-based schedule.', example='test description'),
  enable?: boolean(name='Enable', description='Specifies whether to enable the time-based schedule. Valid values:

*   **true**
*   **false**', example='true'),
  flowName?: string(name='FlowName', description='The name of the flow that is associated with the time-based schedule. The name must be unique within the region and cannot be modified after the time-based schedule is created. The name must meet the following conventions:

*   The name can contain letters, digits, underscores (_), and hyphens (-).
*   The name must start with a letter or an underscore (_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.

This parameter is required.', example='testFlowName'),
  payload?: string(name='Payload', description='The trigger message of the time-based schedule. It must be in the JSON format.', example='{"key": "value"}'),
  scheduleName?: string(name='ScheduleName', description='The name of the time-based schedule. The name must meet the following conventions:

*   The name can contain letters, digits, underscores (_), and hyphens (-).
*   The name must start with a letter or an underscore (_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.

This parameter is required.', example='testScheduleName'),
}

model UpdateScheduleResponseBody = {
  createdTime?: string(name='CreatedTime', description='The time when the time-based schedule was created.', example='2020-01-01T01:01:01.001Z'),
  cronExpression?: string(name='CronExpression', description='The CRON expression.', example='0 * * * * *'),
  description?: string(name='Description', description='The description of the time-based schedule.', example='test description'),
  enable?: boolean(name='Enable', description='Indicates whether the time-based schedule is enabled. Valid values:

*   **true**
*   **false**', example='true'),
  lastModifiedTime?: string(name='LastModifiedTime', description='The time when the time-based schedule was last updated.', example='2020-01-01T01:01:01.001Z'),
  payload?: string(name='Payload', description='The trigger message of the time-based schedule.', example='{"key": "value"}'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
  scheduleId?: string(name='ScheduleId', description='The ID of the time-based schedule.', example='testScheduleId'),
  scheduleName?: string(name='ScheduleName', description='The name of the time-based schedule.', example='testScheduleName'),
}

model UpdateScheduleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateScheduleResponseBody(name='body'),
}

/**
 * @summary Updates a time-based schedule.
 *
 * @param request UpdateScheduleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateScheduleResponse
 */
async function updateScheduleWithOptions(request: UpdateScheduleRequest, runtime: Util.RuntimeOptions): UpdateScheduleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.cronExpression)) {
    body['CronExpression'] = request.cronExpression;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.enable)) {
    body['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.payload)) {
    body['Payload'] = request.payload;
  }
  if (!Util.isUnset(request.scheduleName)) {
    body['ScheduleName'] = request.scheduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSchedule',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a time-based schedule.
 *
 * @param request UpdateScheduleRequest
 * @return UpdateScheduleResponse
 */
async function updateSchedule(request: UpdateScheduleRequest): UpdateScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateScheduleWithOptions(request, runtime);
}

