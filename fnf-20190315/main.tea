/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'cn-beijing.fnf.aliyuncs.com',
    cn-hangzhou = 'cn-hangzhou.fnf.aliyuncs.com',
    cn-shanghai = 'cn-shanghai.fnf.aliyuncs.com',
    cn-shenzhen = 'cn-shenzhen.fnf.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('fnf', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateFlowRequest {
  definition?: string(name='Definition', example='version:&nbsp;v1.0<br/>type:&nbsp;flow<br/>steps:<br/>&nbsp;-&nbsp;type:&nbsp;pass<br/>&nbsp;name:&nbsp;mypass'),
  description?: string(name='Description', example='test flow'),
  executionMode?: string(name='ExecutionMode'),
  externalStorageLocation?: string(name='ExternalStorageLocation', example='/path'),
  name?: string(name='Name', example='flow'),
  requestId?: string(name='RequestId', example='testRequestID'),
  roleArn?: string(name='RoleArn', example='acs:ram:${region}:${accountID}:${role}'),
  type?: string(name='Type', example='FDL'),
}

model CreateFlowResponseBody = {
  createdTime?: string(name='CreatedTime', example='2019-01-01T01:01:01.001Z'),
  definition?: string(name='Definition', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n - type: pass\\n name: mypass'),
  description?: string(name='Description', example='test flow'),
  executionMode?: string(name='ExecutionMode'),
  id?: string(name='Id', example='e589e092-e2c0-4dee-b306-3574ddfdddf5****'),
  lastModifiedTime?: string(name='LastModifiedTime', example='2019-01-01T01:01:01.001Z'),
  name?: string(name='Name', example='flow'),
  requestId?: string(name='RequestId', example='testRequestID'),
  roleArn?: string(name='RoleArn', example='acs:ram:${region}:${accountID}:${role}'),
  type?: string(name='Type', example='FDL'),
}

model CreateFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFlowResponseBody(name='body'),
}

async function createFlowWithOptions(request: CreateFlowRequest, runtime: Util.RuntimeOptions): CreateFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.definition)) {
    body['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.executionMode)) {
    body['ExecutionMode'] = request.executionMode;
  }
  if (!Util.isUnset(request.externalStorageLocation)) {
    body['ExternalStorageLocation'] = request.externalStorageLocation;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.roleArn)) {
    body['RoleArn'] = request.roleArn;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlow',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFlow(request: CreateFlowRequest): CreateFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowWithOptions(request, runtime);
}

model CreateScheduleRequest {
  cronExpression?: string(name='CronExpression', example='0 * * * * *'),
  description?: string(name='Description', example='test description'),
  enable?: boolean(name='Enable', example='true'),
  flowName?: string(name='FlowName', example='flow'),
  payload?: string(name='Payload', example='{"key": "value"}'),
  requestId?: string(name='RequestId', example='testRequestId'),
  scheduleName?: string(name='ScheduleName', example='testScheduleName'),
}

model CreateScheduleResponseBody = {
  createdTime?: string(name='CreatedTime', example='2020-01-01T01:01:01.001Z'),
  cronExpression?: string(name='CronExpression', example='0 * * * * *'),
  description?: string(name='Description', example='test description'),
  enable?: boolean(name='Enable', example='true'),
  lastModifiedTime?: string(name='LastModifiedTime', example='2020-01-01T01:01:01.001Z'),
  payload?: string(name='Payload', example='{"key": "value"}'),
  requestId?: string(name='RequestId', example='testRequestId'),
  scheduleId?: string(name='ScheduleId', example='testScheduleId'),
  scheduleName?: string(name='ScheduleName', example='testScheduleName'),
}

model CreateScheduleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateScheduleResponseBody(name='body'),
}

async function createScheduleWithOptions(request: CreateScheduleRequest, runtime: Util.RuntimeOptions): CreateScheduleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.cronExpression)) {
    body['CronExpression'] = request.cronExpression;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.enable)) {
    body['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.payload)) {
    body['Payload'] = request.payload;
  }
  if (!Util.isUnset(request.scheduleName)) {
    body['ScheduleName'] = request.scheduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSchedule',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSchedule(request: CreateScheduleRequest): CreateScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createScheduleWithOptions(request, runtime);
}

model DeleteFlowRequest {
  name?: string(name='Name', example='flow'),
  requestId?: string(name='RequestId', example='testRequestId'),
}

model DeleteFlowResponseBody = {
  requestId?: string(name='RequestId', example='testRequestId'),
}

model DeleteFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFlowResponseBody(name='body'),
}

async function deleteFlowWithOptions(request: DeleteFlowRequest, runtime: Util.RuntimeOptions): DeleteFlowResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlow',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFlow(request: DeleteFlowRequest): DeleteFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowWithOptions(request, runtime);
}

model DeleteScheduleRequest {
  flowName?: string(name='FlowName', example='testFlowName'),
  requestId?: string(name='RequestId', example='testRequestId'),
  scheduleName?: string(name='ScheduleName', example='testScheduleName'),
}

model DeleteScheduleResponseBody = {
  requestId?: string(name='RequestId', example='testRequestId'),
}

model DeleteScheduleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteScheduleResponseBody(name='body'),
}

async function deleteScheduleWithOptions(request: DeleteScheduleRequest, runtime: Util.RuntimeOptions): DeleteScheduleResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSchedule',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSchedule(request: DeleteScheduleRequest): DeleteScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteScheduleWithOptions(request, runtime);
}

model DescribeExecutionRequest {
  executionName?: string(name='ExecutionName', example='exec'),
  flowName?: string(name='FlowName', example='flow'),
  requestId?: string(name='RequestId', example='testRequestId'),
  waitTimeSeconds?: int32(name='WaitTimeSeconds', example='20'),
}

model DescribeExecutionResponseBody = {
  flowDefinition?: string(name='FlowDefinition', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n - type: pass\\n name: mypass'),
  flowName?: string(name='FlowName', example='flow'),
  input?: string(name='Input', example='{"key":"value"}'),
  name?: string(name='Name', example='exec'),
  output?: string(name='Output', example='{"key":"value"}'),
  requestId?: string(name='RequestId', example='testRequestId'),
  startedTime?: string(name='StartedTime', example='2019-01-01T01:01:01.001Z'),
  status?: string(name='Status', example='Succeeded'),
  stoppedTime?: string(name='StoppedTime', example='2019-01-01T01:01:01.001Z'),
}

model DescribeExecutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeExecutionResponseBody(name='body'),
}

async function describeExecutionWithOptions(request: DescribeExecutionRequest, runtime: Util.RuntimeOptions): DescribeExecutionResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExecution',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeExecution(request: DescribeExecutionRequest): DescribeExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExecutionWithOptions(request, runtime);
}

model DescribeFlowRequest {
  name?: string(name='Name', example='flow'),
  requestId?: string(name='RequestId', example='testRequestId'),
}

model DescribeFlowResponseBody = {
  createdTime?: string(name='CreatedTime', example='2019-01-01T01:01:01.001Z'),
  definition?: string(name='Definition', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n - type: pass\\n name: mypass'),
  description?: string(name='Description', example='test flow'),
  executionMode?: string(name='ExecutionMode'),
  id?: string(name='Id', example='e589e092-e2c0-4dee-b306-3574ddfdddf5****'),
  lastModifiedTime?: string(name='LastModifiedTime', example='2019-01-01T01:01:01.001Z'),
  name?: string(name='Name', example='flow'),
  requestId?: string(name='RequestId', example='testRequestId'),
  roleArn?: string(name='RoleArn', example='acs:ram::${accountID}:${role}'),
  type?: string(name='Type', example='FDL'),
}

model DescribeFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFlowResponseBody(name='body'),
}

async function describeFlowWithOptions(request: DescribeFlowRequest, runtime: Util.RuntimeOptions): DescribeFlowResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlow',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlow(request: DescribeFlowRequest): DescribeFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowWithOptions(request, runtime);
}

model DescribeScheduleRequest {
  flowName?: string(name='FlowName', example='testFlowName'),
  requestId?: string(name='RequestId', example='testRequestId'),
  scheduleName?: string(name='ScheduleName', example='testScheduleName'),
}

model DescribeScheduleResponseBody = {
  createdTime?: string(name='CreatedTime', example='2020-01-01T01:01:01.001Z'),
  cronExpression?: string(name='CronExpression', example='0 * * * * *'),
  description?: string(name='Description', example='test description'),
  enable?: boolean(name='Enable', example='true'),
  lastModifiedTime?: string(name='LastModifiedTime', example='2020-01-01T01:01:01.001Z'),
  payload?: string(name='Payload', example='{"key": "value"}'),
  requestId?: string(name='RequestId', example='testRequestId'),
  scheduleId?: string(name='ScheduleId', example='testScheduleId'),
  scheduleName?: string(name='ScheduleName', example='testScheduleName'),
}

model DescribeScheduleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeScheduleResponseBody(name='body'),
}

async function describeScheduleWithOptions(request: DescribeScheduleRequest, runtime: Util.RuntimeOptions): DescribeScheduleResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSchedule',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSchedule(request: DescribeScheduleRequest): DescribeScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScheduleWithOptions(request, runtime);
}

model GetExecutionHistoryRequest {
  executionName?: string(name='ExecutionName', example='exec'),
  flowName?: string(name='FlowName', example='flow'),
  limit?: int32(name='Limit', example='1'),
  nextToken?: string(name='NextToken', example='flow_xxx'),
  requestId?: string(name='RequestId', example='testRequestId'),
}

model GetExecutionHistoryResponseBody = {
  events?: [ 
    {
      eventDetail?: string(name='EventDetail', example='{}'),
      eventId?: long(name='EventId', example='2'),
      scheduleEventId?: long(name='ScheduleEventId', example='1'),
      stepName?: string(name='StepName', example='passStep'),
      time?: string(name='Time', example='2019-01-01T01:01:01.001Z'),
      type?: string(name='Type', example='TaskSucceeded'),
    }
  ](name='Events'),
  nextToken?: string(name='NextToken', example='3'),
  requestId?: string(name='RequestId', example='testRequestId'),
}

model GetExecutionHistoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExecutionHistoryResponseBody(name='body'),
}

async function getExecutionHistoryWithOptions(request: GetExecutionHistoryRequest, runtime: Util.RuntimeOptions): GetExecutionHistoryResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExecutionHistory',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getExecutionHistory(request: GetExecutionHistoryRequest): GetExecutionHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getExecutionHistoryWithOptions(request, runtime);
}

model ListExecutionsRequest {
  executionNamePrefix?: string(name='ExecutionNamePrefix', example='run'),
  flowName?: string(name='FlowName', example='flow'),
  limit?: int32(name='Limit', example='1'),
  nextToken?: string(name='NextToken', example='flow_xxx'),
  requestId?: string(name='RequestId', example='testRequestId'),
  startedTimeBegin?: string(name='StartedTimeBegin', example='2020-12-02T02:39:20.402Z'),
  startedTimeEnd?: string(name='StartedTimeEnd', example='2020-12-02T02:23:54.817Z'),
  status?: string(name='Status', example='Succeeded'),
}

model ListExecutionsResponseBody = {
  executions?: [ 
    {
      flowDefinition?: string(name='FlowDefinition', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n  - type: pass\\n    name: mypass'),
      flowName?: string(name='FlowName', example='flow'),
      input?: string(name='Input', example='{"key":"value"}'),
      name?: string(name='Name', example='exec'),
      output?: string(name='Output', example='{"key":"value"}'),
      startedTime?: string(name='StartedTime', example='2019-01-01T01:01:01.001Z'),
      status?: string(name='Status', example='Succeeded'),
      stoppedTime?: string(name='StoppedTime', example='2019-01-01T01:01:01.001Z'),
    }
  ](name='Executions'),
  nextToken?: string(name='NextToken', example='exec2'),
  requestId?: string(name='RequestId', example='testRequestId'),
}

model ListExecutionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListExecutionsResponseBody(name='body'),
}

async function listExecutionsWithOptions(request: ListExecutionsRequest, runtime: Util.RuntimeOptions): ListExecutionsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListExecutions',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listExecutions(request: ListExecutionsRequest): ListExecutionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExecutionsWithOptions(request, runtime);
}

model ListFlowsRequest {
  limit?: int32(name='Limit', example='1'),
  nextToken?: string(name='NextToken', example='flow_nextxxx'),
  requestId?: string(name='RequestId', example='testRequestId'),
}

model ListFlowsResponseBody = {
  flows?: [ 
    {
      createdTime?: string(name='CreatedTime', example='2019-01-01T01:01:01.001Z'),
      definition?: string(name='Definition', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n - type: pass\\n name: mypass'),
      description?: string(name='Description', example='test flow'),
      executionMode?: string(name='ExecutionMode'),
      id?: string(name='Id', example='e589e092-e2c0-4dee-b306-3574ddf5****'),
      lastModifiedTime?: string(name='LastModifiedTime', example='2019-01-01T01:01:01.001Z'),
      name?: string(name='Name', example='flow'),
      roleArn?: string(name='RoleArn', example='acs:ram::${accountID}:${role}'),
      type?: string(name='Type', example='FDL'),
    }
  ](name='Flows'),
  nextToken?: string(name='NextToken', example='flow_nextxxx'),
  requestId?: string(name='RequestId', example='testRequestId'),
}

model ListFlowsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFlowsResponseBody(name='body'),
}

async function listFlowsWithOptions(request: ListFlowsRequest, runtime: Util.RuntimeOptions): ListFlowsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFlows',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlows(request: ListFlowsRequest): ListFlowsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowsWithOptions(request, runtime);
}

model ListSchedulesRequest {
  flowName?: string(name='FlowName', example='testFlowName'),
  limit?: int32(name='Limit', example='1'),
  nextToken?: string(name='NextToken', example='testNextToken'),
  requestId?: string(name='RequestId', example='testRequestId'),
}

model ListSchedulesResponseBody = {
  nextToken?: string(name='NextToken', example='testNextToken'),
  requestId?: string(name='RequestId', example='testRequestId'),
  schedules?: [ 
    {
      createdTime?: string(name='CreatedTime', example='2020-01-01T01:01:01.001Z'),
      cronExpression?: string(name='CronExpression', example='0 * * * * *'),
      description?: string(name='Description', example='test description'),
      enable?: boolean(name='Enable', example='true'),
      lastModifiedTime?: string(name='LastModifiedTime', example='2020-01-01T01:01:01.001Z'),
      payload?: string(name='Payload', example='{"key": "value"}'),
      scheduleId?: string(name='ScheduleId', example='testScheduleId'),
      scheduleName?: string(name='ScheduleName', example='testScheduleName'),
    }
  ](name='Schedules'),
}

model ListSchedulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSchedulesResponseBody(name='body'),
}

async function listSchedulesWithOptions(request: ListSchedulesRequest, runtime: Util.RuntimeOptions): ListSchedulesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSchedules',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSchedules(request: ListSchedulesRequest): ListSchedulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSchedulesWithOptions(request, runtime);
}

model ReportTaskFailedRequest {
  cause?: string(name='Cause', example='emptyString'),
  error?: string(name='Error', example='nill'),
  requestId?: string(name='RequestId', example='testRequestId'),
  taskToken?: string(name='TaskToken', example='emptyString'),
}

model ReportTaskFailedResponseBody = {
  eventId?: long(name='EventId', example='1'),
  requestId?: string(name='RequestId', example='testRequestId'),
}

model ReportTaskFailedResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReportTaskFailedResponseBody(name='body'),
}

async function reportTaskFailedWithOptions(request: ReportTaskFailedRequest, runtime: Util.RuntimeOptions): ReportTaskFailedResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.taskToken)) {
    query['TaskToken'] = request.taskToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.cause)) {
    body['Cause'] = request.cause;
  }
  if (!Util.isUnset(request.error)) {
    body['Error'] = request.error;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReportTaskFailed',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportTaskFailed(request: ReportTaskFailedRequest): ReportTaskFailedResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportTaskFailedWithOptions(request, runtime);
}

model ReportTaskSucceededRequest {
  output?: string(name='Output', example='{"key":"value"}'),
  requestId?: string(name='RequestId', example='testRequestId'),
  taskToken?: string(name='TaskToken', example='emptyString'),
}

model ReportTaskSucceededResponseBody = {
  eventId?: long(name='EventId', example='1'),
  requestId?: string(name='RequestId', example='testRequestId'),
}

model ReportTaskSucceededResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReportTaskSucceededResponseBody(name='body'),
}

async function reportTaskSucceededWithOptions(request: ReportTaskSucceededRequest, runtime: Util.RuntimeOptions): ReportTaskSucceededResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.taskToken)) {
    query['TaskToken'] = request.taskToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.output)) {
    body['Output'] = request.output;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReportTaskSucceeded',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportTaskSucceeded(request: ReportTaskSucceededRequest): ReportTaskSucceededResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportTaskSucceededWithOptions(request, runtime);
}

model StartExecutionRequest {
  callbackFnFTaskToken?: string(name='CallbackFnFTaskToken', example='12'),
  executionName?: string(name='ExecutionName', example='exec'),
  flowName?: string(name='FlowName', example='flow'),
  input?: string(name='Input', example='{"key":"value"}'),
  requestId?: string(name='RequestId', example='testRequestId'),
}

model StartExecutionResponseBody = {
  flowDefinition?: string(name='FlowDefinition', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n - type: pass\\n name: mypass'),
  flowName?: string(name='FlowName', example='flow'),
  input?: string(name='Input', example='{"key":"value"}'),
  name?: string(name='Name', example='exec1'),
  output?: string(name='Output', example='{"key":"value"}'),
  requestId?: string(name='RequestId', example='testRequestId'),
  startedTime?: string(name='StartedTime', example='2019-01-01T01:01:01.001Z'),
  status?: string(name='Status', example='Succeeded'),
  stoppedTime?: string(name='StoppedTime', example='2019-01-01T01:01:01.001Z'),
}

model StartExecutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartExecutionResponseBody(name='body'),
}

async function startExecutionWithOptions(request: StartExecutionRequest, runtime: Util.RuntimeOptions): StartExecutionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.callbackFnFTaskToken)) {
    body['CallbackFnFTaskToken'] = request.callbackFnFTaskToken;
  }
  if (!Util.isUnset(request.executionName)) {
    body['ExecutionName'] = request.executionName;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.input)) {
    body['Input'] = request.input;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartExecution',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startExecution(request: StartExecutionRequest): StartExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return startExecutionWithOptions(request, runtime);
}

model StopExecutionRequest {
  cause?: string(name='Cause', example='for test'),
  error?: string(name='Error', example='nill'),
  executionName?: string(name='ExecutionName', example='exec'),
  flowName?: string(name='FlowName', example='flow'),
  requestId?: string(name='RequestId', example='testRequestId'),
}

model StopExecutionResponseBody = {
  flowDefinition?: string(name='FlowDefinition', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n - type: pass\\n name: mypass'),
  flowName?: string(name='FlowName', example='flow'),
  input?: string(name='Input', example='{"key":"value"}'),
  name?: string(name='Name', example='exec'),
  output?: string(name='Output', example='{"key":"value"}'),
  requestId?: string(name='RequestId', example='testRequestId'),
  startedTime?: string(name='StartedTime', example='2019-01-01T01:01:01.001Z'),
  status?: string(name='Status', example='Running'),
  stoppedTime?: string(name='StoppedTime', example='2019-01-01T01:01:01.001Z'),
}

model StopExecutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopExecutionResponseBody(name='body'),
}

async function stopExecutionWithOptions(request: StopExecutionRequest, runtime: Util.RuntimeOptions): StopExecutionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.cause)) {
    body['Cause'] = request.cause;
  }
  if (!Util.isUnset(request.error)) {
    body['Error'] = request.error;
  }
  if (!Util.isUnset(request.executionName)) {
    body['ExecutionName'] = request.executionName;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopExecution',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopExecution(request: StopExecutionRequest): StopExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopExecutionWithOptions(request, runtime);
}

model UpdateFlowRequest {
  definition?: string(name='Definition', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n  - type: pass\\n    name: mypass'),
  description?: string(name='Description', example='test definition'),
  name?: string(name='Name', example='flow'),
  requestId?: string(name='RequestId', example='testRequestId'),
  roleArn?: string(name='RoleArn', example='acs:ram::${accountID}:${role}'),
  type?: string(name='Type', example='FDL'),
}

model UpdateFlowResponseBody = {
  createdTime?: string(name='CreatedTime', example='2019-01-01T01:01:01.001Z'),
  definition?: string(name='Definition', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n  - type: pass\\n    name: mypass'),
  description?: string(name='Description', example='test definition'),
  externalStorageLocation?: string(name='ExternalStorageLocation', example='/path'),
  id?: string(name='Id', example='e589e092-e2c0-4dee-b306-3574ddfdddf5****'),
  lastModifiedTime?: string(name='LastModifiedTime', example='2019-01-01T01:01:01.001Z'),
  name?: string(name='Name', example='flow'),
  requestId?: string(name='RequestId', example='testRequestID'),
  roleArn?: string(name='RoleArn', example='acs:ram::${accountID}:${role}'),
  type?: string(name='Type', example='FDL'),
}

model UpdateFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFlowResponseBody(name='body'),
}

async function updateFlowWithOptions(request: UpdateFlowRequest, runtime: Util.RuntimeOptions): UpdateFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.definition)) {
    body['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.roleArn)) {
    body['RoleArn'] = request.roleArn;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFlow',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateFlow(request: UpdateFlowRequest): UpdateFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFlowWithOptions(request, runtime);
}

model UpdateScheduleRequest {
  cronExpression?: string(name='CronExpression', example='0 * * * * *'),
  description?: string(name='Description', example='test description'),
  enable?: boolean(name='Enable', example='true'),
  flowName?: string(name='FlowName', example='testFlowName'),
  payload?: string(name='Payload', example='{"key": "value"}'),
  requestId?: string(name='RequestId', example='testRequestId'),
  scheduleName?: string(name='ScheduleName', example='testScheduleName'),
}

model UpdateScheduleResponseBody = {
  createdTime?: string(name='CreatedTime', example='2020-01-01T01:01:01.001Z'),
  cronExpression?: string(name='CronExpression', example='0 * * * * *'),
  description?: string(name='Description', example='test description'),
  enable?: boolean(name='Enable', example='true'),
  lastModifiedTime?: string(name='LastModifiedTime', example='2020-01-01T01:01:01.001Z'),
  payload?: string(name='Payload', example='{"key": "value"}'),
  requestId?: string(name='RequestId', example='testRequestId'),
  scheduleId?: string(name='ScheduleId', example='testScheduleId'),
  scheduleName?: string(name='ScheduleName', example='testScheduleName'),
}

model UpdateScheduleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateScheduleResponseBody(name='body'),
}

async function updateScheduleWithOptions(request: UpdateScheduleRequest, runtime: Util.RuntimeOptions): UpdateScheduleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.cronExpression)) {
    body['CronExpression'] = request.cronExpression;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.enable)) {
    body['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.payload)) {
    body['Payload'] = request.payload;
  }
  if (!Util.isUnset(request.scheduleName)) {
    body['ScheduleName'] = request.scheduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSchedule',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSchedule(request: UpdateScheduleRequest): UpdateScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateScheduleWithOptions(request, runtime);
}

