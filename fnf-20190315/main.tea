/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'cn-beijing.fnf.aliyuncs.com',
    cn-hangzhou = 'cn-hangzhou.fnf.aliyuncs.com',
    cn-shanghai = 'cn-shanghai.fnf.aliyuncs.com',
    cn-shenzhen = 'cn-shenzhen.fnf.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('fnf', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateFlowRequest {
  definition?: string(name='Definition', description='The definition of the flow. The definition must comply with the Flow Definition Language (FDL) syntax.', example='version:&nbsp;v1.0<br/>type:&nbsp;flow<br/>steps:<br/>&nbsp;-&nbsp;type:&nbsp;pass<br/>&nbsp;name:&nbsp;mypass'),
  description?: string(name='Description', description='The description of the flow.', example='test flow'),
  executionMode?: string(name='ExecutionMode', description='The execution mode or the enumeration type. Valid values: Express and Standard. The value Standard indicates an empty string.'),
  externalStorageLocation?: string(name='ExternalStorageLocation', description='The path of the external storage.', example='/path'),
  name?: string(name='Name', description='The name of the flow. The name is unique within the region and cannot be modified after the flow is created. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='flow'),
  requestId?: string(name='RequestId', description='The request ID. If you specify this parameter, the system uses this value as the ID of the request. If you do not specify this parameter, the system generates a value at random.', example='testRequestID'),
  roleArn?: string(name='RoleArn', description='The Alibaba Cloud resource name (ARN) of the specified Resource Access Management (RAM) role that Serverless Workflow assumes to invoke resources when the task is executed.', example='acs:ram:${region}:${accountID}:${role}'),
  type?: string(name='Type', description='The type of the flow. Valid value: **FDL**.', example='FDL'),
}

model CreateFlowResponseBody = {
  createdTime?: string(name='CreatedTime', description='The time when the flow was created.', example='2019-01-01T01:01:01.001Z'),
  definition?: string(name='Definition', description='The definition of the flow.', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n - type: pass\\n name: mypass'),
  description?: string(name='Description', description='The description of the flow.', example='test flow'),
  executionMode?: string(name='ExecutionMode', description='The execution mode or the enumeration type. Valid values: Express and Standard. The value Standard indicates an empty string.'),
  id?: string(name='Id', description='The unique ID of the flow.', example='e589e092-e2c0-4dee-b306-3574ddfdddf5****'),
  lastModifiedTime?: string(name='LastModifiedTime', description='The time when the flow was last modified.', example='2019-01-01T01:01:01.001Z'),
  name?: string(name='Name', description='The name of the flow.', example='flow'),
  requestId?: string(name='RequestId', description='The request ID. Each time an `HTTP status code` is returned, Serverless Workflow returns a value for the parameter.', example='testRequestID'),
  roleArn?: string(name='RoleArn', description='The ARN of the RAM role.', example='acs:ram:${region}:${accountID}:${role}'),
  type?: string(name='Type', description='The type of the flow.', example='FDL'),
}

model CreateFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFlowResponseBody(name='body'),
}

/**
  * ## [](#)Usage notes
  * *   The number of flows that each user can create is restricted by resources. For more information, see [Limits](~~122093~~). If you want to create more flows, submit a ticket.
  * *   At the user level, flows are distinguished by name. The name of a flow within one account must be unique.
  *
  * @param request CreateFlowRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateFlowResponse
 */
async function createFlowWithOptions(request: CreateFlowRequest, runtime: Util.RuntimeOptions): CreateFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.definition)) {
    body['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.executionMode)) {
    body['ExecutionMode'] = request.executionMode;
  }
  if (!Util.isUnset(request.externalStorageLocation)) {
    body['ExternalStorageLocation'] = request.externalStorageLocation;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.roleArn)) {
    body['RoleArn'] = request.roleArn;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlow',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## [](#)Usage notes
  * *   The number of flows that each user can create is restricted by resources. For more information, see [Limits](~~122093~~). If you want to create more flows, submit a ticket.
  * *   At the user level, flows are distinguished by name. The name of a flow within one account must be unique.
  *
  * @param request CreateFlowRequest
  * @return CreateFlowResponse
 */
async function createFlow(request: CreateFlowRequest): CreateFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowWithOptions(request, runtime);
}

model CreateScheduleRequest {
  cronExpression?: string(name='CronExpression', description='The CRON expression.', example='0 * * * * *'),
  description?: string(name='Description', description='The description of the time-based schedule.', example='test description'),
  enable?: boolean(name='Enable', description='Specifies whether to enable the time-based schedule. Valid values:

*   **true**
*   **false**', example='true'),
  flowName?: string(name='FlowName', description='The name of the flow that is bound to the time-based schedule.', example='flow'),
  payload?: string(name='Payload', description='The trigger message of the time-based schedule. Specify the value in the JSON format.', example='{"key": "value"}'),
  requestId?: string(name='RequestId', description='The request ID. If you specify this parameter, the system uses this value as the ID of the request. If you do not specify this parameter, the system generates a value at random.', example='testRequestId'),
  scheduleName?: string(name='ScheduleName', description='The name of the time-based schedule. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='testScheduleName'),
}

model CreateScheduleResponseBody = {
  createdTime?: string(name='CreatedTime', description='The time when the time-based schedule was created.', example='2020-01-01T01:01:01.001Z'),
  cronExpression?: string(name='CronExpression', description='The CRON expression.', example='0 * * * * *'),
  description?: string(name='Description', description='The description of the time-based schedule.', example='test description'),
  enable?: boolean(name='Enable', description='Indicates whether the time-based schedule is enabled.', example='true'),
  lastModifiedTime?: string(name='LastModifiedTime', description='The time when the time-based schedule was last modified.', example='2020-01-01T01:01:01.001Z'),
  payload?: string(name='Payload', description='The trigger message of the time-based schedule.', example='{"key": "value"}'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
  scheduleId?: string(name='ScheduleId', description='The ID of the time-based schedule.', example='testScheduleId'),
  scheduleName?: string(name='ScheduleName', description='The name of the time-based schedule.', example='testScheduleName'),
}

model CreateScheduleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateScheduleResponseBody(name='body'),
}

async function createScheduleWithOptions(request: CreateScheduleRequest, runtime: Util.RuntimeOptions): CreateScheduleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.cronExpression)) {
    body['CronExpression'] = request.cronExpression;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.enable)) {
    body['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.payload)) {
    body['Payload'] = request.payload;
  }
  if (!Util.isUnset(request.scheduleName)) {
    body['ScheduleName'] = request.scheduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSchedule',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSchedule(request: CreateScheduleRequest): CreateScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createScheduleWithOptions(request, runtime);
}

model DeleteFlowRequest {
  name?: string(name='Name', description='The name of the flow. The name can contain letters, digits, underscores (\\_), and hyphens (-) only. It cannot start with a digit or a hyphen (-). It must be 1 to 128 characters in length.', example='flow'),
  requestId?: string(name='RequestId', description='The request ID. If you specify this parameter, the system uses this value as the ID of the request. If you do not specify this parameter, the system generates a value at random.', example='testRequestId'),
}

model DeleteFlowResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
}

model DeleteFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFlowResponseBody(name='body'),
}

/**
  * ## [](#)Usage notes
  * A delete operation is asynchronous. If this operation is successful, the system returns a successful response. If an existing flow is pending to be deleted, a new flow of the same name will not be affected by the existing one. After you delete a flow, you cannot query its historical executions. All executions in progress will stop after their most recent steps are complete.
  *
  * @param request DeleteFlowRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteFlowResponse
 */
async function deleteFlowWithOptions(request: DeleteFlowRequest, runtime: Util.RuntimeOptions): DeleteFlowResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlow',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## [](#)Usage notes
  * A delete operation is asynchronous. If this operation is successful, the system returns a successful response. If an existing flow is pending to be deleted, a new flow of the same name will not be affected by the existing one. After you delete a flow, you cannot query its historical executions. All executions in progress will stop after their most recent steps are complete.
  *
  * @param request DeleteFlowRequest
  * @return DeleteFlowResponse
 */
async function deleteFlow(request: DeleteFlowRequest): DeleteFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowWithOptions(request, runtime);
}

model DeleteScheduleRequest {
  flowName?: string(name='FlowName', description='The name of the flow that is associated with the time-based schedule. The name is unique within the region and cannot be modified after the time-based schedule is created. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='testFlowName'),
  requestId?: string(name='RequestId', description='The request ID. If you specify this parameter, the system uses this value as the ID of the request. If you do not specify this parameter, the system generates a value at random.', example='testRequestId'),
  scheduleName?: string(name='ScheduleName', description='The name of the time-based schedule. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='testScheduleName'),
}

model DeleteScheduleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
}

model DeleteScheduleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteScheduleResponseBody(name='body'),
}

async function deleteScheduleWithOptions(request: DeleteScheduleRequest, runtime: Util.RuntimeOptions): DeleteScheduleResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSchedule',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSchedule(request: DeleteScheduleRequest): DeleteScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteScheduleWithOptions(request, runtime);
}

model DescribeExecutionRequest {
  executionName?: string(name='ExecutionName', description='The name of the execution, which is unique within a flow. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='exec'),
  flowName?: string(name='FlowName', description='The name of the flow. The name is unique within the region and cannot be modified after the flow is created. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='flow'),
  requestId?: string(name='RequestId', description='The request ID. If you specify this parameter, the system uses this value as the ID of the request. If you do not specify this parameter, the system generates a value at random.', example='testRequestId'),
  waitTimeSeconds?: int32(name='WaitTimeSeconds', description='The maximum period of time for long polling waits. Valid values: 0 to 60. Unit: seconds. Configure this parameter based on the following rules:

*   If the value is 0, the system immediately returns the current execution status.
*   If the value is greater than 0, the long polling request waits until the execution ends or the specified period elapses.', example='20'),
}

model DescribeExecutionResponseBody = {
  flowDefinition?: string(name='FlowDefinition', description='The definition of the flow.', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n - type: pass\\n name: mypass'),
  flowName?: string(name='FlowName', description='The name of the flow.', example='flow'),
  input?: string(name='Input', description='The input of the execution, which is in the JSON format.', example='{"key":"value"}'),
  name?: string(name='Name', description='The name of the execution.', example='exec'),
  output?: string(name='Output', description='The execution result, which is in the JSON format.', example='{"key":"value"}'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
  startedTime?: string(name='StartedTime', description='The time when the execution started.', example='2019-01-01T01:01:01.001Z'),
  status?: string(name='Status', description='The execution state. Valid values:

*   **Running**
*   **Stopped**
*   **Succeeded**
*   **Failed**
*   **TimedOut**', example='Succeeded'),
  stoppedTime?: string(name='StoppedTime', description='The time when the execution stopped.', example='2019-01-01T01:01:01.001Z'),
}

model DescribeExecutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeExecutionResponseBody(name='body'),
}

async function describeExecutionWithOptions(request: DescribeExecutionRequest, runtime: Util.RuntimeOptions): DescribeExecutionResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExecution',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeExecution(request: DescribeExecutionRequest): DescribeExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExecutionWithOptions(request, runtime);
}

model DescribeFlowRequest {
  name?: string(name='Name', description='The name of the flow.', example='flow'),
  requestId?: string(name='RequestId', description='The request ID. If you specify this parameter, the system uses this value as the ID of the request. If you do not specify this parameter, the system generates a value at random.', example='testRequestId'),
}

model DescribeFlowResponseBody = {
  createdTime?: string(name='CreatedTime', description='The time when the flow was created.', example='2019-01-01T01:01:01.001Z'),
  definition?: string(name='Definition', description='The definition of the flow. The definition must comply with the Flow Definition Language (FDL) syntax.', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n - type: pass\\n name: mypass'),
  description?: string(name='Description', description='The description of the flow.', example='test flow'),
  executionMode?: string(name='ExecutionMode', description='The execution mode or the enumeration type. Valid values: Express and Standard. The value Standard indicates an empty string.'),
  id?: string(name='Id', description='The unique ID of the flow.', example='e589e092-e2c0-4dee-b306-3574ddfdddf5****'),
  lastModifiedTime?: string(name='LastModifiedTime', description='The time when the flow was last modified.', example='2019-01-01T01:01:01.001Z'),
  name?: string(name='Name', description='The name of the flow.', example='flow'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
  roleArn?: string(name='RoleArn', description='The Alibaba Cloud Resource Name (ARN) of the RAM role.', example='acs:ram::${accountID}:${role}'),
  type?: string(name='Type', description='The type of the flow. Valid value: **FDL**.', example='FDL'),
}

model DescribeFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFlowResponseBody(name='body'),
}

async function describeFlowWithOptions(request: DescribeFlowRequest, runtime: Util.RuntimeOptions): DescribeFlowResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlow',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlow(request: DescribeFlowRequest): DescribeFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowWithOptions(request, runtime);
}

model DescribeScheduleRequest {
  flowName?: string(name='FlowName', description='The name of the flow that is associated with the time-based schedule. The name is unique within the region and cannot be modified after the time-based schedule is created. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='testFlowName'),
  requestId?: string(name='RequestId', description='The request ID. If you specify this parameter, the system uses this value as the ID of the request. If you do not specify this parameter, the system generates a value at random.', example='testRequestId'),
  scheduleName?: string(name='ScheduleName', description='The name of the time-based schedule. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='testScheduleName'),
}

model DescribeScheduleResponseBody = {
  createdTime?: string(name='CreatedTime', description='The time when the time-based schedule was created.', example='2020-01-01T01:01:01.001Z'),
  cronExpression?: string(name='CronExpression', description='The CRON expression.', example='0 * * * * *'),
  description?: string(name='Description', description='The description of the time-based schedule.', example='test description'),
  enable?: boolean(name='Enable', description='Indicates whether the time-based schedule is enabled. Valid values:

*   **true**
*   **false**', example='true'),
  lastModifiedTime?: string(name='LastModifiedTime', description='The time when the time-based schedule was last modified.', example='2020-01-01T01:01:01.001Z'),
  payload?: string(name='Payload', description='The trigger message of the time-based schedule.', example='{"key": "value"}'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
  scheduleId?: string(name='ScheduleId', description='The ID of the time-based schedule.', example='testScheduleId'),
  scheduleName?: string(name='ScheduleName', description='The name of the time-based schedule.', example='testScheduleName'),
}

model DescribeScheduleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeScheduleResponseBody(name='body'),
}

async function describeScheduleWithOptions(request: DescribeScheduleRequest, runtime: Util.RuntimeOptions): DescribeScheduleResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSchedule',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSchedule(request: DescribeScheduleRequest): DescribeScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScheduleWithOptions(request, runtime);
}

model GetExecutionHistoryRequest {
  executionName?: string(name='ExecutionName', description='The name of the execution, which is unique within a flow. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='exec'),
  flowName?: string(name='FlowName', description='The name of the flow. The name is unique within the region and cannot be modified after the flow is created. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='flow'),
  limit?: int32(name='Limit', description='The maximum number of steps to be queried. Valid values: 1 to 1000.', example='1'),
  nextToken?: string(name='NextToken', description='The name of the event to start the query. You can obtain the value from the response data.', example='flow_xxx'),
  requestId?: string(name='RequestId', description='The request ID. If you specify this parameter, the system uses this value as the ID of the request. If you do not specify this parameter, the system generates a value at random.', example='testRequestId'),
}

model GetExecutionHistoryResponseBody = {
  events?: [ 
    {
      eventDetail?: string(name='EventDetail', description='The details about the execution step.', example='{}'),
      eventId?: long(name='EventId', description='The ID of the execution step.', example='2'),
      scheduleEventId?: long(name='ScheduleEventId', description='The ID of the scheduling step.', example='1'),
      stepName?: string(name='StepName', description='The name of the execution step.', example='passStep'),
      time?: string(name='Time', description='The time when the event was updated.', example='2019-01-01T01:01:01.001Z'),
      type?: string(name='Type', description='The type of the execution step. Valid values:

*   **StepEntered**
*   **StepStarted**
*   **StepSucceeded**
*   **StepFailed**
*   **StepExited**
*   **BranchEntered**
*   **BranchExited**
*   **IterationEntered**
*   **IterationExited**
*   **TaskScheduled**
*   **TaskStarted**
*   **TaskSubmitted**
*   **TaskSubmitFailed**
*   **TaskSucceeded**
*   **TaskFailed**
*   **TaskTimedOut**
*   **ExecutionStarted**
*   **ExecutionStopped**
*   **ExecutionSucceeded**
*   **ExecutionFailed**
*   **ExecutionTimedOut**', example='TaskSucceeded'),
    }
  ](name='Events', description='The events.'),
  nextToken?: string(name='NextToken', description='You do not need to specify this parameter for the first request. The returned value of **ScheduleEventId** is used as the token for the next query. No value is returned for the last query.', example='3'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
}

model GetExecutionHistoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExecutionHistoryResponseBody(name='body'),
}

async function getExecutionHistoryWithOptions(request: GetExecutionHistoryRequest, runtime: Util.RuntimeOptions): GetExecutionHistoryResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExecutionHistory',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getExecutionHistory(request: GetExecutionHistoryRequest): GetExecutionHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getExecutionHistoryWithOptions(request, runtime);
}

model ListExecutionsRequest {
  executionNamePrefix?: string(name='ExecutionNamePrefix', description='The name prefix of the execution.', example='run'),
  flowName?: string(name='FlowName', description='The name of the flow. The name is unique within the region and cannot be modified after the flow is created. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='flow'),
  limit?: int32(name='Limit', description='The maximum number of executions to be queried. Valid values: 1 to 100.', example='1'),
  nextToken?: string(name='NextToken', description='The name of the execution to start the query. You can obtain the value from the response data. You do not need to specify this parameter for the first request.', example='flow_xxx'),
  requestId?: string(name='RequestId', description='The request ID. If you specify this parameter, the system uses this value as the ID of the request. If you do not specify this parameter, the system generates a value at random.', example='testRequestId'),
  startedTimeBegin?: string(name='StartedTimeBegin', description='The beginning of the time range to query executions. Specify the value in the UTC RFC3339 format.', example='2020-12-02T02:39:20.402Z'),
  startedTimeEnd?: string(name='StartedTimeEnd', description='The end of the time range to query executions. Specify the value in the UTC RFC3339 format.', example='2020-12-02T02:23:54.817Z'),
  status?: string(name='Status', description='The state of the execution that you want to filter. Valid values:

*   **Running**
*   **Stopped**
*   **Succeeded**
*   **Failed**
*   **TimedOut**', example='Succeeded'),
}

model ListExecutionsResponseBody = {
  executions?: [ 
    {
      flowDefinition?: string(name='FlowDefinition', description='The definition of the flow.', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n  - type: pass\\n    name: mypass'),
      flowName?: string(name='FlowName', description='The name of the flow.', example='flow'),
      input?: string(name='Input', description='The input of the execution, which is in the JSON format.', example='{"key":"value"}'),
      name?: string(name='Name', description='The name of the execution.', example='exec'),
      output?: string(name='Output', description='The execution result, which is in the JSON format.', example='{"key":"value"}'),
      startedTime?: string(name='StartedTime', description='The time when the execution started.', example='2019-01-01T01:01:01.001Z'),
      status?: string(name='Status', description='The state of the execution.', example='Succeeded'),
      stoppedTime?: string(name='StoppedTime', description='The time when the execution stopped.', example='2019-01-01T01:01:01.001Z'),
    }
  ](name='Executions', description='The queried executions.'),
  nextToken?: string(name='NextToken', description='The start key for the next query. This parameter is not returned if all results have been returned.', example='exec2'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
}

model ListExecutionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListExecutionsResponseBody(name='body'),
}

/**
  * ## [](#)Usage notes
  * After you delete a flow, you cannot query its historical executions, even if you create a flow of the same name.
  *
  * @param request ListExecutionsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListExecutionsResponse
 */
async function listExecutionsWithOptions(request: ListExecutionsRequest, runtime: Util.RuntimeOptions): ListExecutionsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListExecutions',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## [](#)Usage notes
  * After you delete a flow, you cannot query its historical executions, even if you create a flow of the same name.
  *
  * @param request ListExecutionsRequest
  * @return ListExecutionsResponse
 */
async function listExecutions(request: ListExecutionsRequest): ListExecutionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExecutionsWithOptions(request, runtime);
}

model ListFlowsRequest {
  limit?: int32(name='Limit', description='The number of flows to be queried. Valid values: 1 to 1000.', example='1'),
  nextToken?: string(name='NextToken', description='The token to start the query.', example='flow_nextxxx'),
  requestId?: string(name='RequestId', description='The request ID. If you specify this parameter, the system uses this value as the ID of the request. If you do not specify this parameter, the system generates a value at random.', example='testRequestId'),
}

model ListFlowsResponseBody = {
  flows?: [ 
    {
      createdTime?: string(name='CreatedTime', description='The time when the flow was created.', example='2019-01-01T01:01:01.001Z'),
      definition?: string(name='Definition', description='The definition of the flow. The definition must comply with the Flow Definition Language (FDL) syntax.', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n - type: pass\\n name: mypass'),
      description?: string(name='Description', description='The description of the flow.', example='test flow'),
      executionMode?: string(name='ExecutionMode', description='The execution mode or the enumeration type. Valid values: Express and Standard. The value Standard indicates an empty string.'),
      id?: string(name='Id', description='The unique ID of the flow.', example='e589e092-e2c0-4dee-b306-3574ddf5****'),
      lastModifiedTime?: string(name='LastModifiedTime', description='The time when the flow was last modified.', example='2019-01-01T01:01:01.001Z'),
      name?: string(name='Name', description='The name of the flow.', example='flow'),
      roleArn?: string(name='RoleArn', description='The Alibaba Cloud Resource Name (ARN) of the Resource Access Management (RAM) role.', example='acs:ram::${accountID}:${role}'),
      type?: string(name='Type', description='The type of the flow.', example='FDL'),
    }
  ](name='Flows', description='The details of flows.'),
  nextToken?: string(name='NextToken', description='The start key for the next query. This parameter is not returned if all results have been returned.', example='flow_nextxxx'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
}

model ListFlowsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFlowsResponseBody(name='body'),
}

async function listFlowsWithOptions(request: ListFlowsRequest, runtime: Util.RuntimeOptions): ListFlowsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFlows',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlows(request: ListFlowsRequest): ListFlowsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowsWithOptions(request, runtime);
}

model ListSchedulesRequest {
  flowName?: string(name='FlowName', description='The name of the flow that is associated with the time-based schedule. The name is unique within the region and cannot be modified after the time-based schedule is created. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='testFlowName'),
  limit?: int32(name='Limit', description='The number of schedules to be queried. Valid values: 1 to 1000.', example='1'),
  nextToken?: string(name='NextToken', description='For the first query, you do not need to specify this parameter. The system uses the value of the **FlowName** parameter as the value of the **NextToken** parameter. When the query ends, no value is returned for this parameter.', example='testNextToken'),
  requestId?: string(name='RequestId', description='The request ID. If you specify this parameter, the system uses this value as the ID of the request. If you do not specify this parameter, the system generates a value at random.', example='testRequestId'),
}

model ListSchedulesResponseBody = {
  nextToken?: string(name='NextToken', description='The token for the next query.', example='testNextToken'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
  schedules?: [ 
    {
      createdTime?: string(name='CreatedTime', description='The time when the time-based schedule was created.', example='2020-01-01T01:01:01.001Z'),
      cronExpression?: string(name='CronExpression', description='The CRON expression of the scheduled task.', example='0 * * * * *'),
      description?: string(name='Description', description='The description of the time-based schedule.', example='test description'),
      enable?: boolean(name='Enable', description='Indicates whether the time-based schedule is enabled. Valid values:

*   **true**
*   **false**', example='true'),
      lastModifiedTime?: string(name='LastModifiedTime', description='The time when the time-based schedule was last modified.', example='2020-01-01T01:01:01.001Z'),
      payload?: string(name='Payload', description='The trigger message of the time-based schedule.', example='{"key": "value"}'),
      scheduleId?: string(name='ScheduleId', description='The ID of the time-based schedule.', example='testScheduleId'),
      scheduleName?: string(name='ScheduleName', description='The name of the time-based schedule.', example='testScheduleName'),
    }
  ](name='Schedules', description='The time-based schedules that are queried.'),
}

model ListSchedulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSchedulesResponseBody(name='body'),
}

async function listSchedulesWithOptions(request: ListSchedulesRequest, runtime: Util.RuntimeOptions): ListSchedulesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSchedules',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSchedules(request: ListSchedulesRequest): ListSchedulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSchedulesWithOptions(request, runtime);
}

model ReportTaskFailedRequest {
  cause?: string(name='Cause', description='The cause of the failure. The value must be 1 to 4,096 characters in length.', example='emptyString'),
  error?: string(name='Error', description='The error code for the failed task. The value must be 1 to 128 characters in length.', example='nill'),
  requestId?: string(name='RequestId', description='The request ID. If you specify this parameter, the system uses this value as the ID of the request. If you do not specify this parameter, the system generates a value at random.', example='testRequestId'),
  taskToken?: string(name='TaskToken', description='The token of the specified task that you want to report. If this parameter appears in **waitforCallback** mode, the parameter is passed to the called service, such as Message Service (MNS) or Function Compute. For MNS, the value of this parameter can be obtained from a message. For Function Compute, the value of this parameter can be obtained from an event.', example='emptyString'),
}

model ReportTaskFailedResponseBody = {
  eventId?: long(name='EventId', description='The ID of the event.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
}

model ReportTaskFailedResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReportTaskFailedResponseBody(name='body'),
}

/**
  * ## [](#)Usage notes
  * You can use this operation to call back the task step of `pattern: waitForCallback`, which indicates that the current task fails to be executed.
  *
  * @param request ReportTaskFailedRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ReportTaskFailedResponse
 */
async function reportTaskFailedWithOptions(request: ReportTaskFailedRequest, runtime: Util.RuntimeOptions): ReportTaskFailedResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.taskToken)) {
    query['TaskToken'] = request.taskToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.cause)) {
    body['Cause'] = request.cause;
  }
  if (!Util.isUnset(request.error)) {
    body['Error'] = request.error;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReportTaskFailed',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## [](#)Usage notes
  * You can use this operation to call back the task step of `pattern: waitForCallback`, which indicates that the current task fails to be executed.
  *
  * @param request ReportTaskFailedRequest
  * @return ReportTaskFailedResponse
 */
async function reportTaskFailed(request: ReportTaskFailedRequest): ReportTaskFailedResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportTaskFailedWithOptions(request, runtime);
}

model ReportTaskSucceededRequest {
  output?: string(name='Output', description='The output information of the task whose execution success you want to report.', example='{"key":"value"}'),
  requestId?: string(name='RequestId', description='The request ID. If you specify this parameter, the system uses this value as the ID of the request. If you do not specify this parameter, the system generates a value at random.', example='testRequestId'),
  taskToken?: string(name='TaskToken', description='The token of the task whose execution success you want to report. If this parameter appears in **waitforCallback** mode, the parameter is passed to the called service, such as Message Service (MNS) or Function Compute. For MNS, the value of this parameter can be obtained from the message. For Function Compute, the value of this parameter can be obtained from the event.', example='emptyString'),
}

model ReportTaskSucceededResponseBody = {
  eventId?: long(name='EventId', description='The ID of the event.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
}

model ReportTaskSucceededResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReportTaskSucceededResponseBody(name='body'),
}

/**
  * ## [](#)Usage notes
  * You can use this operation to call back the task step of `pattern: waitForCallback`, which indicates that the current task is successfully executed.
  *
  * @param request ReportTaskSucceededRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ReportTaskSucceededResponse
 */
async function reportTaskSucceededWithOptions(request: ReportTaskSucceededRequest, runtime: Util.RuntimeOptions): ReportTaskSucceededResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.taskToken)) {
    query['TaskToken'] = request.taskToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.output)) {
    body['Output'] = request.output;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReportTaskSucceeded',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## [](#)Usage notes
  * You can use this operation to call back the task step of `pattern: waitForCallback`, which indicates that the current task is successfully executed.
  *
  * @param request ReportTaskSucceededRequest
  * @return ReportTaskSucceededResponse
 */
async function reportTaskSucceeded(request: ReportTaskSucceededRequest): ReportTaskSucceededResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportTaskSucceededWithOptions(request, runtime);
}

model StartExecutionRequest {
  callbackFnFTaskToken?: string(name='CallbackFnFTaskToken', description='Specifies that the **TaskToken**-related tasks are called back after the execution in the flow ends.', example='12'),
  executionName?: string(name='ExecutionName', description='The name of the execution, which is unique within a flow. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='exec'),
  flowName?: string(name='FlowName', description='The name of the flow you want to start to execute. The name is unique within the region and cannot be modified after the flow is created. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='flow'),
  input?: string(name='Input', description='The input of the execution, which is in the JSON format.', example='{"key":"value"}'),
  requestId?: string(name='RequestId', description='The request ID. If you specify this parameter, the system uses this value as the ID of the request. If you do not specify this parameter, the system generates a value at random.', example='testRequestId'),
}

model StartExecutionResponseBody = {
  flowDefinition?: string(name='FlowDefinition', description='The definition of the flow.', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n - type: pass\\n name: mypass'),
  flowName?: string(name='FlowName', description='The name of the flow.', example='flow'),
  input?: string(name='Input', description='The input of the execution, which is in the JSON format.', example='{"key":"value"}'),
  name?: string(name='Name', description='The name of the execution.', example='exec1'),
  output?: string(name='Output', description='The execution result, which is in the JSON format.', example='{"key":"value"}'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
  startedTime?: string(name='StartedTime', description='The time when the execution started.', example='2019-01-01T01:01:01.001Z'),
  status?: string(name='Status', description='The execution state. Valid values:

*   **Running**
*   **Stopped**
*   **Succeeded**
*   **Failed**
*   **TimedOut**', example='Succeeded'),
  stoppedTime?: string(name='StoppedTime', description='The time when the execution stopped.', example='2019-01-01T01:01:01.001Z'),
}

model StartExecutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartExecutionResponseBody(name='body'),
}

/**
  * ## [](#)Usage notes
  * *   The flow is created.
  * *   If you do not specify an execution, the system automatically generates an execution and starts the execution.
  * *   If an ongoing execution has the same name as that of the execution to be started, the system directly returns the ongoing execution.
  * *   If the ongoing execution with the same name has ended (succeeded or failed), the `ExecutionAlreadyExists` error is returned.
  * *   If no execution with the same name exists, the system starts a new execution.
  *
  * @param request StartExecutionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return StartExecutionResponse
 */
async function startExecutionWithOptions(request: StartExecutionRequest, runtime: Util.RuntimeOptions): StartExecutionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.callbackFnFTaskToken)) {
    body['CallbackFnFTaskToken'] = request.callbackFnFTaskToken;
  }
  if (!Util.isUnset(request.executionName)) {
    body['ExecutionName'] = request.executionName;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.input)) {
    body['Input'] = request.input;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartExecution',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## [](#)Usage notes
  * *   The flow is created.
  * *   If you do not specify an execution, the system automatically generates an execution and starts the execution.
  * *   If an ongoing execution has the same name as that of the execution to be started, the system directly returns the ongoing execution.
  * *   If the ongoing execution with the same name has ended (succeeded or failed), the `ExecutionAlreadyExists` error is returned.
  * *   If no execution with the same name exists, the system starts a new execution.
  *
  * @param request StartExecutionRequest
  * @return StartExecutionResponse
 */
async function startExecution(request: StartExecutionRequest): StartExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return startExecutionWithOptions(request, runtime);
}

model StartSyncExecutionRequest {
  executionName?: string(name='ExecutionName', example='my_exec_name'),
  flowName?: string(name='FlowName', example='my_flow_name'),
  input?: string(name='Input', example='{"key":"value"}'),
  requestId?: string(name='RequestId', example='testRequestId'),
}

model StartSyncExecutionResponseBody = {
  errorCode?: string(name='ErrorCode', example='ActionNotSupported'),
  errorMessage?: string(name='ErrorMessage', example='Standard execution is not supported'),
  flowName?: string(name='FlowName', example='my_flow_name'),
  name?: string(name='Name', example='my_exec_name:{UUID}'),
  output?: string(name='Output', example='{"key":"value"}'),
  requestId?: string(name='RequestId', example='testRequestId'),
  startedTime?: string(name='StartedTime', example='2019-01-01T01:01:01.001Z'),
  status?: string(name='Status', example='Succeeded'),
  stoppedTime?: string(name='StoppedTime', example='2019-01-01T01:01:01.001Z'),
}

model StartSyncExecutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartSyncExecutionResponseBody(name='body'),
}

async function startSyncExecutionWithOptions(request: StartSyncExecutionRequest, runtime: Util.RuntimeOptions): StartSyncExecutionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.executionName)) {
    body['ExecutionName'] = request.executionName;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.input)) {
    body['Input'] = request.input;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartSyncExecution',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startSyncExecution(request: StartSyncExecutionRequest): StartSyncExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return startSyncExecutionWithOptions(request, runtime);
}

model StopExecutionRequest {
  cause?: string(name='Cause', description='The reason for stopping the execution. The value must be 1 to 4,096 characters in length.', example='for test'),
  error?: string(name='Error', description='The error for stopping the execution. The value must be 1 to 128 characters in length.', example='nill'),
  executionName?: string(name='ExecutionName', description='The name of the execution that you want to stop. You can call the **ListExecutions** operation to obtain the value of this parameter. The name is unique in a flow. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='exec'),
  flowName?: string(name='FlowName', description='The name of the flow that you want to stop. You can call the **ListFlows** operation to obtain the value of this parameter. The name is unique within the region and cannot be modified after the flow is created. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='flow'),
  requestId?: string(name='RequestId', description='The request ID. If you specify this parameter, the system uses this value as the ID of the request. If you do not specify this parameter, the system generates a value at random.', example='testRequestId'),
}

model StopExecutionResponseBody = {
  flowDefinition?: string(name='FlowDefinition', description='The definition of the flow.', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n - type: pass\\n name: mypass'),
  flowName?: string(name='FlowName', description='The name of the flow.', example='flow'),
  input?: string(name='Input', description='The input of the execution, which is in the JSON format.', example='{"key":"value"}'),
  name?: string(name='Name', description='The name of the execution.', example='exec'),
  output?: string(name='Output', description='The execution result, which is in the JSON format.', example='{"key":"value"}'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
  startedTime?: string(name='StartedTime', description='The time when the execution started.', example='2019-01-01T01:01:01.001Z'),
  status?: string(name='Status', description='The execution state. Valid values:

*   **Running**
*   **Stopped**
*   **Succeeded**
*   **Failed**
*   **TimedOut**', example='Running'),
  stoppedTime?: string(name='StoppedTime', description='The time when the execution stopped.', example='2019-01-01T01:01:01.001Z'),
}

model StopExecutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopExecutionResponseBody(name='body'),
}

/**
  * ## [](#)Usage notes
  * The flow must be in progress.
  *
  * @param request StopExecutionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return StopExecutionResponse
 */
async function stopExecutionWithOptions(request: StopExecutionRequest, runtime: Util.RuntimeOptions): StopExecutionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.cause)) {
    body['Cause'] = request.cause;
  }
  if (!Util.isUnset(request.error)) {
    body['Error'] = request.error;
  }
  if (!Util.isUnset(request.executionName)) {
    body['ExecutionName'] = request.executionName;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopExecution',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## [](#)Usage notes
  * The flow must be in progress.
  *
  * @param request StopExecutionRequest
  * @return StopExecutionResponse
 */
async function stopExecution(request: StopExecutionRequest): StopExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopExecutionWithOptions(request, runtime);
}

model UpdateFlowRequest {
  definition?: string(name='Definition', description='The definition of the flow. The definition must comply with the Flow Definition Language (FDL) syntax.', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n  - type: pass\\n    name: mypass'),
  description?: string(name='Description', description='The description of the flow.', example='test definition'),
  name?: string(name='Name', description='The name of the flow. The name is unique within the region and cannot be modified after the time-based schedule is created. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='flow'),
  requestId?: string(name='RequestId', description='The request ID. If you specify this parameter, the system uses this value as the ID of the request. If you do not specify this parameter, the system generates a value at random.', example='testRequestId'),
  roleArn?: string(name='RoleArn', description='The Alibaba Cloud resource name (ARN) of the specified Resource Access Management (RAM) role that Serverless Workflow assumes to invoke resources when the task is executed.', example='acs:ram::${accountID}:${role}'),
  type?: string(name='Type', description='The type of the flow. Valid value: **FDL**.', example='FDL'),
}

model UpdateFlowResponseBody = {
  createdTime?: string(name='CreatedTime', description='The time when the flow was created.', example='2019-01-01T01:01:01.001Z'),
  definition?: string(name='Definition', description='The definition of the flow.', example='version: v1.0\\ntype: flow\\nname: test\\nsteps:\\n  - type: pass\\n    name: mypass'),
  description?: string(name='Description', description='The description of the flow.', example='test definition'),
  externalStorageLocation?: string(name='ExternalStorageLocation', description='The path of the external storage.', example='/path'),
  id?: string(name='Id', description='The unique ID of the flow.', example='e589e092-e2c0-4dee-b306-3574ddfdddf5****'),
  lastModifiedTime?: string(name='LastModifiedTime', description='The time when the flow was last modified.', example='2019-01-01T01:01:01.001Z'),
  name?: string(name='Name', description='The name of the flow.', example='flow'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestID'),
  roleArn?: string(name='RoleArn', description='The ARN of the RAM role.', example='acs:ram::${accountID}:${role}'),
  type?: string(name='Type', description='The type of the flow.', example='FDL'),
}

model UpdateFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFlowResponseBody(name='body'),
}

async function updateFlowWithOptions(request: UpdateFlowRequest, runtime: Util.RuntimeOptions): UpdateFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.definition)) {
    body['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.roleArn)) {
    body['RoleArn'] = request.roleArn;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFlow',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateFlow(request: UpdateFlowRequest): UpdateFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFlowWithOptions(request, runtime);
}

model UpdateScheduleRequest {
  cronExpression?: string(name='CronExpression', description='The CRON expression.', example='0 * * * * *'),
  description?: string(name='Description', description='The description of the time-based schedule.', example='test description'),
  enable?: boolean(name='Enable', description='Specifies whether to enable the time-based schedule. Valid values:

*   **true**
*   **false**', example='true'),
  flowName?: string(name='FlowName', description='The name of the flow that is associated with the time-based schedule. The name is unique within the region and cannot be modified after the time-based schedule is created. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='testFlowName'),
  payload?: string(name='Payload', description='The trigger message of the time-based schedule. It must be in the JSON format.', example='{"key": "value"}'),
  requestId?: string(name='RequestId', description='The request ID. If you specify this parameter, the system uses this value as the ID of the request. If you do not specify this parameter, the system generates a value at random.', example='testRequestId'),
  scheduleName?: string(name='ScheduleName', description='The name of the time-based schedule. Configure this parameter based on the following rules:

*   The name can contain letters, digits, underscores (\\_), and hyphens (-).
*   The name must start with a letter or an underscore (\\_).
*   The name is case-sensitive.
*   The name must be 1 to 128 characters in length.', example='testScheduleName'),
}

model UpdateScheduleResponseBody = {
  createdTime?: string(name='CreatedTime', description='The time when the time-based schedule was created.', example='2020-01-01T01:01:01.001Z'),
  cronExpression?: string(name='CronExpression', description='The CRON expression.', example='0 * * * * *'),
  description?: string(name='Description', description='The description of the time-based schedule.', example='test description'),
  enable?: boolean(name='Enable', description='Indicates whether the time-based schedule is enabled. Valid values:

*   **true**
*   **false**', example='true'),
  lastModifiedTime?: string(name='LastModifiedTime', description='The time when the time-based schedule was last updated.', example='2020-01-01T01:01:01.001Z'),
  payload?: string(name='Payload', description='The trigger message of the time-based schedule.', example='{"key": "value"}'),
  requestId?: string(name='RequestId', description='The request ID.', example='testRequestId'),
  scheduleId?: string(name='ScheduleId', description='The ID of the time-based schedule.', example='testScheduleId'),
  scheduleName?: string(name='ScheduleName', description='The name of the time-based schedule.', example='testScheduleName'),
}

model UpdateScheduleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateScheduleResponseBody(name='body'),
}

async function updateScheduleWithOptions(request: UpdateScheduleRequest, runtime: Util.RuntimeOptions): UpdateScheduleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.cronExpression)) {
    body['CronExpression'] = request.cronExpression;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.enable)) {
    body['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.payload)) {
    body['Payload'] = request.payload;
  }
  if (!Util.isUnset(request.scheduleName)) {
    body['ScheduleName'] = request.scheduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSchedule',
    version = '2019-03-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSchedule(request: UpdateScheduleRequest): UpdateScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateScheduleWithOptions(request, runtime);
}

