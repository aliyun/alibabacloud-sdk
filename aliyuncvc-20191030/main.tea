/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('aliyuncvc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ActiveDeviceRequest {
  activeCode?: string(name='ActiveCode'),
  deviceVersion?: string(name='DeviceVersion'),
  IP?: string(name='IP'),
  mac?: string(name='Mac'),
  SN?: string(name='SN'),
}

model ActiveDeviceResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  token?: string(name='Token'),
}

model ActiveDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ActiveDeviceResponseBody(name='body'),
}

async function activeDeviceWithOptions(request: ActiveDeviceRequest, runtime: Util.RuntimeOptions): ActiveDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.activeCode)) {
    body['ActiveCode'] = request.activeCode;
  }
  if (!Util.isUnset(request.deviceVersion)) {
    body['DeviceVersion'] = request.deviceVersion;
  }
  if (!Util.isUnset(request.IP)) {
    body['IP'] = request.IP;
  }
  if (!Util.isUnset(request.mac)) {
    body['Mac'] = request.mac;
  }
  if (!Util.isUnset(request.SN)) {
    body['SN'] = request.SN;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ActiveDevice',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function activeDevice(request: ActiveDeviceRequest): ActiveDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return activeDeviceWithOptions(request, runtime);
}

model ActiveMeetingRequest {
  meetingCode?: string(name='MeetingCode'),
  meetingUUID?: string(name='MeetingUUID'),
}

model ActiveMeetingResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  meetingInfo?: {
    meetingCode?: string(name='MeetingCode'),
    validTime?: long(name='ValidTime'),
  }(name='MeetingInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ActiveMeetingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ActiveMeetingResponseBody(name='body'),
}

async function activeMeetingWithOptions(request: ActiveMeetingRequest, runtime: Util.RuntimeOptions): ActiveMeetingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.meetingCode)) {
    query['MeetingCode'] = request.meetingCode;
  }
  if (!Util.isUnset(request.meetingUUID)) {
    query['MeetingUUID'] = request.meetingUUID;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ActiveMeeting',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function activeMeeting(request: ActiveMeetingRequest): ActiveMeetingResponse {
  var runtime = new Util.RuntimeOptions{};
  return activeMeetingWithOptions(request, runtime);
}

model BatchCreateDeviceRequest {
  SN?: string(name='SN'),
}

model BatchCreateDeviceResponseBody = {
  devices?: [ 
    {
      activeCode?: string(name='ActiveCode'),
      deviceErrorCode?: int32(name='DeviceErrorCode'),
      deviceMessage?: string(name='DeviceMessage'),
      SN?: string(name='SN'),
    }
  ](name='Devices'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchCreateDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchCreateDeviceResponseBody(name='body'),
}

async function batchCreateDeviceWithOptions(request: BatchCreateDeviceRequest, runtime: Util.RuntimeOptions): BatchCreateDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.SN)) {
    body['SN'] = request.SN;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchCreateDevice',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchCreateDevice(request: BatchCreateDeviceRequest): BatchCreateDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchCreateDeviceWithOptions(request, runtime);
}

model BatchJoinMeetingRequest {
  meetingCode?: string(name='MeetingCode'),
  password?: string(name='Password'),
  rtcEngine?: string(name='RtcEngine'),
  userId?: string(name='UserId'),
}

model BatchJoinMeetingResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  meetingInfo?: {
    clientAppId?: string(name='ClientAppId'),
    meetingAppId?: string(name='MeetingAppId'),
    meetingCode?: string(name='MeetingCode'),
    meetingDomain?: string(name='MeetingDomain'),
    meetingUUID?: string(name='MeetingUUID'),
    memberList?: [ 
      {
        meetingToken?: string(name='MeetingToken'),
        memberUUID?: string(name='MemberUUID'),
        userId?: string(name='UserId'),
      }
    ](name='MemberList'),
    slsInfo?: {
      logServiceEndpoint?: string(name='LogServiceEndpoint'),
      logstore?: string(name='Logstore'),
      project?: string(name='Project'),
    }(name='SlsInfo'),
  }(name='MeetingInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchJoinMeetingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchJoinMeetingResponseBody(name='body'),
}

async function batchJoinMeetingWithOptions(request: BatchJoinMeetingRequest, runtime: Util.RuntimeOptions): BatchJoinMeetingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meetingCode)) {
    body['MeetingCode'] = request.meetingCode;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.rtcEngine)) {
    body['RtcEngine'] = request.rtcEngine;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchJoinMeeting',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchJoinMeeting(request: BatchJoinMeetingRequest): BatchJoinMeetingResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchJoinMeetingWithOptions(request, runtime);
}

model BatchJoinMeetingInternationalRequest {
  meetingCode?: string(name='MeetingCode'),
  password?: string(name='Password'),
  userId?: string(name='UserId'),
}

model BatchJoinMeetingInternationalResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  meetingInfo?: {
    clientAppId?: string(name='ClientAppId'),
    meetingAppId?: string(name='MeetingAppId'),
    meetingCode?: string(name='MeetingCode'),
    meetingDomain?: string(name='MeetingDomain'),
    meetingToken?: string(name='MeetingToken'),
    meetingUUID?: string(name='MeetingUUID'),
    memberList?: [ 
      {
        meetingToken?: string(name='MeetingToken'),
        memberUUID?: string(name='MemberUUID'),
        userId?: string(name='UserId'),
      }
    ](name='MemberList'),
    slsInfo?: {
      logServiceEndpoint?: string(name='LogServiceEndpoint'),
      logstore?: string(name='Logstore'),
      project?: string(name='Project'),
    }(name='SlsInfo'),
  }(name='MeetingInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchJoinMeetingInternationalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchJoinMeetingInternationalResponseBody(name='body'),
}

async function batchJoinMeetingInternationalWithOptions(request: BatchJoinMeetingInternationalRequest, runtime: Util.RuntimeOptions): BatchJoinMeetingInternationalResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meetingCode)) {
    body['MeetingCode'] = request.meetingCode;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchJoinMeetingInternational',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchJoinMeetingInternational(request: BatchJoinMeetingInternationalRequest): BatchJoinMeetingInternationalResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchJoinMeetingInternationalWithOptions(request, runtime);
}

model CallDeviceRequest {
  inviteName?: string(name='InviteName'),
  joinMeetingFlag?: boolean(name='JoinMeetingFlag'),
  meetingCode?: string(name='MeetingCode'),
  operateUserId?: string(name='OperateUserId'),
  SN?: string(name='SN'),
}

model CallDeviceResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  messageId?: string(name='MessageId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CallDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CallDeviceResponseBody(name='body'),
}

async function callDeviceWithOptions(request: CallDeviceRequest, runtime: Util.RuntimeOptions): CallDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.joinMeetingFlag)) {
    query['JoinMeetingFlag'] = request.joinMeetingFlag;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.inviteName)) {
    body['InviteName'] = request.inviteName;
  }
  if (!Util.isUnset(request.meetingCode)) {
    body['MeetingCode'] = request.meetingCode;
  }
  if (!Util.isUnset(request.operateUserId)) {
    body['OperateUserId'] = request.operateUserId;
  }
  if (!Util.isUnset(request.SN)) {
    body['SN'] = request.SN;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CallDevice',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function callDevice(request: CallDeviceRequest): CallDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return callDeviceWithOptions(request, runtime);
}

model ConferenceToLiveRequest {
  liveName?: string(name='LiveName'),
  meetingUUID?: string(name='MeetingUUID'),
  openPasswordFlag?: boolean(name='OpenPasswordFlag'),
  password?: string(name='Password'),
  userId?: string(name='UserId'),
}

model ConferenceToLiveResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  liveInfo?: {
    liveUUID?: string(name='LiveUUID'),
  }(name='LiveInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConferenceToLiveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConferenceToLiveResponseBody(name='body'),
}

async function conferenceToLiveWithOptions(request: ConferenceToLiveRequest, runtime: Util.RuntimeOptions): ConferenceToLiveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.liveName)) {
    body['LiveName'] = request.liveName;
  }
  if (!Util.isUnset(request.meetingUUID)) {
    body['MeetingUUID'] = request.meetingUUID;
  }
  if (!Util.isUnset(request.openPasswordFlag)) {
    body['OpenPasswordFlag'] = request.openPasswordFlag;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ConferenceToLive',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function conferenceToLive(request: ConferenceToLiveRequest): ConferenceToLiveResponse {
  var runtime = new Util.RuntimeOptions{};
  return conferenceToLiveWithOptions(request, runtime);
}

model CreateDeviceMeetingRequest {
  meetingName?: string(name='MeetingName'),
  openPasswordtag?: boolean(name='OpenPasswordtag'),
  password?: string(name='Password'),
  SN?: string(name='SN'),
  token?: string(name='Token'),
}

model CreateDeviceMeetingResponseBody = {
  devices?: {
    meetingCode?: string(name='MeetingCode'),
    meetingUUID?: string(name='MeetingUUID'),
  }(name='Devices'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDeviceMeetingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDeviceMeetingResponseBody(name='body'),
}

async function createDeviceMeetingWithOptions(request: CreateDeviceMeetingRequest, runtime: Util.RuntimeOptions): CreateDeviceMeetingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meetingName)) {
    body['MeetingName'] = request.meetingName;
  }
  if (!Util.isUnset(request.openPasswordtag)) {
    body['OpenPasswordtag'] = request.openPasswordtag;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.SN)) {
    body['SN'] = request.SN;
  }
  if (!Util.isUnset(request.token)) {
    body['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDeviceMeeting',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDeviceMeeting(request: CreateDeviceMeetingRequest): CreateDeviceMeetingResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDeviceMeetingWithOptions(request, runtime);
}

model CreateEvaluationRequest {
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  evaluation?: string(name='Evaluation'),
  meetingUUID?: string(name='MeetingUUID'),
  memberUUID?: string(name='MemberUUID'),
  memo?: string(name='Memo'),
  score?: string(name='Score'),
  userId?: string(name='UserId'),
}

model CreateEvaluationResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateEvaluationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEvaluationResponseBody(name='body'),
}

async function createEvaluationWithOptions(request: CreateEvaluationRequest, runtime: Util.RuntimeOptions): CreateEvaluationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createTime)) {
    query['CreateTime'] = request.createTime;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.evaluation)) {
    query['Evaluation'] = request.evaluation;
  }
  if (!Util.isUnset(request.meetingUUID)) {
    query['MeetingUUID'] = request.meetingUUID;
  }
  if (!Util.isUnset(request.memberUUID)) {
    query['MemberUUID'] = request.memberUUID;
  }
  if (!Util.isUnset(request.memo)) {
    query['Memo'] = request.memo;
  }
  if (!Util.isUnset(request.score)) {
    query['Score'] = request.score;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEvaluation',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createEvaluation(request: CreateEvaluationRequest): CreateEvaluationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEvaluationWithOptions(request, runtime);
}

model CreateLiveRequest {
  liveName?: string(name='LiveName'),
  openPasswordFlag?: boolean(name='OpenPasswordFlag'),
  password?: string(name='Password'),
  userId?: string(name='UserId'),
}

model CreateLiveResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  liveInfo?: {
    liveUUID?: string(name='LiveUUID'),
    streamUUID?: string(name='StreamUUID'),
  }(name='LiveInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateLiveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLiveResponseBody(name='body'),
}

async function createLiveWithOptions(request: CreateLiveRequest, runtime: Util.RuntimeOptions): CreateLiveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.liveName)) {
    body['LiveName'] = request.liveName;
  }
  if (!Util.isUnset(request.openPasswordFlag)) {
    body['OpenPasswordFlag'] = request.openPasswordFlag;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLive',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLive(request: CreateLiveRequest): CreateLiveResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLiveWithOptions(request, runtime);
}

model CreateMeetingRequest {
  masterEnableFlag?: boolean(name='MasterEnableFlag'),
  meetingMode?: string(name='MeetingMode'),
  meetingName?: string(name='MeetingName'),
  openPasswordFlag?: boolean(name='OpenPasswordFlag'),
  password?: string(name='Password'),
  tenantCode?: string(name='TenantCode'),
  userId?: string(name='UserId'),
}

model CreateMeetingResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  meetingInfo?: {
    meetingCode?: string(name='MeetingCode'),
    meetingUUID?: string(name='MeetingUUID'),
  }(name='MeetingInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateMeetingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMeetingResponseBody(name='body'),
}

async function createMeetingWithOptions(request: CreateMeetingRequest, runtime: Util.RuntimeOptions): CreateMeetingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tenantCode)) {
    query['TenantCode'] = request.tenantCode;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.masterEnableFlag)) {
    body['MasterEnableFlag'] = request.masterEnableFlag;
  }
  if (!Util.isUnset(request.meetingMode)) {
    body['MeetingMode'] = request.meetingMode;
  }
  if (!Util.isUnset(request.meetingName)) {
    body['MeetingName'] = request.meetingName;
  }
  if (!Util.isUnset(request.openPasswordFlag)) {
    body['OpenPasswordFlag'] = request.openPasswordFlag;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMeeting',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMeeting(request: CreateMeetingRequest): CreateMeetingResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMeetingWithOptions(request, runtime);
}

model CreateMeetingInternationalRequest {
  meetingName?: string(name='MeetingName'),
  openPasswordFlag?: string(name='OpenPasswordFlag'),
  password?: string(name='Password'),
  userId?: string(name='UserId'),
}

model CreateMeetingInternationalResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  meetingInfo?: {
    meetingCode?: string(name='MeetingCode'),
    meetingUUID?: string(name='MeetingUUID'),
  }(name='MeetingInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateMeetingInternationalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMeetingInternationalResponseBody(name='body'),
}

async function createMeetingInternationalWithOptions(request: CreateMeetingInternationalRequest, runtime: Util.RuntimeOptions): CreateMeetingInternationalResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meetingName)) {
    body['MeetingName'] = request.meetingName;
  }
  if (!Util.isUnset(request.openPasswordFlag)) {
    body['OpenPasswordFlag'] = request.openPasswordFlag;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMeetingInternational',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMeetingInternational(request: CreateMeetingInternationalRequest): CreateMeetingInternationalResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMeetingInternationalWithOptions(request, runtime);
}

model CreateUserRequest {
  count?: int32(name='Count'),
  tenantCode?: string(name='TenantCode'),
  userInfo?: string(name='UserInfo'),
}

model CreateUserResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  userId?: string(name='UserId'),
}

model CreateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUserResponseBody(name='body'),
}

async function createUserWithOptions(request: CreateUserRequest, runtime: Util.RuntimeOptions): CreateUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tenantCode)) {
    query['TenantCode'] = request.tenantCode;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    body['Count'] = request.count;
  }
  if (!Util.isUnset(request.userInfo)) {
    body['UserInfo'] = request.userInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateUser',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserWithOptions(request, runtime);
}

model CreateUserInternationalRequest {
  count?: int32(name='Count'),
  userInfo?: string(name='UserInfo'),
}

model CreateUserInternationalResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  userId?: string(name='UserId'),
}

model CreateUserInternationalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUserInternationalResponseBody(name='body'),
}

async function createUserInternationalWithOptions(request: CreateUserInternationalRequest, runtime: Util.RuntimeOptions): CreateUserInternationalResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    body['Count'] = request.count;
  }
  if (!Util.isUnset(request.userInfo)) {
    body['UserInfo'] = request.userInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateUserInternational',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUserInternational(request: CreateUserInternationalRequest): CreateUserInternationalResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserInternationalWithOptions(request, runtime);
}

model CustomGonggeLayoutRequest {
  layoutSolution?: string(name='LayoutSolution'),
  meetingUUID?: string(name='MeetingUUID'),
}

model CustomGonggeLayoutResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CustomGonggeLayoutResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CustomGonggeLayoutResponseBody(name='body'),
}

async function customGonggeLayoutWithOptions(request: CustomGonggeLayoutRequest, runtime: Util.RuntimeOptions): CustomGonggeLayoutResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.layoutSolution)) {
    body['LayoutSolution'] = request.layoutSolution;
  }
  if (!Util.isUnset(request.meetingUUID)) {
    body['MeetingUUID'] = request.meetingUUID;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CustomGonggeLayout',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function customGonggeLayout(request: CustomGonggeLayoutRequest): CustomGonggeLayoutResponse {
  var runtime = new Util.RuntimeOptions{};
  return customGonggeLayoutWithOptions(request, runtime);
}

model CustomLayoutRequest {
  layoutInfo?: string(name='LayoutInfo'),
  liveUUID?: string(name='LiveUUID'),
}

model CustomLayoutResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CustomLayoutResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CustomLayoutResponseBody(name='body'),
}

async function customLayoutWithOptions(request: CustomLayoutRequest, runtime: Util.RuntimeOptions): CustomLayoutResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.layoutInfo)) {
    body['LayoutInfo'] = request.layoutInfo;
  }
  if (!Util.isUnset(request.liveUUID)) {
    body['LiveUUID'] = request.liveUUID;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CustomLayout',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function customLayout(request: CustomLayoutRequest): CustomLayoutResponse {
  var runtime = new Util.RuntimeOptions{};
  return customLayoutWithOptions(request, runtime);
}

model DeleteDeviceRequest {
  groupId?: string(name='GroupId'),
  SN?: string(name='SN'),
}

model DeleteDeviceResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDeviceResponseBody(name='body'),
}

async function deleteDeviceWithOptions(request: DeleteDeviceRequest, runtime: Util.RuntimeOptions): DeleteDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.SN)) {
    body['SN'] = request.SN;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDevice',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDevice(request: DeleteDeviceRequest): DeleteDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeviceWithOptions(request, runtime);
}

model DeleteLiveRequest {
  liveUUID?: string(name='LiveUUID'),
  userId?: string(name='UserId'),
}

model DeleteLiveResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteLiveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLiveResponseBody(name='body'),
}

async function deleteLiveWithOptions(request: DeleteLiveRequest, runtime: Util.RuntimeOptions): DeleteLiveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.liveUUID)) {
    body['LiveUUID'] = request.liveUUID;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLive',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLive(request: DeleteLiveRequest): DeleteLiveResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLiveWithOptions(request, runtime);
}

model DeleteMeetingRequest {
  meetingUUID?: string(name='MeetingUUID'),
  tenantCode?: string(name='TenantCode'),
  userId?: string(name='UserId'),
}

model DeleteMeetingResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMeetingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMeetingResponseBody(name='body'),
}

async function deleteMeetingWithOptions(request: DeleteMeetingRequest, runtime: Util.RuntimeOptions): DeleteMeetingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.meetingUUID)) {
    query['MeetingUUID'] = request.meetingUUID;
  }
  if (!Util.isUnset(request.tenantCode)) {
    query['TenantCode'] = request.tenantCode;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMeeting',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMeeting(request: DeleteMeetingRequest): DeleteMeetingResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMeetingWithOptions(request, runtime);
}

model DeleteUserRequest {
  count?: int32(name='Count'),
  userInfo?: string(name='UserInfo'),
}

model DeleteUserResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUserWithOptions(request: DeleteUserRequest, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    body['Count'] = request.count;
  }
  if (!Util.isUnset(request.userInfo)) {
    body['UserInfo'] = request.userInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUser',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserWithOptions(request, runtime);
}

model EnableLiveSpeakerRequest {
  enableSpeakerFlag?: boolean(name='EnableSpeakerFlag'),
  liveUUID?: string(name='LiveUUID'),
}

model EnableLiveSpeakerResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableLiveSpeakerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableLiveSpeakerResponseBody(name='body'),
}

async function enableLiveSpeakerWithOptions(request: EnableLiveSpeakerRequest, runtime: Util.RuntimeOptions): EnableLiveSpeakerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.enableSpeakerFlag)) {
    body['EnableSpeakerFlag'] = request.enableSpeakerFlag;
  }
  if (!Util.isUnset(request.liveUUID)) {
    body['LiveUUID'] = request.liveUUID;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EnableLiveSpeaker',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableLiveSpeaker(request: EnableLiveSpeakerRequest): EnableLiveSpeakerResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableLiveSpeakerWithOptions(request, runtime);
}

model EndDeviceMeetingRequest {
  meetingUUID?: string(name='MeetingUUID'),
  SN?: string(name='SN'),
}

model EndDeviceMeetingResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EndDeviceMeetingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EndDeviceMeetingResponseBody(name='body'),
}

async function endDeviceMeetingWithOptions(request: EndDeviceMeetingRequest, runtime: Util.RuntimeOptions): EndDeviceMeetingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meetingUUID)) {
    body['MeetingUUID'] = request.meetingUUID;
  }
  if (!Util.isUnset(request.SN)) {
    body['SN'] = request.SN;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EndDeviceMeeting',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function endDeviceMeeting(request: EndDeviceMeetingRequest): EndDeviceMeetingResponse {
  var runtime = new Util.RuntimeOptions{};
  return endDeviceMeetingWithOptions(request, runtime);
}

model EndLiveRequest {
  liveUUID?: string(name='LiveUUID'),
  userId?: string(name='UserId'),
}

model EndLiveResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EndLiveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EndLiveResponseBody(name='body'),
}

async function endLiveWithOptions(request: EndLiveRequest, runtime: Util.RuntimeOptions): EndLiveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.liveUUID)) {
    body['LiveUUID'] = request.liveUUID;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EndLive',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function endLive(request: EndLiveRequest): EndLiveResponse {
  var runtime = new Util.RuntimeOptions{};
  return endLiveWithOptions(request, runtime);
}

model GetAccountInfoResponseBody = {
  accountInfo?: {
    accountApplicationMax?: int32(name='AccountApplicationMax'),
    accountApplicationNumber?: int32(name='AccountApplicationNumber'),
    accountConcurrentMax?: int32(name='AccountConcurrentMax'),
  }(name='AccountInfo'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAccountInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAccountInfoResponseBody(name='body'),
}

async function getAccountInfoWithOptions(runtime: Util.RuntimeOptions): GetAccountInfoResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetAccountInfo',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAccountInfo(): GetAccountInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountInfoWithOptions(runtime);
}

model GetConferenceConcurrencyStatisticsResponseBody = {
  data?: {
    buyConcurrency?: int32(name='BuyConcurrency'),
    currentMeeting?: int32(name='CurrentMeeting'),
    useConcurrency?: int32(name='UseConcurrency'),
  }(name='Data'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetConferenceConcurrencyStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConferenceConcurrencyStatisticsResponseBody(name='body'),
}

async function getConferenceConcurrencyStatisticsWithOptions(runtime: Util.RuntimeOptions): GetConferenceConcurrencyStatisticsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetConferenceConcurrencyStatistics',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConferenceConcurrencyStatistics(): GetConferenceConcurrencyStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConferenceConcurrencyStatisticsWithOptions(runtime);
}

model GetDeviceActiveCodeRequest {
  SN?: string(name='SN'),
}

model GetDeviceActiveCodeResponseBody = {
  devices?: [ 
    {
      activeCode?: string(name='ActiveCode'),
      deviceErrorCode?: int32(name='DeviceErrorCode'),
      deviceMessage?: string(name='DeviceMessage'),
      SN?: string(name='SN'),
    }
  ](name='Devices'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  success?: boolean(name='Success'),
}

model GetDeviceActiveCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceActiveCodeResponseBody(name='body'),
}

async function getDeviceActiveCodeWithOptions(request: GetDeviceActiveCodeRequest, runtime: Util.RuntimeOptions): GetDeviceActiveCodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.SN)) {
    body['SN'] = request.SN;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceActiveCode',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceActiveCode(request: GetDeviceActiveCodeRequest): GetDeviceActiveCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceActiveCodeWithOptions(request, runtime);
}

model GetDeviceInfoRequest {
  castScreenCode?: string(name='CastScreenCode'),
  groupId?: string(name='GroupId'),
  sn?: string(name='Sn'),
  tenantCode?: string(name='TenantCode'),
}

model GetDeviceInfoResponseBody = {
  device?: {
    activationCode?: string(name='ActivationCode'),
    castScreenCode?: string(name='CastScreenCode'),
    IP?: string(name='IP'),
    mac?: string(name='Mac'),
    port?: string(name='Port'),
    sn?: string(name='Sn'),
    ssid?: string(name='Ssid'),
    status?: int32(name='Status'),
  }(name='Device'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDeviceInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceInfoResponseBody(name='body'),
}

async function getDeviceInfoWithOptions(request: GetDeviceInfoRequest, runtime: Util.RuntimeOptions): GetDeviceInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.castScreenCode)) {
    query['CastScreenCode'] = request.castScreenCode;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.sn)) {
    query['Sn'] = request.sn;
  }
  if (!Util.isUnset(request.tenantCode)) {
    query['TenantCode'] = request.tenantCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceInfo',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceInfo(request: GetDeviceInfoRequest): GetDeviceInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceInfoWithOptions(request, runtime);
}

model GetDeviceListRequest {
  castScreenCode?: string(name='CastScreenCode'),
  groupId?: string(name='GroupId'),
}

model GetDeviceListResponseBody = {
  data?: [ 
    {
      activationCode?: string(name='ActivationCode'),
      castScreenCode?: string(name='CastScreenCode'),
      IP?: string(name='IP'),
      mac?: string(name='Mac'),
      port?: string(name='Port'),
      SN?: string(name='SN'),
      status?: int32(name='Status'),
    }
  ](name='Data'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDeviceListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceListResponseBody(name='body'),
}

async function getDeviceListWithOptions(request: GetDeviceListRequest, runtime: Util.RuntimeOptions): GetDeviceListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.castScreenCode)) {
    query['CastScreenCode'] = request.castScreenCode;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceList',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceList(request: GetDeviceListRequest): GetDeviceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceListWithOptions(request, runtime);
}

model GetDeviceTokenRequest {
  SN?: string(name='SN'),
  token?: string(name='Token'),
}

model GetDeviceTokenResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  token?: string(name='Token'),
}

model GetDeviceTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceTokenResponseBody(name='body'),
}

async function getDeviceTokenWithOptions(request: GetDeviceTokenRequest, runtime: Util.RuntimeOptions): GetDeviceTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.SN)) {
    query['SN'] = request.SN;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceToken',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceToken(request: GetDeviceTokenRequest): GetDeviceTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceTokenWithOptions(request, runtime);
}

model GetGrtnTokenResponseBody = {
  errorCode?: long(name='ErrorCode'),
  grtnInfo?: {
    agent?: string(name='Agent'),
    appId?: string(name='AppId'),
    channelId?: string(name='ChannelId'),
    gslb?: string(name='Gslb'),
    nonce?: string(name='Nonce'),
    timestamp?: long(name='Timestamp'),
    token?: string(name='Token'),
    userId?: string(name='UserId'),
  }(name='GrtnInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetGrtnTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGrtnTokenResponseBody(name='body'),
}

async function getGrtnTokenWithOptions(runtime: Util.RuntimeOptions): GetGrtnTokenResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetGrtnToken',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGrtnToken(): GetGrtnTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGrtnTokenWithOptions(runtime);
}

model GetMeetingRequest {
  meetingUUID?: string(name='MeetingUUID'),
  tenantCode?: string(name='TenantCode'),
}

model GetMeetingResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  meetingInfo?: {
    appointmentType?: int32(name='AppointmentType'),
    createTime?: long(name='CreateTime'),
    endTime?: long(name='EndTime'),
    masterEnableFlag?: boolean(name='MasterEnableFlag'),
    meetingCode?: string(name='MeetingCode'),
    meetingCodeExpire?: boolean(name='MeetingCodeExpire'),
    meetingName?: string(name='MeetingName'),
    meetingUUID?: string(name='MeetingUUID'),
    memberList?: [ 
      {
        creatorFlag?: boolean(name='CreatorFlag'),
        masterFlag?: boolean(name='MasterFlag'),
        memberUUID?: string(name='MemberUUID'),
        status?: string(name='Status'),
        userAvatarUrl?: string(name='UserAvatarUrl'),
        userDeptName?: string(name='UserDeptName'),
        userId?: string(name='UserId'),
        userName?: string(name='UserName'),
      }
    ](name='MemberList'),
    openPasswordFlag?: boolean(name='OpenPasswordFlag'),
    password?: string(name='Password'),
    startTime?: long(name='StartTime'),
    status?: int32(name='Status'),
    userId?: string(name='UserId'),
    validTime?: long(name='ValidTime'),
  }(name='MeetingInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMeetingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMeetingResponseBody(name='body'),
}

async function getMeetingWithOptions(request: GetMeetingRequest, runtime: Util.RuntimeOptions): GetMeetingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tenantCode)) {
    query['TenantCode'] = request.tenantCode;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.meetingUUID)) {
    body['MeetingUUID'] = request.meetingUUID;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetMeeting',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMeeting(request: GetMeetingRequest): GetMeetingResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMeetingWithOptions(request, runtime);
}

model GetMeetingConcurrencyRequest {
  meetingUUID?: string(name='MeetingUUID'),
  tenantCode?: string(name='TenantCode'),
}

model GetMeetingConcurrencyResponseBody = {
  data?: {
    endTime?: long(name='EndTime'),
    meetingCode?: string(name='MeetingCode'),
    meetingName?: string(name='MeetingName'),
    offlineCount?: int32(name='OfflineCount'),
    onlineCount?: int32(name='OnlineCount'),
    startTime?: long(name='StartTime'),
  }(name='Data'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMeetingConcurrencyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMeetingConcurrencyResponseBody(name='body'),
}

async function getMeetingConcurrencyWithOptions(request: GetMeetingConcurrencyRequest, runtime: Util.RuntimeOptions): GetMeetingConcurrencyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.meetingUUID)) {
    query['MeetingUUID'] = request.meetingUUID;
  }
  if (!Util.isUnset(request.tenantCode)) {
    query['TenantCode'] = request.tenantCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMeetingConcurrency',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMeetingConcurrency(request: GetMeetingConcurrencyRequest): GetMeetingConcurrencyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMeetingConcurrencyWithOptions(request, runtime);
}

model GetMeetingInternationalRequest {
  meetingUUID?: string(name='MeetingUUID'),
}

model GetMeetingInternationalResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  meetingInfo?: {
    createTime?: long(name='CreateTime'),
    meetingCode?: string(name='MeetingCode'),
    meetingName?: string(name='MeetingName'),
    meetingUUID?: string(name='MeetingUUID'),
    memberList?: [ 
      {
        memberUUID?: string(name='MemberUUID'),
        status?: string(name='Status'),
        userAvatarUrl?: string(name='UserAvatarUrl'),
        userId?: string(name='UserId'),
        userName?: string(name='UserName'),
      }
    ](name='MemberList'),
    password?: string(name='Password'),
    userId?: string(name='UserId'),
    validTime?: long(name='ValidTime'),
  }(name='MeetingInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMeetingInternationalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMeetingInternationalResponseBody(name='body'),
}

async function getMeetingInternationalWithOptions(request: GetMeetingInternationalRequest, runtime: Util.RuntimeOptions): GetMeetingInternationalResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meetingUUID)) {
    body['MeetingUUID'] = request.meetingUUID;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetMeetingInternational',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMeetingInternational(request: GetMeetingInternationalRequest): GetMeetingInternationalResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMeetingInternationalWithOptions(request, runtime);
}

model GetMeetingMemberRequest {
  meetingUUID?: string(name='MeetingUUID'),
}

model GetMeetingMemberResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  members?: map[string]any(name='Members'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMeetingMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMeetingMemberResponseBody(name='body'),
}

async function getMeetingMemberWithOptions(request: GetMeetingMemberRequest, runtime: Util.RuntimeOptions): GetMeetingMemberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.meetingUUID)) {
    query['MeetingUUID'] = request.meetingUUID;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMeetingMember',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMeetingMember(request: GetMeetingMemberRequest): GetMeetingMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMeetingMemberWithOptions(request, runtime);
}

model GetMemberStatusRequest {
  meetingUUID?: string(name='MeetingUUID'),
  userId?: string(name='UserId'),
}

model GetMemberStatusResponseBody = {
  errorCode?: long(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  success?: boolean(name='Success'),
}

model GetMemberStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMemberStatusResponseBody(name='body'),
}

async function getMemberStatusWithOptions(request: GetMemberStatusRequest, runtime: Util.RuntimeOptions): GetMemberStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.meetingUUID)) {
    query['MeetingUUID'] = request.meetingUUID;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMemberStatus',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMemberStatus(request: GetMemberStatusRequest): GetMemberStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMemberStatusWithOptions(request, runtime);
}

model GetScreenVerificationCodeRequest {
  castScreenCode?: string(name='CastScreenCode'),
}

model GetScreenVerificationCodeResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  screenVerificationCode?: string(name='ScreenVerificationCode'),
  success?: boolean(name='Success'),
}

model GetScreenVerificationCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetScreenVerificationCodeResponseBody(name='body'),
}

async function getScreenVerificationCodeWithOptions(request: GetScreenVerificationCodeRequest, runtime: Util.RuntimeOptions): GetScreenVerificationCodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.castScreenCode)) {
    body['CastScreenCode'] = request.castScreenCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetScreenVerificationCode',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getScreenVerificationCode(request: GetScreenVerificationCodeRequest): GetScreenVerificationCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getScreenVerificationCodeWithOptions(request, runtime);
}

model GetStatisticRequest {
  endTime?: long(name='EndTime'),
  startTime?: long(name='StartTime'),
}

model GetStatisticResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  statisticInfo?: {
    maxConcurrency?: long(name='MaxConcurrency'),
    meetingDuration?: long(name='MeetingDuration'),
    meetingNumber?: long(name='MeetingNumber'),
    memberNumber?: long(name='MemberNumber'),
  }(name='StatisticInfo'),
  success?: boolean(name='Success'),
}

model GetStatisticResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetStatisticResponseBody(name='body'),
}

async function getStatisticWithOptions(request: GetStatisticRequest, runtime: Util.RuntimeOptions): GetStatisticResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetStatistic',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getStatistic(request: GetStatisticRequest): GetStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStatisticWithOptions(request, runtime);
}

model GetUserRequest {
  userId?: string(name='UserId'),
}

model GetUserResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  userInfo?: {
    createTime?: long(name='CreateTime'),
    departId?: string(name='DepartId'),
    departName?: string(name='DepartName'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    jobName?: string(name='JobName'),
    userAvatarUrl?: string(name='UserAvatarUrl'),
    userEmail?: string(name='UserEmail'),
    userId?: string(name='UserId'),
    userMobile?: string(name='UserMobile'),
    userName?: string(name='UserName'),
    userTel?: string(name='UserTel'),
  }(name='UserInfo'),
}

model GetUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserResponseBody(name='body'),
}

async function getUserWithOptions(request: GetUserRequest, runtime: Util.RuntimeOptions): GetUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUser',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUser(request: GetUserRequest): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserWithOptions(request, runtime);
}

model GetWebSocketTokenRequest {
  oldToken?: string(name='OldToken'),
  sessionId?: string(name='SessionId'),
}

model GetWebSocketTokenResponseBody = {
  data?: {
    authWsUrl?: string(name='AuthWsUrl'),
    token?: string(name='Token'),
    wsOuterReConnTime?: string(name='WsOuterReConnTime'),
  }(name='Data'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetWebSocketTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWebSocketTokenResponseBody(name='body'),
}

async function getWebSocketTokenWithOptions(request: GetWebSocketTokenRequest, runtime: Util.RuntimeOptions): GetWebSocketTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.oldToken)) {
    query['OldToken'] = request.oldToken;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWebSocketToken',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWebSocketToken(request: GetWebSocketTokenRequest): GetWebSocketTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWebSocketTokenWithOptions(request, runtime);
}

model InviteUserRequest {
  meetingUUID?: string(name='MeetingUUID'),
  userIds?: string(name='UserIds'),
}

model InviteUserResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InviteUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InviteUserResponseBody(name='body'),
}

async function inviteUserWithOptions(request: InviteUserRequest, runtime: Util.RuntimeOptions): InviteUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meetingUUID)) {
    body['MeetingUUID'] = request.meetingUUID;
  }
  if (!Util.isUnset(request.userIds)) {
    body['UserIds'] = request.userIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'InviteUser',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function inviteUser(request: InviteUserRequest): InviteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return inviteUserWithOptions(request, runtime);
}

model JoinDeviceMeetingRequest {
  meetingCode?: string(name='MeetingCode'),
  password?: string(name='Password'),
  SN?: string(name='SN'),
  token?: string(name='Token'),
}

model JoinDeviceMeetingResponseBody = {
  device?: {
    clientAppId?: string(name='ClientAppId'),
    meetingAppId?: string(name='MeetingAppId'),
    meetingCode?: string(name='MeetingCode'),
    meetingDomain?: string(name='MeetingDomain'),
    meetingToken?: string(name='MeetingToken'),
    meetingUUID?: string(name='MeetingUUID'),
    memberUUID?: string(name='MemberUUID'),
    slsInfo?: {
      logServiceEndpoint?: string(name='LogServiceEndpoint'),
      logstore?: string(name='Logstore'),
      project?: string(name='Project'),
    }(name='SlsInfo'),
  }(name='Device'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model JoinDeviceMeetingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: JoinDeviceMeetingResponseBody(name='body'),
}

async function joinDeviceMeetingWithOptions(request: JoinDeviceMeetingRequest, runtime: Util.RuntimeOptions): JoinDeviceMeetingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meetingCode)) {
    body['MeetingCode'] = request.meetingCode;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.SN)) {
    body['SN'] = request.SN;
  }
  if (!Util.isUnset(request.token)) {
    body['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'JoinDeviceMeeting',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function joinDeviceMeeting(request: JoinDeviceMeetingRequest): JoinDeviceMeetingResponse {
  var runtime = new Util.RuntimeOptions{};
  return joinDeviceMeetingWithOptions(request, runtime);
}

model JoinLiveRequest {
  liveUUID?: string(name='LiveUUID'),
  password?: string(name='Password'),
  userId?: string(name='UserId'),
}

model JoinLiveResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  meetingInfo?: {
    clientAppId?: string(name='ClientAppId'),
    meetingAppId?: string(name='MeetingAppId'),
    meetingCode?: string(name='MeetingCode'),
    meetingDomain?: string(name='MeetingDomain'),
    meetingToken?: string(name='MeetingToken'),
    meetingUUID?: string(name='MeetingUUID'),
    memberUUID?: string(name='MemberUUID'),
    slsInfo?: {
      logServiceEndpoint?: string(name='LogServiceEndpoint'),
      logstore?: string(name='Logstore'),
      project?: string(name='Project'),
    }(name='SlsInfo'),
  }(name='MeetingInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model JoinLiveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: JoinLiveResponseBody(name='body'),
}

async function joinLiveWithOptions(request: JoinLiveRequest, runtime: Util.RuntimeOptions): JoinLiveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.liveUUID)) {
    body['LiveUUID'] = request.liveUUID;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'JoinLive',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function joinLive(request: JoinLiveRequest): JoinLiveResponse {
  var runtime = new Util.RuntimeOptions{};
  return joinLiveWithOptions(request, runtime);
}

model JoinMeetingRequest {
  meetingCode?: string(name='MeetingCode'),
  password?: string(name='Password'),
  rtcEngine?: string(name='RtcEngine'),
  tenantCode?: string(name='TenantCode'),
  userId?: string(name='UserId'),
}

model JoinMeetingResponseBody = {
  errorCode?: long(name='ErrorCode'),
  meetingInfo?: {
    clientAppId?: string(name='ClientAppId'),
    endTime?: long(name='EndTime'),
    grtnInfo?: {
      agent?: string(name='Agent'),
      appId?: string(name='AppId'),
      channelId?: long(name='ChannelId'),
      gslb?: [ string ](name='Gslb'),
      nonce?: string(name='Nonce'),
      timestamp?: long(name='Timestamp'),
      token?: string(name='Token'),
      userId?: string(name='UserId'),
    }(name='GrtnInfo'),
    meetingAppId?: string(name='MeetingAppId'),
    meetingCode?: string(name='MeetingCode'),
    meetingDomain?: string(name='MeetingDomain'),
    meetingName?: string(name='MeetingName'),
    meetingToken?: string(name='MeetingToken'),
    meetingUUID?: string(name='MeetingUUID'),
    memberUUID?: string(name='MemberUUID'),
    slsInfo?: {
      logServiceEndpoint?: string(name='LogServiceEndpoint'),
      logstore?: string(name='Logstore'),
      project?: string(name='Project'),
    }(name='SlsInfo'),
    startTime?: long(name='StartTime'),
  }(name='MeetingInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model JoinMeetingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: JoinMeetingResponseBody(name='body'),
}

async function joinMeetingWithOptions(request: JoinMeetingRequest, runtime: Util.RuntimeOptions): JoinMeetingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tenantCode)) {
    query['TenantCode'] = request.tenantCode;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.meetingCode)) {
    body['MeetingCode'] = request.meetingCode;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.rtcEngine)) {
    body['RtcEngine'] = request.rtcEngine;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'JoinMeeting',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function joinMeeting(request: JoinMeetingRequest): JoinMeetingResponse {
  var runtime = new Util.RuntimeOptions{};
  return joinMeetingWithOptions(request, runtime);
}

model JoinMeetingInternationalRequest {
  meetingCode?: string(name='MeetingCode'),
  password?: string(name='Password'),
  userId?: string(name='UserId'),
}

model JoinMeetingInternationalResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  meetingInfo?: {
    clientAppId?: string(name='ClientAppId'),
    meetingAppId?: string(name='MeetingAppId'),
    meetingCode?: string(name='MeetingCode'),
    meetingDomain?: string(name='MeetingDomain'),
    meetingToken?: string(name='MeetingToken'),
    meetingUUID?: string(name='MeetingUUID'),
    memberUUID?: string(name='MemberUUID'),
    slsInfo?: {
      logServiceEndpoint?: string(name='LogServiceEndpoint'),
      logstore?: string(name='Logstore'),
      project?: string(name='Project'),
    }(name='SlsInfo'),
  }(name='MeetingInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model JoinMeetingInternationalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: JoinMeetingInternationalResponseBody(name='body'),
}

async function joinMeetingInternationalWithOptions(request: JoinMeetingInternationalRequest, runtime: Util.RuntimeOptions): JoinMeetingInternationalResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meetingCode)) {
    body['MeetingCode'] = request.meetingCode;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'JoinMeetingInternational',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function joinMeetingInternational(request: JoinMeetingInternationalRequest): JoinMeetingInternationalResponse {
  var runtime = new Util.RuntimeOptions{};
  return joinMeetingInternationalWithOptions(request, runtime);
}

model ListConferenceDevicesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  serialNumber?: string(name='SerialNumber'),
}

model ListConferenceDevicesResponseBody = {
  conferencesDatas?: {
    conferences?: [ 
      {
        activationCode?: string(name='ActivationCode'),
        castScreenCode?: string(name='CastScreenCode'),
        conferenceCode?: string(name='ConferenceCode'),
        conferenceName?: string(name='ConferenceName'),
        createTime?: string(name='CreateTime'),
        deviceModel?: string(name='DeviceModel'),
        manufacturer?: string(name='Manufacturer'),
        pictureUrl?: string(name='PictureUrl'),
        SN?: string(name='SN'),
        startUpPictureUrl?: string(name='StartUpPictureUrl'),
        status?: string(name='Status'),
      }
    ](name='Conferences'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='ConferencesDatas'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListConferenceDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConferenceDevicesResponseBody(name='body'),
}

async function listConferenceDevicesWithOptions(request: ListConferenceDevicesRequest, runtime: Util.RuntimeOptions): ListConferenceDevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serialNumber)) {
    query['SerialNumber'] = request.serialNumber;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConferenceDevices',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listConferenceDevices(request: ListConferenceDevicesRequest): ListConferenceDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConferenceDevicesWithOptions(request, runtime);
}

model ListDeviceIpRequest {
  groupId?: string(name='GroupId'),
  SN?: string(name='SN'),
}

model ListDeviceIpResponseBody = {
  devices?: [ 
    {
      ip?: string(name='Ip'),
      mac?: string(name='Mac'),
      port?: string(name='Port'),
      screenCode?: string(name='ScreenCode'),
      ssId?: string(name='SsId'),
    }
  ](name='Devices'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDeviceIpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeviceIpResponseBody(name='body'),
}

async function listDeviceIpWithOptions(request: ListDeviceIpRequest, runtime: Util.RuntimeOptions): ListDeviceIpResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.SN)) {
    body['SN'] = request.SN;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDeviceIp',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDeviceIp(request: ListDeviceIpRequest): ListDeviceIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDeviceIpWithOptions(request, runtime);
}

model ListDevicesRequest {
  castScreenCode?: string(name='CastScreenCode'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  SN?: string(name='SN'),
}

model ListDevicesResponseBody = {
  data?: {
    devices?: [ 
      {
        activationCode?: string(name='ActivationCode'),
        castScreenCode?: string(name='CastScreenCode'),
        conferenceCode?: string(name='ConferenceCode'),
        conferenceName?: string(name='ConferenceName'),
        createTime?: string(name='CreateTime'),
        pictureUrl?: string(name='PictureUrl'),
        SN?: string(name='SN'),
        startUpPictureUrl?: string(name='StartUpPictureUrl'),
        status?: string(name='Status'),
      }
    ](name='Devices'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDevicesResponseBody(name='body'),
}

async function listDevicesWithOptions(request: ListDevicesRequest, runtime: Util.RuntimeOptions): ListDevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.castScreenCode)) {
    query['CastScreenCode'] = request.castScreenCode;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.SN)) {
    query['SN'] = request.SN;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDevices',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDevices(request: ListDevicesRequest): ListDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDevicesWithOptions(request, runtime);
}

model ListEvaluationsResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  userEvaluation?: string(name='UserEvaluation'),
}

model ListEvaluationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEvaluationsResponseBody(name='body'),
}

async function listEvaluationsWithOptions(runtime: Util.RuntimeOptions): ListEvaluationsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListEvaluations',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEvaluations(): ListEvaluationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEvaluationsWithOptions(runtime);
}

model ListIsvStatisticsRequest {
  endTime?: long(name='EndTime'),
  startTime?: long(name='StartTime'),
}

model ListIsvStatisticsResponseBody = {
  data?: {
    statistics?: [ 
      {
        day?: string(name='Day'),
        meetingLength?: string(name='MeetingLength'),
        meetingNumber?: string(name='MeetingNumber'),
        memberNumber?: string(name='MemberNumber'),
      }
    ](name='Statistics'),
    total?: {
      meetingLength?: int32(name='MeetingLength'),
      meetingNumber?: int32(name='MeetingNumber'),
      memberNumber?: int32(name='MemberNumber'),
    }(name='Total'),
  }(name='Data'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListIsvStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIsvStatisticsResponseBody(name='body'),
}

async function listIsvStatisticsWithOptions(request: ListIsvStatisticsRequest, runtime: Util.RuntimeOptions): ListIsvStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIsvStatistics',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listIsvStatistics(request: ListIsvStatisticsRequest): ListIsvStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIsvStatisticsWithOptions(request, runtime);
}

model ListMembersRequest {
  meetingUUID?: string(name='MeetingUUID'),
}

model ListMembersResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  meetingInfo?: {
    createTime?: long(name='CreateTime'),
    meetingCode?: string(name='MeetingCode'),
    meetingName?: string(name='MeetingName'),
    meetingUUID?: string(name='MeetingUUID'),
    memberInfos?: [ 
      {
        beginTime?: long(name='BeginTime'),
        endTime?: long(name='EndTime'),
        memberUUID?: string(name='MemberUUID'),
        status?: string(name='Status'),
        userId?: string(name='UserId'),
        userName?: string(name='UserName'),
      }
    ](name='MemberInfos'),
    memo?: string(name='Memo'),
    userId?: string(name='UserId'),
    userName?: string(name='UserName'),
  }(name='MeetingInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListMembersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMembersResponseBody(name='body'),
}

async function listMembersWithOptions(request: ListMembersRequest, runtime: Util.RuntimeOptions): ListMembersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.meetingUUID)) {
    query['MeetingUUID'] = request.meetingUUID;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMembers',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMembers(request: ListMembersRequest): ListMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMembersWithOptions(request, runtime);
}

model ListUsersRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListUsersResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    userInfos?: [ 
      {
        createTime?: long(name='CreateTime'),
        departId?: string(name='DepartId'),
        departName?: string(name='DepartName'),
        groupId?: string(name='GroupId'),
        groupName?: string(name='GroupName'),
        jobName?: string(name='JobName'),
        userAvatarUrl?: string(name='UserAvatarUrl'),
        userEmail?: string(name='UserEmail'),
        userId?: string(name='UserId'),
        userMobile?: string(name='UserMobile'),
        userName?: string(name='UserName'),
        userTel?: string(name='UserTel'),
      }
    ](name='UserInfos'),
  }(name='Data'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsersWithOptions(request: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUsers',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model ModifyDeviceBackgroundRequest {
  picture?: string(name='Picture'),
  serialNumber?: string(name='SerialNumber'),
}

model ModifyDeviceBackgroundResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyDeviceBackgroundResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDeviceBackgroundResponseBody(name='body'),
}

async function modifyDeviceBackgroundWithOptions(request: ModifyDeviceBackgroundRequest, runtime: Util.RuntimeOptions): ModifyDeviceBackgroundResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.picture)) {
    body['Picture'] = request.picture;
  }
  if (!Util.isUnset(request.serialNumber)) {
    body['SerialNumber'] = request.serialNumber;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDeviceBackground',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDeviceBackground(request: ModifyDeviceBackgroundRequest): ModifyDeviceBackgroundResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDeviceBackgroundWithOptions(request, runtime);
}

model ModifyMeetingPasswordRequest {
  meetingUUID?: string(name='MeetingUUID'),
  openPasswordFlag?: boolean(name='OpenPasswordFlag'),
  password?: string(name='Password'),
  userId?: string(name='UserId'),
}

model ModifyMeetingPasswordResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyMeetingPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyMeetingPasswordResponseBody(name='body'),
}

async function modifyMeetingPasswordWithOptions(request: ModifyMeetingPasswordRequest, runtime: Util.RuntimeOptions): ModifyMeetingPasswordResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meetingUUID)) {
    body['MeetingUUID'] = request.meetingUUID;
  }
  if (!Util.isUnset(request.openPasswordFlag)) {
    body['OpenPasswordFlag'] = request.openPasswordFlag;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyMeetingPassword',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyMeetingPassword(request: ModifyMeetingPasswordRequest): ModifyMeetingPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMeetingPasswordWithOptions(request, runtime);
}

model ModifyMeetingPasswordInternationalRequest {
  meetingUUID?: string(name='MeetingUUID'),
  openPasswordFlag?: boolean(name='OpenPasswordFlag'),
  password?: string(name='Password'),
  userId?: string(name='UserId'),
}

model ModifyMeetingPasswordInternationalResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyMeetingPasswordInternationalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyMeetingPasswordInternationalResponseBody(name='body'),
}

async function modifyMeetingPasswordInternationalWithOptions(request: ModifyMeetingPasswordInternationalRequest, runtime: Util.RuntimeOptions): ModifyMeetingPasswordInternationalResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meetingUUID)) {
    body['MeetingUUID'] = request.meetingUUID;
  }
  if (!Util.isUnset(request.openPasswordFlag)) {
    body['OpenPasswordFlag'] = request.openPasswordFlag;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyMeetingPasswordInternational',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyMeetingPasswordInternational(request: ModifyMeetingPasswordInternationalRequest): ModifyMeetingPasswordInternationalResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMeetingPasswordInternationalWithOptions(request, runtime);
}

model QueryMeetingMemberActionRequest {
  endTime?: long(name='EndTime'),
  meetingUUID?: string(name='MeetingUUID'),
  meetingUnitKey?: string(name='MeetingUnitKey'),
  memberUUID?: string(name='MemberUUID'),
  startTime?: long(name='StartTime'),
}

model QueryMeetingMemberActionResponseBody = {
  audioStatus?: int32(name='AudioStatus'),
  errorCode?: int32(name='ErrorCode'),
  errorCodeCount?: long(name='ErrorCodeCount'),
  errorCodeList?: [ 
    {
      errorCodeCount?: long(name='ErrorCodeCount'),
      time?: long(name='Time'),
    }
  ](name='ErrorCodeList'),
  meetingStatus?: int32(name='MeetingStatus'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  videoStatus?: int32(name='VideoStatus'),
}

model QueryMeetingMemberActionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMeetingMemberActionResponseBody(name='body'),
}

async function queryMeetingMemberActionWithOptions(request: QueryMeetingMemberActionRequest, runtime: Util.RuntimeOptions): QueryMeetingMemberActionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.meetingUUID)) {
    body['MeetingUUID'] = request.meetingUUID;
  }
  if (!Util.isUnset(request.meetingUnitKey)) {
    body['MeetingUnitKey'] = request.meetingUnitKey;
  }
  if (!Util.isUnset(request.memberUUID)) {
    body['MemberUUID'] = request.memberUUID;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryMeetingMemberAction',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMeetingMemberAction(request: QueryMeetingMemberActionRequest): QueryMeetingMemberActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMeetingMemberActionWithOptions(request, runtime);
}

model RefreshDeviceScreenCodeRequest {
  serialNumber?: string(name='SerialNumber'),
}

model RefreshDeviceScreenCodeResponseBody = {
  data?: {
    screenCode?: string(name='ScreenCode'),
    serialNumber?: string(name='SerialNumber'),
  }(name='Data'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RefreshDeviceScreenCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefreshDeviceScreenCodeResponseBody(name='body'),
}

async function refreshDeviceScreenCodeWithOptions(request: RefreshDeviceScreenCodeRequest, runtime: Util.RuntimeOptions): RefreshDeviceScreenCodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.serialNumber)) {
    body['SerialNumber'] = request.serialNumber;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RefreshDeviceScreenCode',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshDeviceScreenCode(request: RefreshDeviceScreenCodeRequest): RefreshDeviceScreenCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshDeviceScreenCodeWithOptions(request, runtime);
}

model RegisterDeviceRequest {
  deviceVersion?: string(name='DeviceVersion'),
  IP?: string(name='IP'),
  mac?: string(name='Mac'),
  SN?: string(name='SN'),
  token?: string(name='Token'),
}

model RegisterDeviceResponseBody = {
  deviceInfo?: {
    authWsChannelConfig?: {
      authWsUrl?: string(name='AuthWsUrl'),
      token?: string(name='Token'),
      wsOuterReconnTime?: int32(name='WsOuterReconnTime'),
    }(name='AuthWsChannelConfig'),
    channelType?: string(name='ChannelType'),
    deviceName?: string(name='DeviceName'),
    deviceSessionId?: string(name='DeviceSessionId'),
    messageKey?: string(name='MessageKey'),
    mqttParam?: {
      cleanSession?: string(name='CleanSession'),
      clientId?: string(name='ClientId'),
      groupId?: string(name='GroupId'),
      host?: string(name='Host'),
      password?: string(name='Password'),
      port?: string(name='Port'),
      reconnectTimeout?: string(name='ReconnectTimeout'),
      SDKClientPort?: string(name='SDKClientPort'),
      TLSPort?: string(name='TLSPort'),
      topic?: string(name='Topic'),
      useTLS?: string(name='UseTLS'),
      userName?: string(name='UserName'),
    }(name='MqttParam'),
    registerTime?: long(name='RegisterTime'),
    screenCode?: string(name='ScreenCode'),
    slsConfig?: {
      logServiceEndpoint?: string(name='LogServiceEndpoint'),
      logStore?: string(name='LogStore'),
      project?: string(name='Project'),
    }(name='SlsConfig'),
  }(name='DeviceInfo'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RegisterDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterDeviceResponseBody(name='body'),
}

async function registerDeviceWithOptions(request: RegisterDeviceRequest, runtime: Util.RuntimeOptions): RegisterDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceVersion)) {
    query['DeviceVersion'] = request.deviceVersion;
  }
  if (!Util.isUnset(request.IP)) {
    query['IP'] = request.IP;
  }
  if (!Util.isUnset(request.mac)) {
    query['Mac'] = request.mac;
  }
  if (!Util.isUnset(request.SN)) {
    query['SN'] = request.SN;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RegisterDevice',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerDevice(request: RegisterDeviceRequest): RegisterDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerDeviceWithOptions(request, runtime);
}

model RegisterUemDeviceRequest {
  deviceId?: string(name='DeviceId'),
  deviceVersion?: string(name='DeviceVersion'),
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  IP?: string(name='IP'),
  mac?: string(name='Mac'),
  ownerId?: string(name='OwnerId'),
}

model RegisterUemDeviceResponseBody = {
  deviceInfo?: {
    authWsChannelConfig?: {
      authWsUrl?: string(name='AuthWsUrl'),
      token?: string(name='Token'),
      wsOuterReconnTime?: int32(name='WsOuterReconnTime'),
    }(name='AuthWsChannelConfig'),
    channelType?: string(name='ChannelType'),
    deviceName?: string(name='DeviceName'),
    deviceSessionId?: string(name='DeviceSessionId'),
    messageKey?: string(name='MessageKey'),
    mqttParam?: {
      cleanSession?: string(name='CleanSession'),
      clientId?: string(name='ClientId'),
      groupId?: string(name='GroupId'),
      host?: string(name='Host'),
      password?: string(name='Password'),
      port?: string(name='Port'),
      reconnectTimeout?: string(name='ReconnectTimeout'),
      SDKClientPort?: string(name='SDKClientPort'),
      TLSPort?: string(name='TLSPort'),
      topic?: string(name='Topic'),
      useTLS?: string(name='UseTLS'),
      userName?: string(name='UserName'),
    }(name='MqttParam'),
    registerTime?: long(name='RegisterTime'),
    screenCode?: string(name='ScreenCode'),
    slsConfig?: {
      logServiceEndpoint?: string(name='LogServiceEndpoint'),
      logStore?: string(name='LogStore'),
      project?: string(name='Project'),
    }(name='SlsConfig'),
    token?: string(name='Token'),
  }(name='DeviceInfo'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RegisterUemDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterUemDeviceResponseBody(name='body'),
}

async function registerUemDeviceWithOptions(request: RegisterUemDeviceRequest, runtime: Util.RuntimeOptions): RegisterUemDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceId)) {
    query['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.deviceVersion)) {
    query['DeviceVersion'] = request.deviceVersion;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.IP)) {
    query['IP'] = request.IP;
  }
  if (!Util.isUnset(request.mac)) {
    query['Mac'] = request.mac;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RegisterUemDevice',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerUemDevice(request: RegisterUemDeviceRequest): RegisterUemDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerUemDeviceWithOptions(request, runtime);
}

model SendMeetingCommandRequest {
  command?: string(name='Command'),
  meetingUUID?: string(name='MeetingUUID'),
  memberUUID?: string(name='MemberUUID'),
  operatorMemberUUID?: string(name='OperatorMemberUUID'),
  sendType?: int32(name='SendType'),
}

model SendMeetingCommandResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SendMeetingCommandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SendMeetingCommandResponseBody(name='body'),
}

async function sendMeetingCommandWithOptions(request: SendMeetingCommandRequest, runtime: Util.RuntimeOptions): SendMeetingCommandResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.meetingUUID)) {
    query['MeetingUUID'] = request.meetingUUID;
  }
  if (!Util.isUnset(request.memberUUID)) {
    query['MemberUUID'] = request.memberUUID;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.command)) {
    body['Command'] = request.command;
  }
  if (!Util.isUnset(request.operatorMemberUUID)) {
    body['OperatorMemberUUID'] = request.operatorMemberUUID;
  }
  if (!Util.isUnset(request.sendType)) {
    body['SendType'] = request.sendType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SendMeetingCommand',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendMeetingCommand(request: SendMeetingCommandRequest): SendMeetingCommandResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendMeetingCommandWithOptions(request, runtime);
}

model SendScreenStartRequest {
  castScreenCode?: string(name='CastScreenCode'),
  sessionId?: string(name='SessionId'),
}

model SendScreenStartResponseBody = {
  data?: {
    authWsChannelConfig?: {
      authWsUrl?: string(name='AuthWsUrl'),
      token?: string(name='Token'),
      wsOuterReConnTime?: int32(name='WsOuterReConnTime'),
    }(name='AuthWsChannelConfig'),
    iceServers?: [ 
      {
        credential?: string(name='Credential'),
        url?: string(name='Url'),
        userName?: string(name='UserName'),
      }
    ](name='IceServers'),
    receiverInfo?: map[string]any(name='ReceiverInfo'),
    sessionId?: string(name='SessionId'),
    shareConfig?: {
      maxMultiScreenShareBitrate?: int32(name='MaxMultiScreenShareBitrate'),
      maxScreenShareBitrate?: int32(name='MaxScreenShareBitrate'),
      shareConfigMaxFrameRate?: int32(name='ShareConfigMaxFrameRate'),
      shareConfigMinFrameRate?: int32(name='ShareConfigMinFrameRate'),
    }(name='ShareConfig'),
    signallingServerConfig?: {
      clientHeartBeatUrl?: string(name='ClientHeartBeatUrl'),
      getMessageUrl?: string(name='GetMessageUrl'),
      getReceiverInfoUrl?: string(name='GetReceiverInfoUrl'),
      sendMessageUrl?: string(name='SendMessageUrl'),
      shareScreenMeetingRobUrl?: string(name='ShareScreenMeetingRobUrl'),
    }(name='SignallingServerConfig'),
  }(name='Data'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SendScreenStartResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SendScreenStartResponseBody(name='body'),
}

async function sendScreenStartWithOptions(request: SendScreenStartRequest, runtime: Util.RuntimeOptions): SendScreenStartResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.castScreenCode)) {
    body['CastScreenCode'] = request.castScreenCode;
  }
  if (!Util.isUnset(request.sessionId)) {
    body['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SendScreenStart',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendScreenStart(request: SendScreenStartRequest): SendScreenStartResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendScreenStartWithOptions(request, runtime);
}

model StartLiveRequest {
  layoutInfo?: string(name='LayoutInfo'),
  liveUUID?: string(name='LiveUUID'),
  pushInfo?: string(name='PushInfo'),
  userId?: string(name='UserId'),
}

model StartLiveResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StartLiveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartLiveResponseBody(name='body'),
}

async function startLiveWithOptions(request: StartLiveRequest, runtime: Util.RuntimeOptions): StartLiveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.layoutInfo)) {
    body['LayoutInfo'] = request.layoutInfo;
  }
  if (!Util.isUnset(request.liveUUID)) {
    body['LiveUUID'] = request.liveUUID;
  }
  if (!Util.isUnset(request.pushInfo)) {
    body['PushInfo'] = request.pushInfo;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartLive',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startLive(request: StartLiveRequest): StartLiveResponse {
  var runtime = new Util.RuntimeOptions{};
  return startLiveWithOptions(request, runtime);
}

model UpdateDeviceHeartBeatRequest {
  message?: string(name='Message'),
}

model UpdateDeviceHeartBeatResponseBody = {
  deviceInfo?: {
    channelType?: string(name='ChannelType'),
  }(name='DeviceInfo'),
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDeviceHeartBeatResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDeviceHeartBeatResponseBody(name='body'),
}

async function updateDeviceHeartBeatWithOptions(request: UpdateDeviceHeartBeatRequest, runtime: Util.RuntimeOptions): UpdateDeviceHeartBeatResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDeviceHeartBeat',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDeviceHeartBeat(request: UpdateDeviceHeartBeatRequest): UpdateDeviceHeartBeatResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDeviceHeartBeatWithOptions(request, runtime);
}

model UpdateDeviceStartupPictureRequest {
  picture?: string(name='Picture'),
  serialNumber?: string(name='SerialNumber'),
}

model UpdateDeviceStartupPictureResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDeviceStartupPictureResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDeviceStartupPictureResponseBody(name='body'),
}

async function updateDeviceStartupPictureWithOptions(request: UpdateDeviceStartupPictureRequest, runtime: Util.RuntimeOptions): UpdateDeviceStartupPictureResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.picture)) {
    body['Picture'] = request.picture;
  }
  if (!Util.isUnset(request.serialNumber)) {
    body['SerialNumber'] = request.serialNumber;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDeviceStartupPicture',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDeviceStartupPicture(request: UpdateDeviceStartupPictureRequest): UpdateDeviceStartupPictureResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDeviceStartupPictureWithOptions(request, runtime);
}

model UpdateGonggeLayoutRequest {
  meetingUUID?: string(name='MeetingUUID'),
  value?: string(name='Value'),
  videoCount?: string(name='VideoCount'),
}

model UpdateGonggeLayoutResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateGonggeLayoutResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGonggeLayoutResponseBody(name='body'),
}

async function updateGonggeLayoutWithOptions(request: UpdateGonggeLayoutRequest, runtime: Util.RuntimeOptions): UpdateGonggeLayoutResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meetingUUID)) {
    body['MeetingUUID'] = request.meetingUUID;
  }
  if (!Util.isUnset(request.value)) {
    body['Value'] = request.value;
  }
  if (!Util.isUnset(request.videoCount)) {
    body['VideoCount'] = request.videoCount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGonggeLayout',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGonggeLayout(request: UpdateGonggeLayoutRequest): UpdateGonggeLayoutResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGonggeLayoutWithOptions(request, runtime);
}

model UpdateLivePasswordRequest {
  liveUUID?: string(name='LiveUUID'),
  openPasswordFlag?: boolean(name='OpenPasswordFlag'),
  password?: string(name='Password'),
  userId?: string(name='UserId'),
}

model UpdateLivePasswordResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateLivePasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLivePasswordResponseBody(name='body'),
}

async function updateLivePasswordWithOptions(request: UpdateLivePasswordRequest, runtime: Util.RuntimeOptions): UpdateLivePasswordResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.liveUUID)) {
    body['LiveUUID'] = request.liveUUID;
  }
  if (!Util.isUnset(request.openPasswordFlag)) {
    body['OpenPasswordFlag'] = request.openPasswordFlag;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLivePassword',
    version = '2019-10-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLivePassword(request: UpdateLivePasswordRequest): UpdateLivePasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLivePasswordWithOptions(request, runtime);
}

