/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Slb';
  @version = '2014-05-15';
  @endpointRule = 'regional';
  @endpointMap = {
    cn-qingdao = 'slb.aliyuncs.com',
    cn-beijing = 'slb.aliyuncs.com',
    cn-hangzhou = 'slb.aliyuncs.com',
    cn-shanghai = 'slb.aliyuncs.com',
    cn-shenzhen = 'slb.aliyuncs.com',
    cn-hongkong = 'slb.aliyuncs.com',
    ap-southeast-1 = 'slb.aliyuncs.com',
    us-west-1 = 'slb.aliyuncs.com',
    us-east-1 = 'slb.aliyuncs.com',
    cn-shanghai-finance-1 = 'slb.aliyuncs.com',
    cn-shenzhen-finance-1 = 'slb.aliyuncs.com',
    cn-north-2-gov-1 = 'slb.aliyuncs.com',
    ap-northeast-2-pop = 'slb.aliyuncs.com',
    cn-beijing-finance-1 = 'slb.aliyuncs.com',
    cn-beijing-finance-pop = 'slb.aliyuncs.com',
    cn-beijing-gov-1 = 'slb.aliyuncs.com',
    cn-beijing-nu16-b01 = 'slb.aliyuncs.com',
    cn-edge-1 = 'slb.aliyuncs.com',
    cn-fujian = 'slb.aliyuncs.com',
    cn-haidian-cm12-c01 = 'slb.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'slb.aliyuncs.com',
    cn-hangzhou-finance = 'slb.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'slb.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'slb.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'slb.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'slb.aliyuncs.com',
    cn-hangzhou-test-306 = 'slb.aliyuncs.com',
    cn-hongkong-finance-pop = 'slb.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'slb-api.cn-qingdao-nebula.aliyuncs.com',
    cn-shanghai-et15-b01 = 'slb.aliyuncs.com',
    cn-shanghai-et2-b01 = 'slb.aliyuncs.com',
    cn-shanghai-inner = 'slb.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'slb.aliyuncs.com',
    cn-shenzhen-inner = 'slb.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'slb.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'slb.aliyuncs.com',
    cn-wuhan = 'slb.aliyuncs.com',
    cn-yushanfang = 'slb.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'slb.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'slb.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'slb.aliyuncs.com',
    eu-west-1-oxs = 'slb.aliyuncs.com',
    rus-west-1-pop = 'slb.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model AddAccessControlListEntryRequest {
  aclEntrys?: string(name='AclEntrys', position='Query'),
  aclId?: string(name='AclId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AddAccessControlListEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddAccessControlListEntryResponse = {
  headers: map[string]string(name='headers'),
  body: AddAccessControlListEntryResponseBody(name='body'),
}

async function addAccessControlListEntry(request: AddAccessControlListEntryRequest): AddAccessControlListEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddAccessControlListEntry', 'POST', '/', 'json', false, 'json', request);
}

model AddBackendServersRequest {
  backendServers?: string(name='BackendServers', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AddBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: string(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
  requestId?: string(name='RequestId'),
}

model AddBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: AddBackendServersResponseBody(name='body'),
}

async function addBackendServers(request: AddBackendServersRequest): AddBackendServersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddBackendServers', 'POST', '/', 'json', false, 'json', request);
}

model AddListenerWhiteListItemRequest {
  listenerPort: int32(name='ListenerPort', minimum=1, maximum=65535, position='Query'),
  listenerProtocol?: string(name='ListenerProtocol', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sourceItems: string(name='SourceItems', position='Query'),
}

model AddListenerWhiteListItemResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddListenerWhiteListItemResponse = {
  headers: map[string]string(name='headers'),
  body: AddListenerWhiteListItemResponseBody(name='body'),
}

async function addListenerWhiteListItem(request: AddListenerWhiteListItemRequest): AddListenerWhiteListItemResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddListenerWhiteListItem', 'POST', '/', 'json', false, 'json', request);
}

model AddTagsRequest {
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tags: string(name='Tags', position='Query'),
}

model AddTagsResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddTagsResponse = {
  headers: map[string]string(name='headers'),
  body: AddTagsResponseBody(name='body'),
}

async function addTags(request: AddTagsRequest): AddTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddTags', 'POST', '/', 'json', false, 'json', request);
}

model AddVServerGroupBackendServersRequest {
  backendServers: string(name='BackendServers', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  VServerGroupId: string(name='VServerGroupId', position='Query'),
}

model AddVServerGroupBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model AddVServerGroupBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: AddVServerGroupBackendServersResponseBody(name='body'),
}

async function addVServerGroupBackendServers(request: AddVServerGroupBackendServersRequest): AddVServerGroupBackendServersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddVServerGroupBackendServers', 'POST', '/', 'json', false, 'json', request);
}

model CreateAccessControlListRequest {
  aclName: string(name='AclName', position='Query'),
  addressIPVersion?: string(name='AddressIPVersion', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateAccessControlListResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId'),
}

model CreateAccessControlListResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAccessControlListResponseBody(name='body'),
}

async function createAccessControlList(request: CreateAccessControlListRequest): CreateAccessControlListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAccessControlList', 'POST', '/', 'json', false, 'json', request);
}

model CreateDomainExtensionRequest {
  domain: string(name='Domain', position='Query'),
  listenerPort: int32(name='ListenerPort', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serverCertificateId?: string(name='ServerCertificateId', position='Query'),
}

model CreateDomainExtensionResponseBody = {
  domainExtensionId?: string(name='DomainExtensionId'),
  listenerPort?: int32(name='ListenerPort'),
  requestId?: string(name='RequestId'),
}

model CreateDomainExtensionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDomainExtensionResponseBody(name='body'),
}

async function createDomainExtension(request: CreateDomainExtensionRequest): CreateDomainExtensionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDomainExtension', 'POST', '/', 'json', false, 'json', request);
}

model CreateLoadBalancerRequest {
  address?: string(name='Address', position='Query'),
  addressIPVersion?: string(name='AddressIPVersion', position='Query'),
  addressType?: string(name='AddressType', position='Query'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  bandwidth?: int32(name='Bandwidth', minimum=1, maximum=5000, position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  deleteProtection?: string(name='DeleteProtection', position='Query'),
  duration?: int32(name='Duration', minimum=1, position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  loadBalancerName?: string(name='LoadBalancerName', position='Query'),
  loadBalancerSpec?: string(name='LoadBalancerSpec', position='Query'),
  masterZoneId?: string(name='MasterZoneId', position='Query'),
  modificationProtectionReason?: string(name='ModificationProtectionReason', position='Query'),
  modificationProtectionStatus?: string(name='ModificationProtectionStatus', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payType?: string(name='PayType', position='Query'),
  pricingCycle?: string(name='PricingCycle', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  slaveZoneId?: string(name='SlaveZoneId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model CreateLoadBalancerResponseBody = {
  address?: string(name='Address'),
  addressIPVersion?: string(name='AddressIPVersion'),
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerName?: string(name='LoadBalancerName'),
  networkType?: string(name='NetworkType'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model CreateLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerResponseBody(name='body'),
}

async function createLoadBalancer(request: CreateLoadBalancerRequest): CreateLoadBalancerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLoadBalancer', 'POST', '/', 'json', false, 'json', request);
}

model CreateLoadBalancerHTTPListenerRequest {
  aclId?: string(name='AclId', position='Query'),
  aclStatus?: string(name='AclStatus', position='Query'),
  aclType?: string(name='AclType', position='Query'),
  backendServerPort?: int32(name='BackendServerPort', minimum=1, maximum=65535, position='Query'),
  bandwidth?: int32(name='Bandwidth', minimum=-1, maximum=5120, position='Query'),
  cookie?: string(name='Cookie', position='Query'),
  cookieTimeout?: int32(name='CookieTimeout', minimum=1, maximum=86400, position='Query'),
  description?: string(name='Description', position='Query'),
  forwardPort?: int32(name='ForwardPort', minimum=1, maximum=65535, position='Query'),
  gzip?: string(name='Gzip', position='Query'),
  healthCheck: string(name='HealthCheck', position='Query'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', minimum=-520, maximum=65535, position='Query'),
  healthCheckDomain?: string(name='HealthCheckDomain', position='Query'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', position='Query'),
  healthCheckInterval?: int32(name='HealthCheckInterval', minimum=1, maximum=50, position='Query'),
  healthCheckMethod?: string(name='HealthCheckMethod', position='Query'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', minimum=1, maximum=300, position='Query'),
  healthCheckURI?: string(name='HealthCheckURI', position='Query'),
  healthyThreshold?: int32(name='HealthyThreshold', minimum=1, maximum=10, position='Query'),
  idleTimeout?: int32(name='IdleTimeout', minimum=1, maximum=9999, position='Query'),
  listenerForward?: string(name='ListenerForward', position='Query'),
  listenerPort: int32(name='ListenerPort', minimum=1, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  requestTimeout?: int32(name='RequestTimeout', minimum=1, maximum=9999, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scheduler?: string(name='Scheduler', position='Query'),
  stickySession: string(name='StickySession', position='Query'),
  stickySessionType?: string(name='StickySessionType', position='Query'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', minimum=1, maximum=10, position='Query'),
  VServerGroupId?: string(name='VServerGroupId', position='Query'),
  XForwardedFor?: string(name='XForwardedFor', position='Query'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID', position='Query'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP', position='Query'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto', position='Query'),
}

model CreateLoadBalancerHTTPListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateLoadBalancerHTTPListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerHTTPListenerResponseBody(name='body'),
}

async function createLoadBalancerHTTPListener(request: CreateLoadBalancerHTTPListenerRequest): CreateLoadBalancerHTTPListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLoadBalancerHTTPListener', 'POST', '/', 'json', false, 'json', request);
}

model CreateLoadBalancerHTTPSListenerRequest {
  aclId?: string(name='AclId', position='Query'),
  aclStatus?: string(name='AclStatus', position='Query'),
  aclType?: string(name='AclType', position='Query'),
  backendServerPort?: int32(name='BackendServerPort', minimum=1, maximum=65535, position='Query'),
  bandwidth: int32(name='Bandwidth', minimum=-1, maximum=5120, position='Query'),
  CACertificateId?: string(name='CACertificateId', position='Query'),
  cookie?: string(name='Cookie', position='Query'),
  cookieTimeout?: int32(name='CookieTimeout', minimum=1, maximum=86400, position='Query'),
  description?: string(name='Description', position='Query'),
  enableHttp2?: string(name='EnableHttp2', position='Query'),
  gzip?: string(name='Gzip', position='Query'),
  healthCheck: string(name='HealthCheck', position='Query'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', minimum=-520, maximum=65535, position='Query'),
  healthCheckDomain?: string(name='HealthCheckDomain', position='Query'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', position='Query'),
  healthCheckInterval?: int32(name='HealthCheckInterval', minimum=1, maximum=50, position='Query'),
  healthCheckMethod?: string(name='HealthCheckMethod', position='Query'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', minimum=1, maximum=300, position='Query'),
  healthCheckURI?: string(name='HealthCheckURI', position='Query'),
  healthyThreshold?: int32(name='HealthyThreshold', minimum=1, maximum=10, position='Query'),
  idleTimeout?: int32(name='IdleTimeout', minimum=1, maximum=9999, position='Query'),
  listenerPort: int32(name='ListenerPort', minimum=1, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  requestTimeout?: int32(name='RequestTimeout', minimum=1, maximum=9999, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scheduler?: string(name='Scheduler', position='Query'),
  serverCertificateId?: string(name='ServerCertificateId', position='Query'),
  stickySession: string(name='StickySession', position='Query'),
  stickySessionType?: string(name='StickySessionType', position='Query'),
  TLSCipherPolicy?: string(name='TLSCipherPolicy', position='Query'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', minimum=1, maximum=10, position='Query'),
  VServerGroupId?: string(name='VServerGroupId', position='Query'),
  XForwardedFor?: string(name='XForwardedFor', position='Query'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID', position='Query'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP', position='Query'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto', position='Query'),
}

model CreateLoadBalancerHTTPSListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateLoadBalancerHTTPSListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerHTTPSListenerResponseBody(name='body'),
}

async function createLoadBalancerHTTPSListener(request: CreateLoadBalancerHTTPSListenerRequest): CreateLoadBalancerHTTPSListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLoadBalancerHTTPSListener', 'POST', '/', 'json', false, 'json', request);
}

model CreateLoadBalancerTCPListenerRequest {
  aclId?: string(name='AclId', position='Query'),
  aclStatus?: string(name='AclStatus', position='Query'),
  aclType?: string(name='AclType', position='Query'),
  backendServerPort?: int32(name='BackendServerPort', minimum=1, maximum=65535, position='Query'),
  bandwidth: int32(name='Bandwidth', minimum=-1, maximum=5120, position='Query'),
  connectionDrain?: string(name='ConnectionDrain', position='Query'),
  connectionDrainTimeout?: int32(name='ConnectionDrainTimeout', position='Query'),
  description?: string(name='Description', position='Query'),
  establishedTimeout?: int32(name='EstablishedTimeout', minimum=10, maximum=900, position='Query'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', minimum=1, maximum=65535, position='Query'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', minimum=1, maximum=300, position='Query'),
  healthCheckDomain?: string(name='HealthCheckDomain', position='Query'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', position='Query'),
  healthCheckType?: string(name='HealthCheckType', position='Query'),
  healthCheckURI?: string(name='HealthCheckURI', position='Query'),
  healthyThreshold?: int32(name='HealthyThreshold', minimum=1, maximum=10, position='Query'),
  listenerPort: int32(name='ListenerPort', minimum=0, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  persistenceTimeout?: int32(name='PersistenceTimeout', minimum=0, maximum=3600, position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scheduler?: string(name='Scheduler', position='Query'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', minimum=1, maximum=10, position='Query'),
  VServerGroupId?: string(name='VServerGroupId', position='Query'),
  healthCheckInterval?: int32(name='healthCheckInterval', minimum=1, maximum=50, position='Query'),
}

model CreateLoadBalancerTCPListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateLoadBalancerTCPListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerTCPListenerResponseBody(name='body'),
}

async function createLoadBalancerTCPListener(request: CreateLoadBalancerTCPListenerRequest): CreateLoadBalancerTCPListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLoadBalancerTCPListener', 'POST', '/', 'json', false, 'json', request);
}

model CreateLoadBalancerUDPListenerRequest {
  aclId?: string(name='AclId', position='Query'),
  aclStatus?: string(name='AclStatus', position='Query'),
  aclType?: string(name='AclType', position='Query'),
  backendServerPort?: int32(name='BackendServerPort', minimum=1, maximum=65535, position='Query'),
  bandwidth: int32(name='Bandwidth', minimum=-1, maximum=5120, position='Query'),
  description?: string(name='Description', position='Query'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', minimum=1, maximum=65535, position='Query'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', minimum=1, maximum=300, position='Query'),
  healthyThreshold?: int32(name='HealthyThreshold', minimum=1, maximum=10, position='Query'),
  listenerPort: int32(name='ListenerPort', minimum=0, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scheduler?: string(name='Scheduler', position='Query'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', minimum=1, maximum=10, position='Query'),
  VServerGroupId?: string(name='VServerGroupId', position='Query'),
  healthCheckExp?: string(name='healthCheckExp', position='Query'),
  healthCheckInterval?: int32(name='healthCheckInterval', minimum=1, maximum=50, position='Query'),
  healthCheckReq?: string(name='healthCheckReq', position='Query'),
}

model CreateLoadBalancerUDPListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateLoadBalancerUDPListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerUDPListenerResponseBody(name='body'),
}

async function createLoadBalancerUDPListener(request: CreateLoadBalancerUDPListenerRequest): CreateLoadBalancerUDPListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLoadBalancerUDPListener', 'POST', '/', 'json', false, 'json', request);
}

model CreateMasterSlaveServerGroupRequest {
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  masterSlaveBackendServers?: string(name='MasterSlaveBackendServers', position='Query'),
  masterSlaveServerGroupName?: string(name='MasterSlaveServerGroupName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateMasterSlaveServerGroupResponseBody = {
  masterSlaveBackendServers?: {
    masterSlaveBackendServer?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      serverType?: string(name='ServerType'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='MasterSlaveBackendServer')
  }(name='MasterSlaveBackendServers'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateMasterSlaveServerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMasterSlaveServerGroupResponseBody(name='body'),
}

async function createMasterSlaveServerGroup(request: CreateMasterSlaveServerGroupRequest): CreateMasterSlaveServerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMasterSlaveServerGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateRulesRequest {
  listenerPort: int32(name='ListenerPort', position='Query'),
  listenerProtocol?: string(name='ListenerProtocol', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ruleList: string(name='RuleList', position='Query'),
}

model CreateRulesResponseBody = {
  requestId?: string(name='RequestId'),
  rules?: {
    rule?: [ 
    {
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
    }
  ](name='Rule')
  }(name='Rules'),
}

model CreateRulesResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRulesResponseBody(name='body'),
}

async function createRules(request: CreateRulesRequest): CreateRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRules', 'POST', '/', 'json', false, 'json', request);
}

model CreateTLSCipherPolicyRequest {
  ciphers: [ string ](name='Ciphers', position='Query'),
  name: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  TLSVersions: [ string ](name='TLSVersions', position='Query'),
}

model CreateTLSCipherPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  TLSCipherPolicyId?: string(name='TLSCipherPolicyId'),
}

model CreateTLSCipherPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTLSCipherPolicyResponseBody(name='body'),
}

async function createTLSCipherPolicy(request: CreateTLSCipherPolicyRequest): CreateTLSCipherPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTLSCipherPolicy', 'POST', '/', 'json', false, 'json', request);
}

model CreateVServerGroupRequest {
  backendServers?: string(name='BackendServers', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  VServerGroupName?: string(name='VServerGroupName', position='Query'),
}

model CreateVServerGroupResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model CreateVServerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVServerGroupResponseBody(name='body'),
}

async function createVServerGroup(request: CreateVServerGroupRequest): CreateVServerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVServerGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAccessControlListRequest {
  aclId: string(name='AclId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteAccessControlListResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAccessControlListResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAccessControlListResponseBody(name='body'),
}

async function deleteAccessControlList(request: DeleteAccessControlListRequest): DeleteAccessControlListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAccessControlList', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCACertificateRequest {
  CACertificateId: string(name='CACertificateId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteCACertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCACertificateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCACertificateResponseBody(name='body'),
}

async function deleteCACertificate(request: DeleteCACertificateRequest): DeleteCACertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCACertificate', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDomainExtensionRequest {
  domainExtensionId: string(name='DomainExtensionId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDomainExtensionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDomainExtensionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDomainExtensionResponseBody(name='body'),
}

async function deleteDomainExtension(request: DeleteDomainExtensionRequest): DeleteDomainExtensionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDomainExtension', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLoadBalancerRequest {
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteLoadBalancerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLoadBalancerResponseBody(name='body'),
}

async function deleteLoadBalancer(request: DeleteLoadBalancerRequest): DeleteLoadBalancerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLoadBalancer', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLoadBalancerListenerRequest {
  listenerPort: int32(name='ListenerPort', minimum=0, maximum=65535, position='Query'),
  listenerProtocol?: string(name='ListenerProtocol', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteLoadBalancerListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLoadBalancerListenerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLoadBalancerListenerResponseBody(name='body'),
}

async function deleteLoadBalancerListener(request: DeleteLoadBalancerListenerRequest): DeleteLoadBalancerListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLoadBalancerListener', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMasterSlaveServerGroupRequest {
  masterSlaveServerGroupId: string(name='MasterSlaveServerGroupId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteMasterSlaveServerGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMasterSlaveServerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMasterSlaveServerGroupResponseBody(name='body'),
}

async function deleteMasterSlaveServerGroup(request: DeleteMasterSlaveServerGroupRequest): DeleteMasterSlaveServerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMasterSlaveServerGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteRulesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ruleIds: string(name='RuleIds', position='Query'),
}

model DeleteRulesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRulesResponseBody(name='body'),
}

async function deleteRules(request: DeleteRulesRequest): DeleteRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRules', 'POST', '/', 'json', false, 'json', request);
}

model DeleteServerCertificateRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serverCertificateId: string(name='ServerCertificateId', position='Query'),
}

model DeleteServerCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteServerCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteServerCertificateResponseBody(name='body'),
}

async function deleteServerCertificate(request: DeleteServerCertificateRequest): DeleteServerCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteServerCertificate', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTLSCipherPolicyRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  TLSCipherPolicyId: string(name='TLSCipherPolicyId', position='Query'),
}

model DeleteTLSCipherPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTLSCipherPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTLSCipherPolicyResponseBody(name='body'),
}

async function deleteTLSCipherPolicy(request: DeleteTLSCipherPolicyRequest): DeleteTLSCipherPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTLSCipherPolicy', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVServerGroupRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  VServerGroupId: string(name='VServerGroupId', position='Query'),
}

model DeleteVServerGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVServerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVServerGroupResponseBody(name='body'),
}

async function deleteVServerGroup(request: DeleteVServerGroupRequest): DeleteVServerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVServerGroup', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAccessControlListAttributeRequest {
  aclEntryComment?: string(name='AclEntryComment', position='Query'),
  aclId: string(name='AclId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeAccessControlListAttributeResponseBody = {
  aclEntrys?: {
    aclEntry?: [ 
    {
      aclEntryComment?: string(name='AclEntryComment'),
      aclEntryIP?: string(name='AclEntryIP'),
    }
  ](name='AclEntry')
  }(name='AclEntrys'),
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
  addressIPVersion?: string(name='AddressIPVersion'),
  relatedListeners?: {
    relatedListener?: [ 
    {
      aclType?: string(name='AclType'),
      listenerPort?: int32(name='ListenerPort'),
      loadBalancerId?: string(name='LoadBalancerId'),
      protocol?: string(name='Protocol'),
    }
  ](name='RelatedListener')
  }(name='RelatedListeners'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeAccessControlListAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccessControlListAttributeResponseBody(name='body'),
}

async function describeAccessControlListAttribute(request: DescribeAccessControlListAttributeRequest): DescribeAccessControlListAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAccessControlListAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAccessControlListsRequest {
  aclName?: string(name='AclName', position='Query'),
  addressIPVersion?: string(name='AddressIPVersion', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeAccessControlListsResponseBody = {
  acls?: {
    acl?: [ 
    {
      aclId?: string(name='AclId'),
      aclName?: string(name='AclName'),
      addressIPVersion?: string(name='AddressIPVersion'),
      resourceGroupId?: string(name='ResourceGroupId'),
    }
  ](name='Acl')
  }(name='Acls'),
  count?: int32(name='Count'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeAccessControlListsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccessControlListsResponseBody(name='body'),
}

async function describeAccessControlLists(request: DescribeAccessControlListsRequest): DescribeAccessControlListsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAccessControlLists', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAvailableResourceRequest {
  addressIPVersion?: string(name='AddressIPVersion', position='Query'),
  addressType?: string(name='AddressType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeAvailableResourceResponseBody = {
  availableResources?: {
    availableResource?: [ 
    {
      masterZoneId?: string(name='MasterZoneId'),
      slaveZoneId?: string(name='SlaveZoneId'),
      supportResources?: {
        supportResource?: [ 
        {
          addressIPVersion?: string(name='AddressIPVersion'),
          addressType?: string(name='AddressType'),
        }
      ](name='SupportResource')
      }(name='SupportResources'),
    }
  ](name='AvailableResource')
  }(name='AvailableResources'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableResourceResponseBody(name='body'),
}

async function describeAvailableResource(request: DescribeAvailableResourceRequest): DescribeAvailableResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableResource', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCACertificatesRequest {
  CACertificateId?: string(name='CACertificateId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeCACertificatesResponseBody = {
  CACertificates?: {
    CACertificate?: [ 
    {
      CACertificateId?: string(name='CACertificateId'),
      CACertificateName?: string(name='CACertificateName'),
      commonName?: string(name='CommonName'),
      createTime?: string(name='CreateTime'),
      createTimeStamp?: long(name='CreateTimeStamp'),
      expireTime?: string(name='ExpireTime'),
      expireTimeStamp?: long(name='ExpireTimeStamp'),
      fingerprint?: string(name='Fingerprint'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
    }
  ](name='CACertificate')
  }(name='CACertificates'),
  requestId?: string(name='RequestId'),
}

model DescribeCACertificatesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCACertificatesResponseBody(name='body'),
}

async function describeCACertificates(request: DescribeCACertificatesRequest): DescribeCACertificatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCACertificates', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainExtensionAttributeRequest {
  domainExtensionId: string(name='DomainExtensionId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDomainExtensionAttributeResponseBody = {
  domain?: string(name='Domain'),
  domainExtensionId?: string(name='DomainExtensionId'),
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
  requestId?: string(name='RequestId'),
  serverCertificateId?: string(name='ServerCertificateId'),
}

model DescribeDomainExtensionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainExtensionAttributeResponseBody(name='body'),
}

async function describeDomainExtensionAttribute(request: DescribeDomainExtensionAttributeRequest): DescribeDomainExtensionAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainExtensionAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainExtensionsRequest {
  domainExtensionId?: string(name='DomainExtensionId', position='Query'),
  listenerPort: int32(name='ListenerPort', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDomainExtensionsResponseBody = {
  domainExtensions?: {
    domainExtension?: [ 
    {
      domain?: string(name='Domain'),
      domainExtensionId?: string(name='DomainExtensionId'),
      serverCertificateId?: string(name='ServerCertificateId'),
    }
  ](name='DomainExtension')
  }(name='DomainExtensions'),
  requestId?: string(name='RequestId'),
}

model DescribeDomainExtensionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainExtensionsResponseBody(name='body'),
}

async function describeDomainExtensions(request: DescribeDomainExtensionsRequest): DescribeDomainExtensionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainExtensions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHealthStatusRequest {
  listenerPort?: int32(name='ListenerPort', minimum=0, maximum=65535, position='Query'),
  listenerProtocol?: string(name='ListenerProtocol', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeHealthStatusResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      listenerPort?: int32(name='ListenerPort'),
      port?: int32(name='Port'),
      protocol?: string(name='Protocol'),
      serverHealthStatus?: string(name='ServerHealthStatus'),
      serverId?: string(name='ServerId'),
      serverIp?: string(name='ServerIp'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId'),
}

model DescribeHealthStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHealthStatusResponseBody(name='body'),
}

async function describeHealthStatus(request: DescribeHealthStatusRequest): DescribeHealthStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHealthStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeListenerAccessControlAttributeRequest {
  listenerPort: int32(name='ListenerPort', position='Query'),
  listenerProtocol?: string(name='ListenerProtocol', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeListenerAccessControlAttributeResponseBody = {
  accessControlStatus?: string(name='AccessControlStatus'),
  requestId?: string(name='RequestId'),
  sourceItems?: string(name='SourceItems'),
}

model DescribeListenerAccessControlAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeListenerAccessControlAttributeResponseBody(name='body'),
}

async function describeListenerAccessControlAttribute(request: DescribeListenerAccessControlAttributeRequest): DescribeListenerAccessControlAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeListenerAccessControlAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLoadBalancerAttributeRequest {
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeLoadBalancerAttributeResponseBody = {
  address?: string(name='Address'),
  addressIPVersion?: string(name='AddressIPVersion'),
  addressType?: string(name='AddressType'),
  autoReleaseTime?: long(name='AutoReleaseTime'),
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  bandwidth?: int32(name='Bandwidth'),
  createTime?: string(name='CreateTime'),
  createTimeStamp?: long(name='CreateTimeStamp'),
  deleteProtection?: string(name='DeleteProtection'),
  endTime?: string(name='EndTime'),
  endTimeStamp?: long(name='EndTimeStamp'),
  internetChargeType?: string(name='InternetChargeType'),
  listenerPorts?: {
    listenerPort?: [ int32 ](name='ListenerPort')
  }(name='ListenerPorts'),
  listenerPortsAndProtocal?: {
    listenerPortAndProtocal?: [ 
    {
      listenerPort?: int32(name='ListenerPort'),
      listenerProtocal?: string(name='ListenerProtocal'),
    }
  ](name='ListenerPortAndProtocal')
  }(name='ListenerPortsAndProtocal'),
  listenerPortsAndProtocol?: {
    listenerPortAndProtocol?: [ 
    {
      description?: string(name='Description'),
      forwardPort?: int32(name='ForwardPort'),
      listenerForward?: string(name='ListenerForward'),
      listenerPort?: int32(name='ListenerPort'),
      listenerProtocol?: string(name='ListenerProtocol'),
    }
  ](name='ListenerPortAndProtocol')
  }(name='ListenerPortsAndProtocol'),
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerName?: string(name='LoadBalancerName'),
  loadBalancerSpec?: string(name='LoadBalancerSpec'),
  loadBalancerStatus?: string(name='LoadBalancerStatus'),
  masterZoneId?: string(name='MasterZoneId'),
  modificationProtectionReason?: string(name='ModificationProtectionReason'),
  modificationProtectionStatus?: string(name='ModificationProtectionStatus'),
  networkType?: string(name='NetworkType'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  regionIdAlias?: string(name='RegionIdAlias'),
  renewalCycUnit?: string(name='RenewalCycUnit'),
  renewalDuration?: int32(name='RenewalDuration'),
  renewalStatus?: string(name='RenewalStatus'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  slaveZoneId?: string(name='SlaveZoneId'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model DescribeLoadBalancerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerAttribute(request: DescribeLoadBalancerAttributeRequest): DescribeLoadBalancerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLoadBalancerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLoadBalancerHTTPListenerAttributeRequest {
  listenerPort: int32(name='ListenerPort', minimum=1, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeLoadBalancerHTTPListenerAttributeResponseBody = {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  cookie?: string(name='Cookie'),
  cookieTimeout?: int32(name='CookieTimeout'),
  description?: string(name='Description'),
  forwardPort?: int32(name='ForwardPort'),
  gzip?: string(name='Gzip'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  idleTimeout?: int32(name='IdleTimeout'),
  listenerForward?: string(name='ListenerForward'),
  listenerPort?: int32(name='ListenerPort'),
  requestId?: string(name='RequestId'),
  requestTimeout?: int32(name='RequestTimeout'),
  rules?: {
    rule?: [ 
    {
      domain?: string(name='Domain'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      url?: string(name='Url'),
      VServerGroupId?: string(name='VServerGroupId'),
    }
  ](name='Rule')
  }(name='Rules'),
  scheduler?: string(name='Scheduler'),
  securityStatus?: string(name='SecurityStatus'),
  status?: string(name='Status'),
  stickySession?: string(name='StickySession'),
  stickySessionType?: string(name='StickySessionType'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  VServerGroupId?: string(name='VServerGroupId'),
  XForwardedFor?: string(name='XForwardedFor'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto'),
}

model DescribeLoadBalancerHTTPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerHTTPListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerHTTPListenerAttribute(request: DescribeLoadBalancerHTTPListenerAttributeRequest): DescribeLoadBalancerHTTPListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLoadBalancerHTTPListenerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLoadBalancerHTTPSListenerAttributeRequest {
  listenerPort: int32(name='ListenerPort', minimum=1, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeLoadBalancerHTTPSListenerAttributeResponseBody = {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  CACertificateId?: string(name='CACertificateId'),
  cookie?: string(name='Cookie'),
  cookieTimeout?: int32(name='CookieTimeout'),
  description?: string(name='Description'),
  domainExtensions?: {
    domainExtension?: [ 
    {
      domain?: string(name='Domain'),
      domainExtensionId?: string(name='DomainExtensionId'),
      serverCertificateId?: string(name='ServerCertificateId'),
    }
  ](name='DomainExtension')
  }(name='DomainExtensions'),
  enableHttp2?: string(name='EnableHttp2'),
  gzip?: string(name='Gzip'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  idleTimeout?: int32(name='IdleTimeout'),
  listenerPort?: int32(name='ListenerPort'),
  requestId?: string(name='RequestId'),
  requestTimeout?: int32(name='RequestTimeout'),
  rules?: {
    rule?: [ 
    {
      domain?: string(name='Domain'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      url?: string(name='Url'),
      VServerGroupId?: string(name='VServerGroupId'),
    }
  ](name='Rule')
  }(name='Rules'),
  scheduler?: string(name='Scheduler'),
  securityStatus?: string(name='SecurityStatus'),
  serverCertificateId?: string(name='ServerCertificateId'),
  status?: string(name='Status'),
  stickySession?: string(name='StickySession'),
  stickySessionType?: string(name='StickySessionType'),
  TLSCipherPolicy?: string(name='TLSCipherPolicy'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  VServerGroupId?: string(name='VServerGroupId'),
  XForwardedFor?: string(name='XForwardedFor'),
  XForwardedFor_ClientCertClientVerify?: string(name='XForwardedFor_ClientCertClientVerify'),
  XForwardedFor_ClientCertFingerprint?: string(name='XForwardedFor_ClientCertFingerprint'),
  XForwardedFor_ClientCertIssuerDN?: string(name='XForwardedFor_ClientCertIssuerDN'),
  XForwardedFor_ClientCertSubjectDN?: string(name='XForwardedFor_ClientCertSubjectDN'),
  XForwardedFor_ClientSrcPort?: string(name='XForwardedFor_ClientSrcPort'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
  XForwardedFor_SLBPORT?: string(name='XForwardedFor_SLBPORT'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto'),
}

model DescribeLoadBalancerHTTPSListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerHTTPSListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerHTTPSListenerAttribute(request: DescribeLoadBalancerHTTPSListenerAttributeRequest): DescribeLoadBalancerHTTPSListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLoadBalancerHTTPSListenerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLoadBalancerListenersRequest {
  listenerProtocol?: string(name='ListenerProtocol', position='Query'),
  loadBalancerId?: [ string ](name='LoadBalancerId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=0, maximum=101, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeLoadBalancerListenersResponseBody = {
  listeners?: [ 
    {
      aclId?: string(name='AclId'),
      aclStatus?: string(name='AclStatus'),
      aclType?: string(name='AclType'),
      backendServerPort?: int32(name='BackendServerPort'),
      bandwidth?: int32(name='Bandwidth'),
      description?: string(name='Description'),
      HTTPListenerConfig?: {
        cookie?: string(name='Cookie'),
        cookieTimeout?: int32(name='CookieTimeout'),
        forwardPort?: int32(name='ForwardPort'),
        gzip?: string(name='Gzip'),
        healthCheck?: string(name='HealthCheck'),
        healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
        healthCheckDomain?: string(name='HealthCheckDomain'),
        healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
        healthCheckHttpVersion?: string(name='HealthCheckHttpVersion'),
        healthCheckInterval?: int32(name='HealthCheckInterval'),
        healthCheckMethod?: string(name='HealthCheckMethod'),
        healthCheckTimeout?: int32(name='HealthCheckTimeout'),
        healthCheckType?: string(name='HealthCheckType'),
        healthCheckURI?: string(name='HealthCheckURI'),
        healthyThreshold?: int32(name='HealthyThreshold'),
        idleTimeout?: int32(name='IdleTimeout'),
        listenerForward?: string(name='ListenerForward'),
        requestTimeout?: int32(name='RequestTimeout'),
        stickySession?: string(name='StickySession'),
        stickySessionType?: string(name='StickySessionType'),
        unhealthyThreshold?: int32(name='UnhealthyThreshold'),
        XForwardedFor?: string(name='XForwardedFor'),
        XForwardedFor_ClientSrcPort?: string(name='XForwardedFor_ClientSrcPort'),
        XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
        XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
        XForwardedFor_SLBPORT?: string(name='XForwardedFor_SLBPORT'),
        XForwardedFor_proto?: string(name='XForwardedFor_proto'),
      }(name='HTTPListenerConfig'),
      HTTPSListenerConfig?: {
        CACertificateId?: string(name='CACertificateId'),
        cookie?: string(name='Cookie'),
        cookieTimeout?: int32(name='CookieTimeout'),
        enableHttp2?: string(name='EnableHttp2'),
        gzip?: string(name='Gzip'),
        healthCheck?: string(name='HealthCheck'),
        healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
        healthCheckDomain?: string(name='HealthCheckDomain'),
        healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
        healthCheckHttpVersion?: string(name='HealthCheckHttpVersion'),
        healthCheckInterval?: int32(name='HealthCheckInterval'),
        healthCheckMethod?: string(name='HealthCheckMethod'),
        healthCheckTimeout?: int32(name='HealthCheckTimeout'),
        healthCheckType?: string(name='HealthCheckType'),
        healthCheckURI?: string(name='HealthCheckURI'),
        healthyThreshold?: int32(name='HealthyThreshold'),
        idleTimeout?: int32(name='IdleTimeout'),
        requestTimeout?: int32(name='RequestTimeout'),
        serverCertificateId?: string(name='ServerCertificateId'),
        stickySession?: string(name='StickySession'),
        stickySessionType?: string(name='StickySessionType'),
        TLSCipherPolicy?: string(name='TLSCipherPolicy'),
        unhealthyThreshold?: int32(name='UnhealthyThreshold'),
        XForwardedFor?: string(name='XForwardedFor'),
        XForwardedFor_ClientCertClientVerify?: string(name='XForwardedFor_ClientCertClientVerify'),
        XForwardedFor_ClientCertFingerprint?: string(name='XForwardedFor_ClientCertFingerprint'),
        XForwardedFor_ClientCertIssuerDN?: string(name='XForwardedFor_ClientCertIssuerDN'),
        XForwardedFor_ClientCertSubjectDN?: string(name='XForwardedFor_ClientCertSubjectDN'),
        XForwardedFor_ClientSrcPort?: string(name='XForwardedFor_ClientSrcPort'),
        XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
        XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
        XForwardedFor_SLBPORT?: string(name='XForwardedFor_SLBPORT'),
        XForwardedFor_proto?: string(name='XForwardedFor_proto'),
      }(name='HTTPSListenerConfig'),
      listenerPort?: int32(name='ListenerPort'),
      listenerProtocol?: string(name='ListenerProtocol'),
      loadBalancerId?: string(name='LoadBalancerId'),
      scheduler?: string(name='Scheduler'),
      status?: string(name='Status'),
      TCPListenerConfig?: {
        connectionDrain?: string(name='ConnectionDrain'),
        connectionDrainTimeout?: int32(name='ConnectionDrainTimeout'),
        establishedTimeout?: int32(name='EstablishedTimeout'),
        healthCheck?: string(name='HealthCheck'),
        healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
        healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
        healthCheckDomain?: string(name='HealthCheckDomain'),
        healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
        healthCheckInterval?: int32(name='HealthCheckInterval'),
        healthCheckMethod?: string(name='HealthCheckMethod'),
        healthCheckType?: string(name='HealthCheckType'),
        healthCheckURI?: string(name='HealthCheckURI'),
        healthyThreshold?: int32(name='HealthyThreshold'),
        masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
        persistenceTimeout?: int32(name='PersistenceTimeout'),
        unhealthyThreshold?: int32(name='UnhealthyThreshold'),
      }(name='TCPListenerConfig'),
      UDPListenerConfig?: {
        connectionDrain?: string(name='ConnectionDrain'),
        connectionDrainTimeout?: int32(name='ConnectionDrainTimeout'),
        healthCheck?: string(name='HealthCheck'),
        healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
        healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
        healthCheckExp?: string(name='HealthCheckExp'),
        healthCheckInterval?: int32(name='HealthCheckInterval'),
        healthCheckReq?: string(name='HealthCheckReq'),
        healthyThreshold?: int32(name='HealthyThreshold'),
        masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
        unhealthyThreshold?: int32(name='UnhealthyThreshold'),
      }(name='UDPListenerConfig'),
      VServerGroupId?: string(name='VServerGroupId'),
    }
  ](name='Listeners'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeLoadBalancerListenersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerListenersResponseBody(name='body'),
}

async function describeLoadBalancerListeners(request: DescribeLoadBalancerListenersRequest): DescribeLoadBalancerListenersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLoadBalancerListeners', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLoadBalancerTCPListenerAttributeRequest {
  listenerPort: int32(name='ListenerPort', minimum=0, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeLoadBalancerTCPListenerAttributeResponseBody = {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  connectionDrain?: string(name='ConnectionDrain'),
  connectionDrainTimeout?: int32(name='ConnectionDrainTimeout'),
  description?: string(name='Description'),
  establishedTimeout?: int32(name='EstablishedTimeout'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckType?: string(name='HealthCheckType'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  listenerPort?: int32(name='ListenerPort'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  persistenceTimeout?: int32(name='PersistenceTimeout'),
  requestId?: string(name='RequestId'),
  scheduler?: string(name='Scheduler'),
  status?: string(name='Status'),
  synProxy?: string(name='SynProxy'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model DescribeLoadBalancerTCPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerTCPListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerTCPListenerAttribute(request: DescribeLoadBalancerTCPListenerAttributeRequest): DescribeLoadBalancerTCPListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLoadBalancerTCPListenerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLoadBalancerUDPListenerAttributeRequest {
  listenerPort: int32(name='ListenerPort', minimum=0, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeLoadBalancerUDPListenerAttributeResponseBody = {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  description?: string(name='Description'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthCheckExp?: string(name='HealthCheckExp'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckReq?: string(name='HealthCheckReq'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  listenerPort?: int32(name='ListenerPort'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  requestId?: string(name='RequestId'),
  scheduler?: string(name='Scheduler'),
  status?: string(name='Status'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model DescribeLoadBalancerUDPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerUDPListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerUDPListenerAttribute(request: DescribeLoadBalancerUDPListenerAttributeRequest): DescribeLoadBalancerUDPListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLoadBalancerUDPListenerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLoadBalancersRequest {
  address?: string(name='Address', position='Query'),
  addressIPVersion?: string(name='AddressIPVersion', position='Query'),
  addressType?: string(name='AddressType', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  loadBalancerId?: string(name='LoadBalancerId', position='Query'),
  loadBalancerName?: string(name='LoadBalancerName', position='Query'),
  loadBalancerStatus?: string(name='LoadBalancerStatus', position='Query'),
  masterZoneId?: string(name='MasterZoneId', position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=1000, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  payType?: string(name='PayType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serverId?: string(name='ServerId', position='Query'),
  serverIntranetAddress?: string(name='ServerIntranetAddress', position='Query'),
  slaveZoneId?: string(name='SlaveZoneId', position='Query'),
  tags?: string(name='Tags', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model DescribeLoadBalancersResponseBody = {
  loadBalancers?: {
    loadBalancer?: [ 
    {
      address?: string(name='Address'),
      addressIPVersion?: string(name='AddressIPVersion'),
      addressType?: string(name='AddressType'),
      bandwidth?: int32(name='Bandwidth'),
      createTime?: string(name='CreateTime'),
      createTimeStamp?: long(name='CreateTimeStamp'),
      deleteProtection?: string(name='DeleteProtection'),
      internetChargeType?: string(name='InternetChargeType'),
      internetChargeTypeAlias?: string(name='InternetChargeTypeAlias'),
      loadBalancerId?: string(name='LoadBalancerId'),
      loadBalancerName?: string(name='LoadBalancerName'),
      loadBalancerSpec?: string(name='LoadBalancerSpec'),
      loadBalancerStatus?: string(name='LoadBalancerStatus'),
      masterZoneId?: string(name='MasterZoneId'),
      modificationProtectionReason?: string(name='ModificationProtectionReason'),
      modificationProtectionStatus?: string(name='ModificationProtectionStatus'),
      networkType?: string(name='NetworkType'),
      payType?: string(name='PayType'),
      regionId?: string(name='RegionId'),
      regionIdAlias?: string(name='RegionIdAlias'),
      resourceGroupId?: string(name='ResourceGroupId'),
      slaveZoneId?: string(name='SlaveZoneId'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
    }
  ](name='LoadBalancer')
  }(name='LoadBalancers'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeLoadBalancersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancersResponseBody(name='body'),
}

async function describeLoadBalancers(request: DescribeLoadBalancersRequest): DescribeLoadBalancersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLoadBalancers', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMasterSlaveServerGroupAttributeRequest {
  masterSlaveServerGroupId: string(name='MasterSlaveServerGroupId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeMasterSlaveServerGroupAttributeResponseBody = {
  loadBalancerId?: string(name='LoadBalancerId'),
  masterSlaveBackendServers?: {
    masterSlaveBackendServer?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      serverType?: string(name='ServerType'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='MasterSlaveBackendServer')
  }(name='MasterSlaveBackendServers'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  masterSlaveServerGroupName?: string(name='MasterSlaveServerGroupName'),
  requestId?: string(name='RequestId'),
}

model DescribeMasterSlaveServerGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMasterSlaveServerGroupAttributeResponseBody(name='body'),
}

async function describeMasterSlaveServerGroupAttribute(request: DescribeMasterSlaveServerGroupAttributeRequest): DescribeMasterSlaveServerGroupAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMasterSlaveServerGroupAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMasterSlaveServerGroupsRequest {
  includeListener?: boolean(name='IncludeListener', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeMasterSlaveServerGroupsResponseBody = {
  masterSlaveServerGroups?: {
    masterSlaveServerGroup?: [ 
    {
      associatedObjects?: {
        listeners?: {
          listener?: [ 
          {
            port?: int32(name='Port'),
            protocol?: string(name='Protocol'),
          }
        ](name='Listener')
        }(name='Listeners'),
      }(name='AssociatedObjects'),
      masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
      masterSlaveServerGroupName?: string(name='MasterSlaveServerGroupName'),
    }
  ](name='MasterSlaveServerGroup')
  }(name='MasterSlaveServerGroups'),
  requestId?: string(name='RequestId'),
}

model DescribeMasterSlaveServerGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMasterSlaveServerGroupsResponseBody(name='body'),
}

async function describeMasterSlaveServerGroups(request: DescribeMasterSlaveServerGroupsRequest): DescribeMasterSlaveServerGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMasterSlaveServerGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRuleAttributeRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ruleId: string(name='RuleId', position='Query'),
}

model DescribeRuleAttributeResponseBody = {
  cookie?: string(name='Cookie'),
  cookieTimeout?: int32(name='CookieTimeout'),
  domain?: string(name='Domain'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  listenerPort?: string(name='ListenerPort'),
  listenerSync?: string(name='ListenerSync'),
  loadBalancerId?: string(name='LoadBalancerId'),
  requestId?: string(name='RequestId'),
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  scheduler?: string(name='Scheduler'),
  stickySession?: string(name='StickySession'),
  stickySessionType?: string(name='StickySessionType'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  url?: string(name='Url'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model DescribeRuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRuleAttributeResponseBody(name='body'),
}

async function describeRuleAttribute(request: DescribeRuleAttributeRequest): DescribeRuleAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRuleAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRulesRequest {
  listenerPort: int32(name='ListenerPort', position='Query'),
  listenerProtocol?: string(name='ListenerProtocol', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeRulesResponseBody = {
  requestId?: string(name='RequestId'),
  rules?: {
    rule?: [ 
    {
      cookie?: string(name='Cookie'),
      cookieTimeout?: int32(name='CookieTimeout'),
      domain?: string(name='Domain'),
      healthCheck?: string(name='HealthCheck'),
      healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
      healthCheckDomain?: string(name='HealthCheckDomain'),
      healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
      healthCheckInterval?: int32(name='HealthCheckInterval'),
      healthCheckTimeout?: int32(name='HealthCheckTimeout'),
      healthCheckURI?: string(name='HealthCheckURI'),
      healthyThreshold?: int32(name='HealthyThreshold'),
      listenerSync?: string(name='ListenerSync'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      scheduler?: string(name='Scheduler'),
      stickySession?: string(name='StickySession'),
      stickySessionType?: string(name='StickySessionType'),
      unhealthyThreshold?: int32(name='UnhealthyThreshold'),
      url?: string(name='Url'),
      VServerGroupId?: string(name='VServerGroupId'),
    }
  ](name='Rule')
  }(name='Rules'),
}

model DescribeRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRulesResponseBody(name='body'),
}

async function describeRules(request: DescribeRulesRequest): DescribeRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRules', 'POST', '/', 'json', false, 'json', request);
}

model DescribeServerCertificatesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serverCertificateId?: string(name='ServerCertificateId', position='Query'),
}

model DescribeServerCertificatesResponseBody = {
  requestId?: string(name='RequestId'),
  serverCertificates?: {
    serverCertificate?: [ 
    {
      aliCloudCertificateId?: string(name='AliCloudCertificateId'),
      aliCloudCertificateName?: string(name='AliCloudCertificateName'),
      commonName?: string(name='CommonName'),
      createTime?: string(name='CreateTime'),
      createTimeStamp?: long(name='CreateTimeStamp'),
      expireTime?: string(name='ExpireTime'),
      expireTimeStamp?: long(name='ExpireTimeStamp'),
      fingerprint?: string(name='Fingerprint'),
      isAliCloudCertificate?: int32(name='IsAliCloudCertificate'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      serverCertificateId?: string(name='ServerCertificateId'),
      serverCertificateName?: string(name='ServerCertificateName'),
      subjectAlternativeNames?: {
        subjectAlternativeName?: [ string ](name='SubjectAlternativeName')
      }(name='SubjectAlternativeNames'),
    }
  ](name='ServerCertificate')
  }(name='ServerCertificates'),
}

model DescribeServerCertificatesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServerCertificatesResponseBody(name='body'),
}

async function describeServerCertificates(request: DescribeServerCertificatesRequest): DescribeServerCertificatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeServerCertificates', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTagsRequest {
  distinctKey?: boolean(name='DistinctKey', position='Query'),
  loadBalancerId?: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tags?: string(name='Tags', position='Query'),
}

model DescribeTagsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  tagSets?: {
    tagSet?: [ 
    {
      instanceCount?: int32(name='InstanceCount'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagSet')
  }(name='TagSets'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeTagsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTagsResponseBody(name='body'),
}

async function describeTags(request: DescribeTagsRequest): DescribeTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTags', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVServerGroupAttributeRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  VServerGroupId: string(name='VServerGroupId', position='Query'),
}

model DescribeVServerGroupAttributeResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
  requestId?: string(name='RequestId'),
  VServerGroupId?: string(name='VServerGroupId'),
  VServerGroupName?: string(name='VServerGroupName'),
}

model DescribeVServerGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVServerGroupAttributeResponseBody(name='body'),
}

async function describeVServerGroupAttribute(request: DescribeVServerGroupAttributeRequest): DescribeVServerGroupAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVServerGroupAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVServerGroupsRequest {
  includeListener?: boolean(name='IncludeListener', position='Query'),
  includeRule?: boolean(name='IncludeRule', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeVServerGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  VServerGroups?: {
    VServerGroup?: [ 
    {
      associatedObjects?: {
        listeners?: {
          listener?: [ 
          {
            port?: int32(name='Port'),
            protocol?: string(name='Protocol'),
          }
        ](name='Listener')
        }(name='Listeners'),
        rules?: {
          rule?: [ 
          {
            domain?: string(name='Domain'),
            ruleId?: string(name='RuleId'),
            ruleName?: string(name='RuleName'),
            url?: string(name='Url'),
          }
        ](name='Rule')
        }(name='Rules'),
      }(name='AssociatedObjects'),
      serverCount?: long(name='ServerCount'),
      VServerGroupId?: string(name='VServerGroupId'),
      VServerGroupName?: string(name='VServerGroupName'),
    }
  ](name='VServerGroup')
  }(name='VServerGroups'),
}

model DescribeVServerGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVServerGroupsResponseBody(name='body'),
}

async function describeVServerGroups(request: DescribeVServerGroupsRequest): DescribeVServerGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVServerGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeZonesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: {
    zone?: [ 
    {
      localName?: string(name='LocalName'),
      slaveZones?: {
        slaveZone?: [ 
        {
          localName?: string(name='LocalName'),
          zoneId?: string(name='ZoneId'),
        }
      ](name='SlaveZone')
      }(name='SlaveZones'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Zone')
  }(name='Zones'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeZonesResponseBody(name='body'),
}

async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeZones', 'POST', '/', 'json', false, 'json', request);
}

model ListTLSCipherPoliciesRequest {
  includeListener?: boolean(name='IncludeListener', position='Query'),
  maxItems?: int32(name='MaxItems', position='Query'),
  name?: string(name='Name', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  TLSCipherPolicyId?: string(name='TLSCipherPolicyId', position='Query'),
}

model ListTLSCipherPoliciesResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  TLSCipherPolicies?: [ 
    {
      ciphers?: [ string ](name='Ciphers'),
      createTime?: long(name='CreateTime'),
      instanceId?: string(name='InstanceId'),
      name?: string(name='Name'),
      relateListeners?: [ 
        {
          loadBalancerId?: string(name='LoadBalancerId'),
          port?: int32(name='Port'),
          protocol?: string(name='Protocol'),
        }
      ](name='RelateListeners'),
      status?: string(name='Status'),
      TLSVersions?: [ string ](name='TLSVersions'),
    }
  ](name='TLSCipherPolicies'),
  totalCount?: int32(name='TotalCount'),
}

model ListTLSCipherPoliciesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTLSCipherPoliciesResponseBody(name='body'),
}

async function listTLSCipherPolicies(request: ListTLSCipherPoliciesRequest): ListTLSCipherPoliciesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTLSCipherPolicies', 'POST', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLoadBalancerInstanceSpecRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  loadBalancerSpec: string(name='LoadBalancerSpec', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyLoadBalancerInstanceSpecResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyLoadBalancerInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyLoadBalancerInstanceSpecResponseBody(name='body'),
}

async function modifyLoadBalancerInstanceSpec(request: ModifyLoadBalancerInstanceSpecRequest): ModifyLoadBalancerInstanceSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLoadBalancerInstanceSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLoadBalancerInternetSpecRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  bandwidth?: int32(name='Bandwidth', minimum=1, maximum=5000, position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyLoadBalancerInternetSpecResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyLoadBalancerInternetSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyLoadBalancerInternetSpecResponseBody(name='body'),
}

async function modifyLoadBalancerInternetSpec(request: ModifyLoadBalancerInternetSpecRequest): ModifyLoadBalancerInternetSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLoadBalancerInternetSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLoadBalancerPayTypeRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  duration?: int32(name='Duration', minimum=1, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payType?: string(name='PayType', position='Query'),
  pricingCycle?: string(name='PricingCycle', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyLoadBalancerPayTypeResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyLoadBalancerPayTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyLoadBalancerPayTypeResponseBody(name='body'),
}

async function modifyLoadBalancerPayType(request: ModifyLoadBalancerPayTypeRequest): ModifyLoadBalancerPayTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLoadBalancerPayType', 'POST', '/', 'json', false, 'json', request);
}

model ModifyVServerGroupBackendServersRequest {
  newBackendServers?: string(name='NewBackendServers', position='Query'),
  oldBackendServers?: string(name='OldBackendServers', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  VServerGroupId: string(name='VServerGroupId', position='Query'),
}

model ModifyVServerGroupBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model ModifyVServerGroupBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVServerGroupBackendServersResponseBody(name='body'),
}

async function modifyVServerGroupBackendServers(request: ModifyVServerGroupBackendServersRequest): ModifyVServerGroupBackendServersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVServerGroupBackendServers', 'POST', '/', 'json', false, 'json', request);
}

model RemoveAccessControlListEntryRequest {
  aclEntrys?: string(name='AclEntrys', position='Query'),
  aclId: string(name='AclId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RemoveAccessControlListEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveAccessControlListEntryResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveAccessControlListEntryResponseBody(name='body'),
}

async function removeAccessControlListEntry(request: RemoveAccessControlListEntryRequest): RemoveAccessControlListEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveAccessControlListEntry', 'POST', '/', 'json', false, 'json', request);
}

model RemoveBackendServersRequest {
  backendServers: string(name='BackendServers', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RemoveBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
  requestId?: string(name='RequestId'),
}

model RemoveBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveBackendServersResponseBody(name='body'),
}

async function removeBackendServers(request: RemoveBackendServersRequest): RemoveBackendServersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveBackendServers', 'POST', '/', 'json', false, 'json', request);
}

model RemoveListenerWhiteListItemRequest {
  listenerPort: int32(name='ListenerPort', minimum=1, maximum=65535, position='Query'),
  listenerProtocol?: string(name='ListenerProtocol', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sourceItems: string(name='SourceItems', position='Query'),
}

model RemoveListenerWhiteListItemResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveListenerWhiteListItemResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveListenerWhiteListItemResponseBody(name='body'),
}

async function removeListenerWhiteListItem(request: RemoveListenerWhiteListItemRequest): RemoveListenerWhiteListItemResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveListenerWhiteListItem', 'POST', '/', 'json', false, 'json', request);
}

model RemoveTagsRequest {
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tags: string(name='Tags', position='Query'),
}

model RemoveTagsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveTagsResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveTagsResponseBody(name='body'),
}

async function removeTags(request: RemoveTagsRequest): RemoveTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveTags', 'POST', '/', 'json', false, 'json', request);
}

model RemoveVServerGroupBackendServersRequest {
  backendServers: string(name='BackendServers', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  VServerGroupId: string(name='VServerGroupId', position='Query'),
}

model RemoveVServerGroupBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model RemoveVServerGroupBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveVServerGroupBackendServersResponseBody(name='body'),
}

async function removeVServerGroupBackendServers(request: RemoveVServerGroupBackendServersRequest): RemoveVServerGroupBackendServersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveVServerGroupBackendServers', 'POST', '/', 'json', false, 'json', request);
}

model SetAccessControlListAttributeRequest {
  aclId: string(name='AclId', position='Query'),
  aclName: string(name='AclName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model SetAccessControlListAttributeResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId'),
}

model SetAccessControlListAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetAccessControlListAttributeResponseBody(name='body'),
}

async function setAccessControlListAttribute(request: SetAccessControlListAttributeRequest): SetAccessControlListAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetAccessControlListAttribute', 'POST', '/', 'json', false, 'json', request);
}

model SetBackendServersRequest {
  backendServers?: string(name='BackendServers', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model SetBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: string(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
  requestId?: string(name='RequestId'),
}

model SetBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: SetBackendServersResponseBody(name='body'),
}

async function setBackendServers(request: SetBackendServersRequest): SetBackendServersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetBackendServers', 'POST', '/', 'json', false, 'json', request);
}

model SetCACertificateNameRequest {
  CACertificateId: string(name='CACertificateId', position='Query'),
  CACertificateName: string(name='CACertificateName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model SetCACertificateNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetCACertificateNameResponse = {
  headers: map[string]string(name='headers'),
  body: SetCACertificateNameResponseBody(name='body'),
}

async function setCACertificateName(request: SetCACertificateNameRequest): SetCACertificateNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetCACertificateName', 'POST', '/', 'json', false, 'json', request);
}

model SetDomainExtensionAttributeRequest {
  domainExtensionId: string(name='DomainExtensionId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serverCertificateId?: string(name='ServerCertificateId', position='Query'),
}

model SetDomainExtensionAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetDomainExtensionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetDomainExtensionAttributeResponseBody(name='body'),
}

async function setDomainExtensionAttribute(request: SetDomainExtensionAttributeRequest): SetDomainExtensionAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDomainExtensionAttribute', 'POST', '/', 'json', false, 'json', request);
}

model SetListenerAccessControlStatusRequest {
  accessControlStatus: string(name='AccessControlStatus', position='Query'),
  listenerPort: int32(name='ListenerPort', minimum=1, maximum=65535, position='Query'),
  listenerProtocol?: string(name='ListenerProtocol', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model SetListenerAccessControlStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetListenerAccessControlStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetListenerAccessControlStatusResponseBody(name='body'),
}

async function setListenerAccessControlStatus(request: SetListenerAccessControlStatusRequest): SetListenerAccessControlStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetListenerAccessControlStatus', 'POST', '/', 'json', false, 'json', request);
}

model SetLoadBalancerDeleteProtectionRequest {
  deleteProtection: string(name='DeleteProtection', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model SetLoadBalancerDeleteProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerDeleteProtectionResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerDeleteProtectionResponseBody(name='body'),
}

async function setLoadBalancerDeleteProtection(request: SetLoadBalancerDeleteProtectionRequest): SetLoadBalancerDeleteProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLoadBalancerDeleteProtection', 'POST', '/', 'json', false, 'json', request);
}

model SetLoadBalancerHTTPListenerAttributeRequest {
  aclId?: string(name='AclId', position='Query'),
  aclStatus?: string(name='AclStatus', position='Query'),
  aclType?: string(name='AclType', position='Query'),
  bandwidth?: int32(name='Bandwidth', minimum=-1, maximum=5120, position='Query'),
  cookie?: string(name='Cookie', position='Query'),
  cookieTimeout?: int32(name='CookieTimeout', minimum=1, maximum=86400, position='Query'),
  description?: string(name='Description', position='Query'),
  gzip?: string(name='Gzip', position='Query'),
  healthCheck?: string(name='HealthCheck', position='Query'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', minimum=-520, maximum=65535, position='Query'),
  healthCheckDomain?: string(name='HealthCheckDomain', position='Query'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', position='Query'),
  healthCheckInterval?: int32(name='HealthCheckInterval', minimum=1, maximum=50, position='Query'),
  healthCheckMethod?: string(name='HealthCheckMethod', position='Query'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', minimum=1, maximum=300, position='Query'),
  healthCheckURI?: string(name='HealthCheckURI', position='Query'),
  healthyThreshold?: int32(name='HealthyThreshold', minimum=1, maximum=10, position='Query'),
  idleTimeout?: int32(name='IdleTimeout', minimum=1, maximum=9999, position='Query'),
  listenerPort: int32(name='ListenerPort', minimum=1, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  requestTimeout?: int32(name='RequestTimeout', minimum=1, maximum=9999, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scheduler?: string(name='Scheduler', position='Query'),
  stickySession?: string(name='StickySession', position='Query'),
  stickySessionType?: string(name='StickySessionType', position='Query'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', minimum=1, maximum=10, position='Query'),
  VServerGroup?: string(name='VServerGroup', position='Query'),
  VServerGroupId?: string(name='VServerGroupId', position='Query'),
  XForwardedFor?: string(name='XForwardedFor', position='Query'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID', position='Query'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP', position='Query'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto', position='Query'),
}

model SetLoadBalancerHTTPListenerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerHTTPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerHTTPListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerHTTPListenerAttribute(request: SetLoadBalancerHTTPListenerAttributeRequest): SetLoadBalancerHTTPListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLoadBalancerHTTPListenerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model SetLoadBalancerHTTPSListenerAttributeRequest {
  aclId?: string(name='AclId', position='Query'),
  aclStatus?: string(name='AclStatus', position='Query'),
  aclType?: string(name='AclType', position='Query'),
  bandwidth?: int32(name='Bandwidth', minimum=-1, maximum=5120, position='Query'),
  CACertificateId?: string(name='CACertificateId', position='Query'),
  cookie?: string(name='Cookie', position='Query'),
  cookieTimeout?: int32(name='CookieTimeout', minimum=1, maximum=86400, position='Query'),
  description?: string(name='Description', position='Query'),
  enableHttp2?: string(name='EnableHttp2', position='Query'),
  gzip?: string(name='Gzip', position='Query'),
  healthCheck?: string(name='HealthCheck', position='Query'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', minimum=-520, maximum=65535, position='Query'),
  healthCheckDomain?: string(name='HealthCheckDomain', position='Query'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', position='Query'),
  healthCheckInterval?: int32(name='HealthCheckInterval', minimum=1, maximum=50, position='Query'),
  healthCheckMethod?: string(name='HealthCheckMethod', position='Query'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', minimum=1, maximum=300, position='Query'),
  healthCheckURI?: string(name='HealthCheckURI', position='Query'),
  healthyThreshold?: int32(name='HealthyThreshold', minimum=1, maximum=10, position='Query'),
  idleTimeout?: int32(name='IdleTimeout', minimum=1, maximum=9999, position='Query'),
  listenerPort: int32(name='ListenerPort', minimum=1, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  requestTimeout?: int32(name='RequestTimeout', minimum=1, maximum=9999, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scheduler?: string(name='Scheduler', position='Query'),
  serverCertificateId?: string(name='ServerCertificateId', position='Query'),
  stickySession?: string(name='StickySession', position='Query'),
  stickySessionType?: string(name='StickySessionType', position='Query'),
  TLSCipherPolicy?: string(name='TLSCipherPolicy', position='Query'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', minimum=1, maximum=10, position='Query'),
  VServerGroup?: string(name='VServerGroup', position='Query'),
  VServerGroupId?: string(name='VServerGroupId', position='Query'),
  XForwardedFor?: string(name='XForwardedFor', position='Query'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID', position='Query'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP', position='Query'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto', position='Query'),
}

model SetLoadBalancerHTTPSListenerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerHTTPSListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerHTTPSListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerHTTPSListenerAttribute(request: SetLoadBalancerHTTPSListenerAttributeRequest): SetLoadBalancerHTTPSListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLoadBalancerHTTPSListenerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model SetLoadBalancerModificationProtectionRequest {
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  modificationProtectionReason?: string(name='ModificationProtectionReason', position='Query'),
  modificationProtectionStatus: string(name='ModificationProtectionStatus', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model SetLoadBalancerModificationProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerModificationProtectionResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerModificationProtectionResponseBody(name='body'),
}

async function setLoadBalancerModificationProtection(request: SetLoadBalancerModificationProtectionRequest): SetLoadBalancerModificationProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLoadBalancerModificationProtection', 'POST', '/', 'json', false, 'json', request);
}

model SetLoadBalancerNameRequest {
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  loadBalancerName: string(name='LoadBalancerName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model SetLoadBalancerNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerNameResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerNameResponseBody(name='body'),
}

async function setLoadBalancerName(request: SetLoadBalancerNameRequest): SetLoadBalancerNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLoadBalancerName', 'POST', '/', 'json', false, 'json', request);
}

model SetLoadBalancerStatusRequest {
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  loadBalancerStatus: string(name='LoadBalancerStatus', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model SetLoadBalancerStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerStatusResponseBody(name='body'),
}

async function setLoadBalancerStatus(request: SetLoadBalancerStatusRequest): SetLoadBalancerStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLoadBalancerStatus', 'POST', '/', 'json', false, 'json', request);
}

model SetLoadBalancerTCPListenerAttributeRequest {
  aclId?: string(name='AclId', position='Query'),
  aclStatus?: string(name='AclStatus', position='Query'),
  aclType?: string(name='AclType', position='Query'),
  bandwidth?: int32(name='Bandwidth', minimum=-1, maximum=5120, position='Query'),
  connectionDrain?: string(name='ConnectionDrain', position='Query'),
  connectionDrainTimeout?: int32(name='ConnectionDrainTimeout', position='Query'),
  description?: string(name='Description', position='Query'),
  establishedTimeout?: int32(name='EstablishedTimeout', minimum=10, maximum=900, position='Query'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', minimum=1, maximum=65535, position='Query'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', minimum=1, maximum=300, position='Query'),
  healthCheckDomain?: string(name='HealthCheckDomain', position='Query'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', position='Query'),
  healthCheckInterval?: int32(name='HealthCheckInterval', minimum=1, maximum=50, position='Query'),
  healthCheckType?: string(name='HealthCheckType', position='Query'),
  healthCheckURI?: string(name='HealthCheckURI', position='Query'),
  healthyThreshold?: int32(name='HealthyThreshold', minimum=1, maximum=10, position='Query'),
  listenerPort: int32(name='ListenerPort', minimum=0, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  masterSlaveServerGroup?: string(name='MasterSlaveServerGroup', position='Query'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  persistenceTimeout?: int32(name='PersistenceTimeout', minimum=0, maximum=3600, position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scheduler?: string(name='Scheduler', position='Query'),
  synProxy?: string(name='SynProxy', position='Query'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', minimum=1, maximum=10, position='Query'),
  VServerGroup?: string(name='VServerGroup', position='Query'),
  VServerGroupId?: string(name='VServerGroupId', position='Query'),
}

model SetLoadBalancerTCPListenerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerTCPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerTCPListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerTCPListenerAttribute(request: SetLoadBalancerTCPListenerAttributeRequest): SetLoadBalancerTCPListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLoadBalancerTCPListenerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model SetLoadBalancerUDPListenerAttributeRequest {
  aclId?: string(name='AclId', position='Query'),
  aclStatus?: string(name='AclStatus', position='Query'),
  aclType?: string(name='AclType', position='Query'),
  bandwidth?: int32(name='Bandwidth', minimum=-1, maximum=5120, position='Query'),
  description?: string(name='Description', position='Query'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', minimum=1, maximum=65535, position='Query'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', minimum=1, maximum=300, position='Query'),
  healthCheckInterval?: int32(name='HealthCheckInterval', minimum=1, maximum=50, position='Query'),
  healthyThreshold?: int32(name='HealthyThreshold', minimum=1, maximum=10, position='Query'),
  listenerPort: int32(name='ListenerPort', minimum=0, maximum=65535, position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  masterSlaveServerGroup?: string(name='MasterSlaveServerGroup', position='Query'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scheduler?: string(name='Scheduler', position='Query'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', minimum=1, maximum=10, position='Query'),
  VServerGroup?: string(name='VServerGroup', position='Query'),
  VServerGroupId?: string(name='VServerGroupId', position='Query'),
  healthCheckExp?: string(name='healthCheckExp', position='Query'),
  healthCheckReq?: string(name='healthCheckReq', position='Query'),
}

model SetLoadBalancerUDPListenerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerUDPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerUDPListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerUDPListenerAttribute(request: SetLoadBalancerUDPListenerAttributeRequest): SetLoadBalancerUDPListenerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLoadBalancerUDPListenerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model SetRuleRequest {
  cookie?: string(name='Cookie', position='Query'),
  cookieTimeout?: int32(name='CookieTimeout', minimum=1, maximum=86400, position='Query'),
  healthCheck?: string(name='HealthCheck', position='Query'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', minimum=1, maximum=65535, position='Query'),
  healthCheckDomain?: string(name='HealthCheckDomain', position='Query'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', position='Query'),
  healthCheckInterval?: int32(name='HealthCheckInterval', minimum=1, maximum=50, position='Query'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', minimum=1, maximum=300, position='Query'),
  healthCheckURI?: string(name='HealthCheckURI', position='Query'),
  healthyThreshold?: int32(name='HealthyThreshold', minimum=1, maximum=10, position='Query'),
  listenerSync?: string(name='ListenerSync', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ruleId: string(name='RuleId', position='Query'),
  ruleName?: string(name='RuleName', position='Query'),
  scheduler?: string(name='Scheduler', position='Query'),
  stickySession?: string(name='StickySession', position='Query'),
  stickySessionType?: string(name='StickySessionType', position='Query'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', minimum=1, maximum=10, position='Query'),
  VServerGroupId?: string(name='VServerGroupId', position='Query'),
}

model SetRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetRuleResponse = {
  headers: map[string]string(name='headers'),
  body: SetRuleResponseBody(name='body'),
}

async function setRule(request: SetRuleRequest): SetRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetRule', 'POST', '/', 'json', false, 'json', request);
}

model SetServerCertificateNameRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serverCertificateId: string(name='ServerCertificateId', position='Query'),
  serverCertificateName: string(name='ServerCertificateName', position='Query'),
}

model SetServerCertificateNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetServerCertificateNameResponse = {
  headers: map[string]string(name='headers'),
  body: SetServerCertificateNameResponseBody(name='body'),
}

async function setServerCertificateName(request: SetServerCertificateNameRequest): SetServerCertificateNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetServerCertificateName', 'POST', '/', 'json', false, 'json', request);
}

model SetTLSCipherPolicyAttributeRequest {
  ciphers: [ string ](name='Ciphers', position='Query'),
  name: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  TLSCipherPolicyId: string(name='TLSCipherPolicyId', position='Query'),
  TLSVersions: [ string ](name='TLSVersions', position='Query'),
}

model SetTLSCipherPolicyAttributeResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model SetTLSCipherPolicyAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetTLSCipherPolicyAttributeResponseBody(name='body'),
}

async function setTLSCipherPolicyAttribute(request: SetTLSCipherPolicyAttributeRequest): SetTLSCipherPolicyAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetTLSCipherPolicyAttribute', 'POST', '/', 'json', false, 'json', request);
}

model SetVServerGroupAttributeRequest {
  backendServers?: string(name='BackendServers', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  VServerGroupId: string(name='VServerGroupId', position='Query'),
  VServerGroupName?: string(name='VServerGroupName', position='Query'),
}

model SetVServerGroupAttributeResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId'),
  VServerGroupId?: string(name='VServerGroupId'),
  VServerGroupName?: string(name='VServerGroupName'),
}

model SetVServerGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetVServerGroupAttributeResponseBody(name='body'),
}

async function setVServerGroupAttribute(request: SetVServerGroupAttributeRequest): SetVServerGroupAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetVServerGroupAttribute', 'POST', '/', 'json', false, 'json', request);
}

model StartLoadBalancerListenerRequest {
  listenerPort: int32(name='ListenerPort', minimum=0, maximum=65535, position='Query'),
  listenerProtocol?: string(name='ListenerProtocol', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model StartLoadBalancerListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartLoadBalancerListenerResponse = {
  headers: map[string]string(name='headers'),
  body: StartLoadBalancerListenerResponseBody(name='body'),
}

async function startLoadBalancerListener(request: StartLoadBalancerListenerRequest): StartLoadBalancerListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartLoadBalancerListener', 'POST', '/', 'json', false, 'json', request);
}

model StopLoadBalancerListenerRequest {
  listenerPort: int32(name='ListenerPort', minimum=0, maximum=65535, position='Query'),
  listenerProtocol?: string(name='ListenerProtocol', position='Query'),
  loadBalancerId: string(name='LoadBalancerId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model StopLoadBalancerListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopLoadBalancerListenerResponse = {
  headers: map[string]string(name='headers'),
  body: StopLoadBalancerListenerResponseBody(name='body'),
}

async function stopLoadBalancerListener(request: StopLoadBalancerListenerRequest): StopLoadBalancerListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopLoadBalancerListener', 'POST', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tagKey?: [ string ](name='TagKey', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

model UploadCACertificateRequest {
  CACertificate: string(name='CACertificate', position='Query'),
  CACertificateName?: string(name='CACertificateName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UploadCACertificateResponseBody = {
  CACertificateId?: string(name='CACertificateId'),
  CACertificateName?: string(name='CACertificateName'),
  commonName?: string(name='CommonName'),
  createTime?: string(name='CreateTime'),
  createTimeStamp?: long(name='CreateTimeStamp'),
  expireTime?: string(name='ExpireTime'),
  expireTimeStamp?: long(name='ExpireTimeStamp'),
  fingerprint?: string(name='Fingerprint'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model UploadCACertificateResponse = {
  headers: map[string]string(name='headers'),
  body: UploadCACertificateResponseBody(name='body'),
}

async function uploadCACertificate(request: UploadCACertificateRequest): UploadCACertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UploadCACertificate', 'POST', '/', 'json', false, 'json', request);
}

model UploadServerCertificateRequest {
  aliCloudCertificateId?: string(name='AliCloudCertificateId', position='Query'),
  aliCloudCertificateName?: string(name='AliCloudCertificateName', position='Query'),
  aliCloudCertificateRegionId?: string(name='AliCloudCertificateRegionId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  privateKey?: string(name='PrivateKey', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serverCertificate?: string(name='ServerCertificate', position='Query'),
  serverCertificateName?: string(name='ServerCertificateName', position='Query'),
}

model UploadServerCertificateResponseBody = {
  aliCloudCertificateId?: string(name='AliCloudCertificateId'),
  aliCloudCertificateName?: string(name='AliCloudCertificateName'),
  commonName?: string(name='CommonName'),
  createTime?: string(name='CreateTime'),
  createTimeStamp?: long(name='CreateTimeStamp'),
  expireTime?: string(name='ExpireTime'),
  expireTimeStamp?: long(name='ExpireTimeStamp'),
  fingerprint?: string(name='Fingerprint'),
  isAliCloudCertificate?: int32(name='IsAliCloudCertificate'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  serverCertificateId?: string(name='ServerCertificateId'),
  serverCertificateName?: string(name='ServerCertificateName'),
  subjectAlternativeNames?: {
    subjectAlternativeName?: [ string ](name='SubjectAlternativeName')
  }(name='SubjectAlternativeNames'),
}

model UploadServerCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: UploadServerCertificateResponseBody(name='body'),
}

async function uploadServerCertificate(request: UploadServerCertificateRequest): UploadServerCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UploadServerCertificate', 'POST', '/', 'json', false, 'json', request);
}

