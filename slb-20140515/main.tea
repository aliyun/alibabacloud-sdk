/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  @endpointMap = {
    cn-qingdao = 'slb.aliyuncs.com',
    cn-beijing = 'slb.aliyuncs.com',
    cn-hangzhou = 'slb.aliyuncs.com',
    cn-shanghai = 'slb.aliyuncs.com',
    cn-shenzhen = 'slb.aliyuncs.com',
    cn-hongkong = 'slb.aliyuncs.com',
    ap-southeast-1 = 'slb.aliyuncs.com',
    us-west-1 = 'slb.aliyuncs.com',
    us-east-1 = 'slb.aliyuncs.com',
    cn-shanghai-finance-1 = 'slb.aliyuncs.com',
    cn-shenzhen-finance-1 = 'slb.aliyuncs.com',
    cn-north-2-gov-1 = 'slb.aliyuncs.com',
    ap-northeast-2-pop = 'slb.aliyuncs.com',
    cn-beijing-finance-1 = 'slb.aliyuncs.com',
    cn-beijing-finance-pop = 'slb.aliyuncs.com',
    cn-beijing-gov-1 = 'slb.aliyuncs.com',
    cn-beijing-nu16-b01 = 'slb.aliyuncs.com',
    cn-edge-1 = 'slb.aliyuncs.com',
    cn-fujian = 'slb.aliyuncs.com',
    cn-haidian-cm12-c01 = 'slb.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'slb.aliyuncs.com',
    cn-hangzhou-finance = 'slb.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'slb.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'slb.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'slb.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'slb.aliyuncs.com',
    cn-hangzhou-test-306 = 'slb.aliyuncs.com',
    cn-hongkong-finance-pop = 'slb.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'slb-api.cn-qingdao-nebula.aliyuncs.com',
    cn-shanghai-et15-b01 = 'slb.aliyuncs.com',
    cn-shanghai-et2-b01 = 'slb.aliyuncs.com',
    cn-shanghai-inner = 'slb.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'slb.aliyuncs.com',
    cn-shenzhen-inner = 'slb.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'slb.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'slb.aliyuncs.com',
    cn-wuhan = 'slb.aliyuncs.com',
    cn-yushanfang = 'slb.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'slb.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'slb.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'slb.aliyuncs.com',
    eu-west-1-oxs = 'slb.aliyuncs.com',
    rus-west-1-pop = 'slb.aliyuncs.com',
  };
  checkConfig(config);
  @endpoint = getEndpoint('slb', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AddAccessControlListEntryRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  aclId?: string(name='AclId'),
  aclEntrys?: string(name='AclEntrys'),
}

model AddAccessControlListEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddAccessControlListEntryResponse = {
  headers: map[string]string(name='headers'),
  body: AddAccessControlListEntryResponseBody(name='body'),
}

async function addAccessControlListEntryWithOptions(request: AddAccessControlListEntryRequest, runtime: Util.RuntimeOptions): AddAccessControlListEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddAccessControlListEntry', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addAccessControlListEntry(request: AddAccessControlListEntryRequest): AddAccessControlListEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAccessControlListEntryWithOptions(request, runtime);
}

model AddBackendServersRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  backendServers?: string(name='BackendServers'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AddBackendServersResponseBody = {
  loadBalancerId?: string(name='LoadBalancerId'),
  requestId?: string(name='RequestId'),
  backendServers?: {
    backendServer?: [ 
    {
      type?: string(name='Type'),
      weight?: string(name='Weight'),
      description?: string(name='Description'),
      serverId?: string(name='ServerId'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
}

model AddBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: AddBackendServersResponseBody(name='body'),
}

async function addBackendServersWithOptions(request: AddBackendServersRequest, runtime: Util.RuntimeOptions): AddBackendServersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddBackendServers', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addBackendServers(request: AddBackendServersRequest): AddBackendServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBackendServersWithOptions(request, runtime);
}

model AddListenerWhiteListItemRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  sourceItems?: string(name='SourceItems'),
  ownerAccount?: string(name='OwnerAccount'),
  listenerProtocol?: string(name='ListenerProtocol'),
}

model AddListenerWhiteListItemResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddListenerWhiteListItemResponse = {
  headers: map[string]string(name='headers'),
  body: AddListenerWhiteListItemResponseBody(name='body'),
}

async function addListenerWhiteListItemWithOptions(request: AddListenerWhiteListItemRequest, runtime: Util.RuntimeOptions): AddListenerWhiteListItemResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddListenerWhiteListItem', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addListenerWhiteListItem(request: AddListenerWhiteListItemRequest): AddListenerWhiteListItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return addListenerWhiteListItemWithOptions(request, runtime);
}

model AddTagsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  tags?: string(name='Tags'),
}

model AddTagsResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddTagsResponse = {
  headers: map[string]string(name='headers'),
  body: AddTagsResponseBody(name='body'),
}

async function addTagsWithOptions(request: AddTagsRequest, runtime: Util.RuntimeOptions): AddTagsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddTags', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addTags(request: AddTagsRequest): AddTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTagsWithOptions(request, runtime);
}

model AddVServerGroupBackendServersRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  VServerGroupId?: string(name='VServerGroupId'),
  backendServers?: string(name='BackendServers'),
}

model AddVServerGroupBackendServersResponseBody = {
  VServerGroupId?: string(name='VServerGroupId'),
  requestId?: string(name='RequestId'),
  backendServers?: {
    backendServer?: [ 
    {
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
}

model AddVServerGroupBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: AddVServerGroupBackendServersResponseBody(name='body'),
}

async function addVServerGroupBackendServersWithOptions(request: AddVServerGroupBackendServersRequest, runtime: Util.RuntimeOptions): AddVServerGroupBackendServersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddVServerGroupBackendServers', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addVServerGroupBackendServers(request: AddVServerGroupBackendServersRequest): AddVServerGroupBackendServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVServerGroupBackendServersWithOptions(request, runtime);
}

model CreateAccessControlListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  aclName?: string(name='AclName'),
  addressIPVersion?: string(name='AddressIPVersion'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateAccessControlListResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId'),
}

model CreateAccessControlListResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAccessControlListResponseBody(name='body'),
}

async function createAccessControlListWithOptions(request: CreateAccessControlListRequest, runtime: Util.RuntimeOptions): CreateAccessControlListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateAccessControlList', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createAccessControlList(request: CreateAccessControlListRequest): CreateAccessControlListResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccessControlListWithOptions(request, runtime);
}

model CreateDomainExtensionRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  domain?: string(name='Domain'),
  serverCertificateId?: string(name='ServerCertificateId'),
}

model CreateDomainExtensionResponseBody = {
  listenerPort?: int32(name='ListenerPort'),
  requestId?: string(name='RequestId'),
  domainExtensionId?: string(name='DomainExtensionId'),
}

model CreateDomainExtensionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDomainExtensionResponseBody(name='body'),
}

async function createDomainExtensionWithOptions(request: CreateDomainExtensionRequest, runtime: Util.RuntimeOptions): CreateDomainExtensionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateDomainExtension', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createDomainExtension(request: CreateDomainExtensionRequest): CreateDomainExtensionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDomainExtensionWithOptions(request, runtime);
}

model CreateLoadBalancerRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  addressType?: string(name='AddressType'),
  internetChargeType?: string(name='InternetChargeType'),
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  loadBalancerName?: string(name='LoadBalancerName'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  ownerAccount?: string(name='OwnerAccount'),
  masterZoneId?: string(name='MasterZoneId'),
  slaveZoneId?: string(name='SlaveZoneId'),
  loadBalancerSpec?: string(name='LoadBalancerSpec'),
  resourceGroupId?: string(name='ResourceGroupId'),
  payType?: string(name='PayType'),
  pricingCycle?: string(name='PricingCycle'),
  duration?: int32(name='Duration'),
  autoPay?: boolean(name='AutoPay'),
  addressIPVersion?: string(name='AddressIPVersion'),
  address?: string(name='Address'),
  deleteProtection?: string(name='DeleteProtection'),
  modificationProtectionStatus?: string(name='ModificationProtectionStatus'),
  modificationProtectionReason?: string(name='ModificationProtectionReason'),
}

model CreateLoadBalancerResponseBody = {
  vpcId?: string(name='VpcId'),
  addressIPVersion?: string(name='AddressIPVersion'),
  vSwitchId?: string(name='VSwitchId'),
  requestId?: string(name='RequestId'),
  loadBalancerName?: string(name='LoadBalancerName'),
  loadBalancerId?: string(name='LoadBalancerId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  address?: string(name='Address'),
  networkType?: string(name='NetworkType'),
  orderId?: long(name='OrderId'),
}

model CreateLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerResponseBody(name='body'),
}

async function createLoadBalancerWithOptions(request: CreateLoadBalancerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateLoadBalancer', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createLoadBalancer(request: CreateLoadBalancerRequest): CreateLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerWithOptions(request, runtime);
}

model CreateLoadBalancerHTTPListenerRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  bandwidth?: int32(name='Bandwidth'),
  listenerPort?: int32(name='ListenerPort'),
  backendServerPort?: int32(name='BackendServerPort'),
  XForwardedFor?: string(name='XForwardedFor'),
  scheduler?: string(name='Scheduler'),
  stickySession?: string(name='StickySession'),
  stickySessionType?: string(name='StickySessionType'),
  cookieTimeout?: int32(name='CookieTimeout'),
  cookie?: string(name='Cookie'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  ownerAccount?: string(name='OwnerAccount'),
  VServerGroupId?: string(name='VServerGroupId'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto'),
  gzip?: string(name='Gzip'),
  aclId?: string(name='AclId'),
  aclType?: string(name='AclType'),
  aclStatus?: string(name='AclStatus'),
  description?: string(name='Description'),
  listenerForward?: string(name='ListenerForward'),
  forwardPort?: int32(name='ForwardPort'),
  idleTimeout?: int32(name='IdleTimeout'),
  requestTimeout?: int32(name='RequestTimeout'),
}

model CreateLoadBalancerHTTPListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateLoadBalancerHTTPListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerHTTPListenerResponseBody(name='body'),
}

async function createLoadBalancerHTTPListenerWithOptions(request: CreateLoadBalancerHTTPListenerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerHTTPListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateLoadBalancerHTTPListener', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createLoadBalancerHTTPListener(request: CreateLoadBalancerHTTPListenerRequest): CreateLoadBalancerHTTPListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerHTTPListenerWithOptions(request, runtime);
}

model CreateLoadBalancerHTTPSListenerRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  bandwidth?: int32(name='Bandwidth'),
  listenerPort?: int32(name='ListenerPort'),
  backendServerPort?: int32(name='BackendServerPort'),
  XForwardedFor?: string(name='XForwardedFor'),
  scheduler?: string(name='Scheduler'),
  stickySession?: string(name='StickySession'),
  stickySessionType?: string(name='StickySessionType'),
  cookieTimeout?: int32(name='CookieTimeout'),
  cookie?: string(name='Cookie'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  serverCertificateId?: string(name='ServerCertificateId'),
  ownerAccount?: string(name='OwnerAccount'),
  VServerGroupId?: string(name='VServerGroupId'),
  CACertificateId?: string(name='CACertificateId'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto'),
  gzip?: string(name='Gzip'),
  aclId?: string(name='AclId'),
  aclType?: string(name='AclType'),
  aclStatus?: string(name='AclStatus'),
  description?: string(name='Description'),
  idleTimeout?: int32(name='IdleTimeout'),
  requestTimeout?: int32(name='RequestTimeout'),
  enableHttp2?: string(name='EnableHttp2'),
  TLSCipherPolicy?: string(name='TLSCipherPolicy'),
}

model CreateLoadBalancerHTTPSListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateLoadBalancerHTTPSListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerHTTPSListenerResponseBody(name='body'),
}

async function createLoadBalancerHTTPSListenerWithOptions(request: CreateLoadBalancerHTTPSListenerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerHTTPSListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateLoadBalancerHTTPSListener', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createLoadBalancerHTTPSListener(request: CreateLoadBalancerHTTPSListenerRequest): CreateLoadBalancerHTTPSListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerHTTPSListenerWithOptions(request, runtime);
}

model CreateLoadBalancerTCPListenerRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  scheduler?: string(name='Scheduler'),
  persistenceTimeout?: int32(name='PersistenceTimeout'),
  establishedTimeout?: int32(name='EstablishedTimeout'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckInterval?: int32(name='healthCheckInterval'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckType?: string(name='HealthCheckType'),
  ownerAccount?: string(name='OwnerAccount'),
  VServerGroupId?: string(name='VServerGroupId'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  aclId?: string(name='AclId'),
  aclType?: string(name='AclType'),
  aclStatus?: string(name='AclStatus'),
  description?: string(name='Description'),
  connectionDrain?: string(name='ConnectionDrain'),
  connectionDrainTimeout?: int32(name='ConnectionDrainTimeout'),
}

model CreateLoadBalancerTCPListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateLoadBalancerTCPListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerTCPListenerResponseBody(name='body'),
}

async function createLoadBalancerTCPListenerWithOptions(request: CreateLoadBalancerTCPListenerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerTCPListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateLoadBalancerTCPListener', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createLoadBalancerTCPListener(request: CreateLoadBalancerTCPListenerRequest): CreateLoadBalancerTCPListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerTCPListenerWithOptions(request, runtime);
}

model CreateLoadBalancerUDPListenerRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  scheduler?: string(name='Scheduler'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckInterval?: int32(name='healthCheckInterval'),
  healthCheckReq?: string(name='healthCheckReq'),
  healthCheckExp?: string(name='healthCheckExp'),
  ownerAccount?: string(name='OwnerAccount'),
  VServerGroupId?: string(name='VServerGroupId'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  aclId?: string(name='AclId'),
  aclType?: string(name='AclType'),
  aclStatus?: string(name='AclStatus'),
  description?: string(name='Description'),
}

model CreateLoadBalancerUDPListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateLoadBalancerUDPListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerUDPListenerResponseBody(name='body'),
}

async function createLoadBalancerUDPListenerWithOptions(request: CreateLoadBalancerUDPListenerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerUDPListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateLoadBalancerUDPListener', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createLoadBalancerUDPListener(request: CreateLoadBalancerUDPListenerRequest): CreateLoadBalancerUDPListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerUDPListenerWithOptions(request, runtime);
}

model CreateMasterSlaveServerGroupRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  loadBalancerId?: string(name='LoadBalancerId'),
  masterSlaveServerGroupName?: string(name='MasterSlaveServerGroupName'),
  masterSlaveBackendServers?: string(name='MasterSlaveBackendServers'),
}

model CreateMasterSlaveServerGroupResponseBody = {
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  requestId?: string(name='RequestId'),
  masterSlaveBackendServers?: {
    masterSlaveBackendServer?: [ 
    {
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      serverType?: string(name='ServerType'),
    }
  ](name='MasterSlaveBackendServer')
  }(name='MasterSlaveBackendServers'),
}

model CreateMasterSlaveServerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMasterSlaveServerGroupResponseBody(name='body'),
}

async function createMasterSlaveServerGroupWithOptions(request: CreateMasterSlaveServerGroupRequest, runtime: Util.RuntimeOptions): CreateMasterSlaveServerGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateMasterSlaveServerGroup', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createMasterSlaveServerGroup(request: CreateMasterSlaveServerGroupRequest): CreateMasterSlaveServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMasterSlaveServerGroupWithOptions(request, runtime);
}

model CreateRulesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  ruleList?: string(name='RuleList'),
}

model CreateRulesResponseBody = {
  requestId?: string(name='RequestId'),
  rules?: {
    rule?: [ 
    {
      ruleName?: string(name='RuleName'),
      ruleId?: string(name='RuleId'),
    }
  ](name='Rule')
  }(name='Rules'),
}

model CreateRulesResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRulesResponseBody(name='body'),
}

async function createRulesWithOptions(request: CreateRulesRequest, runtime: Util.RuntimeOptions): CreateRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateRules', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createRules(request: CreateRulesRequest): CreateRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRulesWithOptions(request, runtime);
}

model CreateTLSCipherPolicyRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  accessKeyId?: string(name='access_key_id'),
  name?: string(name='Name'),
  ciphers?: [ string ](name='Ciphers'),
  TLSVersions?: [ string ](name='TLSVersions'),
}

model CreateTLSCipherPolicyResponseBody = {
  TLSCipherPolicyId?: string(name='TLSCipherPolicyId'),
  requestId?: string(name='RequestId'),
}

model CreateTLSCipherPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTLSCipherPolicyResponseBody(name='body'),
}

async function createTLSCipherPolicyWithOptions(request: CreateTLSCipherPolicyRequest, runtime: Util.RuntimeOptions): CreateTLSCipherPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateTLSCipherPolicy', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createTLSCipherPolicy(request: CreateTLSCipherPolicyRequest): CreateTLSCipherPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTLSCipherPolicyWithOptions(request, runtime);
}

model CreateVServerGroupRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  loadBalancerId?: string(name='LoadBalancerId'),
  VServerGroupName?: string(name='VServerGroupName'),
  backendServers?: string(name='BackendServers'),
}

model CreateVServerGroupResponseBody = {
  VServerGroupId?: string(name='VServerGroupId'),
  requestId?: string(name='RequestId'),
  backendServers?: {
    backendServer?: [ 
    {
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
}

model CreateVServerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVServerGroupResponseBody(name='body'),
}

async function createVServerGroupWithOptions(request: CreateVServerGroupRequest, runtime: Util.RuntimeOptions): CreateVServerGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVServerGroup', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVServerGroup(request: CreateVServerGroupRequest): CreateVServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVServerGroupWithOptions(request, runtime);
}

model DeleteAccessControlListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  aclId?: string(name='AclId'),
}

model DeleteAccessControlListResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAccessControlListResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAccessControlListResponseBody(name='body'),
}

async function deleteAccessControlListWithOptions(request: DeleteAccessControlListRequest, runtime: Util.RuntimeOptions): DeleteAccessControlListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteAccessControlList', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteAccessControlList(request: DeleteAccessControlListRequest): DeleteAccessControlListResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccessControlListWithOptions(request, runtime);
}

model DeleteCACertificateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  CACertificateId?: string(name='CACertificateId'),
}

model DeleteCACertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCACertificateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCACertificateResponseBody(name='body'),
}

async function deleteCACertificateWithOptions(request: DeleteCACertificateRequest, runtime: Util.RuntimeOptions): DeleteCACertificateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteCACertificate', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteCACertificate(request: DeleteCACertificateRequest): DeleteCACertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCACertificateWithOptions(request, runtime);
}

model DeleteDomainExtensionRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  domainExtensionId?: string(name='DomainExtensionId'),
}

model DeleteDomainExtensionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDomainExtensionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDomainExtensionResponseBody(name='body'),
}

async function deleteDomainExtensionWithOptions(request: DeleteDomainExtensionRequest, runtime: Util.RuntimeOptions): DeleteDomainExtensionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteDomainExtension', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteDomainExtension(request: DeleteDomainExtensionRequest): DeleteDomainExtensionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDomainExtensionWithOptions(request, runtime);
}

model DeleteLoadBalancerRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteLoadBalancerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLoadBalancerResponseBody(name='body'),
}

async function deleteLoadBalancerWithOptions(request: DeleteLoadBalancerRequest, runtime: Util.RuntimeOptions): DeleteLoadBalancerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteLoadBalancer', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteLoadBalancer(request: DeleteLoadBalancerRequest): DeleteLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLoadBalancerWithOptions(request, runtime);
}

model DeleteLoadBalancerListenerRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteLoadBalancerListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLoadBalancerListenerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLoadBalancerListenerResponseBody(name='body'),
}

async function deleteLoadBalancerListenerWithOptions(request: DeleteLoadBalancerListenerRequest, runtime: Util.RuntimeOptions): DeleteLoadBalancerListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteLoadBalancerListener', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteLoadBalancerListener(request: DeleteLoadBalancerListenerRequest): DeleteLoadBalancerListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLoadBalancerListenerWithOptions(request, runtime);
}

model DeleteMasterSlaveServerGroupRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
}

model DeleteMasterSlaveServerGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMasterSlaveServerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMasterSlaveServerGroupResponseBody(name='body'),
}

async function deleteMasterSlaveServerGroupWithOptions(request: DeleteMasterSlaveServerGroupRequest, runtime: Util.RuntimeOptions): DeleteMasterSlaveServerGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMasterSlaveServerGroup', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMasterSlaveServerGroup(request: DeleteMasterSlaveServerGroupRequest): DeleteMasterSlaveServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMasterSlaveServerGroupWithOptions(request, runtime);
}

model DeleteRulesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  ruleIds?: string(name='RuleIds'),
}

model DeleteRulesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRulesResponseBody(name='body'),
}

async function deleteRulesWithOptions(request: DeleteRulesRequest, runtime: Util.RuntimeOptions): DeleteRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteRules', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteRules(request: DeleteRulesRequest): DeleteRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRulesWithOptions(request, runtime);
}

model DeleteServerCertificateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  serverCertificateId?: string(name='ServerCertificateId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteServerCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteServerCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteServerCertificateResponseBody(name='body'),
}

async function deleteServerCertificateWithOptions(request: DeleteServerCertificateRequest, runtime: Util.RuntimeOptions): DeleteServerCertificateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteServerCertificate', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteServerCertificate(request: DeleteServerCertificateRequest): DeleteServerCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServerCertificateWithOptions(request, runtime);
}

model DeleteTLSCipherPolicyRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  accessKeyId?: string(name='access_key_id'),
  TLSCipherPolicyId?: string(name='TLSCipherPolicyId'),
}

model DeleteTLSCipherPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTLSCipherPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTLSCipherPolicyResponseBody(name='body'),
}

async function deleteTLSCipherPolicyWithOptions(request: DeleteTLSCipherPolicyRequest, runtime: Util.RuntimeOptions): DeleteTLSCipherPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteTLSCipherPolicy', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteTLSCipherPolicy(request: DeleteTLSCipherPolicyRequest): DeleteTLSCipherPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTLSCipherPolicyWithOptions(request, runtime);
}

model DeleteVServerGroupRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model DeleteVServerGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVServerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVServerGroupResponseBody(name='body'),
}

async function deleteVServerGroupWithOptions(request: DeleteVServerGroupRequest, runtime: Util.RuntimeOptions): DeleteVServerGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVServerGroup', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVServerGroup(request: DeleteVServerGroupRequest): DeleteVServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVServerGroupWithOptions(request, runtime);
}

model DescribeAccessControlListAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  aclId?: string(name='AclId'),
  aclEntryComment?: string(name='AclEntryComment'),
}

model DescribeAccessControlListAttributeResponseBody = {
  aclId?: string(name='AclId'),
  addressIPVersion?: string(name='AddressIPVersion'),
  requestId?: string(name='RequestId'),
  aclName?: string(name='AclName'),
  resourceGroupId?: string(name='ResourceGroupId'),
  aclEntrys?: {
    aclEntry?: [ 
    {
      aclEntryComment?: string(name='AclEntryComment'),
      aclEntryIP?: string(name='AclEntryIP'),
    }
  ](name='AclEntry')
  }(name='AclEntrys'),
  relatedListeners?: {
    relatedListener?: [ 
    {
      listenerPort?: int32(name='ListenerPort'),
      aclType?: string(name='AclType'),
      protocol?: string(name='Protocol'),
      loadBalancerId?: string(name='LoadBalancerId'),
    }
  ](name='RelatedListener')
  }(name='RelatedListeners'),
}

model DescribeAccessControlListAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccessControlListAttributeResponseBody(name='body'),
}

async function describeAccessControlListAttributeWithOptions(request: DescribeAccessControlListAttributeRequest, runtime: Util.RuntimeOptions): DescribeAccessControlListAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeAccessControlListAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeAccessControlListAttribute(request: DescribeAccessControlListAttributeRequest): DescribeAccessControlListAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccessControlListAttributeWithOptions(request, runtime);
}

model DescribeAccessControlListsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  aclName?: string(name='AclName'),
  addressIPVersion?: string(name='AddressIPVersion'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeAccessControlListsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  count?: int32(name='Count'),
  acls?: {
    acl?: [ 
    {
      aclId?: string(name='AclId'),
      addressIPVersion?: string(name='AddressIPVersion'),
      aclName?: string(name='AclName'),
      resourceGroupId?: string(name='ResourceGroupId'),
    }
  ](name='Acl')
  }(name='Acls'),
}

model DescribeAccessControlListsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccessControlListsResponseBody(name='body'),
}

async function describeAccessControlListsWithOptions(request: DescribeAccessControlListsRequest, runtime: Util.RuntimeOptions): DescribeAccessControlListsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeAccessControlLists', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeAccessControlLists(request: DescribeAccessControlListsRequest): DescribeAccessControlListsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccessControlListsWithOptions(request, runtime);
}

model DescribeAvailableResourceRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  addressType?: string(name='AddressType'),
  addressIPVersion?: string(name='AddressIPVersion'),
}

model DescribeAvailableResourceResponseBody = {
  requestId?: string(name='RequestId'),
  availableResources?: {
    availableResource?: [ 
    {
      slaveZoneId?: string(name='SlaveZoneId'),
      masterZoneId?: string(name='MasterZoneId'),
      supportResources?: {
        supportResource?: [ 
        {
          addressType?: string(name='AddressType'),
          addressIPVersion?: string(name='AddressIPVersion'),
        }
      ](name='SupportResource')
      }(name='SupportResources'),
    }
  ](name='AvailableResource')
  }(name='AvailableResources'),
}

model DescribeAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableResourceResponseBody(name='body'),
}

async function describeAvailableResourceWithOptions(request: DescribeAvailableResourceRequest, runtime: Util.RuntimeOptions): DescribeAvailableResourceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeAvailableResource', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeAvailableResource(request: DescribeAvailableResourceRequest): DescribeAvailableResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableResourceWithOptions(request, runtime);
}

model DescribeCACertificatesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  CACertificateId?: string(name='CACertificateId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeCACertificatesResponseBody = {
  requestId?: string(name='RequestId'),
  CACertificates?: {
    CACertificate?: [ 
    {
      createTimeStamp?: long(name='CreateTimeStamp'),
      expireTime?: string(name='ExpireTime'),
      createTime?: string(name='CreateTime'),
      expireTimeStamp?: long(name='ExpireTimeStamp'),
      CACertificateId?: string(name='CACertificateId'),
      regionId?: string(name='RegionId'),
      fingerprint?: string(name='Fingerprint'),
      resourceGroupId?: string(name='ResourceGroupId'),
      commonName?: string(name='CommonName'),
      CACertificateName?: string(name='CACertificateName'),
    }
  ](name='CACertificate')
  }(name='CACertificates'),
}

model DescribeCACertificatesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCACertificatesResponseBody(name='body'),
}

async function describeCACertificatesWithOptions(request: DescribeCACertificatesRequest, runtime: Util.RuntimeOptions): DescribeCACertificatesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeCACertificates', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeCACertificates(request: DescribeCACertificatesRequest): DescribeCACertificatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCACertificatesWithOptions(request, runtime);
}

model DescribeDomainExtensionAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  domainExtensionId?: string(name='DomainExtensionId'),
}

model DescribeDomainExtensionAttributeResponseBody = {
  domain?: string(name='Domain'),
  requestId?: string(name='RequestId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  serverCertificateId?: string(name='ServerCertificateId'),
  domainExtensionId?: string(name='DomainExtensionId'),
}

model DescribeDomainExtensionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainExtensionAttributeResponseBody(name='body'),
}

async function describeDomainExtensionAttributeWithOptions(request: DescribeDomainExtensionAttributeRequest, runtime: Util.RuntimeOptions): DescribeDomainExtensionAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeDomainExtensionAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeDomainExtensionAttribute(request: DescribeDomainExtensionAttributeRequest): DescribeDomainExtensionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainExtensionAttributeWithOptions(request, runtime);
}

model DescribeDomainExtensionsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  domainExtensionId?: string(name='DomainExtensionId'),
}

model DescribeDomainExtensionsResponseBody = {
  requestId?: string(name='RequestId'),
  domainExtensions?: {
    domainExtension?: [ 
    {
      serverCertificateId?: string(name='ServerCertificateId'),
      domain?: string(name='Domain'),
      domainExtensionId?: string(name='DomainExtensionId'),
    }
  ](name='DomainExtension')
  }(name='DomainExtensions'),
}

model DescribeDomainExtensionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainExtensionsResponseBody(name='body'),
}

async function describeDomainExtensionsWithOptions(request: DescribeDomainExtensionsRequest, runtime: Util.RuntimeOptions): DescribeDomainExtensionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeDomainExtensions', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeDomainExtensions(request: DescribeDomainExtensionsRequest): DescribeDomainExtensionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainExtensionsWithOptions(request, runtime);
}

model DescribeHealthStatusRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  ownerAccount?: string(name='OwnerAccount'),
  listenerProtocol?: string(name='ListenerProtocol'),
  regionId?: string(name='RegionId'),
}

model DescribeHealthStatusResponseBody = {
  requestId?: string(name='RequestId'),
  backendServers?: {
    backendServer?: [ 
    {
      protocol?: string(name='Protocol'),
      serverHealthStatus?: string(name='ServerHealthStatus'),
      listenerPort?: int32(name='ListenerPort'),
      serverIp?: string(name='ServerIp'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
}

model DescribeHealthStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHealthStatusResponseBody(name='body'),
}

async function describeHealthStatusWithOptions(request: DescribeHealthStatusRequest, runtime: Util.RuntimeOptions): DescribeHealthStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeHealthStatus', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeHealthStatus(request: DescribeHealthStatusRequest): DescribeHealthStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHealthStatusWithOptions(request, runtime);
}

model DescribeListenerAccessControlAttributeRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeListenerAccessControlAttributeResponseBody = {
  sourceItems?: string(name='SourceItems'),
  accessControlStatus?: string(name='AccessControlStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeListenerAccessControlAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeListenerAccessControlAttributeResponseBody(name='body'),
}

async function describeListenerAccessControlAttributeWithOptions(request: DescribeListenerAccessControlAttributeRequest, runtime: Util.RuntimeOptions): DescribeListenerAccessControlAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeListenerAccessControlAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeListenerAccessControlAttribute(request: DescribeListenerAccessControlAttributeRequest): DescribeListenerAccessControlAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeListenerAccessControlAttributeWithOptions(request, runtime);
}

model DescribeLoadBalancerAttributeRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeLoadBalancerAttributeResponseBody = {
  vpcId?: string(name='VpcId'),
  createTimeStamp?: long(name='CreateTimeStamp'),
  createTime?: string(name='CreateTime'),
  loadBalancerId?: string(name='LoadBalancerId'),
  payType?: string(name='PayType'),
  addressType?: string(name='AddressType'),
  networkType?: string(name='NetworkType'),
  addressIPVersion?: string(name='AddressIPVersion'),
  renewalCycUnit?: string(name='RenewalCycUnit'),
  requestId?: string(name='RequestId'),
  bandwidth?: int32(name='Bandwidth'),
  loadBalancerName?: string(name='LoadBalancerName'),
  address?: string(name='Address'),
  slaveZoneId?: string(name='SlaveZoneId'),
  endTimeStamp?: long(name='EndTimeStamp'),
  masterZoneId?: string(name='MasterZoneId'),
  loadBalancerSpec?: string(name='LoadBalancerSpec'),
  autoReleaseTime?: long(name='AutoReleaseTime'),
  modificationProtectionReason?: string(name='ModificationProtectionReason'),
  regionId?: string(name='RegionId'),
  modificationProtectionStatus?: string(name='ModificationProtectionStatus'),
  endTime?: string(name='EndTime'),
  vSwitchId?: string(name='VSwitchId'),
  loadBalancerStatus?: string(name='LoadBalancerStatus'),
  resourceGroupId?: string(name='ResourceGroupId'),
  internetChargeType?: string(name='InternetChargeType'),
  deleteProtection?: string(name='DeleteProtection'),
  regionIdAlias?: string(name='RegionIdAlias'),
  renewalStatus?: string(name='RenewalStatus'),
  renewalDuration?: int32(name='RenewalDuration'),
  listenerPorts?: {
    listenerPort?: [ int32 ](name='ListenerPort')
  }(name='ListenerPorts'),
  listenerPortsAndProtocal?: {
    listenerPortAndProtocal?: [ 
    {
      listenerProtocal?: string(name='ListenerProtocal'),
      listenerPort?: int32(name='ListenerPort'),
    }
  ](name='ListenerPortAndProtocal')
  }(name='ListenerPortsAndProtocal'),
  listenerPortsAndProtocol?: {
    listenerPortAndProtocol?: [ 
    {
      listenerPort?: int32(name='ListenerPort'),
      listenerProtocol?: string(name='ListenerProtocol'),
      listenerForward?: string(name='ListenerForward'),
      description?: string(name='Description'),
      forwardPort?: int32(name='ForwardPort'),
    }
  ](name='ListenerPortAndProtocol')
  }(name='ListenerPortsAndProtocol'),
  backendServers?: {
    backendServer?: [ 
    {
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
      description?: string(name='Description'),
      serverId?: string(name='ServerId'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
}

model DescribeLoadBalancerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerAttributeWithOptions(request: DescribeLoadBalancerAttributeRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeLoadBalancerAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeLoadBalancerAttribute(request: DescribeLoadBalancerAttributeRequest): DescribeLoadBalancerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerAttributeWithOptions(request, runtime);
}

model DescribeLoadBalancerHTTPListenerAttributeRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeLoadBalancerHTTPListenerAttributeResponseBody = {
  aclType?: string(name='AclType'),
  VServerGroupId?: string(name='VServerGroupId'),
  status?: string(name='Status'),
  cookie?: string(name='Cookie'),
  gzip?: string(name='Gzip'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  requestId?: string(name='RequestId'),
  description?: string(name='Description'),
  bandwidth?: int32(name='Bandwidth'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  aclStatus?: string(name='AclStatus'),
  backendServerPort?: int32(name='BackendServerPort'),
  cookieTimeout?: int32(name='CookieTimeout'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  forwardPort?: int32(name='ForwardPort'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
  securityStatus?: string(name='SecurityStatus'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  listenerForward?: string(name='ListenerForward'),
  XForwardedFor?: string(name='XForwardedFor'),
  idleTimeout?: int32(name='IdleTimeout'),
  requestTimeout?: int32(name='RequestTimeout'),
  listenerPort?: int32(name='ListenerPort'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckURI?: string(name='HealthCheckURI'),
  stickySessionType?: string(name='StickySessionType'),
  aclId?: string(name='AclId'),
  scheduler?: string(name='Scheduler'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
  stickySession?: string(name='StickySession'),
  healthCheck?: string(name='HealthCheck'),
  rules?: {
    rule?: [ 
    {
      VServerGroupId?: string(name='VServerGroupId'),
      url?: string(name='Url'),
      domain?: string(name='Domain'),
      ruleName?: string(name='RuleName'),
      ruleId?: string(name='RuleId'),
    }
  ](name='Rule')
  }(name='Rules'),
}

model DescribeLoadBalancerHTTPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerHTTPListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerHTTPListenerAttributeWithOptions(request: DescribeLoadBalancerHTTPListenerAttributeRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerHTTPListenerAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeLoadBalancerHTTPListenerAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeLoadBalancerHTTPListenerAttribute(request: DescribeLoadBalancerHTTPListenerAttributeRequest): DescribeLoadBalancerHTTPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerHTTPListenerAttributeWithOptions(request, runtime);
}

model DescribeLoadBalancerHTTPSListenerAttributeRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeLoadBalancerHTTPSListenerAttributeResponseBody = {
  aclType?: string(name='AclType'),
  XForwardedFor_ClientCertClientVerify?: string(name='XForwardedFor_ClientCertClientVerify'),
  CACertificateId?: string(name='CACertificateId'),
  requestId?: string(name='RequestId'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  backendServerPort?: int32(name='BackendServerPort'),
  cookieTimeout?: int32(name='CookieTimeout'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  XForwardedFor?: string(name='XForwardedFor'),
  XForwardedFor_ClientCertFingerprint?: string(name='XForwardedFor_ClientCertFingerprint'),
  idleTimeout?: int32(name='IdleTimeout'),
  listenerPort?: int32(name='ListenerPort'),
  healthCheckURI?: string(name='HealthCheckURI'),
  XForwardedFor_SLBPORT?: string(name='XForwardedFor_SLBPORT'),
  stickySessionType?: string(name='StickySessionType'),
  scheduler?: string(name='Scheduler'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto'),
  TLSCipherPolicy?: string(name='TLSCipherPolicy'),
  status?: string(name='Status'),
  VServerGroupId?: string(name='VServerGroupId'),
  XForwardedFor_ClientSrcPort?: string(name='XForwardedFor_ClientSrcPort'),
  cookie?: string(name='Cookie'),
  gzip?: string(name='Gzip'),
  enableHttp2?: string(name='EnableHttp2'),
  bandwidth?: int32(name='Bandwidth'),
  description?: string(name='Description'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  aclStatus?: string(name='AclStatus'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
  XForwardedFor_ClientCertSubjectDN?: string(name='XForwardedFor_ClientCertSubjectDN'),
  securityStatus?: string(name='SecurityStatus'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  requestTimeout?: int32(name='RequestTimeout'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  serverCertificateId?: string(name='ServerCertificateId'),
  aclId?: string(name='AclId'),
  XForwardedFor_ClientCertIssuerDN?: string(name='XForwardedFor_ClientCertIssuerDN'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
  stickySession?: string(name='StickySession'),
  healthCheck?: string(name='HealthCheck'),
  rules?: {
    rule?: [ 
    {
      VServerGroupId?: string(name='VServerGroupId'),
      url?: string(name='Url'),
      domain?: string(name='Domain'),
      ruleName?: string(name='RuleName'),
      ruleId?: string(name='RuleId'),
    }
  ](name='Rule')
  }(name='Rules'),
  domainExtensions?: {
    domainExtension?: [ 
    {
      serverCertificateId?: string(name='ServerCertificateId'),
      domain?: string(name='Domain'),
      domainExtensionId?: string(name='DomainExtensionId'),
    }
  ](name='DomainExtension')
  }(name='DomainExtensions'),
}

model DescribeLoadBalancerHTTPSListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerHTTPSListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerHTTPSListenerAttributeWithOptions(request: DescribeLoadBalancerHTTPSListenerAttributeRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerHTTPSListenerAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeLoadBalancerHTTPSListenerAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeLoadBalancerHTTPSListenerAttribute(request: DescribeLoadBalancerHTTPSListenerAttributeRequest): DescribeLoadBalancerHTTPSListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerHTTPSListenerAttributeWithOptions(request, runtime);
}

model DescribeLoadBalancerListenersRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  listenerProtocol?: string(name='ListenerProtocol'),
  loadBalancerId?: [ string ](name='LoadBalancerId'),
}

model DescribeLoadBalancerListenersResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  maxResults?: int32(name='MaxResults'),
  listeners?: [ 
    {
      aclType?: string(name='AclType'),
      status?: string(name='Status'),
      VServerGroupId?: string(name='VServerGroupId'),
      listenerProtocol?: string(name='ListenerProtocol'),
      loadBalancerId?: string(name='LoadBalancerId'),
      listenerPort?: int32(name='ListenerPort'),
      aclId?: string(name='AclId'),
      scheduler?: string(name='Scheduler'),
      bandwidth?: int32(name='Bandwidth'),
      description?: string(name='Description'),
      aclStatus?: string(name='AclStatus'),
      backendServerPort?: int32(name='BackendServerPort'),
      HTTPListenerConfig?: {
        healthCheckHttpVersion?: string(name='HealthCheckHttpVersion'),
        XForwardedFor_ClientSrcPort?: string(name='XForwardedFor_ClientSrcPort'),
        cookie?: string(name='Cookie'),
        gzip?: string(name='Gzip'),
        healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
        healthCheckTimeout?: int32(name='HealthCheckTimeout'),
        healthCheckType?: string(name='HealthCheckType'),
        cookieTimeout?: int32(name='CookieTimeout'),
        healthCheckDomain?: string(name='HealthCheckDomain'),
        unhealthyThreshold?: int32(name='UnhealthyThreshold'),
        XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
        forwardPort?: int32(name='ForwardPort'),
        healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
        listenerForward?: string(name='ListenerForward'),
        XForwardedFor?: string(name='XForwardedFor'),
        idleTimeout?: int32(name='IdleTimeout'),
        requestTimeout?: int32(name='RequestTimeout'),
        healthCheckInterval?: int32(name='HealthCheckInterval'),
        XForwardedFor_SLBPORT?: string(name='XForwardedFor_SLBPORT'),
        healthCheckURI?: string(name='HealthCheckURI'),
        stickySessionType?: string(name='StickySessionType'),
        healthyThreshold?: int32(name='HealthyThreshold'),
        XForwardedFor_proto?: string(name='XForwardedFor_proto'),
        XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
        stickySession?: string(name='StickySession'),
        healthCheckMethod?: string(name='HealthCheckMethod'),
        healthCheck?: string(name='HealthCheck'),
      }(name='HTTPListenerConfig'),
      HTTPSListenerConfig?: {
        XForwardedFor_ClientCertClientVerify?: string(name='XForwardedFor_ClientCertClientVerify'),
        healthCheckHttpVersion?: string(name='HealthCheckHttpVersion'),
        XForwardedFor_ClientSrcPort?: string(name='XForwardedFor_ClientSrcPort'),
        cookie?: string(name='Cookie'),
        gzip?: string(name='Gzip'),
        enableHttp2?: string(name='EnableHttp2'),
        CACertificateId?: string(name='CACertificateId'),
        healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
        healthCheckTimeout?: int32(name='HealthCheckTimeout'),
        healthCheckType?: string(name='HealthCheckType'),
        cookieTimeout?: int32(name='CookieTimeout'),
        healthCheckDomain?: string(name='HealthCheckDomain'),
        unhealthyThreshold?: int32(name='UnhealthyThreshold'),
        XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
        XForwardedFor_ClientCertSubjectDN?: string(name='XForwardedFor_ClientCertSubjectDN'),
        healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
        XForwardedFor_ClientCertFingerprint?: string(name='XForwardedFor_ClientCertFingerprint'),
        XForwardedFor?: string(name='XForwardedFor'),
        requestTimeout?: int32(name='RequestTimeout'),
        idleTimeout?: int32(name='IdleTimeout'),
        serverCertificateId?: string(name='ServerCertificateId'),
        healthCheckInterval?: int32(name='HealthCheckInterval'),
        XForwardedFor_SLBPORT?: string(name='XForwardedFor_SLBPORT'),
        healthCheckURI?: string(name='HealthCheckURI'),
        stickySessionType?: string(name='StickySessionType'),
        XForwardedFor_ClientCertIssuerDN?: string(name='XForwardedFor_ClientCertIssuerDN'),
        healthyThreshold?: int32(name='HealthyThreshold'),
        XForwardedFor_proto?: string(name='XForwardedFor_proto'),
        XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
        stickySession?: string(name='StickySession'),
        healthCheckMethod?: string(name='HealthCheckMethod'),
        TLSCipherPolicy?: string(name='TLSCipherPolicy'),
        healthCheck?: string(name='HealthCheck'),
      }(name='HTTPSListenerConfig'),
      TCPListenerConfig?: {
        healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
        connectionDrainTimeout?: int32(name='ConnectionDrainTimeout'),
        persistenceTimeout?: int32(name='PersistenceTimeout'),
        healthCheckInterval?: int32(name='HealthCheckInterval'),
        healthCheckURI?: string(name='HealthCheckURI'),
        healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
        establishedTimeout?: int32(name='EstablishedTimeout'),
        healthCheckType?: string(name='HealthCheckType'),
        healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
        masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
        healthyThreshold?: int32(name='HealthyThreshold'),
        healthCheckDomain?: string(name='HealthCheckDomain'),
        unhealthyThreshold?: int32(name='UnhealthyThreshold'),
        connectionDrain?: string(name='ConnectionDrain'),
        healthCheckMethod?: string(name='HealthCheckMethod'),
        healthCheck?: string(name='HealthCheck'),
      }(name='TCPListenerConfig'),
      UDPListenerConfig?: {
        connectionDrainTimeout?: int32(name='ConnectionDrainTimeout'),
        healthCheckInterval?: int32(name='HealthCheckInterval'),
        healthCheckExp?: string(name='HealthCheckExp'),
        healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
        healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
        masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
        healthyThreshold?: int32(name='HealthyThreshold'),
        unhealthyThreshold?: int32(name='UnhealthyThreshold'),
        connectionDrain?: string(name='ConnectionDrain'),
        healthCheckReq?: string(name='HealthCheckReq'),
        healthCheck?: string(name='HealthCheck'),
      }(name='UDPListenerConfig'),
    }
  ](name='Listeners'),
}

model DescribeLoadBalancerListenersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerListenersResponseBody(name='body'),
}

async function describeLoadBalancerListenersWithOptions(request: DescribeLoadBalancerListenersRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerListenersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeLoadBalancerListeners', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeLoadBalancerListeners(request: DescribeLoadBalancerListenersRequest): DescribeLoadBalancerListenersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerListenersWithOptions(request, runtime);
}

model DescribeLoadBalancersRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  serverId?: string(name='ServerId'),
  addressIPVersion?: string(name='AddressIPVersion'),
  loadBalancerStatus?: string(name='LoadBalancerStatus'),
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerName?: string(name='LoadBalancerName'),
  serverIntranetAddress?: string(name='ServerIntranetAddress'),
  addressType?: string(name='AddressType'),
  internetChargeType?: string(name='InternetChargeType'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  networkType?: string(name='NetworkType'),
  address?: string(name='Address'),
  masterZoneId?: string(name='MasterZoneId'),
  slaveZoneId?: string(name='SlaveZoneId'),
  ownerAccount?: string(name='OwnerAccount'),
  tags?: string(name='Tags'),
  payType?: string(name='PayType'),
  resourceGroupId?: string(name='ResourceGroupId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeLoadBalancersResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  totalCount?: int32(name='TotalCount'),
  loadBalancers?: {
    loadBalancer?: [ 
    {
      vpcId?: string(name='VpcId'),
      createTimeStamp?: long(name='CreateTimeStamp'),
      loadBalancerId?: string(name='LoadBalancerId'),
      createTime?: string(name='CreateTime'),
      payType?: string(name='PayType'),
      addressType?: string(name='AddressType'),
      networkType?: string(name='NetworkType'),
      addressIPVersion?: string(name='AddressIPVersion'),
      loadBalancerName?: string(name='LoadBalancerName'),
      bandwidth?: int32(name='Bandwidth'),
      address?: string(name='Address'),
      slaveZoneId?: string(name='SlaveZoneId'),
      masterZoneId?: string(name='MasterZoneId'),
      internetChargeTypeAlias?: string(name='InternetChargeTypeAlias'),
      loadBalancerSpec?: string(name='LoadBalancerSpec'),
      regionId?: string(name='RegionId'),
      modificationProtectionReason?: string(name='ModificationProtectionReason'),
      modificationProtectionStatus?: string(name='ModificationProtectionStatus'),
      vSwitchId?: string(name='VSwitchId'),
      loadBalancerStatus?: string(name='LoadBalancerStatus'),
      resourceGroupId?: string(name='ResourceGroupId'),
      internetChargeType?: string(name='InternetChargeType'),
      deleteProtection?: string(name='DeleteProtection'),
      regionIdAlias?: string(name='RegionIdAlias'),
    }
  ](name='LoadBalancer')
  }(name='LoadBalancers'),
}

model DescribeLoadBalancersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancersResponseBody(name='body'),
}

async function describeLoadBalancersWithOptions(request: DescribeLoadBalancersRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeLoadBalancers', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeLoadBalancers(request: DescribeLoadBalancersRequest): DescribeLoadBalancersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancersWithOptions(request, runtime);
}

model DescribeLoadBalancerTCPListenerAttributeRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeLoadBalancerTCPListenerAttributeResponseBody = {
  VServerGroupId?: string(name='VServerGroupId'),
  status?: string(name='Status'),
  aclType?: string(name='AclType'),
  connectionDrainTimeout?: int32(name='ConnectionDrainTimeout'),
  requestId?: string(name='RequestId'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  description?: string(name='Description'),
  bandwidth?: int32(name='Bandwidth'),
  healthCheckType?: string(name='HealthCheckType'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  backendServerPort?: int32(name='BackendServerPort'),
  aclStatus?: string(name='AclStatus'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  persistenceTimeout?: int32(name='PersistenceTimeout'),
  listenerPort?: int32(name='ListenerPort'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckURI?: string(name='HealthCheckURI'),
  aclId?: string(name='AclId'),
  synProxy?: string(name='SynProxy'),
  scheduler?: string(name='Scheduler'),
  establishedTimeout?: int32(name='EstablishedTimeout'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  connectionDrain?: string(name='ConnectionDrain'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheck?: string(name='HealthCheck'),
}

model DescribeLoadBalancerTCPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerTCPListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerTCPListenerAttributeWithOptions(request: DescribeLoadBalancerTCPListenerAttributeRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerTCPListenerAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeLoadBalancerTCPListenerAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeLoadBalancerTCPListenerAttribute(request: DescribeLoadBalancerTCPListenerAttributeRequest): DescribeLoadBalancerTCPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerTCPListenerAttributeWithOptions(request, runtime);
}

model DescribeLoadBalancerUDPListenerAttributeRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeLoadBalancerUDPListenerAttributeResponseBody = {
  VServerGroupId?: string(name='VServerGroupId'),
  status?: string(name='Status'),
  aclType?: string(name='AclType'),
  requestId?: string(name='RequestId'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  description?: string(name='Description'),
  bandwidth?: int32(name='Bandwidth'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  backendServerPort?: int32(name='BackendServerPort'),
  aclStatus?: string(name='AclStatus'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  listenerPort?: int32(name='ListenerPort'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckExp?: string(name='HealthCheckExp'),
  aclId?: string(name='AclId'),
  scheduler?: string(name='Scheduler'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  healthCheckReq?: string(name='HealthCheckReq'),
  healthCheck?: string(name='HealthCheck'),
}

model DescribeLoadBalancerUDPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLoadBalancerUDPListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerUDPListenerAttributeWithOptions(request: DescribeLoadBalancerUDPListenerAttributeRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerUDPListenerAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeLoadBalancerUDPListenerAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeLoadBalancerUDPListenerAttribute(request: DescribeLoadBalancerUDPListenerAttributeRequest): DescribeLoadBalancerUDPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerUDPListenerAttributeWithOptions(request, runtime);
}

model DescribeMasterSlaveServerGroupAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
}

model DescribeMasterSlaveServerGroupAttributeResponseBody = {
  requestId?: string(name='RequestId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  masterSlaveServerGroupName?: string(name='MasterSlaveServerGroupName'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  masterSlaveBackendServers?: {
    masterSlaveBackendServer?: [ 
    {
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      serverType?: string(name='ServerType'),
    }
  ](name='MasterSlaveBackendServer')
  }(name='MasterSlaveBackendServers'),
}

model DescribeMasterSlaveServerGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMasterSlaveServerGroupAttributeResponseBody(name='body'),
}

async function describeMasterSlaveServerGroupAttributeWithOptions(request: DescribeMasterSlaveServerGroupAttributeRequest, runtime: Util.RuntimeOptions): DescribeMasterSlaveServerGroupAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMasterSlaveServerGroupAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMasterSlaveServerGroupAttribute(request: DescribeMasterSlaveServerGroupAttributeRequest): DescribeMasterSlaveServerGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMasterSlaveServerGroupAttributeWithOptions(request, runtime);
}

model DescribeMasterSlaveServerGroupsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  loadBalancerId?: string(name='LoadBalancerId'),
  includeListener?: boolean(name='IncludeListener'),
}

model DescribeMasterSlaveServerGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  masterSlaveServerGroups?: {
    masterSlaveServerGroup?: [ 
    {
      masterSlaveServerGroupName?: string(name='MasterSlaveServerGroupName'),
      masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
      associatedObjects?: {
        listeners?: {
          listener?: [ 
          {
            port?: int32(name='Port'),
            protocol?: string(name='Protocol'),
          }
        ](name='Listener')
        }(name='Listeners'),
      }(name='AssociatedObjects'),
    }
  ](name='MasterSlaveServerGroup')
  }(name='MasterSlaveServerGroups'),
}

model DescribeMasterSlaveServerGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMasterSlaveServerGroupsResponseBody(name='body'),
}

async function describeMasterSlaveServerGroupsWithOptions(request: DescribeMasterSlaveServerGroupsRequest, runtime: Util.RuntimeOptions): DescribeMasterSlaveServerGroupsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMasterSlaveServerGroups', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMasterSlaveServerGroups(request: DescribeMasterSlaveServerGroupsRequest): DescribeMasterSlaveServerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMasterSlaveServerGroupsWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  regions?: {
    region?: [ 
    {
      regionEndpoint?: string(name='RegionEndpoint'),
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Region')
  }(name='Regions'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRegions', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeRuleAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  ruleId?: string(name='RuleId'),
}

model DescribeRuleAttributeResponseBody = {
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  VServerGroupId?: string(name='VServerGroupId'),
  domain?: string(name='Domain'),
  cookie?: string(name='Cookie'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: string(name='ListenerPort'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  url?: string(name='Url'),
  healthCheckURI?: string(name='HealthCheckURI'),
  stickySessionType?: string(name='StickySessionType'),
  ruleName?: string(name='RuleName'),
  ruleId?: string(name='RuleId'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  scheduler?: string(name='Scheduler'),
  requestId?: string(name='RequestId'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  listenerSync?: string(name='ListenerSync'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  cookieTimeout?: int32(name='CookieTimeout'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  stickySession?: string(name='StickySession'),
  healthCheck?: string(name='HealthCheck'),
}

model DescribeRuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRuleAttributeResponseBody(name='body'),
}

async function describeRuleAttributeWithOptions(request: DescribeRuleAttributeRequest, runtime: Util.RuntimeOptions): DescribeRuleAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRuleAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRuleAttribute(request: DescribeRuleAttributeRequest): DescribeRuleAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRuleAttributeWithOptions(request, runtime);
}

model DescribeRulesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerProtocol?: string(name='ListenerProtocol'),
  listenerPort?: int32(name='ListenerPort'),
}

model DescribeRulesResponseBody = {
  requestId?: string(name='RequestId'),
  rules?: {
    rule?: [ 
    {
      healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
      VServerGroupId?: string(name='VServerGroupId'),
      domain?: string(name='Domain'),
      cookie?: string(name='Cookie'),
      healthCheckInterval?: int32(name='HealthCheckInterval'),
      url?: string(name='Url'),
      healthCheckURI?: string(name='HealthCheckURI'),
      stickySessionType?: string(name='StickySessionType'),
      ruleName?: string(name='RuleName'),
      ruleId?: string(name='RuleId'),
      healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
      scheduler?: string(name='Scheduler'),
      healthCheckTimeout?: int32(name='HealthCheckTimeout'),
      listenerSync?: string(name='ListenerSync'),
      healthyThreshold?: int32(name='HealthyThreshold'),
      cookieTimeout?: int32(name='CookieTimeout'),
      healthCheckDomain?: string(name='HealthCheckDomain'),
      unhealthyThreshold?: int32(name='UnhealthyThreshold'),
      stickySession?: string(name='StickySession'),
      healthCheck?: string(name='HealthCheck'),
    }
  ](name='Rule')
  }(name='Rules'),
}

model DescribeRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRulesResponseBody(name='body'),
}

async function describeRulesWithOptions(request: DescribeRulesRequest, runtime: Util.RuntimeOptions): DescribeRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRules', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRules(request: DescribeRulesRequest): DescribeRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRulesWithOptions(request, runtime);
}

model DescribeServerCertificatesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  serverCertificateId?: string(name='ServerCertificateId'),
  ownerAccount?: string(name='OwnerAccount'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeServerCertificatesResponseBody = {
  requestId?: string(name='RequestId'),
  serverCertificates?: {
    serverCertificate?: [ 
    {
      createTimeStamp?: long(name='CreateTimeStamp'),
      aliCloudCertificateName?: string(name='AliCloudCertificateName'),
      expireTime?: string(name='ExpireTime'),
      createTime?: string(name='CreateTime'),
      serverCertificateId?: string(name='ServerCertificateId'),
      expireTimeStamp?: long(name='ExpireTimeStamp'),
      regionId?: string(name='RegionId'),
      serverCertificateName?: string(name='ServerCertificateName'),
      fingerprint?: string(name='Fingerprint'),
      commonName?: string(name='CommonName'),
      resourceGroupId?: string(name='ResourceGroupId'),
      isAliCloudCertificate?: int32(name='IsAliCloudCertificate'),
      aliCloudCertificateId?: string(name='AliCloudCertificateId'),
      subjectAlternativeNames?: {
        subjectAlternativeName?: [ string ](name='SubjectAlternativeName')
      }(name='SubjectAlternativeNames'),
    }
  ](name='ServerCertificate')
  }(name='ServerCertificates'),
}

model DescribeServerCertificatesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServerCertificatesResponseBody(name='body'),
}

async function describeServerCertificatesWithOptions(request: DescribeServerCertificatesRequest, runtime: Util.RuntimeOptions): DescribeServerCertificatesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeServerCertificates', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeServerCertificates(request: DescribeServerCertificatesRequest): DescribeServerCertificatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServerCertificatesWithOptions(request, runtime);
}

model DescribeTagsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  tags?: string(name='Tags'),
  distinctKey?: boolean(name='DistinctKey'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeTagsResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  tagSets?: {
    tagSet?: [ 
    {
      tagValue?: string(name='TagValue'),
      instanceCount?: int32(name='InstanceCount'),
      tagKey?: string(name='TagKey'),
    }
  ](name='TagSet')
  }(name='TagSets'),
}

model DescribeTagsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTagsResponseBody(name='body'),
}

async function describeTagsWithOptions(request: DescribeTagsRequest, runtime: Util.RuntimeOptions): DescribeTagsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeTags', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeTags(request: DescribeTagsRequest): DescribeTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagsWithOptions(request, runtime);
}

model DescribeVServerGroupAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model DescribeVServerGroupAttributeResponseBody = {
  VServerGroupId?: string(name='VServerGroupId'),
  VServerGroupName?: string(name='VServerGroupName'),
  requestId?: string(name='RequestId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  backendServers?: {
    backendServer?: [ 
    {
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
}

model DescribeVServerGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVServerGroupAttributeResponseBody(name='body'),
}

async function describeVServerGroupAttributeWithOptions(request: DescribeVServerGroupAttributeRequest, runtime: Util.RuntimeOptions): DescribeVServerGroupAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVServerGroupAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVServerGroupAttribute(request: DescribeVServerGroupAttributeRequest): DescribeVServerGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVServerGroupAttributeWithOptions(request, runtime);
}

model DescribeVServerGroupsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  loadBalancerId?: string(name='LoadBalancerId'),
  includeRule?: boolean(name='IncludeRule'),
  includeListener?: boolean(name='IncludeListener'),
}

model DescribeVServerGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  VServerGroups?: {
    VServerGroup?: [ 
    {
      VServerGroupId?: string(name='VServerGroupId'),
      VServerGroupName?: string(name='VServerGroupName'),
      associatedObjects?: {
        listeners?: {
          listener?: [ 
          {
            port?: int32(name='Port'),
            protocol?: string(name='Protocol'),
          }
        ](name='Listener')
        }(name='Listeners'),
        rules?: {
          rule?: [ 
          {
            url?: string(name='Url'),
            domain?: string(name='Domain'),
            ruleName?: string(name='RuleName'),
            ruleId?: string(name='RuleId'),
          }
        ](name='Rule')
        }(name='Rules'),
      }(name='AssociatedObjects'),
    }
  ](name='VServerGroup')
  }(name='VServerGroups'),
}

model DescribeVServerGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVServerGroupsResponseBody(name='body'),
}

async function describeVServerGroupsWithOptions(request: DescribeVServerGroupsRequest, runtime: Util.RuntimeOptions): DescribeVServerGroupsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVServerGroups', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVServerGroups(request: DescribeVServerGroupsRequest): DescribeVServerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVServerGroupsWithOptions(request, runtime);
}

model DescribeZonesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: {
    zone?: [ 
    {
      zoneId?: string(name='ZoneId'),
      localName?: string(name='LocalName'),
      slaveZones?: {
        slaveZone?: [ 
        {
          zoneId?: string(name='ZoneId'),
          localName?: string(name='LocalName'),
        }
      ](name='SlaveZone')
      }(name='SlaveZones'),
    }
  ](name='Zone')
  }(name='Zones'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeZonesResponseBody(name='body'),
}

async function describeZonesWithOptions(request: DescribeZonesRequest, runtime: Util.RuntimeOptions): DescribeZonesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeZones', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeZonesWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
  nextToken?: string(name='NextToken'),
  resourceId?: [ string ](name='ResourceId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      tagValue?: string(name='TagValue'),
      resourceType?: string(name='ResourceType'),
      resourceId?: string(name='ResourceId'),
      tagKey?: string(name='TagKey'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTagResources', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListTLSCipherPoliciesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  accessKeyId?: string(name='access_key_id'),
  TLSCipherPolicyId?: string(name='TLSCipherPolicyId'),
  name?: string(name='Name'),
  includeListener?: boolean(name='IncludeListener'),
  nextToken?: string(name='NextToken'),
  maxItems?: int32(name='MaxItems'),
}

model ListTLSCipherPoliciesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  isTruncated?: boolean(name='IsTruncated'),
  TLSCipherPolicies?: [ 
    {
      status?: string(name='Status'),
      instanceId?: string(name='InstanceId'),
      name?: string(name='Name'),
      createTime?: long(name='CreateTime'),
      relateListeners?: [ 
        {
          port?: int32(name='Port'),
          protocol?: string(name='Protocol'),
          loadBalancerId?: string(name='LoadBalancerId'),
        }
      ](name='RelateListeners'),
      TLSVersions?: [ string ](name='TLSVersions'),
      ciphers?: [ string ](name='Ciphers'),
    }
  ](name='TLSCipherPolicies'),
}

model ListTLSCipherPoliciesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTLSCipherPoliciesResponseBody(name='body'),
}

async function listTLSCipherPoliciesWithOptions(request: ListTLSCipherPoliciesRequest, runtime: Util.RuntimeOptions): ListTLSCipherPoliciesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTLSCipherPolicies', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTLSCipherPolicies(request: ListTLSCipherPoliciesRequest): ListTLSCipherPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTLSCipherPoliciesWithOptions(request, runtime);
}

model ModifyLoadBalancerInstanceSpecRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  loadBalancerSpec?: string(name='LoadBalancerSpec'),
  autoPay?: boolean(name='AutoPay'),
}

model ModifyLoadBalancerInstanceSpecResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyLoadBalancerInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyLoadBalancerInstanceSpecResponseBody(name='body'),
}

async function modifyLoadBalancerInstanceSpecWithOptions(request: ModifyLoadBalancerInstanceSpecRequest, runtime: Util.RuntimeOptions): ModifyLoadBalancerInstanceSpecResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyLoadBalancerInstanceSpec', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyLoadBalancerInstanceSpec(request: ModifyLoadBalancerInstanceSpecRequest): ModifyLoadBalancerInstanceSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLoadBalancerInstanceSpecWithOptions(request, runtime);
}

model ModifyLoadBalancerInternetSpecRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  internetChargeType?: string(name='InternetChargeType'),
  bandwidth?: int32(name='Bandwidth'),
  ownerAccount?: string(name='OwnerAccount'),
  autoPay?: boolean(name='AutoPay'),
}

model ModifyLoadBalancerInternetSpecResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyLoadBalancerInternetSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyLoadBalancerInternetSpecResponseBody(name='body'),
}

async function modifyLoadBalancerInternetSpecWithOptions(request: ModifyLoadBalancerInternetSpecRequest, runtime: Util.RuntimeOptions): ModifyLoadBalancerInternetSpecResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyLoadBalancerInternetSpec', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyLoadBalancerInternetSpec(request: ModifyLoadBalancerInternetSpecRequest): ModifyLoadBalancerInternetSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLoadBalancerInternetSpecWithOptions(request, runtime);
}

model ModifyLoadBalancerPayTypeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  loadBalancerId?: string(name='LoadBalancerId'),
  payType?: string(name='PayType'),
  pricingCycle?: string(name='PricingCycle'),
  duration?: int32(name='Duration'),
  autoPay?: boolean(name='AutoPay'),
}

model ModifyLoadBalancerPayTypeResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyLoadBalancerPayTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyLoadBalancerPayTypeResponseBody(name='body'),
}

async function modifyLoadBalancerPayTypeWithOptions(request: ModifyLoadBalancerPayTypeRequest, runtime: Util.RuntimeOptions): ModifyLoadBalancerPayTypeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyLoadBalancerPayType', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyLoadBalancerPayType(request: ModifyLoadBalancerPayTypeRequest): ModifyLoadBalancerPayTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLoadBalancerPayTypeWithOptions(request, runtime);
}

model ModifyVServerGroupBackendServersRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  VServerGroupId?: string(name='VServerGroupId'),
  oldBackendServers?: string(name='OldBackendServers'),
  newBackendServers?: string(name='NewBackendServers'),
}

model ModifyVServerGroupBackendServersResponseBody = {
  VServerGroupId?: string(name='VServerGroupId'),
  requestId?: string(name='RequestId'),
  backendServers?: {
    backendServer?: [ 
    {
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
}

model ModifyVServerGroupBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVServerGroupBackendServersResponseBody(name='body'),
}

async function modifyVServerGroupBackendServersWithOptions(request: ModifyVServerGroupBackendServersRequest, runtime: Util.RuntimeOptions): ModifyVServerGroupBackendServersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyVServerGroupBackendServers', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyVServerGroupBackendServers(request: ModifyVServerGroupBackendServersRequest): ModifyVServerGroupBackendServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVServerGroupBackendServersWithOptions(request, runtime);
}

model RemoveAccessControlListEntryRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  aclId?: string(name='AclId'),
  aclEntrys?: string(name='AclEntrys'),
}

model RemoveAccessControlListEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveAccessControlListEntryResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveAccessControlListEntryResponseBody(name='body'),
}

async function removeAccessControlListEntryWithOptions(request: RemoveAccessControlListEntryRequest, runtime: Util.RuntimeOptions): RemoveAccessControlListEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveAccessControlListEntry', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeAccessControlListEntry(request: RemoveAccessControlListEntryRequest): RemoveAccessControlListEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeAccessControlListEntryWithOptions(request, runtime);
}

model RemoveBackendServersRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  backendServers?: string(name='BackendServers'),
  ownerAccount?: string(name='OwnerAccount'),
}

model RemoveBackendServersResponseBody = {
  loadBalancerId?: string(name='LoadBalancerId'),
  requestId?: string(name='RequestId'),
  backendServers?: {
    backendServer?: [ 
    {
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
      description?: string(name='Description'),
      serverId?: string(name='ServerId'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
}

model RemoveBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveBackendServersResponseBody(name='body'),
}

async function removeBackendServersWithOptions(request: RemoveBackendServersRequest, runtime: Util.RuntimeOptions): RemoveBackendServersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveBackendServers', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeBackendServers(request: RemoveBackendServersRequest): RemoveBackendServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeBackendServersWithOptions(request, runtime);
}

model RemoveListenerWhiteListItemRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  sourceItems?: string(name='SourceItems'),
  ownerAccount?: string(name='OwnerAccount'),
  listenerProtocol?: string(name='ListenerProtocol'),
}

model RemoveListenerWhiteListItemResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveListenerWhiteListItemResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveListenerWhiteListItemResponseBody(name='body'),
}

async function removeListenerWhiteListItemWithOptions(request: RemoveListenerWhiteListItemRequest, runtime: Util.RuntimeOptions): RemoveListenerWhiteListItemResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveListenerWhiteListItem', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeListenerWhiteListItem(request: RemoveListenerWhiteListItemRequest): RemoveListenerWhiteListItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeListenerWhiteListItemWithOptions(request, runtime);
}

model RemoveTagsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  tags?: string(name='Tags'),
}

model RemoveTagsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveTagsResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveTagsResponseBody(name='body'),
}

async function removeTagsWithOptions(request: RemoveTagsRequest, runtime: Util.RuntimeOptions): RemoveTagsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveTags', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeTags(request: RemoveTagsRequest): RemoveTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeTagsWithOptions(request, runtime);
}

model RemoveVServerGroupBackendServersRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  VServerGroupId?: string(name='VServerGroupId'),
  backendServers?: string(name='BackendServers'),
}

model RemoveVServerGroupBackendServersResponseBody = {
  VServerGroupId?: string(name='VServerGroupId'),
  requestId?: string(name='RequestId'),
  backendServers?: {
    backendServer?: [ 
    {
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
}

model RemoveVServerGroupBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveVServerGroupBackendServersResponseBody(name='body'),
}

async function removeVServerGroupBackendServersWithOptions(request: RemoveVServerGroupBackendServersRequest, runtime: Util.RuntimeOptions): RemoveVServerGroupBackendServersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveVServerGroupBackendServers', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeVServerGroupBackendServers(request: RemoveVServerGroupBackendServersRequest): RemoveVServerGroupBackendServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeVServerGroupBackendServersWithOptions(request, runtime);
}

model SetAccessControlListAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
}

model SetAccessControlListAttributeResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId'),
}

model SetAccessControlListAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetAccessControlListAttributeResponseBody(name='body'),
}

async function setAccessControlListAttributeWithOptions(request: SetAccessControlListAttributeRequest, runtime: Util.RuntimeOptions): SetAccessControlListAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetAccessControlListAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setAccessControlListAttribute(request: SetAccessControlListAttributeRequest): SetAccessControlListAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setAccessControlListAttributeWithOptions(request, runtime);
}

model SetBackendServersRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  backendServers?: string(name='BackendServers'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SetBackendServersResponseBody = {
  loadBalancerId?: string(name='LoadBalancerId'),
  requestId?: string(name='RequestId'),
  backendServers?: {
    backendServer?: [ 
    {
      type?: string(name='Type'),
      weight?: string(name='Weight'),
      description?: string(name='Description'),
      serverId?: string(name='ServerId'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
}

model SetBackendServersResponse = {
  headers: map[string]string(name='headers'),
  body: SetBackendServersResponseBody(name='body'),
}

async function setBackendServersWithOptions(request: SetBackendServersRequest, runtime: Util.RuntimeOptions): SetBackendServersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetBackendServers', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setBackendServers(request: SetBackendServersRequest): SetBackendServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return setBackendServersWithOptions(request, runtime);
}

model SetCACertificateNameRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  CACertificateId?: string(name='CACertificateId'),
  CACertificateName?: string(name='CACertificateName'),
}

model SetCACertificateNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetCACertificateNameResponse = {
  headers: map[string]string(name='headers'),
  body: SetCACertificateNameResponseBody(name='body'),
}

async function setCACertificateNameWithOptions(request: SetCACertificateNameRequest, runtime: Util.RuntimeOptions): SetCACertificateNameResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetCACertificateName', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setCACertificateName(request: SetCACertificateNameRequest): SetCACertificateNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return setCACertificateNameWithOptions(request, runtime);
}

model SetDomainExtensionAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  domainExtensionId?: string(name='DomainExtensionId'),
  serverCertificateId?: string(name='ServerCertificateId'),
}

model SetDomainExtensionAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetDomainExtensionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetDomainExtensionAttributeResponseBody(name='body'),
}

async function setDomainExtensionAttributeWithOptions(request: SetDomainExtensionAttributeRequest, runtime: Util.RuntimeOptions): SetDomainExtensionAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetDomainExtensionAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setDomainExtensionAttribute(request: SetDomainExtensionAttributeRequest): SetDomainExtensionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDomainExtensionAttributeWithOptions(request, runtime);
}

model SetListenerAccessControlStatusRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  accessControlStatus?: string(name='AccessControlStatus'),
  ownerAccount?: string(name='OwnerAccount'),
  listenerProtocol?: string(name='ListenerProtocol'),
}

model SetListenerAccessControlStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetListenerAccessControlStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetListenerAccessControlStatusResponseBody(name='body'),
}

async function setListenerAccessControlStatusWithOptions(request: SetListenerAccessControlStatusRequest, runtime: Util.RuntimeOptions): SetListenerAccessControlStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetListenerAccessControlStatus', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setListenerAccessControlStatus(request: SetListenerAccessControlStatusRequest): SetListenerAccessControlStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setListenerAccessControlStatusWithOptions(request, runtime);
}

model SetLoadBalancerDeleteProtectionRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  deleteProtection?: string(name='DeleteProtection'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SetLoadBalancerDeleteProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerDeleteProtectionResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerDeleteProtectionResponseBody(name='body'),
}

async function setLoadBalancerDeleteProtectionWithOptions(request: SetLoadBalancerDeleteProtectionRequest, runtime: Util.RuntimeOptions): SetLoadBalancerDeleteProtectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetLoadBalancerDeleteProtection', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setLoadBalancerDeleteProtection(request: SetLoadBalancerDeleteProtectionRequest): SetLoadBalancerDeleteProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerDeleteProtectionWithOptions(request, runtime);
}

model SetLoadBalancerHTTPListenerAttributeRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  bandwidth?: int32(name='Bandwidth'),
  XForwardedFor?: string(name='XForwardedFor'),
  scheduler?: string(name='Scheduler'),
  stickySession?: string(name='StickySession'),
  stickySessionType?: string(name='StickySessionType'),
  cookieTimeout?: int32(name='CookieTimeout'),
  cookie?: string(name='Cookie'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  ownerAccount?: string(name='OwnerAccount'),
  VServerGroup?: string(name='VServerGroup'),
  VServerGroupId?: string(name='VServerGroupId'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto'),
  gzip?: string(name='Gzip'),
  aclId?: string(name='AclId'),
  aclType?: string(name='AclType'),
  aclStatus?: string(name='AclStatus'),
  idleTimeout?: int32(name='IdleTimeout'),
  requestTimeout?: int32(name='RequestTimeout'),
  description?: string(name='Description'),
}

model SetLoadBalancerHTTPListenerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerHTTPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerHTTPListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerHTTPListenerAttributeWithOptions(request: SetLoadBalancerHTTPListenerAttributeRequest, runtime: Util.RuntimeOptions): SetLoadBalancerHTTPListenerAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetLoadBalancerHTTPListenerAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setLoadBalancerHTTPListenerAttribute(request: SetLoadBalancerHTTPListenerAttributeRequest): SetLoadBalancerHTTPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerHTTPListenerAttributeWithOptions(request, runtime);
}

model SetLoadBalancerHTTPSListenerAttributeRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  bandwidth?: int32(name='Bandwidth'),
  XForwardedFor?: string(name='XForwardedFor'),
  scheduler?: string(name='Scheduler'),
  stickySession?: string(name='StickySession'),
  stickySessionType?: string(name='StickySessionType'),
  cookieTimeout?: int32(name='CookieTimeout'),
  cookie?: string(name='Cookie'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  ownerAccount?: string(name='OwnerAccount'),
  serverCertificateId?: string(name='ServerCertificateId'),
  CACertificateId?: string(name='CACertificateId'),
  VServerGroup?: string(name='VServerGroup'),
  VServerGroupId?: string(name='VServerGroupId'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto'),
  gzip?: string(name='Gzip'),
  aclId?: string(name='AclId'),
  aclType?: string(name='AclType'),
  aclStatus?: string(name='AclStatus'),
  idleTimeout?: int32(name='IdleTimeout'),
  requestTimeout?: int32(name='RequestTimeout'),
  enableHttp2?: string(name='EnableHttp2'),
  TLSCipherPolicy?: string(name='TLSCipherPolicy'),
  description?: string(name='Description'),
}

model SetLoadBalancerHTTPSListenerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerHTTPSListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerHTTPSListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerHTTPSListenerAttributeWithOptions(request: SetLoadBalancerHTTPSListenerAttributeRequest, runtime: Util.RuntimeOptions): SetLoadBalancerHTTPSListenerAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetLoadBalancerHTTPSListenerAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setLoadBalancerHTTPSListenerAttribute(request: SetLoadBalancerHTTPSListenerAttributeRequest): SetLoadBalancerHTTPSListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerHTTPSListenerAttributeWithOptions(request, runtime);
}

model SetLoadBalancerModificationProtectionRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  modificationProtectionStatus?: string(name='ModificationProtectionStatus'),
  ownerAccount?: string(name='OwnerAccount'),
  modificationProtectionReason?: string(name='ModificationProtectionReason'),
}

model SetLoadBalancerModificationProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerModificationProtectionResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerModificationProtectionResponseBody(name='body'),
}

async function setLoadBalancerModificationProtectionWithOptions(request: SetLoadBalancerModificationProtectionRequest, runtime: Util.RuntimeOptions): SetLoadBalancerModificationProtectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetLoadBalancerModificationProtection', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setLoadBalancerModificationProtection(request: SetLoadBalancerModificationProtectionRequest): SetLoadBalancerModificationProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerModificationProtectionWithOptions(request, runtime);
}

model SetLoadBalancerNameRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerName?: string(name='LoadBalancerName'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SetLoadBalancerNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerNameResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerNameResponseBody(name='body'),
}

async function setLoadBalancerNameWithOptions(request: SetLoadBalancerNameRequest, runtime: Util.RuntimeOptions): SetLoadBalancerNameResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetLoadBalancerName', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setLoadBalancerName(request: SetLoadBalancerNameRequest): SetLoadBalancerNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerNameWithOptions(request, runtime);
}

model SetLoadBalancerStatusRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerStatus?: string(name='LoadBalancerStatus'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SetLoadBalancerStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerStatusResponseBody(name='body'),
}

async function setLoadBalancerStatusWithOptions(request: SetLoadBalancerStatusRequest, runtime: Util.RuntimeOptions): SetLoadBalancerStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetLoadBalancerStatus', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setLoadBalancerStatus(request: SetLoadBalancerStatusRequest): SetLoadBalancerStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerStatusWithOptions(request, runtime);
}

model SetLoadBalancerTCPListenerAttributeRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  bandwidth?: int32(name='Bandwidth'),
  scheduler?: string(name='Scheduler'),
  persistenceTimeout?: int32(name='PersistenceTimeout'),
  establishedTimeout?: int32(name='EstablishedTimeout'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckType?: string(name='HealthCheckType'),
  synProxy?: string(name='SynProxy'),
  ownerAccount?: string(name='OwnerAccount'),
  VServerGroup?: string(name='VServerGroup'),
  VServerGroupId?: string(name='VServerGroupId'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  masterSlaveServerGroup?: string(name='MasterSlaveServerGroup'),
  aclId?: string(name='AclId'),
  aclType?: string(name='AclType'),
  aclStatus?: string(name='AclStatus'),
  description?: string(name='Description'),
  connectionDrain?: string(name='ConnectionDrain'),
  connectionDrainTimeout?: int32(name='ConnectionDrainTimeout'),
}

model SetLoadBalancerTCPListenerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerTCPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerTCPListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerTCPListenerAttributeWithOptions(request: SetLoadBalancerTCPListenerAttributeRequest, runtime: Util.RuntimeOptions): SetLoadBalancerTCPListenerAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetLoadBalancerTCPListenerAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setLoadBalancerTCPListenerAttribute(request: SetLoadBalancerTCPListenerAttributeRequest): SetLoadBalancerTCPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerTCPListenerAttributeWithOptions(request, runtime);
}

model SetLoadBalancerUDPListenerAttributeRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  bandwidth?: int32(name='Bandwidth'),
  scheduler?: string(name='Scheduler'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckReq?: string(name='healthCheckReq'),
  healthCheckExp?: string(name='healthCheckExp'),
  ownerAccount?: string(name='OwnerAccount'),
  VServerGroup?: string(name='VServerGroup'),
  VServerGroupId?: string(name='VServerGroupId'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  masterSlaveServerGroup?: string(name='MasterSlaveServerGroup'),
  aclId?: string(name='AclId'),
  aclType?: string(name='AclType'),
  aclStatus?: string(name='AclStatus'),
  description?: string(name='Description'),
}

model SetLoadBalancerUDPListenerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerUDPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetLoadBalancerUDPListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerUDPListenerAttributeWithOptions(request: SetLoadBalancerUDPListenerAttributeRequest, runtime: Util.RuntimeOptions): SetLoadBalancerUDPListenerAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetLoadBalancerUDPListenerAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setLoadBalancerUDPListenerAttribute(request: SetLoadBalancerUDPListenerAttributeRequest): SetLoadBalancerUDPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerUDPListenerAttributeWithOptions(request, runtime);
}

model SetRuleRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  ruleId?: string(name='RuleId'),
  VServerGroupId?: string(name='VServerGroupId'),
  ruleName?: string(name='RuleName'),
  listenerSync?: string(name='ListenerSync'),
  scheduler?: string(name='Scheduler'),
  stickySession?: string(name='StickySession'),
  stickySessionType?: string(name='StickySessionType'),
  cookieTimeout?: int32(name='CookieTimeout'),
  cookie?: string(name='Cookie'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
}

model SetRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetRuleResponse = {
  headers: map[string]string(name='headers'),
  body: SetRuleResponseBody(name='body'),
}

async function setRuleWithOptions(request: SetRuleRequest, runtime: Util.RuntimeOptions): SetRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetRule', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setRule(request: SetRuleRequest): SetRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return setRuleWithOptions(request, runtime);
}

model SetServerCertificateNameRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  serverCertificateId?: string(name='ServerCertificateId'),
  serverCertificateName?: string(name='ServerCertificateName'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SetServerCertificateNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetServerCertificateNameResponse = {
  headers: map[string]string(name='headers'),
  body: SetServerCertificateNameResponseBody(name='body'),
}

async function setServerCertificateNameWithOptions(request: SetServerCertificateNameRequest, runtime: Util.RuntimeOptions): SetServerCertificateNameResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetServerCertificateName', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setServerCertificateName(request: SetServerCertificateNameRequest): SetServerCertificateNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return setServerCertificateNameWithOptions(request, runtime);
}

model SetTLSCipherPolicyAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  accessKeyId?: string(name='access_key_id'),
  TLSCipherPolicyId?: string(name='TLSCipherPolicyId'),
  name?: string(name='Name'),
  TLSVersions?: [ string ](name='TLSVersions'),
  ciphers?: [ string ](name='Ciphers'),
}

model SetTLSCipherPolicyAttributeResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
}

model SetTLSCipherPolicyAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetTLSCipherPolicyAttributeResponseBody(name='body'),
}

async function setTLSCipherPolicyAttributeWithOptions(request: SetTLSCipherPolicyAttributeRequest, runtime: Util.RuntimeOptions): SetTLSCipherPolicyAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetTLSCipherPolicyAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setTLSCipherPolicyAttribute(request: SetTLSCipherPolicyAttributeRequest): SetTLSCipherPolicyAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setTLSCipherPolicyAttributeWithOptions(request, runtime);
}

model SetVServerGroupAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  VServerGroupId?: string(name='VServerGroupId'),
  VServerGroupName?: string(name='VServerGroupName'),
  backendServers?: string(name='BackendServers'),
}

model SetVServerGroupAttributeResponseBody = {
  VServerGroupId?: string(name='VServerGroupId'),
  VServerGroupName?: string(name='VServerGroupName'),
  requestId?: string(name='RequestId'),
  backendServers?: {
    backendServer?: [ 
    {
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
}

model SetVServerGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SetVServerGroupAttributeResponseBody(name='body'),
}

async function setVServerGroupAttributeWithOptions(request: SetVServerGroupAttributeRequest, runtime: Util.RuntimeOptions): SetVServerGroupAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetVServerGroupAttribute', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setVServerGroupAttribute(request: SetVServerGroupAttributeRequest): SetVServerGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setVServerGroupAttributeWithOptions(request, runtime);
}

model StartLoadBalancerListenerRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  ownerAccount?: string(name='OwnerAccount'),
  listenerProtocol?: string(name='ListenerProtocol'),
}

model StartLoadBalancerListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartLoadBalancerListenerResponse = {
  headers: map[string]string(name='headers'),
  body: StartLoadBalancerListenerResponseBody(name='body'),
}

async function startLoadBalancerListenerWithOptions(request: StartLoadBalancerListenerRequest, runtime: Util.RuntimeOptions): StartLoadBalancerListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('StartLoadBalancerListener', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function startLoadBalancerListener(request: StartLoadBalancerListenerRequest): StartLoadBalancerListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return startLoadBalancerListenerWithOptions(request, runtime);
}

model StopLoadBalancerListenerRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  loadBalancerId?: string(name='LoadBalancerId'),
  listenerPort?: int32(name='ListenerPort'),
  ownerAccount?: string(name='OwnerAccount'),
  listenerProtocol?: string(name='ListenerProtocol'),
}

model StopLoadBalancerListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopLoadBalancerListenerResponse = {
  headers: map[string]string(name='headers'),
  body: StopLoadBalancerListenerResponseBody(name='body'),
}

async function stopLoadBalancerListenerWithOptions(request: StopLoadBalancerListenerRequest, runtime: Util.RuntimeOptions): StopLoadBalancerListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('StopLoadBalancerListener', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function stopLoadBalancerListener(request: StopLoadBalancerListenerRequest): StopLoadBalancerListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopLoadBalancerListenerWithOptions(request, runtime);
}

model TagResourcesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
  resourceId?: [ string ](name='ResourceId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TagResources', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
  all?: boolean(name='All'),
  resourceId?: [ string ](name='ResourceId'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UntagResources', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UploadCACertificateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  CACertificate?: string(name='CACertificate'),
  CACertificateName?: string(name='CACertificateName'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model UploadCACertificateResponseBody = {
  createTimeStamp?: long(name='CreateTimeStamp'),
  requestId?: string(name='RequestId'),
  expireTime?: string(name='ExpireTime'),
  fingerprint?: string(name='Fingerprint'),
  createTime?: string(name='CreateTime'),
  commonName?: string(name='CommonName'),
  resourceGroupId?: string(name='ResourceGroupId'),
  CACertificateName?: string(name='CACertificateName'),
  expireTimeStamp?: long(name='ExpireTimeStamp'),
  CACertificateId?: string(name='CACertificateId'),
}

model UploadCACertificateResponse = {
  headers: map[string]string(name='headers'),
  body: UploadCACertificateResponseBody(name='body'),
}

async function uploadCACertificateWithOptions(request: UploadCACertificateRequest, runtime: Util.RuntimeOptions): UploadCACertificateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UploadCACertificate', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function uploadCACertificate(request: UploadCACertificateRequest): UploadCACertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadCACertificateWithOptions(request, runtime);
}

model UploadServerCertificateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  aliCloudCertificateId?: string(name='AliCloudCertificateId'),
  aliCloudCertificateName?: string(name='AliCloudCertificateName'),
  aliCloudCertificateRegionId?: string(name='AliCloudCertificateRegionId'),
  serverCertificate?: string(name='ServerCertificate'),
  privateKey?: string(name='PrivateKey'),
  serverCertificateName?: string(name='ServerCertificateName'),
  ownerAccount?: string(name='OwnerAccount'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model UploadServerCertificateResponseBody = {
  aliCloudCertificateName?: string(name='AliCloudCertificateName'),
  createTimeStamp?: long(name='CreateTimeStamp'),
  expireTime?: string(name='ExpireTime'),
  createTime?: string(name='CreateTime'),
  serverCertificateId?: string(name='ServerCertificateId'),
  expireTimeStamp?: long(name='ExpireTimeStamp'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  fingerprint?: string(name='Fingerprint'),
  serverCertificateName?: string(name='ServerCertificateName'),
  commonName?: string(name='CommonName'),
  resourceGroupId?: string(name='ResourceGroupId'),
  aliCloudCertificateId?: string(name='AliCloudCertificateId'),
  isAliCloudCertificate?: int32(name='IsAliCloudCertificate'),
  subjectAlternativeNames?: {
    subjectAlternativeName?: [ string ](name='SubjectAlternativeName')
  }(name='SubjectAlternativeNames'),
}

model UploadServerCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: UploadServerCertificateResponseBody(name='body'),
}

async function uploadServerCertificateWithOptions(request: UploadServerCertificateRequest, runtime: Util.RuntimeOptions): UploadServerCertificateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UploadServerCertificate', '2014-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function uploadServerCertificate(request: UploadServerCertificateRequest): UploadServerCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadServerCertificateWithOptions(request, runtime);
}

