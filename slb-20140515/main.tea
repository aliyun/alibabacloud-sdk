/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-qingdao = 'slb.aliyuncs.com',
    cn-beijing = 'slb.aliyuncs.com',
    cn-hangzhou = 'slb.aliyuncs.com',
    cn-shanghai = 'slb.aliyuncs.com',
    cn-shenzhen = 'slb.aliyuncs.com',
    cn-hongkong = 'slb.aliyuncs.com',
    ap-southeast-1 = 'slb.aliyuncs.com',
    us-east-1 = 'slb.aliyuncs.com',
    us-west-1 = 'slb.aliyuncs.com',
    cn-shanghai-finance-1 = 'slb.aliyuncs.com',
    cn-shenzhen-finance-1 = 'slb.aliyuncs.com',
    cn-north-2-gov-1 = 'slb.aliyuncs.com',
    ap-northeast-2-pop = 'slb.aliyuncs.com',
    cn-beijing-finance-pop = 'slb.aliyuncs.com',
    cn-beijing-gov-1 = 'slb.aliyuncs.com',
    cn-beijing-nu16-b01 = 'slb.aliyuncs.com',
    cn-edge-1 = 'slb.aliyuncs.com',
    cn-fujian = 'slb.aliyuncs.com',
    cn-haidian-cm12-c01 = 'slb.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'slb.aliyuncs.com',
    cn-hangzhou-finance = 'slb.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'slb.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'slb.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'slb.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'slb.aliyuncs.com',
    cn-hangzhou-test-306 = 'slb.aliyuncs.com',
    cn-hongkong-finance-pop = 'slb.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'slb-api.cn-qingdao-nebula.aliyuncs.com',
    cn-shanghai-et15-b01 = 'slb.aliyuncs.com',
    cn-shanghai-et2-b01 = 'slb.aliyuncs.com',
    cn-shanghai-inner = 'slb.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'slb.aliyuncs.com',
    cn-shenzhen-inner = 'slb.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'slb.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'slb.aliyuncs.com',
    cn-wuhan = 'slb.aliyuncs.com',
    cn-yushanfang = 'slb.aliyuncs.com',
    cn-zhangbei = 'slb.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'slb.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'slb.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'slb.aliyuncs.com',
    eu-west-1-oxs = 'slb.aliyuncs.com',
    rus-west-1-pop = 'slb.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('slb', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddAccessControlListEntryRequest {
  aclEntrys?: string(name='AclEntrys'),
  aclId?: string(name='AclId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddAccessControlListEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddAccessControlListEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddAccessControlListEntryResponseBody(name='body'),
}

async function addAccessControlListEntryWithOptions(request: AddAccessControlListEntryRequest, runtime: Util.RuntimeOptions): AddAccessControlListEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclEntrys)) {
    query['AclEntrys'] = request.aclEntrys;
  }
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddAccessControlListEntry',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addAccessControlListEntry(request: AddAccessControlListEntryRequest): AddAccessControlListEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAccessControlListEntryWithOptions(request, runtime);
}

model AddBackendServersRequest {
  backendServers?: string(name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: string(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
  requestId?: string(name='RequestId'),
}

model AddBackendServersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddBackendServersResponseBody(name='body'),
}

async function addBackendServersWithOptions(request: AddBackendServersRequest, runtime: Util.RuntimeOptions): AddBackendServersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backendServers)) {
    query['BackendServers'] = request.backendServers;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddBackendServers',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addBackendServers(request: AddBackendServersRequest): AddBackendServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBackendServersWithOptions(request, runtime);
}

model AddListenerWhiteListItemRequest {
  listenerPort?: int32(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceItems?: string(name='SourceItems'),
}

model AddListenerWhiteListItemResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddListenerWhiteListItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddListenerWhiteListItemResponseBody(name='body'),
}

async function addListenerWhiteListItemWithOptions(request: AddListenerWhiteListItemRequest, runtime: Util.RuntimeOptions): AddListenerWhiteListItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceItems)) {
    query['SourceItems'] = request.sourceItems;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddListenerWhiteListItem',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addListenerWhiteListItem(request: AddListenerWhiteListItemRequest): AddListenerWhiteListItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return addListenerWhiteListItemWithOptions(request, runtime);
}

model AddTagsRequest {
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tags?: string(name='Tags'),
}

model AddTagsResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddTagsResponseBody(name='body'),
}

async function addTagsWithOptions(request: AddTagsRequest, runtime: Util.RuntimeOptions): AddTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddTags',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addTags(request: AddTagsRequest): AddTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTagsWithOptions(request, runtime);
}

model AddVServerGroupBackendServersRequest {
  backendServers?: string(name='BackendServers'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model AddVServerGroupBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model AddVServerGroupBackendServersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddVServerGroupBackendServersResponseBody(name='body'),
}

async function addVServerGroupBackendServersWithOptions(request: AddVServerGroupBackendServersRequest, runtime: Util.RuntimeOptions): AddVServerGroupBackendServersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backendServers)) {
    query['BackendServers'] = request.backendServers;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddVServerGroupBackendServers',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addVServerGroupBackendServers(request: AddVServerGroupBackendServersRequest): AddVServerGroupBackendServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVServerGroupBackendServersWithOptions(request, runtime);
}

model CreateAccessControlListRequest {
  aclName?: string(name='AclName'),
  addressIPVersion?: string(name='AddressIPVersion'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateAccessControlListResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId'),
}

model CreateAccessControlListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAccessControlListResponseBody(name='body'),
}

async function createAccessControlListWithOptions(request: CreateAccessControlListRequest, runtime: Util.RuntimeOptions): CreateAccessControlListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclName)) {
    query['AclName'] = request.aclName;
  }
  if (!Util.isUnset(request.addressIPVersion)) {
    query['AddressIPVersion'] = request.addressIPVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccessControlList',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAccessControlList(request: CreateAccessControlListRequest): CreateAccessControlListResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccessControlListWithOptions(request, runtime);
}

model CreateDomainExtensionRequest {
  domain?: string(name='Domain'),
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serverCertificateId?: string(name='ServerCertificateId'),
}

model CreateDomainExtensionResponseBody = {
  domainExtensionId?: string(name='DomainExtensionId'),
  listenerPort?: int32(name='ListenerPort'),
  requestId?: string(name='RequestId'),
}

model CreateDomainExtensionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDomainExtensionResponseBody(name='body'),
}

async function createDomainExtensionWithOptions(request: CreateDomainExtensionRequest, runtime: Util.RuntimeOptions): CreateDomainExtensionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.serverCertificateId)) {
    query['ServerCertificateId'] = request.serverCertificateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDomainExtension',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDomainExtension(request: CreateDomainExtensionRequest): CreateDomainExtensionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDomainExtensionWithOptions(request, runtime);
}

model CreateLoadBalancerRequest {
  address?: string(name='Address'),
  addressIPVersion?: string(name='AddressIPVersion'),
  addressType?: string(name='AddressType'),
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  deleteProtection?: string(name='DeleteProtection'),
  duration?: int32(name='Duration'),
  instanceChargeType?: string(name='InstanceChargeType'),
  internetChargeType?: string(name='InternetChargeType'),
  loadBalancerName?: string(name='LoadBalancerName'),
  loadBalancerSpec?: string(name='LoadBalancerSpec'),
  masterZoneId?: string(name='MasterZoneId'),
  modificationProtectionReason?: string(name='ModificationProtectionReason'),
  modificationProtectionStatus?: string(name='ModificationProtectionStatus'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  slaveZoneId?: string(name='SlaveZoneId'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model CreateLoadBalancerResponseBody = {
  address?: string(name='Address'),
  addressIPVersion?: string(name='AddressIPVersion'),
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerName?: string(name='LoadBalancerName'),
  networkType?: string(name='NetworkType'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model CreateLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLoadBalancerResponseBody(name='body'),
}

async function createLoadBalancerWithOptions(request: CreateLoadBalancerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.addressIPVersion)) {
    query['AddressIPVersion'] = request.addressIPVersion;
  }
  if (!Util.isUnset(request.addressType)) {
    query['AddressType'] = request.addressType;
  }
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.deleteProtection)) {
    query['DeleteProtection'] = request.deleteProtection;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query['InstanceChargeType'] = request.instanceChargeType;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.loadBalancerName)) {
    query['LoadBalancerName'] = request.loadBalancerName;
  }
  if (!Util.isUnset(request.loadBalancerSpec)) {
    query['LoadBalancerSpec'] = request.loadBalancerSpec;
  }
  if (!Util.isUnset(request.masterZoneId)) {
    query['MasterZoneId'] = request.masterZoneId;
  }
  if (!Util.isUnset(request.modificationProtectionReason)) {
    query['ModificationProtectionReason'] = request.modificationProtectionReason;
  }
  if (!Util.isUnset(request.modificationProtectionStatus)) {
    query['ModificationProtectionStatus'] = request.modificationProtectionStatus;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.slaveZoneId)) {
    query['SlaveZoneId'] = request.slaveZoneId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLoadBalancer',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLoadBalancer(request: CreateLoadBalancerRequest): CreateLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerWithOptions(request, runtime);
}

model CreateLoadBalancerHTTPListenerRequest {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  cookie?: string(name='Cookie'),
  cookieTimeout?: int32(name='CookieTimeout'),
  description?: string(name='Description'),
  forwardPort?: int32(name='ForwardPort'),
  gzip?: string(name='Gzip'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  idleTimeout?: int32(name='IdleTimeout'),
  listenerForward?: string(name='ListenerForward'),
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  requestTimeout?: int32(name='RequestTimeout'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scheduler?: string(name='Scheduler'),
  stickySession?: string(name='StickySession'),
  stickySessionType?: string(name='StickySessionType'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  VServerGroupId?: string(name='VServerGroupId'),
  XForwardedFor?: string(name='XForwardedFor'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto'),
}

model CreateLoadBalancerHTTPListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateLoadBalancerHTTPListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLoadBalancerHTTPListenerResponseBody(name='body'),
}

async function createLoadBalancerHTTPListenerWithOptions(request: CreateLoadBalancerHTTPListenerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerHTTPListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.aclStatus)) {
    query['AclStatus'] = request.aclStatus;
  }
  if (!Util.isUnset(request.aclType)) {
    query['AclType'] = request.aclType;
  }
  if (!Util.isUnset(request.backendServerPort)) {
    query['BackendServerPort'] = request.backendServerPort;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.cookie)) {
    query['Cookie'] = request.cookie;
  }
  if (!Util.isUnset(request.cookieTimeout)) {
    query['CookieTimeout'] = request.cookieTimeout;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.forwardPort)) {
    query['ForwardPort'] = request.forwardPort;
  }
  if (!Util.isUnset(request.gzip)) {
    query['Gzip'] = request.gzip;
  }
  if (!Util.isUnset(request.healthCheck)) {
    query['HealthCheck'] = request.healthCheck;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckDomain)) {
    query['HealthCheckDomain'] = request.healthCheckDomain;
  }
  if (!Util.isUnset(request.healthCheckHttpCode)) {
    query['HealthCheckHttpCode'] = request.healthCheckHttpCode;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckMethod)) {
    query['HealthCheckMethod'] = request.healthCheckMethod;
  }
  if (!Util.isUnset(request.healthCheckTimeout)) {
    query['HealthCheckTimeout'] = request.healthCheckTimeout;
  }
  if (!Util.isUnset(request.healthCheckURI)) {
    query['HealthCheckURI'] = request.healthCheckURI;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.idleTimeout)) {
    query['IdleTimeout'] = request.idleTimeout;
  }
  if (!Util.isUnset(request.listenerForward)) {
    query['ListenerForward'] = request.listenerForward;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestTimeout)) {
    query['RequestTimeout'] = request.requestTimeout;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.stickySession)) {
    query['StickySession'] = request.stickySession;
  }
  if (!Util.isUnset(request.stickySessionType)) {
    query['StickySessionType'] = request.stickySessionType;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }
  if (!Util.isUnset(request.XForwardedFor)) {
    query['XForwardedFor'] = request.XForwardedFor;
  }
  if (!Util.isUnset(request.XForwardedFor_SLBID)) {
    query['XForwardedFor_SLBID'] = request.XForwardedFor_SLBID;
  }
  if (!Util.isUnset(request.XForwardedFor_SLBIP)) {
    query['XForwardedFor_SLBIP'] = request.XForwardedFor_SLBIP;
  }
  if (!Util.isUnset(request.XForwardedFor_proto)) {
    query['XForwardedFor_proto'] = request.XForwardedFor_proto;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLoadBalancerHTTPListener',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLoadBalancerHTTPListener(request: CreateLoadBalancerHTTPListenerRequest): CreateLoadBalancerHTTPListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerHTTPListenerWithOptions(request, runtime);
}

model CreateLoadBalancerHTTPSListenerRequest {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  CACertificateId?: string(name='CACertificateId'),
  cookie?: string(name='Cookie'),
  cookieTimeout?: int32(name='CookieTimeout'),
  description?: string(name='Description'),
  enableHttp2?: string(name='EnableHttp2'),
  gzip?: string(name='Gzip'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  idleTimeout?: int32(name='IdleTimeout'),
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  requestTimeout?: int32(name='RequestTimeout'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scheduler?: string(name='Scheduler'),
  serverCertificateId?: string(name='ServerCertificateId'),
  stickySession?: string(name='StickySession'),
  stickySessionType?: string(name='StickySessionType'),
  TLSCipherPolicy?: string(name='TLSCipherPolicy'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  VServerGroupId?: string(name='VServerGroupId'),
  XForwardedFor?: string(name='XForwardedFor'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto'),
}

model CreateLoadBalancerHTTPSListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateLoadBalancerHTTPSListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLoadBalancerHTTPSListenerResponseBody(name='body'),
}

async function createLoadBalancerHTTPSListenerWithOptions(request: CreateLoadBalancerHTTPSListenerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerHTTPSListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.aclStatus)) {
    query['AclStatus'] = request.aclStatus;
  }
  if (!Util.isUnset(request.aclType)) {
    query['AclType'] = request.aclType;
  }
  if (!Util.isUnset(request.backendServerPort)) {
    query['BackendServerPort'] = request.backendServerPort;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.CACertificateId)) {
    query['CACertificateId'] = request.CACertificateId;
  }
  if (!Util.isUnset(request.cookie)) {
    query['Cookie'] = request.cookie;
  }
  if (!Util.isUnset(request.cookieTimeout)) {
    query['CookieTimeout'] = request.cookieTimeout;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.enableHttp2)) {
    query['EnableHttp2'] = request.enableHttp2;
  }
  if (!Util.isUnset(request.gzip)) {
    query['Gzip'] = request.gzip;
  }
  if (!Util.isUnset(request.healthCheck)) {
    query['HealthCheck'] = request.healthCheck;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckDomain)) {
    query['HealthCheckDomain'] = request.healthCheckDomain;
  }
  if (!Util.isUnset(request.healthCheckHttpCode)) {
    query['HealthCheckHttpCode'] = request.healthCheckHttpCode;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckMethod)) {
    query['HealthCheckMethod'] = request.healthCheckMethod;
  }
  if (!Util.isUnset(request.healthCheckTimeout)) {
    query['HealthCheckTimeout'] = request.healthCheckTimeout;
  }
  if (!Util.isUnset(request.healthCheckURI)) {
    query['HealthCheckURI'] = request.healthCheckURI;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.idleTimeout)) {
    query['IdleTimeout'] = request.idleTimeout;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestTimeout)) {
    query['RequestTimeout'] = request.requestTimeout;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.serverCertificateId)) {
    query['ServerCertificateId'] = request.serverCertificateId;
  }
  if (!Util.isUnset(request.stickySession)) {
    query['StickySession'] = request.stickySession;
  }
  if (!Util.isUnset(request.stickySessionType)) {
    query['StickySessionType'] = request.stickySessionType;
  }
  if (!Util.isUnset(request.TLSCipherPolicy)) {
    query['TLSCipherPolicy'] = request.TLSCipherPolicy;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }
  if (!Util.isUnset(request.XForwardedFor)) {
    query['XForwardedFor'] = request.XForwardedFor;
  }
  if (!Util.isUnset(request.XForwardedFor_SLBID)) {
    query['XForwardedFor_SLBID'] = request.XForwardedFor_SLBID;
  }
  if (!Util.isUnset(request.XForwardedFor_SLBIP)) {
    query['XForwardedFor_SLBIP'] = request.XForwardedFor_SLBIP;
  }
  if (!Util.isUnset(request.XForwardedFor_proto)) {
    query['XForwardedFor_proto'] = request.XForwardedFor_proto;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLoadBalancerHTTPSListener',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLoadBalancerHTTPSListener(request: CreateLoadBalancerHTTPSListenerRequest): CreateLoadBalancerHTTPSListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerHTTPSListenerWithOptions(request, runtime);
}

model CreateLoadBalancerTCPListenerRequest {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  connectionDrain?: string(name='ConnectionDrain'),
  connectionDrainTimeout?: int32(name='ConnectionDrainTimeout'),
  description?: string(name='Description'),
  establishedTimeout?: int32(name='EstablishedTimeout'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckType?: string(name='HealthCheckType'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  persistenceTimeout?: int32(name='PersistenceTimeout'),
  proxyProtocolV2Enabled?: boolean(name='ProxyProtocolV2Enabled'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scheduler?: string(name='Scheduler'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  VServerGroupId?: string(name='VServerGroupId'),
  healthCheckInterval?: int32(name='healthCheckInterval'),
}

model CreateLoadBalancerTCPListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateLoadBalancerTCPListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLoadBalancerTCPListenerResponseBody(name='body'),
}

async function createLoadBalancerTCPListenerWithOptions(request: CreateLoadBalancerTCPListenerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerTCPListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.aclStatus)) {
    query['AclStatus'] = request.aclStatus;
  }
  if (!Util.isUnset(request.aclType)) {
    query['AclType'] = request.aclType;
  }
  if (!Util.isUnset(request.backendServerPort)) {
    query['BackendServerPort'] = request.backendServerPort;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.connectionDrain)) {
    query['ConnectionDrain'] = request.connectionDrain;
  }
  if (!Util.isUnset(request.connectionDrainTimeout)) {
    query['ConnectionDrainTimeout'] = request.connectionDrainTimeout;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.establishedTimeout)) {
    query['EstablishedTimeout'] = request.establishedTimeout;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckConnectTimeout)) {
    query['HealthCheckConnectTimeout'] = request.healthCheckConnectTimeout;
  }
  if (!Util.isUnset(request.healthCheckDomain)) {
    query['HealthCheckDomain'] = request.healthCheckDomain;
  }
  if (!Util.isUnset(request.healthCheckHttpCode)) {
    query['HealthCheckHttpCode'] = request.healthCheckHttpCode;
  }
  if (!Util.isUnset(request.healthCheckType)) {
    query['HealthCheckType'] = request.healthCheckType;
  }
  if (!Util.isUnset(request.healthCheckURI)) {
    query['HealthCheckURI'] = request.healthCheckURI;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.masterSlaveServerGroupId)) {
    query['MasterSlaveServerGroupId'] = request.masterSlaveServerGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.persistenceTimeout)) {
    query['PersistenceTimeout'] = request.persistenceTimeout;
  }
  if (!Util.isUnset(request.proxyProtocolV2Enabled)) {
    query['ProxyProtocolV2Enabled'] = request.proxyProtocolV2Enabled;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['healthCheckInterval'] = request.healthCheckInterval;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLoadBalancerTCPListener',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLoadBalancerTCPListener(request: CreateLoadBalancerTCPListenerRequest): CreateLoadBalancerTCPListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerTCPListenerWithOptions(request, runtime);
}

model CreateLoadBalancerUDPListenerRequest {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  description?: string(name='Description'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  proxyProtocolV2Enabled?: boolean(name='ProxyProtocolV2Enabled'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scheduler?: string(name='Scheduler'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  VServerGroupId?: string(name='VServerGroupId'),
  healthCheckExp?: string(name='healthCheckExp'),
  healthCheckInterval?: int32(name='healthCheckInterval'),
  healthCheckReq?: string(name='healthCheckReq'),
}

model CreateLoadBalancerUDPListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateLoadBalancerUDPListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLoadBalancerUDPListenerResponseBody(name='body'),
}

async function createLoadBalancerUDPListenerWithOptions(request: CreateLoadBalancerUDPListenerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerUDPListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.aclStatus)) {
    query['AclStatus'] = request.aclStatus;
  }
  if (!Util.isUnset(request.aclType)) {
    query['AclType'] = request.aclType;
  }
  if (!Util.isUnset(request.backendServerPort)) {
    query['BackendServerPort'] = request.backendServerPort;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckConnectTimeout)) {
    query['HealthCheckConnectTimeout'] = request.healthCheckConnectTimeout;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.masterSlaveServerGroupId)) {
    query['MasterSlaveServerGroupId'] = request.masterSlaveServerGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.proxyProtocolV2Enabled)) {
    query['ProxyProtocolV2Enabled'] = request.proxyProtocolV2Enabled;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }
  if (!Util.isUnset(request.healthCheckExp)) {
    query['healthCheckExp'] = request.healthCheckExp;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['healthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckReq)) {
    query['healthCheckReq'] = request.healthCheckReq;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLoadBalancerUDPListener',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLoadBalancerUDPListener(request: CreateLoadBalancerUDPListenerRequest): CreateLoadBalancerUDPListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerUDPListenerWithOptions(request, runtime);
}

model CreateMasterSlaveServerGroupRequest {
  loadBalancerId?: string(name='LoadBalancerId'),
  masterSlaveBackendServers?: string(name='MasterSlaveBackendServers'),
  masterSlaveServerGroupName?: string(name='MasterSlaveServerGroupName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateMasterSlaveServerGroupResponseBody = {
  masterSlaveBackendServers?: {
    masterSlaveBackendServer?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      serverType?: string(name='ServerType'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='MasterSlaveBackendServer')
  }(name='MasterSlaveBackendServers'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateMasterSlaveServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMasterSlaveServerGroupResponseBody(name='body'),
}

async function createMasterSlaveServerGroupWithOptions(request: CreateMasterSlaveServerGroupRequest, runtime: Util.RuntimeOptions): CreateMasterSlaveServerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.masterSlaveBackendServers)) {
    query['MasterSlaveBackendServers'] = request.masterSlaveBackendServers;
  }
  if (!Util.isUnset(request.masterSlaveServerGroupName)) {
    query['MasterSlaveServerGroupName'] = request.masterSlaveServerGroupName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMasterSlaveServerGroup',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMasterSlaveServerGroup(request: CreateMasterSlaveServerGroupRequest): CreateMasterSlaveServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMasterSlaveServerGroupWithOptions(request, runtime);
}

model CreateRulesRequest {
  listenerPort?: int32(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleList?: string(name='RuleList'),
}

model CreateRulesResponseBody = {
  requestId?: string(name='RequestId'),
  rules?: {
    rule?: [ 
    {
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
    }
  ](name='Rule')
  }(name='Rules'),
}

model CreateRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRulesResponseBody(name='body'),
}

async function createRulesWithOptions(request: CreateRulesRequest, runtime: Util.RuntimeOptions): CreateRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleList)) {
    query['RuleList'] = request.ruleList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRules',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRules(request: CreateRulesRequest): CreateRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRulesWithOptions(request, runtime);
}

model CreateTLSCipherPolicyRequest {
  ciphers?: [ string ](name='Ciphers'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  TLSVersions?: [ string ](name='TLSVersions'),
}

model CreateTLSCipherPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  TLSCipherPolicyId?: string(name='TLSCipherPolicyId'),
}

model CreateTLSCipherPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTLSCipherPolicyResponseBody(name='body'),
}

async function createTLSCipherPolicyWithOptions(request: CreateTLSCipherPolicyRequest, runtime: Util.RuntimeOptions): CreateTLSCipherPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ciphers)) {
    query['Ciphers'] = request.ciphers;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.TLSVersions)) {
    query['TLSVersions'] = request.TLSVersions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTLSCipherPolicy',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTLSCipherPolicy(request: CreateTLSCipherPolicyRequest): CreateTLSCipherPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTLSCipherPolicyWithOptions(request, runtime);
}

model CreateVServerGroupRequest {
  backendServers?: string(name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VServerGroupName?: string(name='VServerGroupName'),
}

model CreateVServerGroupResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model CreateVServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVServerGroupResponseBody(name='body'),
}

async function createVServerGroupWithOptions(request: CreateVServerGroupRequest, runtime: Util.RuntimeOptions): CreateVServerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backendServers)) {
    query['BackendServers'] = request.backendServers;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.VServerGroupName)) {
    query['VServerGroupName'] = request.VServerGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVServerGroup',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVServerGroup(request: CreateVServerGroupRequest): CreateVServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVServerGroupWithOptions(request, runtime);
}

model DeleteAccessControlListRequest {
  aclId?: string(name='AclId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteAccessControlListResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAccessControlListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAccessControlListResponseBody(name='body'),
}

async function deleteAccessControlListWithOptions(request: DeleteAccessControlListRequest, runtime: Util.RuntimeOptions): DeleteAccessControlListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAccessControlList',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAccessControlList(request: DeleteAccessControlListRequest): DeleteAccessControlListResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccessControlListWithOptions(request, runtime);
}

model DeleteCACertificateRequest {
  CACertificateId?: string(name='CACertificateId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteCACertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCACertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCACertificateResponseBody(name='body'),
}

async function deleteCACertificateWithOptions(request: DeleteCACertificateRequest, runtime: Util.RuntimeOptions): DeleteCACertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.CACertificateId)) {
    query['CACertificateId'] = request.CACertificateId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCACertificate',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCACertificate(request: DeleteCACertificateRequest): DeleteCACertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCACertificateWithOptions(request, runtime);
}

model DeleteDomainExtensionRequest {
  domainExtensionId?: string(name='DomainExtensionId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDomainExtensionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDomainExtensionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDomainExtensionResponseBody(name='body'),
}

async function deleteDomainExtensionWithOptions(request: DeleteDomainExtensionRequest, runtime: Util.RuntimeOptions): DeleteDomainExtensionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainExtensionId)) {
    query['DomainExtensionId'] = request.domainExtensionId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomainExtension',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDomainExtension(request: DeleteDomainExtensionRequest): DeleteDomainExtensionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDomainExtensionWithOptions(request, runtime);
}

model DeleteLoadBalancerRequest {
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteLoadBalancerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLoadBalancerResponseBody(name='body'),
}

async function deleteLoadBalancerWithOptions(request: DeleteLoadBalancerRequest, runtime: Util.RuntimeOptions): DeleteLoadBalancerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLoadBalancer',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLoadBalancer(request: DeleteLoadBalancerRequest): DeleteLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLoadBalancerWithOptions(request, runtime);
}

model DeleteLoadBalancerListenerRequest {
  listenerPort?: int32(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteLoadBalancerListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLoadBalancerListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLoadBalancerListenerResponseBody(name='body'),
}

async function deleteLoadBalancerListenerWithOptions(request: DeleteLoadBalancerListenerRequest, runtime: Util.RuntimeOptions): DeleteLoadBalancerListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLoadBalancerListener',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLoadBalancerListener(request: DeleteLoadBalancerListenerRequest): DeleteLoadBalancerListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLoadBalancerListenerWithOptions(request, runtime);
}

model DeleteMasterSlaveServerGroupRequest {
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteMasterSlaveServerGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMasterSlaveServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMasterSlaveServerGroupResponseBody(name='body'),
}

async function deleteMasterSlaveServerGroupWithOptions(request: DeleteMasterSlaveServerGroupRequest, runtime: Util.RuntimeOptions): DeleteMasterSlaveServerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.masterSlaveServerGroupId)) {
    query['MasterSlaveServerGroupId'] = request.masterSlaveServerGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMasterSlaveServerGroup',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMasterSlaveServerGroup(request: DeleteMasterSlaveServerGroupRequest): DeleteMasterSlaveServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMasterSlaveServerGroupWithOptions(request, runtime);
}

model DeleteRulesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleIds?: string(name='RuleIds'),
}

model DeleteRulesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRulesResponseBody(name='body'),
}

async function deleteRulesWithOptions(request: DeleteRulesRequest, runtime: Util.RuntimeOptions): DeleteRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleIds)) {
    query['RuleIds'] = request.ruleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRules',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRules(request: DeleteRulesRequest): DeleteRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRulesWithOptions(request, runtime);
}

model DeleteServerCertificateRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serverCertificateId?: string(name='ServerCertificateId'),
}

model DeleteServerCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteServerCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServerCertificateResponseBody(name='body'),
}

async function deleteServerCertificateWithOptions(request: DeleteServerCertificateRequest, runtime: Util.RuntimeOptions): DeleteServerCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.serverCertificateId)) {
    query['ServerCertificateId'] = request.serverCertificateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServerCertificate',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteServerCertificate(request: DeleteServerCertificateRequest): DeleteServerCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServerCertificateWithOptions(request, runtime);
}

model DeleteTLSCipherPolicyRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  TLSCipherPolicyId?: string(name='TLSCipherPolicyId'),
}

model DeleteTLSCipherPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTLSCipherPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTLSCipherPolicyResponseBody(name='body'),
}

async function deleteTLSCipherPolicyWithOptions(request: DeleteTLSCipherPolicyRequest, runtime: Util.RuntimeOptions): DeleteTLSCipherPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.TLSCipherPolicyId)) {
    query['TLSCipherPolicyId'] = request.TLSCipherPolicyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTLSCipherPolicy',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTLSCipherPolicy(request: DeleteTLSCipherPolicyRequest): DeleteTLSCipherPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTLSCipherPolicyWithOptions(request, runtime);
}

model DeleteVServerGroupRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model DeleteVServerGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVServerGroupResponseBody(name='body'),
}

async function deleteVServerGroupWithOptions(request: DeleteVServerGroupRequest, runtime: Util.RuntimeOptions): DeleteVServerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVServerGroup',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVServerGroup(request: DeleteVServerGroupRequest): DeleteVServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVServerGroupWithOptions(request, runtime);
}

model DescribeAccessControlListAttributeRequest {
  aclEntryComment?: string(name='AclEntryComment'),
  aclId?: string(name='AclId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAccessControlListAttributeResponseBody = {
  aclEntrys?: {
    aclEntry?: [ 
    {
      aclEntryComment?: string(name='AclEntryComment'),
      aclEntryIP?: string(name='AclEntryIP'),
    }
  ](name='AclEntry')
  }(name='AclEntrys'),
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
  addressIPVersion?: string(name='AddressIPVersion'),
  relatedListeners?: {
    relatedListener?: [ 
    {
      aclType?: string(name='AclType'),
      listenerPort?: int32(name='ListenerPort'),
      loadBalancerId?: string(name='LoadBalancerId'),
      protocol?: string(name='Protocol'),
    }
  ](name='RelatedListener')
  }(name='RelatedListeners'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeAccessControlListAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAccessControlListAttributeResponseBody(name='body'),
}

async function describeAccessControlListAttributeWithOptions(request: DescribeAccessControlListAttributeRequest, runtime: Util.RuntimeOptions): DescribeAccessControlListAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclEntryComment)) {
    query['AclEntryComment'] = request.aclEntryComment;
  }
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAccessControlListAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAccessControlListAttribute(request: DescribeAccessControlListAttributeRequest): DescribeAccessControlListAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccessControlListAttributeWithOptions(request, runtime);
}

model DescribeAccessControlListsRequest {
  aclName?: string(name='AclName'),
  addressIPVersion?: string(name='AddressIPVersion'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAccessControlListsResponseBody = {
  acls?: {
    acl?: [ 
    {
      aclId?: string(name='AclId'),
      aclName?: string(name='AclName'),
      addressIPVersion?: string(name='AddressIPVersion'),
      resourceGroupId?: string(name='ResourceGroupId'),
    }
  ](name='Acl')
  }(name='Acls'),
  count?: int32(name='Count'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeAccessControlListsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAccessControlListsResponseBody(name='body'),
}

async function describeAccessControlListsWithOptions(request: DescribeAccessControlListsRequest, runtime: Util.RuntimeOptions): DescribeAccessControlListsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclName)) {
    query['AclName'] = request.aclName;
  }
  if (!Util.isUnset(request.addressIPVersion)) {
    query['AddressIPVersion'] = request.addressIPVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAccessControlLists',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAccessControlLists(request: DescribeAccessControlListsRequest): DescribeAccessControlListsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccessControlListsWithOptions(request, runtime);
}

model DescribeAvailableResourceRequest {
  addressIPVersion?: string(name='AddressIPVersion'),
  addressType?: string(name='AddressType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAvailableResourceResponseBody = {
  availableResources?: {
    availableResource?: [ 
    {
      masterZoneId?: string(name='MasterZoneId'),
      slaveZoneId?: string(name='SlaveZoneId'),
      supportResources?: {
        supportResource?: [ 
        {
          addressIPVersion?: string(name='AddressIPVersion'),
          addressType?: string(name='AddressType'),
        }
      ](name='SupportResource')
      }(name='SupportResources'),
    }
  ](name='AvailableResource')
  }(name='AvailableResources'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAvailableResourceResponseBody(name='body'),
}

async function describeAvailableResourceWithOptions(request: DescribeAvailableResourceRequest, runtime: Util.RuntimeOptions): DescribeAvailableResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addressIPVersion)) {
    query['AddressIPVersion'] = request.addressIPVersion;
  }
  if (!Util.isUnset(request.addressType)) {
    query['AddressType'] = request.addressType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAvailableResource',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAvailableResource(request: DescribeAvailableResourceRequest): DescribeAvailableResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableResourceWithOptions(request, runtime);
}

model DescribeCACertificatesRequest {
  CACertificateId?: string(name='CACertificateId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeCACertificatesResponseBody = {
  CACertificates?: {
    CACertificate?: [ 
    {
      CACertificateId?: string(name='CACertificateId'),
      CACertificateName?: string(name='CACertificateName'),
      commonName?: string(name='CommonName'),
      createTime?: string(name='CreateTime'),
      createTimeStamp?: long(name='CreateTimeStamp'),
      expireTime?: string(name='ExpireTime'),
      expireTimeStamp?: long(name='ExpireTimeStamp'),
      fingerprint?: string(name='Fingerprint'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
    }
  ](name='CACertificate')
  }(name='CACertificates'),
  requestId?: string(name='RequestId'),
}

model DescribeCACertificatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCACertificatesResponseBody(name='body'),
}

async function describeCACertificatesWithOptions(request: DescribeCACertificatesRequest, runtime: Util.RuntimeOptions): DescribeCACertificatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.CACertificateId)) {
    query['CACertificateId'] = request.CACertificateId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCACertificates',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCACertificates(request: DescribeCACertificatesRequest): DescribeCACertificatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCACertificatesWithOptions(request, runtime);
}

model DescribeDomainExtensionAttributeRequest {
  domainExtensionId?: string(name='DomainExtensionId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDomainExtensionAttributeResponseBody = {
  domain?: string(name='Domain'),
  domainExtensionId?: string(name='DomainExtensionId'),
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
  requestId?: string(name='RequestId'),
  serverCertificateId?: string(name='ServerCertificateId'),
}

model DescribeDomainExtensionAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainExtensionAttributeResponseBody(name='body'),
}

async function describeDomainExtensionAttributeWithOptions(request: DescribeDomainExtensionAttributeRequest, runtime: Util.RuntimeOptions): DescribeDomainExtensionAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainExtensionId)) {
    query['DomainExtensionId'] = request.domainExtensionId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainExtensionAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainExtensionAttribute(request: DescribeDomainExtensionAttributeRequest): DescribeDomainExtensionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainExtensionAttributeWithOptions(request, runtime);
}

model DescribeDomainExtensionsRequest {
  domainExtensionId?: string(name='DomainExtensionId'),
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDomainExtensionsResponseBody = {
  domainExtensions?: {
    domainExtension?: [ 
    {
      domain?: string(name='Domain'),
      domainExtensionId?: string(name='DomainExtensionId'),
      serverCertificateId?: string(name='ServerCertificateId'),
    }
  ](name='DomainExtension')
  }(name='DomainExtensions'),
  requestId?: string(name='RequestId'),
}

model DescribeDomainExtensionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainExtensionsResponseBody(name='body'),
}

async function describeDomainExtensionsWithOptions(request: DescribeDomainExtensionsRequest, runtime: Util.RuntimeOptions): DescribeDomainExtensionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainExtensionId)) {
    query['DomainExtensionId'] = request.domainExtensionId;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainExtensions',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainExtensions(request: DescribeDomainExtensionsRequest): DescribeDomainExtensionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainExtensionsWithOptions(request, runtime);
}

model DescribeHealthStatusRequest {
  listenerPort?: int32(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeHealthStatusResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      listenerPort?: int32(name='ListenerPort'),
      port?: int32(name='Port'),
      protocol?: string(name='Protocol'),
      serverHealthStatus?: string(name='ServerHealthStatus'),
      serverId?: string(name='ServerId'),
      serverIp?: string(name='ServerIp'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId'),
}

model DescribeHealthStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHealthStatusResponseBody(name='body'),
}

async function describeHealthStatusWithOptions(request: DescribeHealthStatusRequest, runtime: Util.RuntimeOptions): DescribeHealthStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHealthStatus',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHealthStatus(request: DescribeHealthStatusRequest): DescribeHealthStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHealthStatusWithOptions(request, runtime);
}

model DescribeListenerAccessControlAttributeRequest {
  listenerPort?: int32(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeListenerAccessControlAttributeResponseBody = {
  accessControlStatus?: string(name='AccessControlStatus'),
  requestId?: string(name='RequestId'),
  sourceItems?: string(name='SourceItems'),
}

model DescribeListenerAccessControlAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeListenerAccessControlAttributeResponseBody(name='body'),
}

async function describeListenerAccessControlAttributeWithOptions(request: DescribeListenerAccessControlAttributeRequest, runtime: Util.RuntimeOptions): DescribeListenerAccessControlAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeListenerAccessControlAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeListenerAccessControlAttribute(request: DescribeListenerAccessControlAttributeRequest): DescribeListenerAccessControlAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeListenerAccessControlAttributeWithOptions(request, runtime);
}

model DescribeLoadBalancerAttributeRequest {
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeLoadBalancerAttributeResponseBody = {
  address?: string(name='Address'),
  addressIPVersion?: string(name='AddressIPVersion'),
  addressType?: string(name='AddressType'),
  autoReleaseTime?: long(name='AutoReleaseTime'),
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  bandwidth?: int32(name='Bandwidth'),
  createTime?: string(name='CreateTime'),
  createTimeStamp?: long(name='CreateTimeStamp'),
  deleteProtection?: string(name='DeleteProtection'),
  endTime?: string(name='EndTime'),
  endTimeStamp?: long(name='EndTimeStamp'),
  instanceChargeType?: string(name='InstanceChargeType'),
  internetChargeType?: string(name='InternetChargeType'),
  listenerPorts?: {
    listenerPort?: [ int32 ](name='ListenerPort')
  }(name='ListenerPorts'),
  listenerPortsAndProtocal?: {
    listenerPortAndProtocal?: [ 
    {
      listenerPort?: int32(name='ListenerPort'),
      listenerProtocal?: string(name='ListenerProtocal'),
    }
  ](name='ListenerPortAndProtocal')
  }(name='ListenerPortsAndProtocal'),
  listenerPortsAndProtocol?: {
    listenerPortAndProtocol?: [ 
    {
      description?: string(name='Description'),
      forwardPort?: int32(name='ForwardPort'),
      listenerForward?: string(name='ListenerForward'),
      listenerPort?: int32(name='ListenerPort'),
      listenerProtocol?: string(name='ListenerProtocol'),
    }
  ](name='ListenerPortAndProtocol')
  }(name='ListenerPortsAndProtocol'),
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerName?: string(name='LoadBalancerName'),
  loadBalancerSpec?: string(name='LoadBalancerSpec'),
  loadBalancerStatus?: string(name='LoadBalancerStatus'),
  masterZoneId?: string(name='MasterZoneId'),
  modificationProtectionReason?: string(name='ModificationProtectionReason'),
  modificationProtectionStatus?: string(name='ModificationProtectionStatus'),
  networkType?: string(name='NetworkType'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  regionIdAlias?: string(name='RegionIdAlias'),
  renewalCycUnit?: string(name='RenewalCycUnit'),
  renewalDuration?: int32(name='RenewalDuration'),
  renewalStatus?: string(name='RenewalStatus'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  slaveZoneId?: string(name='SlaveZoneId'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model DescribeLoadBalancerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLoadBalancerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerAttributeWithOptions(request: DescribeLoadBalancerAttributeRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLoadBalancerAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLoadBalancerAttribute(request: DescribeLoadBalancerAttributeRequest): DescribeLoadBalancerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerAttributeWithOptions(request, runtime);
}

model DescribeLoadBalancerHTTPListenerAttributeRequest {
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeLoadBalancerHTTPListenerAttributeResponseBody = {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  cookie?: string(name='Cookie'),
  cookieTimeout?: int32(name='CookieTimeout'),
  description?: string(name='Description'),
  forwardPort?: int32(name='ForwardPort'),
  gzip?: string(name='Gzip'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  idleTimeout?: int32(name='IdleTimeout'),
  listenerForward?: string(name='ListenerForward'),
  listenerPort?: int32(name='ListenerPort'),
  requestId?: string(name='RequestId'),
  requestTimeout?: int32(name='RequestTimeout'),
  rules?: {
    rule?: [ 
    {
      domain?: string(name='Domain'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      url?: string(name='Url'),
      VServerGroupId?: string(name='VServerGroupId'),
    }
  ](name='Rule')
  }(name='Rules'),
  scheduler?: string(name='Scheduler'),
  securityStatus?: string(name='SecurityStatus'),
  status?: string(name='Status'),
  stickySession?: string(name='StickySession'),
  stickySessionType?: string(name='StickySessionType'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  VServerGroupId?: string(name='VServerGroupId'),
  XForwardedFor?: string(name='XForwardedFor'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto'),
}

model DescribeLoadBalancerHTTPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLoadBalancerHTTPListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerHTTPListenerAttributeWithOptions(request: DescribeLoadBalancerHTTPListenerAttributeRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerHTTPListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLoadBalancerHTTPListenerAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLoadBalancerHTTPListenerAttribute(request: DescribeLoadBalancerHTTPListenerAttributeRequest): DescribeLoadBalancerHTTPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerHTTPListenerAttributeWithOptions(request, runtime);
}

model DescribeLoadBalancerHTTPSListenerAttributeRequest {
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeLoadBalancerHTTPSListenerAttributeResponseBody = {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  CACertificateId?: string(name='CACertificateId'),
  cookie?: string(name='Cookie'),
  cookieTimeout?: int32(name='CookieTimeout'),
  description?: string(name='Description'),
  domainExtensions?: {
    domainExtension?: [ 
    {
      domain?: string(name='Domain'),
      domainExtensionId?: string(name='DomainExtensionId'),
      serverCertificateId?: string(name='ServerCertificateId'),
    }
  ](name='DomainExtension')
  }(name='DomainExtensions'),
  enableHttp2?: string(name='EnableHttp2'),
  gzip?: string(name='Gzip'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  idleTimeout?: int32(name='IdleTimeout'),
  listenerPort?: int32(name='ListenerPort'),
  requestId?: string(name='RequestId'),
  requestTimeout?: int32(name='RequestTimeout'),
  rules?: {
    rule?: [ 
    {
      domain?: string(name='Domain'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      url?: string(name='Url'),
      VServerGroupId?: string(name='VServerGroupId'),
    }
  ](name='Rule')
  }(name='Rules'),
  scheduler?: string(name='Scheduler'),
  securityStatus?: string(name='SecurityStatus'),
  serverCertificateId?: string(name='ServerCertificateId'),
  status?: string(name='Status'),
  stickySession?: string(name='StickySession'),
  stickySessionType?: string(name='StickySessionType'),
  TLSCipherPolicy?: string(name='TLSCipherPolicy'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  VServerGroupId?: string(name='VServerGroupId'),
  XForwardedFor?: string(name='XForwardedFor'),
  XForwardedFor_ClientCertClientVerify?: string(name='XForwardedFor_ClientCertClientVerify'),
  XForwardedFor_ClientCertFingerprint?: string(name='XForwardedFor_ClientCertFingerprint'),
  XForwardedFor_ClientCertIssuerDN?: string(name='XForwardedFor_ClientCertIssuerDN'),
  XForwardedFor_ClientCertSubjectDN?: string(name='XForwardedFor_ClientCertSubjectDN'),
  XForwardedFor_ClientSrcPort?: string(name='XForwardedFor_ClientSrcPort'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
  XForwardedFor_SLBPORT?: string(name='XForwardedFor_SLBPORT'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto'),
}

model DescribeLoadBalancerHTTPSListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLoadBalancerHTTPSListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerHTTPSListenerAttributeWithOptions(request: DescribeLoadBalancerHTTPSListenerAttributeRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerHTTPSListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLoadBalancerHTTPSListenerAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLoadBalancerHTTPSListenerAttribute(request: DescribeLoadBalancerHTTPSListenerAttributeRequest): DescribeLoadBalancerHTTPSListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerHTTPSListenerAttributeWithOptions(request, runtime);
}

model DescribeLoadBalancerListenersRequest {
  listenerProtocol?: string(name='ListenerProtocol'),
  loadBalancerId?: [ string ](name='LoadBalancerId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeLoadBalancerListenersResponseBody = {
  listeners?: [ 
    {
      aclId?: string(name='AclId'),
      aclStatus?: string(name='AclStatus'),
      aclType?: string(name='AclType'),
      backendServerPort?: int32(name='BackendServerPort'),
      bandwidth?: int32(name='Bandwidth'),
      description?: string(name='Description'),
      HTTPListenerConfig?: {
        cookie?: string(name='Cookie'),
        cookieTimeout?: int32(name='CookieTimeout'),
        forwardPort?: int32(name='ForwardPort'),
        gzip?: string(name='Gzip'),
        healthCheck?: string(name='HealthCheck'),
        healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
        healthCheckDomain?: string(name='HealthCheckDomain'),
        healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
        healthCheckHttpVersion?: string(name='HealthCheckHttpVersion'),
        healthCheckInterval?: int32(name='HealthCheckInterval'),
        healthCheckMethod?: string(name='HealthCheckMethod'),
        healthCheckTimeout?: int32(name='HealthCheckTimeout'),
        healthCheckType?: string(name='HealthCheckType'),
        healthCheckURI?: string(name='HealthCheckURI'),
        healthyThreshold?: int32(name='HealthyThreshold'),
        idleTimeout?: int32(name='IdleTimeout'),
        listenerForward?: string(name='ListenerForward'),
        requestTimeout?: int32(name='RequestTimeout'),
        stickySession?: string(name='StickySession'),
        stickySessionType?: string(name='StickySessionType'),
        unhealthyThreshold?: int32(name='UnhealthyThreshold'),
        XForwardedFor?: string(name='XForwardedFor'),
        XForwardedFor_ClientSrcPort?: string(name='XForwardedFor_ClientSrcPort'),
        XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
        XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
        XForwardedFor_SLBPORT?: string(name='XForwardedFor_SLBPORT'),
        XForwardedFor_proto?: string(name='XForwardedFor_proto'),
      }(name='HTTPListenerConfig'),
      HTTPSListenerConfig?: {
        CACertificateId?: string(name='CACertificateId'),
        cookie?: string(name='Cookie'),
        cookieTimeout?: int32(name='CookieTimeout'),
        enableHttp2?: string(name='EnableHttp2'),
        gzip?: string(name='Gzip'),
        healthCheck?: string(name='HealthCheck'),
        healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
        healthCheckDomain?: string(name='HealthCheckDomain'),
        healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
        healthCheckHttpVersion?: string(name='HealthCheckHttpVersion'),
        healthCheckInterval?: int32(name='HealthCheckInterval'),
        healthCheckMethod?: string(name='HealthCheckMethod'),
        healthCheckTimeout?: int32(name='HealthCheckTimeout'),
        healthCheckType?: string(name='HealthCheckType'),
        healthCheckURI?: string(name='HealthCheckURI'),
        healthyThreshold?: int32(name='HealthyThreshold'),
        idleTimeout?: int32(name='IdleTimeout'),
        requestTimeout?: int32(name='RequestTimeout'),
        serverCertificateId?: string(name='ServerCertificateId'),
        stickySession?: string(name='StickySession'),
        stickySessionType?: string(name='StickySessionType'),
        TLSCipherPolicy?: string(name='TLSCipherPolicy'),
        unhealthyThreshold?: int32(name='UnhealthyThreshold'),
        XForwardedFor?: string(name='XForwardedFor'),
        XForwardedFor_ClientCertClientVerify?: string(name='XForwardedFor_ClientCertClientVerify'),
        XForwardedFor_ClientCertFingerprint?: string(name='XForwardedFor_ClientCertFingerprint'),
        XForwardedFor_ClientCertIssuerDN?: string(name='XForwardedFor_ClientCertIssuerDN'),
        XForwardedFor_ClientCertSubjectDN?: string(name='XForwardedFor_ClientCertSubjectDN'),
        XForwardedFor_ClientSrcPort?: string(name='XForwardedFor_ClientSrcPort'),
        XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
        XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
        XForwardedFor_SLBPORT?: string(name='XForwardedFor_SLBPORT'),
        XForwardedFor_proto?: string(name='XForwardedFor_proto'),
      }(name='HTTPSListenerConfig'),
      listenerPort?: int32(name='ListenerPort'),
      listenerProtocol?: string(name='ListenerProtocol'),
      loadBalancerId?: string(name='LoadBalancerId'),
      scheduler?: string(name='Scheduler'),
      status?: string(name='Status'),
      TCPListenerConfig?: {
        connectionDrain?: string(name='ConnectionDrain'),
        connectionDrainTimeout?: int32(name='ConnectionDrainTimeout'),
        establishedTimeout?: int32(name='EstablishedTimeout'),
        healthCheck?: string(name='HealthCheck'),
        healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
        healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
        healthCheckDomain?: string(name='HealthCheckDomain'),
        healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
        healthCheckInterval?: int32(name='HealthCheckInterval'),
        healthCheckMethod?: string(name='HealthCheckMethod'),
        healthCheckType?: string(name='HealthCheckType'),
        healthCheckURI?: string(name='HealthCheckURI'),
        healthyThreshold?: int32(name='HealthyThreshold'),
        masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
        persistenceTimeout?: int32(name='PersistenceTimeout'),
        unhealthyThreshold?: int32(name='UnhealthyThreshold'),
      }(name='TCPListenerConfig'),
      UDPListenerConfig?: {
        connectionDrain?: string(name='ConnectionDrain'),
        connectionDrainTimeout?: int32(name='ConnectionDrainTimeout'),
        healthCheck?: string(name='HealthCheck'),
        healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
        healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
        healthCheckExp?: string(name='HealthCheckExp'),
        healthCheckInterval?: int32(name='HealthCheckInterval'),
        healthCheckReq?: string(name='HealthCheckReq'),
        healthyThreshold?: int32(name='HealthyThreshold'),
        masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
        unhealthyThreshold?: int32(name='UnhealthyThreshold'),
      }(name='UDPListenerConfig'),
      VServerGroupId?: string(name='VServerGroupId'),
    }
  ](name='Listeners'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeLoadBalancerListenersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLoadBalancerListenersResponseBody(name='body'),
}

async function describeLoadBalancerListenersWithOptions(request: DescribeLoadBalancerListenersRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerListenersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLoadBalancerListeners',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLoadBalancerListeners(request: DescribeLoadBalancerListenersRequest): DescribeLoadBalancerListenersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerListenersWithOptions(request, runtime);
}

model DescribeLoadBalancerTCPListenerAttributeRequest {
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeLoadBalancerTCPListenerAttributeResponseBody = {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  connectionDrain?: string(name='ConnectionDrain'),
  connectionDrainTimeout?: int32(name='ConnectionDrainTimeout'),
  description?: string(name='Description'),
  establishedTimeout?: int32(name='EstablishedTimeout'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckType?: string(name='HealthCheckType'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  listenerPort?: int32(name='ListenerPort'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  persistenceTimeout?: int32(name='PersistenceTimeout'),
  proxyProtocolV2Enabled?: boolean(name='ProxyProtocolV2Enabled'),
  requestId?: string(name='RequestId'),
  scheduler?: string(name='Scheduler'),
  status?: string(name='Status'),
  synProxy?: string(name='SynProxy'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model DescribeLoadBalancerTCPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLoadBalancerTCPListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerTCPListenerAttributeWithOptions(request: DescribeLoadBalancerTCPListenerAttributeRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerTCPListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLoadBalancerTCPListenerAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLoadBalancerTCPListenerAttribute(request: DescribeLoadBalancerTCPListenerAttributeRequest): DescribeLoadBalancerTCPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerTCPListenerAttributeWithOptions(request, runtime);
}

model DescribeLoadBalancerUDPListenerAttributeRequest {
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeLoadBalancerUDPListenerAttributeResponseBody = {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  backendServerPort?: int32(name='BackendServerPort'),
  bandwidth?: int32(name='Bandwidth'),
  description?: string(name='Description'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthCheckExp?: string(name='HealthCheckExp'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckReq?: string(name='HealthCheckReq'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  listenerPort?: int32(name='ListenerPort'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  proxyProtocolV2Enabled?: boolean(name='ProxyProtocolV2Enabled'),
  requestId?: string(name='RequestId'),
  scheduler?: string(name='Scheduler'),
  status?: string(name='Status'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model DescribeLoadBalancerUDPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLoadBalancerUDPListenerAttributeResponseBody(name='body'),
}

async function describeLoadBalancerUDPListenerAttributeWithOptions(request: DescribeLoadBalancerUDPListenerAttributeRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancerUDPListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLoadBalancerUDPListenerAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLoadBalancerUDPListenerAttribute(request: DescribeLoadBalancerUDPListenerAttributeRequest): DescribeLoadBalancerUDPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancerUDPListenerAttributeWithOptions(request, runtime);
}

model DescribeLoadBalancersRequest {
  address?: string(name='Address'),
  addressIPVersion?: string(name='AddressIPVersion'),
  addressType?: string(name='AddressType'),
  internetChargeType?: string(name='InternetChargeType'),
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerName?: string(name='LoadBalancerName'),
  loadBalancerStatus?: string(name='LoadBalancerStatus'),
  masterZoneId?: string(name='MasterZoneId'),
  networkType?: string(name='NetworkType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serverId?: string(name='ServerId'),
  serverIntranetAddress?: string(name='ServerIntranetAddress'),
  slaveZoneId?: string(name='SlaveZoneId'),
  tags?: string(name='Tags'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model DescribeLoadBalancersResponseBody = {
  loadBalancers?: {
    loadBalancer?: [ 
    {
      address?: string(name='Address'),
      addressIPVersion?: string(name='AddressIPVersion'),
      addressType?: string(name='AddressType'),
      bandwidth?: int32(name='Bandwidth'),
      createTime?: string(name='CreateTime'),
      createTimeStamp?: long(name='CreateTimeStamp'),
      deleteProtection?: string(name='DeleteProtection'),
      instanceChargeType?: string(name='InstanceChargeType'),
      internetChargeType?: string(name='InternetChargeType'),
      internetChargeTypeAlias?: string(name='InternetChargeTypeAlias'),
      loadBalancerId?: string(name='LoadBalancerId'),
      loadBalancerName?: string(name='LoadBalancerName'),
      loadBalancerSpec?: string(name='LoadBalancerSpec'),
      loadBalancerStatus?: string(name='LoadBalancerStatus'),
      masterZoneId?: string(name='MasterZoneId'),
      modificationProtectionReason?: string(name='ModificationProtectionReason'),
      modificationProtectionStatus?: string(name='ModificationProtectionStatus'),
      networkType?: string(name='NetworkType'),
      payType?: string(name='PayType'),
      regionId?: string(name='RegionId'),
      regionIdAlias?: string(name='RegionIdAlias'),
      resourceGroupId?: string(name='ResourceGroupId'),
      slaveZoneId?: string(name='SlaveZoneId'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
    }
  ](name='LoadBalancer')
  }(name='LoadBalancers'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeLoadBalancersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLoadBalancersResponseBody(name='body'),
}

async function describeLoadBalancersWithOptions(request: DescribeLoadBalancersRequest, runtime: Util.RuntimeOptions): DescribeLoadBalancersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.addressIPVersion)) {
    query['AddressIPVersion'] = request.addressIPVersion;
  }
  if (!Util.isUnset(request.addressType)) {
    query['AddressType'] = request.addressType;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.loadBalancerName)) {
    query['LoadBalancerName'] = request.loadBalancerName;
  }
  if (!Util.isUnset(request.loadBalancerStatus)) {
    query['LoadBalancerStatus'] = request.loadBalancerStatus;
  }
  if (!Util.isUnset(request.masterZoneId)) {
    query['MasterZoneId'] = request.masterZoneId;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.serverId)) {
    query['ServerId'] = request.serverId;
  }
  if (!Util.isUnset(request.serverIntranetAddress)) {
    query['ServerIntranetAddress'] = request.serverIntranetAddress;
  }
  if (!Util.isUnset(request.slaveZoneId)) {
    query['SlaveZoneId'] = request.slaveZoneId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLoadBalancers',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLoadBalancers(request: DescribeLoadBalancersRequest): DescribeLoadBalancersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoadBalancersWithOptions(request, runtime);
}

model DescribeMasterSlaveServerGroupAttributeRequest {
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeMasterSlaveServerGroupAttributeResponseBody = {
  loadBalancerId?: string(name='LoadBalancerId'),
  masterSlaveBackendServers?: {
    masterSlaveBackendServer?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      serverType?: string(name='ServerType'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='MasterSlaveBackendServer')
  }(name='MasterSlaveBackendServers'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  masterSlaveServerGroupName?: string(name='MasterSlaveServerGroupName'),
  requestId?: string(name='RequestId'),
}

model DescribeMasterSlaveServerGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMasterSlaveServerGroupAttributeResponseBody(name='body'),
}

async function describeMasterSlaveServerGroupAttributeWithOptions(request: DescribeMasterSlaveServerGroupAttributeRequest, runtime: Util.RuntimeOptions): DescribeMasterSlaveServerGroupAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.masterSlaveServerGroupId)) {
    query['MasterSlaveServerGroupId'] = request.masterSlaveServerGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMasterSlaveServerGroupAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMasterSlaveServerGroupAttribute(request: DescribeMasterSlaveServerGroupAttributeRequest): DescribeMasterSlaveServerGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMasterSlaveServerGroupAttributeWithOptions(request, runtime);
}

model DescribeMasterSlaveServerGroupsRequest {
  includeListener?: boolean(name='IncludeListener'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeMasterSlaveServerGroupsResponseBody = {
  masterSlaveServerGroups?: {
    masterSlaveServerGroup?: [ 
    {
      associatedObjects?: {
        listeners?: {
          listener?: [ 
          {
            port?: int32(name='Port'),
            protocol?: string(name='Protocol'),
          }
        ](name='Listener')
        }(name='Listeners'),
      }(name='AssociatedObjects'),
      masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
      masterSlaveServerGroupName?: string(name='MasterSlaveServerGroupName'),
    }
  ](name='MasterSlaveServerGroup')
  }(name='MasterSlaveServerGroups'),
  requestId?: string(name='RequestId'),
}

model DescribeMasterSlaveServerGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMasterSlaveServerGroupsResponseBody(name='body'),
}

async function describeMasterSlaveServerGroupsWithOptions(request: DescribeMasterSlaveServerGroupsRequest, runtime: Util.RuntimeOptions): DescribeMasterSlaveServerGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.includeListener)) {
    query['IncludeListener'] = request.includeListener;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMasterSlaveServerGroups',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMasterSlaveServerGroups(request: DescribeMasterSlaveServerGroupsRequest): DescribeMasterSlaveServerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMasterSlaveServerGroupsWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeRuleAttributeRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleId?: string(name='RuleId'),
}

model DescribeRuleAttributeResponseBody = {
  cookie?: string(name='Cookie'),
  cookieTimeout?: int32(name='CookieTimeout'),
  domain?: string(name='Domain'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  listenerPort?: string(name='ListenerPort'),
  listenerSync?: string(name='ListenerSync'),
  loadBalancerId?: string(name='LoadBalancerId'),
  requestId?: string(name='RequestId'),
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  scheduler?: string(name='Scheduler'),
  stickySession?: string(name='StickySession'),
  stickySessionType?: string(name='StickySessionType'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  url?: string(name='Url'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model DescribeRuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRuleAttributeResponseBody(name='body'),
}

async function describeRuleAttributeWithOptions(request: DescribeRuleAttributeRequest, runtime: Util.RuntimeOptions): DescribeRuleAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRuleAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRuleAttribute(request: DescribeRuleAttributeRequest): DescribeRuleAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRuleAttributeWithOptions(request, runtime);
}

model DescribeRulesRequest {
  listenerPort?: int32(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeRulesResponseBody = {
  requestId?: string(name='RequestId'),
  rules?: {
    rule?: [ 
    {
      cookie?: string(name='Cookie'),
      cookieTimeout?: int32(name='CookieTimeout'),
      domain?: string(name='Domain'),
      healthCheck?: string(name='HealthCheck'),
      healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
      healthCheckDomain?: string(name='HealthCheckDomain'),
      healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
      healthCheckInterval?: int32(name='HealthCheckInterval'),
      healthCheckTimeout?: int32(name='HealthCheckTimeout'),
      healthCheckURI?: string(name='HealthCheckURI'),
      healthyThreshold?: int32(name='HealthyThreshold'),
      listenerSync?: string(name='ListenerSync'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      scheduler?: string(name='Scheduler'),
      stickySession?: string(name='StickySession'),
      stickySessionType?: string(name='StickySessionType'),
      unhealthyThreshold?: int32(name='UnhealthyThreshold'),
      url?: string(name='Url'),
      VServerGroupId?: string(name='VServerGroupId'),
    }
  ](name='Rule')
  }(name='Rules'),
}

model DescribeRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRulesResponseBody(name='body'),
}

async function describeRulesWithOptions(request: DescribeRulesRequest, runtime: Util.RuntimeOptions): DescribeRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRules',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRules(request: DescribeRulesRequest): DescribeRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRulesWithOptions(request, runtime);
}

model DescribeServerCertificatesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serverCertificateId?: string(name='ServerCertificateId'),
}

model DescribeServerCertificatesResponseBody = {
  requestId?: string(name='RequestId'),
  serverCertificates?: {
    serverCertificate?: [ 
    {
      aliCloudCertificateId?: string(name='AliCloudCertificateId'),
      aliCloudCertificateName?: string(name='AliCloudCertificateName'),
      commonName?: string(name='CommonName'),
      createTime?: string(name='CreateTime'),
      createTimeStamp?: long(name='CreateTimeStamp'),
      expireTime?: string(name='ExpireTime'),
      expireTimeStamp?: long(name='ExpireTimeStamp'),
      fingerprint?: string(name='Fingerprint'),
      isAliCloudCertificate?: int32(name='IsAliCloudCertificate'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      serverCertificateId?: string(name='ServerCertificateId'),
      serverCertificateName?: string(name='ServerCertificateName'),
      subjectAlternativeNames?: {
        subjectAlternativeName?: [ string ](name='SubjectAlternativeName')
      }(name='SubjectAlternativeNames'),
    }
  ](name='ServerCertificate')
  }(name='ServerCertificates'),
}

model DescribeServerCertificatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServerCertificatesResponseBody(name='body'),
}

async function describeServerCertificatesWithOptions(request: DescribeServerCertificatesRequest, runtime: Util.RuntimeOptions): DescribeServerCertificatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.serverCertificateId)) {
    query['ServerCertificateId'] = request.serverCertificateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServerCertificates',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServerCertificates(request: DescribeServerCertificatesRequest): DescribeServerCertificatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServerCertificatesWithOptions(request, runtime);
}

model DescribeTagsRequest {
  distinctKey?: boolean(name='DistinctKey'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tags?: string(name='Tags'),
}

model DescribeTagsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  tagSets?: {
    tagSet?: [ 
    {
      instanceCount?: int32(name='InstanceCount'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagSet')
  }(name='TagSets'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTagsResponseBody(name='body'),
}

async function describeTagsWithOptions(request: DescribeTagsRequest, runtime: Util.RuntimeOptions): DescribeTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.distinctKey)) {
    query['DistinctKey'] = request.distinctKey;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTags',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTags(request: DescribeTagsRequest): DescribeTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagsWithOptions(request, runtime);
}

model DescribeVServerGroupAttributeRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model DescribeVServerGroupAttributeResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
  requestId?: string(name='RequestId'),
  VServerGroupId?: string(name='VServerGroupId'),
  VServerGroupName?: string(name='VServerGroupName'),
}

model DescribeVServerGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVServerGroupAttributeResponseBody(name='body'),
}

async function describeVServerGroupAttributeWithOptions(request: DescribeVServerGroupAttributeRequest, runtime: Util.RuntimeOptions): DescribeVServerGroupAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVServerGroupAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVServerGroupAttribute(request: DescribeVServerGroupAttributeRequest): DescribeVServerGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVServerGroupAttributeWithOptions(request, runtime);
}

model DescribeVServerGroupsRequest {
  includeListener?: boolean(name='IncludeListener'),
  includeRule?: boolean(name='IncludeRule'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeVServerGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  VServerGroups?: {
    VServerGroup?: [ 
    {
      associatedObjects?: {
        listeners?: {
          listener?: [ 
          {
            port?: int32(name='Port'),
            protocol?: string(name='Protocol'),
          }
        ](name='Listener')
        }(name='Listeners'),
        rules?: {
          rule?: [ 
          {
            domain?: string(name='Domain'),
            ruleId?: string(name='RuleId'),
            ruleName?: string(name='RuleName'),
            url?: string(name='Url'),
          }
        ](name='Rule')
        }(name='Rules'),
      }(name='AssociatedObjects'),
      serverCount?: long(name='ServerCount'),
      VServerGroupId?: string(name='VServerGroupId'),
      VServerGroupName?: string(name='VServerGroupName'),
    }
  ](name='VServerGroup')
  }(name='VServerGroups'),
}

model DescribeVServerGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVServerGroupsResponseBody(name='body'),
}

async function describeVServerGroupsWithOptions(request: DescribeVServerGroupsRequest, runtime: Util.RuntimeOptions): DescribeVServerGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.includeListener)) {
    query['IncludeListener'] = request.includeListener;
  }
  if (!Util.isUnset(request.includeRule)) {
    query['IncludeRule'] = request.includeRule;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVServerGroups',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVServerGroups(request: DescribeVServerGroupsRequest): DescribeVServerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVServerGroupsWithOptions(request, runtime);
}

model DescribeZonesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: {
    zone?: [ 
    {
      localName?: string(name='LocalName'),
      slaveZones?: {
        slaveZone?: [ 
        {
          localName?: string(name='LocalName'),
          zoneId?: string(name='ZoneId'),
        }
      ](name='SlaveZone')
      }(name='SlaveZones'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Zone')
  }(name='Zones'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeZonesResponseBody(name='body'),
}

async function describeZonesWithOptions(request: DescribeZonesRequest, runtime: Util.RuntimeOptions): DescribeZonesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeZones',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeZonesWithOptions(request, runtime);
}

model ListTLSCipherPoliciesRequest {
  includeListener?: boolean(name='IncludeListener'),
  maxItems?: int32(name='MaxItems'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  TLSCipherPolicyId?: string(name='TLSCipherPolicyId'),
}

model ListTLSCipherPoliciesResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  TLSCipherPolicies?: [ 
    {
      ciphers?: [ string ](name='Ciphers'),
      createTime?: long(name='CreateTime'),
      instanceId?: string(name='InstanceId'),
      name?: string(name='Name'),
      relateListeners?: [ 
        {
          loadBalancerId?: string(name='LoadBalancerId'),
          port?: int32(name='Port'),
          protocol?: string(name='Protocol'),
        }
      ](name='RelateListeners'),
      status?: string(name='Status'),
      TLSVersions?: [ string ](name='TLSVersions'),
    }
  ](name='TLSCipherPolicies'),
  totalCount?: int32(name='TotalCount'),
}

model ListTLSCipherPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTLSCipherPoliciesResponseBody(name='body'),
}

async function listTLSCipherPoliciesWithOptions(request: ListTLSCipherPoliciesRequest, runtime: Util.RuntimeOptions): ListTLSCipherPoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.includeListener)) {
    query['IncludeListener'] = request.includeListener;
  }
  if (!Util.isUnset(request.maxItems)) {
    query['MaxItems'] = request.maxItems;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.TLSCipherPolicyId)) {
    query['TLSCipherPolicyId'] = request.TLSCipherPolicyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTLSCipherPolicies',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTLSCipherPolicies(request: ListTLSCipherPoliciesRequest): ListTLSCipherPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTLSCipherPoliciesWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ModifyLoadBalancerInstanceChargeTypeRequest {
  bandwidth?: int32(name='Bandwidth'),
  instanceChargeType?: string(name='InstanceChargeType'),
  internetChargeType?: string(name='InternetChargeType'),
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerSpec?: string(name='LoadBalancerSpec'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyLoadBalancerInstanceChargeTypeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyLoadBalancerInstanceChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyLoadBalancerInstanceChargeTypeResponseBody(name='body'),
}

async function modifyLoadBalancerInstanceChargeTypeWithOptions(request: ModifyLoadBalancerInstanceChargeTypeRequest, runtime: Util.RuntimeOptions): ModifyLoadBalancerInstanceChargeTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query['InstanceChargeType'] = request.instanceChargeType;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.loadBalancerSpec)) {
    query['LoadBalancerSpec'] = request.loadBalancerSpec;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyLoadBalancerInstanceChargeType',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyLoadBalancerInstanceChargeType(request: ModifyLoadBalancerInstanceChargeTypeRequest): ModifyLoadBalancerInstanceChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLoadBalancerInstanceChargeTypeWithOptions(request, runtime);
}

model ModifyLoadBalancerInstanceSpecRequest {
  autoPay?: boolean(name='AutoPay'),
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerSpec?: string(name='LoadBalancerSpec'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyLoadBalancerInstanceSpecResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyLoadBalancerInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyLoadBalancerInstanceSpecResponseBody(name='body'),
}

async function modifyLoadBalancerInstanceSpecWithOptions(request: ModifyLoadBalancerInstanceSpecRequest, runtime: Util.RuntimeOptions): ModifyLoadBalancerInstanceSpecResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.loadBalancerSpec)) {
    query['LoadBalancerSpec'] = request.loadBalancerSpec;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyLoadBalancerInstanceSpec',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyLoadBalancerInstanceSpec(request: ModifyLoadBalancerInstanceSpecRequest): ModifyLoadBalancerInstanceSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLoadBalancerInstanceSpecWithOptions(request, runtime);
}

model ModifyLoadBalancerInternetSpecRequest {
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: int32(name='Bandwidth'),
  internetChargeType?: string(name='InternetChargeType'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyLoadBalancerInternetSpecResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyLoadBalancerInternetSpecResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyLoadBalancerInternetSpecResponseBody(name='body'),
}

async function modifyLoadBalancerInternetSpecWithOptions(request: ModifyLoadBalancerInternetSpecRequest, runtime: Util.RuntimeOptions): ModifyLoadBalancerInternetSpecResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyLoadBalancerInternetSpec',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyLoadBalancerInternetSpec(request: ModifyLoadBalancerInternetSpecRequest): ModifyLoadBalancerInternetSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLoadBalancerInternetSpecWithOptions(request, runtime);
}

model ModifyLoadBalancerPayTypeRequest {
  autoPay?: boolean(name='AutoPay'),
  duration?: int32(name='Duration'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyLoadBalancerPayTypeResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyLoadBalancerPayTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyLoadBalancerPayTypeResponseBody(name='body'),
}

async function modifyLoadBalancerPayTypeWithOptions(request: ModifyLoadBalancerPayTypeRequest, runtime: Util.RuntimeOptions): ModifyLoadBalancerPayTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyLoadBalancerPayType',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyLoadBalancerPayType(request: ModifyLoadBalancerPayTypeRequest): ModifyLoadBalancerPayTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLoadBalancerPayTypeWithOptions(request, runtime);
}

model ModifyVServerGroupBackendServersRequest {
  newBackendServers?: string(name='NewBackendServers'),
  oldBackendServers?: string(name='OldBackendServers'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model ModifyVServerGroupBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model ModifyVServerGroupBackendServersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVServerGroupBackendServersResponseBody(name='body'),
}

async function modifyVServerGroupBackendServersWithOptions(request: ModifyVServerGroupBackendServersRequest, runtime: Util.RuntimeOptions): ModifyVServerGroupBackendServersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newBackendServers)) {
    query['NewBackendServers'] = request.newBackendServers;
  }
  if (!Util.isUnset(request.oldBackendServers)) {
    query['OldBackendServers'] = request.oldBackendServers;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVServerGroupBackendServers',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVServerGroupBackendServers(request: ModifyVServerGroupBackendServersRequest): ModifyVServerGroupBackendServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVServerGroupBackendServersWithOptions(request, runtime);
}

model RemoveAccessControlListEntryRequest {
  aclEntrys?: string(name='AclEntrys'),
  aclId?: string(name='AclId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RemoveAccessControlListEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveAccessControlListEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveAccessControlListEntryResponseBody(name='body'),
}

async function removeAccessControlListEntryWithOptions(request: RemoveAccessControlListEntryRequest, runtime: Util.RuntimeOptions): RemoveAccessControlListEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclEntrys)) {
    query['AclEntrys'] = request.aclEntrys;
  }
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveAccessControlListEntry',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeAccessControlListEntry(request: RemoveAccessControlListEntryRequest): RemoveAccessControlListEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeAccessControlListEntryWithOptions(request, runtime);
}

model RemoveBackendServersRequest {
  backendServers?: string(name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RemoveBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
  requestId?: string(name='RequestId'),
}

model RemoveBackendServersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveBackendServersResponseBody(name='body'),
}

async function removeBackendServersWithOptions(request: RemoveBackendServersRequest, runtime: Util.RuntimeOptions): RemoveBackendServersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backendServers)) {
    query['BackendServers'] = request.backendServers;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveBackendServers',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeBackendServers(request: RemoveBackendServersRequest): RemoveBackendServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeBackendServersWithOptions(request, runtime);
}

model RemoveListenerWhiteListItemRequest {
  listenerPort?: int32(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceItems?: string(name='SourceItems'),
}

model RemoveListenerWhiteListItemResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveListenerWhiteListItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveListenerWhiteListItemResponseBody(name='body'),
}

async function removeListenerWhiteListItemWithOptions(request: RemoveListenerWhiteListItemRequest, runtime: Util.RuntimeOptions): RemoveListenerWhiteListItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceItems)) {
    query['SourceItems'] = request.sourceItems;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveListenerWhiteListItem',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeListenerWhiteListItem(request: RemoveListenerWhiteListItemRequest): RemoveListenerWhiteListItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeListenerWhiteListItemWithOptions(request, runtime);
}

model RemoveTagsRequest {
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tags?: string(name='Tags'),
}

model RemoveTagsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveTagsResponseBody(name='body'),
}

async function removeTagsWithOptions(request: RemoveTagsRequest, runtime: Util.RuntimeOptions): RemoveTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveTags',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeTags(request: RemoveTagsRequest): RemoveTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeTagsWithOptions(request, runtime);
}

model RemoveVServerGroupBackendServersRequest {
  backendServers?: string(name='BackendServers'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model RemoveVServerGroupBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model RemoveVServerGroupBackendServersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveVServerGroupBackendServersResponseBody(name='body'),
}

async function removeVServerGroupBackendServersWithOptions(request: RemoveVServerGroupBackendServersRequest, runtime: Util.RuntimeOptions): RemoveVServerGroupBackendServersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backendServers)) {
    query['BackendServers'] = request.backendServers;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveVServerGroupBackendServers',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeVServerGroupBackendServers(request: RemoveVServerGroupBackendServersRequest): RemoveVServerGroupBackendServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeVServerGroupBackendServersWithOptions(request, runtime);
}

model SetAccessControlListAttributeRequest {
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SetAccessControlListAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetAccessControlListAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetAccessControlListAttributeResponseBody(name='body'),
}

async function setAccessControlListAttributeWithOptions(request: SetAccessControlListAttributeRequest, runtime: Util.RuntimeOptions): SetAccessControlListAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.aclName)) {
    query['AclName'] = request.aclName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetAccessControlListAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setAccessControlListAttribute(request: SetAccessControlListAttributeRequest): SetAccessControlListAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setAccessControlListAttributeWithOptions(request, runtime);
}

model SetBackendServersRequest {
  backendServers?: string(name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SetBackendServersResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: string(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  loadBalancerId?: string(name='LoadBalancerId'),
  requestId?: string(name='RequestId'),
}

model SetBackendServersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetBackendServersResponseBody(name='body'),
}

async function setBackendServersWithOptions(request: SetBackendServersRequest, runtime: Util.RuntimeOptions): SetBackendServersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backendServers)) {
    query['BackendServers'] = request.backendServers;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetBackendServers',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setBackendServers(request: SetBackendServersRequest): SetBackendServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return setBackendServersWithOptions(request, runtime);
}

model SetCACertificateNameRequest {
  CACertificateId?: string(name='CACertificateId'),
  CACertificateName?: string(name='CACertificateName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SetCACertificateNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetCACertificateNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetCACertificateNameResponseBody(name='body'),
}

async function setCACertificateNameWithOptions(request: SetCACertificateNameRequest, runtime: Util.RuntimeOptions): SetCACertificateNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.CACertificateId)) {
    query['CACertificateId'] = request.CACertificateId;
  }
  if (!Util.isUnset(request.CACertificateName)) {
    query['CACertificateName'] = request.CACertificateName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetCACertificateName',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setCACertificateName(request: SetCACertificateNameRequest): SetCACertificateNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return setCACertificateNameWithOptions(request, runtime);
}

model SetDomainExtensionAttributeRequest {
  domainExtensionId?: string(name='DomainExtensionId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serverCertificateId?: string(name='ServerCertificateId'),
}

model SetDomainExtensionAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetDomainExtensionAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDomainExtensionAttributeResponseBody(name='body'),
}

async function setDomainExtensionAttributeWithOptions(request: SetDomainExtensionAttributeRequest, runtime: Util.RuntimeOptions): SetDomainExtensionAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainExtensionId)) {
    query['DomainExtensionId'] = request.domainExtensionId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.serverCertificateId)) {
    query['ServerCertificateId'] = request.serverCertificateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDomainExtensionAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDomainExtensionAttribute(request: SetDomainExtensionAttributeRequest): SetDomainExtensionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDomainExtensionAttributeWithOptions(request, runtime);
}

model SetListenerAccessControlStatusRequest {
  accessControlStatus?: string(name='AccessControlStatus'),
  listenerPort?: int32(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SetListenerAccessControlStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetListenerAccessControlStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetListenerAccessControlStatusResponseBody(name='body'),
}

async function setListenerAccessControlStatusWithOptions(request: SetListenerAccessControlStatusRequest, runtime: Util.RuntimeOptions): SetListenerAccessControlStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessControlStatus)) {
    query['AccessControlStatus'] = request.accessControlStatus;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetListenerAccessControlStatus',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setListenerAccessControlStatus(request: SetListenerAccessControlStatusRequest): SetListenerAccessControlStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setListenerAccessControlStatusWithOptions(request, runtime);
}

model SetLoadBalancerDeleteProtectionRequest {
  deleteProtection?: string(name='DeleteProtection'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SetLoadBalancerDeleteProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerDeleteProtectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetLoadBalancerDeleteProtectionResponseBody(name='body'),
}

async function setLoadBalancerDeleteProtectionWithOptions(request: SetLoadBalancerDeleteProtectionRequest, runtime: Util.RuntimeOptions): SetLoadBalancerDeleteProtectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deleteProtection)) {
    query['DeleteProtection'] = request.deleteProtection;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetLoadBalancerDeleteProtection',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setLoadBalancerDeleteProtection(request: SetLoadBalancerDeleteProtectionRequest): SetLoadBalancerDeleteProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerDeleteProtectionWithOptions(request, runtime);
}

model SetLoadBalancerHTTPListenerAttributeRequest {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  bandwidth?: int32(name='Bandwidth'),
  cookie?: string(name='Cookie'),
  cookieTimeout?: int32(name='CookieTimeout'),
  description?: string(name='Description'),
  gzip?: string(name='Gzip'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  idleTimeout?: int32(name='IdleTimeout'),
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  requestTimeout?: int32(name='RequestTimeout'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scheduler?: string(name='Scheduler'),
  stickySession?: string(name='StickySession'),
  stickySessionType?: string(name='StickySessionType'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  VServerGroup?: string(name='VServerGroup'),
  VServerGroupId?: string(name='VServerGroupId'),
  XForwardedFor?: string(name='XForwardedFor'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto'),
}

model SetLoadBalancerHTTPListenerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerHTTPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetLoadBalancerHTTPListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerHTTPListenerAttributeWithOptions(request: SetLoadBalancerHTTPListenerAttributeRequest, runtime: Util.RuntimeOptions): SetLoadBalancerHTTPListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.aclStatus)) {
    query['AclStatus'] = request.aclStatus;
  }
  if (!Util.isUnset(request.aclType)) {
    query['AclType'] = request.aclType;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.cookie)) {
    query['Cookie'] = request.cookie;
  }
  if (!Util.isUnset(request.cookieTimeout)) {
    query['CookieTimeout'] = request.cookieTimeout;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.gzip)) {
    query['Gzip'] = request.gzip;
  }
  if (!Util.isUnset(request.healthCheck)) {
    query['HealthCheck'] = request.healthCheck;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckDomain)) {
    query['HealthCheckDomain'] = request.healthCheckDomain;
  }
  if (!Util.isUnset(request.healthCheckHttpCode)) {
    query['HealthCheckHttpCode'] = request.healthCheckHttpCode;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckMethod)) {
    query['HealthCheckMethod'] = request.healthCheckMethod;
  }
  if (!Util.isUnset(request.healthCheckTimeout)) {
    query['HealthCheckTimeout'] = request.healthCheckTimeout;
  }
  if (!Util.isUnset(request.healthCheckURI)) {
    query['HealthCheckURI'] = request.healthCheckURI;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.idleTimeout)) {
    query['IdleTimeout'] = request.idleTimeout;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestTimeout)) {
    query['RequestTimeout'] = request.requestTimeout;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.stickySession)) {
    query['StickySession'] = request.stickySession;
  }
  if (!Util.isUnset(request.stickySessionType)) {
    query['StickySessionType'] = request.stickySessionType;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  if (!Util.isUnset(request.VServerGroup)) {
    query['VServerGroup'] = request.VServerGroup;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }
  if (!Util.isUnset(request.XForwardedFor)) {
    query['XForwardedFor'] = request.XForwardedFor;
  }
  if (!Util.isUnset(request.XForwardedFor_SLBID)) {
    query['XForwardedFor_SLBID'] = request.XForwardedFor_SLBID;
  }
  if (!Util.isUnset(request.XForwardedFor_SLBIP)) {
    query['XForwardedFor_SLBIP'] = request.XForwardedFor_SLBIP;
  }
  if (!Util.isUnset(request.XForwardedFor_proto)) {
    query['XForwardedFor_proto'] = request.XForwardedFor_proto;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetLoadBalancerHTTPListenerAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setLoadBalancerHTTPListenerAttribute(request: SetLoadBalancerHTTPListenerAttributeRequest): SetLoadBalancerHTTPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerHTTPListenerAttributeWithOptions(request, runtime);
}

model SetLoadBalancerHTTPSListenerAttributeRequest {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  bandwidth?: int32(name='Bandwidth'),
  CACertificateId?: string(name='CACertificateId'),
  cookie?: string(name='Cookie'),
  cookieTimeout?: int32(name='CookieTimeout'),
  description?: string(name='Description'),
  enableHttp2?: string(name='EnableHttp2'),
  gzip?: string(name='Gzip'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  idleTimeout?: int32(name='IdleTimeout'),
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  requestTimeout?: int32(name='RequestTimeout'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scheduler?: string(name='Scheduler'),
  serverCertificateId?: string(name='ServerCertificateId'),
  stickySession?: string(name='StickySession'),
  stickySessionType?: string(name='StickySessionType'),
  TLSCipherPolicy?: string(name='TLSCipherPolicy'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  VServerGroup?: string(name='VServerGroup'),
  VServerGroupId?: string(name='VServerGroupId'),
  XForwardedFor?: string(name='XForwardedFor'),
  XForwardedFor_SLBID?: string(name='XForwardedFor_SLBID'),
  XForwardedFor_SLBIP?: string(name='XForwardedFor_SLBIP'),
  XForwardedFor_proto?: string(name='XForwardedFor_proto'),
}

model SetLoadBalancerHTTPSListenerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerHTTPSListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetLoadBalancerHTTPSListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerHTTPSListenerAttributeWithOptions(request: SetLoadBalancerHTTPSListenerAttributeRequest, runtime: Util.RuntimeOptions): SetLoadBalancerHTTPSListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.aclStatus)) {
    query['AclStatus'] = request.aclStatus;
  }
  if (!Util.isUnset(request.aclType)) {
    query['AclType'] = request.aclType;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.CACertificateId)) {
    query['CACertificateId'] = request.CACertificateId;
  }
  if (!Util.isUnset(request.cookie)) {
    query['Cookie'] = request.cookie;
  }
  if (!Util.isUnset(request.cookieTimeout)) {
    query['CookieTimeout'] = request.cookieTimeout;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.enableHttp2)) {
    query['EnableHttp2'] = request.enableHttp2;
  }
  if (!Util.isUnset(request.gzip)) {
    query['Gzip'] = request.gzip;
  }
  if (!Util.isUnset(request.healthCheck)) {
    query['HealthCheck'] = request.healthCheck;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckDomain)) {
    query['HealthCheckDomain'] = request.healthCheckDomain;
  }
  if (!Util.isUnset(request.healthCheckHttpCode)) {
    query['HealthCheckHttpCode'] = request.healthCheckHttpCode;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckMethod)) {
    query['HealthCheckMethod'] = request.healthCheckMethod;
  }
  if (!Util.isUnset(request.healthCheckTimeout)) {
    query['HealthCheckTimeout'] = request.healthCheckTimeout;
  }
  if (!Util.isUnset(request.healthCheckURI)) {
    query['HealthCheckURI'] = request.healthCheckURI;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.idleTimeout)) {
    query['IdleTimeout'] = request.idleTimeout;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestTimeout)) {
    query['RequestTimeout'] = request.requestTimeout;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.serverCertificateId)) {
    query['ServerCertificateId'] = request.serverCertificateId;
  }
  if (!Util.isUnset(request.stickySession)) {
    query['StickySession'] = request.stickySession;
  }
  if (!Util.isUnset(request.stickySessionType)) {
    query['StickySessionType'] = request.stickySessionType;
  }
  if (!Util.isUnset(request.TLSCipherPolicy)) {
    query['TLSCipherPolicy'] = request.TLSCipherPolicy;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  if (!Util.isUnset(request.VServerGroup)) {
    query['VServerGroup'] = request.VServerGroup;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }
  if (!Util.isUnset(request.XForwardedFor)) {
    query['XForwardedFor'] = request.XForwardedFor;
  }
  if (!Util.isUnset(request.XForwardedFor_SLBID)) {
    query['XForwardedFor_SLBID'] = request.XForwardedFor_SLBID;
  }
  if (!Util.isUnset(request.XForwardedFor_SLBIP)) {
    query['XForwardedFor_SLBIP'] = request.XForwardedFor_SLBIP;
  }
  if (!Util.isUnset(request.XForwardedFor_proto)) {
    query['XForwardedFor_proto'] = request.XForwardedFor_proto;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetLoadBalancerHTTPSListenerAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setLoadBalancerHTTPSListenerAttribute(request: SetLoadBalancerHTTPSListenerAttributeRequest): SetLoadBalancerHTTPSListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerHTTPSListenerAttributeWithOptions(request, runtime);
}

model SetLoadBalancerModificationProtectionRequest {
  loadBalancerId?: string(name='LoadBalancerId'),
  modificationProtectionReason?: string(name='ModificationProtectionReason'),
  modificationProtectionStatus?: string(name='ModificationProtectionStatus'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SetLoadBalancerModificationProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerModificationProtectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetLoadBalancerModificationProtectionResponseBody(name='body'),
}

async function setLoadBalancerModificationProtectionWithOptions(request: SetLoadBalancerModificationProtectionRequest, runtime: Util.RuntimeOptions): SetLoadBalancerModificationProtectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.modificationProtectionReason)) {
    query['ModificationProtectionReason'] = request.modificationProtectionReason;
  }
  if (!Util.isUnset(request.modificationProtectionStatus)) {
    query['ModificationProtectionStatus'] = request.modificationProtectionStatus;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetLoadBalancerModificationProtection',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setLoadBalancerModificationProtection(request: SetLoadBalancerModificationProtectionRequest): SetLoadBalancerModificationProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerModificationProtectionWithOptions(request, runtime);
}

model SetLoadBalancerNameRequest {
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerName?: string(name='LoadBalancerName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SetLoadBalancerNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetLoadBalancerNameResponseBody(name='body'),
}

async function setLoadBalancerNameWithOptions(request: SetLoadBalancerNameRequest, runtime: Util.RuntimeOptions): SetLoadBalancerNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.loadBalancerName)) {
    query['LoadBalancerName'] = request.loadBalancerName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetLoadBalancerName',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setLoadBalancerName(request: SetLoadBalancerNameRequest): SetLoadBalancerNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerNameWithOptions(request, runtime);
}

model SetLoadBalancerStatusRequest {
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerStatus?: string(name='LoadBalancerStatus'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SetLoadBalancerStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetLoadBalancerStatusResponseBody(name='body'),
}

async function setLoadBalancerStatusWithOptions(request: SetLoadBalancerStatusRequest, runtime: Util.RuntimeOptions): SetLoadBalancerStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.loadBalancerStatus)) {
    query['LoadBalancerStatus'] = request.loadBalancerStatus;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetLoadBalancerStatus',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setLoadBalancerStatus(request: SetLoadBalancerStatusRequest): SetLoadBalancerStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerStatusWithOptions(request, runtime);
}

model SetLoadBalancerTCPListenerAttributeRequest {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  bandwidth?: int32(name='Bandwidth'),
  connectionDrain?: string(name='ConnectionDrain'),
  connectionDrainTimeout?: int32(name='ConnectionDrainTimeout'),
  description?: string(name='Description'),
  establishedTimeout?: int32(name='EstablishedTimeout'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckType?: string(name='HealthCheckType'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
  masterSlaveServerGroup?: string(name='MasterSlaveServerGroup'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  persistenceTimeout?: int32(name='PersistenceTimeout'),
  proxyProtocolV2Enabled?: boolean(name='ProxyProtocolV2Enabled'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scheduler?: string(name='Scheduler'),
  synProxy?: string(name='SynProxy'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  VServerGroup?: string(name='VServerGroup'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model SetLoadBalancerTCPListenerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerTCPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetLoadBalancerTCPListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerTCPListenerAttributeWithOptions(request: SetLoadBalancerTCPListenerAttributeRequest, runtime: Util.RuntimeOptions): SetLoadBalancerTCPListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.aclStatus)) {
    query['AclStatus'] = request.aclStatus;
  }
  if (!Util.isUnset(request.aclType)) {
    query['AclType'] = request.aclType;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.connectionDrain)) {
    query['ConnectionDrain'] = request.connectionDrain;
  }
  if (!Util.isUnset(request.connectionDrainTimeout)) {
    query['ConnectionDrainTimeout'] = request.connectionDrainTimeout;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.establishedTimeout)) {
    query['EstablishedTimeout'] = request.establishedTimeout;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckConnectTimeout)) {
    query['HealthCheckConnectTimeout'] = request.healthCheckConnectTimeout;
  }
  if (!Util.isUnset(request.healthCheckDomain)) {
    query['HealthCheckDomain'] = request.healthCheckDomain;
  }
  if (!Util.isUnset(request.healthCheckHttpCode)) {
    query['HealthCheckHttpCode'] = request.healthCheckHttpCode;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckType)) {
    query['HealthCheckType'] = request.healthCheckType;
  }
  if (!Util.isUnset(request.healthCheckURI)) {
    query['HealthCheckURI'] = request.healthCheckURI;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.masterSlaveServerGroup)) {
    query['MasterSlaveServerGroup'] = request.masterSlaveServerGroup;
  }
  if (!Util.isUnset(request.masterSlaveServerGroupId)) {
    query['MasterSlaveServerGroupId'] = request.masterSlaveServerGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.persistenceTimeout)) {
    query['PersistenceTimeout'] = request.persistenceTimeout;
  }
  if (!Util.isUnset(request.proxyProtocolV2Enabled)) {
    query['ProxyProtocolV2Enabled'] = request.proxyProtocolV2Enabled;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.synProxy)) {
    query['SynProxy'] = request.synProxy;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  if (!Util.isUnset(request.VServerGroup)) {
    query['VServerGroup'] = request.VServerGroup;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetLoadBalancerTCPListenerAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setLoadBalancerTCPListenerAttribute(request: SetLoadBalancerTCPListenerAttributeRequest): SetLoadBalancerTCPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerTCPListenerAttributeWithOptions(request, runtime);
}

model SetLoadBalancerUDPListenerAttributeRequest {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  bandwidth?: int32(name='Bandwidth'),
  description?: string(name='Description'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  listenerPort?: int32(name='ListenerPort'),
  loadBalancerId?: string(name='LoadBalancerId'),
  masterSlaveServerGroup?: string(name='MasterSlaveServerGroup'),
  masterSlaveServerGroupId?: string(name='MasterSlaveServerGroupId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  proxyProtocolV2Enabled?: boolean(name='ProxyProtocolV2Enabled'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scheduler?: string(name='Scheduler'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  VServerGroup?: string(name='VServerGroup'),
  VServerGroupId?: string(name='VServerGroupId'),
  healthCheckExp?: string(name='healthCheckExp'),
  healthCheckReq?: string(name='healthCheckReq'),
}

model SetLoadBalancerUDPListenerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetLoadBalancerUDPListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetLoadBalancerUDPListenerAttributeResponseBody(name='body'),
}

async function setLoadBalancerUDPListenerAttributeWithOptions(request: SetLoadBalancerUDPListenerAttributeRequest, runtime: Util.RuntimeOptions): SetLoadBalancerUDPListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.aclStatus)) {
    query['AclStatus'] = request.aclStatus;
  }
  if (!Util.isUnset(request.aclType)) {
    query['AclType'] = request.aclType;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckConnectTimeout)) {
    query['HealthCheckConnectTimeout'] = request.healthCheckConnectTimeout;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.masterSlaveServerGroup)) {
    query['MasterSlaveServerGroup'] = request.masterSlaveServerGroup;
  }
  if (!Util.isUnset(request.masterSlaveServerGroupId)) {
    query['MasterSlaveServerGroupId'] = request.masterSlaveServerGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.proxyProtocolV2Enabled)) {
    query['ProxyProtocolV2Enabled'] = request.proxyProtocolV2Enabled;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  if (!Util.isUnset(request.VServerGroup)) {
    query['VServerGroup'] = request.VServerGroup;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }
  if (!Util.isUnset(request.healthCheckExp)) {
    query['healthCheckExp'] = request.healthCheckExp;
  }
  if (!Util.isUnset(request.healthCheckReq)) {
    query['healthCheckReq'] = request.healthCheckReq;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetLoadBalancerUDPListenerAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setLoadBalancerUDPListenerAttribute(request: SetLoadBalancerUDPListenerAttributeRequest): SetLoadBalancerUDPListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setLoadBalancerUDPListenerAttributeWithOptions(request, runtime);
}

model SetRuleRequest {
  cookie?: string(name='Cookie'),
  cookieTimeout?: int32(name='CookieTimeout'),
  healthCheck?: string(name='HealthCheck'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckDomain?: string(name='HealthCheckDomain'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthCheckURI?: string(name='HealthCheckURI'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  listenerSync?: string(name='ListenerSync'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  scheduler?: string(name='Scheduler'),
  stickySession?: string(name='StickySession'),
  stickySessionType?: string(name='StickySessionType'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model SetRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetRuleResponseBody(name='body'),
}

async function setRuleWithOptions(request: SetRuleRequest, runtime: Util.RuntimeOptions): SetRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cookie)) {
    query['Cookie'] = request.cookie;
  }
  if (!Util.isUnset(request.cookieTimeout)) {
    query['CookieTimeout'] = request.cookieTimeout;
  }
  if (!Util.isUnset(request.healthCheck)) {
    query['HealthCheck'] = request.healthCheck;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckDomain)) {
    query['HealthCheckDomain'] = request.healthCheckDomain;
  }
  if (!Util.isUnset(request.healthCheckHttpCode)) {
    query['HealthCheckHttpCode'] = request.healthCheckHttpCode;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckTimeout)) {
    query['HealthCheckTimeout'] = request.healthCheckTimeout;
  }
  if (!Util.isUnset(request.healthCheckURI)) {
    query['HealthCheckURI'] = request.healthCheckURI;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.listenerSync)) {
    query['ListenerSync'] = request.listenerSync;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.stickySession)) {
    query['StickySession'] = request.stickySession;
  }
  if (!Util.isUnset(request.stickySessionType)) {
    query['StickySessionType'] = request.stickySessionType;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetRule',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setRule(request: SetRuleRequest): SetRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return setRuleWithOptions(request, runtime);
}

model SetServerCertificateNameRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serverCertificateId?: string(name='ServerCertificateId'),
  serverCertificateName?: string(name='ServerCertificateName'),
}

model SetServerCertificateNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetServerCertificateNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetServerCertificateNameResponseBody(name='body'),
}

async function setServerCertificateNameWithOptions(request: SetServerCertificateNameRequest, runtime: Util.RuntimeOptions): SetServerCertificateNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.serverCertificateId)) {
    query['ServerCertificateId'] = request.serverCertificateId;
  }
  if (!Util.isUnset(request.serverCertificateName)) {
    query['ServerCertificateName'] = request.serverCertificateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetServerCertificateName',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setServerCertificateName(request: SetServerCertificateNameRequest): SetServerCertificateNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return setServerCertificateNameWithOptions(request, runtime);
}

model SetTLSCipherPolicyAttributeRequest {
  ciphers?: [ string ](name='Ciphers'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  TLSCipherPolicyId?: string(name='TLSCipherPolicyId'),
  TLSVersions?: [ string ](name='TLSVersions'),
}

model SetTLSCipherPolicyAttributeResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model SetTLSCipherPolicyAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetTLSCipherPolicyAttributeResponseBody(name='body'),
}

async function setTLSCipherPolicyAttributeWithOptions(request: SetTLSCipherPolicyAttributeRequest, runtime: Util.RuntimeOptions): SetTLSCipherPolicyAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ciphers)) {
    query['Ciphers'] = request.ciphers;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.TLSCipherPolicyId)) {
    query['TLSCipherPolicyId'] = request.TLSCipherPolicyId;
  }
  if (!Util.isUnset(request.TLSVersions)) {
    query['TLSVersions'] = request.TLSVersions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetTLSCipherPolicyAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setTLSCipherPolicyAttribute(request: SetTLSCipherPolicyAttributeRequest): SetTLSCipherPolicyAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setTLSCipherPolicyAttributeWithOptions(request, runtime);
}

model SetVServerGroupAttributeRequest {
  backendServers?: string(name='BackendServers'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VServerGroupId?: string(name='VServerGroupId'),
  VServerGroupName?: string(name='VServerGroupName'),
}

model SetVServerGroupAttributeResponseBody = {
  backendServers?: {
    backendServer?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='BackendServer')
  }(name='BackendServers'),
  requestId?: string(name='RequestId'),
  VServerGroupId?: string(name='VServerGroupId'),
  VServerGroupName?: string(name='VServerGroupName'),
}

model SetVServerGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetVServerGroupAttributeResponseBody(name='body'),
}

async function setVServerGroupAttributeWithOptions(request: SetVServerGroupAttributeRequest, runtime: Util.RuntimeOptions): SetVServerGroupAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backendServers)) {
    query['BackendServers'] = request.backendServers;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }
  if (!Util.isUnset(request.VServerGroupName)) {
    query['VServerGroupName'] = request.VServerGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetVServerGroupAttribute',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setVServerGroupAttribute(request: SetVServerGroupAttributeRequest): SetVServerGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setVServerGroupAttributeWithOptions(request, runtime);
}

model StartLoadBalancerListenerRequest {
  listenerPort?: int32(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model StartLoadBalancerListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartLoadBalancerListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartLoadBalancerListenerResponseBody(name='body'),
}

async function startLoadBalancerListenerWithOptions(request: StartLoadBalancerListenerRequest, runtime: Util.RuntimeOptions): StartLoadBalancerListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartLoadBalancerListener',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startLoadBalancerListener(request: StartLoadBalancerListenerRequest): StartLoadBalancerListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return startLoadBalancerListenerWithOptions(request, runtime);
}

model StopLoadBalancerListenerRequest {
  listenerPort?: int32(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  loadBalancerId?: string(name='LoadBalancerId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model StopLoadBalancerListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopLoadBalancerListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopLoadBalancerListenerResponseBody(name='body'),
}

async function stopLoadBalancerListenerWithOptions(request: StopLoadBalancerListenerRequest, runtime: Util.RuntimeOptions): StopLoadBalancerListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopLoadBalancerListener',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopLoadBalancerListener(request: StopLoadBalancerListenerRequest): StopLoadBalancerListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopLoadBalancerListenerWithOptions(request, runtime);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UploadCACertificateRequest {
  CACertificate?: string(name='CACertificate'),
  CACertificateName?: string(name='CACertificateName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UploadCACertificateResponseBody = {
  CACertificateId?: string(name='CACertificateId'),
  CACertificateName?: string(name='CACertificateName'),
  commonName?: string(name='CommonName'),
  createTime?: string(name='CreateTime'),
  createTimeStamp?: long(name='CreateTimeStamp'),
  expireTime?: string(name='ExpireTime'),
  expireTimeStamp?: long(name='ExpireTimeStamp'),
  fingerprint?: string(name='Fingerprint'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model UploadCACertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadCACertificateResponseBody(name='body'),
}

async function uploadCACertificateWithOptions(request: UploadCACertificateRequest, runtime: Util.RuntimeOptions): UploadCACertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.CACertificate)) {
    query['CACertificate'] = request.CACertificate;
  }
  if (!Util.isUnset(request.CACertificateName)) {
    query['CACertificateName'] = request.CACertificateName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadCACertificate',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadCACertificate(request: UploadCACertificateRequest): UploadCACertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadCACertificateWithOptions(request, runtime);
}

model UploadServerCertificateRequest {
  aliCloudCertificateId?: string(name='AliCloudCertificateId'),
  aliCloudCertificateName?: string(name='AliCloudCertificateName'),
  aliCloudCertificateRegionId?: string(name='AliCloudCertificateRegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  privateKey?: string(name='PrivateKey'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serverCertificate?: string(name='ServerCertificate'),
  serverCertificateName?: string(name='ServerCertificateName'),
}

model UploadServerCertificateResponseBody = {
  aliCloudCertificateId?: string(name='AliCloudCertificateId'),
  aliCloudCertificateName?: string(name='AliCloudCertificateName'),
  commonName?: string(name='CommonName'),
  createTime?: string(name='CreateTime'),
  createTimeStamp?: long(name='CreateTimeStamp'),
  expireTime?: string(name='ExpireTime'),
  expireTimeStamp?: long(name='ExpireTimeStamp'),
  fingerprint?: string(name='Fingerprint'),
  isAliCloudCertificate?: int32(name='IsAliCloudCertificate'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  serverCertificateId?: string(name='ServerCertificateId'),
  serverCertificateName?: string(name='ServerCertificateName'),
  subjectAlternativeNames?: {
    subjectAlternativeName?: [ string ](name='SubjectAlternativeName')
  }(name='SubjectAlternativeNames'),
}

model UploadServerCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadServerCertificateResponseBody(name='body'),
}

async function uploadServerCertificateWithOptions(request: UploadServerCertificateRequest, runtime: Util.RuntimeOptions): UploadServerCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliCloudCertificateId)) {
    query['AliCloudCertificateId'] = request.aliCloudCertificateId;
  }
  if (!Util.isUnset(request.aliCloudCertificateName)) {
    query['AliCloudCertificateName'] = request.aliCloudCertificateName;
  }
  if (!Util.isUnset(request.aliCloudCertificateRegionId)) {
    query['AliCloudCertificateRegionId'] = request.aliCloudCertificateRegionId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.serverCertificate)) {
    query['ServerCertificate'] = request.serverCertificate;
  }
  if (!Util.isUnset(request.serverCertificateName)) {
    query['ServerCertificateName'] = request.serverCertificateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadServerCertificate',
    version = '2014-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadServerCertificate(request: UploadServerCertificateRequest): UploadServerCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadServerCertificateWithOptions(request, runtime);
}

