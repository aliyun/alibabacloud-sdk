/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('csp', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddAclAuthorizationRequest {
  aclOperation?: string(name='AclOperation'),
  clientToken?: string(name='ClientToken'),
  patternType?: string(name='PatternType'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
}

model AddAclAuthorizationResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddAclAuthorizationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddAclAuthorizationResponseBody(name='body'),
}

async function addAclAuthorizationWithOptions(request: AddAclAuthorizationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddAclAuthorizationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.aclOperation)) {
    query['AclOperation'] = request.aclOperation;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.patternType)) {
    query['PatternType'] = request.patternType;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddAclAuthorization',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/add_acl_authorization`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addAclAuthorization(request: AddAclAuthorizationRequest): AddAclAuthorizationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addAclAuthorizationWithOptions(request, headers, runtime);
}

model AddAuthenticatedUserRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  password?: string(name='Password'),
  userName?: string(name='UserName'),
}

model AddAuthenticatedUserResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddAuthenticatedUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddAuthenticatedUserResponseBody(name='body'),
}

async function addAuthenticatedUserWithOptions(request: AddAuthenticatedUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddAuthenticatedUserResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddAuthenticatedUser',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/add_user`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addAuthenticatedUser(request: AddAuthenticatedUserRequest): AddAuthenticatedUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addAuthenticatedUserWithOptions(request, headers, runtime);
}

model CheckClusterNameRequest {
  clusterName?: string(name='ClusterName'),
}

model CheckClusterNameResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckClusterNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckClusterNameResponseBody(name='body'),
}

async function checkClusterNameWithOptions(request: CheckClusterNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckClusterNameResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckClusterName',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/check/cluster_name`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkClusterName(request: CheckClusterNameRequest): CheckClusterNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkClusterNameWithOptions(request, headers, runtime);
}

model CheckInventoryRequest {
  clusterInfo?: string(name='ClusterInfo'),
}

model CheckInventoryResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckInventoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckInventoryResponseBody(name='body'),
}

async function checkInventoryWithOptions(request: CheckInventoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckInventoryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterInfo)) {
    query['ClusterInfo'] = request.clusterInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckInventory',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/check/inventory`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkInventory(request: CheckInventoryRequest): CheckInventoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkInventoryWithOptions(request, headers, runtime);
}

model CheckLeftCuRequest {
  cuNum?: int32(name='CuNum'),
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
}

model CheckLeftCuResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckLeftCuResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckLeftCuResponseBody(name='body'),
}

async function checkLeftCuWithOptions(request: CheckLeftCuRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckLeftCuResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.cuNum)) {
    query['CuNum'] = request.cuNum;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckLeftCu',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/check/cu`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkLeftCu(request: CheckLeftCuRequest): CheckLeftCuResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkLeftCuWithOptions(request, headers, runtime);
}

model CheckUserAccountResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckUserAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckUserAccountResponseBody(name='body'),
}

async function checkUserAccountWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): CheckUserAccountResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CheckUserAccount',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/check/user_account`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkUserAccount(): CheckUserAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkUserAccountWithOptions(headers, runtime);
}

model CheckUserResourceRequest {
  clusterInfo?: string(name='ClusterInfo'),
  type?: string(name='Type'),
}

model CheckUserResourceResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckUserResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckUserResourceResponseBody(name='body'),
}

async function checkUserResourceWithOptions(request: CheckUserResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckUserResourceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterInfo)) {
    query['ClusterInfo'] = request.clusterInfo;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckUserResource',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/check/user_resource`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkUserResource(request: CheckUserResourceRequest): CheckUserResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkUserResourceWithOptions(request, headers, runtime);
}

model CheckVpcRequest {
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
}

model CheckVpcResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckVpcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckVpcResponseBody(name='body'),
}

async function checkVpcWithOptions(request: CheckVpcRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckVpcResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckVpc',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/check/vpc`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkVpc(request: CheckVpcRequest): CheckVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkVpcWithOptions(request, headers, runtime);
}

model CheckVswitchRequest {
  regionId?: string(name='RegionId'),
  vSwitchIds?: string(name='VSwitchIds'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model CheckVswitchResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckVswitchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckVswitchResponseBody(name='body'),
}

async function checkVswitchWithOptions(request: CheckVswitchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckVswitchResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vSwitchIds)) {
    query['VSwitchIds'] = request.vSwitchIds;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckVswitch',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/check/vswitch`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkVswitch(request: CheckVswitchRequest): CheckVswitchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkVswitchWithOptions(request, headers, runtime);
}

model CreateClusterRequest {
  clientToken?: string(name='ClientToken'),
  clusterInfo?: string(name='ClusterInfo'),
}

model CreateClusterResponseBody = {
  data?: {
    beganOn?: long(name='BeganOn'),
    endOn?: long(name='EndOn'),
    orderId?: string(name='OrderId'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateClusterResponseBody(name='body'),
}

async function createClusterWithOptions(request: CreateClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterInfo)) {
    query['ClusterInfo'] = request.clusterInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCluster',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createClusterWithOptions(request, headers, runtime);
}

model CreateDefaultRoleRequest {
  clientToken?: string(name='ClientToken'),
}

model CreateDefaultRoleResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDefaultRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDefaultRoleResponseBody(name='body'),
}

async function createDefaultRoleWithOptions(request: CreateDefaultRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDefaultRoleResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDefaultRole',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/user/create_default_role`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDefaultRole(request: CreateDefaultRoleRequest): CreateDefaultRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDefaultRoleWithOptions(request, headers, runtime);
}

model CreateOrderRequest {
  clientToken?: string(name='ClientToken'),
  orderInfo?: string(name='OrderInfo'),
}

model CreateOrderResponseBody = {
  data?: {
    orderId?: long(name='OrderId'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrderResponseBody(name='body'),
}

async function createOrderWithOptions(request: CreateOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateOrderResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.orderInfo)) {
    query['OrderInfo'] = request.orderInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrder',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/order/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrder(request: CreateOrderRequest): CreateOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createOrderWithOptions(request, headers, runtime);
}

model DeleteAclAuthorizationRequest {
  aclOperation?: string(name='AclOperation'),
  instanceId?: string(name='InstanceId'),
  patternType?: string(name='PatternType'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
}

model DeleteAclAuthorizationResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteAclAuthorizationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAclAuthorizationResponseBody(name='body'),
}

async function deleteAclAuthorizationWithOptions(request: DeleteAclAuthorizationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAclAuthorizationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.aclOperation)) {
    query['AclOperation'] = request.aclOperation;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.patternType)) {
    query['PatternType'] = request.patternType;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAclAuthorization',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/delete_acl_authorization`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAclAuthorization(request: DeleteAclAuthorizationRequest): DeleteAclAuthorizationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAclAuthorizationWithOptions(request, headers, runtime);
}

model DeleteAuthenticatedUserRequest {
  instanceId?: string(name='InstanceId'),
  password?: string(name='Password'),
  userName?: string(name='UserName'),
}

model DeleteAuthenticatedUserResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteAuthenticatedUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAuthenticatedUserResponseBody(name='body'),
}

async function deleteAuthenticatedUserWithOptions(request: DeleteAuthenticatedUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAuthenticatedUserResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAuthenticatedUser',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/delete_user`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAuthenticatedUser(request: DeleteAuthenticatedUserRequest): DeleteAuthenticatedUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAuthenticatedUserWithOptions(request, headers, runtime);
}

model GetClusterDetailRequest {
  instanceId?: string(name='InstanceId'),
}

model GetClusterDetailResponseBody = {
  data?: {
    askClusterID?: string(name='AskClusterID'),
    autoRenew?: boolean(name='AutoRenew'),
    beginTime?: long(name='BeginTime'),
    clusterBizId?: string(name='ClusterBizId'),
    clusterId?: string(name='ClusterId'),
    clusterInfo?: {
      bucketName?: string(name='BucketName'),
      connectCpu?: int32(name='ConnectCpu'),
      connectEnabled?: boolean(name='ConnectEnabled'),
      connectReplica?: int32(name='ConnectReplica'),
      controlCenterCpu?: int32(name='ControlCenterCpu'),
      controlCenterDataStorageInteger?: int32(name='ControlCenterDataStorageInteger'),
      controlCenterEnabled?: boolean(name='ControlCenterEnabled'),
      controlCenterReplica?: int32(name='ControlCenterReplica'),
      kafkaCpu?: int32(name='KafkaCpu'),
      kafkaDataStorage?: string(name='KafkaDataStorage'),
      kafkaReplica?: int32(name='KafkaReplica'),
      kafkarestproxyEnabled?: boolean(name='KafkarestproxyEnabled'),
      ksqlCpu?: int32(name='KsqlCpu'),
      ksqlDataStorageInteger?: int32(name='KsqlDataStorageInteger'),
      ksqlEnabled?: boolean(name='KsqlEnabled'),
      ksqlReplica?: int32(name='KsqlReplica'),
      restProxyCpu?: int32(name='RestProxyCpu'),
      restProxyReplica?: int32(name='RestProxyReplica'),
      schemaregistryCpu?: int32(name='SchemaregistryCpu'),
      schemaregistryEnabled?: boolean(name='SchemaregistryEnabled'),
      schemaregistryReplica?: int32(name='SchemaregistryReplica'),
      zookeeperCpu?: int32(name='ZookeeperCpu'),
      zookeeperEnabled?: boolean(name='ZookeeperEnabled'),
      zookeeperReplica?: int32(name='ZookeeperReplica'),
      zookeeperStorageInteger?: int32(name='ZookeeperStorageInteger'),
    }(name='ClusterInfo'),
    clusterName?: string(name='ClusterName'),
    clusterStatus?: string(name='ClusterStatus'),
    clusterStatusValue?: int32(name='ClusterStatusValue'),
    connectorVisible?: boolean(name='ConnectorVisible'),
    controlCenterUrl?: string(name='ControlCenterUrl'),
    duration?: int32(name='Duration'),
    expireTime?: long(name='ExpireTime'),
    gmtCreate?: long(name='GmtCreate'),
    gmtModified?: long(name='GmtModified'),
    orderBizId?: string(name='OrderBizId'),
    packageType?: string(name='PackageType'),
    pricingCycle?: string(name='PricingCycle'),
    publicServerCert?: string(name='PublicServerCert'),
    regionId?: string(name='RegionId'),
    runningTime?: long(name='RunningTime'),
    serverCert?: string(name='ServerCert'),
    storageSize?: int32(name='StorageSize'),
    templateVersion?: string(name='TemplateVersion'),
    tieredStorageVisible?: boolean(name='TieredStorageVisible'),
    zoneId?: string(name='ZoneId'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model GetClusterDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClusterDetailResponseBody(name='body'),
}

async function getClusterDetailWithOptions(request: GetClusterDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetClusterDetailResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClusterDetail',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getClusterDetail(request: GetClusterDetailRequest): GetClusterDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getClusterDetailWithOptions(request, headers, runtime);
}

model GetConfigInfoResponseBody = {
  code?: string(name='Code'),
  data?: {
    productCode?: string(name='ProductCode'),
    specVersionInfos?: [ 
      {
        multiAZPermission?: boolean(name='MultiAZPermission'),
        packageType?: string(name='PackageType'),
        pricingInfos?: [ 
          {
            duration?: int32(name='Duration'),
            pricingCycle?: string(name='PricingCycle'),
          }
        ](name='PricingInfos'),
        specVersion?: string(name='SpecVersion'),
        specVersionEn?: string(name='SpecVersionEn'),
        visible?: boolean(name='Visible'),
      }
    ](name='SpecVersionInfos'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetConfigInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConfigInfoResponseBody(name='body'),
}

async function getConfigInfoWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetConfigInfoResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetConfigInfo',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/config_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConfigInfo(): GetConfigInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getConfigInfoWithOptions(headers, runtime);
}

model GetCspConnectorDeployedListRequest {
  instanceId?: string(name='InstanceId'),
}

model GetCspConnectorDeployedListResponseBody = {
  data?: [ 
    {
      componentTypes?: [ string ](name='ComponentTypes'),
      description?: string(name='Description'),
      hubUrl?: string(name='HubUrl'),
      lastModified?: long(name='LastModified'),
      logo?: string(name='Logo'),
      name?: string(name='Name'),
      owner?: {
        logo?: string(name='Logo'),
        name?: string(name='Name'),
        url?: string(name='Url'),
        userName?: string(name='UserName'),
      }(name='Owner'),
      title?: string(name='Title'),
      version?: string(name='Version'),
    }
  ](name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetCspConnectorDeployedListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCspConnectorDeployedListResponseBody(name='body'),
}

async function getCspConnectorDeployedListWithOptions(request: GetCspConnectorDeployedListRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCspConnectorDeployedListResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCspConnectorDeployedList',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/csp/connectors_deployed`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCspConnectorDeployedList(request: GetCspConnectorDeployedListRequest): GetCspConnectorDeployedListResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCspConnectorDeployedListWithOptions(request, headers, runtime);
}

model GetCspSpecificationInfoResponseBody = {
  data?: {
    configuration?: [ 
      {
        componentFormatName?: string(name='ComponentFormatName'),
        componentName?: string(name='ComponentName'),
        defaultCuNum?: int32(name='DefaultCuNum'),
        defaultReplica?: int32(name='DefaultReplica'),
        defaultStorage?: int32(name='DefaultStorage'),
        maxCuNum?: int32(name='MaxCuNum'),
        maxReplica?: int32(name='MaxReplica'),
        maxStorage?: int32(name='MaxStorage'),
        minCuNum?: int32(name='MinCuNum'),
        minReplica?: int32(name='MinReplica'),
        minStorage?: int32(name='MinStorage'),
        modifyEnabled?: boolean(name='ModifyEnabled'),
      }
    ](name='Configuration'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetCspSpecificationInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCspSpecificationInfoResponseBody(name='body'),
}

async function getCspSpecificationInfoWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetCspSpecificationInfoResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetCspSpecificationInfo',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/csp/specification_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCspSpecificationInfo(): GetCspSpecificationInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCspSpecificationInfoWithOptions(headers, runtime);
}

model GetCspUpgradeLimitInfoResponseBody = {
  data?: {
    connectorCpu?: int32(name='ConnectorCpu'),
    connectorModified?: boolean(name='ConnectorModified'),
    connectorReplica?: int32(name='ConnectorReplica'),
    controlCenterCpu?: int32(name='ControlCenterCpu'),
    controlCenterModified?: boolean(name='ControlCenterModified'),
    controlCenterReplica?: int32(name='ControlCenterReplica'),
    kafkaCpu?: int32(name='KafkaCpu'),
    kafkaDataStorage?: string(name='KafkaDataStorage'),
    kafkaDataStorageInteger?: int32(name='KafkaDataStorageInteger'),
    kafkaReplica?: int32(name='KafkaReplica'),
    ksqlCpu?: int32(name='KsqlCpu'),
    ksqlModified?: boolean(name='KsqlModified'),
    ksqlReplica?: int32(name='KsqlReplica'),
    restProxyCpu?: int32(name='RestProxyCpu'),
    restProxyModified?: boolean(name='RestProxyModified'),
    restProxyReplica?: int32(name='RestProxyReplica'),
    schemaregistryCpu?: int32(name='SchemaregistryCpu'),
    schemaregistryModified?: boolean(name='SchemaregistryModified'),
    schemaregistryReplica?: int32(name='SchemaregistryReplica'),
    zookeeperCpu?: int32(name='ZookeeperCpu'),
    zookeeperModified?: boolean(name='ZookeeperModified'),
    zookeeperReplica?: int32(name='ZookeeperReplica'),
  }(name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetCspUpgradeLimitInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCspUpgradeLimitInfoResponseBody(name='body'),
}

async function getCspUpgradeLimitInfoWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetCspUpgradeLimitInfoResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetCspUpgradeLimitInfo',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/csp/upgrade_limit`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCspUpgradeLimitInfo(): GetCspUpgradeLimitInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCspUpgradeLimitInfoWithOptions(headers, runtime);
}

model GetRenewSpecVersionInfoRequest {
  packageType?: string(name='PackageType'),
  regionId?: string(name='RegionId'),
}

model GetRenewSpecVersionInfoResponseBody = {
  data?: {
    multiAZPermission?: boolean(name='MultiAZPermission'),
    packageType?: string(name='PackageType'),
    pricingInfos?: [ 
      {
        duration?: int32(name='Duration'),
        pricingCycle?: string(name='PricingCycle'),
      }
    ](name='PricingInfos'),
    productCode?: string(name='ProductCode'),
    regionId?: string(name='RegionId'),
    specVersion?: string(name='SpecVersion'),
    specVersionEn?: string(name='SpecVersionEn'),
    visible?: boolean(name='Visible'),
  }(name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetRenewSpecVersionInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRenewSpecVersionInfoResponseBody(name='body'),
}

async function getRenewSpecVersionInfoWithOptions(request: GetRenewSpecVersionInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRenewSpecVersionInfoResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.packageType)) {
    query['PackageType'] = request.packageType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRenewSpecVersionInfo',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/renew_spec_version_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRenewSpecVersionInfo(request: GetRenewSpecVersionInfoRequest): GetRenewSpecVersionInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRenewSpecVersionInfoWithOptions(request, headers, runtime);
}

model GetSpecVersionInfoResponseBody = {
  data?: [ 
    {
      multiAZPermission?: boolean(name='MultiAZPermission'),
      packageType?: string(name='PackageType'),
      pricingInfos?: [ 
        {
          duration?: int32(name='Duration'),
          pricingCycle?: string(name='PricingCycle'),
        }
      ](name='PricingInfos'),
      productCode?: string(name='ProductCode'),
      regionId?: string(name='RegionId'),
      specVersion?: string(name='SpecVersion'),
      specVersionEn?: string(name='SpecVersionEn'),
      visible?: boolean(name='Visible'),
    }
  ](name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSpecVersionInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSpecVersionInfoResponseBody(name='body'),
}

async function getSpecVersionInfoWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetSpecVersionInfoResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetSpecVersionInfo',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/spec_version_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSpecVersionInfo(): GetSpecVersionInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSpecVersionInfoWithOptions(headers, runtime);
}

model GetUserAclDetailRequest {
  instanceId?: string(name='InstanceId'),
  patternType?: string(name='PatternType'),
  permissionType?: string(name='PermissionType'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
  userName?: string(name='UserName'),
}

model GetUserAclDetailResponseBody = {
  data?: {
    aclOperationList?: [ string ](name='AclOperationList'),
    patternType?: string(name='PatternType'),
    permissionType?: string(name='PermissionType'),
    resourceName?: string(name='ResourceName'),
    resourceType?: string(name='ResourceType'),
  }(name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetUserAclDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserAclDetailResponseBody(name='body'),
}

async function getUserAclDetailWithOptions(request: GetUserAclDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetUserAclDetailResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.patternType)) {
    query['PatternType'] = request.patternType;
  }
  if (!Util.isUnset(request.permissionType)) {
    query['PermissionType'] = request.permissionType;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserAclDetail',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/user_acl_detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserAclDetail(request: GetUserAclDetailRequest): GetUserAclDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUserAclDetailWithOptions(request, headers, runtime);
}

model GetVersionInfosResponseBody = {
  data?: [ 
    {
      specVersion?: string(name='SpecVersion'),
      specVersionEn?: string(name='SpecVersionEn'),
    }
  ](name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetVersionInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVersionInfosResponseBody(name='body'),
}

async function getVersionInfosWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetVersionInfosResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetVersionInfos',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/version_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVersionInfos(): GetVersionInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getVersionInfosWithOptions(headers, runtime);
}

model HasDefaultRoleResponseBody = {
  data?: {
    hasAuth?: boolean(name='HasAuth'),
    roleAuthUrl?: string(name='RoleAuthUrl'),
  }(name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model HasDefaultRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: HasDefaultRoleResponseBody(name='body'),
}

async function hasDefaultRoleWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): HasDefaultRoleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'HasDefaultRole',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/user/has_default_role`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function hasDefaultRole(): HasDefaultRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return hasDefaultRoleWithOptions(headers, runtime);
}

model ListAclAuthorizationRequest {
  instanceId?: string(name='InstanceId'),
  patternType?: string(name='PatternType'),
  permissionType?: string(name='PermissionType'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
  userName?: string(name='UserName'),
}

model ListAclAuthorizationResponseBody = {
  data?: [ 
    {
      aclOperationList?: [ string ](name='AclOperationList'),
      patternType?: string(name='PatternType'),
      permissionType?: string(name='PermissionType'),
      resourceName?: string(name='ResourceName'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAclAuthorizationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAclAuthorizationResponseBody(name='body'),
}

async function listAclAuthorizationWithOptions(request: ListAclAuthorizationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAclAuthorizationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.patternType)) {
    query['PatternType'] = request.patternType;
  }
  if (!Util.isUnset(request.permissionType)) {
    query['PermissionType'] = request.permissionType;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAclAuthorization',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/acls`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAclAuthorization(request: ListAclAuthorizationRequest): ListAclAuthorizationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAclAuthorizationWithOptions(request, headers, runtime);
}

model ListAuthenticatedUserRequest {
  instanceId?: string(name='InstanceId'),
}

model ListAuthenticatedUserResponseBody = {
  data?: [ 
    {
      creationTime?: long(name='CreationTime'),
      userName?: string(name='UserName'),
    }
  ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAuthenticatedUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAuthenticatedUserResponseBody(name='body'),
}

async function listAuthenticatedUserWithOptions(request: ListAuthenticatedUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAuthenticatedUserResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAuthenticatedUser',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/users`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAuthenticatedUser(request: ListAuthenticatedUserRequest): ListAuthenticatedUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAuthenticatedUserWithOptions(request, headers, runtime);
}

model ListComponentInfoRequest {
  instanceId?: string(name='InstanceId'),
}

model ListComponentInfoResponseBody = {
  data?: [ 
    {
      serviceExternalLink?: string(name='ServiceExternalLink'),
      serviceInternalLink?: string(name='ServiceInternalLink'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListComponentInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListComponentInfoResponseBody(name='body'),
}

async function listComponentInfoWithOptions(request: ListComponentInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListComponentInfoResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListComponentInfo',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/csp/component_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listComponentInfo(request: ListComponentInfoRequest): ListComponentInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listComponentInfoWithOptions(request, headers, runtime);
}

model ListCspConnectorDetailRequest {
  name?: string(name='Name'),
  owner?: int32(name='Owner'),
  packageType?: string(name='PackageType'),
  types?: [ string ](name='Types'),
}

model ListCspConnectorDetailShrinkRequest {
  name?: string(name='Name'),
  owner?: int32(name='Owner'),
  packageType?: string(name='PackageType'),
  typesShrink?: string(name='Types'),
}

model ListCspConnectorDetailResponseBody = {
  data?: [ 
    {
      componentTypes?: [ string ](name='ComponentTypes'),
      description?: string(name='Description'),
      hubUrl?: string(name='HubUrl'),
      lastModified?: long(name='LastModified'),
      logo?: string(name='Logo'),
      name?: string(name='Name'),
      owner?: {
        logo?: string(name='Logo'),
        name?: string(name='Name'),
        url?: string(name='Url'),
        userName?: string(name='UserName'),
      }(name='Owner'),
      title?: string(name='Title'),
      version?: string(name='Version'),
    }
  ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListCspConnectorDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCspConnectorDetailResponseBody(name='body'),
}

async function listCspConnectorDetailWithOptions(tmpReq: ListCspConnectorDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCspConnectorDetailResponse {
  Util.validateModel(tmpReq);
  var request = new ListCspConnectorDetailShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.types)) {
    request.typesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.types, 'Types', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.owner)) {
    query['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.packageType)) {
    query['PackageType'] = request.packageType;
  }
  if (!Util.isUnset(request.typesShrink)) {
    query['Types'] = request.typesShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCspConnectorDetail',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/csp/connectors`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCspConnectorDetail(request: ListCspConnectorDetailRequest): ListCspConnectorDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCspConnectorDetailWithOptions(request, headers, runtime);
}

model ListOssinfosRequest {
  bucketNamePrefix?: string(name='BucketNamePrefix'),
  regionId?: string(name='RegionId'),
}

model ListOssinfosResponseBody = {
  data?: [ 
    {
      bucketName?: string(name='BucketName'),
      endpoint?: string(name='Endpoint'),
      oxsEndpoint?: string(name='OxsEndpoint'),
      vpcEndpoint?: string(name='VpcEndpoint'),
    }
  ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListOssinfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOssinfosResponseBody(name='body'),
}

async function listOssinfosWithOptions(request: ListOssinfosRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOssinfosResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.bucketNamePrefix)) {
    query['BucketNamePrefix'] = request.bucketNamePrefix;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOssinfos',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/user/ossinfos`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOssinfos(request: ListOssinfosRequest): ListOssinfosResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOssinfosWithOptions(request, headers, runtime);
}

model ListRegionsResponseBody = {
  data?: [ 
    {
      description?: string(name='Description'),
      descriptionEn?: string(name='DescriptionEn'),
      regionId?: string(name='RegionId'),
      regionName?: string(name='RegionName'),
    }
  ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRegionsResponseBody(name='body'),
}

async function listRegionsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListRegionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListRegions',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/region/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRegions(): ListRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRegionsWithOptions(headers, runtime);
}

model ListSecurityGroupsRequest {
  vpcId?: string(name='VpcId'),
}

model ListSecurityGroupsResponseBody = {
  data?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupName?: string(name='SecurityGroupName'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListSecurityGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSecurityGroupsResponseBody(name='body'),
}

async function listSecurityGroupsWithOptions(request: ListSecurityGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSecurityGroupsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSecurityGroups',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/user/security_groups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSecurityGroups(request: ListSecurityGroupsRequest): ListSecurityGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSecurityGroupsWithOptions(request, headers, runtime);
}

model ListVpcsRequest {
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
}

model ListVpcsResponseBody = {
  data?: [ 
    {
      cidrBlock?: string(name='CidrBlock'),
      description?: string(name='Description'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
    }
  ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListVpcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVpcsResponseBody(name='body'),
}

async function listVpcsWithOptions(request: ListVpcsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListVpcsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVpcs',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/user/vpcs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVpcs(request: ListVpcsRequest): ListVpcsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVpcsWithOptions(request, headers, runtime);
}

model ListVswitchesRequest {
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model ListVswitchesResponseBody = {
  data?: [ 
    {
      availableIpAddressCount?: long(name='AvailableIpAddressCount'),
      cidrBlock?: string(name='CidrBlock'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      isDefault?: boolean(name='IsDefault'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vSwitchName?: string(name='VSwitchName'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListVswitchesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVswitchesResponseBody(name='body'),
}

async function listVswitchesWithOptions(request: ListVswitchesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListVswitchesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVswitches',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/user/vswitches`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVswitches(request: ListVswitchesRequest): ListVswitchesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVswitchesWithOptions(request, headers, runtime);
}

model ListZonesRequest {
  regionId?: string(name='RegionId'),
}

model ListZonesResponseBody = {
  data?: [ string ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListZonesResponseBody(name='body'),
}

async function listZonesWithOptions(request: ListZonesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListZonesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListZones',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/user/zones`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listZones(request: ListZonesRequest): ListZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listZonesWithOptions(request, headers, runtime);
}

model ModifyAclAuthorizationRequest {
  aclOperations?: string(name='AclOperations'),
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  patternType?: string(name='PatternType'),
  permissionType?: string(name='PermissionType'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
  userName?: string(name='UserName'),
}

model ModifyAclAuthorizationResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyAclAuthorizationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAclAuthorizationResponseBody(name='body'),
}

async function modifyAclAuthorizationWithOptions(request: ModifyAclAuthorizationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyAclAuthorizationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.aclOperations)) {
    query['AclOperations'] = request.aclOperations;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.patternType)) {
    query['PatternType'] = request.patternType;
  }
  if (!Util.isUnset(request.permissionType)) {
    query['PermissionType'] = request.permissionType;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAclAuthorization',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/modify_acl_authorization`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyAclAuthorization(request: ModifyAclAuthorizationRequest): ModifyAclAuthorizationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyAclAuthorizationWithOptions(request, headers, runtime);
}

model ModifyUserPasswordRequest {
  instanceId?: string(name='InstanceId'),
  password?: string(name='Password'),
  userName?: string(name='UserName'),
}

model ModifyUserPasswordResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyUserPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyUserPasswordResponseBody(name='body'),
}

async function modifyUserPasswordWithOptions(request: ModifyUserPasswordRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyUserPasswordResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyUserPassword',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/modify_user_password`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyUserPassword(request: ModifyUserPasswordRequest): ModifyUserPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyUserPasswordWithOptions(request, headers, runtime);
}

model QueryPriceRequest {
  clusterInfo?: string(name='ClusterInfo'),
}

model QueryPriceResponseBody = {
  code?: string(name='Code'),
  data?: {
    cspSoftPriceInfo?: {
      currency?: string(name='Currency'),
      discountPrice?: double(name='DiscountPrice'),
      originalPrice?: double(name='OriginalPrice'),
      tradePrice?: double(name='TradePrice'),
    }(name='CspSoftPriceInfo'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryPriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryPriceResponseBody(name='body'),
}

async function queryPriceWithOptions(request: QueryPriceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryPriceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterInfo)) {
    query['ClusterInfo'] = request.clusterInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryPrice',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/buy/query_abm_asi_price`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryPrice(request: QueryPriceRequest): QueryPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryPriceWithOptions(request, headers, runtime);
}

model QueryRenewPriceRequest {
  duration?: string(name='Duration'),
  instanceId?: string(name='InstanceId'),
  pricingCycle?: string(name='PricingCycle'),
}

model QueryRenewPriceResponseBody = {
  data?: {
    cspSoftPriceInfo?: {
      currency?: string(name='Currency'),
      discountPrice?: double(name='DiscountPrice'),
      originalPrice?: double(name='OriginalPrice'),
      tradePrice?: double(name='TradePrice'),
    }(name='CspSoftPriceInfo'),
  }(name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryRenewPriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryRenewPriceResponseBody(name='body'),
}

async function queryRenewPriceWithOptions(request: QueryRenewPriceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryRenewPriceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryRenewPrice',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/buy/query_abm_asi_renew_price`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryRenewPrice(request: QueryRenewPriceRequest): QueryRenewPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryRenewPriceWithOptions(request, headers, runtime);
}

model QueryScaleUpPriceRequest {
  brokerNumber?: int32(name='BrokerNumber'),
  connectorCpu?: int32(name='ConnectorCpu'),
  connectorNum?: int32(name='ConnectorNum'),
  controlCenterCpu?: int32(name='ControlCenterCpu'),
  controlCenterNum?: int32(name='ControlCenterNum'),
  controlCenterStorage?: int32(name='ControlCenterStorage'),
  cuNumber?: int32(name='CuNumber'),
  diskSize?: int32(name='DiskSize'),
  instanceId?: string(name='InstanceId'),
  ksqlCpu?: int32(name='KsqlCpu'),
  ksqlNum?: int32(name='KsqlNum'),
  ksqlStorage?: int32(name='KsqlStorage'),
  restProxyCpu?: int32(name='RestProxyCpu'),
  restProxyNum?: int32(name='RestProxyNum'),
  schemaregistryCpu?: int32(name='SchemaregistryCpu'),
  schemaregistryNum?: int32(name='SchemaregistryNum'),
  zookeeperCpu?: int32(name='ZookeeperCpu'),
  zookeeperNum?: int32(name='ZookeeperNum'),
  zookeeperStorage?: int32(name='ZookeeperStorage'),
}

model QueryScaleUpPriceResponseBody = {
  data?: {
    cspSoftPriceInfo?: {
      currency?: string(name='Currency'),
      discountPrice?: double(name='DiscountPrice'),
      originalPrice?: double(name='OriginalPrice'),
      tradePrice?: double(name='TradePrice'),
    }(name='CspSoftPriceInfo'),
  }(name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryScaleUpPriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryScaleUpPriceResponseBody(name='body'),
}

async function queryScaleUpPriceWithOptions(request: QueryScaleUpPriceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryScaleUpPriceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.brokerNumber)) {
    query['BrokerNumber'] = request.brokerNumber;
  }
  if (!Util.isUnset(request.connectorCpu)) {
    query['ConnectorCpu'] = request.connectorCpu;
  }
  if (!Util.isUnset(request.connectorNum)) {
    query['ConnectorNum'] = request.connectorNum;
  }
  if (!Util.isUnset(request.controlCenterCpu)) {
    query['ControlCenterCpu'] = request.controlCenterCpu;
  }
  if (!Util.isUnset(request.controlCenterNum)) {
    query['ControlCenterNum'] = request.controlCenterNum;
  }
  if (!Util.isUnset(request.controlCenterStorage)) {
    query['ControlCenterStorage'] = request.controlCenterStorage;
  }
  if (!Util.isUnset(request.cuNumber)) {
    query['CuNumber'] = request.cuNumber;
  }
  if (!Util.isUnset(request.diskSize)) {
    query['DiskSize'] = request.diskSize;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ksqlCpu)) {
    query['KsqlCpu'] = request.ksqlCpu;
  }
  if (!Util.isUnset(request.ksqlNum)) {
    query['KsqlNum'] = request.ksqlNum;
  }
  if (!Util.isUnset(request.ksqlStorage)) {
    query['KsqlStorage'] = request.ksqlStorage;
  }
  if (!Util.isUnset(request.restProxyCpu)) {
    query['RestProxyCpu'] = request.restProxyCpu;
  }
  if (!Util.isUnset(request.restProxyNum)) {
    query['RestProxyNum'] = request.restProxyNum;
  }
  if (!Util.isUnset(request.schemaregistryCpu)) {
    query['SchemaregistryCpu'] = request.schemaregistryCpu;
  }
  if (!Util.isUnset(request.schemaregistryNum)) {
    query['SchemaregistryNum'] = request.schemaregistryNum;
  }
  if (!Util.isUnset(request.zookeeperCpu)) {
    query['ZookeeperCpu'] = request.zookeeperCpu;
  }
  if (!Util.isUnset(request.zookeeperNum)) {
    query['ZookeeperNum'] = request.zookeeperNum;
  }
  if (!Util.isUnset(request.zookeeperStorage)) {
    query['ZookeeperStorage'] = request.zookeeperStorage;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryScaleUpPrice',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/buy/query_abm_asi_scale_up_price`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryScaleUpPrice(request: QueryScaleUpPriceRequest): QueryScaleUpPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryScaleUpPriceWithOptions(request, headers, runtime);
}

model QueryUnpaidOrderRequest {
  instanceId?: string(name='InstanceId'),
}

model QueryUnpaidOrderResponseBody = {
  data?: [ long ](name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryUnpaidOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryUnpaidOrderResponseBody(name='body'),
}

async function queryUnpaidOrderWithOptions(request: QueryUnpaidOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryUnpaidOrderResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryUnpaidOrder',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/order/query_abm_asi_unpaid_order`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryUnpaidOrder(request: QueryUnpaidOrderRequest): QueryUnpaidOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryUnpaidOrderWithOptions(request, headers, runtime);
}

model RenewInstanceRequest {
  duration?: string(name='Duration'),
  instanceId?: string(name='InstanceId'),
  pricingCycle?: string(name='PricingCycle'),
}

model RenewInstanceResponseBody = {
  data?: {
    orderIds?: [ string ](name='OrderIds'),
  }(name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstanceWithOptions(request: RenewInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenewInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenewInstance',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/order/renew_instance`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renewInstanceWithOptions(request, headers, runtime);
}

model ScaleUpClusterRequest {
  brokerNumber?: int32(name='BrokerNumber'),
  connectorCpu?: int32(name='ConnectorCpu'),
  connectorNum?: int32(name='ConnectorNum'),
  controlCenterCpu?: int32(name='ControlCenterCpu'),
  controlCenterNum?: int32(name='ControlCenterNum'),
  controlCenterStorage?: int32(name='ControlCenterStorage'),
  cuNumber?: int32(name='CuNumber'),
  diskSize?: int32(name='DiskSize'),
  instanceId?: string(name='InstanceId'),
  ksqlCpu?: int32(name='KsqlCpu'),
  ksqlNum?: int32(name='KsqlNum'),
  ksqlStorage?: int32(name='KsqlStorage'),
  restProxyCpu?: int32(name='RestProxyCpu'),
  restProxyNum?: int32(name='RestProxyNum'),
  schemaregistryCpu?: int32(name='SchemaregistryCpu'),
  schemaregistryNum?: int32(name='SchemaregistryNum'),
  zookeeperCpu?: int32(name='ZookeeperCpu'),
  zookeeperNum?: int32(name='ZookeeperNum'),
  zookeeperStorage?: int32(name='ZookeeperStorage'),
}

model ScaleUpClusterResponseBody = {
  data?: {
    orderIds?: [ string ](name='OrderIds'),
  }(name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ScaleUpClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ScaleUpClusterResponseBody(name='body'),
}

async function scaleUpClusterWithOptions(request: ScaleUpClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleUpClusterResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.brokerNumber)) {
    query['BrokerNumber'] = request.brokerNumber;
  }
  if (!Util.isUnset(request.connectorCpu)) {
    query['ConnectorCpu'] = request.connectorCpu;
  }
  if (!Util.isUnset(request.connectorNum)) {
    query['ConnectorNum'] = request.connectorNum;
  }
  if (!Util.isUnset(request.controlCenterCpu)) {
    query['ControlCenterCpu'] = request.controlCenterCpu;
  }
  if (!Util.isUnset(request.controlCenterNum)) {
    query['ControlCenterNum'] = request.controlCenterNum;
  }
  if (!Util.isUnset(request.controlCenterStorage)) {
    query['ControlCenterStorage'] = request.controlCenterStorage;
  }
  if (!Util.isUnset(request.cuNumber)) {
    query['CuNumber'] = request.cuNumber;
  }
  if (!Util.isUnset(request.diskSize)) {
    query['DiskSize'] = request.diskSize;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ksqlCpu)) {
    query['KsqlCpu'] = request.ksqlCpu;
  }
  if (!Util.isUnset(request.ksqlNum)) {
    query['KsqlNum'] = request.ksqlNum;
  }
  if (!Util.isUnset(request.ksqlStorage)) {
    query['KsqlStorage'] = request.ksqlStorage;
  }
  if (!Util.isUnset(request.restProxyCpu)) {
    query['RestProxyCpu'] = request.restProxyCpu;
  }
  if (!Util.isUnset(request.restProxyNum)) {
    query['RestProxyNum'] = request.restProxyNum;
  }
  if (!Util.isUnset(request.schemaregistryCpu)) {
    query['SchemaregistryCpu'] = request.schemaregistryCpu;
  }
  if (!Util.isUnset(request.schemaregistryNum)) {
    query['SchemaregistryNum'] = request.schemaregistryNum;
  }
  if (!Util.isUnset(request.zookeeperCpu)) {
    query['ZookeeperCpu'] = request.zookeeperCpu;
  }
  if (!Util.isUnset(request.zookeeperNum)) {
    query['ZookeeperNum'] = request.zookeeperNum;
  }
  if (!Util.isUnset(request.zookeeperStorage)) {
    query['ZookeeperStorage'] = request.zookeeperStorage;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ScaleUpCluster',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/scale_up`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function scaleUpCluster(request: ScaleUpClusterRequest): ScaleUpClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleUpClusterWithOptions(request, headers, runtime);
}

model SearchClusterInstancesRequest {
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model SearchClusterInstancesResponseBody = {
  data?: [ 
    {
      ckuConf?: string(name='CkuConf'),
      clusterId?: string(name='ClusterId'),
      clusterInstanceInfo?: {
        controlCenterLoginName?: string(name='ControlCenterLoginName'),
        duration?: int32(name='Duration'),
        openColddataArchiving?: boolean(name='OpenColddataArchiving'),
        ossBucketPath?: string(name='OssBucketPath'),
        ossEndpoint?: string(name='OssEndpoint'),
        payType?: string(name='PayType'),
        pricingCycle?: string(name='PricingCycle'),
        specVersion?: string(name='SpecVersion'),
        vpcId?: string(name='VpcId'),
        vswIds?: string(name='VswIds'),
      }(name='ClusterInstanceInfo'),
      clusterName?: string(name='ClusterName'),
      clusterSize?: int32(name='ClusterSize'),
      clusterStatus?: string(name='ClusterStatus'),
      clusterStatusValue?: int32(name='ClusterStatusValue'),
      connectorVisible?: boolean(name='ConnectorVisible'),
      controlCenterUrl?: string(name='ControlCenterUrl'),
      cuNum?: int32(name='CuNum'),
      expireTime?: long(name='ExpireTime'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      openKsql?: boolean(name='OpenKsql'),
      orderBizId?: string(name='OrderBizId'),
      packageType?: string(name='PackageType'),
      regionId?: string(name='RegionId'),
      storageSize?: int32(name='StorageSize'),
      templateVersion?: string(name='TemplateVersion'),
      unpaidOrderIds?: [ long ](name='UnpaidOrderIds'),
      validBrokerNumber?: boolean(name='ValidBrokerNumber'),
      version?: string(name='Version'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model SearchClusterInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchClusterInstancesResponseBody(name='body'),
}

async function searchClusterInstancesWithOptions(request: SearchClusterInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchClusterInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchClusterInstances',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/order/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchClusterInstances(request: SearchClusterInstancesRequest): SearchClusterInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchClusterInstancesWithOptions(request, headers, runtime);
}

model SingleOrderRequest {
  instanceId?: string(name='InstanceId'),
}

model SingleOrderResponseBody = {
  data?: {
    autoRenew?: boolean(name='AutoRenew'),
    clusterId?: string(name='ClusterId'),
    clusterSize?: int32(name='ClusterSize'),
    clusterStatus?: int32(name='ClusterStatus'),
    cspResourceConfig?: {
      brokerConfigList?: [ 
        {
          brokerNumber?: int32(name='BrokerNumber'),
          cuNumPerBroker?: int32(name='CuNumPerBroker'),
          storageSizePerBroker?: int32(name='StorageSizePerBroker'),
        }
      ](name='BrokerConfigList'),
      multiAvailableZonePermission?: boolean(name='MultiAvailableZonePermission'),
    }(name='CspResourceConfig'),
    cuNum?: int32(name='CuNum'),
    duration?: int32(name='Duration'),
    ecsGroupList?: [ 
      {
        diskCapacity?: int32(name='DiskCapacity'),
        diskCount?: int32(name='DiskCount'),
        diskType?: string(name='DiskType'),
        hostGroupName?: string(name='HostGroupName'),
        hostGroupType?: string(name='HostGroupType'),
        instanceType?: string(name='InstanceType'),
        nodeCount?: int32(name='NodeCount'),
        sysDiskCapacity?: int32(name='SysDiskCapacity'),
        sysDiskType?: string(name='SysDiskType'),
      }
    ](name='EcsGroupList'),
    instanceId?: string(name='InstanceId'),
    orderId?: string(name='OrderId'),
    packageType?: string(name='PackageType'),
    pricingCycle?: string(name='PricingCycle'),
    specVersion?: string(name='SpecVersion'),
    storageSize?: int32(name='StorageSize'),
  }(name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SingleOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SingleOrderResponseBody(name='body'),
}

async function singleOrderWithOptions(request: SingleOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SingleOrderResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SingleOrder',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/order/single`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function singleOrder(request: SingleOrderRequest): SingleOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return singleOrderWithOptions(request, headers, runtime);
}

model UpdateClusterNameRequest {
  clusterName?: string(name='ClusterName'),
  instanceId?: string(name='InstanceId'),
}

model UpdateClusterNameResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateClusterNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateClusterNameResponseBody(name='body'),
}

async function updateClusterNameWithOptions(request: UpdateClusterNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateClusterNameResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateClusterName',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/update_name`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateClusterName(request: UpdateClusterNameRequest): UpdateClusterNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateClusterNameWithOptions(request, headers, runtime);
}

model UpdateCspConnectorDetailRequest {
  connectorDetails?: [ 
    {
      name?: string(name='name'),
      owner?: string(name='owner'),
      version?: string(name='version'),
    }
  ](name='ConnectorDetails'),
  instanceId?: string(name='InstanceId'),
}

model UpdateCspConnectorDetailShrinkRequest {
  connectorDetailsShrink?: string(name='ConnectorDetails'),
  instanceId?: string(name='InstanceId'),
}

model UpdateCspConnectorDetailResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateCspConnectorDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCspConnectorDetailResponseBody(name='body'),
}

async function updateCspConnectorDetailWithOptions(tmpReq: UpdateCspConnectorDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCspConnectorDetailResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateCspConnectorDetailShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.connectorDetails)) {
    request.connectorDetailsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.connectorDetails, 'ConnectorDetails', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.connectorDetailsShrink)) {
    query['ConnectorDetails'] = request.connectorDetailsShrink;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCspConnectorDetail',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/csp/connectors_update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCspConnectorDetail(request: UpdateCspConnectorDetailRequest): UpdateCspConnectorDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCspConnectorDetailWithOptions(request, headers, runtime);
}

model UpdatePublicNetworkStatusRequest {
  instanceId?: string(name='InstanceId'),
  publicNetworkEnabled?: boolean(name='PublicNetworkEnabled'),
}

model UpdatePublicNetworkStatusResponseBody = {
  data?: boolean(name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdatePublicNetworkStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePublicNetworkStatusResponseBody(name='body'),
}

async function updatePublicNetworkStatusWithOptions(request: UpdatePublicNetworkStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePublicNetworkStatusResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.publicNetworkEnabled)) {
    query['PublicNetworkEnabled'] = request.publicNetworkEnabled;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePublicNetworkStatus',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/csp/public_network_switch`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePublicNetworkStatus(request: UpdatePublicNetworkStatusRequest): UpdatePublicNetworkStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePublicNetworkStatusWithOptions(request, headers, runtime);
}

