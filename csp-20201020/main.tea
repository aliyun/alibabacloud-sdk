/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('csp', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddAclAuthorizationRequest {
  aclOperation?: string(name='AclOperation'),
  clientToken?: string(name='ClientToken'),
  patternType?: string(name='PatternType'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
}

model AddAclAuthorizationResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddAclAuthorizationResponse = {
  headers: map[string]string(name='headers'),
  body: AddAclAuthorizationResponseBody(name='body'),
}

async function addAclAuthorization(request: AddAclAuthorizationRequest): AddAclAuthorizationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addAclAuthorizationWithOptions(request, headers, runtime);
}

async function addAclAuthorizationWithOptions(request: AddAclAuthorizationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddAclAuthorizationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.aclOperation)) {
    query['AclOperation'] = request.aclOperation;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.patternType)) {
    query['PatternType'] = request.patternType;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddAclAuthorization',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/add_acl_authorization`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AddAuthenticatedUserRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  password?: string(name='Password'),
  userName?: string(name='UserName'),
}

model AddAuthenticatedUserResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddAuthenticatedUserResponse = {
  headers: map[string]string(name='headers'),
  body: AddAuthenticatedUserResponseBody(name='body'),
}

async function addAuthenticatedUser(request: AddAuthenticatedUserRequest): AddAuthenticatedUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addAuthenticatedUserWithOptions(request, headers, runtime);
}

async function addAuthenticatedUserWithOptions(request: AddAuthenticatedUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddAuthenticatedUserResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddAuthenticatedUser',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/add_user`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CheckClusterNameRequest {
  clusterName?: string(name='ClusterName'),
}

model CheckClusterNameResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckClusterNameResponse = {
  headers: map[string]string(name='headers'),
  body: CheckClusterNameResponseBody(name='body'),
}

async function checkClusterName(request: CheckClusterNameRequest): CheckClusterNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkClusterNameWithOptions(request, headers, runtime);
}

async function checkClusterNameWithOptions(request: CheckClusterNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckClusterNameResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckClusterName',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/check/cluster_name`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CheckInventoryRequest {
  cloudDiskSize?: long(name='CloudDiskSize'),
  cuNum?: long(name='CuNum'),
  enableMultiAvailableZone?: boolean(name='EnableMultiAvailableZone'),
  instanceId?: string(name='InstanceId'),
  mainZoneId?: string(name='MainZoneId'),
  regionId?: string(name='RegionId'),
  zoneIds?: string(name='ZoneIds'),
}

model CheckInventoryResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckInventoryResponse = {
  headers: map[string]string(name='headers'),
  body: CheckInventoryResponseBody(name='body'),
}

async function checkInventory(request: CheckInventoryRequest): CheckInventoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkInventoryWithOptions(request, headers, runtime);
}

async function checkInventoryWithOptions(request: CheckInventoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckInventoryResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.cloudDiskSize)) {
    query['CloudDiskSize'] = request.cloudDiskSize;
  }
  if (!Util.isUnset(request.cuNum)) {
    query['CuNum'] = request.cuNum;
  }
  if (!Util.isUnset(request.enableMultiAvailableZone)) {
    query['EnableMultiAvailableZone'] = request.enableMultiAvailableZone;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.mainZoneId)) {
    query['MainZoneId'] = request.mainZoneId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.zoneIds)) {
    query['ZoneIds'] = request.zoneIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckInventory',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/check/inventory`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CheckLeftCuRequest {
  cuNum?: int32(name='CuNum'),
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
}

model CheckLeftCuResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckLeftCuResponse = {
  headers: map[string]string(name='headers'),
  body: CheckLeftCuResponseBody(name='body'),
}

async function checkLeftCu(request: CheckLeftCuRequest): CheckLeftCuResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkLeftCuWithOptions(request, headers, runtime);
}

async function checkLeftCuWithOptions(request: CheckLeftCuRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckLeftCuResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.cuNum)) {
    query['CuNum'] = request.cuNum;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckLeftCu',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/check/cu`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CheckUserAccountResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckUserAccountResponse = {
  headers: map[string]string(name='headers'),
  body: CheckUserAccountResponseBody(name='body'),
}

async function checkUserAccount(): CheckUserAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkUserAccountWithOptions(headers, runtime);
}

async function checkUserAccountWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): CheckUserAccountResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CheckUserAccount',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/check/user_account`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CheckUserResourceRequest {
  enableMultiAvailableZone?: boolean(name='EnableMultiAvailableZone'),
  mainZoneId?: string(name='MainZoneId'),
  publicNetworkEnabled?: boolean(name='PublicNetworkEnabled'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
  zoneVswitchList?: string(name='ZoneVswitchList'),
}

model CheckUserResourceResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckUserResourceResponse = {
  headers: map[string]string(name='headers'),
  body: CheckUserResourceResponseBody(name='body'),
}

async function checkUserResource(request: CheckUserResourceRequest): CheckUserResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkUserResourceWithOptions(request, headers, runtime);
}

async function checkUserResourceWithOptions(request: CheckUserResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckUserResourceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.enableMultiAvailableZone)) {
    query['EnableMultiAvailableZone'] = request.enableMultiAvailableZone;
  }
  if (!Util.isUnset(request.mainZoneId)) {
    query['MainZoneId'] = request.mainZoneId;
  }
  if (!Util.isUnset(request.publicNetworkEnabled)) {
    query['PublicNetworkEnabled'] = request.publicNetworkEnabled;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.zoneVswitchList)) {
    query['ZoneVswitchList'] = request.zoneVswitchList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckUserResource',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/check/user_resource`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CheckVpcRequest {
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
}

model CheckVpcResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckVpcResponse = {
  headers: map[string]string(name='headers'),
  body: CheckVpcResponseBody(name='body'),
}

async function checkVpc(request: CheckVpcRequest): CheckVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkVpcWithOptions(request, headers, runtime);
}

async function checkVpcWithOptions(request: CheckVpcRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckVpcResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckVpc',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/check/vpc`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CheckVswitchRequest {
  regionId?: string(name='RegionId'),
  vSwitchIds?: string(name='VSwitchIds'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model CheckVswitchResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckVswitchResponse = {
  headers: map[string]string(name='headers'),
  body: CheckVswitchResponseBody(name='body'),
}

async function checkVswitch(request: CheckVswitchRequest): CheckVswitchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkVswitchWithOptions(request, headers, runtime);
}

async function checkVswitchWithOptions(request: CheckVswitchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckVswitchResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vSwitchIds)) {
    query['VSwitchIds'] = request.vSwitchIds;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckVswitch',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/check/vswitch`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ConfirmOrderRequest {
  orderInfo?: string(name='OrderInfo'),
}

model ConfirmOrderResponseBody = {
  data?: string(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConfirmOrderResponse = {
  headers: map[string]string(name='headers'),
  body: ConfirmOrderResponseBody(name='body'),
}

async function confirmOrder(request: ConfirmOrderRequest): ConfirmOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return confirmOrderWithOptions(request, headers, runtime);
}

async function confirmOrderWithOptions(request: ConfirmOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ConfirmOrderResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.orderInfo)) {
    query['OrderInfo'] = request.orderInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmOrder',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/order/confirm`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateClusterRequest {
  clientToken?: string(name='ClientToken'),
  clusterInfo?: string(name='ClusterInfo'),
}

model CreateClusterResponseBody = {
  data?: {
    beganOn?: long(name='BeganOn'),
    endOn?: long(name='EndOn'),
    orderId?: string(name='OrderId'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterResponseBody(name='body'),
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createClusterWithOptions(request, headers, runtime);
}

async function createClusterWithOptions(request: CreateClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterInfo)) {
    query['ClusterInfo'] = request.clusterInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCluster',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateDefaultRoleRequest {
  clientToken?: string(name='ClientToken'),
}

model CreateDefaultRoleResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDefaultRoleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDefaultRoleResponseBody(name='body'),
}

async function createDefaultRole(request: CreateDefaultRoleRequest): CreateDefaultRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDefaultRoleWithOptions(request, headers, runtime);
}

async function createDefaultRoleWithOptions(request: CreateDefaultRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDefaultRoleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDefaultRole',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/user/create_default_role`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateOrderRequest {
  clientToken?: string(name='ClientToken'),
  orderInfo?: string(name='OrderInfo'),
}

model CreateOrderResponseBody = {
  data?: {
    orderId?: long(name='OrderId'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOrderResponseBody(name='body'),
}

async function createOrder(request: CreateOrderRequest): CreateOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createOrderWithOptions(request, headers, runtime);
}

async function createOrderWithOptions(request: CreateOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateOrderResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.orderInfo)) {
    query['OrderInfo'] = request.orderInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrder',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/order/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteAclAuthorizationRequest {
  aclOperation?: string(name='AclOperation'),
  instanceId?: string(name='InstanceId'),
  patternType?: string(name='PatternType'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
}

model DeleteAclAuthorizationResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteAclAuthorizationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAclAuthorizationResponseBody(name='body'),
}

async function deleteAclAuthorization(request: DeleteAclAuthorizationRequest): DeleteAclAuthorizationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAclAuthorizationWithOptions(request, headers, runtime);
}

async function deleteAclAuthorizationWithOptions(request: DeleteAclAuthorizationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAclAuthorizationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.aclOperation)) {
    query['AclOperation'] = request.aclOperation;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.patternType)) {
    query['PatternType'] = request.patternType;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAclAuthorization',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/delete_acl_authorization`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteAuthenticatedUserRequest {
  instanceId?: string(name='InstanceId'),
  password?: string(name='Password'),
  userName?: string(name='UserName'),
}

model DeleteAuthenticatedUserResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteAuthenticatedUserResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAuthenticatedUserResponseBody(name='body'),
}

async function deleteAuthenticatedUser(request: DeleteAuthenticatedUserRequest): DeleteAuthenticatedUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAuthenticatedUserWithOptions(request, headers, runtime);
}

async function deleteAuthenticatedUserWithOptions(request: DeleteAuthenticatedUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAuthenticatedUserResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAuthenticatedUser',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/delete_user`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetClusterDetailRequest {
  instanceId?: string(name='InstanceId'),
}

model GetClusterDetailResponseBody = {
  data?: {
    beginTime?: long(name='BeginTime'),
    clusterBizId?: string(name='ClusterBizId'),
    clusterId?: string(name='ClusterId'),
    clusterName?: string(name='ClusterName'),
    clusterStatus?: string(name='ClusterStatus'),
    clusterStatusValue?: int32(name='ClusterStatusValue'),
    controlCenterUrl?: string(name='ControlCenterUrl'),
    duration?: int32(name='Duration'),
    expireTime?: boolean(name='ExpireTime'),
    gmtCreate?: long(name='GmtCreate'),
    gmtModified?: long(name='GmtModified'),
    orderBizId?: string(name='OrderBizId'),
    packageType?: string(name='PackageType'),
    pricingCycle?: string(name='PricingCycle'),
    regionId?: string(name='RegionId'),
    runningTime?: long(name='RunningTime'),
    serverCert?: string(name='ServerCert'),
    zoneId?: string(name='ZoneId'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model GetClusterDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetClusterDetailResponseBody(name='body'),
}

async function getClusterDetail(request: GetClusterDetailRequest): GetClusterDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getClusterDetailWithOptions(request, headers, runtime);
}

async function getClusterDetailWithOptions(request: GetClusterDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetClusterDetailResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClusterDetail',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetConfigInfoResponseBody = {
  data?: {
    pricingInfos?: [ 
      {
        duration?: int32(name='Duration'),
        pricingCycle?: string(name='PricingCycle'),
      }
    ](name='PricingInfos'),
    specVersionInfoMap?: map[string]DataSpecVersionInfoMapValue(name='SpecVersionInfoMap'),
  }(name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetConfigInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetConfigInfoResponseBody(name='body'),
}

async function getConfigInfo(): GetConfigInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getConfigInfoWithOptions(headers, runtime);
}

async function getConfigInfoWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetConfigInfoResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetConfigInfo',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/config_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetUserAclDetailRequest {
  instanceId?: string(name='InstanceId'),
  patternType?: string(name='PatternType'),
  permissionType?: string(name='PermissionType'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
  userName?: string(name='UserName'),
}

model GetUserAclDetailResponseBody = {
  data?: {
    aclOperationList?: [ string ](name='AclOperationList'),
    patternType?: string(name='PatternType'),
    permissionType?: string(name='PermissionType'),
    resourceName?: string(name='ResourceName'),
    resourceType?: string(name='ResourceType'),
  }(name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetUserAclDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserAclDetailResponseBody(name='body'),
}

async function getUserAclDetail(request: GetUserAclDetailRequest): GetUserAclDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUserAclDetailWithOptions(request, headers, runtime);
}

async function getUserAclDetailWithOptions(request: GetUserAclDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetUserAclDetailResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.patternType)) {
    query['PatternType'] = request.patternType;
  }
  if (!Util.isUnset(request.permissionType)) {
    query['PermissionType'] = request.permissionType;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserAclDetail',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/user_acl_detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model HasDefaultRoleResponseBody = {
  data?: {
    hasAuth?: boolean(name='HasAuth'),
    roleAuthUrl?: string(name='RoleAuthUrl'),
  }(name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model HasDefaultRoleResponse = {
  headers: map[string]string(name='headers'),
  body: HasDefaultRoleResponseBody(name='body'),
}

async function hasDefaultRole(): HasDefaultRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return hasDefaultRoleWithOptions(headers, runtime);
}

async function hasDefaultRoleWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): HasDefaultRoleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'HasDefaultRole',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/user/has_default_role`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAclAuthorizationRequest {
  instanceId?: string(name='InstanceId'),
  patternType?: string(name='PatternType'),
  permissionType?: string(name='PermissionType'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
  userName?: string(name='UserName'),
}

model ListAclAuthorizationResponseBody = {
  data?: [ 
    {
      aclOperationList?: [ string ](name='AclOperationList'),
      patternType?: string(name='PatternType'),
      permissionType?: string(name='PermissionType'),
      resourceName?: string(name='ResourceName'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAclAuthorizationResponse = {
  headers: map[string]string(name='headers'),
  body: ListAclAuthorizationResponseBody(name='body'),
}

async function listAclAuthorization(request: ListAclAuthorizationRequest): ListAclAuthorizationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAclAuthorizationWithOptions(request, headers, runtime);
}

async function listAclAuthorizationWithOptions(request: ListAclAuthorizationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAclAuthorizationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.patternType)) {
    query['PatternType'] = request.patternType;
  }
  if (!Util.isUnset(request.permissionType)) {
    query['PermissionType'] = request.permissionType;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAclAuthorization',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/acls`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAuthenticatedUserRequest {
  instanceId?: string(name='InstanceId'),
}

model ListAuthenticatedUserResponseBody = {
  data?: [ 
    {
      creationTime?: string(name='CreationTime'),
      userName?: string(name='UserName'),
    }
  ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAuthenticatedUserResponse = {
  headers: map[string]string(name='headers'),
  body: ListAuthenticatedUserResponseBody(name='body'),
}

async function listAuthenticatedUser(request: ListAuthenticatedUserRequest): ListAuthenticatedUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAuthenticatedUserWithOptions(request, headers, runtime);
}

async function listAuthenticatedUserWithOptions(request: ListAuthenticatedUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAuthenticatedUserResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAuthenticatedUser',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/users`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListOssinfosRequest {
  regionId?: string(name='RegionId'),
}

model ListOssinfosResponseBody = {
  data?: [ 
    {
      bucket?: string(name='Bucket'),
      endpoint?: string(name='Endpoint'),
      oxsEndpoint?: string(name='OxsEndpoint'),
      vpcEndpoint?: string(name='VpcEndpoint'),
    }
  ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListOssinfosResponse = {
  headers: map[string]string(name='headers'),
  body: ListOssinfosResponseBody(name='body'),
}

async function listOssinfos(request: ListOssinfosRequest): ListOssinfosResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOssinfosWithOptions(request, headers, runtime);
}

async function listOssinfosWithOptions(request: ListOssinfosRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOssinfosResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOssinfos',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/user/ossinfos`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRegionsResponseBody = {
  data?: [ 
    {
      description?: string(name='Description'),
      regionId?: string(name='RegionId'),
      regionName?: string(name='RegionName'),
    }
  ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRegionsResponseBody(name='body'),
}

async function listRegions(): ListRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRegionsWithOptions(headers, runtime);
}

async function listRegionsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListRegionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListRegions',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/region/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSecurityGroupsRequest {
  vpcId?: string(name='VpcId'),
}

model ListSecurityGroupsResponseBody = {
  data?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupName?: string(name='SecurityGroupName'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListSecurityGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecurityGroupsResponseBody(name='body'),
}

async function listSecurityGroups(request: ListSecurityGroupsRequest): ListSecurityGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSecurityGroupsWithOptions(request, headers, runtime);
}

async function listSecurityGroupsWithOptions(request: ListSecurityGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSecurityGroupsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSecurityGroups',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/user/security_groups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListVpcsRequest {
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
}

model ListVpcsResponseBody = {
  data?: [ 
    {
      cidrBlock?: string(name='CidrBlock'),
      description?: string(name='Description'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
    }
  ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListVpcsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcsResponseBody(name='body'),
}

async function listVpcs(request: ListVpcsRequest): ListVpcsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVpcsWithOptions(request, headers, runtime);
}

async function listVpcsWithOptions(request: ListVpcsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListVpcsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVpcs',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/user/vpcs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListVswitchesRequest {
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model ListVswitchesResponseBody = {
  data?: [ 
    {
      availableIpAddressCount?: long(name='AvailableIpAddressCount'),
      cidrBlock?: string(name='CidrBlock'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      isDefault?: boolean(name='IsDefault'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vSwitchName?: string(name='VSwitchName'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListVswitchesResponse = {
  headers: map[string]string(name='headers'),
  body: ListVswitchesResponseBody(name='body'),
}

async function listVswitches(request: ListVswitchesRequest): ListVswitchesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVswitchesWithOptions(request, headers, runtime);
}

async function listVswitchesWithOptions(request: ListVswitchesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListVswitchesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVswitches',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/user/vswitches`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListZonesRequest {
  regionId?: string(name='RegionId'),
}

model ListZonesResponseBody = {
  data?: [ string ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListZonesResponse = {
  headers: map[string]string(name='headers'),
  body: ListZonesResponseBody(name='body'),
}

async function listZones(request: ListZonesRequest): ListZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listZonesWithOptions(request, headers, runtime);
}

async function listZonesWithOptions(request: ListZonesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListZonesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListZones',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/user/zones`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyAclAuthorizationRequest {
  aclOperations?: string(name='AclOperations'),
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  patternType?: string(name='PatternType'),
  permissionType?: string(name='PermissionType'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
  userName?: string(name='UserName'),
}

model ModifyAclAuthorizationResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyAclAuthorizationResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyAclAuthorizationResponseBody(name='body'),
}

async function modifyAclAuthorization(request: ModifyAclAuthorizationRequest): ModifyAclAuthorizationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyAclAuthorizationWithOptions(request, headers, runtime);
}

async function modifyAclAuthorizationWithOptions(request: ModifyAclAuthorizationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyAclAuthorizationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.aclOperations)) {
    query['AclOperations'] = request.aclOperations;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.patternType)) {
    query['PatternType'] = request.patternType;
  }
  if (!Util.isUnset(request.permissionType)) {
    query['PermissionType'] = request.permissionType;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAclAuthorization',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/modify_acl_authorization`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyUserPasswordRequest {
  instanceId?: string(name='InstanceId'),
  password?: string(name='Password'),
  userName?: string(name='UserName'),
}

model ModifyUserPasswordResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyUserPasswordResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyUserPasswordResponseBody(name='body'),
}

async function modifyUserPassword(request: ModifyUserPasswordRequest): ModifyUserPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyUserPasswordWithOptions(request, headers, runtime);
}

async function modifyUserPasswordWithOptions(request: ModifyUserPasswordRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyUserPasswordResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyUserPassword',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/ldap/modify_user_password`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryControlCenterLoginInfoRequest {
  clusterId?: string(name='ClusterId'),
}

model QueryControlCenterLoginInfoResponseBody = {
  data?: {
    controlCenterLoginName?: string(name='ControlCenterLoginName'),
    controlCenterPassword?: string(name='ControlCenterPassword'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryControlCenterLoginInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryControlCenterLoginInfoResponseBody(name='body'),
}

async function queryControlCenterLoginInfo(request: QueryControlCenterLoginInfoRequest): QueryControlCenterLoginInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryControlCenterLoginInfoWithOptions(request, headers, runtime);
}

async function queryControlCenterLoginInfoWithOptions(request: QueryControlCenterLoginInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryControlCenterLoginInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryControlCenterLoginInfo',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/user/control_center_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryPriceRequest {
  orderInfo?: string(name='OrderInfo'),
}

model QueryPriceResponseBody = {
  data?: string(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryPriceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryPriceResponseBody(name='body'),
}

async function queryPrice(request: QueryPriceRequest): QueryPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryPriceWithOptions(request, headers, runtime);
}

async function queryPriceWithOptions(request: QueryPriceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryPriceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.orderInfo)) {
    query['OrderInfo'] = request.orderInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryPrice',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/buy/query_price`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryRenewPriceRequest {
  duration?: string(name='Duration'),
  instanceId?: string(name='InstanceId'),
  pricingCycle?: string(name='PricingCycle'),
}

model QueryRenewPriceResponseBody = {
  data?: {
    cspSoftPriceInfo?: {
      currency?: string(name='Currency'),
      discountPrice?: double(name='DiscountPrice'),
      originalPrice?: double(name='OriginalPrice'),
      tradePrice?: double(name='TradePrice'),
    }(name='CspSoftPriceInfo'),
  }(name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryRenewPriceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryRenewPriceResponseBody(name='body'),
}

async function queryRenewPrice(request: QueryRenewPriceRequest): QueryRenewPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryRenewPriceWithOptions(request, headers, runtime);
}

async function queryRenewPriceWithOptions(request: QueryRenewPriceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryRenewPriceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryRenewPrice',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/buy/query_abm_asi_renew_price`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryScaleUpPriceRequest {
  brokerNumber?: int32(name='BrokerNumber'),
  instanceId?: string(name='InstanceId'),
}

model QueryScaleUpPriceResponseBody = {
  data?: {
    cspSoftPriceInfo?: {
      currency?: string(name='Currency'),
      discountPrice?: double(name='DiscountPrice'),
      originalPrice?: double(name='OriginalPrice'),
      tradePrice?: double(name='TradePrice'),
    }(name='CspSoftPriceInfo'),
  }(name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryScaleUpPriceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryScaleUpPriceResponseBody(name='body'),
}

async function queryScaleUpPrice(request: QueryScaleUpPriceRequest): QueryScaleUpPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryScaleUpPriceWithOptions(request, headers, runtime);
}

async function queryScaleUpPriceWithOptions(request: QueryScaleUpPriceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryScaleUpPriceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.brokerNumber)) {
    query['BrokerNumber'] = request.brokerNumber;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryScaleUpPrice',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/buy/query_abm_asi_scale_up_price`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryUnpaidOrderRequest {
  instanceId?: string(name='InstanceId'),
}

model QueryUnpaidOrderResponseBody = {
  data?: [ long ](name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryUnpaidOrderResponse = {
  headers: map[string]string(name='headers'),
  body: QueryUnpaidOrderResponseBody(name='body'),
}

async function queryUnpaidOrder(request: QueryUnpaidOrderRequest): QueryUnpaidOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryUnpaidOrderWithOptions(request, headers, runtime);
}

async function queryUnpaidOrderWithOptions(request: QueryUnpaidOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryUnpaidOrderResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryUnpaidOrder',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/order/query_abm_asi_unpaid_order`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RenewInstanceRequest {
  duration?: string(name='Duration'),
  instanceId?: string(name='InstanceId'),
  pricingCycle?: string(name='PricingCycle'),
}

model RenewInstanceResponseBody = {
  data?: {
    orderIds?: [ string ](name='OrderIds'),
  }(name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renewInstanceWithOptions(request, headers, runtime);
}

async function renewInstanceWithOptions(request: RenewInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenewInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenewInstance',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/order/renew_instance`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ScaleUpClusterRequest {
  brokerNumber?: int32(name='BrokerNumber'),
  instanceId?: string(name='InstanceId'),
}

model ScaleUpClusterResponseBody = {
  data?: {
    orderIds?: [ string ](name='OrderIds'),
  }(name='Data'),
  errCode?: int32(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ScaleUpClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ScaleUpClusterResponseBody(name='body'),
}

async function scaleUpCluster(request: ScaleUpClusterRequest): ScaleUpClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleUpClusterWithOptions(request, headers, runtime);
}

async function scaleUpClusterWithOptions(request: ScaleUpClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleUpClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.brokerNumber)) {
    query['BrokerNumber'] = request.brokerNumber;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ScaleUpCluster',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/scale_up`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SearchClusterInstancesRequest {
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model SearchClusterInstancesResponseBody = {
  data?: [ 
    {
      ckuConf?: string(name='CkuConf'),
      clusterId?: string(name='ClusterId'),
      clusterInstanceInfo?: {
        controlCenterLoginName?: string(name='ControlCenterLoginName'),
        duration?: int32(name='Duration'),
        openColddataArchiving?: boolean(name='OpenColddataArchiving'),
        ossBucketPath?: string(name='OssBucketPath'),
        ossEndpoint?: string(name='OssEndpoint'),
        payType?: string(name='PayType'),
        pricingCycle?: string(name='PricingCycle'),
        specVersion?: string(name='SpecVersion'),
        vpcId?: string(name='VpcId'),
        vswIds?: string(name='VswIds'),
      }(name='ClusterInstanceInfo'),
      clusterName?: string(name='ClusterName'),
      clusterSize?: int32(name='ClusterSize'),
      clusterStatus?: string(name='ClusterStatus'),
      clusterStatusValue?: int32(name='ClusterStatusValue'),
      controlCenterUrl?: string(name='ControlCenterUrl'),
      cuNum?: int32(name='CuNum'),
      expireTime?: long(name='ExpireTime'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      openKsql?: boolean(name='OpenKsql'),
      orderBizId?: string(name='OrderBizId'),
      packageType?: string(name='PackageType'),
      regionId?: string(name='RegionId'),
      storageSize?: int32(name='StorageSize'),
      unpaidOrderIds?: [ long ](name='UnpaidOrderIds'),
      validBrokerNumber?: boolean(name='ValidBrokerNumber'),
      version?: string(name='Version'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model SearchClusterInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: SearchClusterInstancesResponseBody(name='body'),
}

async function searchClusterInstances(request: SearchClusterInstancesRequest): SearchClusterInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchClusterInstancesWithOptions(request, headers, runtime);
}

async function searchClusterInstancesWithOptions(request: SearchClusterInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchClusterInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchClusterInstances',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/order/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SingleOrderRequest {
  instanceId?: string(name='InstanceId'),
}

model SingleOrderResponseBody = {
  data?: {
    autoRenew?: boolean(name='AutoRenew'),
    clusterId?: string(name='ClusterId'),
    clusterSize?: int32(name='ClusterSize'),
    clusterStatus?: int32(name='ClusterStatus'),
    cspResourceConfig?: {
      brokerConfigList?: [ 
        {
          brokerNumber?: int32(name='BrokerNumber'),
          cuNumPerBroker?: int32(name='CuNumPerBroker'),
          storageSizePerBroker?: int32(name='StorageSizePerBroker'),
        }
      ](name='BrokerConfigList'),
      multiAvailableZonePermission?: boolean(name='MultiAvailableZonePermission'),
    }(name='CspResourceConfig'),
    cuNum?: int32(name='CuNum'),
    duration?: int32(name='Duration'),
    ecsGroupList?: [ 
      {
        diskCapacity?: int32(name='DiskCapacity'),
        diskCount?: int32(name='DiskCount'),
        diskType?: string(name='DiskType'),
        hostGroupName?: string(name='HostGroupName'),
        hostGroupType?: string(name='HostGroupType'),
        instanceType?: string(name='InstanceType'),
        nodeCount?: int32(name='NodeCount'),
        sysDiskCapacity?: int32(name='SysDiskCapacity'),
        sysDiskType?: string(name='SysDiskType'),
      }
    ](name='EcsGroupList'),
    instanceId?: string(name='InstanceId'),
    orderId?: string(name='OrderId'),
    packageType?: string(name='PackageType'),
    pricingCycle?: string(name='PricingCycle'),
    specVersion?: string(name='SpecVersion'),
    storageSize?: int32(name='StorageSize'),
  }(name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SingleOrderResponse = {
  headers: map[string]string(name='headers'),
  body: SingleOrderResponseBody(name='body'),
}

async function singleOrder(request: SingleOrderRequest): SingleOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return singleOrderWithOptions(request, headers, runtime);
}

async function singleOrderWithOptions(request: SingleOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SingleOrderResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SingleOrder',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/order/single`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateClusterNameRequest {
  clusterName?: string(name='ClusterName'),
  instanceId?: string(name='InstanceId'),
}

model UpdateClusterNameResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateClusterNameResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateClusterNameResponseBody(name='body'),
}

async function updateClusterName(request: UpdateClusterNameRequest): UpdateClusterNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateClusterNameWithOptions(request, headers, runtime);
}

async function updateClusterNameWithOptions(request: UpdateClusterNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateClusterNameResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateClusterName',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/update_name`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DataSpecVersionInfoMapValue = {
  specVersion?: string(name='SpecVersion'),
  specVersionEn?: string(name='SpecVersionEn'),
  multiAZPermission?: boolean(name='MultiAZPermission'),
}

