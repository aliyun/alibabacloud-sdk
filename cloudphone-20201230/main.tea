/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('cloudphone', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CancelTaskRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  taskId?: string(name='TaskId', description='The task ID.', example='t-bp1hvgwromzv32iq****'),
}

model CancelTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83A'),
}

model CancelTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelTaskResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following item:
  * *   If the task is executed, you fail to call the operation and an error is returned.
  *
  * @param request CancelTaskRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CancelTaskResponse
 */
async function cancelTaskWithOptions(request: CancelTaskRequest, runtime: Util.RuntimeOptions): CancelTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelTask',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * When you call this operation, take note of the following item:
  * *   If the task is executed, you fail to call the operation and an error is returned.
  *
  * @param request CancelTaskRequest
  * @return CancelTaskResponse
 */
async function cancelTask(request: CancelTaskRequest): CancelTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelTaskWithOptions(request, runtime);
}

model CopyImageRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see How to ensure idempotence.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  description?: string(name='Description', description='The image description. The description must be 2 to 256 characters in length but cannot start with http:// or https://.', example='testDescription'),
  destinationRegionId?: string(name='DestinationRegionId', description='The destination region to which you want to copy the image.', example='cn-beijing'),
  imageId?: string(name='ImageId', description='The ID of the image that you want to copy.', example='cpm-xxxxxxxx'),
  imageName?: string(name='ImageName', description='The image name. The name must be 2 to 128 characters in length. The name can contain letters, digits, colons (:), underscores (\\_), and hyphens (-). The name can contain letters, digits, colons (:), underscores (\\_), and hyphens (-). It must start with a letter but cannot start with http:// or https://.', example='myCustomImage'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The source region from which you want to copy the image.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CopyImageResponseBody = {
  imageId?: string(name='ImageId', description='The ID of the image that is copied to the destination region.', example='cpm-xxxxxxyy'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model CopyImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CopyImageResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following items:
  * *   The custom image that you want to copy must be in the Available state.
  * *   You can only copy images within your own Alibaba Cloud account. Images cannot be copied from one account to another.
  * *   A single region can have only one image copy task running at a time. Other image copy tasks queue up for the current task to complete before they run in sequence.
  *
  * @param request CopyImageRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CopyImageResponse
 */
async function copyImageWithOptions(request: CopyImageRequest, runtime: Util.RuntimeOptions): CopyImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.destinationRegionId)) {
    query['DestinationRegionId'] = request.destinationRegionId;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CopyImage',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * When you call this operation, take note of the following items:
  * *   The custom image that you want to copy must be in the Available state.
  * *   You can only copy images within your own Alibaba Cloud account. Images cannot be copied from one account to another.
  * *   A single region can have only one image copy task running at a time. Other image copy tasks queue up for the current task to complete before they run in sequence.
  *
  * @param request CopyImageRequest
  * @return CopyImageResponse
 */
async function copyImage(request: CopyImageRequest): CopyImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyImageWithOptions(request, runtime);
}

model CreateImageRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see How to ensure idempotence.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  description?: string(name='Description', description='The image description. The description must be 2 to 256 characters in length. It cannot start with `http://` or `https://`.', example='testDescription'),
  imageName?: string(name='ImageName', description='The image name. The name must be 2 to 128 characters in length. It can contain letters, digits, colons (:), underscores (\\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.', example='myCustomImage'),
  instanceId?: string(name='InstanceId', description='The instance ID.', example='cp-xxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateImageResponseBody = {
  imageId?: string(name='ImageId', description='The custom image ID.', example='cpm-xxxxxxxx'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model CreateImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateImageResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following items:
  * *   You need to only specify the ID (InstanceId) of an ECP instance. The instance is used as a template. The instance must be in the Running or Stopped state.
  * *   You can use the created custom image only if the image is in the Available state.
  *
  * @param request CreateImageRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateImageResponse
 */
async function createImageWithOptions(request: CreateImageRequest, runtime: Util.RuntimeOptions): CreateImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateImage',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * When you call this operation, take note of the following items:
  * *   You need to only specify the ID (InstanceId) of an ECP instance. The instance is used as a template. The instance must be in the Running or Stopped state.
  * *   You can use the created custom image only if the image is in the Available state.
  *
  * @param request CreateImageRequest
  * @return CreateImageResponse
 */
async function createImage(request: CreateImageRequest): CreateImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createImageWithOptions(request, runtime);
}

model DeleteImagesRequest {
  force?: boolean(name='Force', description='Specifies whether to forcefully delete the image. Default value: false', example='false'),
  imageId?: [ string ](name='ImageId', description='The image IDs. You can specify up to 100 images.', example='cpm-xxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteImagesResponseBody = {
  imageResponses?: {
    imageResponse?: [ 
    {
      code?: string(name='Code', description='The HTTP status code that is returned when the image is deleted.', example='200'),
      imageId?: string(name='ImageId', description='The ID of the image that is requested for deletion.', example='cpm-xxxxxxxx'),
      message?: string(name='Message', description='The message that is returned when the image is deleted.', example='Success.'),
    }
  ](name='ImageResponse')
  }(name='ImageResponses', description='Details about images that are deleted.'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model DeleteImagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteImagesResponseBody(name='body'),
}

/**
  * ## [](#)Usage notes
  * When you call this operation, take note of the following items:
  * *   Images that are shared with recipient users can be deleted only after you unshare the images.
  * *   Images that are used by other Elastic Cloud Phone (ECP) instances can only be forcefully deleted.
  *
  * @param request DeleteImagesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteImagesResponse
 */
async function deleteImagesWithOptions(request: DeleteImagesRequest, runtime: Util.RuntimeOptions): DeleteImagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteImages',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## [](#)Usage notes
  * When you call this operation, take note of the following items:
  * *   Images that are shared with recipient users can be deleted only after you unshare the images.
  * *   Images that are used by other Elastic Cloud Phone (ECP) instances can only be forcefully deleted.
  *
  * @param request DeleteImagesRequest
  * @return DeleteImagesResponse
 */
async function deleteImages(request: DeleteImagesRequest): DeleteImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImagesWithOptions(request, runtime);
}

model DeleteInstancesRequest {
  force?: boolean(name='Force', description='Specifies whether to forcefully release the instance if it is in the Running status. Valid values:

*   true. If you set the Force parameter to true, temporary data in the memory and storage of the instance is erased and cannot be restored after you call the operation, which is similar to the effect of a power-off action.
*   false (default)', example='false'),
  instanceId?: [ string ](name='InstanceId', description='The instance IDs. Valid values of N: 1 to 100.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteInstancesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model DeleteInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstancesResponseBody(name='body'),
}

async function deleteInstancesWithOptions(request: DeleteInstancesRequest, runtime: Util.RuntimeOptions): DeleteInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstances',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInstances(request: DeleteInstancesRequest): DeleteInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstancesWithOptions(request, runtime);
}

model DeleteKeyPairsRequest {
  keyPairName?: [ string ](name='KeyPairName', description='The name of the key pair that the cloud phone uses. The value can be a JSON array that consists of up to 100 SSH key pair names. Separate multiple key pair names with commas (,).', example='[keyPairName1, keyPairNam2, keyPairName3]'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the key pair that you want to delete.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteKeyPairsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model DeleteKeyPairsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteKeyPairsResponseBody(name='body'),
}

/**
  * *   Before you call the operation, take note of the following items:
  *     *   If you delete a key pair of a cloud phone, you cannot query the key pair of the cloud phone by calling the ListKeyPairs operation.
  *     *   If you delete a key pair that is bound to an existing Elastic Cloud Phone (ECP) instance, Alibaba Cloud no longer saves the key pair for you, but the ECP instance can use the key pair as expected.
  *
  * @param request DeleteKeyPairsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteKeyPairsResponse
 */
async function deleteKeyPairsWithOptions(request: DeleteKeyPairsRequest, runtime: Util.RuntimeOptions): DeleteKeyPairsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteKeyPairs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   Before you call the operation, take note of the following items:
  *     *   If you delete a key pair of a cloud phone, you cannot query the key pair of the cloud phone by calling the ListKeyPairs operation.
  *     *   If you delete a key pair that is bound to an existing Elastic Cloud Phone (ECP) instance, Alibaba Cloud no longer saves the key pair for you, but the ECP instance can use the key pair as expected.
  *
  * @param request DeleteKeyPairsRequest
  * @return DeleteKeyPairsResponse
 */
async function deleteKeyPairs(request: DeleteKeyPairsRequest): DeleteKeyPairsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteKeyPairsWithOptions(request, runtime);
}

model FetchFileRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance on which you want to run the command. Valid values of N: 1 to 10.', example='cp-acfmxazb4p***'),
  ossBucket?: string(name='OssBucket', description='The OSS bucket to which the file that you want to upload.

>  Before you import an APK file to the OSS bucket for the first time, add a Resource Access Management (RAM) policy. Otherwise, NoSetRoletoECSServiceAcount appears.', example='bucket'),
  ossObject?: string(name='OssObject', description='The name that you want to save to OSS.', example='test.txt'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  path?: string(name='Path', description='The path in which you want to store the file in the cloud phone.', example='/sdcard/test.txt'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model FetchFileResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  taskId?: string(name='TaskId', description='The task ID.', example='t-bp67acfmxazb4p****'),
}

model FetchFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FetchFileResponseBody(name='body'),
}

async function fetchFileWithOptions(request: FetchFileRequest, runtime: Util.RuntimeOptions): FetchFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ossBucket)) {
    query['OssBucket'] = request.ossBucket;
  }
  if (!Util.isUnset(request.ossObject)) {
    query['OssObject'] = request.ossObject;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FetchFile',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function fetchFile(request: FetchFileRequest): FetchFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return fetchFileWithOptions(request, runtime);
}

model ImportImageRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  description?: string(name='Description', description='The image description. The description must be 2 to 256 characters in length, and cannot start with `http://` or `https://`.', example='testDescription'),
  format?: string(name='Format', description='The image format. Valid values:

*   RAW
*   QCOW2', example='RAW'),
  imageName?: string(name='ImageName', description='The image name. The name must be 2 to 128 characters in length. The name can contain letters, digits, colons (:), underscores (\\_), and hyphens (-). It must start with a letter and cannot start with `http://` or `https://`.', example='myCustomImage'),
  ossBucket?: string(name='OssBucket', description='The OSS bucket to which you want to import the image.', example='myOssBucket'),
  ossObject?: string(name='OssObject', description='The name (key) of the image file that you want to use as an OSS object.', example='myOssKeyForImage.raw'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  platform?: string(name='Platform', description='The OS distribution. Valid values:

*   Android 9.0', example='Android 9.0'),
  regionId?: string(name='RegionId', description='The ID of the region where you want to import the image to the ECP instance.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ImportImageResponseBody = {
  imageId?: string(name='ImageId', description='The ID of the image that is imported to the instance.', example='cpm-xxxxxxxx'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model ImportImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ImportImageResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following items:
  * *   Before you import the image, you must upload the image to an Object Storage Service (OSS) bucket. For more information, see [Upload objects](~~31886~~).
  * *   When you import an image for the first time, you must use Resource Access Management (RAM) to grant permissions on the access to OSS buckets in advance to obtain [Cloud Resource Access Authorization](https://ram.console.aliyun.com/role/authorization?request=%7B%22Services%22%3A%5B%7B%22Service%22%3A%22CloudPhone%22%2C%22Roles%22%3A%5B%7B%22RoleName%22%3A%22AliyunCloudPhoneDefaultRole%22%2C%22TemplateId%22%3A%22AliyunCloudPhoneDefaultRole%22%7D%5D%7D%5D%2C%22ReturnUrl%22%3A%22https%3A%2F%2Fcloudphone.console.aliyun.com%2F%23%2Finstances%22%7D) with one click.
  * *   You can import an image only to a region that is the same as that of the OSS bucket to which the image file was imported.
  *
  * @param request ImportImageRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ImportImageResponse
 */
async function importImageWithOptions(request: ImportImageRequest, runtime: Util.RuntimeOptions): ImportImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.format)) {
    query['Format'] = request.format;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.ossBucket)) {
    query['OssBucket'] = request.ossBucket;
  }
  if (!Util.isUnset(request.ossObject)) {
    query['OssObject'] = request.ossObject;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.platform)) {
    query['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportImage',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * When you call this operation, take note of the following items:
  * *   Before you import the image, you must upload the image to an Object Storage Service (OSS) bucket. For more information, see [Upload objects](~~31886~~).
  * *   When you import an image for the first time, you must use Resource Access Management (RAM) to grant permissions on the access to OSS buckets in advance to obtain [Cloud Resource Access Authorization](https://ram.console.aliyun.com/role/authorization?request=%7B%22Services%22%3A%5B%7B%22Service%22%3A%22CloudPhone%22%2C%22Roles%22%3A%5B%7B%22RoleName%22%3A%22AliyunCloudPhoneDefaultRole%22%2C%22TemplateId%22%3A%22AliyunCloudPhoneDefaultRole%22%7D%5D%7D%5D%2C%22ReturnUrl%22%3A%22https%3A%2F%2Fcloudphone.console.aliyun.com%2F%23%2Finstances%22%7D) with one click.
  * *   You can import an image only to a region that is the same as that of the OSS bucket to which the image file was imported.
  *
  * @param request ImportImageRequest
  * @return ImportImageResponse
 */
async function importImage(request: ImportImageRequest): ImportImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return importImageWithOptions(request, runtime);
}

model ImportKeyPairRequest {
  keyPairName?: string(name='KeyPairName', description='The name of the key pair. The name must be globally unique. The name must be 2 to 128 characters in length. The name must start with a letter but cannot start with http:// or https://. The name can contain letters, digits, colons (:), underscores (\\_), and hyphens (-).', example='testKeyPairName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  publicKeyBody?: string(name='PublicKeyBody', description='The public key of the key pair.', example='ABC1234567'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ImportKeyPairResponseBody = {
  keyPairFingerPrint?: string(name='KeyPairFingerPrint', description='The fingerprint of the key pair. The message-digest algorithm 5 (MD5) is used based on the public key fingerprint format defined in RFC 4716.', example='89:f0:ba:62:ac:b8:aa:e1:61:5e:fd:81:69:86:6d:6b:f0:c0:5a:**'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair.', example='testKeyPairName'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model ImportKeyPairResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ImportKeyPairResponseBody(name='body'),
}

/**
  * Usage notes Before you call this operation, take note of the following items:
  * *   You can create up to 500 key pairs in each region.
  * *   The imported public key pair must generate the public key of a key pair for Android Debug Bridge (ADB).
  *
  * @param request ImportKeyPairRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ImportKeyPairResponse
 */
async function importKeyPairWithOptions(request: ImportKeyPairRequest, runtime: Util.RuntimeOptions): ImportKeyPairResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.publicKeyBody)) {
    query['PublicKeyBody'] = request.publicKeyBody;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportKeyPair',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Usage notes Before you call this operation, take note of the following items:
  * *   You can create up to 500 key pairs in each region.
  * *   The imported public key pair must generate the public key of a key pair for Android Debug Bridge (ADB).
  *
  * @param request ImportKeyPairRequest
  * @return ImportKeyPairResponse
 */
async function importKeyPair(request: ImportKeyPairRequest): ImportKeyPairResponse {
  var runtime = new Util.RuntimeOptions{};
  return importKeyPairWithOptions(request, runtime);
}

model InstallApplicationRequest {
  instanceId?: [ string ](name='InstanceId', description='The IDs of the instances on which you want to run the command. Valid values of N: 1 to 10.', example='cp-acfmxazb4p***'),
  ossBucket?: string(name='OssBucket', description='The Object Storage Service (OSS) bucket in which you want to store the application file.

>  Before you import application files to the OSS bucket for the first time, add a Resource Access Management (RAM) policy. Otherwise, NoSetRoletoECSServiceAcount appears.', example='phoneapplication'),
  ossObject?: string(name='OssObject', description='The name (key) of the application file that is used as an OSS object.', example='test.apk'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model InstallApplicationResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='55C15B1C-D507-45F0-B490-69D6E0F113C6'),
  taskId?: {
    taskId?: [ string ](name='TaskId')
  }(name='TaskId', description='The task IDs.'),
}

model InstallApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallApplicationResponseBody(name='body'),
}

async function installApplicationWithOptions(request: InstallApplicationRequest, runtime: Util.RuntimeOptions): InstallApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ossBucket)) {
    query['OssBucket'] = request.ossBucket;
  }
  if (!Util.isUnset(request.ossObject)) {
    query['OssObject'] = request.ossObject;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallApplication',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installApplication(request: InstallApplicationRequest): InstallApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return installApplicationWithOptions(request, runtime);
}

model ListImageSharePermissionRequest {
  imageId?: string(name='ImageId', description='The ID of the image that you want to import to the instance.', example='cpm-xxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListImageSharePermissionResponseBody = {
  accounts?: {
    account?: [ 
    {
      aliyunId?: string(name='AliyunId', description='The ID of the Alibaba Cloud account.', example='1765205448******'),
    }
  ](name='Account')
  }(name='Accounts', description='The list of Alibaba Cloud accounts.'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model ListImageSharePermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListImageSharePermissionResponseBody(name='body'),
}

async function listImageSharePermissionWithOptions(request: ListImageSharePermissionRequest, runtime: Util.RuntimeOptions): ListImageSharePermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListImageSharePermission',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listImageSharePermission(request: ListImageSharePermissionRequest): ListImageSharePermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listImageSharePermissionWithOptions(request, runtime);
}

model ListImagesRequest {
  imageCategory?: string(name='ImageCategory', description='The image source. Valid values:

*   system: public images provided by Alibaba Cloud.
*   self: custom images that you create.
*   others: shared images from other Alibaba Cloud accounts.', example='system'),
  imageId?: [ string ](name='ImageId', description='The image IDs. Valid values of N: 1 to 100.'),
  imageName?: string(name='ImageName', description='The image name. The name must be 2 to 128 characters in length. It can contain letters, digits, colons (:), underscores (\\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.', example='testImageName'),
  instanceType?: string(name='InstanceType', description='The instance type.', example='ecp.ce.large'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries to return on each page. Valid values: 1 to 100.', example='50'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='ADBAAdDWBF2****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: string(name='Status', description='The image state. Valid values:

*   Waiting
*   Creating
*   Copying
*   Importing
*   Available (default)
*   CreateFailed', example='Available'),
}

model ListImagesResponseBody = {
  images?: {
    image?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the image was created. The time follows the ISO 8601 standard.', example='2021-01-01T01:07:58Z'),
      description?: string(name='Description', description='The image description.', example='testDescription'),
      imageCategory?: string(name='ImageCategory', description='The image type.', example='system'),
      imageId?: string(name='ImageId', description='The image ID.', example='cpm-xxxxxxxx'),
      imageName?: string(name='ImageName', description='The image name.', example='testImageName'),
      isSelfShared?: boolean(name='IsSelfShared', description='Indicates whether the image is shared with other Alibaba Cloud accounts.', example='false'),
      OSName?: string(name='OSName', description='The display name of the OS in Chinese.', example='Android 9.0'),
      OSNameEn?: string(name='OSNameEn', description='The display name of the OS in English.', example='Android 9.0'),
      OSType?: string(name='OSType', description='The image OS.', example='android'),
      platform?: string(name='Platform', description='The OS distribution.', example='Android 9.0'),
      progress?: string(name='Progress', description='The progress of image creation.', example='100%'),
      status?: string(name='Status', description='The image state.', example='Available'),
      usage?: string(name='Usage', description='Indicates whether the image is used by instances. Valid values:

*   none: The image is idle.
*   instance: The image is used by instances.', example='none'),
    }
  ](name='Image')
  }(name='Images', description='The list of images.'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries that is returned on each page. Valid values: 1 to 100.', example='50'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='ADBAAdDWBF2****'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  totalCount?: int32(name='TotalCount', description='The total number of images.', example='3'),
}

model ListImagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListImagesResponseBody(name='body'),
}

async function listImagesWithOptions(request: ListImagesRequest, runtime: Util.RuntimeOptions): ListImagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageCategory)) {
    query['ImageCategory'] = request.imageCategory;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListImages',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listImages(request: ListImagesRequest): ListImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listImagesWithOptions(request, runtime);
}

model ListInstanceTypesRequest {
  instanceType?: [ string ](name='InstanceType', description='The names of the instance types. Valid values of N: 1 to 100.'),
  instanceTypeFamily?: string(name='InstanceTypeFamily', description='The instance type family.', example='ecp.ce'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListInstanceTypesResponseBody = {
  instanceTypes?: {
    instanceType?: [ 
    {
      cpuCoreCount?: int32(name='CpuCoreCount', description='The number of vCPUs supported by the instance type.', example='2'),
      defaultResolution?: string(name='DefaultResolution', description='The default resolution supported by the instance type.', example='720*1280'),
      instanceType?: string(name='InstanceType', description='The instance type.', example='ecp.ce.xlarge'),
      instanceTypeFamily?: string(name='InstanceTypeFamily', description='The instance type family.', example='ecp.ce'),
      memorySize?: string(name='MemorySize', description='The memory size supported by the instance type. Unit: GiB.', example='4096'),
      name?: string(name='Name', description='The name of the instance type in Chinese.', example='Performance Type'),
      nameEn?: string(name='NameEn', description='The name of the instance type in English.', example='Performance Type'),
      resolutions?: {
        resolution?: [ string ](name='Resolution')
      }(name='Resolutions', description='The resolutions supported by the instance type.'),
    }
  ](name='InstanceType')
  }(name='InstanceTypes', description='The instance types.'),
  requestId?: string(name='RequestId', description='The request ID.', example='41345CE8-6FE8-505D-BCF8-B9D972C1873F'),
}

model ListInstanceTypesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceTypesResponseBody(name='body'),
}

async function listInstanceTypesWithOptions(request: ListInstanceTypesRequest, runtime: Util.RuntimeOptions): ListInstanceTypesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.instanceTypeFamily)) {
    query['InstanceTypeFamily'] = request.instanceTypeFamily;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceTypes',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstanceTypes(request: ListInstanceTypesRequest): ListInstanceTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceTypesWithOptions(request, runtime);
}

model ListInstanceVncUrlRequest {
  instanceId?: string(name='InstanceId', description='The instance ID.', example='cp-xxxxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region where the instance resides.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListInstanceVncUrlResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  vncUrl?: string(name='VncUrl', description='The Virtual Network Computing (VNC) connection URL.', example='wss%3A%2F%2Fhz01-vncproxy.aliyun.com%2Fwebsockify%2F%3Fs%3DDvh%252FIA%252BYc73gWO48cBx2gBxUDVzaAnSKr74pq30mzqUYgeUMcB%252FbkNixDxdEA996'),
  webRtcToken?: string(name='WebRtcToken', description='The token that is used for WebRTC logon.', example='D3EC1DE8C12E******'),
}

model ListInstanceVncUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceVncUrlResponseBody(name='body'),
}

/**
  * ## [](#)Usage notes
  * When you call this operation, take note of the following items:
  * *   The URL returned is valid only for 15 seconds. If no connection is established within 15 seconds after a successful query, the URL expires. You must query the URL again if you still want to use the URL.
  * *   The keep-alive duration of a single URL of a management terminal is 60 seconds. If no interaction is detected within the 60 seconds, the management terminal is automatically disconnected.
  * *   After the management terminal is disconnected, you can only reconnect to the terminal up to 30 times per minute.
  * *   You need to add vncUrl=\\*\\*\\*\\*, instanceId= ****and password=**** to the end of the link https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html? and use ampersands (&) between the parameters. Parameter description:
  *     *   vncUrl: the value that is returned after the operation is called.
  *     *   instanceId: the instance ID.
  *     *   (Optional) password: the password for remote connection of the instance, which can contain six characters in length. The password can be digits or letters. If you specify this parameter, you do not need to enter your password again when the management terminal is being connected.
  * Example:
  * https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html?vncUrl=ws%3A%2F%****\\&instanceId=cp-wz9hhwq5a6tm****
  * Or:
  * https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html?vncUrl=ws%3A%2F%****\\&instanceId=cp-wz9hhwq5a6tm****\\&password=\\*\\*\\*\\*
  *
  * @param request ListInstanceVncUrlRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListInstanceVncUrlResponse
 */
async function listInstanceVncUrlWithOptions(request: ListInstanceVncUrlRequest, runtime: Util.RuntimeOptions): ListInstanceVncUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceVncUrl',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## [](#)Usage notes
  * When you call this operation, take note of the following items:
  * *   The URL returned is valid only for 15 seconds. If no connection is established within 15 seconds after a successful query, the URL expires. You must query the URL again if you still want to use the URL.
  * *   The keep-alive duration of a single URL of a management terminal is 60 seconds. If no interaction is detected within the 60 seconds, the management terminal is automatically disconnected.
  * *   After the management terminal is disconnected, you can only reconnect to the terminal up to 30 times per minute.
  * *   You need to add vncUrl=\\*\\*\\*\\*, instanceId= ****and password=**** to the end of the link https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html? and use ampersands (&) between the parameters. Parameter description:
  *     *   vncUrl: the value that is returned after the operation is called.
  *     *   instanceId: the instance ID.
  *     *   (Optional) password: the password for remote connection of the instance, which can contain six characters in length. The password can be digits or letters. If you specify this parameter, you do not need to enter your password again when the management terminal is being connected.
  * Example:
  * https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html?vncUrl=ws%3A%2F%****\\&instanceId=cp-wz9hhwq5a6tm****
  * Or:
  * https://g.alicdn.com/aliyun/ecs-console-vnc2/0.0.8/index.html?vncUrl=ws%3A%2F%****\\&instanceId=cp-wz9hhwq5a6tm****\\&password=\\*\\*\\*\\*
  *
  * @param request ListInstanceVncUrlRequest
  * @return ListInstanceVncUrlResponse
 */
async function listInstanceVncUrl(request: ListInstanceVncUrlRequest): ListInstanceVncUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceVncUrlWithOptions(request, runtime);
}

model ListInstancesRequest {
  chargeType?: string(name='ChargeType', description='The billing method. Valid values:

*   PrePaid: subscription
*   PostPaid: pay-as-you-go', example='PostPaid'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filter'),
  imageId?: string(name='ImageId', description='The image ID.', example='cpm-xxxxxxxxx'),
  instanceId?: [ string ](name='InstanceId', description='The instance IDs. Valid values of N: 1 to 100.', example='cp-xxxxxxxxxx'),
  instanceName?: string(name='InstanceName', description='The instance name.', example='phone'),
  instanceType?: string(name='InstanceType', description='The instance type.', example='ecp.ce.large'),
  keyPairName?: string(name='KeyPairName', description='The key pair name. The name must be globally unique. The name must be 2 to 128 characters in length. The name must start with a letter and cannot start with http:// or https://. The name can contain letters, digits, colons (:), underscores (\\_), and hyphens (-).', example='testKeyPairName'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries returned on each page. Valid values: 1 to 100.', example='50'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='ADBAAdDWBF2****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resolution?: string(name='Resolution', description='The instance resolution.', example='1920*1080'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  showWebRtcToken?: boolean(name='ShowWebRtcToken', description='Specifies whether webRtcToken is returned in the query result.', example='false'),
  status?: string(name='Status', description='The instance status. Valid values:

*   Pending: The instance is being created.
*   Running: The instance is running.
*   Starting: The instance is being started.
*   Stopping: The instance is being stopped.
*   Stopped: The instance is stopped.
*   Expired: The instance has expired.', example='Running'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key of the instance. Valid values of N: 1 to 20.', example='TestKey'),
      value?: string(name='Value', description='The tag value of the instance. Valid values of N: 1 to 20.', example='TestValue'),
    }
  ](name='Tag', description='The instances that you want to filter by using a specified tag.'),
  zoneId?: string(name='ZoneId', description='The ID of the zone where the instance resides.', example='cn-hangzhou-i'),
}

model ListInstancesResponseBody = {
  instances?: {
    instance?: [ 
    {
      autoRenew?: boolean(name='AutoRenew', description='Indicates whether auto-renewal is enabled. This parameter takes effect only for subscription instances.', example='false'),
      chargeType?: string(name='ChargeType', description='The billing method of the instance.', example='PostPaid'),
      creationTime?: string(name='CreationTime', description='The time when the image was created. The time follows the ISO 8601 standard.', example='2021-01-01T01:07:58Z'),
      description?: string(name='Description', description='The instance description.', example='testDescription'),
      eipAddress?: {
        allocationId?: string(name='AllocationId', description='The ID of the EIP that is used by the instance.', example='eip-bp1vctqgcoi6i9nxxxxxx'),
        bandwidth?: int32(name='Bandwidth', description='The bandwidth of the EIP.', example='2'),
        internetChargeType?: string(name='InternetChargeType', description='The billing method of the EIP.', example='PayByTraffic'),
        ipAddress?: string(name='IpAddress', description='The EIP.', example='120.55.XX.XX'),
      }(name='EipAddress', description='The information about the elastic IP address (EIP) of the instance.'),
      expiredTime?: string(name='ExpiredTime', description='The time when the subscription instance expires.', example='2021-12-21 22:00:00'),
      imageId?: string(name='ImageId', description='The image ID.', example='cpm-xxxxxxxx'),
      instanceId?: string(name='InstanceId', description='The instance ID.', example='cp-xxxxxxxxxxx'),
      instanceName?: string(name='InstanceName', description='The instance name.', example='testInstanceName'),
      instanceType?: string(name='InstanceType', description='The instance type.', example='ecp.ce.large'),
      keyPairName?: string(name='KeyPairName', description='The name of the key pair for the instance.', example='testKeyPairName'),
      osName?: string(name='OsName', description='The display name of the OS in Chinese.', example='Android 9.0'),
      osNameEn?: string(name='OsNameEn', description='The display name of the OS in English.', example='Android 9.0'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
      resolution?: string(name='Resolution', description='The resolution of the instance.', example='1920*1080'),
      securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group that the instance uses. The security group is the same as that of the Elastic Compute Service (ECS) instance that you use.', example='sg-xxxxx'),
      status?: string(name='Status', description='The instance state. Valid values:

*   Pending: The instance is being created.
*   Running: The instance is running.
*   Starting: The instance is being started.
*   Stopping: The instance is being stopped.
*   Stopped: The instance is stopped.', example='Running'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key', description='The tag key of the instance.', example='TestKey'),
          value?: string(name='Value', description='The tag value of the instance.', example='TestValue'),
        }
      ](name='Tag')
      }(name='Tags', description='The tags of the instance.'),
      vpcAttributes?: {
        privateIpAddress?: string(name='PrivateIpAddress', description='The private IP address.', example='192.168.0.85'),
        vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-bp1kbwqxxxxx'),
      }(name='VpcAttributes', description='The information about the virtual private cloud (VPC) in which the instance is deployed.'),
      webRtcToken?: string(name='WebRtcToken', description='The information about webRtcToken.', example='eDeybrh74h34***'),
      zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-i'),
    }
  ](name='Instance')
  }(name='Instances', description='Details of the instances.'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries returned on each page. Valid values: 1 to 100.', example='50'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='ADBAAdDWBF2****'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  totalCount?: int32(name='TotalCount', description='The total number of entries that is returned.', example='3'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstancesResponseBody(name='body'),
}

/**
  * *   This operation only supports the NextToken query method.
  * *   Results are returned in descending order based on the time when ECP instances were created.
  * *   When you use NextToken to specify a query token, set the value to the NextToken value that is returned in the last call to the ListInstances operation. Then, use MaxResults to specify the maximum number of entries to return on each page.
  *
  * @param request ListInstancesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListInstancesResponse
 */
async function listInstancesWithOptions(request: ListInstancesRequest, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resolution)) {
    query['Resolution'] = request.resolution;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.showWebRtcToken)) {
    query['ShowWebRtcToken'] = request.showWebRtcToken;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   This operation only supports the NextToken query method.
  * *   Results are returned in descending order based on the time when ECP instances were created.
  * *   When you use NextToken to specify a query token, set the value to the NextToken value that is returned in the last call to the ListInstances operation. Then, use MaxResults to specify the maximum number of entries to return on each page.
  *
  * @param request ListInstancesRequest
  * @return ListInstancesResponse
 */
async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstancesWithOptions(request, runtime);
}

model ListKeyPairsRequest {
  keyPairFingerPrint?: string(name='KeyPairFingerPrint', description='The fingerprint of the key pair. The message-digest algorithm 5 (MD5) is used based on the public key fingerprint format defined in RFC 4716.', example='ABC1234567'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair.', example='testKeyPair'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries per page. Valid values: 1 to 100.', example='50'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='ADBAAdDWBF2****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region where the key pair resides.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListKeyPairsResponseBody = {
  keyPairs?: {
    keyPair?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the key pair was created.', example='2021-03-04T13:35:00Z'),
      keyPairFingerPrint?: string(name='KeyPairFingerPrint', description='The fingerprint of the key pair.', example='ABC1234567'),
      keyPairName?: string(name='KeyPairName', description='The name of the SSH key pair.', example='testKeyPairName'),
    }
  ](name='KeyPair')
  }(name='KeyPairs', description='The key pairs that are returned.'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries per page. Valid values: 1 to 100.', example='100'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='t'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  totalCount?: int32(name='TotalCount', description='The total number of key pairs.', example='5'),
}

model ListKeyPairsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListKeyPairsResponseBody(name='body'),
}

/**
  * You can call this operation to query one or more key pairs of cloud phones.
  *
  * @param request ListKeyPairsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListKeyPairsResponse
 */
async function listKeyPairsWithOptions(request: ListKeyPairsRequest, runtime: Util.RuntimeOptions): ListKeyPairsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyPairFingerPrint)) {
    query['KeyPairFingerPrint'] = request.keyPairFingerPrint;
  }
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListKeyPairs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this operation to query one or more key pairs of cloud phones.
  *
  * @param request ListKeyPairsRequest
  * @return ListKeyPairsResponse
 */
async function listKeyPairs(request: ListKeyPairsRequest): ListKeyPairsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listKeyPairsWithOptions(request, runtime);
}

model ListRegionsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      regionEndpoint?: string(name='RegionEndpoint', description='The endpoint that corresponds to the region.', example='cloudphone.cn-hangzhou.aliyuncs.com'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
    }
  ](name='Region')
  }(name='Regions', description='The details of the regions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model ListRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRegionsResponseBody(name='body'),
}

/**
  * *   You can call this operation to query regions where ECP is available.
  *
  * @param request ListRegionsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListRegionsResponse
 */
async function listRegionsWithOptions(request: ListRegionsRequest, runtime: Util.RuntimeOptions): ListRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRegions',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   You can call this operation to query regions where ECP is available.
  *
  * @param request ListRegionsRequest
  * @return ListRegionsResponse
 */
async function listRegions(request: ListRegionsRequest): ListRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRegionsWithOptions(request, runtime);
}

model ListTagKeysRequest {
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='ADBAAdDWBF2****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType', description='The resource type. Valid value:

*   instance: Elastic Cloud Phone (ECP) instance', example='instance'),
}

model ListTagKeysResponseBody = {
  keys?: {
    key?: [ string ](name='Key')
  }(name='Keys', description='The tag keys.'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries to return on each page.', example='50'),
  nextToken?: string(name='NextToken', description='The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results. If the NextToken parameter is empty, no next page exists.', example='ADBAAdDWBF2****'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model ListTagKeysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagKeysResponseBody(name='body'),
}

async function listTagKeysWithOptions(request: ListTagKeysRequest, runtime: Util.RuntimeOptions): ListTagKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagKeys',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagKeys(request: ListTagKeysRequest): ListTagKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagKeysWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='ADBAAdDWBF2****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs. You can specify up to 50 resources.'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType', description='The resource type. Valid value:

*   instance: Elastic Cloud Phone (ECP) instance', example='instance'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='TestKey'),
      value?: string(name='Value', description='The tag value.', example='TestValue'),
    }
  ](name='Tag', description='The tags. You can specify up to 20 tags.'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results. If the NextToken parameter is empty, no next page exists.', example='ADBAAdDWBF2****'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83A'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId', description='The resource ID.', example='cp-xxx'),
      resourceType?: string(name='ResourceType', description='The resource type. Valid value:

*   instance: ECP instance', example='instance'),
      tagKey?: string(name='TagKey', description='The tag key.', example='TestKey'),
      tagValue?: string(name='TagValue', description='The tag value.', example='TestValue'),
    }
  ](name='TagResource')
  }(name='TagResources', description='The list of resources.'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListTagValuesRequest {
  key?: string(name='Key', description='The tag key whose values you want to query.', example='TestKey'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='ADBAAdDWBF2****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType', description='The resource type. Valid value:

*   instance: Elastic Cloud Phone (ECP) instance', example='instance'),
}

model ListTagValuesResponseBody = {
  maxResults?: int32(name='MaxResults', description='The maximum number of entries that is returned on each page.', example='50'),
  nextToken?: string(name='NextToken', description='The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results. If the NextToken parameter is empty, no next page exists.', example='ADBAAdDWBF2****'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  values?: {
    value?: [ string ](name='Value')
  }(name='Values', description='The list of resources.'),
}

model ListTagValuesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagValuesResponseBody(name='body'),
}

async function listTagValuesWithOptions(request: ListTagValuesRequest, runtime: Util.RuntimeOptions): ListTagValuesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagValues',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagValues(request: ListTagValuesRequest): ListTagValuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagValuesWithOptions(request, runtime);
}

model ListTasksRequest {
  instanceId?: string(name='InstanceId', description='The instance ID.', example='cp-acfmxazb4p***'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries to return on each page. Valid values: 1 to 100. Default value: 50.', example='50'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='55C15B1C-D507-45F0-B490-69D6E0F113C6'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  taskId?: [ string ](name='TaskId', description='The task IDs. Valid values of N: 1 to 100.', example='t-bp67acfmxazb4p****'),
  taskStatus?: string(name='TaskStatus', description='The task state. Valid values:

*   Finished
*   Processing
*   Failed

This parameter is empty by default.

>  The system only queries tasks that are in the Finished, Processing, and Failed states and ignores other values.', example='Finished'),
  taskType?: string(name='TaskType', description='The name of the operation that you can call to execute the task on the instance. Valid values:

*   Shell: runs a shell command.
*   InstallApplication: installs an application.
*   UninstallApplication: uninstalls an application.
*   SendFile: uploads a file.
*   ImportImage: imports an image.', example='Shell'),
}

model ListTasksResponseBody = {
  maxResults?: int32(name='MaxResults', description='The maximum number of entries that is returned on each page. Valid values: 1 to 200. Default value: 50.', example='50'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='ADBAAdDWBF2****'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  tasks?: {
    task?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the task was created.', example='2021-04-15 10:10:00'),
      executeMsg?: string(name='ExecuteMsg', description='The content that is returned after the task is executed. The content can be up to 1,024 bytes in length.', example='file1 file2'),
      finishedTime?: string(name='FinishedTime', description='The time when the task ended.', example='2021-04-15 10:10:01'),
      instanceId?: string(name='InstanceId', description='The instance ID.', example='cp-acfmxazb4p***'),
      progress?: string(name='Progress', description='The task progress.', example='100%'),
      taskId?: string(name='TaskId', description='The task ID.', example='t-bp67acfmxazb4p****'),
      taskStatus?: string(name='TaskStatus', description='The task state.', example='Finished'),
      taskType?: string(name='TaskType', description='The task type.', example='Shell'),
    }
  ](name='Task')
  }(name='Tasks', description='The tasks.'),
  totalCount?: int32(name='TotalCount', description='The total number of tasks.', example='1'),
}

model ListTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTasksResponseBody(name='body'),
}

async function listTasksWithOptions(request: ListTasksRequest, runtime: Util.RuntimeOptions): ListTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskStatus)) {
    query['TaskStatus'] = request.taskStatus;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTasks',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTasks(request: ListTasksRequest): ListTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTasksWithOptions(request, runtime);
}

model ListZonesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListZonesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  zones?: {
    zone?: [ 
    {
      zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-i'),
    }
  ](name='Zone')
  }(name='Zones', description='The zones available in the current region.'),
}

model ListZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListZonesResponseBody(name='body'),
}

/**
  * ## [](#)Usage notes
  * *   You can call the operation to query zones available in a specified region.
  *
  * @param request ListZonesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListZonesResponse
 */
async function listZonesWithOptions(request: ListZonesRequest, runtime: Util.RuntimeOptions): ListZonesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListZones',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## [](#)Usage notes
  * *   You can call the operation to query zones available in a specified region.
  *
  * @param request ListZonesRequest
  * @return ListZonesResponse
 */
async function listZones(request: ListZonesRequest): ListZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listZonesWithOptions(request, runtime);
}

model RebootInstancesRequest {
  force?: boolean(name='Force', description='Specifies whether to forcefully restart the instance. Valid values:

*   true If you set this parameter to true, cache data that is not written to storage in the instance will be lost after you call this operation, which is similar to the effect of a power-off action.
*   false (default)', example='false'),
  instanceId?: [ string ](name='InstanceId', description='The instance IDs.', example='cp-xxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RebootInstancesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model RebootInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RebootInstancesResponseBody(name='body'),
}

async function rebootInstancesWithOptions(request: RebootInstancesRequest, runtime: Util.RuntimeOptions): RebootInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RebootInstances',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rebootInstances(request: RebootInstancesRequest): RebootInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return rebootInstancesWithOptions(request, runtime);
}

model RenewInstancesRequest {
  autoPay?: boolean(name='AutoPay', description='Specifies whether to enable auto-payment. Default value: true.', example='false'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see How to ensure idempotence.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  instanceId?: [ string ](name='InstanceId', description='The IDs of the instances that you want to renew. You can renew up to 20 instances at a time.', example='cp-xxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period', description='The renewal period. Default value: 1.', example='1'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the renewal period.

*   Valid values if you set this parameter to Year: 1, 2, 3, 4, and 5.
*   Valid values if you set this parameter to Month (default): 1, 2, 3, and 6.
*   Valid values if you set this parameter to Hour: 1.', example='Month'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RenewInstancesResponseBody = {
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds', description='The IDs of the instances that are renewed.'),
  orderId?: string(name='OrderId', description='The order ID.', example='10000'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model RenewInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenewInstancesResponseBody(name='body'),
}

/**
  * *   You can call the operation to renew multiple ECP instances at a time.
  *
  * @param request RenewInstancesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return RenewInstancesResponse
 */
async function renewInstancesWithOptions(request: RenewInstancesRequest, runtime: Util.RuntimeOptions): RenewInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenewInstances',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   You can call the operation to renew multiple ECP instances at a time.
  *
  * @param request RenewInstancesRequest
  * @return RenewInstancesResponse
 */
async function renewInstances(request: RenewInstancesRequest): RenewInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewInstancesWithOptions(request, runtime);
}

model ResetInstancesRequest {
  imageId?: string(name='ImageId', description='The image ID of the instance. If you do not specify this parameter, the image of the current instance is used to reset the instance.', example='cpm-xxxxxx'),
  instanceId?: [ string ](name='InstanceId', description='The instance IDs. Valid values of N: 1 to 100.', example='cp-xxxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ResetInstancesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model ResetInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetInstancesResponseBody(name='body'),
}

/**
  * ## [](#)Usage notes
  * When you call this operation, take note of the following items:
  * *   This operation is valid only for ECP instances that are in the Stopped state.
  * *   If the images based on which the instances are created are deleted, the instances cannot be reset.
  *
  * @param request ResetInstancesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ResetInstancesResponse
 */
async function resetInstancesWithOptions(request: ResetInstancesRequest, runtime: Util.RuntimeOptions): ResetInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetInstances',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## [](#)Usage notes
  * When you call this operation, take note of the following items:
  * *   This operation is valid only for ECP instances that are in the Stopped state.
  * *   If the images based on which the instances are created are deleted, the instances cannot be reset.
  *
  * @param request ResetInstancesRequest
  * @return ResetInstancesResponse
 */
async function resetInstances(request: ResetInstancesRequest): ResetInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetInstancesWithOptions(request, runtime);
}

model RunCommandRequest {
  command?: string(name='Command', description='The command that you want to run.\\
The name can be up to 1024 bytes in length and can contain only letters, digits, underscores (\\_), periods (.), slashes (/), colons (:), and hyphens (-).', example='ls -al /'),
  instanceId?: [ string ](name='InstanceId', description='The IDs of the instances on which you want to run the command.\\
Valid values of N: 1 to 10.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RunCommandResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='55C15B1C-D507-45F0-B490-69D6E0F113C6'),
  taskId?: {
    taskId?: [ string ](name='TaskId')
  }(name='TaskId', description='The task IDs.'),
}

model RunCommandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RunCommandResponseBody(name='body'),
}

async function runCommandWithOptions(request: RunCommandRequest, runtime: Util.RuntimeOptions): RunCommandResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.command)) {
    query['Command'] = request.command;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RunCommand',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runCommand(request: RunCommandRequest): RunCommandResponse {
  var runtime = new Util.RuntimeOptions{};
  return runCommandWithOptions(request, runtime);
}

model RunInstancesRequest {
  amount?: int32(name='Amount', description='The number of ECS instances that you want to create. Valid values: 1 to 100.

Default value: 1.', example='10'),
  autoPay?: boolean(name='AutoPay', description='Specifies whether to enable the auto-payment feature. Default value: true.', example='true'),
  autoRenew?: boolean(name='AutoRenew', description='Specifies whether to enable the auto-renewal feature. This parameter takes effect only if you set InstanceChargeType to PrePaid. Valid values:

*   true
*   false (default)', example='true'),
  chargeType?: string(name='ChargeType', description='The billing method of the ECP instance. Valid values:

*   PrePaid: subscription
*   PostPaid (default): pay-as-you-go', example='PostPaid'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see How to ensure idempotence.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  description?: string(name='Description', description='The description of the ECP instance. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.', example='cloudphone instance'),
  eipBandwidth?: int32(name='EipBandwidth', description='The bandwidth of the elastic IP address (EIP). Valid values: 1 to 200. If you specify this parameter, an ECP instance that uses an EIP with specified bandwidth is automatically created and associated with the ECP instance. If the ECP instance is released, the EIP is also released.', example='2'),
  imageId?: string(name='ImageId', description='The ID of the image.', example='cpm-xxxx'),
  instanceName?: string(name='InstanceName', description='The name of the ECP instance. The name must be 2 to 128 characters in length. It must start with a letter but cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\\_), periods (.), and hyphens (-). The default value of this parameter is the value of the InstanceId parameter.', example='instance'),
  instanceType?: string(name='InstanceType', description='The specifications of the ECP instance.', example='ecp.ce.large'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair that you want to use to connect to the instance. You can call the ImportKeyPair operation to import a key pair for cloud phones.', example='keypair'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: long(name='Period', description='The subscription duration. Default value: 1.

*   Valid values if you set PeriodUnit to Month: 1, 2, 3, and 6.
*   Valid values if you set PeriodUnit to Year: 1, 2, 3, 4, and 5.', example='1'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the subscription duration. Valid values:

*   Year
*   Month (default)', example='Month'),
  privateIpAddress?: string(name='PrivateIpAddress', description='The private IP address of the cloud phone. When you configure a private IP address for an ECP instance, you must select an idle CIDR block from the CIDR blocks of the vSwitch (VSwitchId). When you specify this parameter, take note of the following items: After you specify the PrivateIpAddress parameter, you must set Amount to 1, which indicates that a cloud phone with a specific private IP address is created.', example='192.168.157.224'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  resolution?: string(name='Resolution', description='The resolution that you want to select for the ECP instance. You can query the resolutions that are supported by the current instance by calling the DescribeInstanceTypes operation and select an appropriate resolution.', example='1920*1080'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group that the ECP instance uses. The security group is the same as that of the Elastic Compute Service (ECS) instance that you use.', example='sg-xxxxx'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key of the ECP instance. Valid values of N: 1 to 20.', example='TestKey'),
      value?: string(name='Value', description='The tag value of the ECP instance. Valid values of N: 1 to 20.', example='TestValue'),
    }
  ](name='Tag', description='The tags of the ECP instance.'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-xxxx'),
}

model RunInstancesResponseBody = {
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds', description='The IDs of the ECP instances.'),
  orderId?: string(name='OrderId', description='The ID of the order.', example='9611111323245'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  tradePrice?: float(name='TradePrice', description='The price of the ECP resource.', example='133.32'),
}

model RunInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RunInstancesResponseBody(name='body'),
}

/**
  * Preparations:
  * *   The real-name verification is complete. For more information, see [Real-name verification](~~428525~~).
  * Precautions:
  * *   You can create up to 100 ECP instances at a time.
  * *   You can call this operation to create and start ECP instances.
  * *   If an ECP instance fails to be created due to force majeure factors, such as insufficient inventory, the ECP instance is automatically rolled back and released.
  *
  * @param request RunInstancesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return RunInstancesResponse
 */
async function runInstancesWithOptions(request: RunInstancesRequest, runtime: Util.RuntimeOptions): RunInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.amount)) {
    query['Amount'] = request.amount;
  }
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eipBandwidth)) {
    query['EipBandwidth'] = request.eipBandwidth;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resolution)) {
    query['Resolution'] = request.resolution;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RunInstances',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Preparations:
  * *   The real-name verification is complete. For more information, see [Real-name verification](~~428525~~).
  * Precautions:
  * *   You can create up to 100 ECP instances at a time.
  * *   You can call this operation to create and start ECP instances.
  * *   If an ECP instance fails to be created due to force majeure factors, such as insufficient inventory, the ECP instance is automatically rolled back and released.
  *
  * @param request RunInstancesRequest
  * @return RunInstancesResponse
 */
async function runInstances(request: RunInstancesRequest): RunInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return runInstancesWithOptions(request, runtime);
}

model SendFileRequest {
  instanceId?: [ string ](name='InstanceId', description='The IDs of the instances on which you want to run the command. Valid values of N: 1 to 10.'),
  ossBucket?: string(name='OssBucket', description='The Object Storage Service (OSS) bucket to which you want to upload the file.

>  Before you import an APK file to the OSS bucket for the first time, add a Resource Access Management (RAM) policy. Otherwise, NoSetRoletoECSServiceAcount appears.', example='The ID of instance N on which you want to run commands. Valid values of N: 1 to 10.'),
  ossObject?: string(name='OssObject', description='The name (key) of the file that you want to use as an OSS object.', example='test.txt'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  path?: string(name='Path', description='The directory of the file that you want to pull in the cloud phone.', example='/sdcard'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SendFileResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  taskId?: {
    taskId?: [ string ](name='TaskId')
  }(name='TaskId', description='The task IDs. Valid values of N: 1 to 100.'),
}

model SendFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SendFileResponseBody(name='body'),
}

async function sendFileWithOptions(request: SendFileRequest, runtime: Util.RuntimeOptions): SendFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ossBucket)) {
    query['OssBucket'] = request.ossBucket;
  }
  if (!Util.isUnset(request.ossObject)) {
    query['OssObject'] = request.ossObject;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SendFile',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendFile(request: SendFileRequest): SendFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendFileWithOptions(request, runtime);
}

model StartInstancesRequest {
  instanceId?: [ string ](name='InstanceId', description='The instance IDs.', example='cp-xxxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model StartInstancesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model StartInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartInstancesResponseBody(name='body'),
}

async function startInstancesWithOptions(request: StartInstancesRequest, runtime: Util.RuntimeOptions): StartInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartInstances',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startInstances(request: StartInstancesRequest): StartInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return startInstancesWithOptions(request, runtime);
}

model StopInstancesRequest {
  force?: boolean(name='Force', description='Specifies whether to forcefully stop the instance. Valid values:

*   true. If you set this parameter to true, cache data that is not written to storage in the instance will be lost after you call this operation, which is similar to the effect of a power-off action.
*   false (default)', example='false'),
  instanceId?: [ string ](name='InstanceId', description='The instance IDs. Valid values of N: 1 to 100.', example='cp-xxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model StopInstancesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model StopInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopInstancesResponseBody(name='body'),
}

async function stopInstancesWithOptions(request: StopInstancesRequest, runtime: Util.RuntimeOptions): StopInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopInstances',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopInstances(request: StopInstancesRequest): StopInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopInstancesWithOptions(request, runtime);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs. You can specify up to 50 resources.'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType', description='The resource type. Valid value:

*   instance: Elastic Cloud Phone (ECP) instance', example='instance'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='TestKey'),
      value?: string(name='Value', description='The tag value.', example='TestValue'),
    }
  ](name='Tag', description='The tags. You can specify up to 20 tags.'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UninstallApplicationRequest {
  instanceId?: [ string ](name='InstanceId', description='The IDs of the instances on which you want to run the command. Valid values of N: 1 to 10.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  packageName?: string(name='PackageName', description='The name of the application that you want to uninstall. The name can be up to 1024 bytes in length and can contain only letters, digits, underscores (\\_), periods (.), slashes (/), colons (:), and hyphens (-).', example='com.theapp.test'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UninstallApplicationResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='55C15B1C-D507-45F0-B490-69D6E0F113C6'),
  taskId?: {
    taskId?: [ string ](name='TaskId')
  }(name='TaskId', description='The task ID.'),
}

model UninstallApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallApplicationResponseBody(name='body'),
}

async function uninstallApplicationWithOptions(request: UninstallApplicationRequest, runtime: Util.RuntimeOptions): UninstallApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.packageName)) {
    query['PackageName'] = request.packageName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallApplication',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uninstallApplication(request: UninstallApplicationRequest): UninstallApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallApplicationWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to delete all tags. This parameter takes effect only when the TagKey.N parameter is not specified. Valid values: true and false. Default value: false.', example='true'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs. You can specify up to 50 resources.'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType', description='The resource type. Valid value:

*   instance: Elastic Cloud Phone (ECP) instance', example='instance'),
  tagKey?: [ string ](name='TagKey', description='The tag keys. You can specify up to 20 tag keys.'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateImageAttributeRequest {
  addAccount?: [ string ](name='AddAccount', description='The IDs of the Alibaba Cloud accounts that are authorized to share images. You can specify up to 10 Alibaba Cloud accounts.', example='123456******'),
  description?: string(name='Description', description='The description of the custom image. The description must be 2 to 256 characters in length. It cannot start with `http://` or `https://`. By default, this parameter is empty, which indicates that the original description is retained.', example='newDescription'),
  imageId?: string(name='ImageId', description='The image ID.', example='cpm-xxxxxxxx'),
  imageName?: string(name='ImageName', description='The name of the custom image. The name must be 2 to 128 characters in length. The name can contain letters, digits, colons (:), underscores (\\_), and hyphens (-). It cannot start with `http://` or `https://`. By default, this parameter is empty, which indicates that the original name is retained.', example='newImageName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  removeAccount?: [ string ](name='RemoveAccount', description='The IDs of the Alibaba Cloud accounts from which you want to revoke image sharing permissions. You can specify up to 10 Alibaba Cloud accounts.', example='987654******'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdateImageAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model UpdateImageAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateImageAttributeResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following items:
  * *   You can share only your own custom images with other Alibaba Cloud accounts.
  * *   You can share a custom image with up to 10 Alibaba Cloud accounts at a time.
  *
  * @param request UpdateImageAttributeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateImageAttributeResponse
 */
async function updateImageAttributeWithOptions(request: UpdateImageAttributeRequest, runtime: Util.RuntimeOptions): UpdateImageAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addAccount)) {
    query['AddAccount'] = request.addAccount;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.removeAccount)) {
    query['RemoveAccount'] = request.removeAccount;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateImageAttribute',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * When you call this operation, take note of the following items:
  * *   You can share only your own custom images with other Alibaba Cloud accounts.
  * *   You can share a custom image with up to 10 Alibaba Cloud accounts at a time.
  *
  * @param request UpdateImageAttributeRequest
  * @return UpdateImageAttributeResponse
 */
async function updateImageAttribute(request: UpdateImageAttributeRequest): UpdateImageAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateImageAttributeWithOptions(request, runtime);
}

model UpdateInstanceAttributeRequest {
  description?: string(name='Description', description='The instance description. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.', example='myDescription'),
  instanceId?: string(name='InstanceId', description='The instance ID.', example='cp-bp67acfmxazb4p***'),
  instanceName?: string(name='InstanceName', description='The instance name. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. The name can contain letters, digits, colons (:), underscores (\\_), and hyphens (-).', example='myInstanceName'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair that is used to connect to the instance. To improve the security of an instance, we recommend that you use a key pair to connect to the instance.', example='myKeyPairName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  resolution?: string(name='Resolution', description='The instance resolution.', example='1920*1080'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key of the instance. Valid values of N: 1 to 20.', example='TestKey'),
      value?: string(name='Value', description='The tag value of the instance. Valid values of N: 1 to 20.', example='TestValue'),
    }
  ](name='Tag', description='Details of tags.'),
  vncPassword?: string(name='VncPassword', description='The VNC password of the instance. The password must be six characters in length and can contain only uppercase letters, lowercase letters, and digits.', example='Cp1234'),
}

model UpdateInstanceAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='FDB6C963-9CE8-4B7F-BCA3-845F6BD29AFC'),
}

model UpdateInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceAttributeResponseBody(name='body'),
}

/**
  * You can call this operation to modify the name, key pair, Virtual Network Computing (VNC) password, and resolution of an ECP instance. Take note that the modified key pair and resolution takes effect the next time you restart the instance.
  *
  * @param request UpdateInstanceAttributeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateInstanceAttributeResponse
 */
async function updateInstanceAttributeWithOptions(request: UpdateInstanceAttributeRequest, runtime: Util.RuntimeOptions): UpdateInstanceAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resolution)) {
    query['Resolution'] = request.resolution;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vncPassword)) {
    query['VncPassword'] = request.vncPassword;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstanceAttribute',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this operation to modify the name, key pair, Virtual Network Computing (VNC) password, and resolution of an ECP instance. Take note that the modified key pair and resolution takes effect the next time you restart the instance.
  *
  * @param request UpdateInstanceAttributeRequest
  * @return UpdateInstanceAttributeResponse
 */
async function updateInstanceAttribute(request: UpdateInstanceAttributeRequest): UpdateInstanceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateInstanceAttributeWithOptions(request, runtime);
}

