/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('cloudphone', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CancelTaskRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  taskId?: string(name='TaskId'),
}

model CancelTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelTaskResponseBody(name='body'),
}

async function cancelTaskWithOptions(request: CancelTaskRequest, runtime: Util.RuntimeOptions): CancelTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelTask',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelTask(request: CancelTaskRequest): CancelTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelTaskWithOptions(request, runtime);
}

model CopyImageRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  destinationRegionId?: string(name='DestinationRegionId'),
  imageId?: string(name='ImageId'),
  imageName?: string(name='ImageName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CopyImageResponseBody = {
  imageId?: string(name='ImageId'),
  requestId?: string(name='RequestId'),
}

model CopyImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CopyImageResponseBody(name='body'),
}

async function copyImageWithOptions(request: CopyImageRequest, runtime: Util.RuntimeOptions): CopyImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.destinationRegionId)) {
    query['DestinationRegionId'] = request.destinationRegionId;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CopyImage',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function copyImage(request: CopyImageRequest): CopyImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyImageWithOptions(request, runtime);
}

model CreateImageRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  imageName?: string(name='ImageName'),
  instanceId?: string(name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateImageResponseBody = {
  imageId?: string(name='ImageId'),
  requestId?: string(name='RequestId'),
}

model CreateImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateImageResponseBody(name='body'),
}

async function createImageWithOptions(request: CreateImageRequest, runtime: Util.RuntimeOptions): CreateImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateImage',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createImage(request: CreateImageRequest): CreateImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createImageWithOptions(request, runtime);
}

model DeleteImagesRequest {
  force?: boolean(name='Force'),
  imageId?: [ string ](name='ImageId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteImagesResponseBody = {
  imageResponses?: {
    imageResponse?: [ 
    {
      code?: string(name='Code'),
      imageId?: string(name='ImageId'),
      message?: string(name='Message'),
    }
  ](name='ImageResponse')
  }(name='ImageResponses'),
  requestId?: string(name='RequestId'),
}

model DeleteImagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteImagesResponseBody(name='body'),
}

async function deleteImagesWithOptions(request: DeleteImagesRequest, runtime: Util.RuntimeOptions): DeleteImagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteImages',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteImages(request: DeleteImagesRequest): DeleteImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImagesWithOptions(request, runtime);
}

model DeleteInstancesRequest {
  force?: boolean(name='Force'),
  instanceId?: [ string ](name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteInstancesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstancesResponseBody(name='body'),
}

async function deleteInstancesWithOptions(request: DeleteInstancesRequest, runtime: Util.RuntimeOptions): DeleteInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstances',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInstances(request: DeleteInstancesRequest): DeleteInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstancesWithOptions(request, runtime);
}

model DeleteKeyPairsRequest {
  keyPairName?: [ string ](name='KeyPairName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteKeyPairsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteKeyPairsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteKeyPairsResponseBody(name='body'),
}

async function deleteKeyPairsWithOptions(request: DeleteKeyPairsRequest, runtime: Util.RuntimeOptions): DeleteKeyPairsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteKeyPairs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteKeyPairs(request: DeleteKeyPairsRequest): DeleteKeyPairsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteKeyPairsWithOptions(request, runtime);
}

model FetchFileRequest {
  instanceId?: string(name='InstanceId'),
  ossBucket?: string(name='OssBucket'),
  ossObject?: string(name='OssObject'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  path?: string(name='Path'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model FetchFileResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model FetchFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FetchFileResponseBody(name='body'),
}

async function fetchFileWithOptions(request: FetchFileRequest, runtime: Util.RuntimeOptions): FetchFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ossBucket)) {
    query['OssBucket'] = request.ossBucket;
  }
  if (!Util.isUnset(request.ossObject)) {
    query['OssObject'] = request.ossObject;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FetchFile',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function fetchFile(request: FetchFileRequest): FetchFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return fetchFileWithOptions(request, runtime);
}

model ImportImageRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  format?: string(name='Format'),
  imageName?: string(name='ImageName'),
  ossBucket?: string(name='OssBucket'),
  ossObject?: string(name='OssObject'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  platform?: string(name='Platform'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ImportImageResponseBody = {
  imageId?: string(name='ImageId'),
  requestId?: string(name='RequestId'),
}

model ImportImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ImportImageResponseBody(name='body'),
}

async function importImageWithOptions(request: ImportImageRequest, runtime: Util.RuntimeOptions): ImportImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.format)) {
    query['Format'] = request.format;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.ossBucket)) {
    query['OssBucket'] = request.ossBucket;
  }
  if (!Util.isUnset(request.ossObject)) {
    query['OssObject'] = request.ossObject;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.platform)) {
    query['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportImage',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importImage(request: ImportImageRequest): ImportImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return importImageWithOptions(request, runtime);
}

model ImportKeyPairRequest {
  keyPairName?: string(name='KeyPairName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  publicKeyBody?: string(name='PublicKeyBody'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ImportKeyPairResponseBody = {
  keyPairFingerPrint?: string(name='KeyPairFingerPrint'),
  keyPairName?: string(name='KeyPairName'),
  requestId?: string(name='RequestId'),
}

model ImportKeyPairResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ImportKeyPairResponseBody(name='body'),
}

async function importKeyPairWithOptions(request: ImportKeyPairRequest, runtime: Util.RuntimeOptions): ImportKeyPairResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.publicKeyBody)) {
    query['PublicKeyBody'] = request.publicKeyBody;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportKeyPair',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importKeyPair(request: ImportKeyPairRequest): ImportKeyPairResponse {
  var runtime = new Util.RuntimeOptions{};
  return importKeyPairWithOptions(request, runtime);
}

model InstallApplicationRequest {
  instanceId?: [ string ](name='InstanceId'),
  ossBucket?: string(name='OssBucket'),
  ossObject?: string(name='OssObject'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model InstallApplicationResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: {
    taskId?: [ string ](name='TaskId')
  }(name='TaskId'),
}

model InstallApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallApplicationResponseBody(name='body'),
}

async function installApplicationWithOptions(request: InstallApplicationRequest, runtime: Util.RuntimeOptions): InstallApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ossBucket)) {
    query['OssBucket'] = request.ossBucket;
  }
  if (!Util.isUnset(request.ossObject)) {
    query['OssObject'] = request.ossObject;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallApplication',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installApplication(request: InstallApplicationRequest): InstallApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return installApplicationWithOptions(request, runtime);
}

model ListImageSharePermissionRequest {
  imageId?: string(name='ImageId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListImageSharePermissionResponseBody = {
  accounts?: {
    account?: [ 
    {
      aliyunId?: string(name='AliyunId'),
    }
  ](name='Account')
  }(name='Accounts'),
  requestId?: string(name='RequestId'),
}

model ListImageSharePermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListImageSharePermissionResponseBody(name='body'),
}

async function listImageSharePermissionWithOptions(request: ListImageSharePermissionRequest, runtime: Util.RuntimeOptions): ListImageSharePermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListImageSharePermission',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listImageSharePermission(request: ListImageSharePermissionRequest): ListImageSharePermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listImageSharePermissionWithOptions(request, runtime);
}

model ListImagesRequest {
  imageCategory?: string(name='ImageCategory'),
  imageId?: [ string ](name='ImageId'),
  imageName?: string(name='ImageName'),
  instanceType?: string(name='InstanceType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: string(name='Status'),
}

model ListImagesResponseBody = {
  images?: {
    image?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      imageCategory?: string(name='ImageCategory'),
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      isSelfShared?: boolean(name='IsSelfShared'),
      OSName?: string(name='OSName'),
      OSNameEn?: string(name='OSNameEn'),
      OSType?: string(name='OSType'),
      platform?: string(name='Platform'),
      progress?: string(name='Progress'),
      status?: string(name='Status'),
      usage?: string(name='Usage'),
    }
  ](name='Image')
  }(name='Images'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListImagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListImagesResponseBody(name='body'),
}

async function listImagesWithOptions(request: ListImagesRequest, runtime: Util.RuntimeOptions): ListImagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageCategory)) {
    query['ImageCategory'] = request.imageCategory;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListImages',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listImages(request: ListImagesRequest): ListImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listImagesWithOptions(request, runtime);
}

model ListInstanceTypesRequest {
  instanceType?: [ string ](name='InstanceType'),
  instanceTypeFamily?: string(name='InstanceTypeFamily'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListInstanceTypesResponseBody = {
  instanceTypes?: {
    instanceType?: [ 
    {
      cpuCoreCount?: int32(name='CpuCoreCount'),
      defaultResolution?: string(name='DefaultResolution'),
      instanceType?: string(name='InstanceType'),
      instanceTypeFamily?: string(name='InstanceTypeFamily'),
      memorySize?: string(name='MemorySize'),
      name?: string(name='Name'),
      nameEn?: string(name='NameEn'),
      resolutions?: {
        resolution?: [ string ](name='Resolution')
      }(name='Resolutions'),
    }
  ](name='InstanceType')
  }(name='InstanceTypes'),
  requestId?: string(name='RequestId'),
}

model ListInstanceTypesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceTypesResponseBody(name='body'),
}

async function listInstanceTypesWithOptions(request: ListInstanceTypesRequest, runtime: Util.RuntimeOptions): ListInstanceTypesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.instanceTypeFamily)) {
    query['InstanceTypeFamily'] = request.instanceTypeFamily;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceTypes',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstanceTypes(request: ListInstanceTypesRequest): ListInstanceTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceTypesWithOptions(request, runtime);
}

model ListInstanceVncUrlRequest {
  instanceId?: string(name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListInstanceVncUrlResponseBody = {
  requestId?: string(name='RequestId'),
  vncUrl?: string(name='VncUrl'),
  webRtcToken?: string(name='WebRtcToken'),
}

model ListInstanceVncUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceVncUrlResponseBody(name='body'),
}

async function listInstanceVncUrlWithOptions(request: ListInstanceVncUrlRequest, runtime: Util.RuntimeOptions): ListInstanceVncUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceVncUrl',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstanceVncUrl(request: ListInstanceVncUrlRequest): ListInstanceVncUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceVncUrlWithOptions(request, runtime);
}

model ListInstancesRequest {
  chargeType?: string(name='ChargeType'),
  imageId?: string(name='ImageId'),
  instanceId?: [ string ](name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  instanceType?: string(name='InstanceType'),
  keyPairName?: string(name='KeyPairName'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resolution?: string(name='Resolution'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  showWebRtcToken?: boolean(name='ShowWebRtcToken'),
  status?: string(name='Status'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  zoneId?: string(name='ZoneId'),
}

model ListInstancesResponseBody = {
  instances?: {
    instance?: [ 
    {
      autoRenew?: boolean(name='AutoRenew'),
      chargeType?: string(name='ChargeType'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      eipAddress?: {
        allocationId?: string(name='AllocationId'),
        bandwidth?: int32(name='Bandwidth'),
        internetChargeType?: string(name='InternetChargeType'),
        ipAddress?: string(name='IpAddress'),
      }(name='EipAddress'),
      expiredTime?: string(name='ExpiredTime'),
      imageId?: string(name='ImageId'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      instanceType?: string(name='InstanceType'),
      keyPairName?: string(name='KeyPairName'),
      osName?: string(name='OsName'),
      osNameEn?: string(name='OsNameEn'),
      regionId?: string(name='RegionId'),
      resolution?: string(name='Resolution'),
      securityGroupId?: string(name='SecurityGroupId'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vpcAttributes?: {
        privateIpAddress?: string(name='PrivateIpAddress'),
        vSwitchId?: string(name='VSwitchId'),
      }(name='VpcAttributes'),
      webRtcToken?: string(name='WebRtcToken'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Instance')
  }(name='Instances'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstancesWithOptions(request: ListInstancesRequest, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resolution)) {
    query['Resolution'] = request.resolution;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.showWebRtcToken)) {
    query['ShowWebRtcToken'] = request.showWebRtcToken;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstancesWithOptions(request, runtime);
}

model ListKeyPairsRequest {
  keyPairFingerPrint?: string(name='KeyPairFingerPrint'),
  keyPairName?: string(name='KeyPairName'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListKeyPairsResponseBody = {
  keyPairs?: {
    keyPair?: [ 
    {
      creationTime?: string(name='CreationTime'),
      keyPairFingerPrint?: string(name='KeyPairFingerPrint'),
      keyPairName?: string(name='KeyPairName'),
    }
  ](name='KeyPair')
  }(name='KeyPairs'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListKeyPairsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListKeyPairsResponseBody(name='body'),
}

async function listKeyPairsWithOptions(request: ListKeyPairsRequest, runtime: Util.RuntimeOptions): ListKeyPairsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyPairFingerPrint)) {
    query['KeyPairFingerPrint'] = request.keyPairFingerPrint;
  }
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListKeyPairs',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listKeyPairs(request: ListKeyPairsRequest): ListKeyPairsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listKeyPairsWithOptions(request, runtime);
}

model ListRegionsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model ListRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRegionsResponseBody(name='body'),
}

async function listRegionsWithOptions(request: ListRegionsRequest, runtime: Util.RuntimeOptions): ListRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRegions',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRegions(request: ListRegionsRequest): ListRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRegionsWithOptions(request, runtime);
}

model ListTagKeysRequest {
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType'),
}

model ListTagKeysResponseBody = {
  keys?: {
    key?: [ string ](name='Key')
  }(name='Keys'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListTagKeysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagKeysResponseBody(name='body'),
}

async function listTagKeysWithOptions(request: ListTagKeysRequest, runtime: Util.RuntimeOptions): ListTagKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagKeys',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagKeys(request: ListTagKeysRequest): ListTagKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagKeysWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListTagValuesRequest {
  key?: string(name='Key'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType'),
}

model ListTagValuesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  values?: {
    value?: [ string ](name='Value')
  }(name='Values'),
}

model ListTagValuesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagValuesResponseBody(name='body'),
}

async function listTagValuesWithOptions(request: ListTagValuesRequest, runtime: Util.RuntimeOptions): ListTagValuesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagValues',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagValues(request: ListTagValuesRequest): ListTagValuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagValuesWithOptions(request, runtime);
}

model ListTasksRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  taskId?: [ string ](name='TaskId'),
  taskStatus?: string(name='TaskStatus'),
  taskType?: string(name='TaskType'),
}

model ListTasksResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  tasks?: {
    task?: [ 
    {
      createTime?: string(name='CreateTime'),
      executeMsg?: string(name='ExecuteMsg'),
      finishedTime?: string(name='FinishedTime'),
      instanceId?: string(name='InstanceId'),
      progress?: string(name='Progress'),
      taskId?: string(name='TaskId'),
      taskStatus?: string(name='TaskStatus'),
      taskType?: string(name='TaskType'),
    }
  ](name='Task')
  }(name='Tasks'),
  totalCount?: int32(name='TotalCount'),
}

model ListTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTasksResponseBody(name='body'),
}

async function listTasksWithOptions(request: ListTasksRequest, runtime: Util.RuntimeOptions): ListTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskStatus)) {
    query['TaskStatus'] = request.taskStatus;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTasks',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTasks(request: ListTasksRequest): ListTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTasksWithOptions(request, runtime);
}

model ListZonesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: {
    zone?: [ 
    {
      zoneId?: string(name='ZoneId'),
    }
  ](name='Zone')
  }(name='Zones'),
}

model ListZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListZonesResponseBody(name='body'),
}

async function listZonesWithOptions(request: ListZonesRequest, runtime: Util.RuntimeOptions): ListZonesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListZones',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listZones(request: ListZonesRequest): ListZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listZonesWithOptions(request, runtime);
}

model RebootInstancesRequest {
  force?: boolean(name='Force'),
  instanceId?: [ string ](name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RebootInstancesResponseBody = {
  requestId?: string(name='RequestId'),
}

model RebootInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RebootInstancesResponseBody(name='body'),
}

async function rebootInstancesWithOptions(request: RebootInstancesRequest, runtime: Util.RuntimeOptions): RebootInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RebootInstances',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rebootInstances(request: RebootInstancesRequest): RebootInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return rebootInstancesWithOptions(request, runtime);
}

model RenewInstancesRequest {
  autoPay?: boolean(name='AutoPay'),
  clientToken?: string(name='ClientToken'),
  instanceId?: [ string ](name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RenewInstancesResponseBody = {
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenewInstancesResponseBody(name='body'),
}

async function renewInstancesWithOptions(request: RenewInstancesRequest, runtime: Util.RuntimeOptions): RenewInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenewInstances',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function renewInstances(request: RenewInstancesRequest): RenewInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewInstancesWithOptions(request, runtime);
}

model ResetInstancesRequest {
  imageId?: string(name='ImageId'),
  instanceId?: [ string ](name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ResetInstancesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetInstancesResponseBody(name='body'),
}

async function resetInstancesWithOptions(request: ResetInstancesRequest, runtime: Util.RuntimeOptions): ResetInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetInstances',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetInstances(request: ResetInstancesRequest): ResetInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetInstancesWithOptions(request, runtime);
}

model RunCommandRequest {
  command?: string(name='Command'),
  instanceId?: [ string ](name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RunCommandResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: {
    taskId?: [ string ](name='TaskId')
  }(name='TaskId'),
}

model RunCommandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RunCommandResponseBody(name='body'),
}

async function runCommandWithOptions(request: RunCommandRequest, runtime: Util.RuntimeOptions): RunCommandResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.command)) {
    query['Command'] = request.command;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RunCommand',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runCommand(request: RunCommandRequest): RunCommandResponse {
  var runtime = new Util.RuntimeOptions{};
  return runCommandWithOptions(request, runtime);
}

model RunInstancesRequest {
  amount?: int32(name='Amount'),
  autoPay?: boolean(name='AutoPay'),
  autoRenew?: boolean(name='AutoRenew'),
  chargeType?: string(name='ChargeType'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  eipBandwidth?: int32(name='EipBandwidth'),
  imageId?: string(name='ImageId'),
  instanceName?: string(name='InstanceName'),
  instanceType?: string(name='InstanceType'),
  keyPairName?: string(name='KeyPairName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: long(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  regionId?: string(name='RegionId'),
  resolution?: string(name='Resolution'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  securityGroupId?: string(name='SecurityGroupId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vSwitchId?: string(name='VSwitchId'),
}

model RunInstancesResponseBody = {
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  tradePrice?: float(name='TradePrice'),
}

model RunInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RunInstancesResponseBody(name='body'),
}

async function runInstancesWithOptions(request: RunInstancesRequest, runtime: Util.RuntimeOptions): RunInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.amount)) {
    query['Amount'] = request.amount;
  }
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eipBandwidth)) {
    query['EipBandwidth'] = request.eipBandwidth;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resolution)) {
    query['Resolution'] = request.resolution;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RunInstances',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runInstances(request: RunInstancesRequest): RunInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return runInstancesWithOptions(request, runtime);
}

model SendFileRequest {
  instanceId?: [ string ](name='InstanceId'),
  ossBucket?: string(name='OssBucket'),
  ossObject?: string(name='OssObject'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  path?: string(name='Path'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SendFileResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: {
    taskId?: [ string ](name='TaskId')
  }(name='TaskId'),
}

model SendFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SendFileResponseBody(name='body'),
}

async function sendFileWithOptions(request: SendFileRequest, runtime: Util.RuntimeOptions): SendFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ossBucket)) {
    query['OssBucket'] = request.ossBucket;
  }
  if (!Util.isUnset(request.ossObject)) {
    query['OssObject'] = request.ossObject;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SendFile',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendFile(request: SendFileRequest): SendFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendFileWithOptions(request, runtime);
}

model StartInstancesRequest {
  instanceId?: [ string ](name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model StartInstancesResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartInstancesResponseBody(name='body'),
}

async function startInstancesWithOptions(request: StartInstancesRequest, runtime: Util.RuntimeOptions): StartInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartInstances',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startInstances(request: StartInstancesRequest): StartInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return startInstancesWithOptions(request, runtime);
}

model StopInstancesRequest {
  force?: boolean(name='Force'),
  instanceId?: [ string ](name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model StopInstancesResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopInstancesResponseBody(name='body'),
}

async function stopInstancesWithOptions(request: StopInstancesRequest, runtime: Util.RuntimeOptions): StopInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopInstances',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopInstances(request: StopInstancesRequest): StopInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopInstancesWithOptions(request, runtime);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UninstallApplicationRequest {
  instanceId?: [ string ](name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  packageName?: string(name='PackageName'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UninstallApplicationResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: {
    taskId?: [ string ](name='TaskId')
  }(name='TaskId'),
}

model UninstallApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallApplicationResponseBody(name='body'),
}

async function uninstallApplicationWithOptions(request: UninstallApplicationRequest, runtime: Util.RuntimeOptions): UninstallApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.packageName)) {
    query['PackageName'] = request.packageName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallApplication',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uninstallApplication(request: UninstallApplicationRequest): UninstallApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallApplicationWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateImageAttributeRequest {
  addAccount?: [ string ](name='AddAccount'),
  description?: string(name='Description'),
  imageId?: string(name='ImageId'),
  imageName?: string(name='ImageName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  removeAccount?: [ string ](name='RemoveAccount'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdateImageAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateImageAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateImageAttributeResponseBody(name='body'),
}

async function updateImageAttributeWithOptions(request: UpdateImageAttributeRequest, runtime: Util.RuntimeOptions): UpdateImageAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addAccount)) {
    query['AddAccount'] = request.addAccount;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.removeAccount)) {
    query['RemoveAccount'] = request.removeAccount;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateImageAttribute',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateImageAttribute(request: UpdateImageAttributeRequest): UpdateImageAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateImageAttributeWithOptions(request, runtime);
}

model UpdateInstanceAttributeRequest {
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  keyPairName?: string(name='KeyPairName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resolution?: string(name='Resolution'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vncPassword?: string(name='VncPassword'),
}

model UpdateInstanceAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceAttributeResponseBody(name='body'),
}

async function updateInstanceAttributeWithOptions(request: UpdateInstanceAttributeRequest, runtime: Util.RuntimeOptions): UpdateInstanceAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resolution)) {
    query['Resolution'] = request.resolution;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vncPassword)) {
    query['VncPassword'] = request.vncPassword;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstanceAttribute',
    version = '2020-12-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateInstanceAttribute(request: UpdateInstanceAttributeRequest): UpdateInstanceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateInstanceAttributeWithOptions(request, runtime);
}

