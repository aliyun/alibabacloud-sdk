/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('fc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AccelerationInfo {
  status?: string(name='status'),
}

model Alias {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName?: string(name='aliasName'),
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  versionId?: string(name='versionId'),
}

model AsyncConfig {
  createdTime?: string(name='createdTime'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  functionName?: string(name='functionName'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts'),
  qualifier?: string(name='qualifier'),
}

model CertConfig {
  certName?: string(name='certName'),
  certificate?: string(name='certificate'),
  privateKey?: string(name='privateKey'),
}

model ConcurrencyConfig {
  functionArn?: string(name='functionArn'),
  reservedConcurrency?: long(name='reservedConcurrency'),
}

model CreateAliasInput {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName?: string(name='aliasName'),
  description?: string(name='description'),
  versionId?: string(name='versionId'),
}

model CreateCustomDomainInput {
  certConfig?: CertConfig(name='certConfig'),
  domainName?: string(name='domainName'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model CreateFunctionInput {
  code?: InputCodeLocation(name='code'),
  cpu?: float(name='cpu'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description'),
  diskSize?: int32(name='diskSize'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionName?: string(name='functionName'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess'),
  layers?: [ string ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role'),
  runtime?: string(name='runtime'),
  timeout?: int32(name='timeout'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcBinding?: VPCBinding(name='vpcBinding'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model CreateLayerVersionInput {
  code?: InputCodeLocation(name='code'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  description?: string(name='description'),
  license?: string(name='license'),
}

model CreateTriggerInput {
  description?: string(name='description'),
  invocationRole?: string(name='invocationRole'),
  qualifier?: string(name='qualifier'),
  sourceArn?: string(name='sourceArn'),
  triggerConfig?: string(name='triggerConfig'),
  triggerName?: string(name='triggerName'),
  triggerType?: string(name='triggerType'),
}

model CustomContainerConfig {
  accelerationInfo?: AccelerationInfo(name='accelerationInfo'),
  accelerationType?: string(name='accelerationType'),
  acrInstanceID?: string(name='acrInstanceID'),
  command?: [ string ](name='command'),
  entrypoint?: [ string ](name='entrypoint'),
  healthCheckConfig?: CustomHealthCheckConfig(name='healthCheckConfig'),
  image?: string(name='image'),
  port?: int32(name='port'),
}

model CustomDNS {
  dnsOptions?: [
    DNSOption
  ](name='dnsOptions'),
  nameServers?: [ string ](name='nameServers'),
  searches?: [ string ](name='searches'),
}

model CustomDomain {
  accountId?: string(name='accountId'),
  apiVersion?: string(name='apiVersion'),
  certConfig?: CertConfig(name='certConfig'),
  createdTime?: string(name='createdTime'),
  domainName?: string(name='domainName'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  subdomainCount?: string(name='subdomainCount'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model CustomHealthCheckConfig {
  failureThreshold?: int32(name='failureThreshold'),
  httpGetUrl?: string(name='httpGetUrl'),
  initialDelaySeconds?: int32(name='initialDelaySeconds'),
  periodSeconds?: int32(name='periodSeconds'),
  successThreshold?: int32(name='successThreshold'),
  timeoutSeconds?: int32(name='timeoutSeconds'),
}

model CustomRuntimeConfig {
  args?: [ string ](name='args'),
  command?: [ string ](name='command'),
  healthCheckConfig?: CustomHealthCheckConfig(name='healthCheckConfig'),
  port?: int32(name='port'),
}

model DNSOption {
  name?: string(name='name'),
  value?: string(name='value'),
}

model Destination {
  destination?: string(name='destination'),
}

model DestinationConfig {
  onFailure?: Destination(name='onFailure'),
  onSuccess?: Destination(name='onSuccess'),
}

model EqualRule {
  match?: string(name='match'),
  replacement?: string(name='replacement'),
}

model Error {
  code?: string(name='code'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
}

model Function {
  codeChecksum?: string(name='codeChecksum'),
  codeSize?: long(name='codeSize'),
  cpu?: float(name='cpu'),
  createdTime?: string(name='createdTime'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description'),
  diskSize?: int32(name='diskSize'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionArn?: string(name='functionArn'),
  functionId?: string(name='functionId'),
  functionName?: string(name='functionName'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  layers?: [
    FunctionLayer
  ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role'),
  runtime?: string(name='runtime'),
  timeout?: int32(name='timeout'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcBinding?: VPCBinding(name='vpcBinding'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model FunctionLayer {
  arn?: string(name='arn'),
  size?: long(name='size'),
}

model GPUConfig {
  gpuMemorySize?: int32(name='gpuMemorySize'),
  gpuType?: string(name='gpuType'),
}

model GetResourceTagsOutput {
  resourceArn?: string(name='resourceArn'),
  tags?: map[string]string(name='tags'),
}

model HTTPTrigger {
  urlInternet?: string(name='urlInternet'),
  urlIntranet?: string(name='urlIntranet'),
}

model HealthCheckConfig {
  failureThreshold?: int32(name='failureThreshold'),
  httpGetUrl?: string(name='httpGetUrl'),
  initialDelaySeconds?: int32(name='initialDelaySeconds'),
  periodSeconds?: int32(name='periodSeconds'),
  successThreshold?: int32(name='successThreshold'),
  timeoutSeconds?: int32(name='timeoutSeconds'),
}

model InnerRewriteConfig {
  regexRules?: [
    RewriteRegexRule
  ](name='regexRules'),
}

model InputCodeLocation {
  checksum?: string(name='checksum'),
  ossBucketName?: string(name='ossBucketName'),
  ossObjectName?: string(name='ossObjectName'),
  zipFile?: string(name='zipFile'),
}

model InstanceInfo {
  instanceId?: string(name='instanceId'),
  versionId?: string(name='versionId'),
}

model InstanceLifecycleConfig {
  initializer?: LifecycleHook(name='initializer'),
  preStop?: LifecycleHook(name='preStop'),
}

model Layer {
  acl?: string(name='acl'),
  code?: OutputCodeLocation(name='code'),
  codeChecksum?: string(name='codeChecksum'),
  codeSize?: long(name='codeSize'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  createTime?: string(name='createTime'),
  description?: string(name='description'),
  layerName?: string(name='layerName'),
  layerVersionArn?: string(name='layerVersionArn'),
  license?: string(name='license'),
  version?: int32(name='version'),
}

model LifecycleHook {
  handler?: string(name='handler'),
  timeout?: int32(name='timeout'),
}

model ListAliasesOutput {
  aliases?: [
    Alias
  ](name='aliases'),
  nextToken?: string(name='nextToken'),
}

model ListAsyncInvokeConfigOutput {
  configs?: [
    AsyncConfig
  ](name='configs'),
  nextToken?: string(name='nextToken'),
}

model ListConcurrencyConfigsOutput {
  configs?: [
    ConcurrencyConfig
  ](name='configs'),
  nextToken?: string(name='nextToken'),
}

model ListCustomDomainOutput {
  customDomains?: [
    CustomDomain
  ](name='customDomains'),
  nextToken?: string(name='nextToken'),
}

model ListFunctionsOutput {
  functions?: [
    Function
  ](name='functions'),
  nextToken?: string(name='nextToken'),
}

model ListInstancesOutput {
  instances?: [
    InstanceInfo
  ](name='instances'),
}

model ListLayerVersionOutput {
  layers?: [
    Layer
  ](name='layers'),
  nextVersion?: int32(name='nextVersion'),
}

model ListLayersOutput {
  layers?: [
    Layer
  ](name='layers'),
  nextToken?: string(name='nextToken'),
}

model ListProvisionConfigsOutput {
  nextToken?: string(name='nextToken'),
  provisionConfigs?: [
    ProvisionConfig
  ](name='provisionConfigs'),
}

model ListTaggedResourcesOutput {
  nextToken?: string(name='nextToken'),
  resources?: [
    Resource
  ](name='resources'),
}

model ListTriggersOutput {
  nextToken?: string(name='nextToken'),
  triggers?: [
    Trigger
  ](name='triggers'),
}

model ListVersionsOutput {
  direction?: string(name='direction'),
  nextToken?: string(name='nextToken'),
  versions?: [
    Version
  ](name='versions'),
}

model LogConfig {
  enableInstanceMetrics?: boolean(name='enableInstanceMetrics'),
  enableRequestMetrics?: boolean(name='enableRequestMetrics'),
  logBeginRule?: string(name='logBeginRule'),
  logstore?: string(name='logstore'),
  project?: string(name='project'),
}

model NASConfig {
  groupId?: int32(name='groupId'),
  mountPoints?: [
    NASMountConfig
  ](name='mountPoints'),
  userId?: int32(name='userId'),
}

model NASMountConfig {
  enableTLS?: boolean(name='enableTLS'),
  mountDir?: string(name='mountDir'),
  serverAddr?: string(name='serverAddr'),
}

model OSSMountConfig {
  mountPoints?: [
    OSSMountPoint
  ](name='mountPoints'),
}

model OSSMountPoint {
  bucketName?: string(name='bucketName'),
  bucketPath?: string(name='bucketPath'),
  endpoint?: string(name='endpoint'),
  mountDir?: string(name='mountDir'),
  readOnly?: boolean(name='readOnly'),
}

model OutputCodeLocation {
  location?: string(name='location'),
  repositoryType?: string(name='repositoryType'),
}

model OutputFuncCode {
  checksum?: string(name='checksum'),
  url?: string(name='url'),
}

model PathConfig {
  accountId?: string(name='accountId'),
  functionName?: string(name='functionName'),
  innerRewriteConfig?: InnerRewriteConfig(name='innerRewriteConfig'),
  methods?: [ string ](name='methods'),
  path?: string(name='path'),
  qualifier?: string(name='qualifier'),
  rewriteConfig?: RewriteConfig(name='rewriteConfig'),
  serviceName?: string(name='serviceName'),
}

model PolicyItem {
  key?: string(name='key'),
  operator?: string(name='operator'),
  type?: string(name='type'),
  value?: string(name='value'),
}

model ProvisionConfig {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU'),
  current?: long(name='current'),
  currentError?: string(name='currentError'),
  functionArn?: string(name='functionArn'),
  scheduledActions?: [
    ScheduledAction
  ](name='scheduledActions'),
  target?: long(name='target'),
  targetTrackingPolicies?: [
    TargetTrackingPolicy
  ](name='targetTrackingPolicies'),
}

model PublishVersionInput {
  description?: string(name='description'),
}

model PutAsyncInvokeConfigInput {
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts'),
}

model PutConcurrencyInput {
  reservedConcurrency?: long(name='reservedConcurrency'),
}

model PutProvisionConfigInput {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU'),
  scheduledActions?: [
    ScheduledAction
  ](name='scheduledActions'),
  target?: long(name='target'),
  targetTrackingPolicies?: [
    TargetTrackingPolicy
  ](name='targetTrackingPolicies'),
}

model RegexRule {
  match?: string(name='match'),
  replacement?: string(name='replacement'),
}

model Resource {
  resourceArn?: string(name='resourceArn'),
  tags?: map[string]string(name='tags'),
}

model RewriteConfig {
  equalRules?: [
    EqualRule
  ](name='equalRules'),
  regexRules?: [
    RegexRule
  ](name='regexRules'),
  wildcardRules?: [
    WildcardRule
  ](name='wildcardRules'),
}

model RewriteRegexRule {
  regexStr?: string(name='regexStr'),
  replacement?: string(name='replacement'),
}

model RouteConfig {
  routes?: [
    PathConfig
  ](name='routes'),
}

model RoutePolicy {
  condition?: string(name='condition'),
  policyItems?: [
    PolicyItem
  ](name='policyItems'),
}

model ScheduledAction {
  endTime?: string(name='endTime'),
  name?: string(name='name'),
  scheduleExpression?: string(name='scheduleExpression'),
  startTime?: string(name='startTime'),
  target?: long(name='target'),
}

model TLSConfig {
  cipherSuites?: [ string ](name='cipherSuites'),
  maxVersion?: string(name='maxVersion'),
  minVersion?: string(name='minVersion'),
}

model Tag {
  key?: string(name='key'),
  value?: string(name='value'),
}

model TagResourceInput {
  resourceArn?: string(name='resourceArn'),
  resourceType?: string(name='resourceType'),
  tags?: map[string]string(name='tags'),
}

model TargetTrackingPolicy {
  endTime?: string(name='endTime'),
  maxCapacity?: long(name='maxCapacity'),
  metricTarget?: float(name='metricTarget'),
  metricType?: string(name='metricType'),
  minCapacity?: long(name='minCapacity'),
  name?: string(name='name'),
  startTime?: string(name='startTime'),
}

model TracingConfig {
  params?: map[string]string(name='params'),
  type?: string(name='type'),
}

model Trigger {
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  httpTrigger?: HTTPTrigger(name='httpTrigger'),
  invocationRole?: string(name='invocationRole'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  qualifier?: string(name='qualifier'),
  sourceArn?: string(name='sourceArn'),
  status?: string(name='status'),
  targetArn?: string(name='targetArn'),
  triggerConfig?: string(name='triggerConfig'),
  triggerId?: string(name='triggerId'),
  triggerName?: string(name='triggerName'),
  triggerType?: string(name='triggerType'),
}

model UpdateAliasInput {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  description?: string(name='description'),
  versionId?: string(name='versionId'),
}

model UpdateCustomDomainInput {
  certConfig?: CertConfig(name='certConfig'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model UpdateFunctionInput {
  code?: InputCodeLocation(name='code'),
  cpu?: float(name='cpu'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description'),
  diskSize?: int32(name='diskSize'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess'),
  layers?: [ string ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role'),
  runtime?: string(name='runtime'),
  timeout?: int32(name='timeout'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcBinding?: VPCBinding(name='vpcBinding'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model UpdateTriggerInput {
  description?: string(name='description'),
  invocationRole?: string(name='invocationRole'),
  qualifier?: string(name='qualifier'),
  triggerConfig?: string(name='triggerConfig'),
}

model VPCBinding {
  vpcIds?: [ string ](name='vpcIds'),
}

model VPCConfig {
  securityGroupId?: string(name='securityGroupId'),
  vSwitchIds?: [ string ](name='vSwitchIds'),
  vpcId?: string(name='vpcId'),
}

model Version {
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  functionVersionArn?: string(name='functionVersionArn'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  versionId?: string(name='versionId'),
}

model WAFConfig {
  enableWAF?: boolean(name='enableWAF'),
}

model WildcardRule {
  match?: string(name='match'),
  replacement?: string(name='replacement'),
}

model CreateAliasRequest {
  request?: CreateAliasInput(name='request'),
}

model CreateAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Alias  
}

/**
  * create function version
  *
  * @param request CreateAliasRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateAliasResponse
 */
async function createAliasWithOptions(functionName: string, request: CreateAliasRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAliasResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.request),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlias',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * create function version
  *
  * @param request CreateAliasRequest
  * @return CreateAliasResponse
 */
async function createAlias(functionName: string, request: CreateAliasRequest): CreateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAliasWithOptions(functionName, request, headers, runtime);
}

model CreateCustomDomainRequest {
  request?: CreateCustomDomainInput(name='request'),
}

model CreateCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CustomDomain  
}

/**
  * Create custom domain.
  *
  * @param request CreateCustomDomainRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateCustomDomainResponse
 */
async function createCustomDomainWithOptions(request: CreateCustomDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateCustomDomainResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.request),
  };
  var params = new OpenApi.Params{
    action = 'CreateCustomDomain',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Create custom domain.
  *
  * @param request CreateCustomDomainRequest
  * @return CreateCustomDomainResponse
 */
async function createCustomDomain(request: CreateCustomDomainRequest): CreateCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createCustomDomainWithOptions(request, headers, runtime);
}

model CreateFunctionRequest {
  request?: CreateFunctionInput(name='request'),
}

model CreateFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Function  
}

/**
  * Create function
  *
  * @param request CreateFunctionRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateFunctionResponse
 */
async function createFunctionWithOptions(request: CreateFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFunctionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.request),
  };
  var params = new OpenApi.Params{
    action = 'CreateFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Create function
  *
  * @param request CreateFunctionRequest
  * @return CreateFunctionResponse
 */
async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFunctionWithOptions(request, headers, runtime);
}

model CreateLayerVersionRequest {
  request?: CreateLayerVersionInput(name='request'),
}

model CreateLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Layer  
}

/**
  * Create layer version
  *
  * @param request CreateLayerVersionRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateLayerVersionResponse
 */
async function createLayerVersionWithOptions(layerName: string, request: CreateLayerVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLayerVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.request),
  };
  var params = new OpenApi.Params{
    action = 'CreateLayerVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Create layer version
  *
  * @param request CreateLayerVersionRequest
  * @return CreateLayerVersionResponse
 */
async function createLayerVersion(layerName: string, request: CreateLayerVersionRequest): CreateLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLayerVersionWithOptions(layerName, request, headers, runtime);
}

model CreateTriggerRequest {
  request?: CreateTriggerInput(name='request'),
}

model CreateTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Trigger  
}

/**
  * Create trigger.
  *
  * @param request CreateTriggerRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateTriggerResponse
 */
async function createTriggerWithOptions(functionName: string, request: CreateTriggerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTriggerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.request),
  };
  var params = new OpenApi.Params{
    action = 'CreateTrigger',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Create trigger.
  *
  * @param request CreateTriggerRequest
  * @return CreateTriggerResponse
 */
async function createTrigger(functionName: string, request: CreateTriggerRequest): CreateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTriggerWithOptions(functionName, request, headers, runtime);
}

model DeleteAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * Delete function alias
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteAliasResponse
 */
async function deleteAliasWithOptions(functionName: string, aliasName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAliasResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlias',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases/${OpenApiUtil.getEncodeParam(aliasName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * Delete function alias
  *
  * @return DeleteAliasResponse
 */
async function deleteAlias(functionName: string, aliasName: string): DeleteAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAliasWithOptions(functionName, aliasName, headers, runtime);
}

model DeleteAsyncInvokeConfigRequest {
  qualifier?: string(name='qualifier'),
}

model DeleteAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * Delete function async invoke config
  *
  * @param request DeleteAsyncInvokeConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteAsyncInvokeConfigResponse
 */
async function deleteAsyncInvokeConfigWithOptions(functionName: string, request: DeleteAsyncInvokeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAsyncInvokeConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-invoke-config`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * Delete function async invoke config
  *
  * @param request DeleteAsyncInvokeConfigRequest
  * @return DeleteAsyncInvokeConfigResponse
 */
async function deleteAsyncInvokeConfig(functionName: string, request: DeleteAsyncInvokeConfigRequest): DeleteAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAsyncInvokeConfigWithOptions(functionName, request, headers, runtime);
}

model DeleteConcurrencyConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * deletes the concurrency config for a function
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteConcurrencyConfigResponse
 */
async function deleteConcurrencyConfigWithOptions(functionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConcurrencyConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteConcurrencyConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/concurrency`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * deletes the concurrency config for a function
  *
  * @return DeleteConcurrencyConfigResponse
 */
async function deleteConcurrencyConfig(functionName: string): DeleteConcurrencyConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConcurrencyConfigWithOptions(functionName, headers, runtime);
}

model DeleteCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * Delete custom domain.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteCustomDomainResponse
 */
async function deleteCustomDomainWithOptions(domainName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteCustomDomainResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomDomain',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains/${OpenApiUtil.getEncodeParam(domainName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * Delete custom domain.
  *
  * @return DeleteCustomDomainResponse
 */
async function deleteCustomDomain(domainName: string): DeleteCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteCustomDomainWithOptions(domainName, headers, runtime);
}

model DeleteFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * Delete function
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteFunctionResponse
 */
async function deleteFunctionWithOptions(functionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFunctionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * Delete function
  *
  * @return DeleteFunctionResponse
 */
async function deleteFunction(functionName: string): DeleteFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionWithOptions(functionName, headers, runtime);
}

model DeleteFunctionVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * Delete function version
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteFunctionVersionResponse
 */
async function deleteFunctionVersionWithOptions(functionName: string, versionID: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFunctionVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunctionVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/versions/${OpenApiUtil.getEncodeParam(versionID)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * Delete function version
  *
  * @return DeleteFunctionVersionResponse
 */
async function deleteFunctionVersion(functionName: string, versionID: string): DeleteFunctionVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionVersionWithOptions(functionName, versionID, headers, runtime);
}

model DeleteLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * Delete layer version
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteLayerVersionResponse
 */
async function deleteLayerVersionWithOptions(layerName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLayerVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLayerVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions/${OpenApiUtil.getEncodeParam(version)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * Delete layer version
  *
  * @return DeleteLayerVersionResponse
 */
async function deleteLayerVersion(layerName: string, version: string): DeleteLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLayerVersionWithOptions(layerName, version, headers, runtime);
}

model DeleteProvisionConfigRequest {
  qualifier?: string(name='qualifier'),
}

model DeleteProvisionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * Delete provision config.
  *
  * @param request DeleteProvisionConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteProvisionConfigResponse
 */
async function deleteProvisionConfigWithOptions(functionName: string, request: DeleteProvisionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProvisionConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProvisionConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/provision-config`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * Delete provision config.
  *
  * @param request DeleteProvisionConfigRequest
  * @return DeleteProvisionConfigResponse
 */
async function deleteProvisionConfig(functionName: string, request: DeleteProvisionConfigRequest): DeleteProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProvisionConfigWithOptions(functionName, request, headers, runtime);
}

model DeleteTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * Delete trigger.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteTriggerResponse
 */
async function deleteTriggerWithOptions(functionName: string, triggerName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTriggerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteTrigger',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers/${OpenApiUtil.getEncodeParam(triggerName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * Delete trigger.
  *
  * @return DeleteTriggerResponse
 */
async function deleteTrigger(functionName: string, triggerName: string): DeleteTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTriggerWithOptions(functionName, triggerName, headers, runtime);
}

model GetAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Alias  
}

/**
  * Get function alias
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetAliasResponse
 */
async function getAliasWithOptions(functionName: string, aliasName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAliasResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAlias',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases/${OpenApiUtil.getEncodeParam(aliasName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Get function alias
  *
  * @return GetAliasResponse
 */
async function getAlias(functionName: string, aliasName: string): GetAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAliasWithOptions(functionName, aliasName, headers, runtime);
}

model GetAsyncInvokeConfigRequest {
  qualifier?: string(name='qualifier'),
}

model GetAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AsyncConfig  
}

/**
  * Get function async invoke config
  *
  * @param request GetAsyncInvokeConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetAsyncInvokeConfigResponse
 */
async function getAsyncInvokeConfigWithOptions(functionName: string, request: GetAsyncInvokeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAsyncInvokeConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-invoke-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Get function async invoke config
  *
  * @param request GetAsyncInvokeConfigRequest
  * @return GetAsyncInvokeConfigResponse
 */
async function getAsyncInvokeConfig(functionName: string, request: GetAsyncInvokeConfigRequest): GetAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAsyncInvokeConfigWithOptions(functionName, request, headers, runtime);
}

model GetConcurrencyConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConcurrencyConfig  
}

/**
  * gets the concurrency config for a function
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetConcurrencyConfigResponse
 */
async function getConcurrencyConfigWithOptions(functionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetConcurrencyConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetConcurrencyConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/concurrency`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * gets the concurrency config for a function
  *
  * @return GetConcurrencyConfigResponse
 */
async function getConcurrencyConfig(functionName: string): GetConcurrencyConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getConcurrencyConfigWithOptions(functionName, headers, runtime);
}

model GetCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CustomDomain  
}

/**
  * Get custom domain.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetCustomDomainResponse
 */
async function getCustomDomainWithOptions(domainName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetCustomDomainResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetCustomDomain',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains/${OpenApiUtil.getEncodeParam(domainName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Get custom domain.
  *
  * @return GetCustomDomainResponse
 */
async function getCustomDomain(domainName: string): GetCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCustomDomainWithOptions(domainName, headers, runtime);
}

model GetFunctionRequest {
  qualifier?: string(name='qualifier'),
}

model GetFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Function  
}

/**
  * Get function info by function name
  *
  * @param request GetFunctionRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetFunctionResponse
 */
async function getFunctionWithOptions(functionName: string, request: GetFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Get function info by function name
  *
  * @param request GetFunctionRequest
  * @return GetFunctionResponse
 */
async function getFunction(functionName: string, request: GetFunctionRequest): GetFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionWithOptions(functionName, request, headers, runtime);
}

model GetFunctionCodeRequest {
  qualifier?: string(name='qualifier'),
}

model GetFunctionCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OutputFuncCode  
}

/**
  * Get function code by function name
  *
  * @param request GetFunctionCodeRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetFunctionCodeResponse
 */
async function getFunctionCodeWithOptions(functionName: string, request: GetFunctionCodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionCodeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunctionCode',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/code`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Get function code by function name
  *
  * @param request GetFunctionCodeRequest
  * @return GetFunctionCodeResponse
 */
async function getFunctionCode(functionName: string, request: GetFunctionCodeRequest): GetFunctionCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionCodeWithOptions(functionName, request, headers, runtime);
}

model GetLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Layer  
}

/**
  * Get layer version.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetLayerVersionResponse
 */
async function getLayerVersionWithOptions(layerName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLayerVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLayerVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions/${OpenApiUtil.getEncodeParam(version)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Get layer version.
  *
  * @return GetLayerVersionResponse
 */
async function getLayerVersion(layerName: string, version: string): GetLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLayerVersionWithOptions(layerName, version, headers, runtime);
}

model GetLayerVersionByArnResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Layer  
}

/**
  * Get layer version by arn.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetLayerVersionByArnResponse
 */
async function getLayerVersionByArnWithOptions(arn: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLayerVersionByArnResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLayerVersionByArn',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layerarn/${OpenApiUtil.getEncodeParam(arn)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Get layer version by arn.
  *
  * @return GetLayerVersionByArnResponse
 */
async function getLayerVersionByArn(arn: string): GetLayerVersionByArnResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLayerVersionByArnWithOptions(arn, headers, runtime);
}

model GetProvisionConfigRequest {
  qualifier?: string(name='qualifier'),
}

model GetProvisionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ProvisionConfig  
}

/**
  * Get provision config.
  *
  * @param request GetProvisionConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetProvisionConfigResponse
 */
async function getProvisionConfigWithOptions(functionName: string, request: GetProvisionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProvisionConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProvisionConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/provision-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Get provision config.
  *
  * @param request GetProvisionConfigRequest
  * @return GetProvisionConfigResponse
 */
async function getProvisionConfig(functionName: string, request: GetProvisionConfigRequest): GetProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProvisionConfigWithOptions(functionName, request, headers, runtime);
}

model GetResourceTagsRequest {
  arn?: string(name='arn'),
}

model GetResourceTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceTagsOutput  
}

/**
  * Get resource tag
  *
  * @param request GetResourceTagsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetResourceTagsResponse
 */
async function getResourceTagsWithOptions(request: GetResourceTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetResourceTagsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.arn)) {
    query['arn'] = request.arn;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceTags',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/tag`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Get resource tag
  *
  * @param request GetResourceTagsRequest
  * @return GetResourceTagsResponse
 */
async function getResourceTags(request: GetResourceTagsRequest): GetResourceTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getResourceTagsWithOptions(request, headers, runtime);
}

model GetTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Trigger  
}

/**
  * Get trigger.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetTriggerResponse
 */
async function getTriggerWithOptions(functionName: string, triggerName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTriggerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTrigger',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers/${OpenApiUtil.getEncodeParam(triggerName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Get trigger.
  *
  * @return GetTriggerResponse
 */
async function getTrigger(functionName: string, triggerName: string): GetTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTriggerWithOptions(functionName, triggerName, headers, runtime);
}

model InvokeFunctionHeaders {
  commonHeaders?: map[string]string,
  xFcInvocationType?: string(name='x-fc-invocation-type'),
  xFcLogType?: string(name='x-fc-log-type'),
}

model InvokeFunctionRequest {
  qualifier?: string(name='qualifier'),
  request?: readable(name='request'),
}

model InvokeFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: readable(name='body'),
}

/**
  * Invoke function
  *
  * @param request InvokeFunctionRequest
  * @param headers InvokeFunctionHeaders
  * @param runtime runtime options for this request RuntimeOptions
  * @return InvokeFunctionResponse
 */
async function invokeFunctionWithOptions(functionName: string, request: InvokeFunctionRequest, headers: InvokeFunctionHeaders, runtime: Util.RuntimeOptions): InvokeFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcInvocationType)) {
    realHeaders['x-fc-invocation-type'] = Util.toJSONString(headers.xFcInvocationType);
  }
  if (!Util.isUnset(headers.xFcLogType)) {
    realHeaders['x-fc-log-type'] = Util.toJSONString(headers.xFcLogType);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = request.request,
    stream = request.request,
  };
  var params = new OpenApi.Params{
    action = 'InvokeFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/invocations`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'binary',
  };
  var res = new InvokeFunctionResponse{};
  var tmp = Util.assertAsMap(callApi(params, req, runtime));
  if (!Util.isUnset(tmp.body)) {
    var respBody = Util.assertAsReadable(tmp.body);
    res.body = respBody;
  }
  if (!Util.isUnset(tmp.headers)) {
    var respHeaders = Util.assertAsMap(tmp.headers);
    res.headers = Util.stringifyMapValue(respHeaders);
  }
  if (!Util.isUnset(tmp.statusCode)) {
    var statusCode = Util.assertAsInteger(tmp.statusCode);
    res.statusCode = statusCode;
  }
  return res;
}

/**
  * Invoke function
  *
  * @param request InvokeFunctionRequest
  * @return InvokeFunctionResponse
 */
async function invokeFunction(functionName: string, request: InvokeFunctionRequest): InvokeFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new InvokeFunctionHeaders{};
  return invokeFunctionWithOptions(functionName, request, headers, runtime);
}

model ListAliasesRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
  prefix?: string(name='prefix'),
}

model ListAliasesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAliasesOutput  
}

/**
  * List function aliases
  *
  * @param request ListAliasesRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListAliasesResponse
 */
async function listAliasesWithOptions(functionName: string, request: ListAliasesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAliasesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAliases',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * List function aliases
  *
  * @param request ListAliasesRequest
  * @return ListAliasesResponse
 */
async function listAliases(functionName: string, request: ListAliasesRequest): ListAliasesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAliasesWithOptions(functionName, request, headers, runtime);
}

model ListAsyncInvokeConfigsRequest {
  functionName?: string(name='functionName'),
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
}

model ListAsyncInvokeConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAsyncInvokeConfigOutput  
}

/**
  * List all functions async invoke config
  *
  * @param request ListAsyncInvokeConfigsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListAsyncInvokeConfigsResponse
 */
async function listAsyncInvokeConfigsWithOptions(request: ListAsyncInvokeConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAsyncInvokeConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.functionName)) {
    query['functionName'] = request.functionName;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAsyncInvokeConfigs',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/async-invoke-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * List all functions async invoke config
  *
  * @param request ListAsyncInvokeConfigsRequest
  * @return ListAsyncInvokeConfigsResponse
 */
async function listAsyncInvokeConfigs(request: ListAsyncInvokeConfigsRequest): ListAsyncInvokeConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAsyncInvokeConfigsWithOptions(request, headers, runtime);
}

model ListConcurrencyConfigsRequest {
  functionName?: string(name='functionName'),
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
}

model ListConcurrencyConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConcurrencyConfigsOutput  
}

/**
  * List all functions concurrency configs
  *
  * @param request ListConcurrencyConfigsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListConcurrencyConfigsResponse
 */
async function listConcurrencyConfigsWithOptions(request: ListConcurrencyConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListConcurrencyConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.functionName)) {
    query['functionName'] = request.functionName;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConcurrencyConfigs',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/concurrency-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * List all functions concurrency configs
  *
  * @param request ListConcurrencyConfigsRequest
  * @return ListConcurrencyConfigsResponse
 */
async function listConcurrencyConfigs(request: ListConcurrencyConfigsRequest): ListConcurrencyConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConcurrencyConfigsWithOptions(request, headers, runtime);
}

model ListCustomDomainsRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
  prefix?: string(name='prefix'),
}

model ListCustomDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCustomDomainOutput  
}

/**
  * List custom domains.
  *
  * @param request ListCustomDomainsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListCustomDomainsResponse
 */
async function listCustomDomainsWithOptions(request: ListCustomDomainsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCustomDomainsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCustomDomains',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * List custom domains.
  *
  * @param request ListCustomDomainsRequest
  * @return ListCustomDomainsResponse
 */
async function listCustomDomains(request: ListCustomDomainsRequest): ListCustomDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCustomDomainsWithOptions(request, headers, runtime);
}

model ListFunctionVersionsRequest {
  direction?: string(name='direction'),
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
}

model ListFunctionVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVersionsOutput  
}

/**
  * List function versions
  *
  * @param request ListFunctionVersionsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListFunctionVersionsResponse
 */
async function listFunctionVersionsWithOptions(functionName: string, request: ListFunctionVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.direction)) {
    query['direction'] = request.direction;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctionVersions',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * List function versions
  *
  * @param request ListFunctionVersionsRequest
  * @return ListFunctionVersionsResponse
 */
async function listFunctionVersions(functionName: string, request: ListFunctionVersionsRequest): ListFunctionVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionVersionsWithOptions(functionName, request, headers, runtime);
}

model ListFunctionsRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
  prefix?: string(name='prefix'),
}

model ListFunctionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFunctionsOutput  
}

/**
  * Lists existing functions.
  *
  * @param request ListFunctionsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListFunctionsResponse
 */
async function listFunctionsWithOptions(request: ListFunctionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctions',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Lists existing functions.
  *
  * @param request ListFunctionsRequest
  * @return ListFunctionsResponse
 */
async function listFunctions(request: ListFunctionsRequest): ListFunctionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionsWithOptions(request, headers, runtime);
}

model ListInstancesRequest {
  qualifier?: string(name='qualifier'),
  withAllActive?: boolean(name='withAllActive'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstancesOutput  
}

/**
  * List instances for function.
  *
  * @param request ListInstancesRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListInstancesResponse
 */
async function listInstancesWithOptions(functionName: string, request: ListInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }
  if (!Util.isUnset(request.withAllActive)) {
    query['withAllActive'] = request.withAllActive;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * List instances for function.
  *
  * @param request ListInstancesRequest
  * @return ListInstancesResponse
 */
async function listInstances(functionName: string, request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstancesWithOptions(functionName, request, headers, runtime);
}

model ListLayerVersionsRequest {
  limit?: int32(name='limit'),
  startVersion?: string(name='startVersion'),
}

model ListLayerVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLayerVersionOutput  
}

/**
  * List layer versions.
  *
  * @param request ListLayerVersionsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListLayerVersionsResponse
 */
async function listLayerVersionsWithOptions(layerName: string, request: ListLayerVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLayerVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.startVersion)) {
    query['startVersion'] = request.startVersion;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLayerVersions',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * List layer versions.
  *
  * @param request ListLayerVersionsRequest
  * @return ListLayerVersionsResponse
 */
async function listLayerVersions(layerName: string, request: ListLayerVersionsRequest): ListLayerVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLayerVersionsWithOptions(layerName, request, headers, runtime);
}

model ListLayersRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
  official?: string(name='official'),
  prefix?: string(name='prefix'),
  public?: string(name='public'),
}

model ListLayersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLayersOutput  
}

/**
  * List layers .
  *
  * @param request ListLayersRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListLayersResponse
 */
async function listLayersWithOptions(request: ListLayersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLayersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.official)) {
    query['official'] = request.official;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.public)) {
    query['public'] = request.public;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLayers',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * List layers .
  *
  * @param request ListLayersRequest
  * @return ListLayersResponse
 */
async function listLayers(request: ListLayersRequest): ListLayersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLayersWithOptions(request, headers, runtime);
}

model ListProvisionConfigsRequest {
  functionName?: string(name='functionName'),
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
}

model ListProvisionConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProvisionConfigsOutput  
}

/**
  * List provision configs.
  *
  * @param request ListProvisionConfigsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListProvisionConfigsResponse
 */
async function listProvisionConfigsWithOptions(request: ListProvisionConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProvisionConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.functionName)) {
    query['functionName'] = request.functionName;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProvisionConfigs',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/provision-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * List provision configs.
  *
  * @param request ListProvisionConfigsRequest
  * @return ListProvisionConfigsResponse
 */
async function listProvisionConfigs(request: ListProvisionConfigsRequest): ListProvisionConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProvisionConfigsWithOptions(request, headers, runtime);
}

model ListTaggedResourcesRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
}

model ListTaggedResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTaggedResourcesOutput  
}

/**
  * List tagged resources
  *
  * @param request ListTaggedResourcesRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListTaggedResourcesResponse
 */
async function listTaggedResourcesWithOptions(request: ListTaggedResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTaggedResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTaggedResources',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * List tagged resources
  *
  * @param request ListTaggedResourcesRequest
  * @return ListTaggedResourcesResponse
 */
async function listTaggedResources(request: ListTaggedResourcesRequest): ListTaggedResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTaggedResourcesWithOptions(request, headers, runtime);
}

model ListTriggersRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
  prefix?: string(name='prefix'),
}

model ListTriggersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTriggersOutput  
}

/**
  * List triggers.
  *
  * @param request ListTriggersRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListTriggersResponse
 */
async function listTriggersWithOptions(functionName: string, request: ListTriggersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTriggersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTriggers',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * List triggers.
  *
  * @param request ListTriggersRequest
  * @return ListTriggersResponse
 */
async function listTriggers(functionName: string, request: ListTriggersRequest): ListTriggersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTriggersWithOptions(functionName, request, headers, runtime);
}

model PublishFunctionVersionRequest {
  request?: PublishVersionInput(name='request'),
}

model PublishFunctionVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Version  
}

/**
  * publish new function version
  *
  * @param request PublishFunctionVersionRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return PublishFunctionVersionResponse
 */
async function publishFunctionVersionWithOptions(functionName: string, request: PublishFunctionVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PublishFunctionVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.request),
  };
  var params = new OpenApi.Params{
    action = 'PublishFunctionVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * publish new function version
  *
  * @param request PublishFunctionVersionRequest
  * @return PublishFunctionVersionResponse
 */
async function publishFunctionVersion(functionName: string, request: PublishFunctionVersionRequest): PublishFunctionVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return publishFunctionVersionWithOptions(functionName, request, headers, runtime);
}

model PutAsyncInvokeConfigRequest {
  qualifier?: string(name='qualifier'),
  request?: PutAsyncInvokeConfigInput(name='request'),
}

model PutAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AsyncConfig  
}

/**
  * Put function async invoke config.
  *
  * @param request PutAsyncInvokeConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return PutAsyncInvokeConfigResponse
 */
async function putAsyncInvokeConfigWithOptions(functionName: string, request: PutAsyncInvokeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.request),
  };
  var params = new OpenApi.Params{
    action = 'PutAsyncInvokeConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-invoke-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Put function async invoke config.
  *
  * @param request PutAsyncInvokeConfigRequest
  * @return PutAsyncInvokeConfigResponse
 */
async function putAsyncInvokeConfig(functionName: string, request: PutAsyncInvokeConfigRequest): PutAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putAsyncInvokeConfigWithOptions(functionName, request, headers, runtime);
}

model PutConcurrencyConfigRequest {
  request?: PutConcurrencyInput(name='request'),
}

model PutConcurrencyConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConcurrencyConfig  
}

/**
  * sets the concurrency config for a function
  *
  * @param request PutConcurrencyConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return PutConcurrencyConfigResponse
 */
async function putConcurrencyConfigWithOptions(functionName: string, request: PutConcurrencyConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutConcurrencyConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.request),
  };
  var params = new OpenApi.Params{
    action = 'PutConcurrencyConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/concurrency`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * sets the concurrency config for a function
  *
  * @param request PutConcurrencyConfigRequest
  * @return PutConcurrencyConfigResponse
 */
async function putConcurrencyConfig(functionName: string, request: PutConcurrencyConfigRequest): PutConcurrencyConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putConcurrencyConfigWithOptions(functionName, request, headers, runtime);
}

model PutLayerACLRequest {
  public?: string(name='public'),
}

model PutLayerACLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * Update layer ACL.
  *
  * @param request PutLayerACLRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return PutLayerACLResponse
 */
async function putLayerACLWithOptions(layerName: string, request: PutLayerACLRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutLayerACLResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.public)) {
    query['public'] = request.public;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutLayerACL',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/acl`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * Update layer ACL.
  *
  * @param request PutLayerACLRequest
  * @return PutLayerACLResponse
 */
async function putLayerACL(layerName: string, request: PutLayerACLRequest): PutLayerACLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putLayerACLWithOptions(layerName, request, headers, runtime);
}

model PutProvisionConfigRequest {
  qualifier?: string(name='qualifier'),
  request?: PutProvisionConfigInput(name='request'),
}

model PutProvisionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ProvisionConfig  
}

/**
  * Put provision config.
  *
  * @param request PutProvisionConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return PutProvisionConfigResponse
 */
async function putProvisionConfigWithOptions(functionName: string, request: PutProvisionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutProvisionConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.request),
  };
  var params = new OpenApi.Params{
    action = 'PutProvisionConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/provision-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Put provision config.
  *
  * @param request PutProvisionConfigRequest
  * @return PutProvisionConfigResponse
 */
async function putProvisionConfig(functionName: string, request: PutProvisionConfigRequest): PutProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putProvisionConfigWithOptions(functionName, request, headers, runtime);
}

model TagResourceRequest {
  request?: TagResourceInput(name='request'),
}

model TagResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Tag  
}

/**
  * Tag resource
  *
  * @param request TagResourceRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return TagResourceResponse
 */
async function tagResourceWithOptions(request: TagResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.request),
  };
  var params = new OpenApi.Params{
    action = 'TagResource',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/tag`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Tag resource
  *
  * @param request TagResourceRequest
  * @return TagResourceResponse
 */
async function tagResource(request: TagResourceRequest): TagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourceWithOptions(request, headers, runtime);
}

model UntagResourceRequest {
  all?: boolean(name='all'),
  arn?: string(name='arn'),
  tagKeys?: string(name='tagKeys'),
}

model UntagResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * Untag resource tag, support resource type: function, service
  *
  * @param request UntagResourceRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UntagResourceResponse
 */
async function untagResourceWithOptions(request: UntagResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    query['all'] = request.all;
  }
  if (!Util.isUnset(request.arn)) {
    query['arn'] = request.arn;
  }
  if (!Util.isUnset(request.tagKeys)) {
    query['tagKeys'] = request.tagKeys;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResource',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/tag`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * Untag resource tag, support resource type: function, service
  *
  * @param request UntagResourceRequest
  * @return UntagResourceResponse
 */
async function untagResource(request: UntagResourceRequest): UntagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourceWithOptions(request, headers, runtime);
}

model UpdateAliasRequest {
  request?: UpdateAliasInput(name='request'),
}

model UpdateAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Alias  
}

/**
  * Update function alias
  *
  * @param request UpdateAliasRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateAliasResponse
 */
async function updateAliasWithOptions(functionName: string, aliasName: string, request: UpdateAliasRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAliasResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlias',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases/${OpenApiUtil.getEncodeParam(aliasName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Update function alias
  *
  * @param request UpdateAliasRequest
  * @return UpdateAliasResponse
 */
async function updateAlias(functionName: string, aliasName: string, request: UpdateAliasRequest): UpdateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAliasWithOptions(functionName, aliasName, request, headers, runtime);
}

model UpdateCustomDomainRequest {
  request?: UpdateCustomDomainInput(name='request'),
}

model UpdateCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CustomDomain  
}

/**
  * Update custom domain.
  *
  * @param request UpdateCustomDomainRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateCustomDomainResponse
 */
async function updateCustomDomainWithOptions(domainName: string, request: UpdateCustomDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCustomDomainResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCustomDomain',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains/${OpenApiUtil.getEncodeParam(domainName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Update custom domain.
  *
  * @param request UpdateCustomDomainRequest
  * @return UpdateCustomDomainResponse
 */
async function updateCustomDomain(domainName: string, request: UpdateCustomDomainRequest): UpdateCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCustomDomainWithOptions(domainName, request, headers, runtime);
}

model UpdateFunctionRequest {
  request?: UpdateFunctionInput(name='request'),
}

model UpdateFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Function  
}

/**
  * Update function
  *
  * @param request UpdateFunctionRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateFunctionResponse
 */
async function updateFunctionWithOptions(functionName: string, request: UpdateFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFunctionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Update function
  *
  * @param request UpdateFunctionRequest
  * @return UpdateFunctionResponse
 */
async function updateFunction(functionName: string, request: UpdateFunctionRequest): UpdateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFunctionWithOptions(functionName, request, headers, runtime);
}

model UpdateTriggerRequest {
  request?: UpdateTriggerInput(name='request'),
}

model UpdateTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Trigger  
}

/**
  * Update trigger.
  *
  * @param request UpdateTriggerRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateTriggerResponse
 */
async function updateTriggerWithOptions(functionName: string, triggerName: string, request: UpdateTriggerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTriggerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTrigger',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers/${OpenApiUtil.getEncodeParam(triggerName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Update trigger.
  *
  * @param request UpdateTriggerRequest
  * @return UpdateTriggerResponse
 */
async function updateTrigger(functionName: string, triggerName: string, request: UpdateTriggerRequest): UpdateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTriggerWithOptions(functionName, triggerName, request, headers, runtime);
}

