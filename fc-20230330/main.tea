/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('fc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AccelerationInfo {
  status?: string(name='status', example='Ready'),
}

model Alias {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName?: string(name='aliasName', example='prod'),
  createdTime?: string(name='createdTime', example='2006-01-02T15:04:05Z07:00'),
  description?: string(name='description', example='alias for pre env'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2006-01-02T15:04:05Z07:00'),
  versionId?: string(name='versionId', example='1'),
}

model AsyncConfig {
  createdTime?: string(name='createdTime', example='2006-01-02T15:04:05Z07:00'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:1234/functions/my-func'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2006-01-02T15:04:05Z07:00'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', example='3600'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', example='3'),
}

model AuthConfig {
  authInfo?: string(name='authInfo', example='{}'),
  authType?: string(name='authType', example='anonymous, function, jwt'),
}

model CertConfig {
  certName?: string(name='certName', example='my-cert'),
  certificate?: string(name='certificate', example='PEM format'),
  privateKey?: string(name='privateKey', example='PEM format'),
}

model ConcurrencyConfig {
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:123:functions/demo'),
  reservedConcurrency?: long(name='reservedConcurrency', example='10'),
}

model CreateAliasInput {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName?: string(name='aliasName', example='prod'),
  description?: string(name='description', example='my alias'),
  versionId?: string(name='versionId', example='1'),
}

model CreateCustomDomainInput {
  authConfig?: AuthConfig(name='authConfig'),
  certConfig?: CertConfig(name='certConfig'),
  domainName?: string(name='domainName', example='example.com'),
  protocol?: string(name='protocol', example='HTTP'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model CreateFunctionInput {
  code?: InputCodeLocation(name='code'),
  cpu?: float(name='cpu', example='1'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description', example='my function'),
  diskSize?: int32(name='diskSize', example='512'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionName?: string(name='functionName', example='my-function-1'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler', example='index.handler'),
  instanceConcurrency?: int32(name='instanceConcurrency', example='1'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess', example='true'),
  layers?: [ string ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize', example='512'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role', example='acs:ram::188077086902****:role/fc-test'),
  runtime?: string(name='runtime', example='python3.10'),
  timeout?: int32(name='timeout', example='60'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model CreateLayerVersionInput {
  code?: InputCodeLocation(name='code'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  description?: string(name='description', example='my first layer'),
  license?: string(name='license', example='Apache'),
}

model CreateTriggerInput {
  description?: string(name='description', example='trigger for test'),
  invocationRole?: string(name='invocationRole', example='acs:ram::1234567890:role/fc-test'),
  qualifier?: string(name='qualifier', example='LATEST'),
  sourceArn?: string(name='sourceArn', example='acs:oss:cn-shanghai:12345:mybucket'),
  triggerConfig?: string(name='triggerConfig', example='{"events":["oss:ObjectCreated:*"],"filter":{"key":{"prefix":"/prefix","suffix":".zip"}}}'),
  triggerName?: string(name='triggerName', example='oss_create_object_demo'),
  triggerType?: string(name='triggerType', example='oss'),
}

model CreateVpcBindingInput {
  vpcId?: string(name='vpcId', example='vpc-8vb8x8dggvr0axxxxxxxx'),
}

model CustomContainerConfig {
  accelerationInfo?: AccelerationInfo(name='accelerationInfo'),
  accelerationType?: string(name='accelerationType', example='default'),
  acrInstanceId?: string(name='acrInstanceId', example='cri-xxxxxxxxxx'),
  command?: [ string ](name='command'),
  entrypoint?: [ string ](name='entrypoint'),
  healthCheckConfig?: CustomHealthCheckConfig(name='healthCheckConfig'),
  image?: string(name='image', example='registry-vpc.cn-hangzhou.aliyuncs.com/fc-demo/helloworld:v1beta1'),
  port?: int32(name='port', example='9000'),
}

model CustomDNS {
  dnsOptions?: [
    DNSOption
  ](name='dnsOptions'),
  nameServers?: [ string ](name='nameServers'),
  searches?: [ string ](name='searches'),
}

model CustomDomain {
  accountId?: string(name='accountId'),
  apiVersion?: string(name='apiVersion', example='2023-03-30'),
  authConfig?: AuthConfig(name='authConfig'),
  certConfig?: CertConfig(name='certConfig'),
  createdTime?: string(name='createdTime', example='2023-03-30T08:02:19Z'),
  domainName?: string(name='domainName', example='example.com'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2023-03-30T08:02:19Z'),
  protocol?: string(name='protocol', example='HTTP'),
  routeConfig?: RouteConfig(name='routeConfig'),
  subdomainCount?: string(name='subdomainCount', example='1'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model CustomHealthCheckConfig {
  failureThreshold?: int32(name='failureThreshold', example='1'),
  httpGetUrl?: string(name='httpGetUrl', example='/ready'),
  initialDelaySeconds?: int32(name='initialDelaySeconds', example='1'),
  periodSeconds?: int32(name='periodSeconds', example='1'),
  successThreshold?: int32(name='successThreshold', example='2'),
  timeoutSeconds?: int32(name='timeoutSeconds', example='2'),
}

model CustomRuntimeConfig {
  args?: [ string ](name='args'),
  command?: [ string ](name='command'),
  healthCheckConfig?: CustomHealthCheckConfig(name='healthCheckConfig'),
  port?: int32(name='port', example='9000'),
}

model DNSOption {
  name?: string(name='name', example='ndots'),
  value?: string(name='value', example='2'),
}

model Destination {
  destination?: string(name='destination', example='acs:fc:cn-shanghai:xxx:functions/f1'),
}

model DestinationConfig {
  onFailure?: Destination(name='onFailure'),
  onSuccess?: Destination(name='onSuccess'),
}

model EqualRule {
  match?: string(name='match', example='/old'),
  replacement?: string(name='replacement', example='/new'),
}

model Error {
  code?: string(name='Code', example='FunctionNotFound'),
  message?: string(name='Message', example='function not found'),
  requestId?: string(name='RequestId', example='1-64e70cf1-5cbef92ea8fc8c42899cf5d1'),
}

model Function {
  codeChecksum?: string(name='codeChecksum', example='2825179536350****'),
  codeSize?: long(name='codeSize', example='412'),
  cpu?: float(name='cpu', example='1'),
  createdTime?: string(name='createdTime', example='2023-04-01T08:15:27Z'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description', example='my function'),
  diskSize?: int32(name='diskSize', example='512'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:123:functions/functionName'),
  functionId?: string(name='functionId', example='aa715851-1c20-4b89-a8fb-***'),
  functionName?: string(name='functionName', example='my-function-1'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler', example='index.handler'),
  instanceConcurrency?: int32(name='instanceConcurrency', example='1'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess', example='true'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2023-05-01T08:15:27Z'),
  layers?: [
    FunctionLayer
  ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize', example='512'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role', example='acs:ram::188077086902****:role/fc-test'),
  runtime?: string(name='runtime', example='python3.10'),
  timeout?: int32(name='timeout', example='60'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model FunctionLayer {
  arn?: string(name='arn', example='acs:fc:cn-beijing:186824xxxxxx:layers/fc_layer/versions/1'),
  size?: long(name='size', example='421'),
}

model GPUConfig {
  gpuMemorySize?: int32(name='gpuMemorySize', example='2048'),
  gpuType?: string(name='gpuType', example='fc.gpu.ampere.1'),
}

model GetResourceTagsOutput {
  resourceArn?: string(name='resourceArn', example='acs:fc:cn-shanghai:****:functions/demo'),
  tags?: map[string]string(name='tags'),
}

model HTTPTrigger {
  urlInternet?: string(name='urlInternet', example='https://svc-func-xxxxxxxx.cn-hangzhou.fcapp.run'),
  urlIntranet?: string(name='urlIntranet', example='https://svc-func-xxxxxxxx.cn-hangzhou-vpc.fcapp.run'),
}

model InputCodeLocation {
  checksum?: string(name='checksum', example='2825179536350****'),
  ossBucketName?: string(name='ossBucketName', example='demo-bucket'),
  ossObjectName?: string(name='ossObjectName', example='demo-object'),
  zipFile?: string(name='zipFile', example='UEsDBAoAAAAAANF'),
}

model InstanceInfo {
  instanceId?: string(name='instanceId', example='1ef6b6ff-7f7b-485e-ab49-501ac681****'),
  versionId?: string(name='versionId', example='LATEST'),
}

model InstanceLifecycleConfig {
  initializer?: LifecycleHook(name='initializer'),
  preStop?: LifecycleHook(name='preStop'),
}

model Layer {
  acl?: string(name='acl', example='0'),
  code?: OutputCodeLocation(name='code'),
  codeChecksum?: string(name='codeChecksum', example='2825179536350****'),
  codeSize?: long(name='codeSize', example='421'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  createTime?: string(name='createTime', example='2023-03-30T11:08:00Z'),
  description?: string(name='description', example='My first layer'),
  layerName?: string(name='layerName', example='MyLayer'),
  layerVersionArn?: string(name='layerVersionArn', example='acs:fc:cn-beijing:186824xxxxxx:layers/fc_layer/versions/1'),
  license?: string(name='license', example='Apache'),
  version?: int32(name='version', example='1'),
}

model LifecycleHook {
  handler?: string(name='handler', example='index.initializer'),
  timeout?: int32(name='timeout', example='10'),
}

model ListAliasesOutput {
  aliases?: [
    Alias
  ](name='aliases'),
  nextToken?: string(name='nextToken', example='test'),
}

model ListAsyncInvokeConfigOutput {
  configs?: [
    AsyncConfig
  ](name='configs'),
  nextToken?: string(name='nextToken', example='8bj81uI8n****'),
}

model ListConcurrencyConfigsOutput {
  configs?: [
    ConcurrencyConfig
  ](name='configs'),
  nextToken?: string(name='nextToken', example='next_token'),
}

model ListCustomDomainOutput {
  customDomains?: [
    CustomDomain
  ](name='customDomains'),
  nextToken?: string(name='nextToken', example='next_domain_name'),
}

model ListFunctionsOutput {
  functions?: [
    Function
  ](name='functions'),
  nextToken?: string(name='nextToken', example='next_function_name'),
}

model ListInstancesOutput {
  instances?: [
    InstanceInfo
  ](name='instances'),
}

model ListLayerVersionOutput {
  layers?: [
    Layer
  ](name='layers'),
  nextVersion?: int32(name='nextVersion', example='10'),
}

model ListLayersOutput {
  layers?: [
    Layer
  ](name='layers'),
  nextToken?: string(name='nextToken', example='next-layer-name'),
}

model ListProvisionConfigsOutput {
  nextToken?: string(name='nextToken', example='next_token'),
  provisionConfigs?: [
    ProvisionConfig
  ](name='provisionConfigs'),
}

model ListTaggedResourcesOutput {
  nextToken?: string(name='nextToken', example='next_token'),
  resources?: [
    Resource
  ](name='resources'),
}

model ListTriggersOutput {
  nextToken?: string(name='nextToken', example='next_token'),
  triggers?: [
    Trigger
  ](name='triggers'),
}

model ListVersionsOutput {
  direction?: string(name='direction', example='FORWARD'),
  nextToken?: string(name='nextToken', example='3'),
  versions?: [
    Version
  ](name='versions'),
}

model ListVpcBindingsOutput {
  vpcIds?: [ string ](name='vpcIds'),
}

model LogConfig {
  enableInstanceMetrics?: boolean(name='enableInstanceMetrics', example='true'),
  enableRequestMetrics?: boolean(name='enableRequestMetrics', example='true'),
  logBeginRule?: string(name='logBeginRule', example='DefaultRegex'),
  logstore?: string(name='logstore', example='test-logstore'),
  project?: string(name='project', example='test-project'),
}

model NASConfig {
  groupId?: int32(name='groupId', example='100'),
  mountPoints?: [
    NASMountConfig
  ](name='mountPoints'),
  userId?: int32(name='userId', example='100'),
}

model NASMountConfig {
  enableTLS?: boolean(name='enableTLS'),
  mountDir?: string(name='mountDir', example='/home/test'),
  serverAddr?: string(name='serverAddr', example='***-uni85.cn-hangzhou.nas.com:/'),
}

model OSSMountConfig {
  mountPoints?: [
    OSSMountPoint
  ](name='mountPoints'),
}

model OSSMountPoint {
  bucketName?: string(name='bucketName', example='my-bucket'),
  bucketPath?: string(name='bucketPath', example='/my-dir'),
  endpoint?: string(name='endpoint', example='http://oss-cn-shanghai.aliyuncs.com'),
  mountDir?: string(name='mountDir', example='/mnt/dir'),
  readOnly?: boolean(name='readOnly', example='true'),
}

model OutputCodeLocation {
  location?: string(name='location', example='https://xyz.oss-cn-shanghai.aliyuncs.com/xxx/xxx/xxx'),
  repositoryType?: string(name='repositoryType', example='OSS'),
}

model OutputFuncCode {
  checksum?: string(name='checksum', example='1234567890'),
  url?: string(name='url', example='http://func-code.oss-cn-shanghai.aliyuncs.com/1a2b3c4d5e6f'),
}

model PathConfig {
  functionName?: string(name='functionName', example='myFunction'),
  methods?: [ string ](name='methods'),
  path?: string(name='path', example='/api/*'),
  qualifier?: string(name='qualifier', example='myAlias'),
  rewriteConfig?: RewriteConfig(name='rewriteConfig'),
}

model ProvisionConfig {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', example='true'),
  current?: long(name='current', example='1'),
  currentError?: string(name='currentError', example='image not found'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:124:functions/myFunction'),
  scheduledActions?: [
    ScheduledAction
  ](name='scheduledActions'),
  target?: long(name='target', example='5'),
  targetTrackingPolicies?: [
    TargetTrackingPolicy
  ](name='targetTrackingPolicies'),
}

model PublishVersionInput {
  description?: string(name='description', example='my version'),
}

model PutAsyncInvokeConfigInput {
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', example='300'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', example='3'),
}

model PutConcurrencyInput {
  reservedConcurrency?: long(name='reservedConcurrency', example='10'),
}

model PutProvisionConfigInput {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', example='true'),
  scheduledActions?: [
    ScheduledAction
  ](name='scheduledActions'),
  target?: long(name='target', example='1'),
  targetTrackingPolicies?: [
    TargetTrackingPolicy
  ](name='targetTrackingPolicies'),
}

model RegexRule {
  match?: string(name='match', example='^/api/.+?/(.*)'),
  replacement?: string(name='replacement', example='/api/v2/$1'),
}

model Resource {
  resourceArn?: string(name='resourceArn', example='acs:fc:cn-shanghai:****:functions/demo'),
  tags?: map[string]string(name='tags'),
}

model RewriteConfig {
  equalRules?: [
    EqualRule
  ](name='equalRules'),
  regexRules?: [
    RegexRule
  ](name='regexRules'),
  wildcardRules?: [
    WildcardRule
  ](name='wildcardRules'),
}

model RouteConfig {
  routes?: [
    PathConfig
  ](name='routes'),
}

model ScheduledAction {
  endTime?: string(name='endTime', example='2024-03-10T10:10:10Z'),
  name?: string(name='name', example='test_1'),
  scheduleExpression?: string(name='scheduleExpression', example='cron(0 0 22 * * *)'),
  startTime?: string(name='startTime', example='2023-03-10T10:10:10Z'),
  target?: long(name='target', example='50'),
}

model TLSConfig {
  cipherSuites?: [ string ](name='cipherSuites'),
  maxVersion?: string(name='maxVersion', example='TLSv1.3'),
  minVersion?: string(name='minVersion', example='TLSv1.0'),
}

model TagResourceInput {
  resourceArn?: string(name='resourceArn', example='acs:fc:cn-shanghai:xxx:functions/f1'),
  tags?: map[string]string(name='tags'),
}

model TargetTrackingPolicy {
  endTime?: string(name='endTime', example='2024-03-10T10:10:10Z'),
  maxCapacity?: long(name='maxCapacity', example='10'),
  metricTarget?: float(name='metricTarget', example='0.6'),
  metricType?: string(name='metricType', example='CPUUtilization'),
  minCapacity?: long(name='minCapacity', example='1'),
  name?: string(name='name', example='test_1'),
  startTime?: string(name='startTime', example='2023-03-10T10:10:10Z'),
}

model TracingConfig {
  params?: map[string]string(name='params'),
  type?: string(name='type', example='Jaeger'),
}

model Trigger {
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  httpTrigger?: HTTPTrigger(name='httpTrigger'),
  invocationRole?: string(name='invocationRole'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  qualifier?: string(name='qualifier'),
  sourceArn?: string(name='sourceArn'),
  status?: string(name='status'),
  targetArn?: string(name='targetArn'),
  triggerConfig?: string(name='triggerConfig'),
  triggerId?: string(name='triggerId'),
  triggerName?: string(name='triggerName'),
  triggerType?: string(name='triggerType'),
}

model UpdateAliasInput {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  description?: string(name='description', example='my alias'),
  versionId?: string(name='versionId', example='1'),
}

model UpdateCustomDomainInput {
  authConfig?: AuthConfig(name='authConfig'),
  certConfig?: CertConfig(name='certConfig'),
  protocol?: string(name='protocol', example='HTTP'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model UpdateFunctionInput {
  code?: InputCodeLocation(name='code'),
  cpu?: float(name='cpu', example='1'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description', example='my function'),
  diskSize?: int32(name='diskSize', example='512'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler', example='index.handler'),
  instanceConcurrency?: int32(name='instanceConcurrency', example='1'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess', example='true'),
  layers?: [ string ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize', example='512'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role', example='acs:ram::188077086902****:role/fc-test'),
  runtime?: string(name='runtime'),
  timeout?: int32(name='timeout', example='60'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model UpdateTriggerInput {
  description?: string(name='description', example='trigger for test'),
  invocationRole?: string(name='invocationRole', example='acs:ram::1234567890:role/fc-test'),
  qualifier?: string(name='qualifier', example='LATEST'),
  triggerConfig?: string(name='triggerConfig', example='{"events":["oss:ObjectCreated:*"],"filter":{"key":{"prefix":"/prefix","suffix":".zip"}}}'),
}

model VPCConfig {
  securityGroupId?: string(name='securityGroupId', example='sg-bp18hj1wtxgy3b0***'),
  vSwitchIds?: [ string ](name='vSwitchIds'),
  vpcId?: string(name='vpcId', example='vpc-***'),
}

model Version {
  createdTime?: string(name='createdTime', example='2006-01-02T15:04:05Z07:00'),
  description?: string(name='description', example='my version'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2006-01-02T15:04:05Z07:00'),
  versionId?: string(name='versionId', example='1'),
}

model WAFConfig {
  enableWAF?: boolean(name='enableWAF', example='true'),
}

model WildcardRule {
  match?: string(name='match', example='/api/*'),
  replacement?: string(name='replacement', example='/$1'),
}

model CreateAliasRequest {
  body?: CreateAliasInput(name='body'),
}

model CreateAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Alias  
}

/**
  * 创建函数别名
  *
  * @param request CreateAliasRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateAliasResponse
 */
async function createAliasWithOptions(functionName: string, request: CreateAliasRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAliasResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlias',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 创建函数别名
  *
  * @param request CreateAliasRequest
  * @return CreateAliasResponse
 */
async function createAlias(functionName: string, request: CreateAliasRequest): CreateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAliasWithOptions(functionName, request, headers, runtime);
}

model CreateCustomDomainRequest {
  body?: CreateCustomDomainInput(name='body'),
}

model CreateCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CustomDomain  
}

/**
  * 创建自定义域名
  *
  * @param request CreateCustomDomainRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateCustomDomainResponse
 */
async function createCustomDomainWithOptions(request: CreateCustomDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateCustomDomainResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCustomDomain',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 创建自定义域名
  *
  * @param request CreateCustomDomainRequest
  * @return CreateCustomDomainResponse
 */
async function createCustomDomain(request: CreateCustomDomainRequest): CreateCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createCustomDomainWithOptions(request, headers, runtime);
}

model CreateFunctionRequest {
  body?: CreateFunctionInput(name='body'),
}

model CreateFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Function  
}

/**
  * 创建函数
  *
  * @param request CreateFunctionRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateFunctionResponse
 */
async function createFunctionWithOptions(request: CreateFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFunctionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 创建函数
  *
  * @param request CreateFunctionRequest
  * @return CreateFunctionResponse
 */
async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFunctionWithOptions(request, headers, runtime);
}

model CreateLayerVersionRequest {
  body?: CreateLayerVersionInput(name='body'),
}

model CreateLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Layer  
}

/**
  * 创建层版本
  *
  * @param request CreateLayerVersionRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateLayerVersionResponse
 */
async function createLayerVersionWithOptions(layerName: string, request: CreateLayerVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLayerVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLayerVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 创建层版本
  *
  * @param request CreateLayerVersionRequest
  * @return CreateLayerVersionResponse
 */
async function createLayerVersion(layerName: string, request: CreateLayerVersionRequest): CreateLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLayerVersionWithOptions(layerName, request, headers, runtime);
}

model CreateTriggerRequest {
  body?: CreateTriggerInput(name='body'),
}

model CreateTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Trigger  
}

/**
  * 创建函数触发器
  *
  * @param request CreateTriggerRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateTriggerResponse
 */
async function createTriggerWithOptions(functionName: string, request: CreateTriggerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTriggerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTrigger',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 创建函数触发器
  *
  * @param request CreateTriggerRequest
  * @return CreateTriggerResponse
 */
async function createTrigger(functionName: string, request: CreateTriggerRequest): CreateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTriggerWithOptions(functionName, request, headers, runtime);
}

model CreateVpcBindingRequest {
  body?: CreateVpcBindingInput(name='body'),
}

model CreateVpcBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * 创建VPC绑定
  *
  * @param request CreateVpcBindingRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateVpcBindingResponse
 */
async function createVpcBindingWithOptions(functionName: string, request: CreateVpcBindingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateVpcBindingResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpcBinding',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/vpc-bindings`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * 创建VPC绑定
  *
  * @param request CreateVpcBindingRequest
  * @return CreateVpcBindingResponse
 */
async function createVpcBinding(functionName: string, request: CreateVpcBindingRequest): CreateVpcBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createVpcBindingWithOptions(functionName, request, headers, runtime);
}

model DeleteAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * 删除函数别名
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteAliasResponse
 */
async function deleteAliasWithOptions(functionName: string, aliasName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAliasResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlias',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases/${OpenApiUtil.getEncodeParam(aliasName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * 删除函数别名
  *
  * @return DeleteAliasResponse
 */
async function deleteAlias(functionName: string, aliasName: string): DeleteAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAliasWithOptions(functionName, aliasName, headers, runtime);
}

model DeleteAsyncInvokeConfigRequest {
  qualifier?: string(name='qualifier', example='LATEST, prod, 1'),
}

model DeleteAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * 删除函数异步调用配置
  *
  * @param request DeleteAsyncInvokeConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteAsyncInvokeConfigResponse
 */
async function deleteAsyncInvokeConfigWithOptions(functionName: string, request: DeleteAsyncInvokeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAsyncInvokeConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-invoke-config`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * 删除函数异步调用配置
  *
  * @param request DeleteAsyncInvokeConfigRequest
  * @return DeleteAsyncInvokeConfigResponse
 */
async function deleteAsyncInvokeConfig(functionName: string, request: DeleteAsyncInvokeConfigRequest): DeleteAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAsyncInvokeConfigWithOptions(functionName, request, headers, runtime);
}

model DeleteConcurrencyConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * 删除函数并发度配置
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteConcurrencyConfigResponse
 */
async function deleteConcurrencyConfigWithOptions(functionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConcurrencyConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteConcurrencyConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/concurrency`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * 删除函数并发度配置
  *
  * @return DeleteConcurrencyConfigResponse
 */
async function deleteConcurrencyConfig(functionName: string): DeleteConcurrencyConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConcurrencyConfigWithOptions(functionName, headers, runtime);
}

model DeleteCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * 删除自定义域名
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteCustomDomainResponse
 */
async function deleteCustomDomainWithOptions(domainName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteCustomDomainResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomDomain',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains/${OpenApiUtil.getEncodeParam(domainName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * 删除自定义域名
  *
  * @return DeleteCustomDomainResponse
 */
async function deleteCustomDomain(domainName: string): DeleteCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteCustomDomainWithOptions(domainName, headers, runtime);
}

model DeleteFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * 删除函数
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteFunctionResponse
 */
async function deleteFunctionWithOptions(functionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFunctionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * 删除函数
  *
  * @return DeleteFunctionResponse
 */
async function deleteFunction(functionName: string): DeleteFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionWithOptions(functionName, headers, runtime);
}

model DeleteFunctionVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * 删除函数版本
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteFunctionVersionResponse
 */
async function deleteFunctionVersionWithOptions(functionName: string, versionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFunctionVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunctionVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/versions/${OpenApiUtil.getEncodeParam(versionId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * 删除函数版本
  *
  * @return DeleteFunctionVersionResponse
 */
async function deleteFunctionVersion(functionName: string, versionId: string): DeleteFunctionVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionVersionWithOptions(functionName, versionId, headers, runtime);
}

model DeleteLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * 删除层版本
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteLayerVersionResponse
 */
async function deleteLayerVersionWithOptions(layerName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLayerVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLayerVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions/${OpenApiUtil.getEncodeParam(version)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * 删除层版本
  *
  * @return DeleteLayerVersionResponse
 */
async function deleteLayerVersion(layerName: string, version: string): DeleteLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLayerVersionWithOptions(layerName, version, headers, runtime);
}

model DeleteProvisionConfigRequest {
  qualifier?: string(name='qualifier', example='LATEST, prod'),
}

model DeleteProvisionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * 删除函数预留配置
  *
  * @param request DeleteProvisionConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteProvisionConfigResponse
 */
async function deleteProvisionConfigWithOptions(functionName: string, request: DeleteProvisionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProvisionConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProvisionConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/provision-config`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * 删除函数预留配置
  *
  * @param request DeleteProvisionConfigRequest
  * @return DeleteProvisionConfigResponse
 */
async function deleteProvisionConfig(functionName: string, request: DeleteProvisionConfigRequest): DeleteProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProvisionConfigWithOptions(functionName, request, headers, runtime);
}

model DeleteTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * 删除函数触发器
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteTriggerResponse
 */
async function deleteTriggerWithOptions(functionName: string, triggerName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTriggerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteTrigger',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers/${OpenApiUtil.getEncodeParam(triggerName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * 删除函数触发器
  *
  * @return DeleteTriggerResponse
 */
async function deleteTrigger(functionName: string, triggerName: string): DeleteTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTriggerWithOptions(functionName, triggerName, headers, runtime);
}

model DeleteVpcBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * 删除VPC绑定
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteVpcBindingResponse
 */
async function deleteVpcBindingWithOptions(functionName: string, vpcId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteVpcBindingResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpcBinding',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/vpc-bindings/${OpenApiUtil.getEncodeParam(vpcId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * 删除VPC绑定
  *
  * @return DeleteVpcBindingResponse
 */
async function deleteVpcBinding(functionName: string, vpcId: string): DeleteVpcBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteVpcBindingWithOptions(functionName, vpcId, headers, runtime);
}

model GetAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Alias  
}

/**
  * 获取函数别名信息
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetAliasResponse
 */
async function getAliasWithOptions(functionName: string, aliasName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAliasResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAlias',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases/${OpenApiUtil.getEncodeParam(aliasName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 获取函数别名信息
  *
  * @return GetAliasResponse
 */
async function getAlias(functionName: string, aliasName: string): GetAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAliasWithOptions(functionName, aliasName, headers, runtime);
}

model GetAsyncInvokeConfigRequest {
  qualifier?: string(name='qualifier', example='LATEST, prod, 1'),
}

model GetAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AsyncConfig  
}

/**
  * 获取函数异步调用配置
  *
  * @param request GetAsyncInvokeConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetAsyncInvokeConfigResponse
 */
async function getAsyncInvokeConfigWithOptions(functionName: string, request: GetAsyncInvokeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAsyncInvokeConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-invoke-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 获取函数异步调用配置
  *
  * @param request GetAsyncInvokeConfigRequest
  * @return GetAsyncInvokeConfigResponse
 */
async function getAsyncInvokeConfig(functionName: string, request: GetAsyncInvokeConfigRequest): GetAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAsyncInvokeConfigWithOptions(functionName, request, headers, runtime);
}

model GetConcurrencyConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConcurrencyConfig  
}

/**
  * 获取函数并发度配置
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetConcurrencyConfigResponse
 */
async function getConcurrencyConfigWithOptions(functionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetConcurrencyConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetConcurrencyConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/concurrency`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 获取函数并发度配置
  *
  * @return GetConcurrencyConfigResponse
 */
async function getConcurrencyConfig(functionName: string): GetConcurrencyConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getConcurrencyConfigWithOptions(functionName, headers, runtime);
}

model GetCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CustomDomain  
}

/**
  * 获取自定义域名
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetCustomDomainResponse
 */
async function getCustomDomainWithOptions(domainName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetCustomDomainResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetCustomDomain',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains/${OpenApiUtil.getEncodeParam(domainName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 获取自定义域名
  *
  * @return GetCustomDomainResponse
 */
async function getCustomDomain(domainName: string): GetCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCustomDomainWithOptions(domainName, headers, runtime);
}

model GetFunctionRequest {
  qualifier?: string(name='qualifier', example='LATEST, prod, 1'),
}

model GetFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Function  
}

/**
  * 获取函数信息
  *
  * @param request GetFunctionRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetFunctionResponse
 */
async function getFunctionWithOptions(functionName: string, request: GetFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 获取函数信息
  *
  * @param request GetFunctionRequest
  * @return GetFunctionResponse
 */
async function getFunction(functionName: string, request: GetFunctionRequest): GetFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionWithOptions(functionName, request, headers, runtime);
}

model GetFunctionCodeRequest {
  qualifier?: string(name='qualifier', example='LATEST, prod, 1'),
}

model GetFunctionCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OutputFuncCode  
}

/**
  * 获取函数代码
  *
  * @param request GetFunctionCodeRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetFunctionCodeResponse
 */
async function getFunctionCodeWithOptions(functionName: string, request: GetFunctionCodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionCodeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunctionCode',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/code`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 获取函数代码
  *
  * @param request GetFunctionCodeRequest
  * @return GetFunctionCodeResponse
 */
async function getFunctionCode(functionName: string, request: GetFunctionCodeRequest): GetFunctionCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionCodeWithOptions(functionName, request, headers, runtime);
}

model GetLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Layer  
}

/**
  * 获取层版本
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetLayerVersionResponse
 */
async function getLayerVersionWithOptions(layerName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLayerVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLayerVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions/${OpenApiUtil.getEncodeParam(version)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 获取层版本
  *
  * @return GetLayerVersionResponse
 */
async function getLayerVersion(layerName: string, version: string): GetLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLayerVersionWithOptions(layerName, version, headers, runtime);
}

model GetLayerVersionByArnResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Layer  
}

/**
  * 根据资源标识获取层版本
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetLayerVersionByArnResponse
 */
async function getLayerVersionByArnWithOptions(arn: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLayerVersionByArnResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLayerVersionByArn',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layerarn/${OpenApiUtil.getEncodeParam(arn)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 根据资源标识获取层版本
  *
  * @return GetLayerVersionByArnResponse
 */
async function getLayerVersionByArn(arn: string): GetLayerVersionByArnResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLayerVersionByArnWithOptions(arn, headers, runtime);
}

model GetProvisionConfigRequest {
  qualifier?: string(name='qualifier', example='LATEST, prod'),
}

model GetProvisionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ProvisionConfig  
}

/**
  * 获取函数预留配置
  *
  * @param request GetProvisionConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetProvisionConfigResponse
 */
async function getProvisionConfigWithOptions(functionName: string, request: GetProvisionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProvisionConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProvisionConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/provision-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 获取函数预留配置
  *
  * @param request GetProvisionConfigRequest
  * @return GetProvisionConfigResponse
 */
async function getProvisionConfig(functionName: string, request: GetProvisionConfigRequest): GetProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProvisionConfigWithOptions(functionName, request, headers, runtime);
}

model GetResourceTagsRequest {
  arn?: string(name='arn', example='acs:fc:cn-shanghai:1234/functions/my-func'),
}

model GetResourceTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceTagsOutput  
}

/**
  * 获取资源标签
  *
  * @param request GetResourceTagsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetResourceTagsResponse
 */
async function getResourceTagsWithOptions(request: GetResourceTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetResourceTagsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.arn)) {
    query['arn'] = request.arn;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceTags',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/tag`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 获取资源标签
  *
  * @param request GetResourceTagsRequest
  * @return GetResourceTagsResponse
 */
async function getResourceTags(request: GetResourceTagsRequest): GetResourceTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getResourceTagsWithOptions(request, headers, runtime);
}

model GetTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Trigger  
}

/**
  * 获取函数触发器
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetTriggerResponse
 */
async function getTriggerWithOptions(functionName: string, triggerName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTriggerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTrigger',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers/${OpenApiUtil.getEncodeParam(triggerName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 获取函数触发器
  *
  * @return GetTriggerResponse
 */
async function getTrigger(functionName: string, triggerName: string): GetTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTriggerWithOptions(functionName, triggerName, headers, runtime);
}

model InvokeFunctionHeaders {
  commonHeaders?: map[string]string,
  xFcInvocationType?: string(name='x-fc-invocation-type', example='Sync, Async'),
  xFcLogType?: string(name='x-fc-log-type', example='None, Tail'),
}

model InvokeFunctionRequest {
  body?: readable(name='body'),
  qualifier?: string(name='qualifier', example='LATEST, prod, 1'),
}

model InvokeFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: readable(name='body'),
}

/**
  * 调用函数
  *
  * @param request InvokeFunctionRequest
  * @param headers InvokeFunctionHeaders
  * @param runtime runtime options for this request RuntimeOptions
  * @return InvokeFunctionResponse
 */
async function invokeFunctionWithOptions(functionName: string, request: InvokeFunctionRequest, headers: InvokeFunctionHeaders, runtime: Util.RuntimeOptions): InvokeFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcInvocationType)) {
    realHeaders['x-fc-invocation-type'] = Util.toJSONString(headers.xFcInvocationType);
  }
  if (!Util.isUnset(headers.xFcLogType)) {
    realHeaders['x-fc-log-type'] = Util.toJSONString(headers.xFcLogType);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = request.body,
    stream = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InvokeFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/invocations`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'binary',
  };
  var res = new InvokeFunctionResponse{};
  var tmp = Util.assertAsMap(callApi(params, req, runtime));
  if (!Util.isUnset(tmp.body)) {
    var respBody = Util.assertAsReadable(tmp.body);
    res.body = respBody;
  }
  if (!Util.isUnset(tmp.headers)) {
    var respHeaders = Util.assertAsMap(tmp.headers);
    res.headers = Util.stringifyMapValue(respHeaders);
  }
  if (!Util.isUnset(tmp.statusCode)) {
    var statusCode = Util.assertAsInteger(tmp.statusCode);
    res.statusCode = statusCode;
  }
  return res;
}

/**
  * 调用函数
  *
  * @param request InvokeFunctionRequest
  * @return InvokeFunctionResponse
 */
async function invokeFunction(functionName: string, request: InvokeFunctionRequest): InvokeFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new InvokeFunctionHeaders{};
  return invokeFunctionWithOptions(functionName, request, headers, runtime);
}

model ListAliasesRequest {
  limit?: int32(name='limit', example='10'),
  nextToken?: string(name='nextToken', example='MTIzNCNhYmM='),
  prefix?: string(name='prefix', example='my-alias'),
}

model ListAliasesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAliasesOutput  
}

/**
  * 列出函数别名
  *
  * @param request ListAliasesRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListAliasesResponse
 */
async function listAliasesWithOptions(functionName: string, request: ListAliasesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAliasesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAliases',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 列出函数别名
  *
  * @param request ListAliasesRequest
  * @return ListAliasesResponse
 */
async function listAliases(functionName: string, request: ListAliasesRequest): ListAliasesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAliasesWithOptions(functionName, request, headers, runtime);
}

model ListAsyncInvokeConfigsRequest {
  functionName?: string(name='functionName', example='my-func'),
  limit?: int32(name='limit', example='10'),
  nextToken?: string(name='nextToken', example='MTIzNCNhYmM='),
}

model ListAsyncInvokeConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAsyncInvokeConfigOutput  
}

/**
  * 列出函数异步调用配置
  *
  * @param request ListAsyncInvokeConfigsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListAsyncInvokeConfigsResponse
 */
async function listAsyncInvokeConfigsWithOptions(request: ListAsyncInvokeConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAsyncInvokeConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.functionName)) {
    query['functionName'] = request.functionName;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAsyncInvokeConfigs',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/async-invoke-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 列出函数异步调用配置
  *
  * @param request ListAsyncInvokeConfigsRequest
  * @return ListAsyncInvokeConfigsResponse
 */
async function listAsyncInvokeConfigs(request: ListAsyncInvokeConfigsRequest): ListAsyncInvokeConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAsyncInvokeConfigsWithOptions(request, headers, runtime);
}

model ListConcurrencyConfigsRequest {
  functionName?: string(name='functionName', example='my-func'),
  limit?: int32(name='limit', example='10'),
  nextToken?: string(name='nextToken', example='MTIzNCNhYmM='),
}

model ListConcurrencyConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConcurrencyConfigsOutput  
}

/**
  * 列出函数并发度配置
  *
  * @param request ListConcurrencyConfigsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListConcurrencyConfigsResponse
 */
async function listConcurrencyConfigsWithOptions(request: ListConcurrencyConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListConcurrencyConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.functionName)) {
    query['functionName'] = request.functionName;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConcurrencyConfigs',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/concurrency-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 列出函数并发度配置
  *
  * @param request ListConcurrencyConfigsRequest
  * @return ListConcurrencyConfigsResponse
 */
async function listConcurrencyConfigs(request: ListConcurrencyConfigsRequest): ListConcurrencyConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConcurrencyConfigsWithOptions(request, headers, runtime);
}

model ListCustomDomainsRequest {
  limit?: int32(name='limit', example='10'),
  nextToken?: string(name='nextToken', example='MTIzNCNhYmM='),
  prefix?: string(name='prefix', example='foo'),
}

model ListCustomDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCustomDomainOutput  
}

/**
  * 列出自定义域名
  *
  * @param request ListCustomDomainsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListCustomDomainsResponse
 */
async function listCustomDomainsWithOptions(request: ListCustomDomainsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCustomDomainsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCustomDomains',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 列出自定义域名
  *
  * @param request ListCustomDomainsRequest
  * @return ListCustomDomainsResponse
 */
async function listCustomDomains(request: ListCustomDomainsRequest): ListCustomDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCustomDomainsWithOptions(request, headers, runtime);
}

model ListFunctionVersionsRequest {
  direction?: string(name='direction', example='BACKWARD, FORWARD'),
  limit?: int32(name='limit', example='10'),
  nextToken?: string(name='nextToken', example='MTIzNCNhYmM='),
}

model ListFunctionVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVersionsOutput  
}

/**
  * 列出函数版本
  *
  * @param request ListFunctionVersionsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListFunctionVersionsResponse
 */
async function listFunctionVersionsWithOptions(functionName: string, request: ListFunctionVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.direction)) {
    query['direction'] = request.direction;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctionVersions',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 列出函数版本
  *
  * @param request ListFunctionVersionsRequest
  * @return ListFunctionVersionsResponse
 */
async function listFunctionVersions(functionName: string, request: ListFunctionVersionsRequest): ListFunctionVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionVersionsWithOptions(functionName, request, headers, runtime);
}

model ListFunctionsRequest {
  limit?: int32(name='limit', example='10'),
  nextToken?: string(name='nextToken', example='MTIzNCNhYmM='),
  prefix?: string(name='prefix', example='my-func'),
}

model ListFunctionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFunctionsOutput  
}

/**
  * 列出函数
  *
  * @param request ListFunctionsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListFunctionsResponse
 */
async function listFunctionsWithOptions(request: ListFunctionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctions',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 列出函数
  *
  * @param request ListFunctionsRequest
  * @return ListFunctionsResponse
 */
async function listFunctions(request: ListFunctionsRequest): ListFunctionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionsWithOptions(request, headers, runtime);
}

model ListInstancesRequest {
  qualifier?: string(name='qualifier', example='LATEST, prod, 1'),
  withAllActive?: boolean(name='withAllActive'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstancesOutput  
}

/**
  * 列出函数实例
  *
  * @param request ListInstancesRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListInstancesResponse
 */
async function listInstancesWithOptions(functionName: string, request: ListInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }
  if (!Util.isUnset(request.withAllActive)) {
    query['withAllActive'] = request.withAllActive;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 列出函数实例
  *
  * @param request ListInstancesRequest
  * @return ListInstancesResponse
 */
async function listInstances(functionName: string, request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstancesWithOptions(functionName, request, headers, runtime);
}

model ListLayerVersionsRequest {
  limit?: int32(name='limit', example='10'),
  startVersion?: string(name='startVersion', example='1'),
}

model ListLayerVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLayerVersionOutput  
}

/**
  * 列出层版本
  *
  * @param request ListLayerVersionsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListLayerVersionsResponse
 */
async function listLayerVersionsWithOptions(layerName: string, request: ListLayerVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLayerVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.startVersion)) {
    query['startVersion'] = request.startVersion;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLayerVersions',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 列出层版本
  *
  * @param request ListLayerVersionsRequest
  * @return ListLayerVersionsResponse
 */
async function listLayerVersions(layerName: string, request: ListLayerVersionsRequest): ListLayerVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLayerVersionsWithOptions(layerName, request, headers, runtime);
}

model ListLayersRequest {
  limit?: int32(name='limit', example='10'),
  nextToken?: string(name='nextToken', example='MTIzNCNhYmM='),
  official?: string(name='official', example='false, true'),
  prefix?: string(name='prefix', example='my-layer'),
  public?: string(name='public', example='false, true'),
}

model ListLayersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLayersOutput  
}

/**
  * 列出层
  *
  * @param request ListLayersRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListLayersResponse
 */
async function listLayersWithOptions(request: ListLayersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLayersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.official)) {
    query['official'] = request.official;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.public)) {
    query['public'] = request.public;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLayers',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 列出层
  *
  * @param request ListLayersRequest
  * @return ListLayersResponse
 */
async function listLayers(request: ListLayersRequest): ListLayersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLayersWithOptions(request, headers, runtime);
}

model ListProvisionConfigsRequest {
  functionName?: string(name='functionName', example='my-func'),
  limit?: int32(name='limit', example='10'),
  nextToken?: string(name='nextToken', example='MTIzNCNhYmM='),
}

model ListProvisionConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProvisionConfigsOutput  
}

/**
  * 列出函数预留配置
  *
  * @param request ListProvisionConfigsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListProvisionConfigsResponse
 */
async function listProvisionConfigsWithOptions(request: ListProvisionConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProvisionConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.functionName)) {
    query['functionName'] = request.functionName;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProvisionConfigs',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/provision-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 列出函数预留配置
  *
  * @param request ListProvisionConfigsRequest
  * @return ListProvisionConfigsResponse
 */
async function listProvisionConfigs(request: ListProvisionConfigsRequest): ListProvisionConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProvisionConfigsWithOptions(request, headers, runtime);
}

model ListTaggedResourcesRequest {
  limit?: int32(name='limit', example='10'),
  nextToken?: string(name='nextToken', example='MTIzNCNhYmM='),
}

model ListTaggedResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTaggedResourcesOutput  
}

/**
  * 列出具有标签的资源
  *
  * @param request ListTaggedResourcesRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListTaggedResourcesResponse
 */
async function listTaggedResourcesWithOptions(request: ListTaggedResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTaggedResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTaggedResources',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 列出具有标签的资源
  *
  * @param request ListTaggedResourcesRequest
  * @return ListTaggedResourcesResponse
 */
async function listTaggedResources(request: ListTaggedResourcesRequest): ListTaggedResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTaggedResourcesWithOptions(request, headers, runtime);
}

model ListTriggersRequest {
  limit?: int32(name='limit', example='10'),
  nextToken?: string(name='nextToken', example='MTIzNCNhYmM='),
  prefix?: string(name='prefix', example='my-trigger'),
}

model ListTriggersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTriggersOutput  
}

/**
  * 列出函数触发器
  *
  * @param request ListTriggersRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListTriggersResponse
 */
async function listTriggersWithOptions(functionName: string, request: ListTriggersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTriggersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTriggers',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 列出函数触发器
  *
  * @param request ListTriggersRequest
  * @return ListTriggersResponse
 */
async function listTriggers(functionName: string, request: ListTriggersRequest): ListTriggersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTriggersWithOptions(functionName, request, headers, runtime);
}

model ListVpcBindingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVpcBindingsOutput  
}

/**
  * 列出VPC绑定配置
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListVpcBindingsResponse
 */
async function listVpcBindingsWithOptions(functionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListVpcBindingsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListVpcBindings',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/vpc-bindings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 列出VPC绑定配置
  *
  * @return ListVpcBindingsResponse
 */
async function listVpcBindings(functionName: string): ListVpcBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVpcBindingsWithOptions(functionName, headers, runtime);
}

model PublishFunctionVersionRequest {
  body?: PublishVersionInput(name='body'),
}

model PublishFunctionVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Version  
}

/**
  * 发布函数版本
  *
  * @param request PublishFunctionVersionRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return PublishFunctionVersionResponse
 */
async function publishFunctionVersionWithOptions(functionName: string, request: PublishFunctionVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PublishFunctionVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PublishFunctionVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 发布函数版本
  *
  * @param request PublishFunctionVersionRequest
  * @return PublishFunctionVersionResponse
 */
async function publishFunctionVersion(functionName: string, request: PublishFunctionVersionRequest): PublishFunctionVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return publishFunctionVersionWithOptions(functionName, request, headers, runtime);
}

model PutAsyncInvokeConfigRequest {
  body?: PutAsyncInvokeConfigInput(name='body'),
  qualifier?: string(name='qualifier', example='LATEST, prod, 1'),
}

model PutAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AsyncConfig  
}

/**
  * 设置函数异步调用配置
  *
  * @param request PutAsyncInvokeConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return PutAsyncInvokeConfigResponse
 */
async function putAsyncInvokeConfigWithOptions(functionName: string, request: PutAsyncInvokeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PutAsyncInvokeConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-invoke-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 设置函数异步调用配置
  *
  * @param request PutAsyncInvokeConfigRequest
  * @return PutAsyncInvokeConfigResponse
 */
async function putAsyncInvokeConfig(functionName: string, request: PutAsyncInvokeConfigRequest): PutAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putAsyncInvokeConfigWithOptions(functionName, request, headers, runtime);
}

model PutConcurrencyConfigRequest {
  body?: PutConcurrencyInput(name='body'),
}

model PutConcurrencyConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConcurrencyConfig  
}

/**
  * 设置函数并发度配置
  *
  * @param request PutConcurrencyConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return PutConcurrencyConfigResponse
 */
async function putConcurrencyConfigWithOptions(functionName: string, request: PutConcurrencyConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutConcurrencyConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PutConcurrencyConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/concurrency`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 设置函数并发度配置
  *
  * @param request PutConcurrencyConfigRequest
  * @return PutConcurrencyConfigResponse
 */
async function putConcurrencyConfig(functionName: string, request: PutConcurrencyConfigRequest): PutConcurrencyConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putConcurrencyConfigWithOptions(functionName, request, headers, runtime);
}

model PutLayerACLRequest {
  public?: string(name='public', example='false, true'),
}

model PutLayerACLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * 设置层的访问权限
  *
  * @param request PutLayerACLRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return PutLayerACLResponse
 */
async function putLayerACLWithOptions(layerName: string, request: PutLayerACLRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutLayerACLResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.public)) {
    query['public'] = request.public;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutLayerACL',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/acl`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * 设置层的访问权限
  *
  * @param request PutLayerACLRequest
  * @return PutLayerACLResponse
 */
async function putLayerACL(layerName: string, request: PutLayerACLRequest): PutLayerACLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putLayerACLWithOptions(layerName, request, headers, runtime);
}

model PutProvisionConfigRequest {
  body?: PutProvisionConfigInput(name='body'),
  qualifier?: string(name='qualifier', example='LATEST, prod'),
}

model PutProvisionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ProvisionConfig  
}

/**
  * 设置函数预留配置
  *
  * @param request PutProvisionConfigRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return PutProvisionConfigResponse
 */
async function putProvisionConfigWithOptions(functionName: string, request: PutProvisionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutProvisionConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PutProvisionConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/provision-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 设置函数预留配置
  *
  * @param request PutProvisionConfigRequest
  * @return PutProvisionConfigResponse
 */
async function putProvisionConfig(functionName: string, request: PutProvisionConfigRequest): PutProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putProvisionConfigWithOptions(functionName, request, headers, runtime);
}

model TagResourceRequest {
  body?: TagResourceInput(name='body'),
}

model TagResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * 设置资源标签
  *
  * @param request TagResourceRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return TagResourceResponse
 */
async function tagResourceWithOptions(request: TagResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'TagResource',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/tag`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * 设置资源标签
  *
  * @param request TagResourceRequest
  * @return TagResourceResponse
 */
async function tagResource(request: TagResourceRequest): TagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourceWithOptions(request, headers, runtime);
}

model UntagResourceRequest {
  all?: boolean(name='all'),
  arn?: string(name='arn', example='acs:fc:cn-shanghai:1234/functions/my-func'),
  tagKeys?: string(name='tagKeys', example='tag1, tag2'),
}

model UntagResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * 删除资源标签
  *
  * @param request UntagResourceRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UntagResourceResponse
 */
async function untagResourceWithOptions(request: UntagResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    query['all'] = request.all;
  }
  if (!Util.isUnset(request.arn)) {
    query['arn'] = request.arn;
  }
  if (!Util.isUnset(request.tagKeys)) {
    query['tagKeys'] = request.tagKeys;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResource',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/tag`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * 删除资源标签
  *
  * @param request UntagResourceRequest
  * @return UntagResourceResponse
 */
async function untagResource(request: UntagResourceRequest): UntagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourceWithOptions(request, headers, runtime);
}

model UpdateAliasRequest {
  body?: UpdateAliasInput(name='body'),
}

model UpdateAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Alias  
}

/**
  * 更新函数别名
  *
  * @param request UpdateAliasRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateAliasResponse
 */
async function updateAliasWithOptions(functionName: string, aliasName: string, request: UpdateAliasRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAliasResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlias',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases/${OpenApiUtil.getEncodeParam(aliasName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 更新函数别名
  *
  * @param request UpdateAliasRequest
  * @return UpdateAliasResponse
 */
async function updateAlias(functionName: string, aliasName: string, request: UpdateAliasRequest): UpdateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAliasWithOptions(functionName, aliasName, request, headers, runtime);
}

model UpdateCustomDomainRequest {
  body?: UpdateCustomDomainInput(name='body'),
}

model UpdateCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CustomDomain  
}

/**
  * 更新自定义域名
  *
  * @param request UpdateCustomDomainRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateCustomDomainResponse
 */
async function updateCustomDomainWithOptions(domainName: string, request: UpdateCustomDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCustomDomainResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCustomDomain',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains/${OpenApiUtil.getEncodeParam(domainName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 更新自定义域名
  *
  * @param request UpdateCustomDomainRequest
  * @return UpdateCustomDomainResponse
 */
async function updateCustomDomain(domainName: string, request: UpdateCustomDomainRequest): UpdateCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCustomDomainWithOptions(domainName, request, headers, runtime);
}

model UpdateFunctionRequest {
  body?: UpdateFunctionInput(name='body'),
}

model UpdateFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Function  
}

/**
  * 更新函数
  *
  * @param request UpdateFunctionRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateFunctionResponse
 */
async function updateFunctionWithOptions(functionName: string, request: UpdateFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFunctionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 更新函数
  *
  * @param request UpdateFunctionRequest
  * @return UpdateFunctionResponse
 */
async function updateFunction(functionName: string, request: UpdateFunctionRequest): UpdateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFunctionWithOptions(functionName, request, headers, runtime);
}

model UpdateTriggerRequest {
  body?: UpdateTriggerInput(name='body'),
}

model UpdateTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Trigger  
}

/**
  * 更新函数触发器
  *
  * @param request UpdateTriggerRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateTriggerResponse
 */
async function updateTriggerWithOptions(functionName: string, triggerName: string, request: UpdateTriggerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTriggerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTrigger',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers/${OpenApiUtil.getEncodeParam(triggerName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 更新函数触发器
  *
  * @param request UpdateTriggerRequest
  * @return UpdateTriggerResponse
 */
async function updateTrigger(functionName: string, triggerName: string, request: UpdateTriggerRequest): UpdateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTriggerWithOptions(functionName, triggerName, request, headers, runtime);
}

