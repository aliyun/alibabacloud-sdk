/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('fc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AccelerationInfo {
  status?: string(name='status', example='deprecated'),
}

model Alias {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName?: string(name='aliasName', example='prod'),
  createdTime?: string(name='createdTime', example='2006-01-02T15:04:05Z07:00'),
  description?: string(name='description', example='alias for pre env'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2006-01-02T15:04:05Z07:00'),
  versionId?: string(name='versionId', example='1'),
}

model AsyncConfig {
  asyncTask?: boolean(name='asyncTask', example='true'),
  createdTime?: string(name='createdTime', example='2006-01-02T15:04:05Z07:00'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:1234/functions/my-func'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2006-01-02T15:04:05Z07:00'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', example='3600'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', example='3'),
}

model AsyncTask {
  alreadyRetriedTimes?: long(name='alreadyRetriedTimes', example='3'),
  destinationStatus?: string(name='destinationStatus', example='Succeeded'),
  durationMs?: long(name='durationMs', example='1000'),
  endTime?: long(name='endTime', example='1633449590000'),
  events?: [
    AsyncTaskEvent
  ](name='events'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:1234/functions/my-func'),
  instanceId?: string(name='instanceId', example='D4-*******9FD1-882707E'),
  qualifier?: string(name='qualifier', example='prod'),
  requestId?: string(name='requestId', example='e026ae92-61e5-472f-b32d-1c9e3c4e****'),
  returnPayload?: string(name='returnPayload', example='result'),
  startedTime?: long(name='startedTime', example='1633449590000'),
  status?: string(name='status', example='Running'),
  taskErrorMessage?: string(name='taskErrorMessage', example='UnhandledInvocationError'),
  taskId?: string(name='taskId', example='e026ae92-61e5-472f-b32d-1c9e3c4e****'),
  taskPayload?: string(name='taskPayload', example='body'),
}

model AsyncTaskEvent {
  eventDetail?: string(name='eventDetail', example='body'),
  eventId?: long(name='eventId', example='1'),
  status?: string(name='status', example='Succeeded'),
  timestamp?: long(name='timestamp', example='1647420449721'),
}

model AuthConfig {
  authInfo?: string(name='authInfo', example='{}'),
  authType?: string(name='authType', example='anonymous, function, jwt'),
}

model BatchWindow {
  countBasedWindow?: int32(name='CountBasedWindow', example='100'),
  timeBasedWindow?: int32(name='TimeBasedWindow', example='10'),
}

model CDNTriggerConfig {
  eventName?: string(name='eventName', example='CdnDomainStarted'),
  eventVersion?: string(name='eventVersion', example='1.0.0'),
  filter?: map[string][ string ](name='filter'),
  notes?: string(name='notes', example='缓存事件触发器'),
}

model CertConfig {
  certName?: string(name='certName', example='my-cert'),
  certificate?: string(name='certificate', example='PEM format'),
  privateKey?: string(name='privateKey', example='PEM format'),
}

model ConcurrencyConfig {
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:123:functions/demo'),
  reservedConcurrency?: long(name='reservedConcurrency', example='10'),
}

model CreateAliasInput {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName?: string(name='aliasName', example='prod'),
  description?: string(name='description', example='my alias'),
  versionId?: string(name='versionId', example='1'),
}

model CreateCustomDomainInput {
  authConfig?: AuthConfig(name='authConfig'),
  certConfig?: CertConfig(name='certConfig'),
  domainName?: string(name='domainName', example='example.com'),
  protocol?: string(name='protocol', example='HTTP'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model CreateFunctionInput {
  code?: InputCodeLocation(name='code'),
  cpu?: float(name='cpu', example='1'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description', example='my function'),
  diskSize?: int32(name='diskSize', example='512'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionName?: string(name='functionName', example='my-function-1'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler', example='index.handler'),
  instanceConcurrency?: int32(name='instanceConcurrency', example='1'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess', example='true'),
  layers?: [ string ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize', example='512'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role', example='acs:ram::188077086902****:role/fc-test'),
  runtime?: string(name='runtime', example='python3.10'),
  timeout?: int32(name='timeout', example='60'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model CreateLayerVersionInput {
  code?: InputCodeLocation(name='code'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  description?: string(name='description', example='my first layer'),
  license?: string(name='license', example='Apache'),
}

model CreateTriggerInput {
  description?: string(name='description', example='trigger for test'),
  invocationRole?: string(name='invocationRole', example='acs:ram::1234567890:role/fc-test'),
  qualifier?: string(name='qualifier', example='LATEST'),
  sourceArn?: string(name='sourceArn', example='acs:oss:cn-shanghai:12345:mybucket'),
  triggerConfig?: string(name='triggerConfig', example='{"events":["oss:ObjectCreated:*"],"filter":{"key":{"prefix":"/prefix","suffix":".zip"}}}'),
  triggerName?: string(name='triggerName', example='oss_create_object_demo'),
  triggerType?: string(name='triggerType', example='oss'),
}

model CreateVpcBindingInput {
  vpcId?: string(name='vpcId', example='vpc-8vb8x8dggvr0axxxxxxxx'),
}

model CustomContainerConfig {
  accelerationInfo?: AccelerationInfo(name='accelerationInfo'),
  accelerationType?: string(name='accelerationType', example='deprecated'),
  acrInstanceId?: string(name='acrInstanceId', example='deprecated'),
  command?: [ string ](name='command'),
  entrypoint?: [ string ](name='entrypoint'),
  healthCheckConfig?: CustomHealthCheckConfig(name='healthCheckConfig'),
  image?: string(name='image', example='registry-vpc.cn-hangzhou.aliyuncs.com/fc-demo/helloworld:v1'),
  port?: int32(name='port', example='9000'),
  resolvedImageUri?: string(name='resolvedImageUri', example='stand-sh-registry-vpc.cn-shanghai.cr.aliyuncs.com/fc-demo2/springboot-helloworld@sha256:68d1****0d64d6'),
}

model CustomDNS {
  dnsOptions?: [
    DNSOption
  ](name='dnsOptions'),
  nameServers?: [ string ](name='nameServers'),
  searches?: [ string ](name='searches'),
}

model CustomDomain {
  accountId?: string(name='accountId'),
  apiVersion?: string(name='apiVersion', example='2023-03-30'),
  authConfig?: AuthConfig(name='authConfig'),
  certConfig?: CertConfig(name='certConfig'),
  createdTime?: string(name='createdTime', example='2023-03-30T08:02:19Z'),
  domainName?: string(name='domainName', example='example.com'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2023-03-30T08:02:19Z'),
  protocol?: string(name='protocol', example='HTTP'),
  routeConfig?: RouteConfig(name='routeConfig'),
  subdomainCount?: string(name='subdomainCount', example='1'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model CustomHealthCheckConfig {
  failureThreshold?: int32(name='failureThreshold', example='1'),
  httpGetUrl?: string(name='httpGetUrl', example='/ready'),
  initialDelaySeconds?: int32(name='initialDelaySeconds', example='1'),
  periodSeconds?: int32(name='periodSeconds', example='1'),
  successThreshold?: int32(name='successThreshold', example='2'),
  timeoutSeconds?: int32(name='timeoutSeconds', example='2'),
}

model CustomRuntimeConfig {
  args?: [ string ](name='args'),
  command?: [ string ](name='command'),
  healthCheckConfig?: CustomHealthCheckConfig(name='healthCheckConfig'),
  port?: int32(name='port', example='9000'),
}

model DNSOption {
  name?: string(name='name', example='ndots'),
  value?: string(name='value', example='2'),
}

model DeadLetterQueue {
  arn?: string(name='Arn', example='acs:mq:cn-shanghai:14319991365*****:/instances/MQ_INST_14319991365*****_BYWs****/topic/testTopic'),
}

model DeliveryOption {
  concurrency?: long(name='concurrency', example='2'),
  eventSchema?: string(name='eventSchema', example='RawData'),
}

model Destination {
  destination?: string(name='destination', example='acs:fc:cn-shanghai:xxx:functions/f1'),
}

model DestinationConfig {
  onFailure?: Destination(name='onFailure'),
  onSuccess?: Destination(name='onSuccess'),
}

model EqualRule {
  match?: string(name='match', example='/old'),
  replacement?: string(name='replacement', example='/new'),
}

model Error {
  code?: string(name='Code', example='FunctionNotFound'),
  message?: string(name='Message', example='function not found'),
  requestId?: string(name='RequestId', example='1-64e70cf1-5cbef92ea8fc8c42899cf5d1'),
}

model EventBridgeTriggerConfig {
  asyncInvocationType?: boolean(name='asyncInvocationType'),
  eventRuleFilterPattern?: string(name='eventRuleFilterPattern', example='{}'),
  eventSinkConfig?: EventSinkConfig(name='eventSinkConfig'),
  eventSourceConfig?: EventSourceConfig(name='eventSourceConfig'),
  runOptions?: RunOptions(name='runOptions'),
  triggerEnable?: boolean(name='triggerEnable', example='true'),
}

model EventSinkConfig {
  deliveryOption?: DeliveryOption(name='deliveryOption'),
}

model EventSourceConfig {
  eventSourceParameters?: EventSourceParameters(name='eventSourceParameters'),
  eventSourceType?: string(name='eventSourceType', example='MNS'),
}

model EventSourceParameters {
  sourceDTSParameters?: SourceDTSParameters(name='sourceDTSParameters'),
  sourceKafkaParameters?: SourceKafkaParameters(name='sourceKafkaParameters'),
  sourceMNSParameters?: SourceMNSParameters(name='sourceMNSParameters'),
  sourceMQTTParameters?: SourceMQTTParameters(name='sourceMQTTParameters'),
  sourceRabbitMQParameters?: SourceRabbitMQParameters(name='sourceRabbitMQParameters'),
  sourceRocketMQParameters?: SourceRocketMQParameters(name='sourceRocketMQParameters'),
}

model Filter {
  key?: Key(name='key'),
}

model Function {
  codeChecksum?: string(name='codeChecksum', example='2825179536350****'),
  codeSize?: long(name='codeSize', example='412'),
  cpu?: float(name='cpu', example='1'),
  createdTime?: string(name='createdTime', example='2023-04-01T08:15:27Z'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description', example='my function'),
  diskSize?: int32(name='diskSize', example='512'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:123:functions/functionName'),
  functionId?: string(name='functionId', example='aa715851-1c20-4b89-a8fb-***'),
  functionName?: string(name='functionName', example='my-function-1'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler', example='index.handler'),
  instanceConcurrency?: int32(name='instanceConcurrency', example='1'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess', example='true'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2023-05-01T08:15:27Z'),
  lastUpdateStatus?: string(name='lastUpdateStatus', example='InProgress'),
  lastUpdateStatusReason?: string(name='lastUpdateStatusReason', example='The system is currently processing the acceleration optimization for the image.'),
  lastUpdateStatusReasonCode?: string(name='lastUpdateStatusReasonCode', example='ImageOptimizing'),
  layers?: [
    FunctionLayer
  ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize', example='512'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role', example='acs:ram::188077086902****:role/fc-test'),
  runtime?: string(name='runtime', example='python3.10'),
  state?: string(name='state', example='Pending'),
  stateReason?: string(name='stateReason', example='Function creating'),
  stateReasonCode?: string(name='stateReasonCode', example='Creating'),
  timeout?: int32(name='timeout', example='60'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model FunctionLayer {
  arn?: string(name='arn', example='acs:fc:cn-beijing:186824xxxxxx:layers/fc_layer/versions/1'),
  size?: long(name='size', example='421'),
}

model GPUConfig {
  gpuMemorySize?: int32(name='gpuMemorySize', example='2048'),
  gpuType?: string(name='gpuType', example='fc.gpu.ampere.1'),
}

model GetResourceTagsOutput {
  resouceType?: string(name='resouceType', example='ALIYUN::FC::FUNCTION'),
  resourceArn?: string(name='resourceArn', example='acs:fc:cn-shanghai:****:functions/demo'),
  tags?: map[string]string(name='tags'),
}

model HTTPTrigger {
  urlInternet?: string(name='urlInternet', example='https://svc-func-xxxxxxxx.cn-hangzhou.fcapp.run'),
  urlIntranet?: string(name='urlIntranet', example='https://svc-func-xxxxxxxx.cn-hangzhou-vpc.fcapp.run'),
}

model HTTPTriggerConfig {
  authConfig?: string(name='authConfig', example='{"JWKS":{"foo":"bar"},"TokenLookup":"header:Authorization:Bearer,cookie:AuthorizationCookie","ClaimPassBy":"query:uid:uid,header:name:name"}'),
  authType?: string(name='authType', example='anonymous'),
  disableURLInternet?: boolean(name='disableURLInternet', example='true'),
  methods?: [ string ](name='methods'),
}

model InputCodeLocation {
  checksum?: string(name='checksum', example='2825179536350****'),
  ossBucketName?: string(name='ossBucketName', example='demo-bucket'),
  ossObjectName?: string(name='ossObjectName', example='demo-object'),
  zipFile?: string(name='zipFile', example='UEsDBAoAAAAAANF'),
}

model InstanceInfo {
  instanceId?: string(name='instanceId', example='1ef6b6ff-7f7b-485e-ab49-501ac681****'),
  versionId?: string(name='versionId', example='LATEST'),
}

model InstanceLifecycleConfig {
  initializer?: LifecycleHook(name='initializer'),
  preStop?: LifecycleHook(name='preStop'),
}

model JobConfig {
  maxRetryTime?: int32(name='maxRetryTime', example='3'),
  triggerInterval?: int32(name='triggerInterval', example='60'),
}

model Key {
  prefix?: string(name='prefix', example='serverless_'),
  suffix?: string(name='suffix', example='.zip'),
}

model Layer {
  acl?: string(name='acl', example='0'),
  code?: OutputCodeLocation(name='code'),
  codeChecksum?: string(name='codeChecksum', example='2825179536350****'),
  codeSize?: long(name='codeSize', example='421'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  createTime?: string(name='createTime', example='2023-03-30T11:08:00Z'),
  description?: string(name='description', example='My first layer'),
  layerName?: string(name='layerName', example='MyLayer'),
  layerVersionArn?: string(name='layerVersionArn', example='acs:fc:cn-beijing:186824xxxxxx:layers/fc_layer/versions/1'),
  license?: string(name='license', example='Apache'),
  version?: int32(name='version', example='1'),
}

model LifecycleHook {
  handler?: string(name='handler', example='index.initializer'),
  timeout?: int32(name='timeout', example='10'),
}

model ListAliasesOutput {
  aliases?: [
    Alias
  ](name='aliases'),
  nextToken?: string(name='nextToken', example='test'),
}

model ListAsyncInvokeConfigOutput {
  configs?: [
    AsyncConfig
  ](name='configs'),
  nextToken?: string(name='nextToken', example='8bj81uI8n****'),
}

model ListAsyncTaskOutput {
  nextToken?: string(name='nextToken'),
  tasks?: [
    AsyncTask
  ](name='tasks'),
}

model ListConcurrencyConfigsOutput {
  configs?: [
    ConcurrencyConfig
  ](name='configs'),
  nextToken?: string(name='nextToken', example='next_token'),
}

model ListCustomDomainOutput {
  customDomains?: [
    CustomDomain
  ](name='customDomains'),
  nextToken?: string(name='nextToken', example='next_domain_name'),
}

model ListFunctionsOutput {
  functions?: [
    Function
  ](name='functions'),
  nextToken?: string(name='nextToken', example='next_function_name'),
}

model ListInstancesOutput {
  instances?: [
    InstanceInfo
  ](name='instances'),
}

model ListLayerVersionOutput {
  layers?: [
    Layer
  ](name='layers'),
  nextVersion?: int32(name='nextVersion', example='10'),
}

model ListLayersOutput {
  layers?: [
    Layer
  ](name='layers'),
  nextToken?: string(name='nextToken', example='next-layer-name'),
}

model ListProvisionConfigsOutput {
  nextToken?: string(name='nextToken', example='next_token'),
  provisionConfigs?: [
    ProvisionConfig
  ](name='provisionConfigs'),
}

model ListTagResourcesOutput {
  nextToken?: string(name='NextToken', example='next_token'),
  requestId?: string(name='RequestId'),
  tagResources?: [
    TagResource
  ](name='TagResources'),
}

model ListTaggedResourcesOutput {
  nextToken?: string(name='nextToken', example='next_token'),
  resources?: [
    Resource
  ](name='resources'),
}

model ListTriggersOutput {
  nextToken?: string(name='nextToken', example='next_token'),
  triggers?: [
    Trigger
  ](name='triggers'),
}

model ListVersionsOutput {
  direction?: string(name='direction', example='FORWARD'),
  nextToken?: string(name='nextToken', example='3'),
  versions?: [
    Version
  ](name='versions'),
}

model ListVpcBindingsOutput {
  vpcIds?: [ string ](name='vpcIds'),
}

model LogConfig {
  enableInstanceMetrics?: boolean(name='enableInstanceMetrics', example='true'),
  enableRequestMetrics?: boolean(name='enableRequestMetrics', example='true'),
  logBeginRule?: string(name='logBeginRule', example='DefaultRegex'),
  logstore?: string(name='logstore', example='test-logstore'),
  project?: string(name='project', example='test-project'),
}

model MNSTopicTriggerConfig {
  filterTag?: string(name='filterTag', example='serverless'),
  notifyContentFormat?: string(name='notifyContentFormat', example='JSON'),
  notifyStrategy?: string(name='notifyStrategy', example='BACKOFF_RETRY'),
}

model NASConfig {
  groupId?: int32(name='groupId', example='100'),
  mountPoints?: [
    NASMountConfig
  ](name='mountPoints'),
  userId?: int32(name='userId', example='100'),
}

model NASMountConfig {
  enableTLS?: boolean(name='enableTLS'),
  mountDir?: string(name='mountDir', example='/home/test'),
  serverAddr?: string(name='serverAddr', example='***-uni85.cn-hangzhou.nas.com:/'),
}

model OSSMountConfig {
  mountPoints?: [
    OSSMountPoint
  ](name='mountPoints'),
}

model OSSMountPoint {
  bucketName?: string(name='bucketName', example='my-bucket'),
  bucketPath?: string(name='bucketPath', example='/my-dir'),
  endpoint?: string(name='endpoint', example='http://oss-cn-shanghai.aliyuncs.com'),
  mountDir?: string(name='mountDir', example='/mnt/dir'),
  readOnly?: boolean(name='readOnly', example='true'),
}

model OSSTriggerConfig {
  events?: [ string ](name='events'),
  filter?: Filter(name='filter'),
}

model OutputCodeLocation {
  location?: string(name='location', example='https://xyz.oss-cn-shanghai.aliyuncs.com/xxx/xxx/xxx'),
  repositoryType?: string(name='repositoryType', example='OSS'),
}

model OutputFuncCode {
  checksum?: string(name='checksum', example='1234567890'),
  url?: string(name='url', example='http://func-code.oss-cn-shanghai.aliyuncs.com/1a2b3c4d5e6f'),
}

model PathConfig {
  functionName?: string(name='functionName', example='myFunction'),
  methods?: [ string ](name='methods'),
  path?: string(name='path', example='/api/*'),
  qualifier?: string(name='qualifier', example='myAlias'),
  rewriteConfig?: RewriteConfig(name='rewriteConfig'),
}

model ProvisionConfig {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', example='true'),
  current?: long(name='current', example='1'),
  currentError?: string(name='currentError', example='image not found'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:124:functions/myFunction'),
  scheduledActions?: [
    ScheduledAction
  ](name='scheduledActions'),
  target?: long(name='target', example='5'),
  targetTrackingPolicies?: [
    TargetTrackingPolicy
  ](name='targetTrackingPolicies'),
}

model PublishVersionInput {
  description?: string(name='description', example='my version'),
}

model PutAsyncInvokeConfigInput {
  asyncTask?: boolean(name='asyncTask', example='true'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', example='300'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', example='3'),
}

model PutConcurrencyInput {
  reservedConcurrency?: long(name='reservedConcurrency', example='10'),
}

model PutProvisionConfigInput {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', example='true'),
  scheduledActions?: [
    ScheduledAction
  ](name='scheduledActions'),
  target?: long(name='target', example='1'),
  targetTrackingPolicies?: [
    TargetTrackingPolicy
  ](name='targetTrackingPolicies'),
}

model RegexRule {
  match?: string(name='match', example='^/api/.+?/(.*)'),
  replacement?: string(name='replacement', example='/api/v2/$1'),
}

model Resource {
  resouceType?: string(name='resouceType', example='ALIYUN::FC::FUNCTION'),
  resourceArn?: string(name='resourceArn', example='acs:fc:cn-shanghai:****:functions/demo'),
  tags?: map[string]string(name='tags'),
}

model RetryStrategy {
  pushRetryStrategy?: string(name='PushRetryStrategy', example='BACKOFF_RETRY'),
}

model RewriteConfig {
  equalRules?: [
    EqualRule
  ](name='equalRules'),
  regexRules?: [
    RegexRule
  ](name='regexRules'),
  wildcardRules?: [
    WildcardRule
  ](name='wildcardRules'),
}

model RouteConfig {
  routes?: [
    PathConfig
  ](name='routes'),
}

model RunOptions {
  batchWindow?: BatchWindow(name='batchWindow'),
  deadLetterQueue?: DeadLetterQueue(name='deadLetterQueue'),
  errorsTolerance?: string(name='errorsTolerance', example='ALL'),
  mode?: string(name='mode', example='event-streaming'),
  retryStrategy?: RetryStrategy(name='retryStrategy'),
}

model SLSTriggerConfig {
  enable?: boolean(name='enable', example='true'),
  functionParameter?: map[string]string(name='functionParameter'),
  jobConfig?: JobConfig(name='jobConfig'),
  logConfig?: SLSTriggerLogConfig(name='logConfig'),
  sourceConfig?: SourceConfig(name='sourceConfig'),
}

model SLSTriggerLogConfig {
  logstore?: string(name='logstore', example='my-sls-logstore-name'),
  project?: string(name='project', example='my-sls-project-name'),
}

model ScheduledAction {
  endTime?: string(name='endTime', example='2024-03-10T10:10:10Z'),
  name?: string(name='name', example='test_1'),
  scheduleExpression?: string(name='scheduleExpression', example='cron(0 0 22 * * *)'),
  startTime?: string(name='startTime', example='2023-03-10T10:10:10Z'),
  target?: long(name='target', example='50'),
}

model SourceConfig {
  logstore?: string(name='logstore', example='my-sls-logstore-name'),
  startTime?: long(name='startTime', example='1704790317'),
}

model SourceDTSParameters {
  brokerUrl?: string(name='BrokerUrl', example='dts-cn-shanghai-vpc.com:18003'),
  initCheckPoint?: int32(name='InitCheckPoint', example='1677340805'),
  password?: string(name='Password', example='dtsTest123'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  sid?: string(name='Sid', example='dtse34j22j025a****'),
  taskId?: string(name='TaskId', example='e34z2gm325q****'),
  topic?: string(name='Topic', example='cn_shanghai_vpc_rm_uf6398ykj0218****_dts_trigger_upgrade_from_old_version2'),
  username?: string(name='Username', example='dts_trigger'),
}

model SourceKafkaParameters {
  consumerGroup?: string(name='ConsumerGroup', example='DEFAULT_GROUP'),
  instanceId?: string(name='InstanceId', example='r-8vb64581862c****'),
  network?: string(name='Network', example='Default'),
  offsetReset?: string(name='OffsetReset', example='latest'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  securityGroupId?: string(name='SecurityGroupId', example='sg-bp1iv19sp1msc7zot4****'),
  topic?: string(name='Topic', example='popvip_center_robot_order'),
  vSwitchIds?: string(name='VSwitchIds', example='vsw-bp179l3llg3jjxwrq72****'),
  vpcId?: string(name='VpcId', example='vpc-8vblalsi0vbhizr77****'),
}

model SourceMNSParameters {
  isBase64Decode?: boolean(name='IsBase64Decode', example='true'),
  queueName?: string(name='QueueName', example='demo'),
  regionId?: string(name='RegionId', example='cn-shanghai'),
}

model SourceMQTTParameters {
  instanceId?: string(name='InstanceId', example='mqtt-****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  topic?: string(name='Topic', example='testTopic'),
}

model SourceRabbitMQParameters {
  instanceId?: string(name='InstanceId', example='amqp-cn-nif22u74****'),
  queueName?: string(name='QueueName', example='demo'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  virtualHostName?: string(name='VirtualHostName', example='eb-connect'),
}

model SourceRocketMQParameters {
  authType?: string(name='AuthType', example='ACL'),
  filterType?: string(name='FilterType', example='Tag'),
  groupID?: string(name='GroupID', example='GID_group1'),
  instanceEndpoint?: string(name='InstanceEndpoint', example='registry-vpc.cn-hangzhou.aliyuncs.com'),
  instanceId?: string(name='InstanceId', example='MQ_INST_164901546557****_BAAN****'),
  instanceNetwork?: string(name='InstanceNetwork', example='PrivateNetwork'),
  instancePassword?: string(name='InstancePassword', example='123'),
  instanceSecurityGroupId?: string(name='InstanceSecurityGroupId', example='sg-hp35r2hc3a3sv8q2****'),
  instanceType?: string(name='InstanceType', example='Cloud_5'),
  instanceUsername?: string(name='InstanceUsername', example='6W0xz2uPfiwp****'),
  instanceVSwitchIds?: string(name='InstanceVSwitchIds', example='vsw-uf6gwtbn6etadpvz7****'),
  instanceVpcId?: string(name='InstanceVpcId', example='vpc-uf6of9452b2pba82c****'),
  offset?: string(name='Offset', example='CONSUME_FROM_TIMESTAMP'),
  regionId?: string(name='RegionId', example='cn-shanghai'),
  tag?: string(name='Tag', example='test'),
  timestamp?: int32(name='Timestamp', example='1636597951964'),
  topic?: string(name='Topic', example='myTopic'),
}

model TLSConfig {
  cipherSuites?: [ string ](name='cipherSuites'),
  maxVersion?: string(name='maxVersion', example='TLSv1.3'),
  minVersion?: string(name='minVersion', example='TLSv1.0'),
}

model Tag {
  key?: string(name='Key', example='k1'),
  value?: string(name='Value', example='v1'),
}

model TagResource {
  resourceId?: string(name='ResourceId', example='acs:fc:cn-shanghai:****:functions/demo'),
  resourceType?: string(name='ResourceType', example='ALIYUN::FC::FUNCTION'),
  tagKey?: string(name='TagKey', example='key1'),
  tagValue?: string(name='TagValue', example='key1'),
}

model TagResourceInput {
  resourceArn?: string(name='resourceArn', example='acs:fc:cn-shanghai:xxx:functions/f1'),
  tags?: map[string]string(name='tags'),
}

model TagResourcesInput {
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType', example='FUNCTION'),
  tag?: [
    Tag
  ](name='Tag'),
}

model TargetTrackingPolicy {
  endTime?: string(name='endTime', example='2024-03-10T10:10:10Z'),
  maxCapacity?: long(name='maxCapacity', example='10'),
  metricTarget?: float(name='metricTarget', example='0.6'),
  metricType?: string(name='metricType', example='CPUUtilization'),
  minCapacity?: long(name='minCapacity', example='1'),
  name?: string(name='name', example='test_1'),
  startTime?: string(name='startTime', example='2023-03-10T10:10:10Z'),
}

model TimerTriggerConfig {
  cronExpression?: string(name='cronExpression', example='0 0 4 * * *'),
  enable?: boolean(name='enable', example='true'),
  payload?: string(name='payload', example='{"workflowInstanceId":"39639"}'),
}

model TracingConfig {
  params?: map[string]string(name='params'),
  type?: string(name='type', example='Jaeger'),
}

model Trigger {
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  httpTrigger?: HTTPTrigger(name='httpTrigger'),
  invocationRole?: string(name='invocationRole'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  qualifier?: string(name='qualifier'),
  sourceArn?: string(name='sourceArn'),
  status?: string(name='status'),
  targetArn?: string(name='targetArn'),
  triggerConfig?: string(name='triggerConfig'),
  triggerId?: string(name='triggerId'),
  triggerName?: string(name='triggerName'),
  triggerType?: string(name='triggerType'),
}

model UpdateAliasInput {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  description?: string(name='description', example='my alias'),
  versionId?: string(name='versionId', example='1'),
}

model UpdateCustomDomainInput {
  authConfig?: AuthConfig(name='authConfig'),
  certConfig?: CertConfig(name='certConfig'),
  protocol?: string(name='protocol', example='HTTP'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model UpdateFunctionInput {
  code?: InputCodeLocation(name='code'),
  cpu?: float(name='cpu', example='1'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description', example='my function'),
  diskSize?: int32(name='diskSize', example='512'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler', example='index.handler'),
  instanceConcurrency?: int32(name='instanceConcurrency', example='1'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess', example='true'),
  layers?: [ string ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize', example='512'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role', example='acs:ram::188077086902****:role/fc-test'),
  runtime?: string(name='runtime'),
  timeout?: int32(name='timeout', example='60'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model UpdateTriggerInput {
  description?: string(name='description', example='trigger for test'),
  invocationRole?: string(name='invocationRole', example='acs:ram::1234567890:role/fc-test'),
  qualifier?: string(name='qualifier', example='LATEST'),
  triggerConfig?: string(name='triggerConfig', example='{"events":["oss:ObjectCreated:*"],"filter":{"key":{"prefix":"/prefix","suffix":".zip"}}}'),
}

model VPCConfig {
  securityGroupId?: string(name='securityGroupId', example='sg-bp18hj1wtxgy3b0***'),
  vSwitchIds?: [ string ](name='vSwitchIds'),
  vpcId?: string(name='vpcId', example='vpc-***'),
}

model Version {
  createdTime?: string(name='createdTime', example='2006-01-02T15:04:05Z07:00'),
  description?: string(name='description', example='my version'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2006-01-02T15:04:05Z07:00'),
  versionId?: string(name='versionId', example='1'),
}

model WAFConfig {
  enableWAF?: boolean(name='enableWAF', example='true'),
}

model WildcardRule {
  match?: string(name='match', example='/api/*'),
  replacement?: string(name='replacement', example='/$1'),
}

model CreateAliasRequest {
  body?: CreateAliasInput(name='body', description='The request parameters for creating an alias.'),
}

model CreateAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Alias  
}

async function createAliasWithOptions(functionName: string, request: CreateAliasRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAliasResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlias',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAlias(functionName: string, request: CreateAliasRequest): CreateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAliasWithOptions(functionName, request, headers, runtime);
}

model CreateCustomDomainRequest {
  body?: CreateCustomDomainInput(name='body', description='The information about the custom domain name.'),
}

model CreateCustomDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CustomDomain  
}

async function createCustomDomainWithOptions(request: CreateCustomDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateCustomDomainResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCustomDomain',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCustomDomain(request: CreateCustomDomainRequest): CreateCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createCustomDomainWithOptions(request, headers, runtime);
}

model CreateFunctionRequest {
  body?: CreateFunctionInput(name='body', description='The information about function configurations.'),
}

model CreateFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Function  
}

async function createFunctionWithOptions(request: CreateFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFunctionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFunctionWithOptions(request, headers, runtime);
}

model CreateLayerVersionRequest {
  body?: CreateLayerVersionInput(name='body', description='The information about layer configurations.'),
}

model CreateLayerVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Layer  
}

async function createLayerVersionWithOptions(layerName: string, request: CreateLayerVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLayerVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLayerVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLayerVersion(layerName: string, request: CreateLayerVersionRequest): CreateLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLayerVersionWithOptions(layerName, request, headers, runtime);
}

model CreateTriggerRequest {
  body?: CreateTriggerInput(name='body', description='The trigger configurations.'),
}

model CreateTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Trigger  
}

async function createTriggerWithOptions(functionName: string, request: CreateTriggerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTriggerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTrigger',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTrigger(functionName: string, request: CreateTriggerRequest): CreateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTriggerWithOptions(functionName, request, headers, runtime);
}

model CreateVpcBindingRequest {
  body?: CreateVpcBindingInput(name='body', description='The configurations of the virtual private cloud (VPC) binding.'),
}

model CreateVpcBindingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function createVpcBindingWithOptions(functionName: string, request: CreateVpcBindingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateVpcBindingResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpcBinding',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/vpc-bindings`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function createVpcBinding(functionName: string, request: CreateVpcBindingRequest): CreateVpcBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createVpcBindingWithOptions(functionName, request, headers, runtime);
}

model DeleteAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteAliasWithOptions(functionName: string, aliasName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAliasResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlias',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases/${OpenApiUtil.getEncodeParam(aliasName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteAlias(functionName: string, aliasName: string): DeleteAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAliasWithOptions(functionName, aliasName, headers, runtime);
}

model DeleteAsyncInvokeConfigRequest {
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST'),
}

model DeleteAsyncInvokeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteAsyncInvokeConfigWithOptions(functionName: string, request: DeleteAsyncInvokeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAsyncInvokeConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-invoke-config`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteAsyncInvokeConfig(functionName: string, request: DeleteAsyncInvokeConfigRequest): DeleteAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAsyncInvokeConfigWithOptions(functionName, request, headers, runtime);
}

model DeleteConcurrencyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteConcurrencyConfigWithOptions(functionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConcurrencyConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteConcurrencyConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/concurrency`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteConcurrencyConfig(functionName: string): DeleteConcurrencyConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConcurrencyConfigWithOptions(functionName, headers, runtime);
}

model DeleteCustomDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteCustomDomainWithOptions(domainName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteCustomDomainResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomDomain',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains/${OpenApiUtil.getEncodeParam(domainName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteCustomDomain(domainName: string): DeleteCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteCustomDomainWithOptions(domainName, headers, runtime);
}

model DeleteFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteFunctionWithOptions(functionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFunctionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteFunction(functionName: string): DeleteFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionWithOptions(functionName, headers, runtime);
}

model DeleteFunctionVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteFunctionVersionWithOptions(functionName: string, versionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFunctionVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunctionVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/versions/${OpenApiUtil.getEncodeParam(versionId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteFunctionVersion(functionName: string, versionId: string): DeleteFunctionVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionVersionWithOptions(functionName, versionId, headers, runtime);
}

model DeleteLayerVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteLayerVersionWithOptions(layerName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLayerVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLayerVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions/${OpenApiUtil.getEncodeParam(version)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteLayerVersion(layerName: string, version: string): DeleteLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLayerVersionWithOptions(layerName, version, headers, runtime);
}

model DeleteProvisionConfigRequest {
  qualifier?: string(name='qualifier', description='The function alias or LATEST.', example='LATEST'),
}

model DeleteProvisionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteProvisionConfigWithOptions(functionName: string, request: DeleteProvisionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProvisionConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProvisionConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/provision-config`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteProvisionConfig(functionName: string, request: DeleteProvisionConfigRequest): DeleteProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProvisionConfigWithOptions(functionName, request, headers, runtime);
}

model DeleteTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteTriggerWithOptions(functionName: string, triggerName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTriggerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteTrigger',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers/${OpenApiUtil.getEncodeParam(triggerName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteTrigger(functionName: string, triggerName: string): DeleteTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTriggerWithOptions(functionName, triggerName, headers, runtime);
}

model DeleteVpcBindingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteVpcBindingWithOptions(functionName: string, vpcId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteVpcBindingResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpcBinding',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/vpc-bindings/${OpenApiUtil.getEncodeParam(vpcId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteVpcBinding(functionName: string, vpcId: string): DeleteVpcBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteVpcBindingWithOptions(functionName, vpcId, headers, runtime);
}

model GetAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Alias  
}

async function getAliasWithOptions(functionName: string, aliasName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAliasResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAlias',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases/${OpenApiUtil.getEncodeParam(aliasName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAlias(functionName: string, aliasName: string): GetAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAliasWithOptions(functionName, aliasName, headers, runtime);
}

model GetAsyncInvokeConfigRequest {
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST'),
}

model GetAsyncInvokeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AsyncConfig  
}

async function getAsyncInvokeConfigWithOptions(functionName: string, request: GetAsyncInvokeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAsyncInvokeConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-invoke-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAsyncInvokeConfig(functionName: string, request: GetAsyncInvokeConfigRequest): GetAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAsyncInvokeConfigWithOptions(functionName, request, headers, runtime);
}

model GetAsyncTaskRequest {
  qualifier?: string(name='qualifier', example='LATEST'),
}

model GetAsyncTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AsyncTask  
}

async function getAsyncTaskWithOptions(functionName: string, taskId: string, request: GetAsyncTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAsyncTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAsyncTask',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-tasks/${OpenApiUtil.getEncodeParam(taskId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAsyncTask(functionName: string, taskId: string, request: GetAsyncTaskRequest): GetAsyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAsyncTaskWithOptions(functionName, taskId, request, headers, runtime);
}

model GetConcurrencyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConcurrencyConfig  
}

async function getConcurrencyConfigWithOptions(functionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetConcurrencyConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetConcurrencyConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/concurrency`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConcurrencyConfig(functionName: string): GetConcurrencyConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getConcurrencyConfigWithOptions(functionName, headers, runtime);
}

model GetCustomDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CustomDomain  
}

async function getCustomDomainWithOptions(domainName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetCustomDomainResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetCustomDomain',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains/${OpenApiUtil.getEncodeParam(domainName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCustomDomain(domainName: string): GetCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCustomDomainWithOptions(domainName, headers, runtime);
}

model GetFunctionRequest {
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST'),
}

model GetFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Function  
}

async function getFunctionWithOptions(functionName: string, request: GetFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFunction(functionName: string, request: GetFunctionRequest): GetFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionWithOptions(functionName, request, headers, runtime);
}

model GetFunctionCodeRequest {
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST'),
}

model GetFunctionCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OutputFuncCode  
}

async function getFunctionCodeWithOptions(functionName: string, request: GetFunctionCodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionCodeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunctionCode',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/code`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFunctionCode(functionName: string, request: GetFunctionCodeRequest): GetFunctionCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionCodeWithOptions(functionName, request, headers, runtime);
}

model GetLayerVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Layer  
}

async function getLayerVersionWithOptions(layerName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLayerVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLayerVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions/${OpenApiUtil.getEncodeParam(version)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLayerVersion(layerName: string, version: string): GetLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLayerVersionWithOptions(layerName, version, headers, runtime);
}

model GetLayerVersionByArnResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Layer  
}

async function getLayerVersionByArnWithOptions(arn: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLayerVersionByArnResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLayerVersionByArn',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layerarn/${OpenApiUtil.getEncodeParam(arn)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLayerVersionByArn(arn: string): GetLayerVersionByArnResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLayerVersionByArnWithOptions(arn, headers, runtime);
}

model GetProvisionConfigRequest {
  qualifier?: string(name='qualifier', description='The function alias or LATEST.', example='LATEST'),
}

model GetProvisionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ProvisionConfig  
}

async function getProvisionConfigWithOptions(functionName: string, request: GetProvisionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProvisionConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProvisionConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/provision-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProvisionConfig(functionName: string, request: GetProvisionConfigRequest): GetProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProvisionConfigWithOptions(functionName, request, headers, runtime);
}

model GetTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Trigger  
}

async function getTriggerWithOptions(functionName: string, triggerName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTriggerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTrigger',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers/${OpenApiUtil.getEncodeParam(triggerName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTrigger(functionName: string, triggerName: string): GetTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTriggerWithOptions(functionName, triggerName, headers, runtime);
}

model InvokeFunctionHeaders {
  commonHeaders?: map[string]string,
  xFcAsyncTaskId?: string(name='x-fc-async-task-id'),
  xFcInvocationType?: string(name='x-fc-invocation-type', description='The type of function invocation. Valid values: Sync and Async.', example='Sync'),
  xFcLogType?: string(name='x-fc-log-type', description='The log type of function invocation. Valid values: None and Tail.', example='Tail'),
}

model InvokeFunctionRequest {
  body?: readable(name='body', description='The request parameters of function invocation.', example='event'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST'),
}

model InvokeFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: readable(name='body'),
}

async function invokeFunctionWithOptions(functionName: string, request: InvokeFunctionRequest, headers: InvokeFunctionHeaders, runtime: Util.RuntimeOptions): InvokeFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAsyncTaskId)) {
    realHeaders['x-fc-async-task-id'] = Util.toJSONString(headers.xFcAsyncTaskId);
  }
  if (!Util.isUnset(headers.xFcInvocationType)) {
    realHeaders['x-fc-invocation-type'] = Util.toJSONString(headers.xFcInvocationType);
  }
  if (!Util.isUnset(headers.xFcLogType)) {
    realHeaders['x-fc-log-type'] = Util.toJSONString(headers.xFcLogType);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = request.body,
    stream = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InvokeFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/invocations`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'binary',
  };
  var res = new InvokeFunctionResponse{};
  var tmp = Util.assertAsMap(callApi(params, req, runtime));
  if (!Util.isUnset(tmp.body)) {
    var respBody = Util.assertAsReadable(tmp.body);
    res.body = respBody;
  }
  if (!Util.isUnset(tmp.headers)) {
    var respHeaders = Util.assertAsMap(tmp.headers);
    res.headers = Util.stringifyMapValue(respHeaders);
  }
  if (!Util.isUnset(tmp.statusCode)) {
    var statusCode = Util.assertAsInteger(tmp.statusCode);
    res.statusCode = statusCode;
  }
  return res;
}

async function invokeFunction(functionName: string, request: InvokeFunctionRequest): InvokeFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new InvokeFunctionHeaders{};
  return invokeFunctionWithOptions(functionName, request, headers, runtime);
}

model ListAliasesRequest {
  limit?: int32(name='limit', description='The number of aliases returned.', example='10'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM='),
  prefix?: string(name='prefix', description='The alias prefix.', example='my-alias'),
}

model ListAliasesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAliasesOutput  
}

async function listAliasesWithOptions(functionName: string, request: ListAliasesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAliasesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAliases',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAliases(functionName: string, request: ListAliasesRequest): ListAliasesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAliasesWithOptions(functionName, request, headers, runtime);
}

model ListAsyncInvokeConfigsRequest {
  functionName?: string(name='functionName', description='The function name. If you do not configure this parameter, the asynchronous invocation configurations of all functions are displayed.', example='my-func'),
  limit?: int32(name='limit', description='The maximum number of entries to be returned.', example='10'),
  nextToken?: string(name='nextToken', description='The paging information. This parameter specifies the start point of the query.', example='MTIzNCNhYmM='),
}

model ListAsyncInvokeConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAsyncInvokeConfigOutput  
}

async function listAsyncInvokeConfigsWithOptions(request: ListAsyncInvokeConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAsyncInvokeConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.functionName)) {
    query['functionName'] = request.functionName;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAsyncInvokeConfigs',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/async-invoke-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAsyncInvokeConfigs(request: ListAsyncInvokeConfigsRequest): ListAsyncInvokeConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAsyncInvokeConfigsWithOptions(request, headers, runtime);
}

model ListAsyncTasksRequest {
  includePayload?: boolean(name='includePayload', example='true'),
  limit?: int32(name='limit', example='10'),
  nextToken?: string(name='nextToken', example='MTIzNCNhYmM='),
  prefix?: string(name='prefix', example='job-'),
  qualifier?: string(name='qualifier', example='LATEST'),
  sortOrderByTime?: string(name='sortOrderByTime', example='asc'),
  startedTimeBegin?: long(name='startedTimeBegin', example='1640966400000'),
  startedTimeEnd?: long(name='startedTimeEnd', example='1640966400000'),
  status?: string(name='status', example='Running'),
}

model ListAsyncTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAsyncTaskOutput  
}

async function listAsyncTasksWithOptions(functionName: string, request: ListAsyncTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAsyncTasksResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.includePayload)) {
    query['includePayload'] = request.includePayload;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }
  if (!Util.isUnset(request.sortOrderByTime)) {
    query['sortOrderByTime'] = request.sortOrderByTime;
  }
  if (!Util.isUnset(request.startedTimeBegin)) {
    query['startedTimeBegin'] = request.startedTimeBegin;
  }
  if (!Util.isUnset(request.startedTimeEnd)) {
    query['startedTimeEnd'] = request.startedTimeEnd;
  }
  if (!Util.isUnset(request.status)) {
    query['status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAsyncTasks',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAsyncTasks(functionName: string, request: ListAsyncTasksRequest): ListAsyncTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAsyncTasksWithOptions(functionName, request, headers, runtime);
}

model ListConcurrencyConfigsRequest {
  functionName?: string(name='functionName', description='The function name. If you leave this parameter empty, the concurrency configurations of all functions are returned.', example='my-func'),
  limit?: int32(name='limit', description='The maximum number of entries returned.', example='10'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM='),
}

model ListConcurrencyConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListConcurrencyConfigsOutput  
}

async function listConcurrencyConfigsWithOptions(request: ListConcurrencyConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListConcurrencyConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.functionName)) {
    query['functionName'] = request.functionName;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConcurrencyConfigs',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/concurrency-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listConcurrencyConfigs(request: ListConcurrencyConfigsRequest): ListConcurrencyConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConcurrencyConfigsWithOptions(request, headers, runtime);
}

model ListCustomDomainsRequest {
  limit?: int32(name='limit', description='The number of custom domain names returned.', example='10'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM='),
  prefix?: string(name='prefix', description='The domain name prefix.', example='foo'),
}

model ListCustomDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCustomDomainOutput  
}

async function listCustomDomainsWithOptions(request: ListCustomDomainsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCustomDomainsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCustomDomains',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCustomDomains(request: ListCustomDomainsRequest): ListCustomDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCustomDomainsWithOptions(request, headers, runtime);
}

model ListFunctionVersionsRequest {
  direction?: string(name='direction', description='The sorting mode of function versions. Valid values: BACKWARD and FORWARD.', example='BACKWARD'),
  limit?: int32(name='limit', description='The number of function versions that are returned.', example='10'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM='),
}

model ListFunctionVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVersionsOutput  
}

async function listFunctionVersionsWithOptions(functionName: string, request: ListFunctionVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.direction)) {
    query['direction'] = request.direction;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctionVersions',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFunctionVersions(functionName: string, request: ListFunctionVersionsRequest): ListFunctionVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionVersionsWithOptions(functionName, request, headers, runtime);
}

model ListFunctionsRequest {
  limit?: int32(name='limit', description='The number of functions to return. The minimum value is 1 and the maximum value is 100.', example='10'),
  nextToken?: string(name='nextToken', description='The pagination token.', example='MTIzNCNhYmM='),
  prefix?: string(name='prefix', description='The prefix of the function name.', example='my-func'),
}

model ListFunctionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionsOutput  
}

async function listFunctionsWithOptions(request: ListFunctionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctions',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFunctions(request: ListFunctionsRequest): ListFunctionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionsWithOptions(request, headers, runtime);
}

model ListInstancesRequest {
  qualifier?: string(name='qualifier', description='The function version or alias.', example='LATEST'),
  withAllActive?: boolean(name='withAllActive', description='Specifies whether to list all instances. Valid values: true and false.', example='true'),
}

model ListInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstancesOutput  
}

async function listInstancesWithOptions(functionName: string, request: ListInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }
  if (!Util.isUnset(request.withAllActive)) {
    query['withAllActive'] = request.withAllActive;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstances(functionName: string, request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstancesWithOptions(functionName, request, headers, runtime);
}

model ListLayerVersionsRequest {
  limit?: int32(name='limit', description='The number of versions to be returned.', example='10'),
  startVersion?: string(name='startVersion', description='The initial version of the layer.', example='1'),
}

model ListLayerVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLayerVersionOutput  
}

async function listLayerVersionsWithOptions(layerName: string, request: ListLayerVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLayerVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.startVersion)) {
    query['startVersion'] = request.startVersion;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLayerVersions',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLayerVersions(layerName: string, request: ListLayerVersionsRequest): ListLayerVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLayerVersionsWithOptions(layerName, request, headers, runtime);
}

model ListLayersRequest {
  limit?: int32(name='limit', description='The number of layers that are returned', example='10'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM='),
  official?: string(name='official', description='Specifies whether the layer is official. Valid values: true and false.', example='true'),
  prefix?: string(name='prefix', description='The name prefix of the layer.', example='my-layer'),
  public?: string(name='public', description='Specifies whether the layer is public. Valid values: true and false.', example='true'),
}

model ListLayersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLayersOutput  
}

async function listLayersWithOptions(request: ListLayersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLayersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.official)) {
    query['official'] = request.official;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.public)) {
    query['public'] = request.public;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLayers',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLayers(request: ListLayersRequest): ListLayersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLayersWithOptions(request, headers, runtime);
}

model ListProvisionConfigsRequest {
  functionName?: string(name='functionName', description='The name of the function. If this parameter is not specified, the provisioned configurations of all functions are listed.', example='my-func'),
  limit?: int32(name='limit', description='Number of provisioned configurations to return.', example='10'),
  nextToken?: string(name='nextToken', description='A pagination token.', example='MTIzNCNhYmM='),
}

model ListProvisionConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProvisionConfigsOutput  
}

async function listProvisionConfigsWithOptions(request: ListProvisionConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProvisionConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.functionName)) {
    query['functionName'] = request.functionName;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProvisionConfigs',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/provision-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProvisionConfigs(request: ListProvisionConfigsRequest): ListProvisionConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProvisionConfigsWithOptions(request, headers, runtime);
}

model ListTagResourcesRequest {
  limit?: int32(name='Limit', description='The number of resources to return.', example='10'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM='),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs.'),
  resourceType?: string(name='ResourceType', description='The resource type.', example='ALIYUN::FC:FUNCTION'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.

The tag key can be up to 64 characters in length, and cannot contain `http://` or `https://`. The tag key cannot start with `aliyun` or `acs:`.', example='k1'),
      value?: string(name='Value', description='The tag value.

The tag value can be up to 128 characters in length and can be an empty string.', example='v1'),
    }
  ](name='Tag', description='The tags.

You can query up to 20 tags at a time.'),
}

model ListTagResourcesShrinkRequest {
  limit?: int32(name='Limit', description='The number of resources to return.', example='10'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM='),
  resourceIdShrink?: string(name='ResourceId', description='The resource IDs.'),
  resourceType?: string(name='ResourceType', description='The resource type.', example='ALIYUN::FC:FUNCTION'),
  tagShrink?: string(name='Tag', description='The tags.

You can query up to 20 tags at a time.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesOutput  
}

async function listTagResourcesWithOptions(tmpReq: ListTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceId)) {
    request.resourceIdShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceId, 'ResourceId', 'json');
  }
  if (!Util.isUnset(tmpReq.tag)) {
    request.tagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tag, 'Tag', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceIdShrink)) {
    query['ResourceId'] = request.resourceIdShrink;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagShrink)) {
    query['Tag'] = request.tagShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/tags-v2`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

model ListTriggersRequest {
  limit?: int32(name='limit', description='The number of triggers returned.', example='10'),
  nextToken?: string(name='nextToken', description='The token for the next page.', example='MTIzNCNhYmM='),
  prefix?: string(name='prefix', description='The trigger name prefix.', example='my-trigger'),
}

model ListTriggersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTriggersOutput  
}

async function listTriggersWithOptions(functionName: string, request: ListTriggersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTriggersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTriggers',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTriggers(functionName: string, request: ListTriggersRequest): ListTriggersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTriggersWithOptions(functionName, request, headers, runtime);
}

model ListVpcBindingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVpcBindingsOutput  
}

async function listVpcBindingsWithOptions(functionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListVpcBindingsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListVpcBindings',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/vpc-bindings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVpcBindings(functionName: string): ListVpcBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVpcBindingsWithOptions(functionName, headers, runtime);
}

model PublishFunctionVersionRequest {
  body?: PublishVersionInput(name='body', description='The information about the function version.'),
}

model PublishFunctionVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Version  
}

async function publishFunctionVersionWithOptions(functionName: string, request: PublishFunctionVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PublishFunctionVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PublishFunctionVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function publishFunctionVersion(functionName: string, request: PublishFunctionVersionRequest): PublishFunctionVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return publishFunctionVersionWithOptions(functionName, request, headers, runtime);
}

model PutAsyncInvokeConfigRequest {
  body?: PutAsyncInvokeConfigInput(name='body', description='The configurations of asynchronous function invocation.'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST'),
}

model PutAsyncInvokeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AsyncConfig  
}

async function putAsyncInvokeConfigWithOptions(functionName: string, request: PutAsyncInvokeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PutAsyncInvokeConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-invoke-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putAsyncInvokeConfig(functionName: string, request: PutAsyncInvokeConfigRequest): PutAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putAsyncInvokeConfigWithOptions(functionName, request, headers, runtime);
}

model PutConcurrencyConfigRequest {
  body?: PutConcurrencyInput(name='body', description='The concurrency configurations.'),
}

model PutConcurrencyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConcurrencyConfig  
}

async function putConcurrencyConfigWithOptions(functionName: string, request: PutConcurrencyConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutConcurrencyConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PutConcurrencyConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/concurrency`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putConcurrencyConfig(functionName: string, request: PutConcurrencyConfigRequest): PutConcurrencyConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putConcurrencyConfigWithOptions(functionName, request, headers, runtime);
}

model PutLayerACLRequest {
  public?: string(name='public', description='Specifies whether the layer is a public layer. Valid values: true and false.', example='true'),
}

model PutLayerACLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function putLayerACLWithOptions(layerName: string, request: PutLayerACLRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutLayerACLResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.public)) {
    query['public'] = request.public;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutLayerACL',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/acl`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function putLayerACL(layerName: string, request: PutLayerACLRequest): PutLayerACLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putLayerACLWithOptions(layerName, request, headers, runtime);
}

model PutProvisionConfigRequest {
  body?: PutProvisionConfigInput(name='body', description='The information about the provisioned configuration.'),
  qualifier?: string(name='qualifier', description='The function alias or LATEST.', example='LATEST'),
}

model PutProvisionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ProvisionConfig  
}

async function putProvisionConfigWithOptions(functionName: string, request: PutProvisionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutProvisionConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PutProvisionConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/provision-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putProvisionConfig(functionName: string, request: PutProvisionConfigRequest): PutProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putProvisionConfigWithOptions(functionName, request, headers, runtime);
}

model StopAsyncTaskRequest {
  qualifier?: string(name='qualifier', example='LATEST'),
}

model StopAsyncTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function stopAsyncTaskWithOptions(functionName: string, taskId: string, request: StopAsyncTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopAsyncTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopAsyncTask',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-tasks/${OpenApiUtil.getEncodeParam(taskId)}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function stopAsyncTask(functionName: string, taskId: string, request: StopAsyncTaskRequest): StopAsyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopAsyncTaskWithOptions(functionName, taskId, request, headers, runtime);
}

model TagResourcesRequest {
  body?: TagResourcesInput(name='body', description='The configuration of the resource tag.'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/tags-v2`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(request, headers, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to delete all tags.', example='true'),
  resourceId?: [ string ](name='ResourceId', description='The resource identifiers.'),
  resourceType?: string(name='ResourceType', description='The resource type.', example='function'),
  tagKey?: [ string ](name='TagKey', description='The tag to remove. You can specify a maximum of 50 tags.'),
}

model UntagResourcesShrinkRequest {
  all?: boolean(name='All', description='Specifies whether to delete all tags.', example='true'),
  resourceIdShrink?: string(name='ResourceId', description='The resource identifiers.'),
  resourceType?: string(name='ResourceType', description='The resource type.', example='function'),
  tagKeyShrink?: string(name='TagKey', description='The tag to remove. You can specify a maximum of 50 tags.'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function untagResourcesWithOptions(tmpReq: UntagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new UntagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceId)) {
    request.resourceIdShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceId, 'ResourceId', 'json');
  }
  if (!Util.isUnset(tmpReq.tagKey)) {
    request.tagKeyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tagKey, 'TagKey', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.resourceIdShrink)) {
    query['ResourceId'] = request.resourceIdShrink;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKeyShrink)) {
    query['TagKey'] = request.tagKeyShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/tags-v2`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourcesWithOptions(request, headers, runtime);
}

model UpdateAliasRequest {
  body?: UpdateAliasInput(name='body', description='The alias information to be updated.'),
}

model UpdateAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Alias  
}

async function updateAliasWithOptions(functionName: string, aliasName: string, request: UpdateAliasRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAliasResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlias',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases/${OpenApiUtil.getEncodeParam(aliasName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAlias(functionName: string, aliasName: string, request: UpdateAliasRequest): UpdateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAliasWithOptions(functionName, aliasName, request, headers, runtime);
}

model UpdateCustomDomainRequest {
  body?: UpdateCustomDomainInput(name='body', description='The information about the custom domain name.'),
}

model UpdateCustomDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CustomDomain  
}

async function updateCustomDomainWithOptions(domainName: string, request: UpdateCustomDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCustomDomainResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCustomDomain',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains/${OpenApiUtil.getEncodeParam(domainName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCustomDomain(domainName: string, request: UpdateCustomDomainRequest): UpdateCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCustomDomainWithOptions(domainName, request, headers, runtime);
}

model UpdateFunctionRequest {
  body?: UpdateFunctionInput(name='body', description='The function information'),
}

model UpdateFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Function  
}

async function updateFunctionWithOptions(functionName: string, request: UpdateFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFunctionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateFunction(functionName: string, request: UpdateFunctionRequest): UpdateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFunctionWithOptions(functionName, request, headers, runtime);
}

model UpdateTriggerRequest {
  body?: UpdateTriggerInput(name='body', description='The trigger configurations.'),
}

model UpdateTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Trigger  
}

async function updateTriggerWithOptions(functionName: string, triggerName: string, request: UpdateTriggerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTriggerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTrigger',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers/${OpenApiUtil.getEncodeParam(triggerName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTrigger(functionName: string, triggerName: string, request: UpdateTriggerRequest): UpdateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTriggerWithOptions(functionName, triggerName, request, headers, runtime);
}

