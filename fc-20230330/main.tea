/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('fc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AccelerationInfo {
  status?: string(name='status', example='deprecated'),
}

model Alias {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName?: string(name='aliasName', example='prod'),
  createdTime?: string(name='createdTime', example='2006-01-02T15:04:05Z07:00'),
  description?: string(name='description', example='alias for pre env'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2006-01-02T15:04:05Z07:00'),
  versionId?: string(name='versionId', example='1'),
}

model AsyncConfig {
  asyncTask?: boolean(name='asyncTask', example='true'),
  createdTime?: string(name='createdTime', example='2006-01-02T15:04:05Z07:00'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:1234/functions/my-func'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2006-01-02T15:04:05Z07:00'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', example='3600'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', example='3'),
}

model AsyncTask {
  alreadyRetriedTimes?: long(name='alreadyRetriedTimes', example='3'),
  destinationStatus?: string(name='destinationStatus', example='Succeeded'),
  durationMs?: long(name='durationMs', example='1000'),
  endTime?: long(name='endTime', example='1633449590000'),
  events?: [
    AsyncTaskEvent
  ](name='events'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:1234/functions/my-func'),
  instanceId?: string(name='instanceId', example='D4-*******9FD1-882707E'),
  qualifier?: string(name='qualifier', example='prod'),
  requestId?: string(name='requestId', example='e026ae92-61e5-472f-b32d-1c9e3c4e****'),
  returnPayload?: string(name='returnPayload', example='result'),
  startedTime?: long(name='startedTime', example='1633449590000'),
  status?: string(name='status', example='Running'),
  taskErrorMessage?: string(name='taskErrorMessage', example='UnhandledInvocationError'),
  taskId?: string(name='taskId', example='e026ae92-61e5-472f-b32d-1c9e3c4e****'),
  taskPayload?: string(name='taskPayload', example='body'),
}

model AsyncTaskEvent {
  eventDetail?: string(name='eventDetail', example='body'),
  eventId?: long(name='eventId', example='1'),
  status?: string(name='status', example='Succeeded'),
  timestamp?: long(name='timestamp', example='1647420449721'),
}

model AuthConfig {
  authInfo?: string(name='authInfo', example='{}'),
  authType?: string(name='authType', example='anonymous, function, jwt'),
}

model BatchWindow {
  countBasedWindow?: int32(name='CountBasedWindow', example='100'),
  timeBasedWindow?: int32(name='TimeBasedWindow', example='10'),
}

model CDNTriggerConfig {
  eventName?: string(name='eventName', example='CdnDomainStarted'),
  eventVersion?: string(name='eventVersion', example='1.0.0'),
  filter?: map[string][ string ](name='filter'),
  notes?: string(name='notes', example='缓存事件触发器'),
}

model CertConfig {
  certName?: string(name='certName', description='This parameter is required.', example='my-cert'),
  certificate?: string(name='certificate', description='This parameter is required.', example='PEM format'),
  privateKey?: string(name='privateKey', description='This parameter is required.', example='PEM format'),
}

model ConcurrencyConfig {
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:123:functions/demo'),
  reservedConcurrency?: long(name='reservedConcurrency', example='10'),
}

model CreateAliasInput {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName?: string(name='aliasName', description='This parameter is required.', example='prod'),
  description?: string(name='description', example='my alias'),
  versionId?: string(name='versionId', description='This parameter is required.', example='1'),
}

model CreateCustomDomainInput {
  authConfig?: AuthConfig(name='authConfig'),
  certConfig?: CertConfig(name='certConfig'),
  domainName?: string(name='domainName', description='This parameter is required.', example='example.com'),
  protocol?: string(name='protocol', example='HTTP'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model CreateFunctionInput {
  code?: InputCodeLocation(name='code'),
  cpu?: float(name='cpu', example='1'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description', example='my function'),
  disableOndemand?: boolean(name='disableOndemand'),
  diskSize?: int32(name='diskSize', example='512'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionName?: string(name='functionName', description='This parameter is required.', example='my-function-1'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler', description='This parameter is required.', example='index.handler'),
  instanceConcurrency?: int32(name='instanceConcurrency', example='1'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess', example='true'),
  layers?: [ string ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize', example='512'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role', example='acs:ram::188077086902****:role/fc-test'),
  runtime?: string(name='runtime', description='This parameter is required.', example='python3.10'),
  tags?: [
    Tag
  ](name='tags'),
  timeout?: int32(name='timeout', example='60'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model CreateLayerVersionInput {
  code?: InputCodeLocation(name='code'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  description?: string(name='description', example='my first layer'),
  license?: string(name='license', example='Apache'),
}

model CreateTriggerInput {
  description?: string(name='description', example='trigger for test'),
  invocationRole?: string(name='invocationRole', example='acs:ram::1234567890:role/fc-test'),
  qualifier?: string(name='qualifier', example='LATEST'),
  sourceArn?: string(name='sourceArn', example='acs:oss:cn-shanghai:12345:mybucket'),
  triggerConfig?: string(name='triggerConfig', description='This parameter is required.', example='{"events":["oss:ObjectCreated:*"],"filter":{"key":{"prefix":"/prefix","suffix":".zip"}}}'),
  triggerName?: string(name='triggerName', description='This parameter is required.', example='oss_create_object_demo'),
  triggerType?: string(name='triggerType', description='This parameter is required.', example='oss'),
}

model CreateVpcBindingInput {
  vpcId?: string(name='vpcId', description='This parameter is required.', example='vpc-8vb8x8dggvr0axxxxxxxx'),
}

model CustomContainerConfig {
  accelerationInfo?: AccelerationInfo(name='accelerationInfo'),
  accelerationType?: string(name='accelerationType', example='deprecated'),
  acrInstanceId?: string(name='acrInstanceId', example='deprecated'),
  command?: [ string ](name='command'),
  entrypoint?: [ string ](name='entrypoint'),
  healthCheckConfig?: CustomHealthCheckConfig(name='healthCheckConfig'),
  image?: string(name='image', example='registry-vpc.cn-hangzhou.aliyuncs.com/fc-demo/helloworld:v1'),
  port?: int32(name='port', example='9000'),
  registryConfig?: RegistryConfig(name='registryConfig'),
  resolvedImageUri?: string(name='resolvedImageUri', example='stand-sh-registry-vpc.cn-shanghai.cr.aliyuncs.com/fc-demo2/springboot-helloworld@sha256:68d1****0d64d6'),
}

model CustomDNS {
  dnsOptions?: [
    DNSOption
  ](name='dnsOptions'),
  nameServers?: [ string ](name='nameServers'),
  searches?: [ string ](name='searches'),
}

model CustomDomain {
  accountId?: string(name='accountId'),
  apiVersion?: string(name='apiVersion', example='2023-03-30'),
  authConfig?: AuthConfig(name='authConfig'),
  certConfig?: CertConfig(name='certConfig'),
  createdTime?: string(name='createdTime', example='2023-03-30T08:02:19Z'),
  domainName?: string(name='domainName', example='example.com'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2023-03-30T08:02:19Z'),
  protocol?: string(name='protocol', example='HTTP'),
  routeConfig?: RouteConfig(name='routeConfig'),
  subdomainCount?: string(name='subdomainCount', example='1'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model CustomHealthCheckConfig {
  failureThreshold?: int32(name='failureThreshold', example='1'),
  httpGetUrl?: string(name='httpGetUrl', example='/ready'),
  initialDelaySeconds?: int32(name='initialDelaySeconds', example='1'),
  periodSeconds?: int32(name='periodSeconds', example='1'),
  successThreshold?: int32(name='successThreshold', example='2'),
  timeoutSeconds?: int32(name='timeoutSeconds', example='2'),
}

model CustomRuntimeConfig {
  args?: [ string ](name='args'),
  command?: [ string ](name='command'),
  healthCheckConfig?: CustomHealthCheckConfig(name='healthCheckConfig'),
  port?: int32(name='port', example='9000'),
}

model DNSOption {
  name?: string(name='name', example='ndots'),
  value?: string(name='value', example='2'),
}

model DeadLetterQueue {
  arn?: string(name='Arn'),
}

model DeliveryOption {
  concurrency?: long(name='concurrency', example='2'),
  eventSchema?: string(name='eventSchema', example='RawData'),
}

model DescribeRegionsOutput {
  regions?: {
    region?: [ 
      {
        localName?: string(name='LocalName'),
        regionId?: string(name='RegionId'),
      }
    ](name='Region'),
  }(name='Regions'),
}

model Destination {
  destination?: string(name='destination', example='acs:fc:cn-shanghai:xxx:functions/f1'),
}

model DestinationConfig {
  onFailure?: Destination(name='onFailure'),
  onSuccess?: Destination(name='onSuccess'),
}

model EqualRule {
  match?: string(name='match', description='This parameter is required.', example='/old'),
  replacement?: string(name='replacement', description='This parameter is required.', example='/new'),
}

model Error {
  code?: string(name='Code', example='FunctionNotFound'),
  message?: string(name='Message', example='function not found'),
  requestId?: string(name='RequestId', example='1-64e70cf1-5cbef92ea8fc8c42899cf5d1'),
}

model EventBridgeTriggerConfig {
  asyncInvocationType?: boolean(name='asyncInvocationType'),
  eventRuleFilterPattern?: string(name='eventRuleFilterPattern', example='{}'),
  eventSinkConfig?: EventSinkConfig(name='eventSinkConfig'),
  eventSourceConfig?: EventSourceConfig(name='eventSourceConfig'),
  runOptions?: RunOptions(name='runOptions'),
  triggerEnable?: boolean(name='triggerEnable', example='true'),
}

model EventSinkConfig {
  deliveryOption?: DeliveryOption(name='deliveryOption'),
}

model EventSourceConfig {
  eventSourceParameters?: EventSourceParameters(name='eventSourceParameters'),
  eventSourceType?: string(name='eventSourceType', example='MNS'),
}

model EventSourceParameters {
  sourceDTSParameters?: SourceDTSParameters(name='sourceDTSParameters'),
  sourceKafkaParameters?: SourceKafkaParameters(name='sourceKafkaParameters'),
  sourceMNSParameters?: SourceMNSParameters(name='sourceMNSParameters'),
  sourceMQTTParameters?: SourceMQTTParameters(name='sourceMQTTParameters'),
  sourceRabbitMQParameters?: SourceRabbitMQParameters(name='sourceRabbitMQParameters'),
  sourceRocketMQParameters?: SourceRocketMQParameters(name='sourceRocketMQParameters'),
}

model Filter {
  key?: Key(name='key'),
}

model Function {
  codeChecksum?: string(name='codeChecksum', example='2825179536350****'),
  codeSize?: long(name='codeSize', example='412'),
  cpu?: float(name='cpu', example='1'),
  createdTime?: string(name='createdTime', example='2023-04-01T08:15:27Z'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description', example='my function'),
  disableOndemand?: boolean(name='disableOndemand'),
  diskSize?: int32(name='diskSize', example='512'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:123:functions/functionName'),
  functionId?: string(name='functionId', example='aa715851-1c20-4b89-a8fb-***'),
  functionName?: string(name='functionName', example='my-function-1'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler', example='index.handler'),
  instanceConcurrency?: int32(name='instanceConcurrency', example='1'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess', example='true'),
  invocationRestriction?: FunctionRestriction(name='invocationRestriction'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2023-05-01T08:15:27Z'),
  lastUpdateStatus?: string(name='lastUpdateStatus', example='InProgress'),
  lastUpdateStatusReason?: string(name='lastUpdateStatusReason', example='The system is currently processing the acceleration optimization for the image.'),
  lastUpdateStatusReasonCode?: string(name='lastUpdateStatusReasonCode', example='ImageOptimizing'),
  layers?: [
    FunctionLayer
  ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize', example='512'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role', example='acs:ram::188077086902****:role/fc-test'),
  runtime?: string(name='runtime', example='python3.10'),
  state?: string(name='state', example='Pending'),
  stateReason?: string(name='stateReason', example='Function creating'),
  stateReasonCode?: string(name='stateReasonCode', example='Creating'),
  tags?: [
    Tag
  ](name='tags'),
  timeout?: int32(name='timeout', example='60'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model FunctionLayer {
  arn?: string(name='arn', example='acs:fc:cn-beijing:186824xxxxxx:layers/fc_layer/versions/1'),
  size?: long(name='size', example='421'),
}

model FunctionRestriction {
  disable?: boolean(name='disable'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  reason?: string(name='reason'),
}

model GPUConfig {
  gpuMemorySize?: int32(name='gpuMemorySize', example='2048'),
  gpuType?: string(name='gpuType', example='fc.gpu.tesla.1'),
}

model GetInstanceLifecycleEventsOutput {
  events?: [
    InstanceEventItem
  ](name='events'),
  requestId?: string(name='requestId'),
}

model GetResourceTagsOutput {
  resouceType?: string(name='resouceType', example='ALIYUN::FC::FUNCTION'),
  resourceArn?: string(name='resourceArn', example='acs:fc:cn-shanghai:****:functions/demo'),
  tags?: map[string]string(name='tags'),
}

model HTTPTrigger {
  urlInternet?: string(name='urlInternet', example='https://svc-func-xxxxxxxx.cn-hangzhou.fcapp.run'),
  urlIntranet?: string(name='urlIntranet', example='https://svc-func-xxxxxxxx.cn-hangzhou-vpc.fcapp.run'),
}

model HTTPTriggerConfig {
  authConfig?: string(name='authConfig', example='{"JWKS":{"foo":"bar"},"TokenLookup":"header:Authorization:Bearer,cookie:AuthorizationCookie","ClaimPassBy":"query:uid:uid,header:name:name"}'),
  authType?: string(name='authType', example='anonymous'),
  disableURLInternet?: boolean(name='disableURLInternet', example='true'),
  methods?: [ string ](name='methods'),
}

model InputCodeLocation {
  checksum?: string(name='checksum', example='2825179536350****'),
  ossBucketName?: string(name='ossBucketName', example='demo-bucket'),
  ossObjectName?: string(name='ossObjectName', example='demo-object'),
  zipFile?: string(name='zipFile', example='UEsDBAoAAAAAANF'),
}

model InstanceEventItem {
  children?: [
    InstanceEventItem
  ](name='children'),
  level?: string(name='level'),
  message?: string(name='message'),
  time?: string(name='time'),
  type?: string(name='type'),
}

model InstanceInfo {
  createdTimeMs?: long(name='createdTimeMs'),
  destroyedTimeMs?: long(name='destroyedTimeMs'),
  instanceId?: string(name='instanceId', example='1ef6b6ff-7f7b-485e-ab49-501ac681****'),
  qualifier?: string(name='qualifier'),
  status?: string(name='status'),
  versionId?: string(name='versionId'),
}

model InstanceLifecycleConfig {
  initializer?: LifecycleHook(name='initializer'),
  preStop?: LifecycleHook(name='preStop'),
}

model JobConfig {
  maxRetryTime?: int32(name='maxRetryTime', example='3'),
  triggerInterval?: int32(name='triggerInterval', example='60'),
}

model Key {
  prefix?: string(name='prefix', example='serverless_'),
  suffix?: string(name='suffix', example='.zip'),
}

model Layer {
  acl?: string(name='acl', example='0'),
  code?: OutputCodeLocation(name='code'),
  codeChecksum?: string(name='codeChecksum', example='2825179536350****'),
  codeSize?: long(name='codeSize', example='421'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  createTime?: string(name='createTime', example='2023-03-30T11:08:00Z'),
  description?: string(name='description', example='My first layer'),
  layerName?: string(name='layerName', description='This parameter is required.', example='MyLayer'),
  layerVersionArn?: string(name='layerVersionArn', example='acs:fc:cn-beijing:186824xxxxxx:layers/fc_layer/versions/1'),
  license?: string(name='license', example='Apache'),
  version?: int32(name='version', example='1'),
}

model LifecycleHook {
  handler?: string(name='handler', example='index.initializer'),
  timeout?: int32(name='timeout', example='10'),
}

model ListAliasesOutput {
  aliases?: [
    Alias
  ](name='aliases'),
  nextToken?: string(name='nextToken', example='test'),
}

model ListAsyncInvokeConfigOutput {
  configs?: [
    AsyncConfig
  ](name='configs'),
  nextToken?: string(name='nextToken', example='8bj81uI8n****'),
}

model ListAsyncTaskOutput {
  nextToken?: string(name='nextToken'),
  tasks?: [
    AsyncTask
  ](name='tasks'),
}

model ListConcurrencyConfigsOutput {
  configs?: [
    ConcurrencyConfig
  ](name='configs'),
  nextToken?: string(name='nextToken', example='next_token'),
}

model ListCustomDomainOutput {
  customDomains?: [
    CustomDomain
  ](name='customDomains'),
  nextToken?: string(name='nextToken', example='next_domain_name'),
}

model ListFunctionsOutput {
  functions?: [
    Function
  ](name='functions'),
  nextToken?: string(name='nextToken', example='next_function_name'),
}

model ListInstancesOutput {
  instances?: [
    InstanceInfo
  ](name='instances'),
  requestId?: string(name='requestId'),
}

model ListLayerVersionOutput {
  layers?: [
    Layer
  ](name='layers'),
  nextVersion?: int32(name='nextVersion', example='10'),
}

model ListLayersOutput {
  layers?: [
    Layer
  ](name='layers'),
  nextToken?: string(name='nextToken', example='next-layer-name'),
}

model ListProvisionConfigsOutput {
  nextToken?: string(name='nextToken', example='next_token'),
  provisionConfigs?: [
    ProvisionConfig
  ](name='provisionConfigs'),
}

model ListTagResourcesOutput {
  nextToken?: string(name='NextToken', example='next_token'),
  requestId?: string(name='RequestId'),
  tagResources?: [
    TagResource
  ](name='TagResources'),
}

model ListTaggedResourcesOutput {
  nextToken?: string(name='nextToken', example='next_token'),
  resources?: [
    Resource
  ](name='resources'),
}

model ListTriggersOutput {
  nextToken?: string(name='nextToken', example='next_token'),
  triggers?: [
    Trigger
  ](name='triggers'),
}

model ListVersionsOutput {
  direction?: string(name='direction', example='FORWARD'),
  nextToken?: string(name='nextToken', example='3'),
  versions?: [
    Version
  ](name='versions'),
}

model ListVpcBindingsOutput {
  vpcIds?: [ string ](name='vpcIds'),
}

model LogConfig {
  enableInstanceMetrics?: boolean(name='enableInstanceMetrics', example='true'),
  enableRequestMetrics?: boolean(name='enableRequestMetrics', example='true'),
  logBeginRule?: string(name='logBeginRule', example='DefaultRegex'),
  logstore?: string(name='logstore', example='test-logstore'),
  project?: string(name='project', example='test-project'),
}

model MNSTopicTriggerConfig {
  filterTag?: string(name='filterTag', example='serverless'),
  notifyContentFormat?: string(name='notifyContentFormat', example='JSON'),
  notifyStrategy?: string(name='notifyStrategy', example='BACKOFF_RETRY'),
}

model NASConfig {
  groupId?: int32(name='groupId', example='100'),
  mountPoints?: [
    NASMountConfig
  ](name='mountPoints'),
  userId?: int32(name='userId', example='100'),
}

model NASMountConfig {
  enableTLS?: boolean(name='enableTLS'),
  mountDir?: string(name='mountDir', example='/home/test'),
  serverAddr?: string(name='serverAddr', example='***-uni85.cn-hangzhou.nas.com:/'),
}

model OSSMountConfig {
  mountPoints?: [
    OSSMountPoint
  ](name='mountPoints'),
}

model OSSMountPoint {
  bucketName?: string(name='bucketName', example='my-bucket'),
  bucketPath?: string(name='bucketPath', example='/my-dir'),
  endpoint?: string(name='endpoint', example='http://oss-cn-shanghai.aliyuncs.com'),
  mountDir?: string(name='mountDir', example='/mnt/dir'),
  readOnly?: boolean(name='readOnly', example='true'),
}

model OSSTriggerConfig {
  events?: [ string ](name='events'),
  filter?: Filter(name='filter'),
}

model OutputCodeLocation {
  location?: string(name='location', example='https://xyz.oss-cn-shanghai.aliyuncs.com/xxx/xxx/xxx'),
  repositoryType?: string(name='repositoryType', example='OSS'),
}

model OutputFuncCode {
  checksum?: string(name='checksum', example='1234567890'),
  url?: string(name='url', example='http://func-code.oss-cn-shanghai.aliyuncs.com/1a2b3c4d5e6f'),
}

model PathConfig {
  functionName?: string(name='functionName', description='This parameter is required.', example='myFunction'),
  methods?: [ string ](name='methods'),
  path?: string(name='path', description='This parameter is required.', example='/api/*'),
  qualifier?: string(name='qualifier', example='myAlias'),
  rewriteConfig?: RewriteConfig(name='rewriteConfig'),
}

model ProvisionConfig {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', example='true'),
  alwaysAllocateGPU?: boolean(name='alwaysAllocateGPU', example='true'),
  current?: long(name='current', example='1'),
  currentError?: string(name='currentError', example='image not found'),
  defaultTarget?: long(name='defaultTarget', example='5'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:124:functions/myFunction/prod'),
  scheduledActions?: [
    ScheduledAction
  ](name='scheduledActions'),
  target?: long(name='target', example='5'),
  targetTrackingPolicies?: [
    TargetTrackingPolicy
  ](name='targetTrackingPolicies'),
}

model PublishVersionInput {
  description?: string(name='description', example='my version'),
}

model PutAsyncInvokeConfigInput {
  asyncTask?: boolean(name='asyncTask', example='true'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', example='300'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', example='3'),
}

model PutConcurrencyInput {
  reservedConcurrency?: long(name='reservedConcurrency', description='This parameter is required.', example='10'),
}

model PutProvisionConfigInput {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', example='true'),
  alwaysAllocateGPU?: boolean(name='alwaysAllocateGPU', example='true'),
  defaultTarget?: long(name='defaultTarget', nullable=true),
  scheduledActions?: [
    ScheduledAction
  ](name='scheduledActions'),
  target?: long(name='target', description='This parameter is required.', example='1', deprecated=true, nullable=true),
  targetTrackingPolicies?: [
    TargetTrackingPolicy
  ](name='targetTrackingPolicies'),
}

model RegexRule {
  match?: string(name='match', description='This parameter is required.', example='^/api/.+?/(.*)'),
  replacement?: string(name='replacement', description='This parameter is required.', example='/api/v2/$1'),
}

model RegistryAuthConfig {
  password?: string(name='password', example='abc***'),
  userName?: string(name='userName', example='admin'),
}

model RegistryCertConfig {
  insecure?: boolean(name='insecure'),
  rootCaCertBase64?: string(name='rootCaCertBase64', example='cm9vdF9jYV9jZXJ0'),
}

model RegistryConfig {
  authConfig?: RegistryAuthConfig(name='authConfig'),
  certConfig?: RegistryCertConfig(name='certConfig'),
  networkConfig?: RegistryNetworkConfig(name='networkConfig'),
}

model RegistryNetworkConfig {
  securityGroupId?: string(name='securityGroupId', example='sg-xxxxxxxxxxxxxx'),
  vSwitchId?: string(name='vSwitchId', example='vsw-xxxxxxxxxxxxxx'),
  vpcId?: string(name='vpcId', example='vpc-xxxxxxxxxxxxxx'),
}

model Resource {
  resouceType?: string(name='resouceType', example='ALIYUN::FC::FUNCTION'),
  resourceArn?: string(name='resourceArn', example='acs:fc:cn-shanghai:****:functions/demo'),
  tags?: map[string]string(name='tags'),
}

model RetryStrategy {
  pushRetryStrategy?: string(name='PushRetryStrategy', example='BACKOFF_RETRY'),
}

model RewriteConfig {
  equalRules?: [
    EqualRule
  ](name='equalRules'),
  regexRules?: [
    RegexRule
  ](name='regexRules'),
  wildcardRules?: [
    WildcardRule
  ](name='wildcardRules'),
}

model RouteConfig {
  routes?: [
    PathConfig
  ](name='routes'),
}

model RunOptions {
  batchWindow?: BatchWindow(name='batchWindow'),
  deadLetterQueue?: DeadLetterQueue(name='deadLetterQueue'),
  errorsTolerance?: string(name='errorsTolerance', example='ALL'),
  mode?: string(name='mode', example='event-streaming'),
  retryStrategy?: RetryStrategy(name='retryStrategy'),
}

model SLSTriggerConfig {
  enable?: boolean(name='enable', example='true'),
  functionParameter?: map[string]string(name='functionParameter'),
  jobConfig?: JobConfig(name='jobConfig'),
  logConfig?: SLSTriggerLogConfig(name='logConfig'),
  sourceConfig?: SourceConfig(name='sourceConfig'),
}

model SLSTriggerLogConfig {
  logstore?: string(name='logstore', example='my-sls-logstore-name'),
  project?: string(name='project', example='my-sls-project-name'),
}

model ScheduledAction {
  endTime?: string(name='endTime', example='2024-03-10T10:10:10'),
  name?: string(name='name', description='This parameter is required.', example='test_1'),
  scheduleExpression?: string(name='scheduleExpression', description='This parameter is required.', example='cron(0 0 22 * * *)'),
  startTime?: string(name='startTime', example='2023-03-10T10:10:10'),
  target?: long(name='target', description='This parameter is required.', example='50'),
  timeZone?: string(name='timeZone', example='Asia/Shanghai'),
}

model SourceConfig {
  logstore?: string(name='logstore', example='my-sls-logstore-name'),
  startTime?: long(name='startTime', example='1704790317'),
}

model SourceDTSParameters {
  brokerUrl?: string(name='BrokerUrl', example='dts-cn-shanghai-vpc.com:18003'),
  initCheckPoint?: int32(name='InitCheckPoint', example='1677340805'),
  password?: string(name='Password', example='dtsTest123'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  sid?: string(name='Sid', example='dtse34j22j025a****'),
  taskId?: string(name='TaskId', example='e34z2gm325q****'),
  topic?: string(name='Topic', example='cn_shanghai_vpc_rm_uf6398ykj0218****_dts_trigger_upgrade_from_old_version2'),
  username?: string(name='Username', example='dts_trigger'),
}

model SourceKafkaParameters {
  consumerGroup?: string(name='ConsumerGroup', example='DEFAULT_GROUP'),
  instanceId?: string(name='InstanceId', example='r-8vb64581862c****'),
  network?: string(name='Network', example='Default'),
  offsetReset?: string(name='OffsetReset', example='latest'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  securityGroupId?: string(name='SecurityGroupId', example='sg-bp1iv19sp1msc7zot4****'),
  topic?: string(name='Topic', example='popvip_center_robot_order'),
  vSwitchIds?: string(name='VSwitchIds', example='vsw-bp179l3llg3jjxwrq72****'),
  vpcId?: string(name='VpcId', example='vpc-8vblalsi0vbhizr77****'),
}

model SourceMNSParameters {
  isBase64Decode?: boolean(name='IsBase64Decode', example='true'),
  queueName?: string(name='QueueName', example='demo'),
  regionId?: string(name='RegionId', example='cn-shanghai'),
}

model SourceMQTTParameters {
  instanceId?: string(name='InstanceId', example='mqtt-****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  topic?: string(name='Topic', example='testTopic'),
}

model SourceRabbitMQParameters {
  instanceId?: string(name='InstanceId', example='amqp-cn-nif22u74****'),
  queueName?: string(name='QueueName', example='demo'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  virtualHostName?: string(name='VirtualHostName', example='eb-connect'),
}

model SourceRocketMQParameters {
  authType?: string(name='AuthType', example='ACL'),
  filterType?: string(name='FilterType', example='Tag'),
  groupID?: string(name='GroupID', example='GID_group1'),
  instanceEndpoint?: string(name='InstanceEndpoint', example='registry-vpc.cn-hangzhou.aliyuncs.com'),
  instanceId?: string(name='InstanceId', example='MQ_INST_164901546557****_BAAN****'),
  instanceNetwork?: string(name='InstanceNetwork', example='PrivateNetwork'),
  instancePassword?: string(name='InstancePassword', example='123'),
  instanceSecurityGroupId?: string(name='InstanceSecurityGroupId', example='sg-hp35r2hc3a3sv8q2****'),
  instanceType?: string(name='InstanceType', example='Cloud_5'),
  instanceUsername?: string(name='InstanceUsername', example='6W0xz2uPfiwp****'),
  instanceVSwitchIds?: string(name='InstanceVSwitchIds', example='vsw-uf6gwtbn6etadpvz7****'),
  instanceVpcId?: string(name='InstanceVpcId', example='vpc-uf6of9452b2pba82c****'),
  offset?: string(name='Offset', example='CONSUME_FROM_TIMESTAMP'),
  regionId?: string(name='RegionId', example='cn-shanghai'),
  tag?: string(name='Tag', example='test'),
  timestamp?: int32(name='Timestamp', example='1636597951964'),
  topic?: string(name='Topic', example='myTopic'),
}

model TLSConfig {
  cipherSuites?: [ string ](name='cipherSuites', description='This parameter is required.'),
  maxVersion?: string(name='maxVersion', example='TLSv1.3'),
  minVersion?: string(name='minVersion', description='This parameter is required.', example='TLSv1.0'),
}

model Tag {
  key?: string(name='Key', example='k1'),
  value?: string(name='Value', example='v1'),
}

model TagResource {
  resourceId?: string(name='ResourceId', example='acs:fc:cn-shanghai:****:functions/demo'),
  resourceType?: string(name='ResourceType', example='ALIYUN::FC::FUNCTION'),
  tagKey?: string(name='TagKey', example='key1'),
  tagValue?: string(name='TagValue', example='key1'),
}

model TagResourceInput {
  resourceArn?: string(name='resourceArn', description='This parameter is required.', example='acs:fc:cn-shanghai:xxx:functions/f1'),
  tags?: map[string]string(name='tags', description='This parameter is required.'),
}

model TagResourcesInput {
  resourceId?: [ string ](name='ResourceId', description='This parameter is required.'),
  resourceType?: string(name='ResourceType', example='FUNCTION'),
  tag?: [
    Tag
  ](name='Tag', description='This parameter is required.'),
}

model TargetTrackingPolicy {
  endTime?: string(name='endTime', example='2024-03-10T10:10:10'),
  maxCapacity?: long(name='maxCapacity', description='This parameter is required.', example='10'),
  metricTarget?: float(name='metricTarget', description='This parameter is required.', example='0.6'),
  metricType?: string(name='metricType', description='This parameter is required.', example='CPUUtilization'),
  minCapacity?: long(name='minCapacity', description='This parameter is required.', example='1'),
  name?: string(name='name', description='This parameter is required.', example='test_1'),
  startTime?: string(name='startTime', example='2023-03-10T10:10:10'),
  timeZone?: string(name='timeZone', example='Asia/Shanghai'),
}

model TimerTriggerConfig {
  cronExpression?: string(name='cronExpression', example='0 0 4 * * *'),
  enable?: boolean(name='enable', example='true'),
  payload?: string(name='payload', example='{"workflowInstanceId":"39639"}'),
}

model TracingConfig {
  params?: map[string]string(name='params'),
  type?: string(name='type', example='Jaeger'),
}

model Trigger {
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  httpTrigger?: HTTPTrigger(name='httpTrigger'),
  invocationRole?: string(name='invocationRole'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  qualifier?: string(name='qualifier'),
  sourceArn?: string(name='sourceArn'),
  status?: string(name='status'),
  targetArn?: string(name='targetArn'),
  triggerConfig?: string(name='triggerConfig'),
  triggerId?: string(name='triggerId'),
  triggerName?: string(name='triggerName'),
  triggerType?: string(name='triggerType'),
}

model UpdateAliasInput {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  description?: string(name='description', example='my alias'),
  versionId?: string(name='versionId', example='1'),
}

model UpdateCustomDomainInput {
  authConfig?: AuthConfig(name='authConfig'),
  certConfig?: CertConfig(name='certConfig'),
  protocol?: string(name='protocol', example='HTTP'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model UpdateFunctionInput {
  code?: InputCodeLocation(name='code'),
  cpu?: float(name='cpu', example='1'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description', example='my function'),
  disableOndemand?: boolean(name='disableOndemand'),
  diskSize?: int32(name='diskSize', example='512'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler', example='index.handler'),
  instanceConcurrency?: int32(name='instanceConcurrency', example='1'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess', example='true'),
  layers?: [ string ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize', example='512'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role', example='acs:ram::188077086902****:role/fc-test'),
  runtime?: string(name='runtime'),
  timeout?: int32(name='timeout', example='60'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model UpdateTriggerInput {
  description?: string(name='description', example='trigger for test'),
  invocationRole?: string(name='invocationRole', example='acs:ram::1234567890:role/fc-test'),
  qualifier?: string(name='qualifier', example='LATEST'),
  triggerConfig?: string(name='triggerConfig', example='{"events":["oss:ObjectCreated:*"],"filter":{"key":{"prefix":"/prefix","suffix":".zip"}}}'),
}

model VPCConfig {
  role?: string(name='role', example='acs:ram::188077086902****:role/fc-test'),
  securityGroupId?: string(name='securityGroupId', example='sg-bp18hj1wtxgy3b0***'),
  vSwitchIds?: [ string ](name='vSwitchIds'),
  vpcId?: string(name='vpcId', example='vpc-***'),
}

model Version {
  createdTime?: string(name='createdTime', example='2006-01-02T15:04:05Z07:00'),
  description?: string(name='description', example='my version'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2006-01-02T15:04:05Z07:00'),
  versionId?: string(name='versionId', example='1'),
}

model WAFConfig {
  enableWAF?: boolean(name='enableWAF', example='true'),
}

model WildcardRule {
  match?: string(name='match', description='This parameter is required.', example='/api/*'),
  replacement?: string(name='replacement', description='This parameter is required.', example='/$1'),
}

model CreateAliasRequest {
  body?: CreateAliasInput(name='body', description='The request parameters for creating an alias.

This parameter is required.'),
}

model CreateAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Alias  
}

/**
 * @summary 创建函数别名。
 *
 * @param request CreateAliasRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAliasResponse
 */
async function createAliasWithOptions(functionName: string, request: CreateAliasRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAliasResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlias',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建函数别名。
 *
 * @param request CreateAliasRequest
 * @return CreateAliasResponse
 */
async function createAlias(functionName: string, request: CreateAliasRequest): CreateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAliasWithOptions(functionName, request, headers, runtime);
}

model CreateCustomDomainRequest {
  body?: CreateCustomDomainInput(name='body', description='The information about the custom domain name.

This parameter is required.'),
}

model CreateCustomDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CustomDomain  
}

/**
 * @summary Creates a custom domain name.
 *
 * @description If you want to use a fixed domain name to access an application or function in a production environment of Function Compute, or to resolve the issue of forced downloads when accessing an HTTP trigger, you can bind a custom domain name to the application or function.
 *
 * @param request CreateCustomDomainRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCustomDomainResponse
 */
async function createCustomDomainWithOptions(request: CreateCustomDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateCustomDomainResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCustomDomain',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a custom domain name.
 *
 * @description If you want to use a fixed domain name to access an application or function in a production environment of Function Compute, or to resolve the issue of forced downloads when accessing an HTTP trigger, you can bind a custom domain name to the application or function.
 *
 * @param request CreateCustomDomainRequest
 * @return CreateCustomDomainResponse
 */
async function createCustomDomain(request: CreateCustomDomainRequest): CreateCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createCustomDomainWithOptions(request, headers, runtime);
}

model CreateFunctionRequest {
  body?: CreateFunctionInput(name='body', description='The information about function configurations.

This parameter is required.'),
}

model CreateFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Function  
}

/**
 * @summary Creates a function.
 *
 * @description Resources of Function Compute are scheduled and run based on functions. A function usually refers to a code snippet that is written by a user and can be independently executed to respond to events and requests.
 *
 * @param request CreateFunctionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFunctionResponse
 */
async function createFunctionWithOptions(request: CreateFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFunctionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a function.
 *
 * @description Resources of Function Compute are scheduled and run based on functions. A function usually refers to a code snippet that is written by a user and can be independently executed to respond to events and requests.
 *
 * @param request CreateFunctionRequest
 * @return CreateFunctionResponse
 */
async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFunctionWithOptions(request, headers, runtime);
}

model CreateLayerVersionRequest {
  body?: CreateLayerVersionInput(name='body', description='The information about layer configurations.

This parameter is required.'),
}

model CreateLayerVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Layer  
}

/**
 * @summary 创建层版本。
 *
 * @param request CreateLayerVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLayerVersionResponse
 */
async function createLayerVersionWithOptions(layerName: string, request: CreateLayerVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLayerVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLayerVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建层版本。
 *
 * @param request CreateLayerVersionRequest
 * @return CreateLayerVersionResponse
 */
async function createLayerVersion(layerName: string, request: CreateLayerVersionRequest): CreateLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLayerVersionWithOptions(layerName, request, headers, runtime);
}

model CreateTriggerRequest {
  body?: CreateTriggerInput(name='body', description='The trigger configurations.

This parameter is required.'),
}

model CreateTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Trigger  
}

/**
 * @summary 创建函数触发器。
 *
 * @param request CreateTriggerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTriggerResponse
 */
async function createTriggerWithOptions(functionName: string, request: CreateTriggerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTriggerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTrigger',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建函数触发器。
 *
 * @param request CreateTriggerRequest
 * @return CreateTriggerResponse
 */
async function createTrigger(functionName: string, request: CreateTriggerRequest): CreateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTriggerWithOptions(functionName, request, headers, runtime);
}

model CreateVpcBindingRequest {
  body?: CreateVpcBindingInput(name='body', description='The VPC binding configurations.

This parameter is required.'),
}

model CreateVpcBindingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a VPC connection.
 *
 * @param request CreateVpcBindingRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpcBindingResponse
 */
async function createVpcBindingWithOptions(functionName: string, request: CreateVpcBindingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateVpcBindingResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpcBinding',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/vpc-bindings`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a VPC connection.
 *
 * @param request CreateVpcBindingRequest
 * @return CreateVpcBindingResponse
 */
async function createVpcBinding(functionName: string, request: CreateVpcBindingRequest): CreateVpcBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createVpcBindingWithOptions(functionName, request, headers, runtime);
}

model DeleteAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes an alias.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAliasResponse
 */
async function deleteAliasWithOptions(functionName: string, aliasName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAliasResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlias',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases/${OpenApiUtil.getEncodeParam(aliasName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an alias.
 *
 * @return DeleteAliasResponse
 */
async function deleteAlias(functionName: string, aliasName: string): DeleteAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAliasWithOptions(functionName, aliasName, headers, runtime);
}

model DeleteAsyncInvokeConfigRequest {
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST'),
}

model DeleteAsyncInvokeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes an asynchronous invocation configuration.
 *
 * @param request DeleteAsyncInvokeConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAsyncInvokeConfigResponse
 */
async function deleteAsyncInvokeConfigWithOptions(functionName: string, request: DeleteAsyncInvokeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAsyncInvokeConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-invoke-config`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an asynchronous invocation configuration.
 *
 * @param request DeleteAsyncInvokeConfigRequest
 * @return DeleteAsyncInvokeConfigResponse
 */
async function deleteAsyncInvokeConfig(functionName: string, request: DeleteAsyncInvokeConfigRequest): DeleteAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAsyncInvokeConfigWithOptions(functionName, request, headers, runtime);
}

model DeleteConcurrencyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a concurrency configuration.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConcurrencyConfigResponse
 */
async function deleteConcurrencyConfigWithOptions(functionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConcurrencyConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteConcurrencyConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/concurrency`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a concurrency configuration.
 *
 * @return DeleteConcurrencyConfigResponse
 */
async function deleteConcurrencyConfig(functionName: string): DeleteConcurrencyConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConcurrencyConfigWithOptions(functionName, headers, runtime);
}

model DeleteCustomDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a custom domain name.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomDomainResponse
 */
async function deleteCustomDomainWithOptions(domainName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteCustomDomainResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomDomain',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains/${OpenApiUtil.getEncodeParam(domainName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a custom domain name.
 *
 * @return DeleteCustomDomainResponse
 */
async function deleteCustomDomain(domainName: string): DeleteCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteCustomDomainWithOptions(domainName, headers, runtime);
}

model DeleteFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a function.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFunctionResponse
 */
async function deleteFunctionWithOptions(functionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFunctionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a function.
 *
 * @return DeleteFunctionResponse
 */
async function deleteFunction(functionName: string): DeleteFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionWithOptions(functionName, headers, runtime);
}

model DeleteFunctionVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary http://pre.hhht/#vpc
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFunctionVersionResponse
 */
async function deleteFunctionVersionWithOptions(functionName: string, versionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFunctionVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunctionVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/versions/${OpenApiUtil.getEncodeParam(versionId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary http://pre.hhht/#vpc
 *
 * @return DeleteFunctionVersionResponse
 */
async function deleteFunctionVersion(functionName: string, versionId: string): DeleteFunctionVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionVersionWithOptions(functionName, versionId, headers, runtime);
}

model DeleteLayerVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a layer version.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteLayerVersionResponse
 */
async function deleteLayerVersionWithOptions(layerName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLayerVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLayerVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions/${OpenApiUtil.getEncodeParam(version)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a layer version.
 *
 * @return DeleteLayerVersionResponse
 */
async function deleteLayerVersion(layerName: string, version: string): DeleteLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLayerVersionWithOptions(layerName, version, headers, runtime);
}

model DeleteProvisionConfigRequest {
  qualifier?: string(name='qualifier', description='The function alias.', example='LATEST'),
}

model DeleteProvisionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a provisioned configuration.
 *
 * @param request DeleteProvisionConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteProvisionConfigResponse
 */
async function deleteProvisionConfigWithOptions(functionName: string, request: DeleteProvisionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProvisionConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProvisionConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/provision-config`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a provisioned configuration.
 *
 * @param request DeleteProvisionConfigRequest
 * @return DeleteProvisionConfigResponse
 */
async function deleteProvisionConfig(functionName: string, request: DeleteProvisionConfigRequest): DeleteProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProvisionConfigWithOptions(functionName, request, headers, runtime);
}

model DeleteTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a trigger.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTriggerResponse
 */
async function deleteTriggerWithOptions(functionName: string, triggerName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTriggerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteTrigger',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers/${OpenApiUtil.getEncodeParam(triggerName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a trigger.
 *
 * @return DeleteTriggerResponse
 */
async function deleteTrigger(functionName: string, triggerName: string): DeleteTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTriggerWithOptions(functionName, triggerName, headers, runtime);
}

model DeleteVpcBindingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes an access control policy from a specified policy group for a VPC firewall.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpcBindingResponse
 */
async function deleteVpcBindingWithOptions(functionName: string, vpcId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteVpcBindingResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpcBinding',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/vpc-bindings/${OpenApiUtil.getEncodeParam(vpcId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an access control policy from a specified policy group for a VPC firewall.
 *
 * @return DeleteVpcBindingResponse
 */
async function deleteVpcBinding(functionName: string, vpcId: string): DeleteVpcBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteVpcBindingWithOptions(functionName, vpcId, headers, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', example='zh-CN'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsOutput  
}

/**
 * @summary 查询产品的地域信息列表
 *
 * @param request DescribeRegionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
async function describeRegionsWithOptions(request: DescribeRegionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/regions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询产品的地域信息列表
 *
 * @param request DescribeRegionsRequest
 * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(request, headers, runtime);
}

model DisableFunctionInvocationRequest {
  abortOngoingRequest?: boolean(name='abortOngoingRequest', description='Specifies whether to immediately terminate all ongoing requests.', example='false'),
  reason?: string(name='reason', description='The reason for disabling the function\\\\"s invocation.'),
}

model DisableFunctionInvocationResponseBody = {
  success?: boolean(name='success', description='Indicates whether the request is successful.', example='true'),
}

model DisableFunctionInvocationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableFunctionInvocationResponseBody(name='body'),
}

/**
 * @summary The DisableFunctionInvocation operation prevents a function from being invoked and optionally terminates all requests that are being processed. Once a function\\"s invocation is disabled, no new instances can be created, and the existing provisioned instances are destroyed. This operation is currently in private preview.
 *
 * @description Exercise caution when you call this operation on a function in a production environment, as improper deactivation may lead to business disruptions.
 *
 * @param request DisableFunctionInvocationRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableFunctionInvocationResponse
 */
async function disableFunctionInvocationWithOptions(functionName: string, request: DisableFunctionInvocationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DisableFunctionInvocationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.abortOngoingRequest)) {
    body['abortOngoingRequest'] = request.abortOngoingRequest;
  }
  if (!Util.isUnset(request.reason)) {
    body['reason'] = request.reason;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DisableFunctionInvocation',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/invoke/disable`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary The DisableFunctionInvocation operation prevents a function from being invoked and optionally terminates all requests that are being processed. Once a function\\"s invocation is disabled, no new instances can be created, and the existing provisioned instances are destroyed. This operation is currently in private preview.
 *
 * @description Exercise caution when you call this operation on a function in a production environment, as improper deactivation may lead to business disruptions.
 *
 * @param request DisableFunctionInvocationRequest
 * @return DisableFunctionInvocationResponse
 */
async function disableFunctionInvocation(functionName: string, request: DisableFunctionInvocationRequest): DisableFunctionInvocationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableFunctionInvocationWithOptions(functionName, request, headers, runtime);
}

model EnableFunctionInvocationResponseBody = {
  success?: boolean(name='success', example='true'),
}

model EnableFunctionInvocationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableFunctionInvocationResponseBody(name='body'),
}

/**
 * @summary 允许函数调用
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableFunctionInvocationResponse
 */
async function enableFunctionInvocationWithOptions(functionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): EnableFunctionInvocationResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'EnableFunctionInvocation',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/invoke/enable`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 允许函数调用
 *
 * @return EnableFunctionInvocationResponse
 */
async function enableFunctionInvocation(functionName: string): EnableFunctionInvocationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableFunctionInvocationWithOptions(functionName, headers, runtime);
}

model GetAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Alias  
}

/**
 * @summary Queries information about an alias.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAliasResponse
 */
async function getAliasWithOptions(functionName: string, aliasName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAliasResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAlias',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases/${OpenApiUtil.getEncodeParam(aliasName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries information about an alias.
 *
 * @return GetAliasResponse
 */
async function getAlias(functionName: string, aliasName: string): GetAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAliasWithOptions(functionName, aliasName, headers, runtime);
}

model GetAsyncInvokeConfigRequest {
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST'),
}

model GetAsyncInvokeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AsyncConfig  
}

/**
 * @summary Gets asynchronous invocation configurations of a function.
 *
 * @param request GetAsyncInvokeConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAsyncInvokeConfigResponse
 */
async function getAsyncInvokeConfigWithOptions(functionName: string, request: GetAsyncInvokeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAsyncInvokeConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-invoke-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Gets asynchronous invocation configurations of a function.
 *
 * @param request GetAsyncInvokeConfigRequest
 * @return GetAsyncInvokeConfigResponse
 */
async function getAsyncInvokeConfig(functionName: string, request: GetAsyncInvokeConfigRequest): GetAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAsyncInvokeConfigWithOptions(functionName, request, headers, runtime);
}

model GetAsyncTaskRequest {
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST'),
}

model GetAsyncTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AsyncTask  
}

/**
 * @summary Queries the information about an asynchronous task.
 *
 * @param request GetAsyncTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAsyncTaskResponse
 */
async function getAsyncTaskWithOptions(functionName: string, taskId: string, request: GetAsyncTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAsyncTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAsyncTask',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-tasks/${OpenApiUtil.getEncodeParam(taskId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about an asynchronous task.
 *
 * @param request GetAsyncTaskRequest
 * @return GetAsyncTaskResponse
 */
async function getAsyncTask(functionName: string, taskId: string, request: GetAsyncTaskRequest): GetAsyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAsyncTaskWithOptions(functionName, taskId, request, headers, runtime);
}

model GetConcurrencyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConcurrencyConfig  
}

/**
 * @summary Obtains a concurrency configuration.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetConcurrencyConfigResponse
 */
async function getConcurrencyConfigWithOptions(functionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetConcurrencyConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetConcurrencyConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/concurrency`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a concurrency configuration.
 *
 * @return GetConcurrencyConfigResponse
 */
async function getConcurrencyConfig(functionName: string): GetConcurrencyConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getConcurrencyConfigWithOptions(functionName, headers, runtime);
}

model GetCustomDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CustomDomain  
}

/**
 * @summary Queries information about a custom domain name.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCustomDomainResponse
 */
async function getCustomDomainWithOptions(domainName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetCustomDomainResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetCustomDomain',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains/${OpenApiUtil.getEncodeParam(domainName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries information about a custom domain name.
 *
 * @return GetCustomDomainResponse
 */
async function getCustomDomain(domainName: string): GetCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCustomDomainWithOptions(domainName, headers, runtime);
}

model GetFunctionRequest {
  qualifier?: string(name='qualifier', description='2023-03-10T10:10:10Z', example='LATEST'),
}

model GetFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Function  
}

/**
 * @summary http://pre.hhht/#vpc
 *
 * @param request GetFunctionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionResponse
 */
async function getFunctionWithOptions(functionName: string, request: GetFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary http://pre.hhht/#vpc
 *
 * @param request GetFunctionRequest
 * @return GetFunctionResponse
 */
async function getFunction(functionName: string, request: GetFunctionRequest): GetFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionWithOptions(functionName, request, headers, runtime);
}

model GetFunctionCodeRequest {
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST'),
}

model GetFunctionCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OutputFuncCode  
}

/**
 * @summary Queries a code package of a function.
 *
 * @param request GetFunctionCodeRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionCodeResponse
 */
async function getFunctionCodeWithOptions(functionName: string, request: GetFunctionCodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionCodeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunctionCode',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/code`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a code package of a function.
 *
 * @param request GetFunctionCodeRequest
 * @return GetFunctionCodeResponse
 */
async function getFunctionCode(functionName: string, request: GetFunctionCodeRequest): GetFunctionCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionCodeWithOptions(functionName, request, headers, runtime);
}

model GetLayerVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Layer  
}

/**
 * @summary Queries versions of a layer.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLayerVersionResponse
 */
async function getLayerVersionWithOptions(layerName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLayerVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLayerVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions/${OpenApiUtil.getEncodeParam(version)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries versions of a layer.
 *
 * @return GetLayerVersionResponse
 */
async function getLayerVersion(layerName: string, version: string): GetLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLayerVersionWithOptions(layerName, version, headers, runtime);
}

model GetLayerVersionByArnResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Layer  
}

/**
 * @summary Obtain version information of a layer by using ARNs.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLayerVersionByArnResponse
 */
async function getLayerVersionByArnWithOptions(arn: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLayerVersionByArnResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLayerVersionByArn',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layerarn/${OpenApiUtil.getEncodeParam(arn)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtain version information of a layer by using ARNs.
 *
 * @return GetLayerVersionByArnResponse
 */
async function getLayerVersionByArn(arn: string): GetLayerVersionByArnResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLayerVersionByArnWithOptions(arn, headers, runtime);
}

model GetProvisionConfigRequest {
  qualifier?: string(name='qualifier', description='The function alias.', example='LATEST'),
}

model GetProvisionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ProvisionConfig  
}

/**
 * @summary Queries provisioned configurations.
 *
 * @param request GetProvisionConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetProvisionConfigResponse
 */
async function getProvisionConfigWithOptions(functionName: string, request: GetProvisionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProvisionConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProvisionConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/provision-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries provisioned configurations.
 *
 * @param request GetProvisionConfigRequest
 * @return GetProvisionConfigResponse
 */
async function getProvisionConfig(functionName: string, request: GetProvisionConfigRequest): GetProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProvisionConfigWithOptions(functionName, request, headers, runtime);
}

model GetTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Trigger  
}

/**
 * @summary Queries information about a trigger.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTriggerResponse
 */
async function getTriggerWithOptions(functionName: string, triggerName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTriggerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTrigger',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers/${OpenApiUtil.getEncodeParam(triggerName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries information about a trigger.
 *
 * @return GetTriggerResponse
 */
async function getTrigger(functionName: string, triggerName: string): GetTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTriggerWithOptions(functionName, triggerName, headers, runtime);
}

model InvokeFunctionHeaders {
  commonHeaders?: map[string]string,
  xFcAsyncTaskId?: string(name='x-fc-async-task-id', description='The ID of the asynchronous task. You must enable the asynchronous task feature in advance.

>  If you use an SDK to invoke a function, we recommend that you specify a business-related ID to facilitate subsequent operations. For example, a video processing function can use video file names as invocation IDs. This way, you can easily check whether a video is successfully processed or terminated before it is processed. The ID can start only with letters or underscores. An ID can contain *letters, digits (0 - 9), underscores*, and hyphens (-). It can be up to 128 characters in length. If you do not specify the ID of the asynchronous invocation, the system automatically generates an ID.', example='test-id'),
  xFcInvocationType?: string(name='x-fc-invocation-type', description='The type of function invocation. Valid values: Sync and Async.', example='Sync'),
  xFcLogType?: string(name='x-fc-log-type', description='The log type of function invocation. Valid values: None and Tail.', example='Tail'),
}

model InvokeFunctionRequest {
  body?: readable(name='body', description='The request parameters of function invocation.', example='event'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST'),
}

model InvokeFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: readable(name='body'),
}

/**
 * @summary Invokes a function.
 *
 * @param request InvokeFunctionRequest
 * @param headers InvokeFunctionHeaders
 * @param runtime runtime options for this request RuntimeOptions
 * @return InvokeFunctionResponse
 */
async function invokeFunctionWithOptions(functionName: string, request: InvokeFunctionRequest, headers: InvokeFunctionHeaders, runtime: Util.RuntimeOptions): InvokeFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAsyncTaskId)) {
    realHeaders['x-fc-async-task-id'] = Util.toJSONString(headers.xFcAsyncTaskId);
  }
  if (!Util.isUnset(headers.xFcInvocationType)) {
    realHeaders['x-fc-invocation-type'] = Util.toJSONString(headers.xFcInvocationType);
  }
  if (!Util.isUnset(headers.xFcLogType)) {
    realHeaders['x-fc-log-type'] = Util.toJSONString(headers.xFcLogType);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = request.body,
    stream = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InvokeFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/invocations`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'binary',
  };
  var res = new InvokeFunctionResponse{};
  var tmp = Util.assertAsMap(callApi(params, req, runtime));
  if (!Util.isUnset(tmp.body)) {
    var respBody = Util.assertAsReadable(tmp.body);
    res.body = respBody;
  }
  if (!Util.isUnset(tmp.headers)) {
    var respHeaders = Util.assertAsMap(tmp.headers);
    res.headers = Util.stringifyMapValue(respHeaders);
  }
  if (!Util.isUnset(tmp.statusCode)) {
    var statusCode = Util.assertAsInteger(tmp.statusCode);
    res.statusCode = statusCode;
  }
  return res;
}

/**
 * @summary Invokes a function.
 *
 * @param request InvokeFunctionRequest
 * @return InvokeFunctionResponse
 */
async function invokeFunction(functionName: string, request: InvokeFunctionRequest): InvokeFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new InvokeFunctionHeaders{};
  return invokeFunctionWithOptions(functionName, request, headers, runtime);
}

model ListAliasesRequest {
  limit?: int32(name='limit', description='The number of aliases returned.', example='10'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM='),
  prefix?: string(name='prefix', description='The alias prefix.', example='my-alias'),
}

model ListAliasesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAliasesOutput  
}

/**
 * @summary Queries aliases.
 *
 * @param request ListAliasesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAliasesResponse
 */
async function listAliasesWithOptions(functionName: string, request: ListAliasesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAliasesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAliases',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries aliases.
 *
 * @param request ListAliasesRequest
 * @return ListAliasesResponse
 */
async function listAliases(functionName: string, request: ListAliasesRequest): ListAliasesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAliasesWithOptions(functionName, request, headers, runtime);
}

model ListAsyncInvokeConfigsRequest {
  functionName?: string(name='functionName', description='The function name. If you do not configure this parameter, the asynchronous invocation configurations of all functions are displayed.', example='my-func'),
  limit?: int32(name='limit', description='The maximum number of entries to be returned.', example='10'),
  nextToken?: string(name='nextToken', description='The paging information. This parameter specifies the start point of the query.', example='MTIzNCNhYmM='),
}

model ListAsyncInvokeConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAsyncInvokeConfigOutput  
}

/**
 * @summary Queries all asynchronous configurations of a function.
 *
 * @param request ListAsyncInvokeConfigsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAsyncInvokeConfigsResponse
 */
async function listAsyncInvokeConfigsWithOptions(request: ListAsyncInvokeConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAsyncInvokeConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.functionName)) {
    query['functionName'] = request.functionName;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAsyncInvokeConfigs',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/async-invoke-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all asynchronous configurations of a function.
 *
 * @param request ListAsyncInvokeConfigsRequest
 * @return ListAsyncInvokeConfigsResponse
 */
async function listAsyncInvokeConfigs(request: ListAsyncInvokeConfigsRequest): ListAsyncInvokeConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAsyncInvokeConfigsWithOptions(request, headers, runtime);
}

model ListAsyncTasksRequest {
  includePayload?: boolean(name='includePayload', description='Specifies whether to return input parameters of the asynchronous tasks. Valid values:

*   true: returns the `invocationPayload` parameter in the response.
*   false: does not return the `invocationPayload` parameter in the response.

>  The `invocationPayload` parameter indicates the input parameters of an asynchronous task.', example='true'),
  limit?: int32(name='limit', description='The number of asynchronous tasks to return. The default value is 20. Valid values: [1,100].', example='10'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='MTIzNCNhYmM='),
  prefix?: string(name='prefix', description='The ID prefix of asynchronous tasks. If this parameter is specified, a list of asynchronous tasks whose IDs match the prefix is returned.', example='job-'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST'),
  sortOrderByTime?: string(name='sortOrderByTime', description='The order in which the returned asynchronous tasks are sorted.

*   asc: in ascending order.
*   desc: in descending order.', example='asc'),
  startedTimeBegin?: long(name='startedTimeBegin', description='The start time of the period during which the asynchronous tasks are initiated.', example='1640966400000'),
  startedTimeEnd?: long(name='startedTimeEnd', description='The end time of the period during which the asynchronous tasks are initiated.', example='1640966400000'),
  status?: string(name='status', description='The state of asynchronous tasks. The following items list the states of an asynchronous task:

*   Enqueued: The asynchronous invocation is enqueued and waiting to be executed.
*   Dequeued: The asynchronous invocation is dequeued and waiting to be triggered.
*   Running: The invocation is being executed.
*   Succeeded: The invocation is successful.
*   Failed: The invocation fails.
*   Stopped: The invocation is terminated.
*   Stopping: The invocation is being terminated.
*   Expired: The maximum validity period of messages is specified for asynchronous invocation. The invocation is discarded and not executed because the specified maximum validity period of messages expires.
*   Invalid: The invocation is invalid and not executed due to specific reasons. For example, the function is deleted.
*   Retrying: The asynchronous invocation is being retried due to an execution error.', example='Running'),
}

model ListAsyncTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAsyncTaskOutput  
}

/**
 * @summary Lists asynchronous tasks.
 *
 * @param request ListAsyncTasksRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAsyncTasksResponse
 */
async function listAsyncTasksWithOptions(functionName: string, request: ListAsyncTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAsyncTasksResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.includePayload)) {
    query['includePayload'] = request.includePayload;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }
  if (!Util.isUnset(request.sortOrderByTime)) {
    query['sortOrderByTime'] = request.sortOrderByTime;
  }
  if (!Util.isUnset(request.startedTimeBegin)) {
    query['startedTimeBegin'] = request.startedTimeBegin;
  }
  if (!Util.isUnset(request.startedTimeEnd)) {
    query['startedTimeEnd'] = request.startedTimeEnd;
  }
  if (!Util.isUnset(request.status)) {
    query['status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAsyncTasks',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Lists asynchronous tasks.
 *
 * @param request ListAsyncTasksRequest
 * @return ListAsyncTasksResponse
 */
async function listAsyncTasks(functionName: string, request: ListAsyncTasksRequest): ListAsyncTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAsyncTasksWithOptions(functionName, request, headers, runtime);
}

model ListConcurrencyConfigsRequest {
  functionName?: string(name='functionName', description='The function name. If you leave this parameter empty, the concurrency configurations of all functions are returned.', example='my-func'),
  limit?: int32(name='limit', description='The maximum number of entries returned.', example='10'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM='),
}

model ListConcurrencyConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListConcurrencyConfigsOutput  
}

/**
 * @summary 列出函数并发度配置。
 *
 * @param request ListConcurrencyConfigsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListConcurrencyConfigsResponse
 */
async function listConcurrencyConfigsWithOptions(request: ListConcurrencyConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListConcurrencyConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.functionName)) {
    query['functionName'] = request.functionName;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConcurrencyConfigs',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/concurrency-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 列出函数并发度配置。
 *
 * @param request ListConcurrencyConfigsRequest
 * @return ListConcurrencyConfigsResponse
 */
async function listConcurrencyConfigs(request: ListConcurrencyConfigsRequest): ListConcurrencyConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConcurrencyConfigsWithOptions(request, headers, runtime);
}

model ListCustomDomainsRequest {
  limit?: int32(name='limit', description='The number of custom domain names returned.', example='10'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM='),
  prefix?: string(name='prefix', description='The domain name prefix.', example='foo'),
}

model ListCustomDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCustomDomainOutput  
}

/**
 * @summary Queries custom domain names.
 *
 * @param request ListCustomDomainsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCustomDomainsResponse
 */
async function listCustomDomainsWithOptions(request: ListCustomDomainsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCustomDomainsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCustomDomains',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries custom domain names.
 *
 * @param request ListCustomDomainsRequest
 * @return ListCustomDomainsResponse
 */
async function listCustomDomains(request: ListCustomDomainsRequest): ListCustomDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCustomDomainsWithOptions(request, headers, runtime);
}

model ListFunctionVersionsRequest {
  direction?: string(name='direction', description='The sorting mode of function versions. Valid values: BACKWARD and FORWARD.', example='BACKWARD'),
  limit?: int32(name='limit', description='The number of function versions that are returned.', example='10'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM='),
}

model ListFunctionVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVersionsOutput  
}

/**
 * @summary Queries versions of a function.
 *
 * @param request ListFunctionVersionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFunctionVersionsResponse
 */
async function listFunctionVersionsWithOptions(functionName: string, request: ListFunctionVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.direction)) {
    query['direction'] = request.direction;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctionVersions',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries versions of a function.
 *
 * @param request ListFunctionVersionsRequest
 * @return ListFunctionVersionsResponse
 */
async function listFunctionVersions(functionName: string, request: ListFunctionVersionsRequest): ListFunctionVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionVersionsWithOptions(functionName, request, headers, runtime);
}

model ListFunctionsRequest {
  description?: string(name='description', description='The description of the functions to retrieve.', example='test_description'),
  fcVersion?: string(name='fcVersion', description='The version of Function Compute to which the functions belong.

*   v3: Only lists functions of Function Compute 3.0.
*   v2: Only lists functions of Function Compute 2.0.

By default, this parameter is left empty and functions in both Function Compute 3.0 and Function Compute 2.0 are listed.', example='v3'),
  gpuType?: string(name='gpuType', description='The GPU type of the functions to retrieve.', example='fc.gpu.tesla.1'),
  limit?: int32(name='limit', description='The number of functions to return. The minimum value is 1 and the maximum value is 100.', example='10'),
  nextToken?: string(name='nextToken', description='The pagination token.', example='MTIzNCNhYmM='),
  prefix?: string(name='prefix', description='The prefix of the function name.', example='my-func'),
  runtime?: string(name='runtime', description='The runtime of the functions to retrieve.', example='python3.10'),
  tags?: [
    Tag
  ](name='tags', description='The tag of the functions to retrieve.'),
}

model ListFunctionsShrinkRequest {
  description?: string(name='description', description='The description of the functions to retrieve.', example='test_description'),
  fcVersion?: string(name='fcVersion', description='The version of Function Compute to which the functions belong.

*   v3: Only lists functions of Function Compute 3.0.
*   v2: Only lists functions of Function Compute 2.0.

By default, this parameter is left empty and functions in both Function Compute 3.0 and Function Compute 2.0 are listed.', example='v3'),
  gpuType?: string(name='gpuType', description='The GPU type of the functions to retrieve.', example='fc.gpu.tesla.1'),
  limit?: int32(name='limit', description='The number of functions to return. The minimum value is 1 and the maximum value is 100.', example='10'),
  nextToken?: string(name='nextToken', description='The pagination token.', example='MTIzNCNhYmM='),
  prefix?: string(name='prefix', description='The prefix of the function name.', example='my-func'),
  runtime?: string(name='runtime', description='The runtime of the functions to retrieve.', example='python3.10'),
  tagsShrink?: string(name='tags', description='The tag of the functions to retrieve.'),
}

model ListFunctionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionsOutput  
}

/**
 * @summary 列出函数。
 *
 * @description ListFunctions returns only a subset of a function\\"s attribute fields. To obtain the additional fields, which include state, stateReasonCode, stateReason, lastUpdateStatus, lastUpdateStatusReasonCode, and lastUpdateStatusReason, use [GetFunction](https://help.aliyun.com/document_detail/2618610.html).
 *
 * @param tmpReq ListFunctionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFunctionsResponse
 */
async function listFunctionsWithOptions(tmpReq: ListFunctionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionsResponse {
  Util.validateModel(tmpReq);
  var request = new ListFunctionsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'tags', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    query['description'] = request.description;
  }
  if (!Util.isUnset(request.fcVersion)) {
    query['fcVersion'] = request.fcVersion;
  }
  if (!Util.isUnset(request.gpuType)) {
    query['gpuType'] = request.gpuType;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.runtime)) {
    query['runtime'] = request.runtime;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['tags'] = request.tagsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctions',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 列出函数。
 *
 * @description ListFunctions returns only a subset of a function\\"s attribute fields. To obtain the additional fields, which include state, stateReasonCode, stateReason, lastUpdateStatus, lastUpdateStatusReasonCode, and lastUpdateStatusReason, use [GetFunction](https://help.aliyun.com/document_detail/2618610.html).
 *
 * @param request ListFunctionsRequest
 * @return ListFunctionsResponse
 */
async function listFunctions(request: ListFunctionsRequest): ListFunctionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionsWithOptions(request, headers, runtime);
}

model ListInstancesRequest {
  endTimeMs?: long(name='endTimeMs'),
  instanceIds?: [ string ](name='instanceIds'),
  instanceStatus?: [ string ](name='instanceStatus'),
  limit?: string(name='limit'),
  qualifier?: string(name='qualifier', description='The function version or alias.', example='LATEST'),
  startKey?: string(name='startKey'),
  startTimeMs?: long(name='startTimeMs'),
  withAllActive?: boolean(name='withAllActive', description='Specifies whether to list all instances. Valid values: true and false.', example='true'),
}

model ListInstancesShrinkRequest {
  endTimeMs?: long(name='endTimeMs'),
  instanceIdsShrink?: string(name='instanceIds'),
  instanceStatusShrink?: string(name='instanceStatus'),
  limit?: string(name='limit'),
  qualifier?: string(name='qualifier', description='The function version or alias.', example='LATEST'),
  startKey?: string(name='startKey'),
  startTimeMs?: long(name='startTimeMs'),
  withAllActive?: boolean(name='withAllActive', description='Specifies whether to list all instances. Valid values: true and false.', example='true'),
}

model ListInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstancesOutput  
}

/**
 * @summary Queries a list of function instances.
 *
 * @param tmpReq ListInstancesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstancesResponse
 */
async function listInstancesWithOptions(functionName: string, tmpReq: ListInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(tmpReq);
  var request = new ListInstancesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.instanceIds)) {
    request.instanceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.instanceIds, 'instanceIds', 'json');
  }
  if (!Util.isUnset(tmpReq.instanceStatus)) {
    request.instanceStatusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.instanceStatus, 'instanceStatus', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTimeMs)) {
    query['endTimeMs'] = request.endTimeMs;
  }
  if (!Util.isUnset(request.instanceIdsShrink)) {
    query['instanceIds'] = request.instanceIdsShrink;
  }
  if (!Util.isUnset(request.instanceStatusShrink)) {
    query['instanceStatus'] = request.instanceStatusShrink;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }
  if (!Util.isUnset(request.startKey)) {
    query['startKey'] = request.startKey;
  }
  if (!Util.isUnset(request.startTimeMs)) {
    query['startTimeMs'] = request.startTimeMs;
  }
  if (!Util.isUnset(request.withAllActive)) {
    query['withAllActive'] = request.withAllActive;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of function instances.
 *
 * @param request ListInstancesRequest
 * @return ListInstancesResponse
 */
async function listInstances(functionName: string, request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstancesWithOptions(functionName, request, headers, runtime);
}

model ListLayerVersionsRequest {
  limit?: int32(name='limit', description='The number of versions to be returned.', example='10'),
  startVersion?: string(name='startVersion', description='The initial version of the layer.', example='1'),
}

model ListLayerVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLayerVersionOutput  
}

/**
 * @summary Gets a list of layer versions.
 *
 * @param request ListLayerVersionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListLayerVersionsResponse
 */
async function listLayerVersionsWithOptions(layerName: string, request: ListLayerVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLayerVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.startVersion)) {
    query['startVersion'] = request.startVersion;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLayerVersions',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Gets a list of layer versions.
 *
 * @param request ListLayerVersionsRequest
 * @return ListLayerVersionsResponse
 */
async function listLayerVersions(layerName: string, request: ListLayerVersionsRequest): ListLayerVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLayerVersionsWithOptions(layerName, request, headers, runtime);
}

model ListLayersRequest {
  limit?: int32(name='limit', description='The number of layers that are returned', example='10'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM='),
  official?: string(name='official', description='Specifies whether the layer is official. Valid values: true and false.', example='true'),
  prefix?: string(name='prefix', description='The name prefix of the layer.', example='my-layer'),
  public?: string(name='public', description='Specifies whether the layer is public. Valid values: true and false.', example='true'),
}

model ListLayersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLayersOutput  
}

/**
 * @summary Gets a list of layers.
 *
 * @param request ListLayersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListLayersResponse
 */
async function listLayersWithOptions(request: ListLayersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLayersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.official)) {
    query['official'] = request.official;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.public)) {
    query['public'] = request.public;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLayers',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Gets a list of layers.
 *
 * @param request ListLayersRequest
 * @return ListLayersResponse
 */
async function listLayers(request: ListLayersRequest): ListLayersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLayersWithOptions(request, headers, runtime);
}

model ListProvisionConfigsRequest {
  functionName?: string(name='functionName', description='The name of the function. If this parameter is not specified, the provisioned configurations of all functions are listed.', example='my-func'),
  limit?: int32(name='limit', description='Number of provisioned configurations to return.', example='10'),
  nextToken?: string(name='nextToken', description='A pagination token.', example='MTIzNCNhYmM='),
}

model ListProvisionConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProvisionConfigsOutput  
}

/**
 * @summary Queries a list of provisioned configurations.
 *
 * @param request ListProvisionConfigsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListProvisionConfigsResponse
 */
async function listProvisionConfigsWithOptions(request: ListProvisionConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProvisionConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.functionName)) {
    query['functionName'] = request.functionName;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProvisionConfigs',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/provision-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of provisioned configurations.
 *
 * @param request ListProvisionConfigsRequest
 * @return ListProvisionConfigsResponse
 */
async function listProvisionConfigs(request: ListProvisionConfigsRequest): ListProvisionConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProvisionConfigsWithOptions(request, headers, runtime);
}

model ListTagResourcesRequest {
  limit?: int32(name='Limit', description='The number of resources to return.', example='10'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM='),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs.'),
  resourceType?: string(name='ResourceType', description='The type of the resource.

This parameter is required.', example='ALIYUN::FC:FUNCTION'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.

The tag key can be up to 64 characters in length, and cannot contain `http://` or `https://`. The tag key cannot start with `aliyun` or `acs:`.', example='k1'),
      value?: string(name='Value', description='The tag value.

The tag value can be up to 128 characters in length and can be an empty string.', example='v1'),
    }
  ](name='Tag', description='The tags.

You can query up to 20 tags at a time.'),
}

model ListTagResourcesShrinkRequest {
  limit?: int32(name='Limit', description='The number of resources to return.', example='10'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM='),
  resourceIdShrink?: string(name='ResourceId', description='The resource IDs.'),
  resourceType?: string(name='ResourceType', description='The type of the resource.

This parameter is required.', example='ALIYUN::FC:FUNCTION'),
  tagShrink?: string(name='Tag', description='The tags.

You can query up to 20 tags at a time.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesOutput  
}

/**
 * @summary Lists all tagged resources.
 *
 * @param tmpReq ListTagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
async function listTagResourcesWithOptions(tmpReq: ListTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceId)) {
    request.resourceIdShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceId, 'ResourceId', 'json');
  }
  if (!Util.isUnset(tmpReq.tag)) {
    request.tagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tag, 'Tag', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceIdShrink)) {
    query['ResourceId'] = request.resourceIdShrink;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagShrink)) {
    query['Tag'] = request.tagShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/tags-v2`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Lists all tagged resources.
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

model ListTriggersRequest {
  limit?: int32(name='limit', description='The number of triggers returned.', example='10'),
  nextToken?: string(name='nextToken', description='The token for the next page.', example='MTIzNCNhYmM='),
  prefix?: string(name='prefix', description='The trigger name prefix.', example='my-trigger'),
}

model ListTriggersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTriggersOutput  
}

/**
 * @summary Queries the triggers of a function.
 *
 * @param request ListTriggersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTriggersResponse
 */
async function listTriggersWithOptions(functionName: string, request: ListTriggersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTriggersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTriggers',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the triggers of a function.
 *
 * @param request ListTriggersRequest
 * @return ListTriggersResponse
 */
async function listTriggers(functionName: string, request: ListTriggersRequest): ListTriggersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTriggersWithOptions(functionName, request, headers, runtime);
}

model ListVpcBindingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVpcBindingsOutput  
}

/**
 * @summary Queries a list of existing VPC connections.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVpcBindingsResponse
 */
async function listVpcBindingsWithOptions(functionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListVpcBindingsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListVpcBindings',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/vpc-bindings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of existing VPC connections.
 *
 * @return ListVpcBindingsResponse
 */
async function listVpcBindings(functionName: string): ListVpcBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVpcBindingsWithOptions(functionName, headers, runtime);
}

model PublishFunctionVersionRequest {
  body?: PublishVersionInput(name='body', description='The information about the function version.

This parameter is required.'),
}

model PublishFunctionVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Version  
}

/**
 * @summary Publishes a function version.
 *
 * @param request PublishFunctionVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishFunctionVersionResponse
 */
async function publishFunctionVersionWithOptions(functionName: string, request: PublishFunctionVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PublishFunctionVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PublishFunctionVersion',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Publishes a function version.
 *
 * @param request PublishFunctionVersionRequest
 * @return PublishFunctionVersionResponse
 */
async function publishFunctionVersion(functionName: string, request: PublishFunctionVersionRequest): PublishFunctionVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return publishFunctionVersionWithOptions(functionName, request, headers, runtime);
}

model PutAsyncInvokeConfigRequest {
  body?: PutAsyncInvokeConfigInput(name='body', description='The configurations of asynchronous function invocations.

This parameter is required.'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST'),
}

model PutAsyncInvokeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AsyncConfig  
}

/**
 * @summary Creates or modifies an asynchronous invocation configuration for a function.
 *
 * @param request PutAsyncInvokeConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutAsyncInvokeConfigResponse
 */
async function putAsyncInvokeConfigWithOptions(functionName: string, request: PutAsyncInvokeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PutAsyncInvokeConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-invoke-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates or modifies an asynchronous invocation configuration for a function.
 *
 * @param request PutAsyncInvokeConfigRequest
 * @return PutAsyncInvokeConfigResponse
 */
async function putAsyncInvokeConfig(functionName: string, request: PutAsyncInvokeConfigRequest): PutAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putAsyncInvokeConfigWithOptions(functionName, request, headers, runtime);
}

model PutConcurrencyConfigRequest {
  body?: PutConcurrencyInput(name='body', description='The concurrency configurations.

This parameter is required.'),
}

model PutConcurrencyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConcurrencyConfig  
}

/**
 * @summary Configures concurrency of a function.
 *
 * @param request PutConcurrencyConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutConcurrencyConfigResponse
 */
async function putConcurrencyConfigWithOptions(functionName: string, request: PutConcurrencyConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutConcurrencyConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PutConcurrencyConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/concurrency`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Configures concurrency of a function.
 *
 * @param request PutConcurrencyConfigRequest
 * @return PutConcurrencyConfigResponse
 */
async function putConcurrencyConfig(functionName: string, request: PutConcurrencyConfigRequest): PutConcurrencyConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putConcurrencyConfigWithOptions(functionName, request, headers, runtime);
}

model PutLayerACLRequest {
  acl?: string(name='acl', description='Specify the access permission of the layer. A value of 1 indicates public and a value of 0 indicates private. The default value is 0.', example='1'),
  public?: string(name='public', description='Specify whether the layer is a public layer. Valid values: true and false.', example='true', deprecated=true),
}

model PutLayerACLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Modifies permissions of a layer.
 *
 * @param request PutLayerACLRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutLayerACLResponse
 */
async function putLayerACLWithOptions(layerName: string, request: PutLayerACLRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutLayerACLResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.acl)) {
    query['acl'] = request.acl;
  }
  if (!Util.isUnset(request.public)) {
    query['public'] = request.public;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutLayerACL',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/layers/${OpenApiUtil.getEncodeParam(layerName)}/acl`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies permissions of a layer.
 *
 * @param request PutLayerACLRequest
 * @return PutLayerACLResponse
 */
async function putLayerACL(layerName: string, request: PutLayerACLRequest): PutLayerACLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putLayerACLWithOptions(layerName, request, headers, runtime);
}

model PutProvisionConfigRequest {
  body?: PutProvisionConfigInput(name='body', description='The provisioned configuration information.

This parameter is required.'),
  qualifier?: string(name='qualifier', description='The function alias.', example='LATEST'),
}

model PutProvisionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ProvisionConfig  
}

/**
 * @summary Creates provisioned configurations.
 *
 * @param request PutProvisionConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutProvisionConfigResponse
 */
async function putProvisionConfigWithOptions(functionName: string, request: PutProvisionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutProvisionConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PutProvisionConfig',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/provision-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates provisioned configurations.
 *
 * @param request PutProvisionConfigRequest
 * @return PutProvisionConfigResponse
 */
async function putProvisionConfig(functionName: string, request: PutProvisionConfigRequest): PutProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putProvisionConfigWithOptions(functionName, request, headers, runtime);
}

model StopAsyncTaskRequest {
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST'),
}

model StopAsyncTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Stops an asynchronous task.
 *
 * @param request StopAsyncTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopAsyncTaskResponse
 */
async function stopAsyncTaskWithOptions(functionName: string, taskId: string, request: StopAsyncTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopAsyncTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopAsyncTask',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-tasks/${OpenApiUtil.getEncodeParam(taskId)}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Stops an asynchronous task.
 *
 * @param request StopAsyncTaskRequest
 * @return StopAsyncTaskResponse
 */
async function stopAsyncTask(functionName: string, taskId: string, request: StopAsyncTaskRequest): StopAsyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopAsyncTaskWithOptions(functionName, taskId, request, headers, runtime);
}

model TagResourcesRequest {
  body?: TagResourcesInput(name='body', description='The configuration of the resource tag.

This parameter is required.'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Adds tags to a resource.
 *
 * @description Tags are used to identify resources. Tags allow you to categorize, search for, and aggregate resources that have the same characteristics from different dimensions. This facilitates resource management. For more information, see [Tag overview](https://help.aliyun.com/document_detail/156983.html).
 *
 * @param request TagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
async function tagResourcesWithOptions(request: TagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/tags-v2`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds tags to a resource.
 *
 * @description Tags are used to identify resources. Tags allow you to categorize, search for, and aggregate resources that have the same characteristics from different dimensions. This facilitates resource management. For more information, see [Tag overview](https://help.aliyun.com/document_detail/156983.html).
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(request, headers, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to delete all tags.', example='true'),
  resourceId?: [ string ](name='ResourceId', description='The resource identifiers.

This parameter is required.'),
  resourceType?: string(name='ResourceType', description='The resource type.

This parameter is required.', example='function'),
  tagKey?: [ string ](name='TagKey', description='The tag to remove. You can specify a maximum of 50 tags.'),
}

model UntagResourcesShrinkRequest {
  all?: boolean(name='All', description='Specifies whether to delete all tags.', example='true'),
  resourceIdShrink?: string(name='ResourceId', description='The resource identifiers.

This parameter is required.'),
  resourceType?: string(name='ResourceType', description='The resource type.

This parameter is required.', example='function'),
  tagKeyShrink?: string(name='TagKey', description='The tag to remove. You can specify a maximum of 50 tags.'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Removes tags from a resource.
 *
 * @param tmpReq UntagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesResponse
 */
async function untagResourcesWithOptions(tmpReq: UntagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new UntagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceId)) {
    request.resourceIdShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceId, 'ResourceId', 'json');
  }
  if (!Util.isUnset(tmpReq.tagKey)) {
    request.tagKeyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tagKey, 'TagKey', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.resourceIdShrink)) {
    query['ResourceId'] = request.resourceIdShrink;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKeyShrink)) {
    query['TagKey'] = request.tagKeyShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/tags-v2`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Removes tags from a resource.
 *
 * @param request UntagResourcesRequest
 * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourcesWithOptions(request, headers, runtime);
}

model UpdateAliasRequest {
  body?: UpdateAliasInput(name='body', description='The alias information to be updated.

This parameter is required.'),
}

model UpdateAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Alias  
}

/**
 * @summary Updates an alias.
 *
 * @param request UpdateAliasRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAliasResponse
 */
async function updateAliasWithOptions(functionName: string, aliasName: string, request: UpdateAliasRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAliasResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlias',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/aliases/${OpenApiUtil.getEncodeParam(aliasName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates an alias.
 *
 * @param request UpdateAliasRequest
 * @return UpdateAliasResponse
 */
async function updateAlias(functionName: string, aliasName: string, request: UpdateAliasRequest): UpdateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAliasWithOptions(functionName, aliasName, request, headers, runtime);
}

model UpdateCustomDomainRequest {
  body?: UpdateCustomDomainInput(name='body', description='The information about the custom domain name.

This parameter is required.'),
}

model UpdateCustomDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CustomDomain  
}

/**
 * @summary Update a custom domain name.
 *
 * @param request UpdateCustomDomainRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCustomDomainResponse
 */
async function updateCustomDomainWithOptions(domainName: string, request: UpdateCustomDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCustomDomainResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCustomDomain',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/custom-domains/${OpenApiUtil.getEncodeParam(domainName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update a custom domain name.
 *
 * @param request UpdateCustomDomainRequest
 * @return UpdateCustomDomainResponse
 */
async function updateCustomDomain(domainName: string, request: UpdateCustomDomainRequest): UpdateCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCustomDomainWithOptions(domainName, request, headers, runtime);
}

model UpdateFunctionRequest {
  body?: UpdateFunctionInput(name='body', description='The function information

This parameter is required.'),
}

model UpdateFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Function  
}

/**
 * @summary Updates the information about a function.
 *
 * @param request UpdateFunctionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFunctionResponse
 */
async function updateFunctionWithOptions(functionName: string, request: UpdateFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFunctionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFunction',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the information about a function.
 *
 * @param request UpdateFunctionRequest
 * @return UpdateFunctionResponse
 */
async function updateFunction(functionName: string, request: UpdateFunctionRequest): UpdateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFunctionWithOptions(functionName, request, headers, runtime);
}

model UpdateTriggerRequest {
  body?: UpdateTriggerInput(name='body', description='The trigger configurations.

This parameter is required.'),
}

model UpdateTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Trigger  
}

/**
 * @summary Modifies a trigger.
 *
 * @param request UpdateTriggerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTriggerResponse
 */
async function updateTriggerWithOptions(functionName: string, triggerName: string, request: UpdateTriggerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTriggerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTrigger',
    version = '2023-03-30',
    protocol = 'HTTPS',
    pathname = `/2023-03-30/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers/${OpenApiUtil.getEncodeParam(triggerName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a trigger.
 *
 * @param request UpdateTriggerRequest
 * @return UpdateTriggerResponse
 */
async function updateTrigger(functionName: string, triggerName: string, request: UpdateTriggerRequest): UpdateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTriggerWithOptions(functionName, triggerName, request, headers, runtime);
}

