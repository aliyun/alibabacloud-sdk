/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'FC';
  @version = '2023-03-30';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AccelerationInfo {
  status?: string(name='status'),
}

model Alias {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName?: string(name='aliasName'),
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  versionId?: string(name='versionId'),
}

model AsyncConfig {
  createdTime?: string(name='createdTime'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  functionName?: string(name='functionName'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts'),
  qualifier?: string(name='qualifier'),
}

model CertConfig {
  certName?: string(name='certName', minLength=1, maxLength=128),
  certificate?: string(name='certificate', maxLength=20480),
  privateKey?: string(name='privateKey', maxLength=4096),
}

model ConcurrencyConfig {
  functionArn?: string(name='functionArn'),
  reservedConcurrency?: long(name='reservedConcurrency'),
}

model CreateAliasInput {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName?: string(name='aliasName', minLength=1, maxLength=128),
  description?: string(name='description', maxLength=256),
  versionId?: string(name='versionId', minLength=1, maxLength=10),
}

model CreateCustomDomainInput {
  certConfig?: CertConfig(name='certConfig'),
  domainName?: string(name='domainName', minLength=1, maxLength=256),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model CreateFunctionInput {
  code?: InputCodeLocation(name='code'),
  cpu?: float(name='cpu', minimum=0.05),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description', maxLength=256),
  diskSize?: int32(name='diskSize', minimum=512),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionName?: string(name='functionName', minLength=1, maxLength=128),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler', minLength=1, maxLength=128),
  instanceConcurrency?: int32(name='instanceConcurrency', minimum=1, maximum=100),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess'),
  layers?: [ string ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize', minimum=128),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role', maxLength=300),
  runtime?: string(name='runtime'),
  timeout?: int32(name='timeout', minimum=1),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcBinding?: VPCBinding(name='vpcBinding'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model CreateLayerVersionInput {
  code?: InputCodeLocation(name='code'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  description?: string(name='description', maxLength=256),
  license?: string(name='license', maxLength=20480),
}

model CreateTriggerInput {
  description?: string(name='description', maxLength=256),
  invocationRole?: string(name='invocationRole', maxLength=300),
  qualifier?: string(name='qualifier'),
  sourceArn?: string(name='sourceArn', minLength=1, maxLength=300),
  triggerConfig: string(name='triggerConfig'),
  triggerName?: string(name='triggerName', minLength=1, maxLength=128),
  triggerType?: string(name='triggerType'),
}

model CustomContainerConfig {
  accelerationInfo?: AccelerationInfo(name='accelerationInfo'),
  accelerationType?: string(name='accelerationType'),
  acrInstanceID?: string(name='acrInstanceID'),
  command?: [ string ](name='command'),
  entrypoint?: [ string ](name='entrypoint'),
  healthCheckConfig?: CustomHealthCheckConfig(name='healthCheckConfig'),
  image?: string(name='image'),
  port?: int32(name='port'),
}

model CustomDNS {
  dnsOptions?: [
    DNSOption
  ](name='dnsOptions'),
  nameServers?: [ string ](name='nameServers'),
  searches?: [ string ](name='searches'),
}

model CustomDomain {
  accountId?: string(name='accountId'),
  apiVersion?: string(name='apiVersion'),
  certConfig?: CertConfig(name='certConfig'),
  createdTime?: string(name='createdTime'),
  domainName?: string(name='domainName'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  subdomainCount?: string(name='subdomainCount'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model CustomHealthCheckConfig {
  failureThreshold?: int32(name='failureThreshold'),
  httpGetUrl?: string(name='httpGetUrl'),
  initialDelaySeconds?: int32(name='initialDelaySeconds'),
  periodSeconds?: int32(name='periodSeconds'),
  successThreshold?: int32(name='successThreshold'),
  timeoutSeconds?: int32(name='timeoutSeconds'),
}

model CustomRuntimeConfig {
  args?: [ string ](name='args'),
  command?: [ string ](name='command'),
  healthCheckConfig?: CustomHealthCheckConfig(name='healthCheckConfig'),
  port?: int32(name='port'),
}

model DNSOption {
  name?: string(name='name', maxLength=256),
  value?: string(name='value', maxLength=256),
}

model Destination {
  destination?: string(name='destination'),
}

model DestinationConfig {
  onFailure?: Destination(name='onFailure'),
  onSuccess?: Destination(name='onSuccess'),
}

model EqualRule {
  match?: string(name='match', maxLength=256),
  replacement?: string(name='replacement', maxLength=256),
}

model Error {
  code?: string(name='code'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
}

model Function {
  codeChecksum?: string(name='codeChecksum'),
  codeSize?: long(name='codeSize'),
  cpu?: float(name='cpu'),
  createdTime?: string(name='createdTime'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description'),
  diskSize?: int32(name='diskSize'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionArn?: string(name='functionArn'),
  functionId?: string(name='functionId'),
  functionName?: string(name='functionName'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  layers?: [
    FunctionLayer
  ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role'),
  runtime?: string(name='runtime'),
  timeout?: int32(name='timeout'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcBinding?: VPCBinding(name='vpcBinding'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model FunctionLayer {
  arn?: string(name='arn'),
  size?: long(name='size'),
}

model GPUConfig {
  gpuMemorySize?: int32(name='gpuMemorySize', minimum=128),
  gpuType?: string(name='gpuType', maxLength=128),
}

model GetResourceTagsOutput {
  resourceArn?: string(name='resourceArn'),
  tags?: map[string]string(name='tags'),
}

model HTTPTrigger {
  urlInternet?: string(name='urlInternet'),
  urlIntranet?: string(name='urlIntranet'),
}

model HealthCheckConfig {
  failureThreshold?: int32(name='failureThreshold'),
  httpGetUrl?: string(name='httpGetUrl'),
  initialDelaySeconds?: int32(name='initialDelaySeconds'),
  periodSeconds?: int32(name='periodSeconds'),
  successThreshold?: int32(name='successThreshold'),
  timeoutSeconds?: int32(name='timeoutSeconds'),
}

model InnerRewriteConfig {
  regexRules?: [
    RewriteRegexRule
  ](name='regexRules'),
}

model InputCodeLocation {
  checksum?: string(name='checksum'),
  ossBucketName?: string(name='ossBucketName', minLength=3, maxLength=63),
  ossObjectName?: string(name='ossObjectName'),
  zipFile?: string(name='zipFile'),
}

model InstanceInfo {
  instanceId?: string(name='instanceId'),
  versionId?: string(name='versionId'),
}

model InstanceLifecycleConfig {
  initializer?: LifecycleHook(name='initializer'),
  preStop?: LifecycleHook(name='preStop'),
}

model Layer {
  acl?: string(name='acl'),
  code?: OutputCodeLocation(name='code'),
  codeChecksum?: string(name='codeChecksum'),
  codeSize?: long(name='codeSize'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  createTime?: string(name='createTime'),
  description?: string(name='description', maxLength=256),
  layerName?: string(name='layerName', minLength=1, maxLength=128),
  layerVersionArn?: string(name='layerVersionArn'),
  license?: string(name='license'),
  version?: int32(name='version'),
}

model LifecycleHook {
  handler?: string(name='handler', maxLength=128),
  timeout?: int32(name='timeout', minimum=1),
}

model ListAliasesOutput {
  aliases?: [
    Alias
  ](name='aliases'),
  nextToken?: string(name='nextToken'),
}

model ListAsyncInvokeConfigOutput {
  configs?: [
    AsyncConfig
  ](name='configs'),
  nextToken?: string(name='nextToken'),
}

model ListConcurrencyConfigsOutput {
  configs?: [
    ConcurrencyConfig
  ](name='configs'),
  nextToken?: string(name='nextToken'),
}

model ListCustomDomainOutput {
  customDomains?: [
    CustomDomain
  ](name='customDomains'),
  nextToken?: string(name='nextToken'),
}

model ListFunctionsOutput {
  functions?: [
    Function
  ](name='functions'),
  nextToken?: string(name='nextToken'),
}

model ListInstancesOutput {
  instances?: [
    InstanceInfo
  ](name='instances'),
}

model ListLayerVersionOutput {
  layers?: [
    Layer
  ](name='layers'),
  nextVersion?: int32(name='nextVersion'),
}

model ListLayersOutput {
  layers?: [
    Layer
  ](name='layers'),
  nextToken?: string(name='nextToken'),
}

model ListProvisionConfigsOutput {
  nextToken?: string(name='nextToken'),
  provisionConfigs?: [
    ProvisionConfig
  ](name='provisionConfigs'),
}

model ListTaggedResourcesOutput {
  nextToken?: string(name='nextToken'),
  resources?: [
    Resource
  ](name='resources'),
}

model ListTriggersOutput {
  nextToken?: string(name='nextToken'),
  triggers?: [
    Trigger
  ](name='triggers'),
}

model ListVersionsOutput {
  direction?: string(name='direction'),
  nextToken?: string(name='nextToken'),
  versions?: [
    Version
  ](name='versions'),
}

model LogConfig {
  enableInstanceMetrics?: boolean(name='enableInstanceMetrics'),
  enableRequestMetrics?: boolean(name='enableRequestMetrics'),
  logBeginRule?: string(name='logBeginRule'),
  logstore?: string(name='logstore', maxLength=63),
  project?: string(name='project', maxLength=63),
}

model NASConfig {
  groupId?: int32(name='groupId', minimum=-1, maximum=65534),
  mountPoints?: [
    NASMountConfig
  ](name='mountPoints'),
  userId?: int32(name='userId', minimum=-1, maximum=65534),
}

model NASMountConfig {
  enableTLS?: boolean(name='enableTLS'),
  mountDir?: string(name='mountDir', maxLength=64),
  serverAddr?: string(name='serverAddr', maxLength=128),
}

model OSSMountConfig {
  mountPoints?: [
    OSSMountPoint
  ](name='mountPoints'),
}

model OSSMountPoint {
  bucketName?: string(name='bucketName', minLength=3, maxLength=64),
  bucketPath?: string(name='bucketPath', maxLength=128),
  endpoint?: string(name='endpoint', maxLength=128),
  mountDir?: string(name='mountDir', minLength=2, maxLength=64),
  readOnly?: boolean(name='readOnly'),
}

model OutputCodeLocation {
  location?: string(name='location'),
  repositoryType?: string(name='repositoryType'),
}

model OutputFuncCode {
  checksum?: string(name='checksum'),
  url?: string(name='url'),
}

model PathConfig {
  accountId?: string(name='accountId'),
  functionName?: string(name='functionName'),
  innerRewriteConfig?: InnerRewriteConfig(name='innerRewriteConfig'),
  methods?: [ string ](name='methods'),
  path?: string(name='path', maxLength=2048),
  qualifier?: string(name='qualifier'),
  rewriteConfig?: RewriteConfig(name='rewriteConfig'),
  serviceName?: string(name='serviceName'),
}

model PolicyItem {
  key?: string(name='key'),
  operator?: string(name='operator'),
  type?: string(name='type'),
  value?: string(name='value'),
}

model ProvisionConfig {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU'),
  current?: long(name='current'),
  currentError?: string(name='currentError'),
  functionArn?: string(name='functionArn'),
  scheduledActions?: [
    ScheduledAction
  ](name='scheduledActions'),
  target?: long(name='target'),
  targetTrackingPolicies?: [
    TargetTrackingPolicy
  ](name='targetTrackingPolicies'),
}

model PublishVersionInput {
  description?: string(name='description', maxLength=256),
}

model PutAsyncInvokeConfigInput {
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', minimum=1, maximum=2592000),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', minimum=0, maximum=8),
}

model PutConcurrencyInput {
  reservedConcurrency?: long(name='reservedConcurrency', minimum=-1, maximum=5000),
}

model PutProvisionConfigInput {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU'),
  scheduledActions?: [
    ScheduledAction
  ](name='scheduledActions'),
  target?: long(name='target', minimum=0, maximum=100000),
  targetTrackingPolicies?: [
    TargetTrackingPolicy
  ](name='targetTrackingPolicies'),
}

model RegexRule {
  match?: string(name='match', maxLength=256),
  replacement?: string(name='replacement', maxLength=256),
}

model Resource {
  resourceArn?: string(name='resourceArn'),
  tags?: map[string]string(name='tags'),
}

model RewriteConfig {
  equalRules?: [
    EqualRule
  ](name='equalRules'),
  regexRules?: [
    RegexRule
  ](name='regexRules'),
  wildcardRules?: [
    WildcardRule
  ](name='wildcardRules'),
}

model RewriteRegexRule {
  regexStr?: string(name='regexStr'),
  replacement?: string(name='replacement'),
}

model RouteConfig {
  routes?: [
    PathConfig
  ](name='routes'),
}

model RoutePolicy {
  condition?: string(name='condition'),
  policyItems?: [
    PolicyItem
  ](name='policyItems'),
}

model ScheduledAction {
  endTime?: string(name='endTime'),
  name?: string(name='name'),
  scheduleExpression?: string(name='scheduleExpression'),
  startTime?: string(name='startTime'),
  target?: long(name='target', minimum=0, maximum=100000),
}

model TLSConfig {
  cipherSuites?: [ string ](name='cipherSuites'),
  maxVersion?: string(name='maxVersion'),
  minVersion?: string(name='minVersion'),
}

model Tag {
  key?: string(name='key'),
  value?: string(name='value'),
}

model TagResourceInput {
  resourceArn?: string(name='resourceArn', minLength=1),
  resourceType?: string(name='resourceType'),
  tags?: map[string]string(name='tags'),
}

model TargetTrackingPolicy {
  endTime?: string(name='endTime'),
  maxCapacity?: long(name='maxCapacity', minimum=0, maximum=100000),
  metricTarget?: float(name='metricTarget'),
  metricType?: string(name='metricType'),
  minCapacity?: long(name='minCapacity', minimum=0, maximum=100000),
  name?: string(name='name'),
  startTime?: string(name='startTime'),
}

model TracingConfig {
  params?: map[string]string(name='params'),
  type?: string(name='type'),
}

model Trigger {
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  httpTrigger?: HTTPTrigger(name='httpTrigger'),
  invocationRole?: string(name='invocationRole'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  qualifier?: string(name='qualifier'),
  sourceArn?: string(name='sourceArn'),
  status?: string(name='status'),
  targetArn?: string(name='targetArn'),
  triggerConfig?: string(name='triggerConfig'),
  triggerId?: string(name='triggerId'),
  triggerName?: string(name='triggerName'),
  triggerType?: string(name='triggerType'),
}

model UpdateAliasInput {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  description?: string(name='description', maxLength=256),
  versionId?: string(name='versionId', minLength=1, maxLength=10),
}

model UpdateCustomDomainInput {
  certConfig?: CertConfig(name='certConfig'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model UpdateFunctionInput {
  code?: InputCodeLocation(name='code'),
  cpu?: float(name='cpu', minimum=0.05),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description', maxLength=256),
  diskSize?: int32(name='diskSize', minimum=512),
  environmentVariables?: map[string]string(name='environmentVariables'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler', minLength=1, maxLength=128),
  instanceConcurrency?: int32(name='instanceConcurrency', minimum=1, maximum=100),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess'),
  layers?: [ string ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize', minimum=128),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role', maxLength=300),
  runtime?: string(name='runtime'),
  timeout?: int32(name='timeout', minimum=1),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcBinding?: VPCBinding(name='vpcBinding'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model UpdateTriggerInput {
  description?: string(name='description', maxLength=256),
  invocationRole?: string(name='invocationRole', maxLength=300),
  qualifier?: string(name='qualifier'),
  triggerConfig?: string(name='triggerConfig'),
}

model VPCBinding {
  vpcIds?: [ string ](name='vpcIds'),
}

model VPCConfig {
  securityGroupId?: string(name='securityGroupId', maxLength=50),
  vSwitchIds?: [ string ](name='vSwitchIds'),
  vpcId?: string(name='vpcId', maxLength=50),
}

model Version {
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  functionVersionArn?: string(name='functionVersionArn'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  versionId?: string(name='versionId'),
}

model WAFConfig {
  enableWAF?: boolean(name='enableWAF'),
}

model WildcardRule {
  match?: string(name='match', maxLength=256),
  replacement?: string(name='replacement', maxLength=256),
}

model CreateAliasRequest {
  functionName: string(name='functionName', position='Path'),
  body: CreateAliasInput(name='body', position='Body'),
}

model CreateAliasResponse = {
  headers: map[string]string(name='headers'),
  body: Alias  
}

/**
  * create function version
  *
 */
async function createAlias(request: CreateAliasRequest): CreateAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateAlias', 'POST', '/2023-03-30/functions/{functionName}/aliases', 'json', false, 'json', request);
}

model CreateCustomDomainRequest {
  body: CreateCustomDomainInput(name='body', position='Body'),
}

model CreateCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  body: CustomDomain  
}

/**
  * Create custom domain.
  *
 */
async function createCustomDomain(request: CreateCustomDomainRequest): CreateCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateCustomDomain', 'POST', '/2023-03-30/custom-domains', 'json', false, 'json', request);
}

model CreateFunctionRequest {
  body: CreateFunctionInput(name='body', position='Body'),
}

model CreateFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: Function  
}

/**
  * Create function
  *
 */
async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateFunction', 'POST', '/2023-03-30/functions', 'json', false, 'json', request);
}

model CreateLayerVersionRequest {
  layerName: string(name='layerName', position='Path'),
  body: CreateLayerVersionInput(name='body', position='Body'),
}

model CreateLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  body: Layer  
}

/**
  * Create layer version
  *
 */
async function createLayerVersion(request: CreateLayerVersionRequest): CreateLayerVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateLayerVersion', 'POST', '/2023-03-30/layers/{layerName}/versions', 'json', false, 'json', request);
}

model CreateTriggerRequest {
  functionName: string(name='functionName', position='Path'),
  body: CreateTriggerInput(name='body', position='Body'),
}

model CreateTriggerResponse = {
  headers: map[string]string(name='headers'),
  body: Trigger  
}

/**
  * Create trigger.
  *
 */
async function createTrigger(request: CreateTriggerRequest): CreateTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateTrigger', 'POST', '/2023-03-30/functions/{functionName}/triggers', 'json', false, 'json', request);
}

model DeleteAliasRequest {
  functionName: string(name='functionName', position='Path'),
  aliasName: string(name='aliasName', position='Path'),
}

model DeleteAliasResponse = {
  headers: map[string]string(name='headers'),
}

/**
  * Delete function alias
  *
 */
async function deleteAlias(request: DeleteAliasRequest): DeleteAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteAlias', 'DELETE', '/2023-03-30/functions/{functionName}/aliases/{aliasName}', 'none', false, 'json', request);
}

model DeleteAsyncInvokeConfigRequest {
  functionName: string(name='functionName', position='Path'),
  qualifier?: string(name='qualifier', position='Query'),
}

model DeleteAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
}

/**
  * Delete function async invoke config
  *
 */
async function deleteAsyncInvokeConfig(request: DeleteAsyncInvokeConfigRequest): DeleteAsyncInvokeConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteAsyncInvokeConfig', 'DELETE', '/2023-03-30/functions/{functionName}/async-invoke-config', 'none', false, 'json', request);
}

model DeleteConcurrencyConfigRequest {
  functionName: string(name='functionName', position='Path'),
}

model DeleteConcurrencyConfigResponse = {
  headers: map[string]string(name='headers'),
}

/**
  * deletes the concurrency config for a function
  *
 */
async function deleteConcurrencyConfig(request: DeleteConcurrencyConfigRequest): DeleteConcurrencyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteConcurrencyConfig', 'DELETE', '/2023-03-30/functions/{functionName}/concurrency', 'none', false, 'json', request);
}

model DeleteCustomDomainRequest {
  domainName: string(name='domainName', position='Path'),
}

model DeleteCustomDomainResponse = {
  headers: map[string]string(name='headers'),
}

/**
  * Delete custom domain.
  *
 */
async function deleteCustomDomain(request: DeleteCustomDomainRequest): DeleteCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteCustomDomain', 'DELETE', '/2023-03-30/custom-domains/{domainName}', 'none', false, 'json', request);
}

model DeleteFunctionRequest {
  functionName: string(name='functionName', position='Path'),
}

model DeleteFunctionResponse = {
  headers: map[string]string(name='headers'),
}

/**
  * Delete function
  *
 */
async function deleteFunction(request: DeleteFunctionRequest): DeleteFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteFunction', 'DELETE', '/2023-03-30/functions/{functionName}', 'none', false, 'json', request);
}

model DeleteFunctionVersionRequest {
  functionName: string(name='functionName', position='Path'),
  versionID: int32(name='versionID', position='Path'),
}

model DeleteFunctionVersionResponse = {
  headers: map[string]string(name='headers'),
}

/**
  * Delete function version
  *
 */
async function deleteFunctionVersion(request: DeleteFunctionVersionRequest): DeleteFunctionVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteFunctionVersion', 'DELETE', '/2023-03-30/functions/{functionName}/versions/{versionID}', 'none', false, 'json', request);
}

model DeleteLayerVersionRequest {
  layerName: string(name='layerName', position='Path'),
  version: int32(name='version', position='Path'),
}

model DeleteLayerVersionResponse = {
  headers: map[string]string(name='headers'),
}

/**
  * Delete layer version
  *
 */
async function deleteLayerVersion(request: DeleteLayerVersionRequest): DeleteLayerVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteLayerVersion', 'DELETE', '/2023-03-30/layers/{layerName}/versions/{version}', 'none', false, 'json', request);
}

model DeleteProvisionConfigRequest {
  functionName: string(name='functionName', position='Path'),
  qualifier?: string(name='qualifier', position='Query'),
}

model DeleteProvisionConfigResponse = {
  headers: map[string]string(name='headers'),
}

/**
  * Delete provision config.
  *
 */
async function deleteProvisionConfig(request: DeleteProvisionConfigRequest): DeleteProvisionConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteProvisionConfig', 'DELETE', '/2023-03-30/functions/{functionName}/provision-config', 'none', false, 'json', request);
}

model DeleteTriggerRequest {
  functionName: string(name='functionName', position='Path'),
  triggerName: string(name='triggerName', position='Path'),
}

model DeleteTriggerResponse = {
  headers: map[string]string(name='headers'),
}

/**
  * Delete trigger.
  *
 */
async function deleteTrigger(request: DeleteTriggerRequest): DeleteTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteTrigger', 'DELETE', '/2023-03-30/functions/{functionName}/triggers/{triggerName}', 'none', false, 'json', request);
}

model GetAliasRequest {
  functionName: string(name='functionName', position='Path'),
  aliasName: string(name='aliasName', position='Path'),
}

model GetAliasResponse = {
  headers: map[string]string(name='headers'),
  body: Alias  
}

/**
  * Get function alias
  *
 */
async function getAlias(request: GetAliasRequest): GetAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetAlias', 'GET', '/2023-03-30/functions/{functionName}/aliases/{aliasName}', 'json', false, 'json', request);
}

model GetAsyncInvokeConfigRequest {
  functionName: string(name='functionName', position='Path'),
  qualifier?: string(name='qualifier', position='Query'),
}

model GetAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  body: AsyncConfig  
}

/**
  * Get function async invoke config
  *
 */
async function getAsyncInvokeConfig(request: GetAsyncInvokeConfigRequest): GetAsyncInvokeConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetAsyncInvokeConfig', 'GET', '/2023-03-30/functions/{functionName}/async-invoke-config', 'json', false, 'json', request);
}

model GetConcurrencyConfigRequest {
  functionName: string(name='functionName', position='Path'),
}

model GetConcurrencyConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ConcurrencyConfig  
}

/**
  * gets the concurrency config for a function
  *
 */
async function getConcurrencyConfig(request: GetConcurrencyConfigRequest): GetConcurrencyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetConcurrencyConfig', 'GET', '/2023-03-30/functions/{functionName}/concurrency', 'json', false, 'json', request);
}

model GetCustomDomainRequest {
  domainName: string(name='domainName', position='Path'),
}

model GetCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  body: CustomDomain  
}

/**
  * Get custom domain.
  *
 */
async function getCustomDomain(request: GetCustomDomainRequest): GetCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetCustomDomain', 'GET', '/2023-03-30/custom-domains/{domainName}', 'json', false, 'json', request);
}

model GetFunctionRequest {
  functionName: string(name='functionName', position='Path'),
  qualifier?: string(name='qualifier', position='Query'),
}

model GetFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: Function  
}

/**
  * Get function info by function name
  *
 */
async function getFunction(request: GetFunctionRequest): GetFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunction', 'GET', '/2023-03-30/functions/{functionName}', 'json', false, 'json', request);
}

model GetFunctionCodeRequest {
  functionName: string(name='functionName', position='Path'),
  qualifier?: string(name='qualifier', position='Query'),
}

model GetFunctionCodeResponse = {
  headers: map[string]string(name='headers'),
  body: OutputFuncCode  
}

/**
  * Get function code by function name
  *
 */
async function getFunctionCode(request: GetFunctionCodeRequest): GetFunctionCodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunctionCode', 'GET', '/2023-03-30/functions/{functionName}/code', 'json', false, 'json', request);
}

model GetLayerVersionRequest {
  layerName: string(name='layerName', position='Path'),
  version: int32(name='version', position='Path'),
}

model GetLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  body: Layer  
}

/**
  * Get layer version.
  *
 */
async function getLayerVersion(request: GetLayerVersionRequest): GetLayerVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLayerVersion', 'GET', '/2023-03-30/layers/{layerName}/versions/{version}', 'json', false, 'json', request);
}

model GetLayerVersionByArnRequest {
  arn: string(name='arn', position='Path'),
}

model GetLayerVersionByArnResponse = {
  headers: map[string]string(name='headers'),
  body: Layer  
}

/**
  * Get layer version by arn.
  *
 */
async function getLayerVersionByArn(request: GetLayerVersionByArnRequest): GetLayerVersionByArnResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLayerVersionByArn', 'GET', '/2023-03-30/layerarn/{arn}', 'json', false, 'json', request);
}

model GetProvisionConfigRequest {
  functionName: string(name='functionName', position='Path'),
  qualifier?: string(name='qualifier', position='Query'),
}

model GetProvisionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ProvisionConfig  
}

/**
  * Get provision config.
  *
 */
async function getProvisionConfig(request: GetProvisionConfigRequest): GetProvisionConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetProvisionConfig', 'GET', '/2023-03-30/functions/{functionName}/provision-config', 'json', false, 'json', request);
}

model GetResourceTagsRequest {
  arn: string(name='arn', position='Query'),
}

model GetResourceTagsResponse = {
  headers: map[string]string(name='headers'),
  body: GetResourceTagsOutput  
}

/**
  * Get resource tag
  *
 */
async function getResourceTags(request: GetResourceTagsRequest): GetResourceTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetResourceTags', 'GET', '/2023-03-30/tag', 'json', false, 'json', request);
}

model GetTriggerRequest {
  functionName: string(name='functionName', position='Path'),
  triggerName: string(name='triggerName', position='Path'),
}

model GetTriggerResponse = {
  headers: map[string]string(name='headers'),
  body: Trigger  
}

/**
  * Get trigger.
  *
 */
async function getTrigger(request: GetTriggerRequest): GetTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTrigger', 'GET', '/2023-03-30/functions/{functionName}/triggers/{triggerName}', 'json', false, 'json', request);
}

model InvokeFunctionRequest {
  functionName: string(name='functionName', position='Path'),
  body?: readable(name='body', position='Body'),
  qualifier?: string(name='qualifier', position='Query'),
  xFcInvocationType?: string(name='x-fc-invocation-type', position='Header'),
  xFcLogType?: string(name='x-fc-log-type', position='Header'),
}

model InvokeFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: readable(name='body'),
}

/**
  * Invoke function
  *
 */
async function invokeFunction(request: InvokeFunctionRequest): InvokeFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InvokeFunction', 'POST', '/2023-03-30/functions/{functionName}/invocations', 'binary', false, 'json', request);
}

model ListAliasesRequest {
  functionName: string(name='functionName', position='Path'),
  limit?: int32(name='limit', position='Query'),
  nextToken?: string(name='nextToken', position='Query'),
  prefix?: string(name='prefix', position='Query'),
}

model ListAliasesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAliasesOutput  
}

/**
  * List function aliases
  *
 */
async function listAliases(request: ListAliasesRequest): ListAliasesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAliases', 'GET', '/2023-03-30/functions/{functionName}/aliases', 'json', false, 'json', request);
}

model ListAsyncInvokeConfigsRequest {
  functionName?: string(name='functionName', position='Query'),
  limit?: int32(name='limit', position='Query'),
  nextToken?: string(name='nextToken', position='Query'),
}

model ListAsyncInvokeConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAsyncInvokeConfigOutput  
}

/**
  * List all functions async invoke config
  *
 */
async function listAsyncInvokeConfigs(request: ListAsyncInvokeConfigsRequest): ListAsyncInvokeConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAsyncInvokeConfigs', 'GET', '/2023-03-30/async-invoke-configs', 'json', false, 'json', request);
}

model ListConcurrencyConfigsRequest {
  functionName?: string(name='functionName', position='Query'),
  limit?: int32(name='limit', position='Query'),
  nextToken?: string(name='nextToken', position='Query'),
}

model ListConcurrencyConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListConcurrencyConfigsOutput  
}

/**
  * List all functions concurrency configs
  *
 */
async function listConcurrencyConfigs(request: ListConcurrencyConfigsRequest): ListConcurrencyConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListConcurrencyConfigs', 'GET', '/2023-03-30/concurrency-configs', 'json', false, 'json', request);
}

model ListCustomDomainsRequest {
  limit?: int32(name='limit', position='Query'),
  nextToken?: string(name='nextToken', position='Query'),
  prefix?: string(name='prefix', position='Query'),
}

model ListCustomDomainsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCustomDomainOutput  
}

/**
  * List custom domains.
  *
 */
async function listCustomDomains(request: ListCustomDomainsRequest): ListCustomDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListCustomDomains', 'GET', '/2023-03-30/custom-domains', 'json', false, 'json', request);
}

model ListFunctionVersionsRequest {
  functionName: string(name='functionName', position='Path'),
  direction?: string(name='direction', position='Query'),
  limit?: int32(name='limit', position='Query'),
  nextToken?: string(name='nextToken', position='Query'),
}

model ListFunctionVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVersionsOutput  
}

/**
  * List function versions
  *
 */
async function listFunctionVersions(request: ListFunctionVersionsRequest): ListFunctionVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFunctionVersions', 'GET', '/2023-03-30/functions/{functionName}/versions', 'json', false, 'json', request);
}

model ListFunctionsRequest {
  limit?: int32(name='limit', position='Query'),
  nextToken?: string(name='nextToken', position='Query'),
  prefix?: string(name='prefix', position='Query'),
}

model ListFunctionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFunctionsOutput  
}

/**
  * Lists existing functions.
  *
 */
async function listFunctions(request: ListFunctionsRequest): ListFunctionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFunctions', 'GET', '/2023-03-30/functions', 'json', false, 'json', request);
}

model ListInstancesRequest {
  functionName: string(name='functionName', position='Path'),
  qualifier?: string(name='qualifier', position='Query'),
  withAllActive?: boolean(name='withAllActive', position='Query'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstancesOutput  
}

/**
  * List instances for function.
  *
 */
async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListInstances', 'GET', '/2023-03-30/functions/{functionName}/instances', 'json', false, 'json', request);
}

model ListLayerVersionsRequest {
  layerName: string(name='layerName', position='Path'),
  limit?: int32(name='limit', position='Query'),
  startVersion?: string(name='startVersion', position='Query'),
}

model ListLayerVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListLayerVersionOutput  
}

/**
  * List layer versions.
  *
 */
async function listLayerVersions(request: ListLayerVersionsRequest): ListLayerVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLayerVersions', 'GET', '/2023-03-30/layers/{layerName}/versions', 'json', false, 'json', request);
}

model ListLayersRequest {
  limit?: int32(name='limit', position='Query'),
  nextToken?: string(name='nextToken', position='Query'),
  official?: string(name='official', position='Query'),
  prefix?: string(name='prefix', position='Query'),
  public?: string(name='public', position='Query'),
}

model ListLayersResponse = {
  headers: map[string]string(name='headers'),
  body: ListLayersOutput  
}

/**
  * List layers .
  *
 */
async function listLayers(request: ListLayersRequest): ListLayersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLayers', 'GET', '/2023-03-30/layers', 'json', false, 'json', request);
}

model ListProvisionConfigsRequest {
  functionName?: string(name='functionName', position='Query'),
  limit?: int32(name='limit', position='Query'),
  nextToken?: string(name='nextToken', position='Query'),
}

model ListProvisionConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProvisionConfigsOutput  
}

/**
  * List provision configs.
  *
 */
async function listProvisionConfigs(request: ListProvisionConfigsRequest): ListProvisionConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListProvisionConfigs', 'GET', '/2023-03-30/provision-configs', 'json', false, 'json', request);
}

model ListTaggedResourcesRequest {
  limit?: int32(name='limit', position='Query'),
  nextToken?: string(name='nextToken', position='Query'),
}

model ListTaggedResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTaggedResourcesOutput  
}

/**
  * List tagged resources
  *
 */
async function listTaggedResources(request: ListTaggedResourcesRequest): ListTaggedResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTaggedResources', 'GET', '/2023-03-30/tags', 'json', false, 'json', request);
}

model ListTriggersRequest {
  functionName: string(name='functionName', position='Path'),
  limit?: int32(name='limit', position='Query'),
  nextToken?: string(name='nextToken', position='Query'),
  prefix?: string(name='prefix', position='Query'),
}

model ListTriggersResponse = {
  headers: map[string]string(name='headers'),
  body: ListTriggersOutput  
}

/**
  * List triggers.
  *
 */
async function listTriggers(request: ListTriggersRequest): ListTriggersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTriggers', 'GET', '/2023-03-30/functions/{functionName}/triggers', 'json', false, 'json', request);
}

model PublishFunctionVersionRequest {
  functionName: string(name='functionName', position='Path'),
  body: PublishVersionInput(name='body', position='Body'),
}

model PublishFunctionVersionResponse = {
  headers: map[string]string(name='headers'),
  body: Version  
}

/**
  * publish new function version
  *
 */
async function publishFunctionVersion(request: PublishFunctionVersionRequest): PublishFunctionVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PublishFunctionVersion', 'POST', '/2023-03-30/functions/{functionName}/versions', 'json', false, 'json', request);
}

model PutAsyncInvokeConfigRequest {
  functionName: string(name='functionName', position='Path'),
  body: PutAsyncInvokeConfigInput(name='body', position='Body'),
  qualifier?: string(name='qualifier', position='Query'),
}

model PutAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  body: AsyncConfig  
}

/**
  * Put function async invoke config.
  *
 */
async function putAsyncInvokeConfig(request: PutAsyncInvokeConfigRequest): PutAsyncInvokeConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutAsyncInvokeConfig', 'PUT', '/2023-03-30/functions/{functionName}/async-invoke-config', 'json', false, 'json', request);
}

model PutConcurrencyConfigRequest {
  functionName: string(name='functionName', position='Path'),
  body: PutConcurrencyInput(name='body', position='Body'),
}

model PutConcurrencyConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ConcurrencyConfig  
}

/**
  * sets the concurrency config for a function
  *
 */
async function putConcurrencyConfig(request: PutConcurrencyConfigRequest): PutConcurrencyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutConcurrencyConfig', 'PUT', '/2023-03-30/functions/{functionName}/concurrency', 'json', false, 'json', request);
}

model PutLayerACLRequest {
  layerName: string(name='layerName', position='Path'),
  public?: string(name='public', position='Query'),
}

model PutLayerACLResponse = {
  headers: map[string]string(name='headers'),
}

/**
  * Update layer ACL.
  *
 */
async function putLayerACL(request: PutLayerACLRequest): PutLayerACLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutLayerACL', 'PUT', '/2023-03-30/layers/{layerName}/acl', 'none', false, 'json', request);
}

model PutProvisionConfigRequest {
  functionName: string(name='functionName', position='Path'),
  body: PutProvisionConfigInput(name='body', position='Body'),
  qualifier?: string(name='qualifier', position='Query'),
}

model PutProvisionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ProvisionConfig  
}

/**
  * Put provision config.
  *
 */
async function putProvisionConfig(request: PutProvisionConfigRequest): PutProvisionConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutProvisionConfig', 'PUT', '/2023-03-30/functions/{functionName}/provision-config', 'json', false, 'json', request);
}

model TagResourceRequest {
  body: TagResourceInput(name='body', position='Body'),
}

model TagResourceResponse = {
  headers: map[string]string(name='headers'),
  body: Tag  
}

/**
  * Tag resource
  *
 */
async function tagResource(request: TagResourceRequest): TagResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'TagResource', 'POST', '/2023-03-30/tag', 'json', false, 'json', request);
}

model UntagResourceRequest {
  all?: boolean(name='all', position='Query'),
  arn: string(name='arn', position='Query'),
  tagKeys?: string(name='tagKeys', position='Query'),
}

model UntagResourceResponse = {
  headers: map[string]string(name='headers'),
}

/**
  * Untag resource tag, support resource type: function, service
  *
 */
async function untagResource(request: UntagResourceRequest): UntagResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UntagResource', 'DELETE', '/2023-03-30/tag', 'none', false, 'json', request);
}

model UpdateAliasRequest {
  functionName: string(name='functionName', position='Path'),
  aliasName: string(name='aliasName', position='Path'),
  body: UpdateAliasInput(name='body', position='Body'),
}

model UpdateAliasResponse = {
  headers: map[string]string(name='headers'),
  body: Alias  
}

/**
  * Update function alias
  *
 */
async function updateAlias(request: UpdateAliasRequest): UpdateAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateAlias', 'PUT', '/2023-03-30/functions/{functionName}/aliases/{aliasName}', 'json', false, 'json', request);
}

model UpdateCustomDomainRequest {
  domainName: string(name='domainName', position='Path'),
  body: UpdateCustomDomainInput(name='body', position='Body'),
}

model UpdateCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  body: CustomDomain  
}

/**
  * Update custom domain.
  *
 */
async function updateCustomDomain(request: UpdateCustomDomainRequest): UpdateCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateCustomDomain', 'PUT', '/2023-03-30/custom-domains/{domainName}', 'json', false, 'json', request);
}

model UpdateFunctionRequest {
  functionName: string(name='functionName', position='Path'),
  body: UpdateFunctionInput(name='body', position='Body'),
}

model UpdateFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: Function  
}

/**
  * Update function
  *
 */
async function updateFunction(request: UpdateFunctionRequest): UpdateFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateFunction', 'PUT', '/2023-03-30/functions/{functionName}', 'json', false, 'json', request);
}

model UpdateTriggerRequest {
  functionName: string(name='functionName', position='Path'),
  triggerName: string(name='triggerName', position='Path'),
  body: UpdateTriggerInput(name='body', position='Body'),
}

model UpdateTriggerResponse = {
  headers: map[string]string(name='headers'),
  body: Trigger  
}

/**
  * Update trigger.
  *
 */
async function updateTrigger(request: UpdateTriggerRequest): UpdateTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateTrigger', 'PUT', '/2023-03-30/functions/{functionName}/triggers/{triggerName}', 'json', false, 'json', request);
}

