/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'FC';
  @version = '2023-03-30';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AccelerationInfo {
  status?: string(name='status', example='deprecated'),
}

model Alias {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName?: string(name='aliasName', example='prod'),
  createdTime?: string(name='createdTime', example='2006-01-02T15:04:05Z07:00'),
  description?: string(name='description', example='alias for pre env'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2006-01-02T15:04:05Z07:00'),
  versionId?: string(name='versionId', example='1'),
}

model AsyncConfig {
  asyncTask?: boolean(name='asyncTask', example='true'),
  createdTime?: string(name='createdTime', example='2006-01-02T15:04:05Z07:00'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:1234/functions/my-func'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2006-01-02T15:04:05Z07:00'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', example='3600'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', example='3'),
}

model AsyncTask {
  alreadyRetriedTimes?: long(name='alreadyRetriedTimes', example='3'),
  destinationStatus?: string(name='destinationStatus', example='Succeeded'),
  durationMs?: long(name='durationMs', example='1000'),
  endTime?: long(name='endTime', example='1633449590000'),
  events?: [
    AsyncTaskEvent
  ](name='events'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:1234/functions/my-func'),
  instanceId?: string(name='instanceId', example='D4-*******9FD1-882707E'),
  qualifier?: string(name='qualifier', example='prod'),
  requestId?: string(name='requestId', example='e026ae92-61e5-472f-b32d-1c9e3c4e****'),
  returnPayload?: string(name='returnPayload', example='result'),
  startedTime?: long(name='startedTime', example='1633449590000'),
  status?: string(name='status', example='Running'),
  taskErrorMessage?: string(name='taskErrorMessage', example='UnhandledInvocationError'),
  taskId?: string(name='taskId', example='e026ae92-61e5-472f-b32d-1c9e3c4e****'),
  taskPayload?: string(name='taskPayload', example='body'),
}

model AsyncTaskEvent {
  eventDetail?: string(name='eventDetail', example='body'),
  eventId?: long(name='eventId', example='1'),
  status?: string(name='status', example='Succeeded'),
  timestamp?: long(name='timestamp', example='1647420449721'),
}

model AuthConfig {
  authInfo?: string(name='authInfo', example='{}'),
  authType?: string(name='authType', example='anonymous, function, jwt'),
}

model BatchWindow {
  countBasedWindow?: int32(name='CountBasedWindow', example='100'),
  timeBasedWindow?: int32(name='TimeBasedWindow', example='10'),
}

model CDNTriggerConfig {
  eventName?: string(name='eventName', example='CdnDomainStarted'),
  eventVersion?: string(name='eventVersion', example='1.0.0'),
  filter?: map[string][ string ](name='filter'),
  notes?: string(name='notes', example='缓存事件触发器'),
}

model CertConfig {
  certName: string(name='certName', example='my-cert', minLength=1, maxLength=128),
  certificate: string(name='certificate', example='PEM format', maxLength=20480),
  privateKey: string(name='privateKey', example='PEM format', maxLength=4096),
}

model ConcurrencyConfig {
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:123:functions/demo'),
  reservedConcurrency?: long(name='reservedConcurrency', example='10'),
}

model CreateAliasInput {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName: string(name='aliasName', example='prod', minLength=1, maxLength=128),
  description?: string(name='description', example='my alias', maxLength=256),
  versionId: string(name='versionId', example='1', minLength=1, maxLength=10),
}

model CreateCustomDomainInput {
  authConfig?: AuthConfig(name='authConfig'),
  certConfig?: CertConfig(name='certConfig'),
  domainName: string(name='domainName', example='example.com', minLength=1, maxLength=256),
  protocol?: string(name='protocol', example='HTTP'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model CreateFunctionInput {
  code?: InputCodeLocation(name='code'),
  cpu?: float(name='cpu', example='1'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description', example='my function', maxLength=256),
  diskSize?: int32(name='diskSize', example='512'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionName: string(name='functionName', example='my-function-1', minLength=1, maxLength=128),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler: string(name='handler', example='index.handler', minLength=1, maxLength=128),
  instanceConcurrency?: int32(name='instanceConcurrency', example='1'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess', example='true'),
  layers?: [ string ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize', example='512'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role', example='acs:ram::188077086902****:role/fc-test', maxLength=300),
  runtime: string(name='runtime', example='python3.10'),
  timeout?: int32(name='timeout', example='60'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model CreateLayerVersionInput {
  code?: InputCodeLocation(name='code'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  description?: string(name='description', example='my first layer', maxLength=256),
  license?: string(name='license', example='Apache'),
}

model CreateTriggerInput {
  description?: string(name='description', example='trigger for test', maxLength=256),
  invocationRole?: string(name='invocationRole', example='acs:ram::1234567890:role/fc-test', maxLength=300),
  qualifier?: string(name='qualifier', example='LATEST'),
  sourceArn?: string(name='sourceArn', example='acs:oss:cn-shanghai:12345:mybucket', minLength=1, maxLength=300),
  triggerConfig: string(name='triggerConfig', example='{"events":["oss:ObjectCreated:*"],"filter":{"key":{"prefix":"/prefix","suffix":".zip"}}}'),
  triggerName: string(name='triggerName', example='oss_create_object_demo', minLength=1, maxLength=128),
  triggerType: string(name='triggerType', example='oss'),
}

model CreateVpcBindingInput {
  vpcId: string(name='vpcId', example='vpc-8vb8x8dggvr0axxxxxxxx', minLength=1),
}

model CustomContainerConfig {
  accelerationInfo?: AccelerationInfo(name='accelerationInfo'),
  accelerationType?: string(name='accelerationType', example='deprecated'),
  acrInstanceId?: string(name='acrInstanceId', example='deprecated'),
  command?: [ string ](name='command'),
  entrypoint?: [ string ](name='entrypoint'),
  healthCheckConfig?: CustomHealthCheckConfig(name='healthCheckConfig'),
  image?: string(name='image', example='registry-vpc.cn-hangzhou.aliyuncs.com/fc-demo/helloworld:v1'),
  port?: int32(name='port', example='9000'),
  resolvedImageUri?: string(name='resolvedImageUri', example='stand-sh-registry-vpc.cn-shanghai.cr.aliyuncs.com/fc-demo2/springboot-helloworld@sha256:68d1****0d64d6'),
}

model CustomDNS {
  dnsOptions?: [
    DNSOption
  ](name='dnsOptions'),
  nameServers?: [ string ](name='nameServers'),
  searches?: [ string ](name='searches'),
}

model CustomDomain {
  accountId?: string(name='accountId'),
  apiVersion?: string(name='apiVersion', example='2023-03-30'),
  authConfig?: AuthConfig(name='authConfig'),
  certConfig?: CertConfig(name='certConfig'),
  createdTime?: string(name='createdTime', example='2023-03-30T08:02:19Z'),
  domainName?: string(name='domainName', example='example.com'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2023-03-30T08:02:19Z'),
  protocol?: string(name='protocol', example='HTTP'),
  routeConfig?: RouteConfig(name='routeConfig'),
  subdomainCount?: string(name='subdomainCount', example='1'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model CustomHealthCheckConfig {
  failureThreshold?: int32(name='failureThreshold', example='1'),
  httpGetUrl?: string(name='httpGetUrl', example='/ready'),
  initialDelaySeconds?: int32(name='initialDelaySeconds', example='1'),
  periodSeconds?: int32(name='periodSeconds', example='1'),
  successThreshold?: int32(name='successThreshold', example='2'),
  timeoutSeconds?: int32(name='timeoutSeconds', example='2'),
}

model CustomRuntimeConfig {
  args?: [ string ](name='args'),
  command?: [ string ](name='command'),
  healthCheckConfig?: CustomHealthCheckConfig(name='healthCheckConfig'),
  port?: int32(name='port', example='9000'),
}

model DNSOption {
  name?: string(name='name', example='ndots', maxLength=256),
  value?: string(name='value', example='2', maxLength=256),
}

model DeadLetterQueue {
  arn?: string(name='Arn', example='acs:mq:cn-shanghai:14319991365*****:/instances/MQ_INST_14319991365*****_BYWs****/topic/testTopic'),
}

model DeliveryOption {
  concurrency?: long(name='concurrency', example='2'),
  eventSchema?: string(name='eventSchema', example='RawData'),
}

model Destination {
  destination?: string(name='destination', example='acs:fc:cn-shanghai:xxx:functions/f1', maxLength=512),
}

model DestinationConfig {
  onFailure?: Destination(name='onFailure'),
  onSuccess?: Destination(name='onSuccess'),
}

model EqualRule {
  match: string(name='match', example='/old', maxLength=256),
  replacement: string(name='replacement', example='/new', maxLength=256),
}

model Error {
  code?: string(name='Code', example='FunctionNotFound'),
  message?: string(name='Message', example='function not found'),
  requestId?: string(name='RequestId', example='1-64e70cf1-5cbef92ea8fc8c42899cf5d1'),
}

model EventBridgeTriggerConfig {
  asyncInvocationType?: boolean(name='asyncInvocationType'),
  eventRuleFilterPattern?: string(name='eventRuleFilterPattern', example='{}'),
  eventSinkConfig?: EventSinkConfig(name='eventSinkConfig'),
  eventSourceConfig?: EventSourceConfig(name='eventSourceConfig'),
  runOptions?: RunOptions(name='runOptions'),
  triggerEnable?: boolean(name='triggerEnable', example='true'),
}

model EventSinkConfig {
  deliveryOption?: DeliveryOption(name='deliveryOption'),
}

model EventSourceConfig {
  eventSourceParameters?: EventSourceParameters(name='eventSourceParameters'),
  eventSourceType?: string(name='eventSourceType', example='MNS'),
}

model EventSourceParameters {
  sourceDTSParameters?: SourceDTSParameters(name='sourceDTSParameters'),
  sourceKafkaParameters?: SourceKafkaParameters(name='sourceKafkaParameters'),
  sourceMNSParameters?: SourceMNSParameters(name='sourceMNSParameters'),
  sourceMQTTParameters?: SourceMQTTParameters(name='sourceMQTTParameters'),
  sourceRabbitMQParameters?: SourceRabbitMQParameters(name='sourceRabbitMQParameters'),
  sourceRocketMQParameters?: SourceRocketMQParameters(name='sourceRocketMQParameters'),
}

model Filter {
  key?: Key(name='key'),
}

model Function {
  codeChecksum?: string(name='codeChecksum', example='2825179536350****'),
  codeSize?: long(name='codeSize', example='412'),
  cpu?: float(name='cpu', example='1'),
  createdTime?: string(name='createdTime', example='2023-04-01T08:15:27Z'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description', example='my function'),
  diskSize?: int32(name='diskSize', example='512'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:123:functions/functionName'),
  functionId?: string(name='functionId', example='aa715851-1c20-4b89-a8fb-***'),
  functionName?: string(name='functionName', example='my-function-1'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler', example='index.handler'),
  instanceConcurrency?: int32(name='instanceConcurrency', example='1'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess', example='true'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2023-05-01T08:15:27Z'),
  lastUpdateStatus?: string(name='lastUpdateStatus', example='InProgress'),
  lastUpdateStatusReason?: string(name='lastUpdateStatusReason', example='The system is currently processing the acceleration optimization for the image.'),
  lastUpdateStatusReasonCode?: string(name='lastUpdateStatusReasonCode', example='ImageOptimizing'),
  layers?: [
    FunctionLayer
  ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize', example='512'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role', example='acs:ram::188077086902****:role/fc-test'),
  runtime?: string(name='runtime', example='python3.10'),
  state?: string(name='state', example='Pending'),
  stateReason?: string(name='stateReason', example='Function creating'),
  stateReasonCode?: string(name='stateReasonCode', example='Creating'),
  timeout?: int32(name='timeout', example='60'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model FunctionLayer {
  arn?: string(name='arn', example='acs:fc:cn-beijing:186824xxxxxx:layers/fc_layer/versions/1'),
  size?: long(name='size', example='421'),
}

model GPUConfig {
  gpuMemorySize?: int32(name='gpuMemorySize', example='2048'),
  gpuType?: string(name='gpuType', example='fc.gpu.ampere.1', maxLength=128),
}

model GetResourceTagsOutput {
  resouceType?: string(name='resouceType', example='ALIYUN::FC::FUNCTION'),
  resourceArn?: string(name='resourceArn', example='acs:fc:cn-shanghai:****:functions/demo'),
  tags?: map[string]string(name='tags'),
}

model HTTPTrigger {
  urlInternet?: string(name='urlInternet', example='https://svc-func-xxxxxxxx.cn-hangzhou.fcapp.run'),
  urlIntranet?: string(name='urlIntranet', example='https://svc-func-xxxxxxxx.cn-hangzhou-vpc.fcapp.run'),
}

model HTTPTriggerConfig {
  authConfig?: string(name='authConfig', example='{"JWKS":{"foo":"bar"},"TokenLookup":"header:Authorization:Bearer,cookie:AuthorizationCookie","ClaimPassBy":"query:uid:uid,header:name:name"}'),
  authType?: string(name='authType', example='anonymous'),
  disableURLInternet?: boolean(name='disableURLInternet', example='true'),
  methods?: [ string ](name='methods'),
}

model InputCodeLocation {
  checksum?: string(name='checksum', example='2825179536350****'),
  ossBucketName?: string(name='ossBucketName', example='demo-bucket', minLength=3, maxLength=63),
  ossObjectName?: string(name='ossObjectName', example='demo-object'),
  zipFile?: string(name='zipFile', example='UEsDBAoAAAAAANF'),
}

model InstanceInfo {
  instanceId?: string(name='instanceId', example='1ef6b6ff-7f7b-485e-ab49-501ac681****'),
  versionId?: string(name='versionId', example='LATEST'),
}

model InstanceLifecycleConfig {
  initializer?: LifecycleHook(name='initializer'),
  preStop?: LifecycleHook(name='preStop'),
}

model JobConfig {
  maxRetryTime?: int32(name='maxRetryTime', example='3'),
  triggerInterval?: int32(name='triggerInterval', example='60'),
}

model Key {
  prefix?: string(name='prefix', example='serverless_'),
  suffix?: string(name='suffix', example='.zip'),
}

model Layer {
  acl?: string(name='acl', example='0'),
  code?: OutputCodeLocation(name='code'),
  codeChecksum?: string(name='codeChecksum', example='2825179536350****'),
  codeSize?: long(name='codeSize', example='421'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  createTime?: string(name='createTime', example='2023-03-30T11:08:00Z'),
  description?: string(name='description', example='My first layer', maxLength=256),
  layerName: string(name='layerName', example='MyLayer', minLength=1, maxLength=128),
  layerVersionArn?: string(name='layerVersionArn', example='acs:fc:cn-beijing:186824xxxxxx:layers/fc_layer/versions/1'),
  license?: string(name='license', example='Apache'),
  version?: int32(name='version', example='1'),
}

model LifecycleHook {
  handler?: string(name='handler', example='index.initializer', maxLength=128),
  timeout?: int32(name='timeout', example='10'),
}

model ListAliasesOutput {
  aliases?: [
    Alias
  ](name='aliases'),
  nextToken?: string(name='nextToken', example='test'),
}

model ListAsyncInvokeConfigOutput {
  configs?: [
    AsyncConfig
  ](name='configs'),
  nextToken?: string(name='nextToken', example='8bj81uI8n****'),
}

model ListAsyncTaskOutput {
  nextToken?: string(name='nextToken'),
  tasks?: [
    AsyncTask
  ](name='tasks'),
}

model ListConcurrencyConfigsOutput {
  configs?: [
    ConcurrencyConfig
  ](name='configs'),
  nextToken?: string(name='nextToken', example='next_token'),
}

model ListCustomDomainOutput {
  customDomains?: [
    CustomDomain
  ](name='customDomains'),
  nextToken?: string(name='nextToken', example='next_domain_name'),
}

model ListFunctionsOutput {
  functions?: [
    Function
  ](name='functions'),
  nextToken?: string(name='nextToken', example='next_function_name'),
}

model ListInstancesOutput {
  instances?: [
    InstanceInfo
  ](name='instances'),
}

model ListLayerVersionOutput {
  layers?: [
    Layer
  ](name='layers'),
  nextVersion?: int32(name='nextVersion', example='10'),
}

model ListLayersOutput {
  layers?: [
    Layer
  ](name='layers'),
  nextToken?: string(name='nextToken', example='next-layer-name'),
}

model ListProvisionConfigsOutput {
  nextToken?: string(name='nextToken', example='next_token'),
  provisionConfigs?: [
    ProvisionConfig
  ](name='provisionConfigs'),
}

model ListTagResourcesOutput {
  nextToken?: string(name='NextToken', example='next_token'),
  requestId?: string(name='RequestId'),
  tagResources?: [
    TagResource
  ](name='TagResources'),
}

model ListTaggedResourcesOutput {
  nextToken?: string(name='nextToken', example='next_token'),
  resources?: [
    Resource
  ](name='resources'),
}

model ListTriggersOutput {
  nextToken?: string(name='nextToken', example='next_token'),
  triggers?: [
    Trigger
  ](name='triggers'),
}

model ListVersionsOutput {
  direction?: string(name='direction', example='FORWARD'),
  nextToken?: string(name='nextToken', example='3'),
  versions?: [
    Version
  ](name='versions'),
}

model ListVpcBindingsOutput {
  vpcIds?: [ string ](name='vpcIds'),
}

model LogConfig {
  enableInstanceMetrics?: boolean(name='enableInstanceMetrics', example='true'),
  enableRequestMetrics?: boolean(name='enableRequestMetrics', example='true'),
  logBeginRule?: string(name='logBeginRule', example='DefaultRegex'),
  logstore?: string(name='logstore', example='test-logstore', maxLength=63),
  project?: string(name='project', example='test-project', maxLength=63),
}

model MNSTopicTriggerConfig {
  filterTag?: string(name='filterTag', example='serverless'),
  notifyContentFormat?: string(name='notifyContentFormat', example='JSON'),
  notifyStrategy?: string(name='notifyStrategy', example='BACKOFF_RETRY'),
}

model NASConfig {
  groupId?: int32(name='groupId', example='100'),
  mountPoints?: [
    NASMountConfig
  ](name='mountPoints'),
  userId?: int32(name='userId', example='100'),
}

model NASMountConfig {
  enableTLS?: boolean(name='enableTLS'),
  mountDir?: string(name='mountDir', example='/home/test', maxLength=64),
  serverAddr?: string(name='serverAddr', example='***-uni85.cn-hangzhou.nas.com:/', maxLength=128),
}

model OSSMountConfig {
  mountPoints?: [
    OSSMountPoint
  ](name='mountPoints'),
}

model OSSMountPoint {
  bucketName?: string(name='bucketName', example='my-bucket', minLength=3, maxLength=64),
  bucketPath?: string(name='bucketPath', example='/my-dir', maxLength=128),
  endpoint?: string(name='endpoint', example='http://oss-cn-shanghai.aliyuncs.com', maxLength=128),
  mountDir?: string(name='mountDir', example='/mnt/dir', minLength=2, maxLength=64),
  readOnly?: boolean(name='readOnly', example='true'),
}

model OSSTriggerConfig {
  events?: [ string ](name='events'),
  filter?: Filter(name='filter'),
}

model OutputCodeLocation {
  location?: string(name='location', example='https://xyz.oss-cn-shanghai.aliyuncs.com/xxx/xxx/xxx'),
  repositoryType?: string(name='repositoryType', example='OSS'),
}

model OutputFuncCode {
  checksum?: string(name='checksum', example='1234567890'),
  url?: string(name='url', example='http://func-code.oss-cn-shanghai.aliyuncs.com/1a2b3c4d5e6f'),
}

model PathConfig {
  functionName: string(name='functionName', example='myFunction'),
  methods?: [ string ](name='methods'),
  path: string(name='path', example='/api/*', maxLength=2048),
  qualifier?: string(name='qualifier', example='myAlias'),
  rewriteConfig?: RewriteConfig(name='rewriteConfig'),
}

model ProvisionConfig {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', example='true'),
  current?: long(name='current', example='1'),
  currentError?: string(name='currentError', example='image not found'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:124:functions/myFunction'),
  scheduledActions?: [
    ScheduledAction
  ](name='scheduledActions'),
  target?: long(name='target', example='5'),
  targetTrackingPolicies?: [
    TargetTrackingPolicy
  ](name='targetTrackingPolicies'),
}

model PublishVersionInput {
  description?: string(name='description', example='my version', maxLength=256),
}

model PutAsyncInvokeConfigInput {
  asyncTask?: boolean(name='asyncTask', example='true'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', example='300'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', example='3'),
}

model PutConcurrencyInput {
  reservedConcurrency: long(name='reservedConcurrency', example='10'),
}

model PutProvisionConfigInput {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', example='true'),
  scheduledActions?: [
    ScheduledAction
  ](name='scheduledActions'),
  target: long(name='target', example='1'),
  targetTrackingPolicies?: [
    TargetTrackingPolicy
  ](name='targetTrackingPolicies'),
}

model RegexRule {
  match: string(name='match', example='^/api/.+?/(.*)', maxLength=256),
  replacement: string(name='replacement', example='/api/v2/$1', maxLength=256),
}

model Resource {
  resouceType?: string(name='resouceType', example='ALIYUN::FC::FUNCTION'),
  resourceArn?: string(name='resourceArn', example='acs:fc:cn-shanghai:****:functions/demo'),
  tags?: map[string]string(name='tags'),
}

model RetryStrategy {
  pushRetryStrategy?: string(name='PushRetryStrategy', example='BACKOFF_RETRY'),
}

model RewriteConfig {
  equalRules?: [
    EqualRule
  ](name='equalRules'),
  regexRules?: [
    RegexRule
  ](name='regexRules'),
  wildcardRules?: [
    WildcardRule
  ](name='wildcardRules'),
}

model RouteConfig {
  routes?: [
    PathConfig
  ](name='routes'),
}

model RunOptions {
  batchWindow?: BatchWindow(name='batchWindow'),
  deadLetterQueue?: DeadLetterQueue(name='deadLetterQueue'),
  errorsTolerance?: string(name='errorsTolerance', example='ALL'),
  mode?: string(name='mode', example='event-streaming'),
  retryStrategy?: RetryStrategy(name='retryStrategy'),
}

model SLSTriggerConfig {
  enable?: boolean(name='enable', example='true'),
  functionParameter?: map[string]string(name='functionParameter'),
  jobConfig?: JobConfig(name='jobConfig'),
  logConfig?: SLSTriggerLogConfig(name='logConfig'),
  sourceConfig?: SourceConfig(name='sourceConfig'),
}

model SLSTriggerLogConfig {
  logstore?: string(name='logstore', example='my-sls-logstore-name'),
  project?: string(name='project', example='my-sls-project-name'),
}

model ScheduledAction {
  endTime?: string(name='endTime', example='2024-03-10T10:10:10Z'),
  name: string(name='name', example='test_1'),
  scheduleExpression: string(name='scheduleExpression', example='cron(0 0 22 * * *)'),
  startTime?: string(name='startTime', example='2023-03-10T10:10:10Z'),
  target: long(name='target', example='50'),
}

model SourceConfig {
  logstore?: string(name='logstore', example='my-sls-logstore-name'),
  startTime?: long(name='startTime', example='1704790317'),
}

model SourceDTSParameters {
  brokerUrl?: string(name='BrokerUrl', example='dts-cn-shanghai-vpc.com:18003'),
  initCheckPoint?: int32(name='InitCheckPoint', example='1677340805'),
  password?: string(name='Password', example='dtsTest123'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  sid?: string(name='Sid', example='dtse34j22j025a****'),
  taskId?: string(name='TaskId', example='e34z2gm325q****'),
  topic?: string(name='Topic', example='cn_shanghai_vpc_rm_uf6398ykj0218****_dts_trigger_upgrade_from_old_version2'),
  username?: string(name='Username', example='dts_trigger'),
}

model SourceKafkaParameters {
  consumerGroup?: string(name='ConsumerGroup', example='DEFAULT_GROUP'),
  instanceId?: string(name='InstanceId', example='r-8vb64581862c****'),
  network?: string(name='Network', example='Default'),
  offsetReset?: string(name='OffsetReset', example='latest'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  securityGroupId?: string(name='SecurityGroupId', example='sg-bp1iv19sp1msc7zot4****'),
  topic?: string(name='Topic', example='popvip_center_robot_order'),
  vSwitchIds?: string(name='VSwitchIds', example='vsw-bp179l3llg3jjxwrq72****'),
  vpcId?: string(name='VpcId', example='vpc-8vblalsi0vbhizr77****'),
}

model SourceMNSParameters {
  isBase64Decode?: boolean(name='IsBase64Decode', example='true'),
  queueName?: string(name='QueueName', example='demo'),
  regionId?: string(name='RegionId', example='cn-shanghai'),
}

model SourceMQTTParameters {
  instanceId?: string(name='InstanceId', example='mqtt-****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  topic?: string(name='Topic', example='testTopic'),
}

model SourceRabbitMQParameters {
  instanceId?: string(name='InstanceId', example='amqp-cn-nif22u74****'),
  queueName?: string(name='QueueName', example='demo'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  virtualHostName?: string(name='VirtualHostName', example='eb-connect'),
}

model SourceRocketMQParameters {
  authType?: string(name='AuthType', example='ACL'),
  filterType?: string(name='FilterType', example='Tag'),
  groupID?: string(name='GroupID', example='GID_group1'),
  instanceEndpoint?: string(name='InstanceEndpoint', example='registry-vpc.cn-hangzhou.aliyuncs.com'),
  instanceId?: string(name='InstanceId', example='MQ_INST_164901546557****_BAAN****'),
  instanceNetwork?: string(name='InstanceNetwork', example='PrivateNetwork'),
  instancePassword?: string(name='InstancePassword', example='123'),
  instanceSecurityGroupId?: string(name='InstanceSecurityGroupId', example='sg-hp35r2hc3a3sv8q2****'),
  instanceType?: string(name='InstanceType', example='Cloud_5'),
  instanceUsername?: string(name='InstanceUsername', example='6W0xz2uPfiwp****'),
  instanceVSwitchIds?: string(name='InstanceVSwitchIds', example='vsw-uf6gwtbn6etadpvz7****'),
  instanceVpcId?: string(name='InstanceVpcId', example='vpc-uf6of9452b2pba82c****'),
  offset?: string(name='Offset', example='CONSUME_FROM_TIMESTAMP'),
  regionId?: string(name='RegionId', example='cn-shanghai'),
  tag?: string(name='Tag', example='test'),
  timestamp?: int32(name='Timestamp', example='1636597951964'),
  topic?: string(name='Topic', example='myTopic'),
}

model TLSConfig {
  cipherSuites: [ string ](name='cipherSuites'),
  maxVersion?: string(name='maxVersion', example='TLSv1.3'),
  minVersion: string(name='minVersion', example='TLSv1.0'),
}

model Tag {
  key?: string(name='Key', example='k1'),
  value?: string(name='Value', example='v1'),
}

model TagResource {
  resourceId?: string(name='ResourceId', example='acs:fc:cn-shanghai:****:functions/demo'),
  resourceType?: string(name='ResourceType', example='ALIYUN::FC::FUNCTION'),
  tagKey?: string(name='TagKey', example='key1'),
  tagValue?: string(name='TagValue', example='key1'),
}

model TagResourceInput {
  resourceArn: string(name='resourceArn', example='acs:fc:cn-shanghai:xxx:functions/f1', minLength=1),
  tags: map[string]string(name='tags'),
}

model TagResourcesInput {
  resourceId: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType', example='FUNCTION'),
  tag: [
    Tag
  ](name='Tag'),
}

model TargetTrackingPolicy {
  endTime?: string(name='endTime', example='2024-03-10T10:10:10Z'),
  maxCapacity: long(name='maxCapacity', example='10'),
  metricTarget: float(name='metricTarget', example='0.6'),
  metricType: string(name='metricType', example='CPUUtilization'),
  minCapacity: long(name='minCapacity', example='1'),
  name: string(name='name', example='test_1'),
  startTime?: string(name='startTime', example='2023-03-10T10:10:10Z'),
}

model TimerTriggerConfig {
  cronExpression?: string(name='cronExpression', example='0 0 4 * * *'),
  enable?: boolean(name='enable', example='true'),
  payload?: string(name='payload', example='{"workflowInstanceId":"39639"}'),
}

model TracingConfig {
  params?: map[string]string(name='params'),
  type?: string(name='type', example='Jaeger'),
}

model Trigger {
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  httpTrigger?: HTTPTrigger(name='httpTrigger'),
  invocationRole?: string(name='invocationRole'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  qualifier?: string(name='qualifier'),
  sourceArn?: string(name='sourceArn'),
  status?: string(name='status'),
  targetArn?: string(name='targetArn'),
  triggerConfig?: string(name='triggerConfig'),
  triggerId?: string(name='triggerId'),
  triggerName?: string(name='triggerName'),
  triggerType?: string(name='triggerType'),
}

model UpdateAliasInput {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  description?: string(name='description', example='my alias', maxLength=256),
  versionId?: string(name='versionId', example='1', minLength=1, maxLength=10),
}

model UpdateCustomDomainInput {
  authConfig?: AuthConfig(name='authConfig'),
  certConfig?: CertConfig(name='certConfig'),
  protocol?: string(name='protocol', example='HTTP'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model UpdateFunctionInput {
  code?: InputCodeLocation(name='code'),
  cpu?: float(name='cpu', example='1'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description', example='my function', maxLength=256),
  diskSize?: int32(name='diskSize', example='512'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler', example='index.handler', minLength=1, maxLength=128),
  instanceConcurrency?: int32(name='instanceConcurrency', example='1'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess', example='true'),
  layers?: [ string ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize', example='512'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role', example='acs:ram::188077086902****:role/fc-test', maxLength=300),
  runtime?: string(name='runtime'),
  timeout?: int32(name='timeout', example='60'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model UpdateTriggerInput {
  description?: string(name='description', example='trigger for test', maxLength=256),
  invocationRole?: string(name='invocationRole', example='acs:ram::1234567890:role/fc-test', maxLength=300),
  qualifier?: string(name='qualifier', example='LATEST'),
  triggerConfig?: string(name='triggerConfig', example='{"events":["oss:ObjectCreated:*"],"filter":{"key":{"prefix":"/prefix","suffix":".zip"}}}'),
}

model VPCConfig {
  securityGroupId?: string(name='securityGroupId', example='sg-bp18hj1wtxgy3b0***', maxLength=50),
  vSwitchIds?: [ string ](name='vSwitchIds'),
  vpcId?: string(name='vpcId', example='vpc-***', maxLength=50),
}

model Version {
  createdTime?: string(name='createdTime', example='2006-01-02T15:04:05Z07:00'),
  description?: string(name='description', example='my version'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2006-01-02T15:04:05Z07:00'),
  versionId?: string(name='versionId', example='1'),
}

model WAFConfig {
  enableWAF?: boolean(name='enableWAF', example='true'),
}

model WildcardRule {
  match: string(name='match', example='/api/*', maxLength=256),
  replacement: string(name='replacement', example='/$1', maxLength=256),
}

model CreateAliasRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  body: CreateAliasInput(name='body', description='The request parameters for creating an alias.', position='Body'),
}

model CreateAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Alias  
}

async function createAlias(request: CreateAliasRequest): CreateAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateAlias', 'POST', '/2023-03-30/functions/{functionName}/aliases', 'json', false, 'json', request);
}

model CreateCustomDomainRequest {
  body: CreateCustomDomainInput(name='body', description='The information about the custom domain name.', position='Body'),
}

model CreateCustomDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CustomDomain  
}

async function createCustomDomain(request: CreateCustomDomainRequest): CreateCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateCustomDomain', 'POST', '/2023-03-30/custom-domains', 'json', false, 'json', request);
}

model CreateFunctionRequest {
  body: CreateFunctionInput(name='body', description='The information about function configurations.', position='Body'),
}

model CreateFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Function  
}

async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateFunction', 'POST', '/2023-03-30/functions', 'json', false, 'json', request);
}

model CreateLayerVersionRequest {
  layerName: string(name='layerName', description='The name of the layer.', example='my-layer', position='Path'),
  body: CreateLayerVersionInput(name='body', description='The information about layer configurations.', position='Body'),
}

model CreateLayerVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Layer  
}

async function createLayerVersion(request: CreateLayerVersionRequest): CreateLayerVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateLayerVersion', 'POST', '/2023-03-30/layers/{layerName}/versions', 'json', false, 'json', request);
}

model CreateTriggerRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  body: CreateTriggerInput(name='body', description='The trigger configurations.', position='Body'),
}

model CreateTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Trigger  
}

async function createTrigger(request: CreateTriggerRequest): CreateTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateTrigger', 'POST', '/2023-03-30/functions/{functionName}/triggers', 'json', false, 'json', request);
}

model CreateVpcBindingRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  body: CreateVpcBindingInput(name='body', description='The configurations of the virtual private cloud (VPC) binding.', position='Body'),
}

model CreateVpcBindingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function createVpcBinding(request: CreateVpcBindingRequest): CreateVpcBindingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateVpcBinding', 'POST', '/2023-03-30/functions/{functionName}/vpc-bindings', 'none', false, 'json', request);
}

model DeleteAliasRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  aliasName: string(name='aliasName', description='The function alias.', example='my-alias', position='Path'),
}

model DeleteAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteAlias(request: DeleteAliasRequest): DeleteAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteAlias', 'DELETE', '/2023-03-30/functions/{functionName}/aliases/{aliasName}', 'none', false, 'json', request);
}

model DeleteAsyncInvokeConfigRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST', position='Query'),
}

model DeleteAsyncInvokeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteAsyncInvokeConfig(request: DeleteAsyncInvokeConfigRequest): DeleteAsyncInvokeConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteAsyncInvokeConfig', 'DELETE', '/2023-03-30/functions/{functionName}/async-invoke-config', 'none', false, 'json', request);
}

model DeleteConcurrencyConfigRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
}

model DeleteConcurrencyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteConcurrencyConfig(request: DeleteConcurrencyConfigRequest): DeleteConcurrencyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteConcurrencyConfig', 'DELETE', '/2023-03-30/functions/{functionName}/concurrency', 'none', false, 'json', request);
}

model DeleteCustomDomainRequest {
  domainName: string(name='domainName', description='The domain name.', example='foo.bar.com', position='Path'),
}

model DeleteCustomDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteCustomDomain(request: DeleteCustomDomainRequest): DeleteCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteCustomDomain', 'DELETE', '/2023-03-30/custom-domains/{domainName}', 'none', false, 'json', request);
}

model DeleteFunctionRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
}

model DeleteFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteFunction(request: DeleteFunctionRequest): DeleteFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteFunction', 'DELETE', '/2023-03-30/functions/{functionName}', 'none', false, 'json', request);
}

model DeleteFunctionVersionRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  versionId: int32(name='versionId', description='The function version.', example='1', position='Path'),
}

model DeleteFunctionVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteFunctionVersion(request: DeleteFunctionVersionRequest): DeleteFunctionVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteFunctionVersion', 'DELETE', '/2023-03-30/functions/{functionName}/versions/{versionId}', 'none', false, 'json', request);
}

model DeleteLayerVersionRequest {
  layerName: string(name='layerName', description='The layer name.', example='my-layer', position='Path'),
  version: int32(name='version', description='The layer version.', example='1', position='Path'),
}

model DeleteLayerVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteLayerVersion(request: DeleteLayerVersionRequest): DeleteLayerVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteLayerVersion', 'DELETE', '/2023-03-30/layers/{layerName}/versions/{version}', 'none', false, 'json', request);
}

model DeleteProvisionConfigRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  qualifier?: string(name='qualifier', description='The function alias or LATEST.', example='LATEST', position='Query'),
}

model DeleteProvisionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteProvisionConfig(request: DeleteProvisionConfigRequest): DeleteProvisionConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteProvisionConfig', 'DELETE', '/2023-03-30/functions/{functionName}/provision-config', 'none', false, 'json', request);
}

model DeleteTriggerRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  triggerName: string(name='triggerName', description='The trigger name.', example='my-trigger', position='Path'),
}

model DeleteTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteTrigger(request: DeleteTriggerRequest): DeleteTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteTrigger', 'DELETE', '/2023-03-30/functions/{functionName}/triggers/{triggerName}', 'none', false, 'json', request);
}

model DeleteVpcBindingRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  vpcId: string(name='vpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-bp106zxlfj1fqc9', position='Path'),
}

model DeleteVpcBindingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteVpcBinding(request: DeleteVpcBindingRequest): DeleteVpcBindingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteVpcBinding', 'DELETE', '/2023-03-30/functions/{functionName}/vpc-bindings/{vpcId}', 'none', false, 'json', request);
}

model GetAliasRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  aliasName: string(name='aliasName', description='The function alias.', example='my-alias', position='Path'),
}

model GetAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Alias  
}

async function getAlias(request: GetAliasRequest): GetAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetAlias', 'GET', '/2023-03-30/functions/{functionName}/aliases/{aliasName}', 'json', false, 'json', request);
}

model GetAsyncInvokeConfigRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST', position='Query'),
}

model GetAsyncInvokeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AsyncConfig  
}

async function getAsyncInvokeConfig(request: GetAsyncInvokeConfigRequest): GetAsyncInvokeConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetAsyncInvokeConfig', 'GET', '/2023-03-30/functions/{functionName}/async-invoke-config', 'json', false, 'json', request);
}

model GetConcurrencyConfigRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
}

model GetConcurrencyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConcurrencyConfig  
}

async function getConcurrencyConfig(request: GetConcurrencyConfigRequest): GetConcurrencyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetConcurrencyConfig', 'GET', '/2023-03-30/functions/{functionName}/concurrency', 'json', false, 'json', request);
}

model GetCustomDomainRequest {
  domainName: string(name='domainName', description='The domain name.', example='foo.bar.com', position='Path'),
}

model GetCustomDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CustomDomain  
}

async function getCustomDomain(request: GetCustomDomainRequest): GetCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetCustomDomain', 'GET', '/2023-03-30/custom-domains/{domainName}', 'json', false, 'json', request);
}

model GetFunctionRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST', position='Query'),
}

model GetFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Function  
}

async function getFunction(request: GetFunctionRequest): GetFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunction', 'GET', '/2023-03-30/functions/{functionName}', 'json', false, 'json', request);
}

model GetFunctionCodeRequest {
  functionName: string(name='functionName', description='Function name', example='my-func', position='Path'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST', position='Query'),
}

model GetFunctionCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OutputFuncCode  
}

async function getFunctionCode(request: GetFunctionCodeRequest): GetFunctionCodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunctionCode', 'GET', '/2023-03-30/functions/{functionName}/code', 'json', false, 'json', request);
}

model GetLayerVersionRequest {
  layerName: string(name='layerName', description='The name of the layer.', example='my-layer', position='Path'),
  version: int32(name='version', description='The version of the layer.', example='1', position='Path'),
}

model GetLayerVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Layer  
}

async function getLayerVersion(request: GetLayerVersionRequest): GetLayerVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLayerVersion', 'GET', '/2023-03-30/layers/{layerName}/versions/{version}', 'json', false, 'json', request);
}

model GetLayerVersionByArnRequest {
  arn: string(name='arn', description='The Alibaba Cloud Resource Name (ARN) of the layer.', example='acs:fc:cn-shanghai:1234:layers/my-layer/versions/1', position='Path'),
}

model GetLayerVersionByArnResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Layer  
}

async function getLayerVersionByArn(request: GetLayerVersionByArnRequest): GetLayerVersionByArnResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLayerVersionByArn', 'GET', '/2023-03-30/layerarn/{arn}', 'json', false, 'json', request);
}

model GetProvisionConfigRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  qualifier?: string(name='qualifier', description='The function alias or LATEST.', example='LATEST', position='Query'),
}

model GetProvisionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ProvisionConfig  
}

async function getProvisionConfig(request: GetProvisionConfigRequest): GetProvisionConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetProvisionConfig', 'GET', '/2023-03-30/functions/{functionName}/provision-config', 'json', false, 'json', request);
}

model GetTriggerRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  triggerName: string(name='triggerName', description='The trigger name.', example='my-trigger', position='Path'),
}

model GetTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Trigger  
}

async function getTrigger(request: GetTriggerRequest): GetTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTrigger', 'GET', '/2023-03-30/functions/{functionName}/triggers/{triggerName}', 'json', false, 'json', request);
}

model InvokeFunctionRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  body?: readable(name='body', description='The request parameters of function invocation.', example='event', position='Body'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST', position='Query'),
  xFcAsyncTaskId?: string(name='x-fc-async-task-id', position='Header'),
  xFcInvocationType?: string(name='x-fc-invocation-type', description='The type of function invocation. Valid values: Sync and Async.', example='Sync', position='Header'),
  xFcLogType?: string(name='x-fc-log-type', description='The log type of function invocation. Valid values: None and Tail.', example='Tail', position='Header'),
}

model InvokeFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: readable(name='body'),
}

async function invokeFunction(request: InvokeFunctionRequest): InvokeFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InvokeFunction', 'POST', '/2023-03-30/functions/{functionName}/invocations', 'binary', false, 'json', request);
}

async function invokeFunctionWithRequestBody(request: InvokeFunctionRequest, requestBody: RequestBody): InvokeFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.doRequestBody('RESTFUL', 'InvokeFunction', 'POST', '/2023-03-30/functions/{functionName}/invocations', 'binary', false, 'json', request, requestBody);
}

async function invokeFunctionWithAsyncResponseHandler(request: InvokeFunctionRequest, responseHandler: AsyncResponseHandler): InvokeFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.doResponseHandler('RESTFUL', 'InvokeFunction', 'POST', '/2023-03-30/functions/{functionName}/invocations', 'binary', false, 'json', request, responseHandler);
}

model ListAliasesRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  limit?: int32(name='limit', description='The number of aliases returned.', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM=', position='Query'),
  prefix?: string(name='prefix', description='The alias prefix.', example='my-alias', position='Query'),
}

model ListAliasesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAliasesOutput  
}

async function listAliases(request: ListAliasesRequest): ListAliasesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAliases', 'GET', '/2023-03-30/functions/{functionName}/aliases', 'json', false, 'json', request);
}

model ListAsyncInvokeConfigsRequest {
  functionName?: string(name='functionName', description='The function name. If you do not configure this parameter, the asynchronous invocation configurations of all functions are displayed.', example='my-func', position='Query'),
  limit?: int32(name='limit', description='The maximum number of entries to be returned.', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='The paging information. This parameter specifies the start point of the query.', example='MTIzNCNhYmM=', position='Query'),
}

model ListAsyncInvokeConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAsyncInvokeConfigOutput  
}

async function listAsyncInvokeConfigs(request: ListAsyncInvokeConfigsRequest): ListAsyncInvokeConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAsyncInvokeConfigs', 'GET', '/2023-03-30/async-invoke-configs', 'json', false, 'json', request);
}

model ListConcurrencyConfigsRequest {
  functionName?: string(name='functionName', description='The function name. If you leave this parameter empty, the concurrency configurations of all functions are returned.', example='my-func', position='Query'),
  limit?: int32(name='limit', description='The maximum number of entries returned.', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM=', position='Query'),
}

model ListConcurrencyConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListConcurrencyConfigsOutput  
}

async function listConcurrencyConfigs(request: ListConcurrencyConfigsRequest): ListConcurrencyConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListConcurrencyConfigs', 'GET', '/2023-03-30/concurrency-configs', 'json', false, 'json', request);
}

model ListCustomDomainsRequest {
  limit?: int32(name='limit', description='The number of custom domain names returned.', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM=', position='Query'),
  prefix?: string(name='prefix', description='The domain name prefix.', example='foo', position='Query'),
}

model ListCustomDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCustomDomainOutput  
}

async function listCustomDomains(request: ListCustomDomainsRequest): ListCustomDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListCustomDomains', 'GET', '/2023-03-30/custom-domains', 'json', false, 'json', request);
}

model ListFunctionVersionsRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  direction?: string(name='direction', description='The sorting mode of function versions. Valid values: BACKWARD and FORWARD.', example='BACKWARD', position='Query'),
  limit?: int32(name='limit', description='The number of function versions that are returned.', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM=', position='Query'),
}

model ListFunctionVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVersionsOutput  
}

async function listFunctionVersions(request: ListFunctionVersionsRequest): ListFunctionVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFunctionVersions', 'GET', '/2023-03-30/functions/{functionName}/versions', 'json', false, 'json', request);
}

model ListFunctionsRequest {
  limit?: int32(name='limit', description='The number of functions to return. The minimum value is 1 and the maximum value is 100.', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='The pagination token.', example='MTIzNCNhYmM=', position='Query'),
  prefix?: string(name='prefix', description='The prefix of the function name.', example='my-func', position='Query'),
}

model ListFunctionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionsOutput  
}

async function listFunctions(request: ListFunctionsRequest): ListFunctionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFunctions', 'GET', '/2023-03-30/functions', 'json', false, 'json', request);
}

model ListInstancesRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  qualifier?: string(name='qualifier', description='The function version or alias.', example='LATEST', position='Query'),
  withAllActive?: boolean(name='withAllActive', description='Specifies whether to list all instances. Valid values: true and false.', example='true', position='Query'),
}

model ListInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstancesOutput  
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListInstances', 'GET', '/2023-03-30/functions/{functionName}/instances', 'json', false, 'json', request);
}

model ListLayerVersionsRequest {
  layerName: string(name='layerName', description='The layer name.', example='my-layer', position='Path'),
  limit?: int32(name='limit', description='The number of versions to be returned.', example='10', position='Query'),
  startVersion?: string(name='startVersion', description='The initial version of the layer.', example='1', position='Query'),
}

model ListLayerVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLayerVersionOutput  
}

async function listLayerVersions(request: ListLayerVersionsRequest): ListLayerVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLayerVersions', 'GET', '/2023-03-30/layers/{layerName}/versions', 'json', false, 'json', request);
}

model ListLayersRequest {
  limit?: int32(name='limit', description='The number of layers that are returned', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM=', position='Query'),
  official?: string(name='official', description='Specifies whether the layer is official. Valid values: true and false.', example='true', position='Query'),
  prefix?: string(name='prefix', description='The name prefix of the layer.', example='my-layer', position='Query'),
  public?: string(name='public', description='Specifies whether the layer is public. Valid values: true and false.', example='true', position='Query'),
}

model ListLayersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLayersOutput  
}

async function listLayers(request: ListLayersRequest): ListLayersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLayers', 'GET', '/2023-03-30/layers', 'json', false, 'json', request);
}

model ListProvisionConfigsRequest {
  functionName?: string(name='functionName', description='The name of the function. If this parameter is not specified, the provisioned configurations of all functions are listed.', example='my-func', position='Query'),
  limit?: int32(name='limit', description='Number of provisioned configurations to return.', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='A pagination token.', example='MTIzNCNhYmM=', position='Query'),
}

model ListProvisionConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProvisionConfigsOutput  
}

async function listProvisionConfigs(request: ListProvisionConfigsRequest): ListProvisionConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListProvisionConfigs', 'GET', '/2023-03-30/provision-configs', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  limit?: int32(name='Limit', example='10', position='Query'),
  nextToken?: string(name='NextToken', example='MTIzNCNhYmM=', position='Query'),
  resourceId?: [ string ](name='ResourceId', shrink='json', position='Query'),
  resourceType: string(name='ResourceType', example='ALIYUN::FC:FUNCTION', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='标签名', example='k1'),
      value?: string(name='Value', description='标签值', example='v1'),
    }
  ](name='Tag', shrink='json', position='Query'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesOutput  
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTagResources', 'GET', '/2023-03-30/tags-v2', 'json', false, 'json', request);
}

model ListTriggersRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  limit?: int32(name='limit', description='The number of triggers returned.', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='The token for the next page.', example='MTIzNCNhYmM=', position='Query'),
  prefix?: string(name='prefix', description='The trigger name prefix.', example='my-trigger', position='Query'),
}

model ListTriggersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTriggersOutput  
}

async function listTriggers(request: ListTriggersRequest): ListTriggersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTriggers', 'GET', '/2023-03-30/functions/{functionName}/triggers', 'json', false, 'json', request);
}

model ListVpcBindingsRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
}

model ListVpcBindingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVpcBindingsOutput  
}

async function listVpcBindings(request: ListVpcBindingsRequest): ListVpcBindingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListVpcBindings', 'GET', '/2023-03-30/functions/{functionName}/vpc-bindings', 'json', false, 'json', request);
}

model PublishFunctionVersionRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  body: PublishVersionInput(name='body', description='The information about the function version.', position='Body'),
}

model PublishFunctionVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Version  
}

async function publishFunctionVersion(request: PublishFunctionVersionRequest): PublishFunctionVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PublishFunctionVersion', 'POST', '/2023-03-30/functions/{functionName}/versions', 'json', false, 'json', request);
}

model PutAsyncInvokeConfigRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  body: PutAsyncInvokeConfigInput(name='body', description='The configurations of asynchronous function invocation.', position='Body'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST', position='Query'),
}

model PutAsyncInvokeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AsyncConfig  
}

async function putAsyncInvokeConfig(request: PutAsyncInvokeConfigRequest): PutAsyncInvokeConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutAsyncInvokeConfig', 'PUT', '/2023-03-30/functions/{functionName}/async-invoke-config', 'json', false, 'json', request);
}

model PutConcurrencyConfigRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  body: PutConcurrencyInput(name='body', description='The concurrency configurations.', position='Body'),
}

model PutConcurrencyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConcurrencyConfig  
}

async function putConcurrencyConfig(request: PutConcurrencyConfigRequest): PutConcurrencyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutConcurrencyConfig', 'PUT', '/2023-03-30/functions/{functionName}/concurrency', 'json', false, 'json', request);
}

model PutLayerACLRequest {
  layerName: string(name='layerName', description='The layer name.', example='my-layer', position='Path'),
  public?: string(name='public', description='Specifies whether the layer is a public layer. Valid values: true and false.', example='true', position='Query'),
}

model PutLayerACLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function putLayerACL(request: PutLayerACLRequest): PutLayerACLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutLayerACL', 'PUT', '/2023-03-30/layers/{layerName}/acl', 'none', false, 'json', request);
}

model PutProvisionConfigRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  body: PutProvisionConfigInput(name='body', description='The information about the provisioned configuration.', position='Body'),
  qualifier?: string(name='qualifier', description='The function alias or LATEST.', example='LATEST', position='Query'),
}

model PutProvisionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ProvisionConfig  
}

async function putProvisionConfig(request: PutProvisionConfigRequest): PutProvisionConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutProvisionConfig', 'PUT', '/2023-03-30/functions/{functionName}/provision-config', 'json', false, 'json', request);
}

model TagResourcesRequest {
  body: TagResourcesInput(name='body', position='Body'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'TagResources', 'POST', '/2023-03-30/tags-v2', 'none', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', example='true', position='Query'),
  resourceId: [ string ](name='ResourceId', shrink='json', position='Query'),
  resourceType: string(name='ResourceType', example='function', position='Query'),
  tagKey?: [ string ](name='TagKey', shrink='json', position='Query'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UntagResources', 'DELETE', '/2023-03-30/tags-v2', 'none', false, 'json', request);
}

model UpdateAliasRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  aliasName: string(name='aliasName', description='The function alias name.', example='my-alias', position='Path'),
  body: UpdateAliasInput(name='body', description='The alias information to be updated.', position='Body'),
}

model UpdateAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Alias  
}

async function updateAlias(request: UpdateAliasRequest): UpdateAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateAlias', 'PUT', '/2023-03-30/functions/{functionName}/aliases/{aliasName}', 'json', false, 'json', request);
}

model UpdateCustomDomainRequest {
  domainName: string(name='domainName', description='The domain name.', example='foo.bar.com', position='Path'),
  body: UpdateCustomDomainInput(name='body', description='The information about the custom domain name.', position='Body'),
}

model UpdateCustomDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CustomDomain  
}

async function updateCustomDomain(request: UpdateCustomDomainRequest): UpdateCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateCustomDomain', 'PUT', '/2023-03-30/custom-domains/{domainName}', 'json', false, 'json', request);
}

model UpdateFunctionRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  body: UpdateFunctionInput(name='body', description='The function information', position='Body'),
}

model UpdateFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Function  
}

async function updateFunction(request: UpdateFunctionRequest): UpdateFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateFunction', 'PUT', '/2023-03-30/functions/{functionName}', 'json', false, 'json', request);
}

model UpdateTriggerRequest {
  functionName: string(name='functionName', description='The function name.', example='my-func', position='Path'),
  triggerName: string(name='triggerName', description='The trigger name.', example='my-trigger', position='Path'),
  body: UpdateTriggerInput(name='body', description='The trigger configurations.', position='Body'),
}

model UpdateTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Trigger  
}

async function updateTrigger(request: UpdateTriggerRequest): UpdateTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateTrigger', 'PUT', '/2023-03-30/functions/{functionName}/triggers/{triggerName}', 'json', false, 'json', request);
}

