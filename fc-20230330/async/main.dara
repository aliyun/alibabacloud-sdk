/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'FC';
  @version = '2023-03-30';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AccelerationInfo {
  status?: string(name='status', example='deprecated'),
}

model Alias {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName?: string(name='aliasName', example='prod'),
  createdTime?: string(name='createdTime', example='2006-01-02T15:04:05Z07:00'),
  description?: string(name='description', example='alias for pre env'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2006-01-02T15:04:05Z07:00'),
  versionId?: string(name='versionId', example='1'),
}

model AsyncConfig {
  asyncTask?: boolean(name='asyncTask', example='true'),
  createdTime?: string(name='createdTime', example='2006-01-02T15:04:05Z07:00'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:1234/functions/my-func'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2006-01-02T15:04:05Z07:00'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', example='3600'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', example='3'),
}

model AsyncTask {
  alreadyRetriedTimes?: long(name='alreadyRetriedTimes', example='3'),
  destinationStatus?: string(name='destinationStatus', example='Succeeded'),
  durationMs?: long(name='durationMs', example='1000'),
  endTime?: long(name='endTime', example='1633449590000'),
  events?: [
    AsyncTaskEvent
  ](name='events'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:1234/functions/my-func'),
  instanceId?: string(name='instanceId', example='D4-*******9FD1-882707E'),
  qualifier?: string(name='qualifier', example='prod'),
  requestId?: string(name='requestId', example='e026ae92-61e5-472f-b32d-1c9e3c4e****'),
  returnPayload?: string(name='returnPayload', example='result'),
  startedTime?: long(name='startedTime', example='1633449590000'),
  status?: string(name='status', example='Running'),
  taskErrorMessage?: string(name='taskErrorMessage', example='UnhandledInvocationError'),
  taskId?: string(name='taskId', example='e026ae92-61e5-472f-b32d-1c9e3c4e****'),
  taskPayload?: string(name='taskPayload', example='body'),
}

model AsyncTaskEvent {
  eventDetail?: string(name='eventDetail', example='body'),
  eventId?: long(name='eventId', example='1'),
  status?: string(name='status', example='Succeeded'),
  timestamp?: long(name='timestamp', example='1647420449721'),
}

model AuthConfig {
  authInfo?: string(name='authInfo', example='{}'),
  authType?: string(name='authType', example='anonymous, function, jwt'),
}

model BatchWindow {
  countBasedWindow?: int32(name='CountBasedWindow', example='100'),
  timeBasedWindow?: int32(name='TimeBasedWindow', example='10'),
}

model CDNTriggerConfig {
  eventName?: string(name='eventName', example='CdnDomainStarted'),
  eventVersion?: string(name='eventVersion', example='1.0.0'),
  filter?: map[string][ string ](name='filter'),
  notes?: string(name='notes', example='缓存事件触发器'),
}

model CertConfig {
  certName: string(name='certName', description='This parameter is required.', example='my-cert', minLength=1, maxLength=128),
  certificate: string(name='certificate', description='This parameter is required.', example='PEM format', maxLength=20480),
  privateKey: string(name='privateKey', description='This parameter is required.', example='PEM format', maxLength=4096),
}

model ChangeResourceGroupInput {
  newResourceGroupId?: string(name='newResourceGroupId'),
  resourceId?: string(name='resourceId'),
  resourceType?: string(name='resourceType'),
}

model ChangeResourceGroupOutput {
  newResourceGroupId?: string(name='newResourceGroupId'),
  oldResourceGroupId?: string(name='oldResourceGroupId'),
  resourceId?: string(name='resourceId'),
}

model ConcurrencyConfig {
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:123:functions/demo'),
  reservedConcurrency?: long(name='reservedConcurrency', example='10'),
}

model CookieSessionAffinityConfig {
  sessionConcurrencyPerInstance?: long(name='sessionConcurrencyPerInstance'),
  sessionIdleTimeoutInSeconds?: long(name='sessionIdleTimeoutInSeconds'),
  sessionTTLInSeconds?: long(name='sessionTTLInSeconds'),
}

model CreateAliasInput {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName: string(name='aliasName', description='This parameter is required.', example='prod', minLength=1, maxLength=128),
  description?: string(name='description', example='my alias', maxLength=256),
  versionId: string(name='versionId', description='This parameter is required.', example='1', minLength=1, maxLength=10),
}

model CreateCustomDomainInput {
  authConfig?: AuthConfig(name='authConfig'),
  certConfig?: CertConfig(name='certConfig'),
  domainName: string(name='domainName', description='This parameter is required.', example='example.com', minLength=1, maxLength=256),
  protocol?: string(name='protocol', example='HTTP'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model CreateFunctionInput {
  code?: InputCodeLocation(name='code'),
  cpu?: float(name='cpu', example='1'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description', example='my function', maxLength=256),
  disableOndemand?: boolean(name='disableOndemand'),
  diskSize?: int32(name='diskSize', example='512'),
  enableLongLiving?: boolean(name='enableLongLiving', deprecated='true'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionName: string(name='functionName', description='This parameter is required.', example='my-function-1', minLength=1, maxLength=128),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler: string(name='handler', description='This parameter is required.', example='index.handler', minLength=1, maxLength=128),
  instanceConcurrency?: int32(name='instanceConcurrency', example='1'),
  instanceIsolationMode?: string(name='instanceIsolationMode'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess', example='true'),
  layers?: [ string ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize', example='512'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  resourceGroupId?: string(name='resourceGroupId'),
  role?: string(name='role', example='acs:ram::188077086902****:role/fc-test', maxLength=300),
  runtime: string(name='runtime', description='This parameter is required.', example='python3.10'),
  sessionAffinity?: string(name='sessionAffinity', example='MCP_SSE'),
  sessionAffinityConfig?: string(name='sessionAffinityConfig'),
  tags?: [
    Tag
  ](name='tags'),
  timeout?: int32(name='timeout', example='60'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model CreateLayerVersionInput {
  code?: InputCodeLocation(name='code'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  description?: string(name='description', example='my first layer', maxLength=256),
  license?: string(name='license', example='Apache'),
}

model CreateTriggerInput {
  description?: string(name='description', example='trigger for test', maxLength=256),
  invocationRole?: string(name='invocationRole', example='acs:ram::1234567890:role/fc-test', maxLength=300),
  qualifier?: string(name='qualifier', example='LATEST'),
  sourceArn?: string(name='sourceArn', example='acs:oss:cn-shanghai:12345:mybucket', minLength=1, maxLength=300),
  triggerConfig: string(name='triggerConfig', description='This parameter is required.', example='{"events":["oss:ObjectCreated:*"],"filter":{"key":{"prefix":"/prefix","suffix":".zip"}}}'),
  triggerName: string(name='triggerName', description='This parameter is required.', example='oss_create_object_demo', minLength=1, maxLength=128),
  triggerType: string(name='triggerType', description='This parameter is required.', example='oss'),
}

model CreateVpcBindingInput {
  vpcId: string(name='vpcId', description='This parameter is required.', example='vpc-8vb8x8dggvr0axxxxxxxx', minLength=1),
}

model CustomContainerConfig {
  accelerationInfo?: AccelerationInfo(name='accelerationInfo'),
  accelerationType?: string(name='accelerationType', example='deprecated'),
  acrInstanceId?: string(name='acrInstanceId', example='deprecated'),
  command?: [ string ](name='command'),
  entrypoint?: [ string ](name='entrypoint'),
  healthCheckConfig?: CustomHealthCheckConfig(name='healthCheckConfig'),
  image?: string(name='image', example='registry-vpc.cn-hangzhou.aliyuncs.com/fc-demo/helloworld:v1'),
  port?: int32(name='port', example='9000'),
  registryConfig?: RegistryConfig(name='registryConfig'),
  resolvedImageUri?: string(name='resolvedImageUri', example='stand-sh-registry-vpc.cn-shanghai.cr.aliyuncs.com/fc-demo2/springboot-helloworld@sha256:68d1****0d64d6'),
}

model CustomDNS {
  dnsOptions?: [
    DNSOption
  ](name='dnsOptions'),
  nameServers?: [ string ](name='nameServers'),
  searches?: [ string ](name='searches'),
}

model CustomDomain {
  accountId?: string(name='accountId'),
  apiVersion?: string(name='apiVersion', example='2023-03-30'),
  authConfig?: AuthConfig(name='authConfig'),
  certConfig?: CertConfig(name='certConfig'),
  createdTime?: string(name='createdTime', example='2023-03-30T08:02:19Z'),
  domainName?: string(name='domainName', example='example.com'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2023-03-30T08:02:19Z'),
  protocol?: string(name='protocol', example='HTTP'),
  routeConfig?: RouteConfig(name='routeConfig'),
  subdomainCount?: string(name='subdomainCount', example='1'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model CustomHealthCheckConfig {
  failureThreshold?: int32(name='failureThreshold', example='1'),
  httpGetUrl?: string(name='httpGetUrl', example='/ready'),
  initialDelaySeconds?: int32(name='initialDelaySeconds', example='1'),
  periodSeconds?: int32(name='periodSeconds', example='1'),
  successThreshold?: int32(name='successThreshold', example='2'),
  timeoutSeconds?: int32(name='timeoutSeconds', example='2'),
}

model CustomRuntimeConfig {
  args?: [ string ](name='args'),
  command?: [ string ](name='command'),
  healthCheckConfig?: CustomHealthCheckConfig(name='healthCheckConfig'),
  port?: int32(name='port', example='9000'),
}

model DNSOption {
  name?: string(name='name', example='ndots', maxLength=256),
  value?: string(name='value', example='2', maxLength=256),
}

model DeadLetterQueue {
  arn?: string(name='Arn'),
}

model DeliveryOption {
  concurrency?: long(name='concurrency', example='2'),
  eventSchema?: string(name='eventSchema', example='RawData'),
}

model DescribeRegionsOutput {
  regions?: {
    region?: [ 
      {
        localName?: string(name='LocalName'),
        regionId?: string(name='RegionId'),
      }
    ](name='Region'),
  }(name='Regions'),
}

model Destination {
  destination?: string(name='destination', example='acs:fc:cn-shanghai:xxx:functions/f1', maxLength=512),
}

model DestinationConfig {
  onFailure?: Destination(name='onFailure'),
  onSuccess?: Destination(name='onSuccess'),
}

model ElasticConfigStatus {
  currentError?: string(name='currentError'),
  currentInstances?: long(name='currentInstances'),
  functionArn?: string(name='functionArn'),
  minInstances?: long(name='minInstances'),
  residentPoolId?: string(name='residentPoolId'),
  scalingPolicies?: [
    ScalingPolicy
  ](name='scalingPolicies'),
  scheduledPolicies?: [
    ScheduledPolicy
  ](name='scheduledPolicies'),
}

model EqualRule {
  match: string(name='match', description='This parameter is required.', example='/old', maxLength=256),
  replacement: string(name='replacement', description='This parameter is required.', example='/new', maxLength=256),
}

model Error {
  code?: string(name='Code', example='FunctionNotFound'),
  message?: string(name='Message', example='function not found'),
  requestId?: string(name='RequestId', example='1-64e70cf1-5cbef92ea8fc8c42899cf5d1'),
}

model EventBridgeTriggerConfig {
  asyncInvocationType?: boolean(name='asyncInvocationType'),
  eventRuleFilterPattern?: string(name='eventRuleFilterPattern', example='{}'),
  eventSinkConfig?: EventSinkConfig(name='eventSinkConfig'),
  eventSourceConfig?: EventSourceConfig(name='eventSourceConfig'),
  runOptions?: RunOptions(name='runOptions'),
  triggerEnable?: boolean(name='triggerEnable', example='true'),
}

model EventSinkConfig {
  deliveryOption?: DeliveryOption(name='deliveryOption'),
}

model EventSourceConfig {
  eventSourceParameters?: EventSourceParameters(name='eventSourceParameters'),
  eventSourceType?: string(name='eventSourceType', example='MNS'),
}

model EventSourceParameters {
  sourceDTSParameters?: SourceDTSParameters(name='sourceDTSParameters'),
  sourceKafkaParameters?: SourceKafkaParameters(name='sourceKafkaParameters'),
  sourceMNSParameters?: SourceMNSParameters(name='sourceMNSParameters'),
  sourceMQTTParameters?: SourceMQTTParameters(name='sourceMQTTParameters'),
  sourceRabbitMQParameters?: SourceRabbitMQParameters(name='sourceRabbitMQParameters'),
  sourceRocketMQParameters?: SourceRocketMQParameters(name='sourceRocketMQParameters'),
}

model Filter {
  key?: Key(name='key'),
}

model Function {
  codeChecksum?: string(name='codeChecksum', example='2825179536350****'),
  codeSize?: long(name='codeSize', example='412'),
  cpu?: float(name='cpu', example='1'),
  createdTime?: string(name='createdTime', example='2023-04-01T08:15:27Z'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description', example='my function'),
  disableOndemand?: boolean(name='disableOndemand'),
  diskSize?: int32(name='diskSize', example='512'),
  enableLongLiving?: boolean(name='enableLongLiving', deprecated='true'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:123:functions/functionName'),
  functionId?: string(name='functionId', example='aa715851-1c20-4b89-a8fb-***'),
  functionName?: string(name='functionName', example='my-function-1'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler', example='index.handler'),
  instanceConcurrency?: int32(name='instanceConcurrency', example='1'),
  instanceIsolationMode?: string(name='instanceIsolationMode'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess', example='true'),
  invocationRestriction?: FunctionRestriction(name='invocationRestriction'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2023-05-01T08:15:27Z'),
  lastUpdateStatus?: string(name='lastUpdateStatus', example='InProgress'),
  lastUpdateStatusReason?: string(name='lastUpdateStatusReason', example='The system is currently processing the acceleration optimization for the image.'),
  lastUpdateStatusReasonCode?: string(name='lastUpdateStatusReasonCode', example='ImageOptimizing'),
  layers?: [
    FunctionLayer
  ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize', example='512'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  resourceGroupId?: string(name='resourceGroupId'),
  role?: string(name='role', example='acs:ram::188077086902****:role/fc-test'),
  runtime?: string(name='runtime', example='python3.10'),
  sessionAffinity?: string(name='sessionAffinity'),
  sessionAffinityConfig?: string(name='sessionAffinityConfig'),
  state?: string(name='state', example='Pending'),
  stateReason?: string(name='stateReason', example='Function creating'),
  stateReasonCode?: string(name='stateReasonCode', example='Creating'),
  tags?: [
    Tag
  ](name='tags'),
  timeout?: int32(name='timeout', example='60'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model FunctionLayer {
  arn?: string(name='arn', example='acs:fc:cn-beijing:186824xxxxxx:layers/fc_layer/versions/1'),
  size?: long(name='size', example='421'),
}

model FunctionRestriction {
  disable?: boolean(name='disable'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  reason?: string(name='reason'),
}

model GPUConfig {
  gpuMemorySize?: int32(name='gpuMemorySize', example='2048'),
  gpuType?: string(name='gpuType', example='fc.gpu.tesla.1', maxLength=128),
}

model GetInstanceLifecycleEventsOutput {
  events?: [
    InstanceEventItem
  ](name='events'),
  requestId?: string(name='requestId'),
}

model GetResourceTagsOutput {
  resouceType?: string(name='resouceType', example='ALIYUN::FC::FUNCTION'),
  resourceArn?: string(name='resourceArn', example='acs:fc:cn-shanghai:****:functions/demo'),
  tags?: map[string]string(name='tags'),
}

model GetScalingConfigStatusOutput {
  scalingConfigStatus?: ScalingConfigStatus(name='scalingConfigStatus'),
}

model HTTPTrigger {
  urlInternet?: string(name='urlInternet', example='https://svc-func-xxxxxxxx.cn-hangzhou.fcapp.run'),
  urlIntranet?: string(name='urlIntranet', example='https://svc-func-xxxxxxxx.cn-hangzhou-vpc.fcapp.run'),
}

model HTTPTriggerConfig {
  authConfig?: string(name='authConfig', example='{"JWKS":{"foo":"bar"},"TokenLookup":"header:Authorization:Bearer,cookie:AuthorizationCookie","ClaimPassBy":"query:uid:uid,header:name:name"}'),
  authType?: string(name='authType', example='anonymous'),
  disableURLInternet?: boolean(name='disableURLInternet', example='true'),
  methods?: [ string ](name='methods'),
}

model HeaderFieldSessionAffinityConfig {
  affinityHeaderFieldName?: string(name='affinityHeaderFieldName'),
  sessionConcurrencyPerInstance?: long(name='sessionConcurrencyPerInstance'),
  sessionIdleTimeoutInSeconds?: long(name='sessionIdleTimeoutInSeconds'),
  sessionTTLInSeconds?: long(name='sessionTTLInSeconds'),
}

model InputCodeLocation {
  checksum?: string(name='checksum', example='2825179536350****'),
  ossBucketName?: string(name='ossBucketName', example='demo-bucket', minLength=3, maxLength=63),
  ossObjectName?: string(name='ossObjectName', example='demo-object'),
  zipFile?: string(name='zipFile', example='UEsDBAoAAAAAANF'),
}

model InstanceEventItem {
  children?: [
    InstanceEventItem
  ](name='children'),
  level?: string(name='level'),
  message?: string(name='message'),
  time?: string(name='time'),
  type?: string(name='type'),
}

model InstanceInfo {
  createdTimeMs?: long(name='createdTimeMs'),
  destroyedTimeMs?: long(name='destroyedTimeMs'),
  instanceId?: string(name='instanceId', example='1ef6b6ff-7f7b-485e-ab49-501ac681****'),
  qualifier?: string(name='qualifier'),
  status?: string(name='status'),
  versionId?: string(name='versionId'),
}

model InstanceLifecycleConfig {
  initializer?: LifecycleHook(name='initializer'),
  preStop?: LifecycleHook(name='preStop'),
}

model JobConfig {
  maxRetryTime?: int32(name='maxRetryTime', example='3'),
  triggerInterval?: int32(name='triggerInterval', example='60'),
}

model Key {
  prefix?: string(name='prefix', example='serverless_'),
  suffix?: string(name='suffix', example='.zip'),
}

model Layer {
  acl?: string(name='acl', example='0'),
  code?: OutputCodeLocation(name='code'),
  codeChecksum?: string(name='codeChecksum', example='2825179536350****'),
  codeSize?: long(name='codeSize', example='421'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  createTime?: string(name='createTime', example='2023-03-30T11:08:00Z'),
  description?: string(name='description', example='My first layer', maxLength=256),
  layerName: string(name='layerName', description='This parameter is required.', example='MyLayer', minLength=1, maxLength=128),
  layerVersionArn?: string(name='layerVersionArn', example='acs:fc:cn-beijing:186824xxxxxx:layers/fc_layer/versions/1'),
  license?: string(name='license', example='Apache'),
  version?: int32(name='version', example='1'),
}

model LifecycleHook {
  command?: [ string ](name='command'),
  handler?: string(name='handler', example='index.initializer', maxLength=128),
  timeout?: int32(name='timeout', example='10'),
}

model ListAliasesOutput {
  aliases?: [
    Alias
  ](name='aliases'),
  nextToken?: string(name='nextToken', example='test'),
}

model ListAsyncInvokeConfigOutput {
  configs?: [
    AsyncConfig
  ](name='configs'),
  nextToken?: string(name='nextToken', example='8bj81uI8n****'),
}

model ListAsyncTaskOutput {
  nextToken?: string(name='nextToken'),
  tasks?: [
    AsyncTask
  ](name='tasks'),
}

model ListConcurrencyConfigsOutput {
  configs?: [
    ConcurrencyConfig
  ](name='configs'),
  nextToken?: string(name='nextToken', example='next_token'),
}

model ListCustomDomainOutput {
  customDomains?: [
    CustomDomain
  ](name='customDomains'),
  nextToken?: string(name='nextToken', example='next_domain_name'),
}

model ListElasticConfigsOutput {
  elasticConfigs?: [
    ElasticConfigStatus
  ](name='elasticConfigs'),
  nextToken?: string(name='nextToken'),
}

model ListFunctionsOutput {
  functions?: [
    Function
  ](name='functions'),
  nextToken?: string(name='nextToken', example='next_function_name'),
}

model ListInstancesOutput {
  instances?: [
    InstanceInfo
  ](name='instances'),
  requestId?: string(name='requestId'),
}

model ListLayerVersionOutput {
  layers?: [
    Layer
  ](name='layers'),
  nextVersion?: int32(name='nextVersion', example='10'),
}

model ListLayersOutput {
  layers?: [
    Layer
  ](name='layers'),
  nextToken?: string(name='nextToken', example='next-layer-name'),
}

model ListProvisionConfigsOutput {
  nextToken?: string(name='nextToken', example='next_token'),
  provisionConfigs?: [
    ProvisionConfig
  ](name='provisionConfigs'),
}

model ListResidentResourcePoolsOutput {
  nextToken?: string(name='nextToken'),
  residentResourcePools?: [
    ResidentResourcePool
  ](name='residentResourcePools'),
}

model ListScalingConfigStatusOutput {
  nextToken?: string(name='nextToken'),
  result?: [
    ScalingConfigStatus
  ](name='result'),
}

model ListTagResourcesOutput {
  nextToken?: string(name='NextToken', example='next_token'),
  requestId?: string(name='RequestId'),
  tagResources?: [
    TagResource
  ](name='TagResources'),
}

model ListTaggedResourcesOutput {
  nextToken?: string(name='nextToken', example='next_token'),
  resources?: [
    Resource
  ](name='resources'),
}

model ListTriggersOutput {
  nextToken?: string(name='nextToken', example='next_token'),
  triggers?: [
    Trigger
  ](name='triggers'),
}

model ListVersionsOutput {
  direction?: string(name='direction', example='FORWARD'),
  nextToken?: string(name='nextToken', example='3'),
  versions?: [
    Version
  ](name='versions'),
}

model ListVpcBindingsOutput {
  vpcIds?: [ string ](name='vpcIds'),
}

model LogConfig {
  enableInstanceMetrics?: boolean(name='enableInstanceMetrics', example='true'),
  enableRequestMetrics?: boolean(name='enableRequestMetrics', example='true'),
  logBeginRule?: string(name='logBeginRule', example='DefaultRegex'),
  logstore?: string(name='logstore', example='test-logstore', maxLength=63),
  project?: string(name='project', example='test-project', maxLength=63),
}

model MCPSSESessionAffinityConfig {
  sessionConcurrencyPerInstance?: long(name='sessionConcurrencyPerInstance'),
  sseEndpointPath?: string(name='sseEndpointPath'),
}

model MCPStreamableSessionAffinityConfig {
  sessionConcurrencyPerInstance?: long(name='sessionConcurrencyPerInstance'),
  sessionIdleTimeoutInSeconds?: long(name='sessionIdleTimeoutInSeconds'),
  sessionTTLInSeconds?: long(name='sessionTTLInSeconds'),
}

model MNSTopicTriggerConfig {
  filterTag?: string(name='filterTag', example='serverless'),
  notifyContentFormat?: string(name='notifyContentFormat', example='JSON'),
  notifyStrategy?: string(name='notifyStrategy', example='BACKOFF_RETRY'),
}

model NASConfig {
  groupId?: int32(name='groupId', example='100'),
  mountPoints?: [
    NASMountConfig
  ](name='mountPoints'),
  userId?: int32(name='userId', example='100'),
}

model NASMountConfig {
  enableTLS?: boolean(name='enableTLS'),
  mountDir?: string(name='mountDir', example='/home/test', maxLength=64),
  serverAddr?: string(name='serverAddr', example='***-uni85.cn-hangzhou.nas.com:/', maxLength=128),
}

model OSSMountConfig {
  mountPoints?: [
    OSSMountPoint
  ](name='mountPoints'),
}

model OSSMountPoint {
  bucketName?: string(name='bucketName', example='my-bucket', minLength=3, maxLength=64),
  bucketPath?: string(name='bucketPath', example='/my-dir', maxLength=128),
  endpoint?: string(name='endpoint', example='http://oss-cn-shanghai.aliyuncs.com', maxLength=128),
  mountDir?: string(name='mountDir', example='/mnt/dir', minLength=2, maxLength=64),
  readOnly?: boolean(name='readOnly', example='true'),
}

model OSSTriggerConfig {
  events?: [ string ](name='events'),
  filter?: Filter(name='filter'),
}

model OutputCodeLocation {
  location?: string(name='location', example='https://xyz.oss-cn-shanghai.aliyuncs.com/xxx/xxx/xxx'),
  repositoryType?: string(name='repositoryType', example='OSS'),
}

model OutputFuncCode {
  checksum?: string(name='checksum', example='1234567890'),
  url?: string(name='url', example='http://func-code.oss-cn-shanghai.aliyuncs.com/1a2b3c4d5e6f'),
}

model PathConfig {
  functionName: string(name='functionName', description='This parameter is required.', example='myFunction'),
  methods?: [ string ](name='methods'),
  path: string(name='path', description='This parameter is required.', example='/api/*', maxLength=2048),
  qualifier?: string(name='qualifier', example='myAlias'),
  rewriteConfig?: RewriteConfig(name='rewriteConfig'),
}

model ProvisionConfig {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', example='true'),
  alwaysAllocateGPU?: boolean(name='alwaysAllocateGPU', example='true'),
  current?: long(name='current', example='1'),
  currentError?: string(name='currentError', example='image not found'),
  defaultTarget?: long(name='defaultTarget', example='5'),
  functionArn?: string(name='functionArn', example='acs:fc:cn-shanghai:124:functions/myFunction/prod'),
  scheduledActions?: [
    ScheduledAction
  ](name='scheduledActions'),
  target?: long(name='target', example='5'),
  targetTrackingPolicies?: [
    TargetTrackingPolicy
  ](name='targetTrackingPolicies'),
}

model PublishVersionInput {
  description?: string(name='description', example='my version', maxLength=256),
}

model PutAsyncInvokeConfigInput {
  asyncTask?: boolean(name='asyncTask', example='true'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', example='300'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', example='3'),
}

model PutConcurrencyInput {
  reservedConcurrency: long(name='reservedConcurrency', description='This parameter is required.', example='10'),
}

model PutElasticConfigInput {
  minInstances?: long(name='minInstances'),
  residentPoolId?: string(name='residentPoolId'),
  scalingPolicies?: [
    ScalingPolicy
  ](name='scalingPolicies'),
  scheduledPolicies?: [
    ScheduledPolicy
  ](name='scheduledPolicies'),
}

model PutProvisionConfigInput {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', example='true'),
  alwaysAllocateGPU?: boolean(name='alwaysAllocateGPU', example='true'),
  defaultTarget?: long(name='defaultTarget'),
  scheduledActions?: [
    ScheduledAction
  ](name='scheduledActions'),
  target: long(name='target', description='This parameter is required.', example='1', deprecated='true'),
  targetTrackingPolicies?: [
    TargetTrackingPolicy
  ](name='targetTrackingPolicies'),
}

model PutScalingConfigInput {
  residentConfig?: ResidentConfig(name='residentConfig'),
  resourceType?: string(name='resourceType'),
}

model PutScalingConfigOutput {
  functionName?: string(name='functionName'),
  qualifier?: string(name='qualifier'),
  residentConfig?: ResidentConfig(name='residentConfig'),
  resourceType?: string(name='resourceType'),
}

model RegexRule {
  match: string(name='match', description='This parameter is required.', example='^/api/.+?/(.*)', maxLength=256),
  replacement: string(name='replacement', description='This parameter is required.', example='/api/v2/$1', maxLength=256),
}

model RegistryAuthConfig {
  password?: string(name='password', example='abc***'),
  userName?: string(name='userName', example='admin'),
}

model RegistryCertConfig {
  insecure?: boolean(name='insecure'),
  rootCaCertBase64?: string(name='rootCaCertBase64', example='cm9vdF9jYV9jZXJ0'),
}

model RegistryConfig {
  authConfig?: RegistryAuthConfig(name='authConfig'),
  certConfig?: RegistryCertConfig(name='certConfig'),
  networkConfig?: RegistryNetworkConfig(name='networkConfig'),
}

model RegistryNetworkConfig {
  securityGroupId?: string(name='securityGroupId', example='sg-xxxxxxxxxxxxxx'),
  vSwitchId?: string(name='vSwitchId', example='vsw-xxxxxxxxxxxxxx'),
  vpcId?: string(name='vpcId', example='vpc-xxxxxxxxxxxxxx'),
}

model ResidentConfig {
  count?: long(name='count'),
  poolId?: string(name='poolId'),
}

model ResidentResourceAllocation {
  functionName?: string(name='functionName', description='使用该资源池的函数名'),
  instanceCount?: int32(name='instanceCount', description='实例数'),
  qualifier?: string(name='qualifier', description='函数的别名'),
  totalCpuCores?: double(name='totalCpuCores', description='CPU 占用总核数'),
  totalDiskSize?: double(name='totalDiskSize', description='占用磁盘大小，单位 GB'),
  totalGpuMemorySize?: double(name='totalGpuMemorySize', description='占用显存大小，单位 GB'),
  totalMemorySize?: double(name='totalMemorySize', description='内存占用大小，单位 GB'),
}

model ResidentResourceAllocationStatus {
  lastAllocatedTime?: string(name='lastAllocatedTime'),
  lastAllocation?: ResidentResourceAllocation(name='lastAllocation'),
}

model ResidentResourceCapacity {
  gpuType?: string(name='gpuType', description='GPU 卡型'),
  totalCpuCores?: long(name='totalCpuCores', description='CPU 总核数'),
  totalDiskSize?: long(name='totalDiskSize', description='总磁盘大小，单位 GB'),
  totalGpuCards?: long(name='totalGpuCards', description='GPU总卡数'),
  totalGpuMemorySize?: long(name='totalGpuMemorySize', description='总显存大小，单位 GB'),
  totalMemorySize?: long(name='totalMemorySize', description='总内存大小，单位 GB'),
}

model ResidentResourcePool {
  allocationStatus?: ResidentResourceAllocationStatus(name='allocationStatus', description='资源池实时分配情况，包含每个函数的具体分配情况'),
  createdTime?: string(name='createdTime', description='代表创建时间的资源属性字段

Use the UTC time format: yyyy-MM-ddTHH:mmZ'),
  expireTime?: string(name='expireTime', description='资源池过期时间'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次修改时间，包含扩容、续费、更名等操作'),
  residentResourcePoolId?: string(name='residentResourcePoolId'),
  residentResourcePoolName?: string(name='residentResourcePoolName', description='代表资源名称的资源属性字段'),
  resourcePoolCapacity?: ResidentResourceCapacity(name='resourcePoolCapacity', description='资源池总体规格'),
  resourcePoolConfig?: ResidentResourceCapacity(name='resourcePoolConfig'),
}

model Resource {
  resouceType?: string(name='resouceType', example='ALIYUN::FC::FUNCTION'),
  resourceArn?: string(name='resourceArn', example='acs:fc:cn-shanghai:****:functions/demo'),
  tags?: map[string]string(name='tags'),
}

model RetryStrategy {
  pushRetryStrategy?: string(name='PushRetryStrategy', example='BACKOFF_RETRY'),
}

model RewriteConfig {
  equalRules?: [
    EqualRule
  ](name='equalRules'),
  regexRules?: [
    RegexRule
  ](name='regexRules'),
  wildcardRules?: [
    WildcardRule
  ](name='wildcardRules'),
}

model RouteConfig {
  routes?: [
    PathConfig
  ](name='routes'),
}

model RunOptions {
  batchWindow?: BatchWindow(name='batchWindow'),
  deadLetterQueue?: DeadLetterQueue(name='deadLetterQueue'),
  errorsTolerance?: string(name='errorsTolerance', example='ALL'),
  mode?: string(name='mode', example='event-streaming'),
  retryStrategy?: RetryStrategy(name='retryStrategy'),
}

model SLSTriggerConfig {
  enable?: boolean(name='enable', example='true'),
  functionParameter?: map[string]string(name='functionParameter'),
  jobConfig?: JobConfig(name='jobConfig'),
  logConfig?: SLSTriggerLogConfig(name='logConfig'),
  sourceConfig?: SourceConfig(name='sourceConfig'),
}

model SLSTriggerLogConfig {
  logstore?: string(name='logstore', example='my-sls-logstore-name'),
  project?: string(name='project', example='my-sls-project-name'),
}

model ScalingConfigStatus {
  functionName?: string(name='functionName'),
  qualifier?: string(name='qualifier'),
  residentConfig?: ResidentConfig(name='residentConfig'),
  resourceType?: string(name='resourceType'),
  scalingStatus?: ScalingStatus(name='scalingStatus'),
}

model ScalingPolicy {
  endTime?: string(name='endTime'),
  maxInstances?: long(name='maxInstances'),
  metricTarget?: float(name='metricTarget'),
  metricType?: string(name='metricType'),
  minInstances?: long(name='minInstances'),
  name?: string(name='name'),
  startTime?: string(name='startTime'),
  timeZone?: string(name='timeZone'),
}

model ScalingStatus {
  currentError?: string(name='currentError'),
  resourceCount?: long(name='resourceCount'),
}

model ScheduledAction {
  endTime?: string(name='endTime', example='2024-03-10T10:10:10'),
  name: string(name='name', description='This parameter is required.', example='test_1'),
  scheduleExpression: string(name='scheduleExpression', description='This parameter is required.', example='cron(0 0 22 * * *)'),
  startTime?: string(name='startTime', example='2023-03-10T10:10:10'),
  target: long(name='target', description='This parameter is required.', example='50'),
  timeZone?: string(name='timeZone', example='Asia/Shanghai'),
}

model ScheduledPolicy {
  endTime?: string(name='endTime'),
  name?: string(name='name'),
  scheduleExpression?: string(name='scheduleExpression'),
  startTime?: string(name='startTime'),
  target?: long(name='target'),
  timeZone?: string(name='timeZone'),
}

model SourceConfig {
  logstore?: string(name='logstore', example='my-sls-logstore-name'),
  startTime?: long(name='startTime', example='1704790317'),
}

model SourceDTSParameters {
  brokerUrl?: string(name='BrokerUrl', example='dts-cn-shanghai-vpc.com:18003'),
  initCheckPoint?: int32(name='InitCheckPoint', example='1677340805'),
  password?: string(name='Password', example='dtsTest123'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  sid?: string(name='Sid', example='dtse34j22j025a****'),
  taskId?: string(name='TaskId', example='e34z2gm325q****'),
  topic?: string(name='Topic', example='cn_shanghai_vpc_rm_uf6398ykj0218****_dts_trigger_upgrade_from_old_version2'),
  username?: string(name='Username', example='dts_trigger'),
}

model SourceKafkaParameters {
  consumerGroup?: string(name='ConsumerGroup', example='DEFAULT_GROUP'),
  instanceId?: string(name='InstanceId', example='r-8vb64581862c****'),
  network?: string(name='Network', example='Default'),
  offsetReset?: string(name='OffsetReset', example='latest'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  securityGroupId?: string(name='SecurityGroupId', example='sg-bp1iv19sp1msc7zot4****'),
  topic?: string(name='Topic', example='popvip_center_robot_order'),
  vSwitchIds?: string(name='VSwitchIds', example='vsw-bp179l3llg3jjxwrq72****'),
  vpcId?: string(name='VpcId', example='vpc-8vblalsi0vbhizr77****'),
}

model SourceMNSParameters {
  isBase64Decode?: boolean(name='IsBase64Decode', example='true'),
  queueName?: string(name='QueueName', example='demo'),
  regionId?: string(name='RegionId', example='cn-shanghai'),
}

model SourceMQTTParameters {
  instanceId?: string(name='InstanceId', example='mqtt-****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  topic?: string(name='Topic', example='testTopic'),
}

model SourceRabbitMQParameters {
  instanceId?: string(name='InstanceId', example='amqp-cn-nif22u74****'),
  queueName?: string(name='QueueName', example='demo'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  virtualHostName?: string(name='VirtualHostName', example='eb-connect'),
}

model SourceRocketMQParameters {
  authType?: string(name='AuthType', example='ACL'),
  filterType?: string(name='FilterType', example='Tag'),
  groupID?: string(name='GroupID', example='GID_group1'),
  instanceEndpoint?: string(name='InstanceEndpoint', example='registry-vpc.cn-hangzhou.aliyuncs.com'),
  instanceId?: string(name='InstanceId', example='MQ_INST_164901546557****_BAAN****'),
  instanceNetwork?: string(name='InstanceNetwork', example='PrivateNetwork'),
  instancePassword?: string(name='InstancePassword', example='123'),
  instanceSecurityGroupId?: string(name='InstanceSecurityGroupId', example='sg-hp35r2hc3a3sv8q2****'),
  instanceType?: string(name='InstanceType', example='Cloud_5'),
  instanceUsername?: string(name='InstanceUsername', example='6W0xz2uPfiwp****'),
  instanceVSwitchIds?: string(name='InstanceVSwitchIds', example='vsw-uf6gwtbn6etadpvz7****'),
  instanceVpcId?: string(name='InstanceVpcId', example='vpc-uf6of9452b2pba82c****'),
  offset?: string(name='Offset', example='CONSUME_FROM_TIMESTAMP'),
  regionId?: string(name='RegionId', example='cn-shanghai'),
  tag?: string(name='Tag', example='test'),
  timestamp?: int32(name='Timestamp', example='1636597951964'),
  topic?: string(name='Topic', example='myTopic'),
}

model TLSConfig {
  cipherSuites: [ string ](name='cipherSuites', description='This parameter is required.'),
  maxVersion?: string(name='maxVersion', example='TLSv1.3'),
  minVersion: string(name='minVersion', description='This parameter is required.', example='TLSv1.0'),
}

model Tag {
  key?: string(name='Key', example='k1'),
  value?: string(name='Value', example='v1'),
}

model TagResource {
  resourceId?: string(name='ResourceId', example='acs:fc:cn-shanghai:****:functions/demo'),
  resourceType?: string(name='ResourceType', example='ALIYUN::FC::FUNCTION'),
  tagKey?: string(name='TagKey', example='key1'),
  tagValue?: string(name='TagValue', example='key1'),
}

model TagResourceInput {
  resourceArn: string(name='resourceArn', description='This parameter is required.', example='acs:fc:cn-shanghai:xxx:functions/f1', minLength=1),
  tags: map[string]string(name='tags', description='This parameter is required.'),
}

model TagResourcesInput {
  resourceId: [ string ](name='ResourceId', description='This parameter is required.'),
  resourceType?: string(name='ResourceType', example='FUNCTION'),
  tag: [
    Tag
  ](name='Tag', description='This parameter is required.'),
}

model TargetTrackingPolicy {
  endTime?: string(name='endTime', example='2024-03-10T10:10:10'),
  maxCapacity: long(name='maxCapacity', description='This parameter is required.', example='10'),
  metricTarget: float(name='metricTarget', description='This parameter is required.', example='0.6'),
  metricType: string(name='metricType', description='This parameter is required.', example='CPUUtilization'),
  minCapacity: long(name='minCapacity', description='This parameter is required.', example='1'),
  name: string(name='name', description='This parameter is required.', example='test_1'),
  startTime?: string(name='startTime', example='2023-03-10T10:10:10'),
  timeZone?: string(name='timeZone', example='Asia/Shanghai'),
}

model TimerTriggerConfig {
  cronExpression?: string(name='cronExpression', example='0 0 4 * * *'),
  enable?: boolean(name='enable', example='true'),
  payload?: string(name='payload', example='{"workflowInstanceId":"39639"}'),
}

model TracingConfig {
  params?: map[string]string(name='params'),
  type?: string(name='type', example='Jaeger'),
}

model Trigger {
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  httpTrigger?: HTTPTrigger(name='httpTrigger'),
  invocationRole?: string(name='invocationRole'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  qualifier?: string(name='qualifier'),
  sourceArn?: string(name='sourceArn'),
  status?: string(name='status'),
  targetArn?: string(name='targetArn'),
  triggerConfig?: string(name='triggerConfig'),
  triggerId?: string(name='triggerId'),
  triggerName?: string(name='triggerName'),
  triggerType?: string(name='triggerType'),
}

model UpdateAliasInput {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  description?: string(name='description', example='my alias', maxLength=256),
  versionId?: string(name='versionId', example='1', minLength=1, maxLength=10),
}

model UpdateCustomDomainInput {
  authConfig?: AuthConfig(name='authConfig'),
  certConfig?: CertConfig(name='certConfig'),
  protocol?: string(name='protocol', example='HTTP'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
  wafConfig?: WAFConfig(name='wafConfig'),
}

model UpdateFunctionInput {
  code?: InputCodeLocation(name='code'),
  cpu?: float(name='cpu', example='1'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description', example='my function', maxLength=256),
  disableOndemand?: boolean(name='disableOndemand'),
  diskSize?: int32(name='diskSize', example='512'),
  enableLongLiving?: boolean(name='enableLongLiving', deprecated='true'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  gpuConfig?: GPUConfig(name='gpuConfig'),
  handler?: string(name='handler', example='index.handler', minLength=1, maxLength=128),
  instanceConcurrency?: int32(name='instanceConcurrency', example='1'),
  instanceIsolationMode?: string(name='instanceIsolationMode'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  internetAccess?: boolean(name='internetAccess', example='true'),
  layers?: [ string ](name='layers'),
  logConfig?: LogConfig(name='logConfig'),
  memorySize?: int32(name='memorySize', example='512'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role', example='acs:ram::188077086902****:role/fc-test', maxLength=300),
  runtime?: string(name='runtime'),
  sessionAffinity?: string(name='sessionAffinity', example='MCP_SSE'),
  sessionAffinityConfig?: string(name='sessionAffinityConfig'),
  timeout?: int32(name='timeout', example='60'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model UpdateResidentResourcePoolInput {
  name?: string(name='name'),
}

model UpdateTriggerInput {
  description?: string(name='description', example='trigger for test', maxLength=256),
  invocationRole?: string(name='invocationRole', example='acs:ram::1234567890:role/fc-test', maxLength=300),
  qualifier?: string(name='qualifier', example='LATEST'),
  triggerConfig?: string(name='triggerConfig', example='{"events":["oss:ObjectCreated:*"],"filter":{"key":{"prefix":"/prefix","suffix":".zip"}}}'),
}

model VPCConfig {
  role?: string(name='role', example='acs:ram::188077086902****:role/fc-test'),
  securityGroupId?: string(name='securityGroupId', example='sg-bp18hj1wtxgy3b0***', maxLength=50),
  vSwitchIds?: [ string ](name='vSwitchIds'),
  vpcId?: string(name='vpcId', example='vpc-***', maxLength=50),
}

model Version {
  createdTime?: string(name='createdTime', example='2006-01-02T15:04:05Z07:00'),
  description?: string(name='description', example='my version'),
  lastModifiedTime?: string(name='lastModifiedTime', example='2006-01-02T15:04:05Z07:00'),
  versionId?: string(name='versionId', example='1'),
}

model WAFConfig {
  enableWAF?: boolean(name='enableWAF', example='true'),
}

model WildcardRule {
  match: string(name='match', description='This parameter is required.', example='/api/*', maxLength=256),
  replacement: string(name='replacement', description='This parameter is required.', example='/$1', maxLength=256),
}

model ChangeResourceGroupRequest {
  body?: ChangeResourceGroupInput(name='body', position='Body'),
}

model ChangeResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeResourceGroupOutput  
}

/**
  * @param request  the request parameters of ChangeResourceGroup  ChangeResourceGroupRequest
  * @return ChangeResourceGroupResponse
 */
async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ChangeResourceGroup', 'PUT', '/2023-03-30/resource-groups', 'json', false, 'json', request);
}

model CreateAliasRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  body: CreateAliasInput(name='body', description='The request parameters for creating an alias.

This parameter is required.', position='Body'),
}

model CreateAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Alias  
}

/**
  * @param request  the request parameters of CreateAlias  CreateAliasRequest
  * @return CreateAliasResponse
 */
async function createAlias(request: CreateAliasRequest): CreateAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateAlias', 'POST', '/2023-03-30/functions/{functionName}/aliases', 'json', false, 'json', request);
}

model CreateCustomDomainRequest {
  body: CreateCustomDomainInput(name='body', description='The information about the custom domain name.

This parameter is required.', position='Body'),
}

model CreateCustomDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CustomDomain  
}

/**
  * @description If you want to use a fixed domain name to access an application or function in a production environment of Function Compute, or to resolve the issue of forced downloads when accessing an HTTP trigger, you can bind a custom domain name to the application or function.
  * @param request  the request parameters of CreateCustomDomain  CreateCustomDomainRequest
  * @return CreateCustomDomainResponse
 */
async function createCustomDomain(request: CreateCustomDomainRequest): CreateCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateCustomDomain', 'POST', '/2023-03-30/custom-domains', 'json', false, 'json', request);
}

model CreateFunctionRequest {
  body: CreateFunctionInput(name='body', description='The information about function configurations.

This parameter is required.', position='Body'),
}

model CreateFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Function  
}

/**
  * @description Resources of Function Compute are scheduled and run based on functions. A function usually refers to a code snippet that is written by a user and can be independently executed to respond to events and requests.
  * @param request  the request parameters of CreateFunction  CreateFunctionRequest
  * @return CreateFunctionResponse
 */
async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateFunction', 'POST', '/2023-03-30/functions', 'json', false, 'json', request);
}

model CreateLayerVersionRequest {
  layerName: string(name='layerName', description='The name of the layer.

This parameter is required.', example='my-layer', position='Path'),
  body: CreateLayerVersionInput(name='body', description='The information about layer configurations.

This parameter is required.', position='Body'),
}

model CreateLayerVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Layer  
}

/**
  * @param request  the request parameters of CreateLayerVersion  CreateLayerVersionRequest
  * @return CreateLayerVersionResponse
 */
async function createLayerVersion(request: CreateLayerVersionRequest): CreateLayerVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateLayerVersion', 'POST', '/2023-03-30/layers/{layerName}/versions', 'json', false, 'json', request);
}

model CreateTriggerRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  body: CreateTriggerInput(name='body', description='The trigger configurations.

This parameter is required.', position='Body'),
}

model CreateTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Trigger  
}

/**
  * @param request  the request parameters of CreateTrigger  CreateTriggerRequest
  * @return CreateTriggerResponse
 */
async function createTrigger(request: CreateTriggerRequest): CreateTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateTrigger', 'POST', '/2023-03-30/functions/{functionName}/triggers', 'json', false, 'json', request);
}

model CreateVpcBindingRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  body: CreateVpcBindingInput(name='body', description='The VPC binding configurations.

This parameter is required.', position='Body'),
}

model CreateVpcBindingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of CreateVpcBinding  CreateVpcBindingRequest
  * @return CreateVpcBindingResponse
 */
async function createVpcBinding(request: CreateVpcBindingRequest): CreateVpcBindingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateVpcBinding', 'POST', '/2023-03-30/functions/{functionName}/vpc-bindings', 'none', false, 'json', request);
}

model DeleteAliasRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  aliasName: string(name='aliasName', description='The function alias.

This parameter is required.', example='my-alias', position='Path'),
}

model DeleteAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of DeleteAlias  DeleteAliasRequest
  * @return DeleteAliasResponse
 */
async function deleteAlias(request: DeleteAliasRequest): DeleteAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteAlias', 'DELETE', '/2023-03-30/functions/{functionName}/aliases/{aliasName}', 'none', false, 'json', request);
}

model DeleteAsyncInvokeConfigRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST', position='Query'),
}

model DeleteAsyncInvokeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of DeleteAsyncInvokeConfig  DeleteAsyncInvokeConfigRequest
  * @return DeleteAsyncInvokeConfigResponse
 */
async function deleteAsyncInvokeConfig(request: DeleteAsyncInvokeConfigRequest): DeleteAsyncInvokeConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteAsyncInvokeConfig', 'DELETE', '/2023-03-30/functions/{functionName}/async-invoke-config', 'none', false, 'json', request);
}

model DeleteConcurrencyConfigRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
}

model DeleteConcurrencyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of DeleteConcurrencyConfig  DeleteConcurrencyConfigRequest
  * @return DeleteConcurrencyConfigResponse
 */
async function deleteConcurrencyConfig(request: DeleteConcurrencyConfigRequest): DeleteConcurrencyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteConcurrencyConfig', 'DELETE', '/2023-03-30/functions/{functionName}/concurrency', 'none', false, 'json', request);
}

model DeleteCustomDomainRequest {
  domainName: string(name='domainName', description='The domain name.

This parameter is required.', example='foo.bar.com', position='Path'),
}

model DeleteCustomDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of DeleteCustomDomain  DeleteCustomDomainRequest
  * @return DeleteCustomDomainResponse
 */
async function deleteCustomDomain(request: DeleteCustomDomainRequest): DeleteCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteCustomDomain', 'DELETE', '/2023-03-30/custom-domains/{domainName}', 'none', false, 'json', request);
}

model DeleteFunctionRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
}

model DeleteFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of DeleteFunction  DeleteFunctionRequest
  * @return DeleteFunctionResponse
 */
async function deleteFunction(request: DeleteFunctionRequest): DeleteFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteFunction', 'DELETE', '/2023-03-30/functions/{functionName}', 'none', false, 'json', request);
}

model DeleteFunctionVersionRequest {
  functionName: string(name='functionName', description='函数版本。

This parameter is required.', example='my-func', position='Path'),
  versionId: int32(name='versionId', description='This parameter is required.', example='1', position='Path'),
}

model DeleteFunctionVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of DeleteFunctionVersion  DeleteFunctionVersionRequest
  * @return DeleteFunctionVersionResponse
 */
async function deleteFunctionVersion(request: DeleteFunctionVersionRequest): DeleteFunctionVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteFunctionVersion', 'DELETE', '/2023-03-30/functions/{functionName}/versions/{versionId}', 'none', false, 'json', request);
}

model DeleteLayerVersionRequest {
  layerName: string(name='layerName', description='The layer name.

This parameter is required.', example='my-layer', position='Path'),
  version: int32(name='version', description='The layer version.

This parameter is required.', example='1', position='Path'),
}

model DeleteLayerVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of DeleteLayerVersion  DeleteLayerVersionRequest
  * @return DeleteLayerVersionResponse
 */
async function deleteLayerVersion(request: DeleteLayerVersionRequest): DeleteLayerVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteLayerVersion', 'DELETE', '/2023-03-30/layers/{layerName}/versions/{version}', 'none', false, 'json', request);
}

model DeleteProvisionConfigRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  qualifier?: string(name='qualifier', description='The function alias.', example='LATEST', position='Query'),
}

model DeleteProvisionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of DeleteProvisionConfig  DeleteProvisionConfigRequest
  * @return DeleteProvisionConfigResponse
 */
async function deleteProvisionConfig(request: DeleteProvisionConfigRequest): DeleteProvisionConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteProvisionConfig', 'DELETE', '/2023-03-30/functions/{functionName}/provision-config', 'none', false, 'json', request);
}

model DeleteTriggerRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  triggerName: string(name='triggerName', description='The trigger name.

This parameter is required.', example='my-trigger', position='Path'),
}

model DeleteTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of DeleteTrigger  DeleteTriggerRequest
  * @return DeleteTriggerResponse
 */
async function deleteTrigger(request: DeleteTriggerRequest): DeleteTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteTrigger', 'DELETE', '/2023-03-30/functions/{functionName}/triggers/{triggerName}', 'none', false, 'json', request);
}

model DeleteVpcBindingRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  vpcId: string(name='vpcId', description='The ID of the virtual private cloud (VPC).

This parameter is required.', example='vpc-bp106zxlfj1fqc9', position='Path'),
}

model DeleteVpcBindingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of DeleteVpcBinding  DeleteVpcBindingRequest
  * @return DeleteVpcBindingResponse
 */
async function deleteVpcBinding(request: DeleteVpcBindingRequest): DeleteVpcBindingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteVpcBinding', 'DELETE', '/2023-03-30/functions/{functionName}/vpc-bindings/{vpcId}', 'none', false, 'json', request);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', example='zh-CN', position='Query'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsOutput  
}

/**
  * @param request  the request parameters of DescribeRegions  DescribeRegionsRequest
  * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeRegions', 'GET', '/2023-03-30/regions', 'json', false, 'json', request);
}

model DisableFunctionInvocationRequest {
  functionName?: string(name='functionName', description='The name of the function whose invocation you want to disable.', example='helloworld', position='Path'),
  abortOngoingRequest?: boolean(name='abortOngoingRequest', description='Specifies whether to immediately terminate all ongoing requests.', example='false', position='Body'),
  reason?: string(name='reason', description='The reason for disabling the function\\"s invocation.', position='Body'),
}

model DisableFunctionInvocationResponseBody = {
  success?: boolean(name='success', description='Indicates whether the request is successful.', example='true'),
}

model DisableFunctionInvocationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableFunctionInvocationResponseBody(name='body'),
}

/**
  * @description Exercise caution when you call this operation on a function in a production environment, as improper deactivation may lead to business disruptions.
  * @param request  the request parameters of DisableFunctionInvocation  DisableFunctionInvocationRequest
  * @return DisableFunctionInvocationResponse
 */
async function disableFunctionInvocation(request: DisableFunctionInvocationRequest): DisableFunctionInvocationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DisableFunctionInvocation', 'POST', '/2023-03-30/functions/{functionName}/invoke/disable', 'json', false, 'json', request);
}

model EnableFunctionInvocationRequest {
  functionName?: string(name='functionName', position='Path'),
}

model EnableFunctionInvocationResponseBody = {
  success?: boolean(name='success', example='true'),
}

model EnableFunctionInvocationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableFunctionInvocationResponseBody(name='body'),
}

/**
  * @param request  the request parameters of EnableFunctionInvocation  EnableFunctionInvocationRequest
  * @return EnableFunctionInvocationResponse
 */
async function enableFunctionInvocation(request: EnableFunctionInvocationRequest): EnableFunctionInvocationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'EnableFunctionInvocation', 'POST', '/2023-03-30/functions/{functionName}/invoke/enable', 'json', false, 'json', request);
}

model GetAliasRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  aliasName: string(name='aliasName', description='The function alias.

This parameter is required.', example='my-alias', position='Path'),
}

model GetAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Alias  
}

/**
  * @param request  the request parameters of GetAlias  GetAliasRequest
  * @return GetAliasResponse
 */
async function getAlias(request: GetAliasRequest): GetAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetAlias', 'GET', '/2023-03-30/functions/{functionName}/aliases/{aliasName}', 'json', false, 'json', request);
}

model GetAsyncInvokeConfigRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST', position='Query'),
}

model GetAsyncInvokeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AsyncConfig  
}

/**
  * @param request  the request parameters of GetAsyncInvokeConfig  GetAsyncInvokeConfigRequest
  * @return GetAsyncInvokeConfigResponse
 */
async function getAsyncInvokeConfig(request: GetAsyncInvokeConfigRequest): GetAsyncInvokeConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetAsyncInvokeConfig', 'GET', '/2023-03-30/functions/{functionName}/async-invoke-config', 'json', false, 'json', request);
}

model GetAsyncTaskRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  taskId: string(name='taskId', description='The ID of the asynchronous task.

This parameter is required.', example='e026ae92-61e5-472f-b32d-1c9e3c4e****', position='Path'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST', position='Query'),
}

model GetAsyncTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AsyncTask  
}

/**
  * @param request  the request parameters of GetAsyncTask  GetAsyncTaskRequest
  * @return GetAsyncTaskResponse
 */
async function getAsyncTask(request: GetAsyncTaskRequest): GetAsyncTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetAsyncTask', 'GET', '/2023-03-30/functions/{functionName}/async-tasks/{taskId}', 'json', false, 'json', request);
}

model GetConcurrencyConfigRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
}

model GetConcurrencyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConcurrencyConfig  
}

/**
  * @param request  the request parameters of GetConcurrencyConfig  GetConcurrencyConfigRequest
  * @return GetConcurrencyConfigResponse
 */
async function getConcurrencyConfig(request: GetConcurrencyConfigRequest): GetConcurrencyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetConcurrencyConfig', 'GET', '/2023-03-30/functions/{functionName}/concurrency', 'json', false, 'json', request);
}

model GetCustomDomainRequest {
  domainName: string(name='domainName', description='The domain name.

This parameter is required.', example='foo.bar.com', position='Path'),
}

model GetCustomDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CustomDomain  
}

/**
  * @param request  the request parameters of GetCustomDomain  GetCustomDomainRequest
  * @return GetCustomDomainResponse
 */
async function getCustomDomain(request: GetCustomDomainRequest): GetCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetCustomDomain', 'GET', '/2023-03-30/custom-domains/{domainName}', 'json', false, 'json', request);
}

model GetFunctionRequest {
  functionName: string(name='functionName', description='Ready

This parameter is required.', example='my-func', position='Path'),
  qualifier?: string(name='qualifier', description='2023-03-10T10:10:10Z', example='LATEST', position='Query'),
}

model GetFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Function  
}

/**
  * @param request  the request parameters of GetFunction  GetFunctionRequest
  * @return GetFunctionResponse
 */
async function getFunction(request: GetFunctionRequest): GetFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunction', 'GET', '/2023-03-30/functions/{functionName}', 'json', false, 'json', request);
}

model GetFunctionCodeRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST', position='Query'),
}

model GetFunctionCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OutputFuncCode  
}

/**
  * @param request  the request parameters of GetFunctionCode  GetFunctionCodeRequest
  * @return GetFunctionCodeResponse
 */
async function getFunctionCode(request: GetFunctionCodeRequest): GetFunctionCodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunctionCode', 'GET', '/2023-03-30/functions/{functionName}/code', 'json', false, 'json', request);
}

model GetLayerVersionRequest {
  layerName: string(name='layerName', description='The name of the layer.

This parameter is required.', example='my-layer', position='Path'),
  version: int32(name='version', description='The version of the layer.

This parameter is required.', example='1', position='Path'),
}

model GetLayerVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Layer  
}

/**
  * @param request  the request parameters of GetLayerVersion  GetLayerVersionRequest
  * @return GetLayerVersionResponse
 */
async function getLayerVersion(request: GetLayerVersionRequest): GetLayerVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLayerVersion', 'GET', '/2023-03-30/layers/{layerName}/versions/{version}', 'json', false, 'json', request);
}

model GetLayerVersionByArnRequest {
  arn: string(name='arn', description='The Alibaba Cloud Resource Name (ARN) of the layer.

This parameter is required.', example='acs:fc:cn-shanghai:1234:layers/my-layer/versions/1', position='Path'),
}

model GetLayerVersionByArnResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Layer  
}

/**
  * @param request  the request parameters of GetLayerVersionByArn  GetLayerVersionByArnRequest
  * @return GetLayerVersionByArnResponse
 */
async function getLayerVersionByArn(request: GetLayerVersionByArnRequest): GetLayerVersionByArnResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLayerVersionByArn', 'GET', '/2023-03-30/layerarn/{arn}', 'json', false, 'json', request);
}

model GetProvisionConfigRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  qualifier?: string(name='qualifier', description='The function alias.', example='LATEST', position='Query'),
}

model GetProvisionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ProvisionConfig  
}

/**
  * @param request  the request parameters of GetProvisionConfig  GetProvisionConfigRequest
  * @return GetProvisionConfigResponse
 */
async function getProvisionConfig(request: GetProvisionConfigRequest): GetProvisionConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetProvisionConfig', 'GET', '/2023-03-30/functions/{functionName}/provision-config', 'json', false, 'json', request);
}

model GetTriggerRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  triggerName: string(name='triggerName', description='The trigger name.

This parameter is required.', example='my-trigger', position='Path'),
}

model GetTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Trigger  
}

/**
  * @param request  the request parameters of GetTrigger  GetTriggerRequest
  * @return GetTriggerResponse
 */
async function getTrigger(request: GetTriggerRequest): GetTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTrigger', 'GET', '/2023-03-30/functions/{functionName}/triggers/{triggerName}', 'json', false, 'json', request);
}

model InvokeFunctionRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  body?: readable(name='body', description='The request parameters of function invocation.', example='event', position='Body'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST', position='Query'),
  xFcAsyncTaskId?: string(name='x-fc-async-task-id', description='The ID of the asynchronous task. You must enable the asynchronous task feature in advance.

>  If you use an SDK to invoke a function, we recommend that you specify a business-related ID to facilitate subsequent operations. For example, a video processing function can use video file names as invocation IDs. This way, you can easily check whether a video is successfully processed or terminated before it is processed. The ID can start only with letters or underscores. An ID can contain *letters, digits (0 - 9), underscores*, and hyphens (-). It can be up to 128 characters in length. If you do not specify the ID of the asynchronous invocation, the system automatically generates an ID.', example='test-id', position='Header'),
  xFcInvocationType?: string(name='x-fc-invocation-type', description='The type of function invocation. Valid values: Sync and Async.', example='Sync', position='Header'),
  xFcLogType?: string(name='x-fc-log-type', description='The log type of function invocation. Valid values: None and Tail.', example='Tail', position='Header'),
}

model InvokeFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: readable(name='body'),
}

/**
  * @param request  the request parameters of InvokeFunction  InvokeFunctionRequest
  * @return InvokeFunctionResponse
 */
async function invokeFunction(request: InvokeFunctionRequest): InvokeFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InvokeFunction', 'POST', '/2023-03-30/functions/{functionName}/invocations', 'binary', false, 'json', request);
}

async function invokeFunctionWithRequestBody(request: InvokeFunctionRequest, requestBody: RequestBody): InvokeFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.doRequestBody('RESTFUL', 'InvokeFunction', 'POST', '/2023-03-30/functions/{functionName}/invocations', 'binary', false, 'json', request, requestBody);
}

async function invokeFunctionWithAsyncResponseHandler(request: InvokeFunctionRequest, responseHandler: AsyncResponseHandler): InvokeFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.doResponseHandler('RESTFUL', 'InvokeFunction', 'POST', '/2023-03-30/functions/{functionName}/invocations', 'binary', false, 'json', request, responseHandler);
}

model ListAliasesRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  limit?: int32(name='limit', description='The number of aliases returned.', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM=', position='Query'),
  prefix?: string(name='prefix', description='The alias prefix.', example='my-alias', position='Query'),
}

model ListAliasesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAliasesOutput  
}

/**
  * @param request  the request parameters of ListAliases  ListAliasesRequest
  * @return ListAliasesResponse
 */
async function listAliases(request: ListAliasesRequest): ListAliasesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAliases', 'GET', '/2023-03-30/functions/{functionName}/aliases', 'json', false, 'json', request);
}

model ListAsyncInvokeConfigsRequest {
  functionName?: string(name='functionName', description='The function name. If you do not configure this parameter, the asynchronous invocation configurations of all functions are displayed.', example='my-func', position='Query'),
  limit?: int32(name='limit', description='The maximum number of entries to be returned.', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='The paging information. This parameter specifies the start point of the query.', example='MTIzNCNhYmM=', position='Query'),
}

model ListAsyncInvokeConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAsyncInvokeConfigOutput  
}

/**
  * @param request  the request parameters of ListAsyncInvokeConfigs  ListAsyncInvokeConfigsRequest
  * @return ListAsyncInvokeConfigsResponse
 */
async function listAsyncInvokeConfigs(request: ListAsyncInvokeConfigsRequest): ListAsyncInvokeConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAsyncInvokeConfigs', 'GET', '/2023-03-30/async-invoke-configs', 'json', false, 'json', request);
}

model ListAsyncTasksRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  includePayload?: boolean(name='includePayload', description='Specifies whether to return input parameters of the asynchronous tasks. Valid values:

*   true: returns the `invocationPayload` parameter in the response.
*   false: does not return the `invocationPayload` parameter in the response.

>  The `invocationPayload` parameter indicates the input parameters of an asynchronous task.', example='true', position='Query'),
  limit?: int32(name='limit', description='The number of asynchronous tasks to return. The default value is 20. Valid values: [1,100].', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='MTIzNCNhYmM=', position='Query'),
  prefix?: string(name='prefix', description='The ID prefix of asynchronous tasks. If this parameter is specified, a list of asynchronous tasks whose IDs match the prefix is returned.', example='job-', position='Query'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST', position='Query'),
  sortOrderByTime?: string(name='sortOrderByTime', description='The order in which the returned asynchronous tasks are sorted.

*   asc: in ascending order.
*   desc: in descending order.', example='asc', position='Query'),
  startedTimeBegin?: long(name='startedTimeBegin', description='The start time of the period during which the asynchronous tasks are initiated.', example='1640966400000', position='Query'),
  startedTimeEnd?: long(name='startedTimeEnd', description='The end time of the period during which the asynchronous tasks are initiated.', example='1640966400000', position='Query'),
  status?: string(name='status', description='The state of asynchronous tasks. The following items list the states of an asynchronous task:

*   Enqueued: The asynchronous invocation is enqueued and waiting to be executed.
*   Dequeued: The asynchronous invocation is dequeued and waiting to be triggered.
*   Running: The invocation is being executed.
*   Succeeded: The invocation is successful.
*   Failed: The invocation fails.
*   Stopped: The invocation is terminated.
*   Stopping: The invocation is being terminated.
*   Expired: The maximum validity period of messages is specified for asynchronous invocation. The invocation is discarded and not executed because the specified maximum validity period of messages expires.
*   Invalid: The invocation is invalid and not executed due to specific reasons. For example, the function is deleted.
*   Retrying: The asynchronous invocation is being retried due to an execution error.', example='Running', position='Query'),
}

model ListAsyncTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAsyncTaskOutput  
}

/**
  * @param request  the request parameters of ListAsyncTasks  ListAsyncTasksRequest
  * @return ListAsyncTasksResponse
 */
async function listAsyncTasks(request: ListAsyncTasksRequest): ListAsyncTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAsyncTasks', 'GET', '/2023-03-30/functions/{functionName}/async-tasks', 'json', false, 'json', request);
}

model ListConcurrencyConfigsRequest {
  functionName?: string(name='functionName', description='The function name. If you leave this parameter empty, the concurrency configurations of all functions are returned.', example='my-func', position='Query'),
  limit?: int32(name='limit', description='The maximum number of entries returned.', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM=', position='Query'),
}

model ListConcurrencyConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListConcurrencyConfigsOutput  
}

/**
  * @param request  the request parameters of ListConcurrencyConfigs  ListConcurrencyConfigsRequest
  * @return ListConcurrencyConfigsResponse
 */
async function listConcurrencyConfigs(request: ListConcurrencyConfigsRequest): ListConcurrencyConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListConcurrencyConfigs', 'GET', '/2023-03-30/concurrency-configs', 'json', false, 'json', request);
}

model ListCustomDomainsRequest {
  limit?: int32(name='limit', description='The number of custom domain names returned.', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM=', position='Query'),
  prefix?: string(name='prefix', description='The domain name prefix.', example='foo', position='Query'),
}

model ListCustomDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCustomDomainOutput  
}

/**
  * @param request  the request parameters of ListCustomDomains  ListCustomDomainsRequest
  * @return ListCustomDomainsResponse
 */
async function listCustomDomains(request: ListCustomDomainsRequest): ListCustomDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListCustomDomains', 'GET', '/2023-03-30/custom-domains', 'json', false, 'json', request);
}

model ListFunctionVersionsRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  direction?: string(name='direction', description='The sorting mode of function versions. Valid values: BACKWARD and FORWARD.', example='BACKWARD', position='Query'),
  limit?: int32(name='limit', description='The number of function versions that are returned.', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM=', position='Query'),
}

model ListFunctionVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVersionsOutput  
}

/**
  * @param request  the request parameters of ListFunctionVersions  ListFunctionVersionsRequest
  * @return ListFunctionVersionsResponse
 */
async function listFunctionVersions(request: ListFunctionVersionsRequest): ListFunctionVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFunctionVersions', 'GET', '/2023-03-30/functions/{functionName}/versions', 'json', false, 'json', request);
}

model ListFunctionsRequest {
  description?: string(name='description', description='The description of the functions to retrieve.', example='test_description', position='Query'),
  fcVersion?: string(name='fcVersion', description='The version of Function Compute to which the functions belong.

*   v3: Only lists functions of Function Compute 3.0.
*   v2: Only lists functions of Function Compute 2.0.

By default, this parameter is left empty and functions in both Function Compute 3.0 and Function Compute 2.0 are listed.', example='v3', position='Query'),
  functionName?: string(name='functionName', position='Query'),
  gpuType?: string(name='gpuType', description='The GPU type of the functions to retrieve.', example='fc.gpu.tesla.1', position='Query'),
  limit?: int32(name='limit', description='The number of functions to return. The minimum value is 1 and the maximum value is 100.', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='The pagination token.', example='MTIzNCNhYmM=', position='Query'),
  prefix?: string(name='prefix', description='The prefix of the function name.', example='my-func', position='Query'),
  resourceGroupId?: string(name='resourceGroupId', position='Query'),
  runtime?: string(name='runtime', description='The runtime of the functions to retrieve.', example='python3.10', position='Query'),
  tags?: [
    Tag
  ](name='tags', description='The tag of the functions to retrieve.', shrink='json', position='Query'),
}

model ListFunctionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionsOutput  
}

/**
  * @description ListFunctions returns only a subset of a function\\"s attribute fields. To obtain the additional fields, which include state, stateReasonCode, stateReason, lastUpdateStatus, lastUpdateStatusReasonCode, and lastUpdateStatusReason, use [GetFunction](https://help.aliyun.com/document_detail/2618610.html).
  * @param request  the request parameters of ListFunctions  ListFunctionsRequest
  * @return ListFunctionsResponse
 */
async function listFunctions(request: ListFunctionsRequest): ListFunctionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFunctions', 'GET', '/2023-03-30/functions', 'json', false, 'json', request);
}

model ListInstancesRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  endTimeMs?: long(name='endTimeMs', position='Query'),
  instanceIds?: [ string ](name='instanceIds', shrink='json', position='Query'),
  instanceStatus?: [ string ](name='instanceStatus', shrink='json', position='Query'),
  limit?: string(name='limit', position='Query'),
  qualifier?: string(name='qualifier', description='The function version or alias.', example='LATEST', position='Query'),
  startKey?: string(name='startKey', position='Query'),
  startTimeMs?: long(name='startTimeMs', position='Query'),
  withAllActive?: boolean(name='withAllActive', description='Specifies whether to list all instances. Valid values: true and false.', example='true', position='Query'),
}

model ListInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstancesOutput  
}

/**
  * @param request  the request parameters of ListInstances  ListInstancesRequest
  * @return ListInstancesResponse
 */
async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListInstances', 'GET', '/2023-03-30/functions/{functionName}/instances', 'json', false, 'json', request);
}

model ListLayerVersionsRequest {
  layerName: string(name='layerName', description='The layer name.

This parameter is required.', example='my-layer', position='Path'),
  limit?: int32(name='limit', description='The number of versions to be returned.', example='10', position='Query'),
  startVersion?: string(name='startVersion', description='The initial version of the layer.', example='1', position='Query'),
}

model ListLayerVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLayerVersionOutput  
}

/**
  * @param request  the request parameters of ListLayerVersions  ListLayerVersionsRequest
  * @return ListLayerVersionsResponse
 */
async function listLayerVersions(request: ListLayerVersionsRequest): ListLayerVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLayerVersions', 'GET', '/2023-03-30/layers/{layerName}/versions', 'json', false, 'json', request);
}

model ListLayersRequest {
  limit?: int32(name='limit', description='The number of layers that are returned', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM=', position='Query'),
  official?: string(name='official', description='Specifies whether the layer is official. Valid values: true and false.', example='true', position='Query'),
  prefix?: string(name='prefix', description='The name prefix of the layer.', example='my-layer', position='Query'),
  public?: string(name='public', description='Specifies whether the layer is public. Valid values: true and false.', example='true', position='Query'),
}

model ListLayersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLayersOutput  
}

/**
  * @param request  the request parameters of ListLayers  ListLayersRequest
  * @return ListLayersResponse
 */
async function listLayers(request: ListLayersRequest): ListLayersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLayers', 'GET', '/2023-03-30/layers', 'json', false, 'json', request);
}

model ListProvisionConfigsRequest {
  functionName?: string(name='functionName', description='The name of the function. If this parameter is not specified, the provisioned configurations of all functions are listed.', example='my-func', position='Query'),
  limit?: int32(name='limit', description='Number of provisioned configurations to return.', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='A pagination token.', example='MTIzNCNhYmM=', position='Query'),
}

model ListProvisionConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProvisionConfigsOutput  
}

/**
  * @param request  the request parameters of ListProvisionConfigs  ListProvisionConfigsRequest
  * @return ListProvisionConfigsResponse
 */
async function listProvisionConfigs(request: ListProvisionConfigsRequest): ListProvisionConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListProvisionConfigs', 'GET', '/2023-03-30/provision-configs', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  limit?: int32(name='Limit', description='The number of resources to return.', example='10', position='Query'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTIzNCNhYmM=', position='Query'),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs.', shrink='json', position='Query'),
  resourceType: string(name='ResourceType', description='The type of the resource.

This parameter is required.', example='ALIYUN::FC:FUNCTION', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.

The tag key can be up to 64 characters in length, and cannot contain `http://` or `https://`. The tag key cannot start with `aliyun` or `acs:`.', example='k1'),
      value?: string(name='Value', description='The tag value.

The tag value can be up to 128 characters in length and can be an empty string.', example='v1'),
    }
  ](name='Tag', description='The tags.

You can query up to 20 tags at a time.', shrink='json', position='Query'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesOutput  
}

/**
  * @param request  the request parameters of ListTagResources  ListTagResourcesRequest
  * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTagResources', 'GET', '/2023-03-30/tags-v2', 'json', false, 'json', request);
}

model ListTriggersRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  limit?: int32(name='limit', description='The number of triggers returned.', example='10', position='Query'),
  nextToken?: string(name='nextToken', description='The token for the next page.', example='MTIzNCNhYmM=', position='Query'),
  prefix?: string(name='prefix', description='The trigger name prefix.', example='my-trigger', position='Query'),
}

model ListTriggersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTriggersOutput  
}

/**
  * @param request  the request parameters of ListTriggers  ListTriggersRequest
  * @return ListTriggersResponse
 */
async function listTriggers(request: ListTriggersRequest): ListTriggersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTriggers', 'GET', '/2023-03-30/functions/{functionName}/triggers', 'json', false, 'json', request);
}

model ListVpcBindingsRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
}

model ListVpcBindingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVpcBindingsOutput  
}

/**
  * @param request  the request parameters of ListVpcBindings  ListVpcBindingsRequest
  * @return ListVpcBindingsResponse
 */
async function listVpcBindings(request: ListVpcBindingsRequest): ListVpcBindingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListVpcBindings', 'GET', '/2023-03-30/functions/{functionName}/vpc-bindings', 'json', false, 'json', request);
}

model PublishFunctionVersionRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  body: PublishVersionInput(name='body', description='The information about the function version.

This parameter is required.', position='Body'),
}

model PublishFunctionVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Version  
}

/**
  * @param request  the request parameters of PublishFunctionVersion  PublishFunctionVersionRequest
  * @return PublishFunctionVersionResponse
 */
async function publishFunctionVersion(request: PublishFunctionVersionRequest): PublishFunctionVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PublishFunctionVersion', 'POST', '/2023-03-30/functions/{functionName}/versions', 'json', false, 'json', request);
}

model PutAsyncInvokeConfigRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  body: PutAsyncInvokeConfigInput(name='body', description='The configurations of asynchronous function invocations.

This parameter is required.', position='Body'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST', position='Query'),
}

model PutAsyncInvokeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AsyncConfig  
}

/**
  * @param request  the request parameters of PutAsyncInvokeConfig  PutAsyncInvokeConfigRequest
  * @return PutAsyncInvokeConfigResponse
 */
async function putAsyncInvokeConfig(request: PutAsyncInvokeConfigRequest): PutAsyncInvokeConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutAsyncInvokeConfig', 'PUT', '/2023-03-30/functions/{functionName}/async-invoke-config', 'json', false, 'json', request);
}

model PutConcurrencyConfigRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  body: PutConcurrencyInput(name='body', description='The concurrency configurations.

This parameter is required.', position='Body'),
}

model PutConcurrencyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConcurrencyConfig  
}

/**
  * @param request  the request parameters of PutConcurrencyConfig  PutConcurrencyConfigRequest
  * @return PutConcurrencyConfigResponse
 */
async function putConcurrencyConfig(request: PutConcurrencyConfigRequest): PutConcurrencyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutConcurrencyConfig', 'PUT', '/2023-03-30/functions/{functionName}/concurrency', 'json', false, 'json', request);
}

model PutLayerACLRequest {
  layerName: string(name='layerName', description='The layer name.

This parameter is required.', example='my-layer', position='Path'),
  acl?: string(name='acl', description='Specify the access permission of the layer. A value of 1 indicates public and a value of 0 indicates private. The default value is 0.', example='1', position='Query'),
  public?: string(name='public', description='Specify whether the layer is a public layer. Valid values: true and false.', example='true', deprecated='true', position='Query'),
}

model PutLayerACLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of PutLayerACL  PutLayerACLRequest
  * @return PutLayerACLResponse
 */
async function putLayerACL(request: PutLayerACLRequest): PutLayerACLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutLayerACL', 'PUT', '/2023-03-30/layers/{layerName}/acl', 'none', false, 'json', request);
}

model PutProvisionConfigRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  body: PutProvisionConfigInput(name='body', description='The provisioned configuration information.

This parameter is required.', position='Body'),
  qualifier?: string(name='qualifier', description='The function alias.', example='LATEST', position='Query'),
}

model PutProvisionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ProvisionConfig  
}

/**
  * @param request  the request parameters of PutProvisionConfig  PutProvisionConfigRequest
  * @return PutProvisionConfigResponse
 */
async function putProvisionConfig(request: PutProvisionConfigRequest): PutProvisionConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutProvisionConfig', 'PUT', '/2023-03-30/functions/{functionName}/provision-config', 'json', false, 'json', request);
}

model StopAsyncTaskRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  taskId: string(name='taskId', description='The ID of the asynchronous task.

This parameter is required.', example='e026ae92-61e5-472f-b32d-1c9e3c4e****', position='Path'),
  qualifier?: string(name='qualifier', description='The version or alias of the function.', example='LATEST', position='Query'),
}

model StopAsyncTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of StopAsyncTask  StopAsyncTaskRequest
  * @return StopAsyncTaskResponse
 */
async function stopAsyncTask(request: StopAsyncTaskRequest): StopAsyncTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StopAsyncTask', 'PUT', '/2023-03-30/functions/{functionName}/async-tasks/{taskId}/stop', 'none', false, 'json', request);
}

model TagResourcesRequest {
  body: TagResourcesInput(name='body', description='The configuration of the resource tag.

This parameter is required.', position='Body'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @description Tags are used to identify resources. Tags allow you to categorize, search for, and aggregate resources that have the same characteristics from different dimensions. This facilitates resource management. For more information, see [Tag overview](https://help.aliyun.com/document_detail/156983.html).
  * @param request  the request parameters of TagResources  TagResourcesRequest
  * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'TagResources', 'POST', '/2023-03-30/tags-v2', 'none', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to delete all tags.', example='true', position='Query'),
  resourceId: [ string ](name='ResourceId', description='The resource identifiers.

This parameter is required.', shrink='json', position='Query'),
  resourceType: string(name='ResourceType', description='The resource type.

This parameter is required.', example='function', position='Query'),
  tagKey?: [ string ](name='TagKey', description='The tag to remove. You can specify a maximum of 50 tags.', shrink='json', position='Query'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of UntagResources  UntagResourcesRequest
  * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UntagResources', 'DELETE', '/2023-03-30/tags-v2', 'none', false, 'json', request);
}

model UpdateAliasRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  aliasName: string(name='aliasName', description='The function alias name.

This parameter is required.', example='my-alias', position='Path'),
  body: UpdateAliasInput(name='body', description='The alias information to be updated.

This parameter is required.', position='Body'),
}

model UpdateAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Alias  
}

/**
  * @param request  the request parameters of UpdateAlias  UpdateAliasRequest
  * @return UpdateAliasResponse
 */
async function updateAlias(request: UpdateAliasRequest): UpdateAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateAlias', 'PUT', '/2023-03-30/functions/{functionName}/aliases/{aliasName}', 'json', false, 'json', request);
}

model UpdateCustomDomainRequest {
  domainName: string(name='domainName', description='The domain name.

This parameter is required.', example='foo.bar.com', position='Path'),
  body: UpdateCustomDomainInput(name='body', description='The information about the custom domain name.

This parameter is required.', position='Body'),
}

model UpdateCustomDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CustomDomain  
}

/**
  * @param request  the request parameters of UpdateCustomDomain  UpdateCustomDomainRequest
  * @return UpdateCustomDomainResponse
 */
async function updateCustomDomain(request: UpdateCustomDomainRequest): UpdateCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateCustomDomain', 'PUT', '/2023-03-30/custom-domains/{domainName}', 'json', false, 'json', request);
}

model UpdateFunctionRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  body: UpdateFunctionInput(name='body', description='The function information

This parameter is required.', position='Body'),
}

model UpdateFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Function  
}

/**
  * @param request  the request parameters of UpdateFunction  UpdateFunctionRequest
  * @return UpdateFunctionResponse
 */
async function updateFunction(request: UpdateFunctionRequest): UpdateFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateFunction', 'PUT', '/2023-03-30/functions/{functionName}', 'json', false, 'json', request);
}

model UpdateTriggerRequest {
  functionName: string(name='functionName', description='The function name.

This parameter is required.', example='my-func', position='Path'),
  triggerName: string(name='triggerName', description='The trigger name.

This parameter is required.', example='my-trigger', position='Path'),
  body: UpdateTriggerInput(name='body', description='The trigger configurations.

This parameter is required.', position='Body'),
}

model UpdateTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Trigger  
}

/**
  * @param request  the request parameters of UpdateTrigger  UpdateTriggerRequest
  * @return UpdateTriggerResponse
 */
async function updateTrigger(request: UpdateTriggerRequest): UpdateTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateTrigger', 'PUT', '/2023-03-30/functions/{functionName}/triggers/{triggerName}', 'json', false, 'json', request);
}

