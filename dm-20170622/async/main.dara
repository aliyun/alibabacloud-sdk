/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Dm';
  @version = '2017-06-22';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AddIpfilterRequest {
  ipAddress: string(name='IpAddress', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AddIpfilterResponseBody = {
  ipFilterId?: string(name='IpFilterId'),
  requestId?: string(name='RequestId'),
}

model AddIpfilterResponse = {
  headers: map[string]string(name='headers'),
  body: AddIpfilterResponseBody(name='body'),
}

async function addIpfilter(request: AddIpfilterRequest): AddIpfilterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddIpfilter', 'POST', '/', 'json', false, 'json', request);
}

model BatchSendMailRequest {
  accountName: string(name='AccountName', position='Query'),
  addressType: int32(name='AddressType', minimum=0, maximum=1, position='Query'),
  clickTrace?: string(name='ClickTrace', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  receiversName: string(name='ReceiversName', position='Query'),
  replyAddress?: string(name='ReplyAddress', position='Query'),
  replyAddressAlias?: string(name='ReplyAddressAlias', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tagName?: string(name='TagName', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
}

model BatchSendMailResponseBody = {
  envId?: string(name='EnvId'),
  requestId?: string(name='RequestId'),
}

model BatchSendMailResponse = {
  headers: map[string]string(name='headers'),
  body: BatchSendMailResponseBody(name='body'),
}

async function batchSendMail(request: BatchSendMailRequest): BatchSendMailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchSendMail', 'POST', '/', 'json', false, 'json', request);
}

model CheckDomainRequest {
  domainId: int32(name='DomainId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CheckDomainResponseBody = {
  domainStatus?: string(name='DomainStatus'),
  requestId?: string(name='RequestId'),
}

model CheckDomainResponse = {
  headers: map[string]string(name='headers'),
  body: CheckDomainResponseBody(name='body'),
}

async function checkDomain(request: CheckDomainRequest): CheckDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckDomain', 'POST', '/', 'json', false, 'json', request);
}

model CreateDomainRequest {
  domainName: string(name='DomainName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateDomainResponseBody = {
  domainId?: string(name='DomainId'),
  requestId?: string(name='RequestId'),
}

model CreateDomainResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDomainResponseBody(name='body'),
}

async function createDomain(request: CreateDomainRequest): CreateDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDomain', 'POST', '/', 'json', false, 'json', request);
}

model CreateMailAddressRequest {
  accountName: string(name='AccountName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  replyAddress?: string(name='ReplyAddress', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sendtype: string(name='Sendtype', position='Query'),
}

model CreateMailAddressResponseBody = {
  mailAddressId?: string(name='MailAddressId'),
  requestId?: string(name='RequestId'),
}

model CreateMailAddressResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMailAddressResponseBody(name='body'),
}

async function createMailAddress(request: CreateMailAddressRequest): CreateMailAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMailAddress', 'POST', '/', 'json', false, 'json', request);
}

model CreateReceiverRequest {
  desc?: string(name='Desc', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  receiversAlias: string(name='ReceiversAlias', position='Query'),
  receiversName: string(name='ReceiversName', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateReceiverResponseBody = {
  receiverId?: string(name='ReceiverId'),
  requestId?: string(name='RequestId'),
}

model CreateReceiverResponse = {
  headers: map[string]string(name='headers'),
  body: CreateReceiverResponseBody(name='body'),
}

async function createReceiver(request: CreateReceiverRequest): CreateReceiverResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateReceiver', 'POST', '/', 'json', false, 'json', request);
}

model CreateTagRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tagName: string(name='TagName', position='Query'),
}

model CreateTagResponseBody = {
  requestId?: string(name='RequestId'),
  tagId?: string(name='TagId'),
}

model CreateTagResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTagResponseBody(name='body'),
}

async function createTag(request: CreateTagRequest): CreateTagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTag', 'POST', '/', 'json', false, 'json', request);
}

model CreateTemplateRequest {
  fromType?: int32(name='FromType', minimum=1, maximum=2, position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  remark?: string(name='Remark', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  smsContent?: string(name='SmsContent', position='Query'),
  smsType?: int32(name='SmsType', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
  templateNickName?: string(name='TemplateNickName', position='Query'),
  templateSubject?: string(name='TemplateSubject', position='Query'),
  templateText?: string(name='TemplateText', position='Query'),
  templateType?: int32(name='TemplateType', minimum=0, maximum=2, position='Query'),
}

model CreateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: int32(name='TemplateId'),
}

model CreateTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTemplateResponseBody(name='body'),
}

async function createTemplate(request: CreateTemplateRequest): CreateTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTemplate', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDomainRequest {
  domainId: int32(name='DomainId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDomainResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDomainResponseBody(name='body'),
}

async function deleteDomain(request: DeleteDomainRequest): DeleteDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDomain', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMailAddressRequest {
  mailAddressId: int32(name='MailAddressId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteMailAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMailAddressResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMailAddressResponseBody(name='body'),
}

async function deleteMailAddress(request: DeleteMailAddressRequest): DeleteMailAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMailAddress', 'POST', '/', 'json', false, 'json', request);
}

model DeleteReceiverRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  receiverId: string(name='ReceiverId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteReceiverResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteReceiverResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteReceiverResponseBody(name='body'),
}

async function deleteReceiver(request: DeleteReceiverRequest): DeleteReceiverResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteReceiver', 'POST', '/', 'json', false, 'json', request);
}

model DeleteReceiverDetailRequest {
  email?: string(name='Email', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  receiverId: string(name='ReceiverId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteReceiverDetailResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteReceiverDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteReceiverDetailResponseBody(name='body'),
}

async function deleteReceiverDetail(request: DeleteReceiverDetailRequest): DeleteReceiverDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteReceiverDetail', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTagRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tagId: int32(name='TagId', position='Query'),
}

model DeleteTagResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTagResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTagResponseBody(name='body'),
}

async function deleteTag(request: DeleteTagRequest): DeleteTagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTag', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTemplateRequest {
  fromType?: int32(name='FromType', minimum=1, maximum=2, position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  templateId: int32(name='TemplateId', position='Query'),
}

model DeleteTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTemplateResponseBody(name='body'),
}

async function deleteTemplate(request: DeleteTemplateRequest): DeleteTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTemplate', 'POST', '/', 'json', false, 'json', request);
}

model DescAccountSummaryRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescAccountSummaryResponseBody = {
  dailyQuota?: int32(name='DailyQuota'),
  dayuStatus?: int32(name='DayuStatus'),
  domains?: int32(name='Domains'),
  enableTimes?: int32(name='EnableTimes'),
  mailAddresses?: int32(name='MailAddresses'),
  maxQuotaLevel?: int32(name='MaxQuotaLevel'),
  monthQuota?: int32(name='MonthQuota'),
  quotaLevel?: int32(name='QuotaLevel'),
  receivers?: int32(name='Receivers'),
  requestId?: string(name='RequestId'),
  smsRecord?: int32(name='SmsRecord'),
  smsSign?: int32(name='SmsSign'),
  smsTemplates?: int32(name='SmsTemplates'),
  tags?: int32(name='Tags'),
  templates?: int32(name='Templates'),
  userStatus?: int32(name='UserStatus'),
}

model DescAccountSummaryResponse = {
  headers: map[string]string(name='headers'),
  body: DescAccountSummaryResponseBody(name='body'),
}

async function descAccountSummary(request: DescAccountSummaryRequest): DescAccountSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescAccountSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescDomainRequest {
  domainId: int32(name='DomainId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescDomainResponseBody = {
  cnameAuthStatus?: string(name='CnameAuthStatus'),
  cnameConfirmStatus?: string(name='CnameConfirmStatus'),
  cnameRecord?: string(name='CnameRecord'),
  createTime?: string(name='CreateTime'),
  defaultDomain?: string(name='DefaultDomain'),
  dnsMx?: string(name='DnsMx'),
  dnsSpf?: string(name='DnsSpf'),
  dnsTxt?: string(name='DnsTxt'),
  domainId?: string(name='DomainId'),
  domainName?: string(name='DomainName'),
  domainStatus?: string(name='DomainStatus'),
  domainType?: string(name='DomainType'),
  icpStatus?: string(name='IcpStatus'),
  mxAuthStatus?: string(name='MxAuthStatus'),
  mxRecord?: string(name='MxRecord'),
  requestId?: string(name='RequestId'),
  spfAuthStatus?: string(name='SpfAuthStatus'),
  spfRecord?: string(name='SpfRecord'),
  tlDomainName?: string(name='TlDomainName'),
  tracefRecord?: string(name='TracefRecord'),
}

model DescDomainResponse = {
  headers: map[string]string(name='headers'),
  body: DescDomainResponseBody(name='body'),
}

async function descDomain(request: DescDomainRequest): DescDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescDomain', 'POST', '/', 'json', false, 'json', request);
}

model DescTemplateRequest {
  fromType?: int32(name='FromType', minimum=1, maximum=2, position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  templateId: int32(name='TemplateId', position='Query'),
}

model DescTemplateResponseBody = {
  createTime?: string(name='CreateTime'),
  remark?: string(name='Remark'),
  requestId?: string(name='RequestId'),
  smsContent?: string(name='SmsContent'),
  smsType?: string(name='SmsType'),
  templateName?: string(name='TemplateName'),
  templateNickName?: string(name='TemplateNickName'),
  templateStatus?: string(name='TemplateStatus'),
  templateSubject?: string(name='TemplateSubject'),
  templateText?: string(name='TemplateText'),
  templateType?: string(name='TemplateType'),
}

model DescTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DescTemplateResponseBody(name='body'),
}

async function descTemplate(request: DescTemplateRequest): DescTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescTemplate', 'POST', '/', 'json', false, 'json', request);
}

model GetAccountListRequest {
  offset?: string(name='Offset', position='Query'),
  offsetCreateTime?: string(name='OffsetCreateTime', position='Query'),
  offsetCreateTimeDesc?: string(name='OffsetCreateTimeDesc', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: string(name='PageNumber', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  total?: string(name='Total', position='Query'),
}

model GetAccountListResponseBody = {
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
  data?: {
    accountNotificationInfo?: [ 
    {
      region?: string(name='Region'),
      status?: string(name='Status'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='accountNotificationInfo')
  }(name='data'),
}

model GetAccountListResponse = {
  headers: map[string]string(name='headers'),
  body: GetAccountListResponseBody(name='body'),
}

async function getAccountList(request: GetAccountListRequest): GetAccountListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAccountList', 'POST', '/', 'json', false, 'json', request);
}

model GetMailAddressMsgCallBackUrlRequest {
  mailFrom: string(name='MailFrom', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model GetMailAddressMsgCallBackUrlResponseBody = {
  notifyUrl?: int32(name='NotifyUrl'),
  notifyUrlStatus?: int32(name='NotifyUrlStatus'),
  requestId?: string(name='RequestId'),
}

model GetMailAddressMsgCallBackUrlResponse = {
  headers: map[string]string(name='headers'),
  body: GetMailAddressMsgCallBackUrlResponseBody(name='body'),
}

async function getMailAddressMsgCallBackUrl(request: GetMailAddressMsgCallBackUrlRequest): GetMailAddressMsgCallBackUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMailAddressMsgCallBackUrl', 'POST', '/', 'json', false, 'json', request);
}

model GetTrackListRequest {
  endTime: string(name='EndTime', position='Query'),
  offset?: string(name='Offset', position='Query'),
  offsetCreateTime?: string(name='OffsetCreateTime', position='Query'),
  offsetCreateTimeDesc?: string(name='OffsetCreateTimeDesc', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: string(name='PageNumber', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  total?: string(name='Total', position='Query'),
}

model GetTrackListResponseBody = {
  offsetCreateTime?: string(name='OffsetCreateTime'),
  offsetCreateTimeDesc?: string(name='OffsetCreateTimeDesc'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
  data?: {
    stat?: [ 
    {
      createTime?: string(name='CreateTime'),
      rcptClickCount?: string(name='RcptClickCount'),
      rcptClickRate?: string(name='RcptClickRate'),
      rcptOpenCount?: string(name='RcptOpenCount'),
      rcptOpenRate?: string(name='RcptOpenRate'),
      rcptUniqueClickCount?: string(name='RcptUniqueClickCount'),
      rcptUniqueClickRate?: string(name='RcptUniqueClickRate'),
      rcptUniqueOpenCount?: string(name='RcptUniqueOpenCount'),
      rcptUniqueOpenRate?: string(name='RcptUniqueOpenRate'),
      totalNumber?: string(name='TotalNumber'),
    }
  ](name='stat')
  }(name='data'),
}

model GetTrackListResponse = {
  headers: map[string]string(name='headers'),
  body: GetTrackListResponseBody(name='body'),
}

async function getTrackList(request: GetTrackListRequest): GetTrackListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTrackList', 'POST', '/', 'json', false, 'json', request);
}

model ModifyMailAddressRequest {
  mailAddressId: int32(name='MailAddressId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  password?: string(name='Password', position='Query'),
  replyAddress?: string(name='ReplyAddress', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyMailAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyMailAddressResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyMailAddressResponseBody(name='body'),
}

async function modifyMailAddress(request: ModifyMailAddressRequest): ModifyMailAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyMailAddress', 'POST', '/', 'json', false, 'json', request);
}

model ModifyPWByDomainRequest {
  domainName: string(name='DomainName', position='Query'),
  password: string(name='Password', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model ModifyPWByDomainResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyPWByDomainResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPWByDomainResponseBody(name='body'),
}

async function modifyPWByDomain(request: ModifyPWByDomainRequest): ModifyPWByDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyPWByDomain', 'POST', '/', 'json', false, 'json', request);
}

model ModifyTagRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tagId: int32(name='TagId', position='Query'),
  tagName: string(name='TagName', position='Query'),
}

model ModifyTagResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyTagResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyTagResponseBody(name='body'),
}

async function modifyTag(request: ModifyTagRequest): ModifyTagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyTag', 'POST', '/', 'json', false, 'json', request);
}

model ModifyTemplateRequest {
  fromType?: int32(name='FromType', minimum=1, maximum=2, position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  remark?: string(name='Remark', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  smsContent?: string(name='SmsContent', position='Query'),
  smsType?: int32(name='SmsType', position='Query'),
  templateId: int32(name='TemplateId', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
  templateNickName?: string(name='TemplateNickName', position='Query'),
  templateSubject?: string(name='TemplateSubject', position='Query'),
  templateText?: string(name='TemplateText', position='Query'),
}

model ModifyTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyTemplateResponseBody(name='body'),
}

async function modifyTemplate(request: ModifyTemplateRequest): ModifyTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyTemplate', 'POST', '/', 'json', false, 'json', request);
}

model QueryDomainByParamRequest {
  keyWord?: string(name='KeyWord', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: int32(name='Status', minimum=0, maximum=2, position='Query'),
}

model QueryDomainByParamResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  data?: {
    domain?: [ 
    {
      cnameAuthStatus?: string(name='CnameAuthStatus'),
      confirmStatus?: string(name='ConfirmStatus'),
      createTime?: string(name='CreateTime'),
      domainId?: string(name='DomainId'),
      domainName?: string(name='DomainName'),
      domainRecord?: string(name='DomainRecord'),
      domainStatus?: string(name='DomainStatus'),
      icpStatus?: string(name='IcpStatus'),
      mxAuthStatus?: string(name='MxAuthStatus'),
      spfAuthStatus?: string(name='SpfAuthStatus'),
      utcCreateTime?: long(name='UtcCreateTime'),
    }
  ](name='domain')
  }(name='data'),
}

model QueryDomainByParamResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDomainByParamResponseBody(name='body'),
}

async function queryDomainByParam(request: QueryDomainByParamRequest): QueryDomainByParamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDomainByParam', 'POST', '/', 'json', false, 'json', request);
}

model QueryInvalidAddressRequest {
  endTime?: string(name='EndTime', position='Query'),
  keyWord?: string(name='KeyWord', position='Query'),
  length?: int32(name='Length', minimum=1, maximum=100, position='Query'),
  nextStart?: string(name='NextStart', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model QueryInvalidAddressResponseBody = {
  nextStart?: int32(name='NextStart'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  data?: {
    mailDetail?: [ 
    {
      lastUpdateTime?: string(name='LastUpdateTime'),
      toAddress?: string(name='ToAddress'),
      utcLastUpdateTime?: long(name='UtcLastUpdateTime'),
    }
  ](name='mailDetail')
  }(name='data'),
}

model QueryInvalidAddressResponse = {
  headers: map[string]string(name='headers'),
  body: QueryInvalidAddressResponseBody(name='body'),
}

async function queryInvalidAddress(request: QueryInvalidAddressRequest): QueryInvalidAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryInvalidAddress', 'POST', '/', 'json', false, 'json', request);
}

model QueryMailAddressByParamRequest {
  keyWord?: string(name='KeyWord', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=500, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sendtype?: string(name='Sendtype', position='Query'),
}

model QueryMailAddressByParamResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  data?: {
    mailAddress?: [ 
    {
      accountName?: string(name='AccountName'),
      accountStatus?: string(name='AccountStatus'),
      createTime?: string(name='CreateTime'),
      dailyCount?: string(name='DailyCount'),
      dailyReqCount?: string(name='DailyReqCount'),
      domainStatus?: string(name='DomainStatus'),
      mailAddressId?: string(name='MailAddressId'),
      monthCount?: string(name='MonthCount'),
      monthReqCount?: string(name='MonthReqCount'),
      replyAddress?: string(name='ReplyAddress'),
      replyStatus?: string(name='ReplyStatus'),
      sendtype?: string(name='Sendtype'),
    }
  ](name='mailAddress')
  }(name='data'),
}

model QueryMailAddressByParamResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMailAddressByParamResponseBody(name='body'),
}

async function queryMailAddressByParam(request: QueryMailAddressByParamRequest): QueryMailAddressByParamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMailAddressByParam', 'POST', '/', 'json', false, 'json', request);
}

model QueryReceiverByParamRequest {
  keyWord?: string(name='KeyWord', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: int32(name='Status', minimum=0, maximum=2, position='Query'),
}

model QueryReceiverByParamResponseBody = {
  nextStart?: string(name='NextStart'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  data?: {
    receiver?: [ 
    {
      count?: string(name='Count'),
      createTime?: string(name='CreateTime'),
      desc?: string(name='Desc'),
      receiverId?: string(name='ReceiverId'),
      receiversAlias?: string(name='ReceiversAlias'),
      receiversName?: string(name='ReceiversName'),
      receiversStatus?: string(name='ReceiversStatus'),
      utcCreateTime?: long(name='UtcCreateTime'),
    }
  ](name='receiver')
  }(name='data'),
}

model QueryReceiverByParamResponse = {
  headers: map[string]string(name='headers'),
  body: QueryReceiverByParamResponseBody(name='body'),
}

async function queryReceiverByParam(request: QueryReceiverByParamRequest): QueryReceiverByParamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryReceiverByParam', 'POST', '/', 'json', false, 'json', request);
}

model QueryReceiverDetailRequest {
  keyWord?: string(name='KeyWord', position='Query'),
  nextStart?: string(name='NextStart', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  receiverId: string(name='ReceiverId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryReceiverDetailResponseBody = {
  dataSchema?: string(name='DataSchema'),
  nextStart?: string(name='NextStart'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  data?: {
    detail?: [ 
    {
      createTime?: string(name='CreateTime'),
      data?: string(name='Data'),
      email?: string(name='Email'),
      utcCreateTime?: long(name='UtcCreateTime'),
    }
  ](name='detail')
  }(name='data'),
}

model QueryReceiverDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QueryReceiverDetailResponseBody(name='body'),
}

async function queryReceiverDetail(request: QueryReceiverDetailRequest): QueryReceiverDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryReceiverDetail', 'POST', '/', 'json', false, 'json', request);
}

model QueryTagByParamRequest {
  keyWord?: string(name='KeyWord', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=500, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryTagByParamResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  data?: {
    tag?: [ 
    {
      tagId?: string(name='TagId'),
      tagName?: string(name='TagName'),
    }
  ](name='tag')
  }(name='data'),
}

model QueryTagByParamResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTagByParamResponseBody(name='body'),
}

async function queryTagByParam(request: QueryTagByParamRequest): QueryTagByParamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryTagByParam', 'POST', '/', 'json', false, 'json', request);
}

model QueryTaskByParamRequest {
  keyWord?: string(name='KeyWord', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: int32(name='Status', minimum=0, maximum=2, position='Query'),
}

model QueryTaskByParamResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  data?: {
    task?: [ 
    {
      addressType?: string(name='AddressType'),
      createTime?: string(name='CreateTime'),
      receiversName?: string(name='ReceiversName'),
      requestCount?: string(name='RequestCount'),
      tagName?: string(name='TagName'),
      taskId?: string(name='TaskId'),
      taskStatus?: string(name='TaskStatus'),
      templateName?: string(name='TemplateName'),
      utcCreateTime?: long(name='UtcCreateTime'),
    }
  ](name='task')
  }(name='data'),
}

model QueryTaskByParamResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTaskByParamResponseBody(name='body'),
}

async function queryTaskByParam(request: QueryTaskByParamRequest): QueryTaskByParamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryTaskByParam', 'POST', '/', 'json', false, 'json', request);
}

model QueryTemplateByParamRequest {
  fromType?: int32(name='FromType', minimum=1, maximum=2, position='Query'),
  keyWord?: string(name='KeyWord', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: int32(name='Status', minimum=0, maximum=4, position='Query'),
}

model QueryTemplateByParamResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  data?: {
    template?: [ 
    {
      createTime?: string(name='CreateTime'),
      smsStatus?: int32(name='SmsStatus'),
      smsTemplateCode?: int32(name='SmsTemplateCode'),
      smsrejectinfo?: int32(name='Smsrejectinfo'),
      templateComment?: string(name='TemplateComment'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateStatus?: string(name='TemplateStatus'),
      templateType?: int32(name='TemplateType'),
      utcCreatetime?: long(name='UtcCreatetime'),
    }
  ](name='template')
  }(name='data'),
}

model QueryTemplateByParamResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTemplateByParamResponseBody(name='body'),
}

async function queryTemplateByParam(request: QueryTemplateByParamRequest): QueryTemplateByParamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryTemplateByParam', 'POST', '/', 'json', false, 'json', request);
}

model SaveReceiverDetailRequest {
  detail: string(name='Detail', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  receiverId: string(name='ReceiverId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model SaveReceiverDetailResponseBody = {
  data?: {
    detail?: [ 
    {
      email?: string(name='Email'),
    }
  ](name='Detail')
  }(name='Data'),
  errorCount?: int32(name='ErrorCount'),
  requestId?: string(name='RequestId'),
  successCount?: int32(name='SuccessCount'),
}

model SaveReceiverDetailResponse = {
  headers: map[string]string(name='headers'),
  body: SaveReceiverDetailResponseBody(name='body'),
}

async function saveReceiverDetail(request: SaveReceiverDetailRequest): SaveReceiverDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveReceiverDetail', 'POST', '/', 'json', false, 'json', request);
}

model SenderStatisticsByTagNameAndBatchIDRequest {
  accountName?: string(name='AccountName', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  tagName?: string(name='TagName', position='Query'),
}

model SenderStatisticsByTagNameAndBatchIDResponseBody = {
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  data?: {
    stat?: [ 
    {
      createTime?: string(name='CreateTime'),
      faildCount?: string(name='faildCount'),
      requestCount?: string(name='requestCount'),
      succeededPercent?: string(name='succeededPercent'),
      successCount?: string(name='successCount'),
      unavailableCount?: string(name='unavailableCount'),
      unavailablePercent?: string(name='unavailablePercent'),
    }
  ](name='stat')
  }(name='data'),
}

model SenderStatisticsByTagNameAndBatchIDResponse = {
  headers: map[string]string(name='headers'),
  body: SenderStatisticsByTagNameAndBatchIDResponseBody(name='body'),
}

async function senderStatisticsByTagNameAndBatchID(request: SenderStatisticsByTagNameAndBatchIDRequest): SenderStatisticsByTagNameAndBatchIDResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SenderStatisticsByTagNameAndBatchID', 'POST', '/', 'json', false, 'json', request);
}

model SenderStatisticsDetailByParamRequest {
  accountName?: string(name='AccountName', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  length?: int32(name='Length', minimum=1, maximum=100, position='Query'),
  nextStart?: string(name='NextStart', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  status?: int32(name='Status', minimum=0, maximum=4, position='Query'),
  tagName?: string(name='TagName', position='Query'),
  toAddress?: string(name='ToAddress', position='Query'),
}

model SenderStatisticsDetailByParamResponseBody = {
  nextStart?: int32(name='NextStart'),
  requestId?: string(name='RequestId'),
  data?: {
    mailDetail?: [ 
    {
      accountName?: string(name='AccountName'),
      lastUpdateTime?: string(name='LastUpdateTime'),
      message?: string(name='Message'),
      status?: int32(name='Status'),
      toAddress?: string(name='ToAddress'),
      utcLastUpdateTime?: string(name='UtcLastUpdateTime'),
    }
  ](name='mailDetail')
  }(name='data'),
}

model SenderStatisticsDetailByParamResponse = {
  headers: map[string]string(name='headers'),
  body: SenderStatisticsDetailByParamResponseBody(name='body'),
}

async function senderStatisticsDetailByParam(request: SenderStatisticsDetailByParamRequest): SenderStatisticsDetailByParamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SenderStatisticsDetailByParam', 'POST', '/', 'json', false, 'json', request);
}

model SingleSendMailRequest {
  accountName: string(name='AccountName', position='Query'),
  addressType: int32(name='AddressType', minimum=0, maximum=1, position='Query'),
  clickTrace?: string(name='ClickTrace', position='Query'),
  fromAlias?: string(name='FromAlias', position='Query'),
  htmlBody?: string(name='HtmlBody', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  replyAddress?: string(name='ReplyAddress', position='Query'),
  replyAddressAlias?: string(name='ReplyAddressAlias', position='Query'),
  replyToAddress: boolean(name='ReplyToAddress', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  subject: string(name='Subject', position='Query'),
  tagName?: string(name='TagName', position='Query'),
  textBody?: string(name='TextBody', position='Query'),
  toAddress: string(name='ToAddress', position='Query'),
}

model SingleSendMailResponseBody = {
  envId?: string(name='EnvId'),
  requestId?: string(name='RequestId'),
}

model SingleSendMailResponse = {
  headers: map[string]string(name='headers'),
  body: SingleSendMailResponseBody(name='body'),
}

async function singleSendMail(request: SingleSendMailRequest): SingleSendMailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SingleSendMail', 'POST', '/', 'json', false, 'json', request);
}

