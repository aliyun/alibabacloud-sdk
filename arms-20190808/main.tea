/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'arms.aliyuncs.com',
    cn-beijing-finance-1 = 'arms.aliyuncs.com',
    cn-beijing-finance-pop = 'arms.aliyuncs.com',
    cn-beijing-gov-1 = 'arms.aliyuncs.com',
    cn-beijing-nu16-b01 = 'arms.aliyuncs.com',
    cn-edge-1 = 'arms.aliyuncs.com',
    cn-fujian = 'arms.aliyuncs.com',
    cn-haidian-cm12-c01 = 'arms.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'arms.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'arms.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'arms.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'arms.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'arms.aliyuncs.com',
    cn-hangzhou-test-306 = 'arms.aliyuncs.com',
    cn-hongkong-finance-pop = 'arms.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'arms.aliyuncs.com',
    cn-qingdao-nebula = 'arms.aliyuncs.com',
    cn-shanghai-et15-b01 = 'arms.aliyuncs.com',
    cn-shanghai-et2-b01 = 'arms.aliyuncs.com',
    cn-shanghai-inner = 'arms.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'arms.aliyuncs.com',
    cn-shenzhen-inner = 'arms.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'arms.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'arms.aliyuncs.com',
    cn-wuhan = 'arms.aliyuncs.com',
    cn-yushanfang = 'arms.aliyuncs.com',
    cn-zhangbei = 'arms.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'arms.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'arms.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'arms.aliyuncs.com',
    eu-west-1-oxs = 'arms.aliyuncs.com',
    me-east-1 = 'arms.aliyuncs.com',
    rus-west-1-pop = 'arms.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('arms', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CallChainInfo {
  additionalInfo?: string(name='AdditionalInfo'),
  appName?: string(name='AppName'),
  appType?: string(name='AppType'),
  children?: [
    CallChainInfo
  ](name='Children'),
  haveSpan?: boolean(name='HaveSpan'),
  logMap?: map[string]object(name='LogMap'),
  logTime?: long(name='LogTime'),
  parentSpanId?: string(name='ParentSpanId'),
  pid?: string(name='Pid'),
  regionId?: string(name='RegionId'),
  resultCode?: string(name='ResultCode'),
  rpc?: string(name='Rpc'),
  rpcId?: string(name='RpcId'),
  rpcType?: long(name='RpcType'),
  serverIp?: string(name='ServerIp'),
  span?: long(name='Span'),
  spanId?: string(name='SpanId'),
  tagMap?: map[string]string(name='TagMap'),
  traceId?: string(name='TraceId'),
}

model AddAliClusterIdsToPrometheusGlobalViewRequest {
  clusterIds?: string(name='ClusterIds'),
  globalViewClusterId?: string(name='GlobalViewClusterId'),
  groupName?: string(name='GroupName'),
  regionId?: string(name='RegionId'),
}

model AddAliClusterIdsToPrometheusGlobalViewResponseBody = {
  data?: {
    info?: string(name='Info'),
    msg?: string(name='Msg'),
    success?: boolean(name='Success'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddAliClusterIdsToPrometheusGlobalViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddAliClusterIdsToPrometheusGlobalViewResponseBody(name='body'),
}

async function addAliClusterIdsToPrometheusGlobalViewWithOptions(request: AddAliClusterIdsToPrometheusGlobalViewRequest, runtime: Util.RuntimeOptions): AddAliClusterIdsToPrometheusGlobalViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterIds)) {
    query['ClusterIds'] = request.clusterIds;
  }
  if (!Util.isUnset(request.globalViewClusterId)) {
    query['GlobalViewClusterId'] = request.globalViewClusterId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddAliClusterIdsToPrometheusGlobalView',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addAliClusterIdsToPrometheusGlobalView(request: AddAliClusterIdsToPrometheusGlobalViewRequest): AddAliClusterIdsToPrometheusGlobalViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAliClusterIdsToPrometheusGlobalViewWithOptions(request, runtime);
}

model AddGrafanaRequest {
  clusterId?: string(name='ClusterId'),
  integration?: string(name='Integration'),
  regionId?: string(name='RegionId'),
}

model AddGrafanaResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddGrafanaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGrafanaResponseBody(name='body'),
}

async function addGrafanaWithOptions(request: AddGrafanaRequest, runtime: Util.RuntimeOptions): AddGrafanaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.integration)) {
    query['Integration'] = request.integration;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGrafana',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGrafana(request: AddGrafanaRequest): AddGrafanaResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGrafanaWithOptions(request, runtime);
}

model AddIntegrationRequest {
  clusterId?: string(name='ClusterId'),
  integration?: string(name='Integration'),
  regionId?: string(name='RegionId'),
}

model AddIntegrationResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddIntegrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddIntegrationResponseBody(name='body'),
}

async function addIntegrationWithOptions(request: AddIntegrationRequest, runtime: Util.RuntimeOptions): AddIntegrationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.integration)) {
    query['Integration'] = request.integration;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddIntegration',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addIntegration(request: AddIntegrationRequest): AddIntegrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return addIntegrationWithOptions(request, runtime);
}

model AddPrometheusGlobalViewRequest {
  clusters?: string(name='Clusters'),
  groupName?: string(name='GroupName'),
  regionId?: string(name='RegionId'),
}

model AddPrometheusGlobalViewResponseBody = {
  data?: {
    info?: string(name='Info'),
    msg?: string(name='Msg'),
    success?: boolean(name='Success'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddPrometheusGlobalViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddPrometheusGlobalViewResponseBody(name='body'),
}

async function addPrometheusGlobalViewWithOptions(request: AddPrometheusGlobalViewRequest, runtime: Util.RuntimeOptions): AddPrometheusGlobalViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusters)) {
    query['Clusters'] = request.clusters;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddPrometheusGlobalView',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addPrometheusGlobalView(request: AddPrometheusGlobalViewRequest): AddPrometheusGlobalViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPrometheusGlobalViewWithOptions(request, runtime);
}

model AddPrometheusGlobalViewByAliClusterIdsRequest {
  clusterIds?: string(name='ClusterIds'),
  groupName?: string(name='GroupName'),
  productCode?: string(name='ProductCode'),
  regionId?: string(name='RegionId'),
}

model AddPrometheusGlobalViewByAliClusterIdsResponseBody = {
  data?: {
    info?: string(name='Info'),
    msg?: string(name='Msg'),
    success?: boolean(name='Success'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddPrometheusGlobalViewByAliClusterIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddPrometheusGlobalViewByAliClusterIdsResponseBody(name='body'),
}

async function addPrometheusGlobalViewByAliClusterIdsWithOptions(request: AddPrometheusGlobalViewByAliClusterIdsRequest, runtime: Util.RuntimeOptions): AddPrometheusGlobalViewByAliClusterIdsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterIds)) {
    query['ClusterIds'] = request.clusterIds;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddPrometheusGlobalViewByAliClusterIds',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addPrometheusGlobalViewByAliClusterIds(request: AddPrometheusGlobalViewByAliClusterIdsRequest): AddPrometheusGlobalViewByAliClusterIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPrometheusGlobalViewByAliClusterIdsWithOptions(request, runtime);
}

model AddPrometheusInstanceRequest {
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
}

model AddPrometheusInstanceResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddPrometheusInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddPrometheusInstanceResponseBody(name='body'),
}

async function addPrometheusInstanceWithOptions(request: AddPrometheusInstanceRequest, runtime: Util.RuntimeOptions): AddPrometheusInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddPrometheusInstance',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addPrometheusInstance(request: AddPrometheusInstanceRequest): AddPrometheusInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPrometheusInstanceWithOptions(request, runtime);
}

model AddRecordingRuleRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
  ruleYaml?: string(name='RuleYaml'),
}

model AddRecordingRuleResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddRecordingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddRecordingRuleResponseBody(name='body'),
}

async function addRecordingRuleWithOptions(request: AddRecordingRuleRequest, runtime: Util.RuntimeOptions): AddRecordingRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.ruleYaml)) {
    query['RuleYaml'] = request.ruleYaml;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddRecordingRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addRecordingRule(request: AddRecordingRuleRequest): AddRecordingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addRecordingRuleWithOptions(request, runtime);
}

model AppendInstancesToPrometheusGlobalViewRequest {
  clusters?: string(name='Clusters'),
  globalViewClusterId?: string(name='GlobalViewClusterId'),
  groupName?: string(name='GroupName'),
  regionId?: string(name='RegionId'),
}

model AppendInstancesToPrometheusGlobalViewResponseBody = {
  data?: {
    info?: string(name='Info'),
    msg?: string(name='Msg'),
    success?: boolean(name='Success'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model AppendInstancesToPrometheusGlobalViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AppendInstancesToPrometheusGlobalViewResponseBody(name='body'),
}

async function appendInstancesToPrometheusGlobalViewWithOptions(request: AppendInstancesToPrometheusGlobalViewRequest, runtime: Util.RuntimeOptions): AppendInstancesToPrometheusGlobalViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusters)) {
    query['Clusters'] = request.clusters;
  }
  if (!Util.isUnset(request.globalViewClusterId)) {
    query['GlobalViewClusterId'] = request.globalViewClusterId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AppendInstancesToPrometheusGlobalView',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function appendInstancesToPrometheusGlobalView(request: AppendInstancesToPrometheusGlobalViewRequest): AppendInstancesToPrometheusGlobalViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return appendInstancesToPrometheusGlobalViewWithOptions(request, runtime);
}

model ApplyScenarioRequest {
  appId?: string(name='AppId'),
  config?: map[string]any(name='Config'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  scenario?: string(name='Scenario'),
  sign?: string(name='Sign'),
  snDump?: boolean(name='SnDump'),
  snForce?: boolean(name='SnForce'),
  snStat?: boolean(name='SnStat'),
  snTransfer?: boolean(name='SnTransfer'),
  updateOption?: boolean(name='UpdateOption'),
}

model ApplyScenarioShrinkRequest {
  appId?: string(name='AppId'),
  configShrink?: string(name='Config'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  scenario?: string(name='Scenario'),
  sign?: string(name='Sign'),
  snDump?: boolean(name='SnDump'),
  snForce?: boolean(name='SnForce'),
  snStat?: boolean(name='SnStat'),
  snTransfer?: boolean(name='SnTransfer'),
  updateOption?: boolean(name='UpdateOption'),
}

model ApplyScenarioResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model ApplyScenarioResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyScenarioResponseBody(name='body'),
}

async function applyScenarioWithOptions(tmpReq: ApplyScenarioRequest, runtime: Util.RuntimeOptions): ApplyScenarioResponse {
  Util.validateModel(tmpReq);
  var request = new ApplyScenarioShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.config)) {
    request.configShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.config, 'Config', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.configShrink)) {
    query['Config'] = request.configShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.scenario)) {
    query['Scenario'] = request.scenario;
  }
  if (!Util.isUnset(request.sign)) {
    query['Sign'] = request.sign;
  }
  if (!Util.isUnset(request.snDump)) {
    query['SnDump'] = request.snDump;
  }
  if (!Util.isUnset(request.snForce)) {
    query['SnForce'] = request.snForce;
  }
  if (!Util.isUnset(request.snStat)) {
    query['SnStat'] = request.snStat;
  }
  if (!Util.isUnset(request.snTransfer)) {
    query['SnTransfer'] = request.snTransfer;
  }
  if (!Util.isUnset(request.updateOption)) {
    query['UpdateOption'] = request.updateOption;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyScenario',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyScenario(request: ApplyScenarioRequest): ApplyScenarioResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyScenarioWithOptions(request, runtime);
}

model CheckServiceStatusRequest {
  regionId?: string(name='RegionId'),
  svcCode?: string(name='SvcCode'),
}

model CheckServiceStatusResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model CheckServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckServiceStatusResponseBody(name='body'),
}

async function checkServiceStatusWithOptions(request: CheckServiceStatusRequest, runtime: Util.RuntimeOptions): CheckServiceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.svcCode)) {
    query['SvcCode'] = request.svcCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckServiceStatus',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkServiceStatus(request: CheckServiceStatusRequest): CheckServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkServiceStatusWithOptions(request, runtime);
}

model ConfigAppRequest {
  appIds?: string(name='AppIds'),
  enable?: string(name='Enable'),
  regionId?: string(name='RegionId'),
}

model ConfigAppResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ConfigAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfigAppResponseBody(name='body'),
}

async function configAppWithOptions(request: ConfigAppRequest, runtime: Util.RuntimeOptions): ConfigAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appIds)) {
    query['AppIds'] = request.appIds;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfigApp',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function configApp(request: ConfigAppRequest): ConfigAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return configAppWithOptions(request, runtime);
}

model CreateAlertContactRequest {
  contactName?: string(name='ContactName'),
  dingRobotWebhookUrl?: string(name='DingRobotWebhookUrl'),
  email?: string(name='Email'),
  phoneNum?: string(name='PhoneNum'),
  regionId?: string(name='RegionId'),
  systemNoc?: boolean(name='SystemNoc'),
}

model CreateAlertContactResponseBody = {
  contactId?: string(name='ContactId'),
  requestId?: string(name='RequestId'),
}

model CreateAlertContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAlertContactResponseBody(name='body'),
}

async function createAlertContactWithOptions(request: CreateAlertContactRequest, runtime: Util.RuntimeOptions): CreateAlertContactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.dingRobotWebhookUrl)) {
    query['DingRobotWebhookUrl'] = request.dingRobotWebhookUrl;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.phoneNum)) {
    query['PhoneNum'] = request.phoneNum;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.systemNoc)) {
    query['SystemNoc'] = request.systemNoc;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlertContact',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAlertContact(request: CreateAlertContactRequest): CreateAlertContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAlertContactWithOptions(request, runtime);
}

model CreateAlertContactGroupRequest {
  contactGroupName?: string(name='ContactGroupName'),
  contactIds?: string(name='ContactIds'),
  regionId?: string(name='RegionId'),
}

model CreateAlertContactGroupResponseBody = {
  contactGroupId?: string(name='ContactGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateAlertContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAlertContactGroupResponseBody(name='body'),
}

async function createAlertContactGroupWithOptions(request: CreateAlertContactGroupRequest, runtime: Util.RuntimeOptions): CreateAlertContactGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupName)) {
    query['ContactGroupName'] = request.contactGroupName;
  }
  if (!Util.isUnset(request.contactIds)) {
    query['ContactIds'] = request.contactIds;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlertContactGroup',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAlertContactGroup(request: CreateAlertContactGroupRequest): CreateAlertContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAlertContactGroupWithOptions(request, runtime);
}

model CreateDispatchRuleRequest {
  dispatchRule?: string(name='DispatchRule'),
  regionId?: string(name='RegionId'),
}

model CreateDispatchRuleResponseBody = {
  dispatchRuleId?: long(name='DispatchRuleId'),
  requestId?: string(name='RequestId'),
}

model CreateDispatchRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDispatchRuleResponseBody(name='body'),
}

async function createDispatchRuleWithOptions(request: CreateDispatchRuleRequest, runtime: Util.RuntimeOptions): CreateDispatchRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dispatchRule)) {
    query['DispatchRule'] = request.dispatchRule;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDispatchRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDispatchRule(request: CreateDispatchRuleRequest): CreateDispatchRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDispatchRuleWithOptions(request, runtime);
}

model CreateIntegrationRequest {
  autoRecover?: boolean(name='AutoRecover'),
  description?: string(name='Description'),
  integrationName?: string(name='IntegrationName'),
  integrationProductType?: string(name='IntegrationProductType'),
  recoverTime?: long(name='RecoverTime'),
}

model CreateIntegrationResponseBody = {
  integration?: {
    autoRecover?: boolean(name='AutoRecover'),
    description?: string(name='Description'),
    integrationId?: long(name='IntegrationId'),
    integrationName?: string(name='IntegrationName'),
    integrationProductType?: string(name='IntegrationProductType'),
    recoverTime?: long(name='RecoverTime'),
  }(name='Integration'),
  requestId?: string(name='RequestId'),
}

model CreateIntegrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIntegrationResponseBody(name='body'),
}

async function createIntegrationWithOptions(request: CreateIntegrationRequest, runtime: Util.RuntimeOptions): CreateIntegrationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoRecover)) {
    body['AutoRecover'] = request.autoRecover;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.integrationName)) {
    body['IntegrationName'] = request.integrationName;
  }
  if (!Util.isUnset(request.integrationProductType)) {
    body['IntegrationProductType'] = request.integrationProductType;
  }
  if (!Util.isUnset(request.recoverTime)) {
    body['RecoverTime'] = request.recoverTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIntegration',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIntegration(request: CreateIntegrationRequest): CreateIntegrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIntegrationWithOptions(request, runtime);
}

model CreateOrUpdateAlertRuleRequest {
  alertCheckType?: string(name='AlertCheckType'),
  alertGroup?: long(name='AlertGroup'),
  alertId?: long(name='AlertId'),
  alertName?: string(name='AlertName'),
  alertRuleContent?: string(name='AlertRuleContent'),
  alertStatus?: string(name='AlertStatus'),
  alertType?: string(name='AlertType'),
  annotations?: string(name='Annotations'),
  autoAddNewApplication?: boolean(name='AutoAddNewApplication'),
  clusterId?: string(name='ClusterId'),
  duration?: long(name='Duration'),
  filters?: string(name='Filters'),
  labels?: string(name='Labels'),
  level?: string(name='Level'),
  message?: string(name='Message'),
  metricsKey?: string(name='MetricsKey'),
  metricsType?: string(name='MetricsType'),
  notifyStrategy?: string(name='NotifyStrategy'),
  pids?: string(name='Pids'),
  promQL?: string(name='PromQL'),
  regionId?: string(name='RegionId'),
}

model CreateOrUpdateAlertRuleResponseBody = {
  alertRule?: {
    alertCheckType?: string(name='AlertCheckType'),
    alertGroup?: long(name='AlertGroup'),
    alertId?: float(name='AlertId'),
    alertName?: string(name='AlertName'),
    alertRuleContent?: {
      alertRuleItems?: [ 
        {
          aggregate?: string(name='Aggregate'),
          metricKey?: string(name='MetricKey'),
          n?: float(name='N'),
          operator?: string(name='Operator'),
          value?: string(name='Value'),
        }
      ](name='AlertRuleItems'),
      condition?: string(name='Condition'),
    }(name='AlertRuleContent'),
    alertStatus?: string(name='AlertStatus'),
    alertType?: string(name='AlertType'),
    annotations?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Annotations'),
    autoAddNewApplication?: boolean(name='AutoAddNewApplication'),
    clusterId?: string(name='ClusterId'),
    createdTime?: long(name='CreatedTime'),
    duration?: string(name='Duration'),
    extend?: string(name='Extend'),
    filters?: {
      customSLSFilters?: [ 
        {
          key?: string(name='Key'),
          opt?: string(name='Opt'),
          show?: boolean(name='Show'),
          t?: string(name='T'),
          value?: string(name='Value'),
        }
      ](name='CustomSLSFilters'),
      customSLSGroupByDimensions?: [ string ](name='CustomSLSGroupByDimensions'),
      customSLSWheres?: [ string ](name='CustomSLSWheres'),
      dimFilters?: [ 
        {
          filterKey?: string(name='FilterKey'),
          filterOpt?: string(name='FilterOpt'),
          filterValues?: [ string ](name='FilterValues'),
        }
      ](name='DimFilters'),
    }(name='Filters'),
    labels?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Labels'),
    level?: string(name='Level'),
    message?: string(name='Message'),
    metricsType?: string(name='MetricsType'),
    notifyStrategy?: string(name='NotifyStrategy'),
    pids?: [ string ](name='Pids'),
    promQL?: string(name='PromQL'),
    regionId?: string(name='RegionId'),
    updatedTime?: long(name='UpdatedTime'),
    userId?: string(name='UserId'),
  }(name='AlertRule'),
  requestId?: string(name='RequestId'),
}

model CreateOrUpdateAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateAlertRuleResponseBody(name='body'),
}

async function createOrUpdateAlertRuleWithOptions(request: CreateOrUpdateAlertRuleRequest, runtime: Util.RuntimeOptions): CreateOrUpdateAlertRuleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alertCheckType)) {
    body['AlertCheckType'] = request.alertCheckType;
  }
  if (!Util.isUnset(request.alertGroup)) {
    body['AlertGroup'] = request.alertGroup;
  }
  if (!Util.isUnset(request.alertId)) {
    body['AlertId'] = request.alertId;
  }
  if (!Util.isUnset(request.alertName)) {
    body['AlertName'] = request.alertName;
  }
  if (!Util.isUnset(request.alertRuleContent)) {
    body['AlertRuleContent'] = request.alertRuleContent;
  }
  if (!Util.isUnset(request.alertStatus)) {
    body['AlertStatus'] = request.alertStatus;
  }
  if (!Util.isUnset(request.alertType)) {
    body['AlertType'] = request.alertType;
  }
  if (!Util.isUnset(request.annotations)) {
    body['Annotations'] = request.annotations;
  }
  if (!Util.isUnset(request.autoAddNewApplication)) {
    body['AutoAddNewApplication'] = request.autoAddNewApplication;
  }
  if (!Util.isUnset(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.duration)) {
    body['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.filters)) {
    body['Filters'] = request.filters;
  }
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.level)) {
    body['Level'] = request.level;
  }
  if (!Util.isUnset(request.message)) {
    body['Message'] = request.message;
  }
  if (!Util.isUnset(request.metricsKey)) {
    body['MetricsKey'] = request.metricsKey;
  }
  if (!Util.isUnset(request.metricsType)) {
    body['MetricsType'] = request.metricsType;
  }
  if (!Util.isUnset(request.notifyStrategy)) {
    body['NotifyStrategy'] = request.notifyStrategy;
  }
  if (!Util.isUnset(request.pids)) {
    body['Pids'] = request.pids;
  }
  if (!Util.isUnset(request.promQL)) {
    body['PromQL'] = request.promQL;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateAlertRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateAlertRule(request: CreateOrUpdateAlertRuleRequest): CreateOrUpdateAlertRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateAlertRuleWithOptions(request, runtime);
}

model CreateOrUpdateContactRequest {
  contactId?: long(name='ContactId'),
  contactName?: string(name='ContactName'),
  email?: string(name='Email'),
  phone?: string(name='Phone'),
  reissueSendNotice?: long(name='ReissueSendNotice'),
}

model CreateOrUpdateContactResponseBody = {
  alertContact?: {
    contactId?: float(name='ContactId'),
    contactName?: string(name='ContactName'),
    email?: string(name='Email'),
    isVerify?: boolean(name='IsVerify'),
    phone?: string(name='Phone'),
    reissueSendNotice?: long(name='ReissueSendNotice'),
  }(name='AlertContact'),
  requestId?: string(name='RequestId'),
}

model CreateOrUpdateContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateContactResponseBody(name='body'),
}

async function createOrUpdateContactWithOptions(request: CreateOrUpdateContactRequest, runtime: Util.RuntimeOptions): CreateOrUpdateContactResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.contactId)) {
    body['ContactId'] = request.contactId;
  }
  if (!Util.isUnset(request.contactName)) {
    body['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.email)) {
    body['Email'] = request.email;
  }
  if (!Util.isUnset(request.phone)) {
    body['Phone'] = request.phone;
  }
  if (!Util.isUnset(request.reissueSendNotice)) {
    body['ReissueSendNotice'] = request.reissueSendNotice;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateContact',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateContact(request: CreateOrUpdateContactRequest): CreateOrUpdateContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateContactWithOptions(request, runtime);
}

model CreateOrUpdateContactGroupRequest {
  contactGroupId?: long(name='ContactGroupId'),
  contactGroupName?: string(name='ContactGroupName'),
  contactIds?: string(name='ContactIds'),
}

model CreateOrUpdateContactGroupResponseBody = {
  alertContactGroup?: {
    contactGroupId?: float(name='ContactGroupId'),
    contactGroupName?: string(name='ContactGroupName'),
    contactIds?: string(name='ContactIds'),
  }(name='AlertContactGroup'),
  requestId?: string(name='RequestId'),
}

model CreateOrUpdateContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateContactGroupResponseBody(name='body'),
}

async function createOrUpdateContactGroupWithOptions(request: CreateOrUpdateContactGroupRequest, runtime: Util.RuntimeOptions): CreateOrUpdateContactGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.contactGroupId)) {
    body['ContactGroupId'] = request.contactGroupId;
  }
  if (!Util.isUnset(request.contactGroupName)) {
    body['ContactGroupName'] = request.contactGroupName;
  }
  if (!Util.isUnset(request.contactIds)) {
    body['ContactIds'] = request.contactIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateContactGroup',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateContactGroup(request: CreateOrUpdateContactGroupRequest): CreateOrUpdateContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateContactGroupWithOptions(request, runtime);
}

model CreateOrUpdateEventBridgeIntegrationRequest {
  accessKey?: string(name='AccessKey'),
  accessSecret?: string(name='AccessSecret'),
  description?: string(name='Description'),
  endpoint?: string(name='Endpoint'),
  eventBusName?: string(name='EventBusName'),
  eventBusRegionId?: string(name='EventBusRegionId'),
  id?: long(name='Id'),
  name?: string(name='Name'),
  source?: string(name='Source'),
}

model CreateOrUpdateEventBridgeIntegrationResponseBody = {
  eventBridgeIntegration?: {
    accessKey?: string(name='AccessKey'),
    accessSecret?: string(name='AccessSecret'),
    description?: string(name='Description'),
    endpoint?: string(name='Endpoint'),
    eventBusName?: string(name='EventBusName'),
    eventBusRegionId?: string(name='EventBusRegionId'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    source?: string(name='Source'),
  }(name='EventBridgeIntegration'),
  requestId?: string(name='RequestId'),
}

model CreateOrUpdateEventBridgeIntegrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateEventBridgeIntegrationResponseBody(name='body'),
}

async function createOrUpdateEventBridgeIntegrationWithOptions(request: CreateOrUpdateEventBridgeIntegrationRequest, runtime: Util.RuntimeOptions): CreateOrUpdateEventBridgeIntegrationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessKey)) {
    body['AccessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.accessSecret)) {
    body['AccessSecret'] = request.accessSecret;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.endpoint)) {
    body['Endpoint'] = request.endpoint;
  }
  if (!Util.isUnset(request.eventBusName)) {
    body['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventBusRegionId)) {
    body['EventBusRegionId'] = request.eventBusRegionId;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.source)) {
    body['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateEventBridgeIntegration',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateEventBridgeIntegration(request: CreateOrUpdateEventBridgeIntegrationRequest): CreateOrUpdateEventBridgeIntegrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateEventBridgeIntegrationWithOptions(request, runtime);
}

model CreateOrUpdateIMRobotRequest {
  cardTemplate?: string(name='CardTemplate'),
  dailyNoc?: boolean(name='DailyNoc'),
  dailyNocTime?: string(name='DailyNocTime'),
  enableOutgoing?: boolean(name='EnableOutgoing'),
  robotAddress?: string(name='RobotAddress'),
  robotId?: long(name='RobotId'),
  robotName?: string(name='RobotName'),
  token?: string(name='Token'),
  type?: string(name='Type'),
}

model CreateOrUpdateIMRobotResponseBody = {
  alertRobot?: {
    cardTemplate?: string(name='CardTemplate'),
    dailyNoc?: boolean(name='DailyNoc'),
    dailyNocTime?: string(name='DailyNocTime'),
    enableOutgoing?: boolean(name='EnableOutgoing'),
    robotAddress?: string(name='RobotAddress'),
    robotId?: float(name='RobotId'),
    robotName?: string(name='RobotName'),
    token?: string(name='Token'),
    type?: string(name='Type'),
  }(name='AlertRobot'),
  requestId?: string(name='RequestId'),
}

model CreateOrUpdateIMRobotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateIMRobotResponseBody(name='body'),
}

async function createOrUpdateIMRobotWithOptions(request: CreateOrUpdateIMRobotRequest, runtime: Util.RuntimeOptions): CreateOrUpdateIMRobotResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.cardTemplate)) {
    body['CardTemplate'] = request.cardTemplate;
  }
  if (!Util.isUnset(request.dailyNoc)) {
    body['DailyNoc'] = request.dailyNoc;
  }
  if (!Util.isUnset(request.dailyNocTime)) {
    body['DailyNocTime'] = request.dailyNocTime;
  }
  if (!Util.isUnset(request.enableOutgoing)) {
    body['EnableOutgoing'] = request.enableOutgoing;
  }
  if (!Util.isUnset(request.robotAddress)) {
    body['RobotAddress'] = request.robotAddress;
  }
  if (!Util.isUnset(request.robotId)) {
    body['RobotId'] = request.robotId;
  }
  if (!Util.isUnset(request.robotName)) {
    body['RobotName'] = request.robotName;
  }
  if (!Util.isUnset(request.token)) {
    body['Token'] = request.token;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateIMRobot',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateIMRobot(request: CreateOrUpdateIMRobotRequest): CreateOrUpdateIMRobotResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateIMRobotWithOptions(request, runtime);
}

model CreateOrUpdateNotificationPolicyRequest {
  escalationPolicyId?: long(name='EscalationPolicyId'),
  groupRule?: string(name='GroupRule'),
  id?: long(name='Id'),
  integrationId?: long(name='IntegrationId'),
  matchingRules?: string(name='MatchingRules'),
  name?: string(name='Name'),
  notifyRule?: string(name='NotifyRule'),
  notifyTemplate?: string(name='NotifyTemplate'),
  regionId?: string(name='RegionId'),
  repeat?: boolean(name='Repeat'),
  repeatInterval?: long(name='RepeatInterval'),
  sendRecoverMessage?: boolean(name='SendRecoverMessage'),
}

model CreateOrUpdateNotificationPolicyResponseBody = {
  notificationPolicy?: {
    escalationPolicyId?: long(name='EscalationPolicyId'),
    groupRule?: {
      groupInterval?: long(name='GroupInterval'),
      groupWait?: long(name='GroupWait'),
      groupingFields?: [ string ](name='GroupingFields'),
    }(name='GroupRule'),
    id?: long(name='Id'),
    integrationId?: long(name='IntegrationId'),
    matchingRules?: [ 
      {
        matchingConditions?: [ 
          {
            key?: string(name='Key'),
            operator?: string(name='Operator'),
            value?: string(name='Value'),
          }
        ](name='MatchingConditions'),
      }
    ](name='MatchingRules'),
    name?: string(name='Name'),
    notifyRule?: {
      notifyChannels?: [ string ](name='NotifyChannels'),
      notifyEndTime?: string(name='NotifyEndTime'),
      notifyObjects?: [ 
        {
          notifyObjectId?: long(name='NotifyObjectId'),
          notifyObjectName?: string(name='NotifyObjectName'),
          notifyObjectType?: string(name='NotifyObjectType'),
        }
      ](name='NotifyObjects'),
      notifyStartTime?: string(name='NotifyStartTime'),
    }(name='NotifyRule'),
    notifyTemplate?: {
      emailContent?: string(name='EmailContent'),
      emailRecoverContent?: string(name='EmailRecoverContent'),
      emailRecoverTitle?: string(name='EmailRecoverTitle'),
      emailTitle?: string(name='EmailTitle'),
      robotContent?: string(name='RobotContent'),
      smsContent?: string(name='SmsContent'),
      smsRecoverContent?: string(name='SmsRecoverContent'),
      ttsContent?: string(name='TtsContent'),
      ttsRecoverContent?: string(name='TtsRecoverContent'),
    }(name='NotifyTemplate'),
    repeat?: boolean(name='Repeat'),
    repeatInterval?: long(name='RepeatInterval'),
    sendRecoverMessage?: boolean(name='SendRecoverMessage'),
  }(name='NotificationPolicy'),
  requestId?: string(name='RequestId'),
}

model CreateOrUpdateNotificationPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateNotificationPolicyResponseBody(name='body'),
}

async function createOrUpdateNotificationPolicyWithOptions(request: CreateOrUpdateNotificationPolicyRequest, runtime: Util.RuntimeOptions): CreateOrUpdateNotificationPolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.escalationPolicyId)) {
    body['EscalationPolicyId'] = request.escalationPolicyId;
  }
  if (!Util.isUnset(request.groupRule)) {
    body['GroupRule'] = request.groupRule;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.integrationId)) {
    body['IntegrationId'] = request.integrationId;
  }
  if (!Util.isUnset(request.matchingRules)) {
    body['MatchingRules'] = request.matchingRules;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.notifyRule)) {
    body['NotifyRule'] = request.notifyRule;
  }
  if (!Util.isUnset(request.notifyTemplate)) {
    body['NotifyTemplate'] = request.notifyTemplate;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.repeat)) {
    body['Repeat'] = request.repeat;
  }
  if (!Util.isUnset(request.repeatInterval)) {
    body['RepeatInterval'] = request.repeatInterval;
  }
  if (!Util.isUnset(request.sendRecoverMessage)) {
    body['SendRecoverMessage'] = request.sendRecoverMessage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateNotificationPolicy',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateNotificationPolicy(request: CreateOrUpdateNotificationPolicyRequest): CreateOrUpdateNotificationPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateNotificationPolicyWithOptions(request, runtime);
}

model CreateOrUpdateSilencePolicyRequest {
  id?: long(name='Id'),
  matchingRules?: string(name='MatchingRules'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model CreateOrUpdateSilencePolicyResponseBody = {
  requestId?: string(name='RequestId'),
  silencePolicy?: {
    id?: long(name='Id'),
    matchingRules?: [ 
      {
        matchingConditions?: [ 
          {
            key?: string(name='Key'),
            operator?: string(name='Operator'),
            value?: string(name='Value'),
          }
        ](name='MatchingConditions'),
      }
    ](name='MatchingRules'),
    name?: string(name='Name'),
  }(name='SilencePolicy'),
}

model CreateOrUpdateSilencePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateSilencePolicyResponseBody(name='body'),
}

async function createOrUpdateSilencePolicyWithOptions(request: CreateOrUpdateSilencePolicyRequest, runtime: Util.RuntimeOptions): CreateOrUpdateSilencePolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.matchingRules)) {
    body['MatchingRules'] = request.matchingRules;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateSilencePolicy',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateSilencePolicy(request: CreateOrUpdateSilencePolicyRequest): CreateOrUpdateSilencePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateSilencePolicyWithOptions(request, runtime);
}

model CreateOrUpdateWebhookContactRequest {
  bizHeaders?: string(name='BizHeaders'),
  bizParams?: string(name='BizParams'),
  body?: string(name='Body'),
  method?: string(name='Method'),
  recoverBody?: string(name='RecoverBody'),
  url?: string(name='Url'),
  webhookId?: long(name='WebhookId'),
  webhookName?: string(name='WebhookName'),
}

model CreateOrUpdateWebhookContactResponseBody = {
  requestId?: string(name='RequestId'),
  webhookContact?: {
    webhook?: {
      bizHeaders?: string(name='BizHeaders'),
      bizParams?: string(name='BizParams'),
      body?: string(name='Body'),
      method?: string(name='Method'),
      recoverBody?: string(name='RecoverBody'),
      url?: string(name='Url'),
    }(name='Webhook'),
    webhookId?: float(name='WebhookId'),
    webhookName?: string(name='WebhookName'),
  }(name='WebhookContact'),
}

model CreateOrUpdateWebhookContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateWebhookContactResponseBody(name='body'),
}

async function createOrUpdateWebhookContactWithOptions(request: CreateOrUpdateWebhookContactRequest, runtime: Util.RuntimeOptions): CreateOrUpdateWebhookContactResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizHeaders)) {
    body['BizHeaders'] = request.bizHeaders;
  }
  if (!Util.isUnset(request.bizParams)) {
    body['BizParams'] = request.bizParams;
  }
  if (!Util.isUnset(request.body)) {
    body['Body'] = request.body;
  }
  if (!Util.isUnset(request.method)) {
    body['Method'] = request.method;
  }
  if (!Util.isUnset(request.recoverBody)) {
    body['RecoverBody'] = request.recoverBody;
  }
  if (!Util.isUnset(request.url)) {
    body['Url'] = request.url;
  }
  if (!Util.isUnset(request.webhookId)) {
    body['WebhookId'] = request.webhookId;
  }
  if (!Util.isUnset(request.webhookName)) {
    body['WebhookName'] = request.webhookName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateWebhookContact',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateWebhookContact(request: CreateOrUpdateWebhookContactRequest): CreateOrUpdateWebhookContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateWebhookContactWithOptions(request, runtime);
}

model CreatePrometheusAlertRuleRequest {
  alertName?: string(name='AlertName'),
  annotations?: string(name='Annotations'),
  clusterId?: string(name='ClusterId'),
  dispatchRuleId?: long(name='DispatchRuleId'),
  duration?: string(name='Duration'),
  expression?: string(name='Expression'),
  labels?: string(name='Labels'),
  message?: string(name='Message'),
  notifyType?: string(name='NotifyType'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
}

model CreatePrometheusAlertRuleResponseBody = {
  prometheusAlertRule?: {
    alertId?: long(name='AlertId'),
    alertName?: string(name='AlertName'),
    annotations?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Annotations'),
    clusterId?: string(name='ClusterId'),
    dispatchRuleId?: long(name='DispatchRuleId'),
    duration?: string(name='Duration'),
    expression?: string(name='Expression'),
    labels?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Labels'),
    message?: string(name='Message'),
    notifyType?: string(name='NotifyType'),
    status?: int32(name='Status'),
    type?: string(name='Type'),
  }(name='PrometheusAlertRule'),
  requestId?: string(name='RequestId'),
}

model CreatePrometheusAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePrometheusAlertRuleResponseBody(name='body'),
}

async function createPrometheusAlertRuleWithOptions(request: CreatePrometheusAlertRuleRequest, runtime: Util.RuntimeOptions): CreatePrometheusAlertRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertName)) {
    query['AlertName'] = request.alertName;
  }
  if (!Util.isUnset(request.annotations)) {
    query['Annotations'] = request.annotations;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dispatchRuleId)) {
    query['DispatchRuleId'] = request.dispatchRuleId;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.expression)) {
    query['Expression'] = request.expression;
  }
  if (!Util.isUnset(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  if (!Util.isUnset(request.notifyType)) {
    query['NotifyType'] = request.notifyType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePrometheusAlertRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPrometheusAlertRule(request: CreatePrometheusAlertRuleRequest): CreatePrometheusAlertRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPrometheusAlertRuleWithOptions(request, runtime);
}

model CreateRetcodeAppRequest {
  regionId?: string(name='RegionId'),
  retcodeAppName?: string(name='RetcodeAppName'),
  retcodeAppType?: string(name='RetcodeAppType'),
}

model CreateRetcodeAppResponseBody = {
  requestId?: string(name='RequestId'),
  retcodeAppDataBean?: {
    appId?: long(name='AppId'),
    pid?: string(name='Pid'),
  }(name='RetcodeAppDataBean'),
}

model CreateRetcodeAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRetcodeAppResponseBody(name='body'),
}

async function createRetcodeAppWithOptions(request: CreateRetcodeAppRequest, runtime: Util.RuntimeOptions): CreateRetcodeAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.retcodeAppName)) {
    query['RetcodeAppName'] = request.retcodeAppName;
  }
  if (!Util.isUnset(request.retcodeAppType)) {
    query['RetcodeAppType'] = request.retcodeAppType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRetcodeApp',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRetcodeApp(request: CreateRetcodeAppRequest): CreateRetcodeAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRetcodeAppWithOptions(request, runtime);
}

model CreateSyntheticTaskRequest {
  commonParam?: {
    alarmFlag?: string(name='AlarmFlag'),
    alertList?: [ 
      {
        isCritical?: long(name='IsCritical'),
        name?: string(name='Name'),
        symbols?: long(name='Symbols'),
      }
    ](name='AlertList'),
    alertNotifierId?: string(name='AlertNotifierId'),
    alertPolicyId?: string(name='AlertPolicyId'),
    monitorSamples?: long(name='MonitorSamples'),
    startExecutionTime?: long(name='StartExecutionTime'),
  }(name='CommonParam'),
  download?: {
    connectionTimeout?: double(name='ConnectionTimeout'),
    downloadCustomHeaderContent?: string(name='DownloadCustomHeaderContent'),
    downloadCustomHost?: long(name='DownloadCustomHost'),
    downloadCustomHostIp?: string(name='DownloadCustomHostIp'),
    downloadIgnoreCertificateError?: string(name='DownloadIgnoreCertificateError'),
    downloadKernel?: long(name='DownloadKernel'),
    downloadRedirection?: long(name='DownloadRedirection'),
    downloadTransmissionSize?: long(name='DownloadTransmissionSize'),
    monitorTimeout?: long(name='MonitorTimeout'),
    quickProtocol?: string(name='QuickProtocol'),
    validateKeywords?: string(name='ValidateKeywords'),
    verifyWay?: long(name='VerifyWay'),
    whiteList?: string(name='WhiteList'),
  }(name='Download'),
  extendInterval?: {
    days?: [ long ](name='Days'),
    endHour?: long(name='EndHour'),
    endMinute?: long(name='EndMinute'),
    endTime?: string(name='EndTime'),
    startHour?: long(name='StartHour'),
    startMinute?: long(name='StartMinute'),
    startTime?: string(name='StartTime'),
  }(name='ExtendInterval'),
  intervalTime?: string(name='IntervalTime'),
  intervalType?: string(name='IntervalType'),
  ipType?: long(name='IpType'),
  monitorList?: [ 
    {
      cityCode?: long(name='CityCode'),
      monitorType?: long(name='MonitorType'),
      netServiceId?: long(name='NetServiceId'),
    }
  ](name='MonitorList'),
  navigation?: {
    DNSHijackWhiteList?: string(name='DNSHijackWhiteList'),
    elementBlacklist?: string(name='ElementBlacklist'),
    executeActiveX?: long(name='ExecuteActiveX'),
    executeApplication?: long(name='ExecuteApplication'),
    executeScript?: long(name='ExecuteScript'),
    filterInvalidIP?: long(name='FilterInvalidIP'),
    flowHijackJumpTimes?: long(name='FlowHijackJumpTimes'),
    flowHijackLogo?: string(name='FlowHijackLogo'),
    monitorTimeout?: string(name='MonitorTimeout'),
    navAutomaticScrolling?: string(name='NavAutomaticScrolling'),
    navCustomHeader?: string(name='NavCustomHeader'),
    navCustomHeaderContent?: string(name='NavCustomHeaderContent'),
    navCustomHost?: long(name='NavCustomHost'),
    navCustomHostIp?: string(name='NavCustomHostIp'),
    navDisableCache?: long(name='NavDisableCache'),
    navDisableCompression?: string(name='NavDisableCompression'),
    navIgnoreCertificateError?: long(name='NavIgnoreCertificateError'),
    navRedirection?: long(name='NavRedirection'),
    navReturnElement?: long(name='NavReturnElement'),
    pageTamper?: string(name='PageTamper'),
    processName?: string(name='ProcessName'),
    QUICDomain?: string(name='QUICDomain'),
    QUICVersion?: long(name='QUICVersion'),
    requestHeader?: long(name='RequestHeader'),
    responseHeader?: long(name='ResponseHeader'),
    slowElementThreshold?: double(name='SlowElementThreshold'),
    verifyStringBlacklist?: string(name='VerifyStringBlacklist'),
    verifyStringWhiteList?: string(name='VerifyStringWhiteList'),
    waitCompletionTime?: double(name='WaitCompletionTime'),
  }(name='Navigation'),
  net?: {
    netDNSNs?: string(name='NetDNSNs'),
    netDNSQueryMethod?: long(name='NetDNSQueryMethod'),
    netDNSServer?: long(name='NetDNSServer'),
    netDNSSwitch?: long(name='NetDNSSwitch'),
    netDNSTimeout?: long(name='NetDNSTimeout'),
    netDigSwitch?: long(name='NetDigSwitch'),
    netICMPActive?: long(name='NetICMPActive'),
    netICMPDataCut?: long(name='NetICMPDataCut'),
    netICMPInterval?: long(name='NetICMPInterval'),
    netICMPNum?: long(name='NetICMPNum'),
    netICMPSize?: long(name='NetICMPSize'),
    netICMPSwitch?: long(name='NetICMPSwitch'),
    netICMPTimeout?: long(name='NetICMPTimeout'),
    netTraceRouteNum?: long(name='NetTraceRouteNum'),
    netTraceRouteSwitch?: long(name='NetTraceRouteSwitch'),
    netTraceRouteTimeout?: long(name='NetTraceRouteTimeout'),
    whiteList?: string(name='WhiteList'),
  }(name='Net'),
  protocol?: {
    characterEncoding?: long(name='CharacterEncoding'),
    customHost?: long(name='CustomHost'),
    customHostIp?: string(name='CustomHostIp'),
    protocolConnectionTime?: long(name='ProtocolConnectionTime'),
    protocolMonitorTimeout?: string(name='ProtocolMonitorTimeout'),
    receivedDataSize?: long(name='ReceivedDataSize'),
    requestContent?: {
      body?: {
        formData?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='FormData'),
        language?: string(name='Language'),
        mode?: string(name='Mode'),
        raw?: string(name='Raw'),
        urlEncoding?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='UrlEncoding'),
      }(name='Body'),
      header?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Header'),
      method?: string(name='Method'),
    }(name='RequestContent'),
    verifyContent?: string(name='VerifyContent'),
    verifyWay?: long(name='VerifyWay'),
  }(name='Protocol'),
  regionId?: string(name='RegionId'),
  taskName?: string(name='TaskName'),
  taskType?: long(name='TaskType'),
  updateTask?: boolean(name='UpdateTask'),
  url?: string(name='Url'),
}

model CreateSyntheticTaskShrinkRequest {
  commonParamShrink?: string(name='CommonParam'),
  downloadShrink?: string(name='Download'),
  extendIntervalShrink?: string(name='ExtendInterval'),
  intervalTime?: string(name='IntervalTime'),
  intervalType?: string(name='IntervalType'),
  ipType?: long(name='IpType'),
  monitorListShrink?: string(name='MonitorList'),
  navigationShrink?: string(name='Navigation'),
  netShrink?: string(name='Net'),
  protocolShrink?: string(name='Protocol'),
  regionId?: string(name='RegionId'),
  taskName?: string(name='TaskName'),
  taskType?: long(name='TaskType'),
  updateTask?: boolean(name='UpdateTask'),
  url?: string(name='Url'),
}

model CreateSyntheticTaskResponseBody = {
  code?: string(name='Code'),
  data?: {
    taskId?: long(name='TaskId'),
  }(name='Data'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
}

model CreateSyntheticTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSyntheticTaskResponseBody(name='body'),
}

async function createSyntheticTaskWithOptions(tmpReq: CreateSyntheticTaskRequest, runtime: Util.RuntimeOptions): CreateSyntheticTaskResponse {
  Util.validateModel(tmpReq);
  var request = new CreateSyntheticTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.commonParam)) {
    request.commonParamShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.commonParam, 'CommonParam', 'json');
  }
  if (!Util.isUnset(tmpReq.download)) {
    request.downloadShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.download, 'Download', 'json');
  }
  if (!Util.isUnset(tmpReq.extendInterval)) {
    request.extendIntervalShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extendInterval, 'ExtendInterval', 'json');
  }
  if (!Util.isUnset(tmpReq.monitorList)) {
    request.monitorListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.monitorList, 'MonitorList', 'json');
  }
  if (!Util.isUnset(tmpReq.navigation)) {
    request.navigationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.navigation, 'Navigation', 'json');
  }
  if (!Util.isUnset(tmpReq.net)) {
    request.netShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.net, 'Net', 'json');
  }
  if (!Util.isUnset(tmpReq.protocol)) {
    request.protocolShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.protocol, 'Protocol', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.commonParamShrink)) {
    query['CommonParam'] = request.commonParamShrink;
  }
  if (!Util.isUnset(request.downloadShrink)) {
    query['Download'] = request.downloadShrink;
  }
  if (!Util.isUnset(request.extendIntervalShrink)) {
    query['ExtendInterval'] = request.extendIntervalShrink;
  }
  if (!Util.isUnset(request.intervalTime)) {
    query['IntervalTime'] = request.intervalTime;
  }
  if (!Util.isUnset(request.intervalType)) {
    query['IntervalType'] = request.intervalType;
  }
  if (!Util.isUnset(request.ipType)) {
    query['IpType'] = request.ipType;
  }
  if (!Util.isUnset(request.monitorListShrink)) {
    query['MonitorList'] = request.monitorListShrink;
  }
  if (!Util.isUnset(request.navigationShrink)) {
    query['Navigation'] = request.navigationShrink;
  }
  if (!Util.isUnset(request.netShrink)) {
    query['Net'] = request.netShrink;
  }
  if (!Util.isUnset(request.protocolShrink)) {
    query['Protocol'] = request.protocolShrink;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  if (!Util.isUnset(request.updateTask)) {
    query['UpdateTask'] = request.updateTask;
  }
  if (!Util.isUnset(request.url)) {
    query['Url'] = request.url;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSyntheticTask',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSyntheticTask(request: CreateSyntheticTaskRequest): CreateSyntheticTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSyntheticTaskWithOptions(request, runtime);
}

model CreateWebhookRequest {
  body?: string(name='Body'),
  contactName?: string(name='ContactName'),
  httpHeaders?: string(name='HttpHeaders'),
  httpParams?: string(name='HttpParams'),
  method?: string(name='Method'),
  recoverBody?: string(name='RecoverBody'),
  regionId?: string(name='RegionId'),
  url?: string(name='Url'),
}

model CreateWebhookResponseBody = {
  contactId?: string(name='ContactId'),
  requestId?: string(name='RequestId'),
}

model CreateWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateWebhookResponseBody(name='body'),
}

async function createWebhookWithOptions(request: CreateWebhookRequest, runtime: Util.RuntimeOptions): CreateWebhookResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.body)) {
    query['Body'] = request.body;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.httpHeaders)) {
    query['HttpHeaders'] = request.httpHeaders;
  }
  if (!Util.isUnset(request.httpParams)) {
    query['HttpParams'] = request.httpParams;
  }
  if (!Util.isUnset(request.method)) {
    query['Method'] = request.method;
  }
  if (!Util.isUnset(request.recoverBody)) {
    query['RecoverBody'] = request.recoverBody;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.url)) {
    query['Url'] = request.url;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateWebhook',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createWebhook(request: CreateWebhookRequest): CreateWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  return createWebhookWithOptions(request, runtime);
}

model DelAuthTokenRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
}

model DelAuthTokenResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DelAuthTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DelAuthTokenResponseBody(name='body'),
}

async function delAuthTokenWithOptions(request: DelAuthTokenRequest, runtime: Util.RuntimeOptions): DelAuthTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DelAuthToken',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function delAuthToken(request: DelAuthTokenRequest): DelAuthTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return delAuthTokenWithOptions(request, runtime);
}

model DeleteAlertContactRequest {
  contactId?: long(name='ContactId'),
  regionId?: string(name='RegionId'),
}

model DeleteAlertContactResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteAlertContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAlertContactResponseBody(name='body'),
}

async function deleteAlertContactWithOptions(request: DeleteAlertContactRequest, runtime: Util.RuntimeOptions): DeleteAlertContactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactId)) {
    query['ContactId'] = request.contactId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlertContact',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAlertContact(request: DeleteAlertContactRequest): DeleteAlertContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlertContactWithOptions(request, runtime);
}

model DeleteAlertContactGroupRequest {
  contactGroupId?: long(name='ContactGroupId'),
  regionId?: string(name='RegionId'),
}

model DeleteAlertContactGroupResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteAlertContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAlertContactGroupResponseBody(name='body'),
}

async function deleteAlertContactGroupWithOptions(request: DeleteAlertContactGroupRequest, runtime: Util.RuntimeOptions): DeleteAlertContactGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupId)) {
    query['ContactGroupId'] = request.contactGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlertContactGroup',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAlertContactGroup(request: DeleteAlertContactGroupRequest): DeleteAlertContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlertContactGroupWithOptions(request, runtime);
}

model DeleteAlertRuleRequest {
  alertId?: long(name='AlertId'),
}

model DeleteAlertRuleResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAlertRuleResponseBody(name='body'),
}

async function deleteAlertRuleWithOptions(request: DeleteAlertRuleRequest, runtime: Util.RuntimeOptions): DeleteAlertRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlertRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAlertRule(request: DeleteAlertRuleRequest): DeleteAlertRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlertRuleWithOptions(request, runtime);
}

model DeleteAlertRulesRequest {
  alertIds?: string(name='AlertIds'),
  regionId?: string(name='RegionId'),
}

model DeleteAlertRulesResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAlertRulesResponseBody(name='body'),
}

async function deleteAlertRulesWithOptions(request: DeleteAlertRulesRequest, runtime: Util.RuntimeOptions): DeleteAlertRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertIds)) {
    query['AlertIds'] = request.alertIds;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlertRules',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAlertRules(request: DeleteAlertRulesRequest): DeleteAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlertRulesWithOptions(request, runtime);
}

model DeleteCmsExporterRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
}

model DeleteCmsExporterResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteCmsExporterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCmsExporterResponseBody(name='body'),
}

async function deleteCmsExporterWithOptions(request: DeleteCmsExporterRequest, runtime: Util.RuntimeOptions): DeleteCmsExporterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCmsExporter',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCmsExporter(request: DeleteCmsExporterRequest): DeleteCmsExporterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCmsExporterWithOptions(request, runtime);
}

model DeleteContactRequest {
  contactId?: long(name='ContactId'),
}

model DeleteContactResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteContactResponseBody(name='body'),
}

async function deleteContactWithOptions(request: DeleteContactRequest, runtime: Util.RuntimeOptions): DeleteContactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactId)) {
    query['ContactId'] = request.contactId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteContact',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteContact(request: DeleteContactRequest): DeleteContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContactWithOptions(request, runtime);
}

model DeleteContactGroupRequest {
  contactGroupId?: long(name='ContactGroupId'),
}

model DeleteContactGroupResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteContactGroupResponseBody(name='body'),
}

async function deleteContactGroupWithOptions(request: DeleteContactGroupRequest, runtime: Util.RuntimeOptions): DeleteContactGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupId)) {
    query['ContactGroupId'] = request.contactGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteContactGroup',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteContactGroup(request: DeleteContactGroupRequest): DeleteContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContactGroupWithOptions(request, runtime);
}

model DeleteDispatchRuleRequest {
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
}

model DeleteDispatchRuleResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDispatchRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDispatchRuleResponseBody(name='body'),
}

async function deleteDispatchRuleWithOptions(request: DeleteDispatchRuleRequest, runtime: Util.RuntimeOptions): DeleteDispatchRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDispatchRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDispatchRule(request: DeleteDispatchRuleRequest): DeleteDispatchRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDispatchRuleWithOptions(request, runtime);
}

model DeleteEventBridgeIntegrationRequest {
  id?: long(name='Id'),
}

model DeleteEventBridgeIntegrationResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteEventBridgeIntegrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEventBridgeIntegrationResponseBody(name='body'),
}

async function deleteEventBridgeIntegrationWithOptions(request: DeleteEventBridgeIntegrationRequest, runtime: Util.RuntimeOptions): DeleteEventBridgeIntegrationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEventBridgeIntegration',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEventBridgeIntegration(request: DeleteEventBridgeIntegrationRequest): DeleteEventBridgeIntegrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventBridgeIntegrationWithOptions(request, runtime);
}

model DeleteGrafanaResourceRequest {
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  regionId?: string(name='RegionId'),
}

model DeleteGrafanaResourceResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteGrafanaResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGrafanaResourceResponseBody(name='body'),
}

async function deleteGrafanaResourceWithOptions(request: DeleteGrafanaResourceRequest, runtime: Util.RuntimeOptions): DeleteGrafanaResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    body['ClusterName'] = request.clusterName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGrafanaResource',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGrafanaResource(request: DeleteGrafanaResourceRequest): DeleteGrafanaResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGrafanaResourceWithOptions(request, runtime);
}

model DeleteIMRobotRequest {
  robotId?: long(name='RobotId'),
}

model DeleteIMRobotResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteIMRobotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIMRobotResponseBody(name='body'),
}

async function deleteIMRobotWithOptions(request: DeleteIMRobotRequest, runtime: Util.RuntimeOptions): DeleteIMRobotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.robotId)) {
    query['RobotId'] = request.robotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIMRobot',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIMRobot(request: DeleteIMRobotRequest): DeleteIMRobotResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIMRobotWithOptions(request, runtime);
}

model DeleteIntegrationRequest {
  clusterId?: string(name='ClusterId'),
  integration?: string(name='Integration'),
  regionId?: string(name='RegionId'),
}

model DeleteIntegrationResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteIntegrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIntegrationResponseBody(name='body'),
}

async function deleteIntegrationWithOptions(request: DeleteIntegrationRequest, runtime: Util.RuntimeOptions): DeleteIntegrationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.integration)) {
    query['Integration'] = request.integration;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIntegration',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIntegration(request: DeleteIntegrationRequest): DeleteIntegrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIntegrationWithOptions(request, runtime);
}

model DeleteIntegrationsRequest {
  integrationId?: long(name='IntegrationId'),
}

model DeleteIntegrationsResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteIntegrationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIntegrationsResponseBody(name='body'),
}

async function deleteIntegrationsWithOptions(request: DeleteIntegrationsRequest, runtime: Util.RuntimeOptions): DeleteIntegrationsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIntegrations',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIntegrations(request: DeleteIntegrationsRequest): DeleteIntegrationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIntegrationsWithOptions(request, runtime);
}

model DeleteNotificationPolicyRequest {
  id?: long(name='Id'),
}

model DeleteNotificationPolicyResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteNotificationPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNotificationPolicyResponseBody(name='body'),
}

async function deleteNotificationPolicyWithOptions(request: DeleteNotificationPolicyRequest, runtime: Util.RuntimeOptions): DeleteNotificationPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNotificationPolicy',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNotificationPolicy(request: DeleteNotificationPolicyRequest): DeleteNotificationPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNotificationPolicyWithOptions(request, runtime);
}

model DeletePrometheusAlertRuleRequest {
  alertId?: long(name='AlertId'),
}

model DeletePrometheusAlertRuleResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeletePrometheusAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePrometheusAlertRuleResponseBody(name='body'),
}

async function deletePrometheusAlertRuleWithOptions(request: DeletePrometheusAlertRuleRequest, runtime: Util.RuntimeOptions): DeletePrometheusAlertRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePrometheusAlertRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePrometheusAlertRule(request: DeletePrometheusAlertRuleRequest): DeletePrometheusAlertRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePrometheusAlertRuleWithOptions(request, runtime);
}

model DeletePrometheusGlobalViewRequest {
  globalViewClusterId?: string(name='GlobalViewClusterId'),
  regionId?: string(name='RegionId'),
}

model DeletePrometheusGlobalViewResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeletePrometheusGlobalViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePrometheusGlobalViewResponseBody(name='body'),
}

async function deletePrometheusGlobalViewWithOptions(request: DeletePrometheusGlobalViewRequest, runtime: Util.RuntimeOptions): DeletePrometheusGlobalViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalViewClusterId)) {
    query['GlobalViewClusterId'] = request.globalViewClusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePrometheusGlobalView',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePrometheusGlobalView(request: DeletePrometheusGlobalViewRequest): DeletePrometheusGlobalViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePrometheusGlobalViewWithOptions(request, runtime);
}

model DeleteRetcodeAppRequest {
  appId?: string(name='AppId'),
  regionId?: string(name='RegionId'),
}

model DeleteRetcodeAppResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteRetcodeAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRetcodeAppResponseBody(name='body'),
}

async function deleteRetcodeAppWithOptions(request: DeleteRetcodeAppRequest, runtime: Util.RuntimeOptions): DeleteRetcodeAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRetcodeApp',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRetcodeApp(request: DeleteRetcodeAppRequest): DeleteRetcodeAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRetcodeAppWithOptions(request, runtime);
}

model DeleteScenarioRequest {
  regionId?: string(name='RegionId'),
  scenarioId?: long(name='ScenarioId'),
}

model DeleteScenarioResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteScenarioResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteScenarioResponseBody(name='body'),
}

async function deleteScenarioWithOptions(request: DeleteScenarioRequest, runtime: Util.RuntimeOptions): DeleteScenarioResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.scenarioId)) {
    query['ScenarioId'] = request.scenarioId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteScenario',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteScenario(request: DeleteScenarioRequest): DeleteScenarioResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteScenarioWithOptions(request, runtime);
}

model DeleteSilencePolicyRequest {
  id?: long(name='Id'),
}

model DeleteSilencePolicyResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteSilencePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSilencePolicyResponseBody(name='body'),
}

async function deleteSilencePolicyWithOptions(request: DeleteSilencePolicyRequest, runtime: Util.RuntimeOptions): DeleteSilencePolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSilencePolicy',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSilencePolicy(request: DeleteSilencePolicyRequest): DeleteSilencePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSilencePolicyWithOptions(request, runtime);
}

model DeleteSourceMapRequest {
  fidList?: [ string ](name='FidList'),
  pid?: string(name='Pid'),
  regionId?: string(name='RegionId'),
}

model DeleteSourceMapShrinkRequest {
  fidListShrink?: string(name='FidList'),
  pid?: string(name='Pid'),
  regionId?: string(name='RegionId'),
}

model DeleteSourceMapResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteSourceMapResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSourceMapResponseBody(name='body'),
}

async function deleteSourceMapWithOptions(tmpReq: DeleteSourceMapRequest, runtime: Util.RuntimeOptions): DeleteSourceMapResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteSourceMapShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.fidList)) {
    request.fidListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fidList, 'FidList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.fidListShrink)) {
    query['FidList'] = request.fidListShrink;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSourceMap',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSourceMap(request: DeleteSourceMapRequest): DeleteSourceMapResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSourceMapWithOptions(request, runtime);
}

model DeleteSyntheticTaskRequest {
  regionId?: string(name='RegionId'),
  taskIds?: [ string ](name='TaskIds'),
}

model DeleteSyntheticTaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DeleteSyntheticTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSyntheticTaskResponseBody(name='body'),
}

async function deleteSyntheticTaskWithOptions(request: DeleteSyntheticTaskRequest, runtime: Util.RuntimeOptions): DeleteSyntheticTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskIds)) {
    query['TaskIds'] = request.taskIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSyntheticTask',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSyntheticTask(request: DeleteSyntheticTaskRequest): DeleteSyntheticTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSyntheticTaskWithOptions(request, runtime);
}

model DeleteTraceAppRequest {
  appId?: string(name='AppId'),
  pid?: string(name='Pid'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
}

model DeleteTraceAppResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteTraceAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTraceAppResponseBody(name='body'),
}

async function deleteTraceAppWithOptions(request: DeleteTraceAppRequest, runtime: Util.RuntimeOptions): DeleteTraceAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTraceApp',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTraceApp(request: DeleteTraceAppRequest): DeleteTraceAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTraceAppWithOptions(request, runtime);
}

model DeleteWebhookContactRequest {
  webhookId?: long(name='WebhookId'),
}

model DeleteWebhookContactResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteWebhookContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteWebhookContactResponseBody(name='body'),
}

async function deleteWebhookContactWithOptions(request: DeleteWebhookContactRequest, runtime: Util.RuntimeOptions): DeleteWebhookContactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.webhookId)) {
    query['WebhookId'] = request.webhookId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWebhookContact',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWebhookContact(request: DeleteWebhookContactRequest): DeleteWebhookContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWebhookContactWithOptions(request, runtime);
}

model DescribeContactGroupsRequest {
  contactGroupName?: string(name='ContactGroupName'),
  isDetail?: boolean(name='IsDetail'),
  page?: long(name='Page'),
  size?: long(name='Size'),
}

model DescribeContactGroupsResponseBody = {
  pageBean?: {
    alertContactGroups?: [ 
      {
        contactGroupId?: float(name='ContactGroupId'),
        contactGroupName?: string(name='ContactGroupName'),
        contacts?: [ 
          {
            contactId?: float(name='ContactId'),
            contactName?: string(name='ContactName'),
            email?: string(name='Email'),
            phone?: string(name='Phone'),
          }
        ](name='Contacts'),
      }
    ](name='AlertContactGroups'),
    page?: long(name='Page'),
    size?: long(name='Size'),
    total?: long(name='Total'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model DescribeContactGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContactGroupsResponseBody(name='body'),
}

async function describeContactGroupsWithOptions(request: DescribeContactGroupsRequest, runtime: Util.RuntimeOptions): DescribeContactGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupName)) {
    query['ContactGroupName'] = request.contactGroupName;
  }
  if (!Util.isUnset(request.isDetail)) {
    query['IsDetail'] = request.isDetail;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContactGroups',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContactGroups(request: DescribeContactGroupsRequest): DescribeContactGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContactGroupsWithOptions(request, runtime);
}

model DescribeContactsRequest {
  contactName?: string(name='ContactName'),
  email?: string(name='Email'),
  page?: long(name='Page'),
  phone?: string(name='Phone'),
  size?: long(name='Size'),
}

model DescribeContactsResponseBody = {
  pageBean?: {
    alertContacts?: [ 
      {
        contactId?: float(name='ContactId'),
        contactName?: string(name='ContactName'),
        email?: string(name='Email'),
        isVerify?: boolean(name='IsVerify'),
        phone?: string(name='Phone'),
        reissueSendNotice?: long(name='ReissueSendNotice'),
      }
    ](name='AlertContacts'),
    page?: long(name='Page'),
    size?: long(name='Size'),
    total?: long(name='Total'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model DescribeContactsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContactsResponseBody(name='body'),
}

async function describeContactsWithOptions(request: DescribeContactsRequest, runtime: Util.RuntimeOptions): DescribeContactsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.phone)) {
    query['Phone'] = request.phone;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContacts',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContacts(request: DescribeContactsRequest): DescribeContactsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContactsWithOptions(request, runtime);
}

model DescribeDispatchRuleRequest {
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
}

model DescribeDispatchRuleResponseBody = {
  dispatchRule?: {
    dispatchType?: string(name='DispatchType'),
    groupRules?: [ 
      {
        groupId?: long(name='GroupId'),
        groupInterval?: long(name='GroupInterval'),
        groupWaitTime?: long(name='GroupWaitTime'),
        groupingFields?: [ string ](name='GroupingFields'),
        repeatInterval?: long(name='RepeatInterval'),
      }
    ](name='GroupRules'),
    isRecover?: boolean(name='IsRecover'),
    labelMatchExpressionGrid?: {
      labelMatchExpressionGroups?: [ 
        {
          labelMatchExpressions?: [ 
            {
              key?: string(name='Key'),
              operator?: string(name='Operator'),
              value?: string(name='Value'),
            }
          ](name='LabelMatchExpressions'),
        }
      ](name='LabelMatchExpressionGroups'),
    }(name='LabelMatchExpressionGrid'),
    name?: string(name='Name'),
    notifyRules?: [ 
      {
        notifyChannels?: [ string ](name='NotifyChannels'),
        notifyObjects?: [ 
          {
            name?: string(name='Name'),
            notifyObjectId?: string(name='NotifyObjectId'),
            notifyType?: string(name='NotifyType'),
          }
        ](name='NotifyObjects'),
      }
    ](name='NotifyRules'),
    ruleId?: long(name='RuleId'),
    state?: string(name='State'),
  }(name='DispatchRule'),
  requestId?: string(name='RequestId'),
}

model DescribeDispatchRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDispatchRuleResponseBody(name='body'),
}

async function describeDispatchRuleWithOptions(request: DescribeDispatchRuleRequest, runtime: Util.RuntimeOptions): DescribeDispatchRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDispatchRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDispatchRule(request: DescribeDispatchRuleRequest): DescribeDispatchRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDispatchRuleWithOptions(request, runtime);
}

model DescribeIMRobotsRequest {
  page?: long(name='Page'),
  robotName?: string(name='RobotName'),
  size?: long(name='Size'),
}

model DescribeIMRobotsResponseBody = {
  pageBean?: {
    alertIMRobots?: [ 
      {
        dailyNoc?: boolean(name='DailyNoc'),
        dailyNocTime?: string(name='DailyNocTime'),
        robotAddr?: string(name='RobotAddr'),
        robotId?: float(name='RobotId'),
        robotName?: string(name='RobotName'),
        type?: string(name='Type'),
      }
    ](name='AlertIMRobots'),
    page?: long(name='Page'),
    size?: long(name='Size'),
    total?: long(name='Total'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model DescribeIMRobotsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIMRobotsResponseBody(name='body'),
}

async function describeIMRobotsWithOptions(request: DescribeIMRobotsRequest, runtime: Util.RuntimeOptions): DescribeIMRobotsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.robotName)) {
    query['RobotName'] = request.robotName;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIMRobots',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIMRobots(request: DescribeIMRobotsRequest): DescribeIMRobotsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIMRobotsWithOptions(request, runtime);
}

model DescribePrometheusAlertRuleRequest {
  alertId?: long(name='AlertId'),
}

model DescribePrometheusAlertRuleResponseBody = {
  prometheusAlertRule?: {
    alertId?: long(name='AlertId'),
    alertName?: string(name='AlertName'),
    annotations?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Annotations'),
    clusterId?: string(name='ClusterId'),
    dispatchRuleId?: long(name='DispatchRuleId'),
    duration?: string(name='Duration'),
    expression?: string(name='Expression'),
    labels?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Labels'),
    message?: string(name='Message'),
    notifyType?: string(name='NotifyType'),
    status?: int32(name='Status'),
    type?: string(name='Type'),
  }(name='PrometheusAlertRule'),
  requestId?: string(name='RequestId'),
}

model DescribePrometheusAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePrometheusAlertRuleResponseBody(name='body'),
}

async function describePrometheusAlertRuleWithOptions(request: DescribePrometheusAlertRuleRequest, runtime: Util.RuntimeOptions): DescribePrometheusAlertRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePrometheusAlertRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePrometheusAlertRule(request: DescribePrometheusAlertRuleRequest): DescribePrometheusAlertRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePrometheusAlertRuleWithOptions(request, runtime);
}

model DescribeTraceLicenseKeyRequest {
  regionId?: string(name='RegionId'),
}

model DescribeTraceLicenseKeyResponseBody = {
  licenseKey?: string(name='LicenseKey'),
  requestId?: string(name='RequestId'),
}

model DescribeTraceLicenseKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTraceLicenseKeyResponseBody(name='body'),
}

async function describeTraceLicenseKeyWithOptions(request: DescribeTraceLicenseKeyRequest, runtime: Util.RuntimeOptions): DescribeTraceLicenseKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTraceLicenseKey',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTraceLicenseKey(request: DescribeTraceLicenseKeyRequest): DescribeTraceLicenseKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTraceLicenseKeyWithOptions(request, runtime);
}

model DescribeWebhookContactsRequest {
  page?: long(name='Page'),
  size?: long(name='Size'),
  webhookName?: string(name='WebhookName'),
}

model DescribeWebhookContactsResponseBody = {
  pageBean?: {
    page?: long(name='Page'),
    size?: long(name='Size'),
    total?: long(name='Total'),
    webhookContacts?: [ 
      {
        webhook?: {
          bizHeaders?: map[string]any(name='BizHeaders'),
          bizParams?: map[string]any(name='BizParams'),
          body?: string(name='Body'),
          method?: string(name='Method'),
          recoverBody?: string(name='RecoverBody'),
          url?: string(name='Url'),
        }(name='Webhook'),
        webhookId?: float(name='WebhookId'),
        webhookName?: string(name='WebhookName'),
      }
    ](name='WebhookContacts'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model DescribeWebhookContactsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebhookContactsResponseBody(name='body'),
}

async function describeWebhookContactsWithOptions(request: DescribeWebhookContactsRequest, runtime: Util.RuntimeOptions): DescribeWebhookContactsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebhookContacts',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebhookContacts(request: DescribeWebhookContactsRequest): DescribeWebhookContactsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebhookContactsWithOptions(request, runtime);
}

model GetAgentDownloadUrlRequest {
  regionId?: string(name='RegionId'),
}

model GetAgentDownloadUrlResponseBody = {
  armsAgentDownloadUrl?: string(name='ArmsAgentDownloadUrl'),
  requestId?: string(name='RequestId'),
}

model GetAgentDownloadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAgentDownloadUrlResponseBody(name='body'),
}

async function getAgentDownloadUrlWithOptions(request: GetAgentDownloadUrlRequest, runtime: Util.RuntimeOptions): GetAgentDownloadUrlResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAgentDownloadUrl',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAgentDownloadUrl(request: GetAgentDownloadUrlRequest): GetAgentDownloadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAgentDownloadUrlWithOptions(request, runtime);
}

model GetAlertRulesRequest {
  alertIds?: string(name='AlertIds'),
  alertNames?: string(name='AlertNames'),
  alertStatus?: string(name='AlertStatus'),
  alertType?: string(name='AlertType'),
  clusterId?: string(name='ClusterId'),
  page?: long(name='Page'),
  productCode?: string(name='ProductCode'),
  regionId?: string(name='RegionId'),
  size?: long(name='Size'),
}

model GetAlertRulesResponseBody = {
  pageBean?: {
    alertRules?: [ 
      {
        alertCheckType?: string(name='AlertCheckType'),
        alertGroup?: long(name='AlertGroup'),
        alertId?: float(name='AlertId'),
        alertName?: string(name='AlertName'),
        alertRuleContent?: {
          alertRuleItems?: [ 
            {
              aggregate?: string(name='Aggregate'),
              metricKey?: string(name='MetricKey'),
              n?: float(name='N'),
              operator?: string(name='Operator'),
              value?: string(name='Value'),
            }
          ](name='AlertRuleItems'),
          condition?: string(name='Condition'),
        }(name='AlertRuleContent'),
        alertStatus?: string(name='AlertStatus'),
        alertType?: string(name='AlertType'),
        annotations?: [ 
          {
            name?: string(name='Name'),
            value?: string(name='Value'),
          }
        ](name='Annotations'),
        autoAddNewApplication?: boolean(name='AutoAddNewApplication'),
        clusterId?: string(name='ClusterId'),
        createdTime?: long(name='CreatedTime'),
        duration?: string(name='Duration'),
        extend?: string(name='Extend'),
        filters?: {
          customSLSFilters?: [ 
            {
              key?: string(name='Key'),
              opt?: string(name='Opt'),
              show?: boolean(name='Show'),
              t?: string(name='T'),
              value?: string(name='Value'),
            }
          ](name='CustomSLSFilters'),
          customSLSGroupByDimensions?: [ string ](name='CustomSLSGroupByDimensions'),
          customSLSWheres?: [ string ](name='CustomSLSWheres'),
          dimFilters?: [ 
            {
              filterKey?: string(name='FilterKey'),
              filterOpt?: string(name='FilterOpt'),
              filterValues?: [ string ](name='FilterValues'),
            }
          ](name='DimFilters'),
        }(name='Filters'),
        labels?: [ 
          {
            name?: string(name='Name'),
            value?: string(name='Value'),
          }
        ](name='Labels'),
        level?: string(name='Level'),
        message?: string(name='Message'),
        metricsType?: string(name='MetricsType'),
        notifyStrategy?: string(name='NotifyStrategy'),
        pids?: [ string ](name='Pids'),
        promQL?: string(name='PromQL'),
        regionId?: string(name='RegionId'),
        updatedTime?: long(name='UpdatedTime'),
        userId?: string(name='UserId'),
      }
    ](name='AlertRules'),
    page?: long(name='Page'),
    size?: long(name='Size'),
    total?: long(name='Total'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model GetAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlertRulesResponseBody(name='body'),
}

async function getAlertRulesWithOptions(request: GetAlertRulesRequest, runtime: Util.RuntimeOptions): GetAlertRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertIds)) {
    query['AlertIds'] = request.alertIds;
  }
  if (!Util.isUnset(request.alertNames)) {
    query['AlertNames'] = request.alertNames;
  }
  if (!Util.isUnset(request.alertStatus)) {
    query['AlertStatus'] = request.alertStatus;
  }
  if (!Util.isUnset(request.alertType)) {
    query['AlertType'] = request.alertType;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAlertRules',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAlertRules(request: GetAlertRulesRequest): GetAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAlertRulesWithOptions(request, runtime);
}

model GetAppApiByPageRequest {
  currentPage?: int32(name='CurrentPage'),
  endTime?: long(name='EndTime'),
  intervalMills?: int32(name='IntervalMills'),
  PId?: string(name='PId'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  startTime?: long(name='StartTime'),
}

model GetAppApiByPageResponseBody = {
  code?: int32(name='Code'),
  data?: {
    items?: [  map[string]any ](name='Items'),
    page?: int32(name='Page'),
    pageSize?: int32(name='PageSize'),
    total?: string(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAppApiByPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAppApiByPageResponseBody(name='body'),
}

async function getAppApiByPageWithOptions(request: GetAppApiByPageRequest, runtime: Util.RuntimeOptions): GetAppApiByPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.intervalMills)) {
    query['IntervalMills'] = request.intervalMills;
  }
  if (!Util.isUnset(request.PId)) {
    query['PId'] = request.PId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAppApiByPage',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAppApiByPage(request: GetAppApiByPageRequest): GetAppApiByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppApiByPageWithOptions(request, runtime);
}

model GetAuthTokenRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
}

model GetAuthTokenResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetAuthTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAuthTokenResponseBody(name='body'),
}

async function getAuthTokenWithOptions(request: GetAuthTokenRequest, runtime: Util.RuntimeOptions): GetAuthTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAuthToken',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAuthToken(request: GetAuthTokenRequest): GetAuthTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuthTokenWithOptions(request, runtime);
}

model GetClusterAllUrlRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
}

model GetClusterAllUrlResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetClusterAllUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClusterAllUrlResponseBody(name='body'),
}

async function getClusterAllUrlWithOptions(request: GetClusterAllUrlRequest, runtime: Util.RuntimeOptions): GetClusterAllUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClusterAllUrl',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getClusterAllUrl(request: GetClusterAllUrlRequest): GetClusterAllUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClusterAllUrlWithOptions(request, runtime);
}

model GetExploreUrlRequest {
  clusterId?: string(name='ClusterId'),
  expression?: string(name='Expression'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
}

model GetExploreUrlResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetExploreUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExploreUrlResponseBody(name='body'),
}

async function getExploreUrlWithOptions(request: GetExploreUrlRequest, runtime: Util.RuntimeOptions): GetExploreUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.expression)) {
    query['Expression'] = request.expression;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExploreUrl',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getExploreUrl(request: GetExploreUrlRequest): GetExploreUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getExploreUrlWithOptions(request, runtime);
}

model GetIntegrationStateRequest {
  clusterId?: string(name='ClusterId'),
  integration?: string(name='Integration'),
  regionId?: string(name='RegionId'),
}

model GetIntegrationStateResponseBody = {
  requestId?: string(name='RequestId'),
  state?: boolean(name='State'),
}

model GetIntegrationStateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIntegrationStateResponseBody(name='body'),
}

async function getIntegrationStateWithOptions(request: GetIntegrationStateRequest, runtime: Util.RuntimeOptions): GetIntegrationStateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.integration)) {
    query['Integration'] = request.integration;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetIntegrationState',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getIntegrationState(request: GetIntegrationStateRequest): GetIntegrationStateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIntegrationStateWithOptions(request, runtime);
}

model GetManagedPrometheusStatusRequest {
  clusterId?: string(name='ClusterId'),
  clusterType?: string(name='ClusterType'),
  regionId?: string(name='RegionId'),
}

model GetManagedPrometheusStatusResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetManagedPrometheusStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetManagedPrometheusStatusResponseBody(name='body'),
}

async function getManagedPrometheusStatusWithOptions(request: GetManagedPrometheusStatusRequest, runtime: Util.RuntimeOptions): GetManagedPrometheusStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetManagedPrometheusStatus',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getManagedPrometheusStatus(request: GetManagedPrometheusStatusRequest): GetManagedPrometheusStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getManagedPrometheusStatusWithOptions(request, runtime);
}

model GetMultipleTraceRequest {
  regionId?: string(name='RegionId'),
  traceIDs?: [ string ](name='TraceIDs'),
}

model GetMultipleTraceResponseBody = {
  multiCallChainInfos?: [ 
    {
      spans?: [ 
        {
          duration?: long(name='Duration'),
          haveStack?: boolean(name='HaveStack'),
          logEventList?: [ 
            {
              tagEntryList?: [ 
                {
                  key?: string(name='Key'),
                  value?: string(name='Value'),
                }
              ](name='TagEntryList'),
              timestamp?: long(name='Timestamp'),
            }
          ](name='LogEventList'),
          operationName?: string(name='OperationName'),
          parentSpanId?: string(name='ParentSpanId'),
          resultCode?: string(name='ResultCode'),
          rpcId?: string(name='RpcId'),
          rpcType?: int32(name='RpcType'),
          serviceIp?: string(name='ServiceIp'),
          serviceName?: string(name='ServiceName'),
          spanId?: string(name='SpanId'),
          tagEntryList?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
            }
          ](name='TagEntryList'),
          timestamp?: long(name='Timestamp'),
          traceID?: string(name='TraceID'),
        }
      ](name='Spans'),
      traceID?: string(name='TraceID'),
    }
  ](name='MultiCallChainInfos'),
  requestId?: string(name='RequestId'),
}

model GetMultipleTraceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMultipleTraceResponseBody(name='body'),
}

async function getMultipleTraceWithOptions(request: GetMultipleTraceRequest, runtime: Util.RuntimeOptions): GetMultipleTraceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.traceIDs)) {
    query['TraceIDs'] = request.traceIDs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMultipleTrace',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMultipleTrace(request: GetMultipleTraceRequest): GetMultipleTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMultipleTraceWithOptions(request, runtime);
}

model GetOnCallSchedulesDetailRequest {
  endTime?: string(name='EndTime'),
  id?: long(name='Id'),
  startTime?: string(name='StartTime'),
}

model GetOnCallSchedulesDetailResponseBody = {
  data?: {
    alertRobotId?: long(name='AlertRobotId'),
    description?: string(name='Description'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    renderedFinnalEntries?: [ 
      {
        end?: string(name='End'),
        simpleContact?: {
          id?: long(name='Id'),
          name?: string(name='Name'),
        }(name='SimpleContact'),
        start?: string(name='Start'),
      }
    ](name='RenderedFinnalEntries'),
    renderedLayerEntries?: [[ 
      {
        start?: string(name='Start'),
        end?: string(name='End'),
        simpleContact?: {
          id?: long(name='Id'),
          name?: string(name='Name'),
        }(name='SimpleContact'),
      }
    ]    ](name='RenderedLayerEntries'),
    renderedSubstitudeEntries?: [ 
      {
        end?: string(name='End'),
        simpleContact?: {
          id?: long(name='Id'),
          name?: string(name='Name'),
        }(name='SimpleContact'),
        start?: string(name='Start'),
      }
    ](name='RenderedSubstitudeEntries'),
    scheduleLayers?: [ 
      {
        contactIds?: [ long ](name='ContactIds'),
        restrictions?: [ 
          {
            endTimeOfDay?: string(name='EndTimeOfDay'),
            restrictionType?: string(name='RestrictionType'),
            startTimeOfDay?: string(name='StartTimeOfDay'),
          }
        ](name='Restrictions'),
        rotationType?: string(name='RotationType'),
        shiftLength?: long(name='ShiftLength'),
        startTime?: string(name='StartTime'),
      }
    ](name='ScheduleLayers'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetOnCallSchedulesDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOnCallSchedulesDetailResponseBody(name='body'),
}

async function getOnCallSchedulesDetailWithOptions(request: GetOnCallSchedulesDetailRequest, runtime: Util.RuntimeOptions): GetOnCallSchedulesDetailResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOnCallSchedulesDetail',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOnCallSchedulesDetail(request: GetOnCallSchedulesDetailRequest): GetOnCallSchedulesDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOnCallSchedulesDetailWithOptions(request, runtime);
}

model GetPrometheusApiTokenRequest {
  regionId?: string(name='RegionId'),
}

model GetPrometheusApiTokenResponseBody = {
  requestId?: string(name='RequestId'),
  token?: string(name='Token'),
}

model GetPrometheusApiTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPrometheusApiTokenResponseBody(name='body'),
}

async function getPrometheusApiTokenWithOptions(request: GetPrometheusApiTokenRequest, runtime: Util.RuntimeOptions): GetPrometheusApiTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPrometheusApiToken',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPrometheusApiToken(request: GetPrometheusApiTokenRequest): GetPrometheusApiTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPrometheusApiTokenWithOptions(request, runtime);
}

model GetPrometheusGlobalViewRequest {
  globalViewClusterId?: string(name='GlobalViewClusterId'),
  regionId?: string(name='RegionId'),
}

model GetPrometheusGlobalViewResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetPrometheusGlobalViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPrometheusGlobalViewResponseBody(name='body'),
}

async function getPrometheusGlobalViewWithOptions(request: GetPrometheusGlobalViewRequest, runtime: Util.RuntimeOptions): GetPrometheusGlobalViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalViewClusterId)) {
    query['GlobalViewClusterId'] = request.globalViewClusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPrometheusGlobalView',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPrometheusGlobalView(request: GetPrometheusGlobalViewRequest): GetPrometheusGlobalViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPrometheusGlobalViewWithOptions(request, runtime);
}

model GetRecordingRuleRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
}

model GetRecordingRuleResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetRecordingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRecordingRuleResponseBody(name='body'),
}

async function getRecordingRuleWithOptions(request: GetRecordingRuleRequest, runtime: Util.RuntimeOptions): GetRecordingRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRecordingRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRecordingRule(request: GetRecordingRuleRequest): GetRecordingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRecordingRuleWithOptions(request, runtime);
}

model GetRetcodeShareUrlRequest {
  pid?: string(name='Pid'),
}

model GetRetcodeShareUrlResponseBody = {
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model GetRetcodeShareUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRetcodeShareUrlResponseBody(name='body'),
}

async function getRetcodeShareUrlWithOptions(request: GetRetcodeShareUrlRequest, runtime: Util.RuntimeOptions): GetRetcodeShareUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRetcodeShareUrl',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRetcodeShareUrl(request: GetRetcodeShareUrlRequest): GetRetcodeShareUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRetcodeShareUrlWithOptions(request, runtime);
}

model GetSourceMapInfoRequest {
  ascendingSequence?: boolean(name='AscendingSequence'),
  edition?: string(name='Edition'),
  ID?: string(name='ID'),
  keyword?: string(name='Keyword'),
  orderField?: string(name='OrderField'),
  regionId?: string(name='RegionId'),
}

model GetSourceMapInfoResponseBody = {
  requestId?: string(name='RequestId'),
  sourceMapList?: [ 
    {
      fid?: string(name='Fid'),
      fileName?: string(name='FileName'),
      size?: string(name='Size'),
      uploadTime?: string(name='UploadTime'),
      version?: string(name='Version'),
    }
  ](name='SourceMapList'),
}

model GetSourceMapInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSourceMapInfoResponseBody(name='body'),
}

async function getSourceMapInfoWithOptions(request: GetSourceMapInfoRequest, runtime: Util.RuntimeOptions): GetSourceMapInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ascendingSequence)) {
    query['AscendingSequence'] = request.ascendingSequence;
  }
  if (!Util.isUnset(request.edition)) {
    query['Edition'] = request.edition;
  }
  if (!Util.isUnset(request.ID)) {
    query['ID'] = request.ID;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.orderField)) {
    query['OrderField'] = request.orderField;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSourceMapInfo',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSourceMapInfo(request: GetSourceMapInfoRequest): GetSourceMapInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSourceMapInfoWithOptions(request, runtime);
}

model GetStackRequest {
  endTime?: long(name='EndTime'),
  pid?: string(name='Pid'),
  regionId?: string(name='RegionId'),
  rpcID?: string(name='RpcID'),
  startTime?: long(name='StartTime'),
  traceID?: string(name='TraceID'),
}

model GetStackResponseBody = {
  requestId?: string(name='RequestId'),
  stackInfo?: [ 
    {
      api?: string(name='Api'),
      duration?: long(name='Duration'),
      exception?: string(name='Exception'),
      extInfo?: {
        info?: string(name='Info'),
        type?: string(name='Type'),
      }(name='ExtInfo'),
      line?: string(name='Line'),
      rpcId?: string(name='RpcId'),
      serviceName?: string(name='ServiceName'),
      startTime?: long(name='StartTime'),
    }
  ](name='StackInfo'),
}

model GetStackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetStackResponseBody(name='body'),
}

async function getStackWithOptions(request: GetStackRequest, runtime: Util.RuntimeOptions): GetStackResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.rpcID)) {
    query['RpcID'] = request.rpcID;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.traceID)) {
    query['TraceID'] = request.traceID;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetStack',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getStack(request: GetStackRequest): GetStackResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStackWithOptions(request, runtime);
}

model GetSyntheticTaskDetailRequest {
  regionId?: string(name='RegionId'),
  taskId?: string(name='TaskId'),
}

model GetSyntheticTaskDetailResponseBody = {
  requestId?: string(name='RequestId'),
  taskDetail?: {
    download?: {
      connectionTimeout?: long(name='ConnectionTimeout'),
      downloadCustomHeaderContent?: string(name='DownloadCustomHeaderContent'),
      downloadCustomHost?: long(name='DownloadCustomHost'),
      downloadCustomHostIp?: string(name='DownloadCustomHostIp'),
      downloadKernel?: long(name='DownloadKernel'),
      downloadRedirect?: long(name='DownloadRedirect'),
      downloadTransmissionSize?: long(name='DownloadTransmissionSize'),
      monitorTimeout?: long(name='MonitorTimeout'),
      quickProtocol?: string(name='QuickProtocol'),
      validateKeywords?: string(name='ValidateKeywords'),
      verifyWay?: long(name='VerifyWay'),
      whiteList?: string(name='WhiteList'),
    }(name='Download'),
    extendInterval?: {
      days?: [ long ](name='Days'),
      endMinute?: long(name='EndMinute'),
      endTime?: string(name='EndTime'),
      endhour?: long(name='Endhour'),
      startHour?: long(name='StartHour'),
      startMinute?: long(name='StartMinute'),
      startTime?: string(name='StartTime'),
    }(name='ExtendInterval'),
    intervalTime?: long(name='IntervalTime'),
    intervalType?: long(name='IntervalType'),
    ipType?: long(name='IpType'),
    minotorList?: [ 
      {
        cityCode?: long(name='CityCode'),
        monitorType?: long(name='MonitorType'),
        netServiceId?: long(name='NetServiceId'),
        sendCount?: long(name='SendCount'),
      }
    ](name='MinotorList'),
    nav?: {
      dnsHijackWhitelist?: string(name='DnsHijackWhitelist'),
      elementBlacklist?: string(name='ElementBlacklist'),
      executeActiveX?: long(name='ExecuteActiveX'),
      executeApplet?: long(name='ExecuteApplet'),
      executeScript?: long(name='ExecuteScript'),
      filterInvalidIP?: long(name='FilterInvalidIP'),
      flowHijackJumpTimes?: long(name='FlowHijackJumpTimes'),
      flowHijackLogo?: string(name='FlowHijackLogo'),
      monitorTimeout?: long(name='MonitorTimeout'),
      navAutomaticScrolling?: long(name='NavAutomaticScrolling'),
      navCustomHeader?: string(name='NavCustomHeader'),
      navCustomHeaderContent?: string(name='NavCustomHeaderContent'),
      navCustomHost?: long(name='NavCustomHost'),
      navCustomHostIp?: string(name='NavCustomHostIp'),
      navDisableCache?: long(name='NavDisableCache'),
      navDisableCompression?: long(name='NavDisableCompression'),
      navIgnoreCertificateError?: long(name='NavIgnoreCertificateError'),
      navRedirect?: long(name='NavRedirect'),
      navReturnElement?: long(name='NavReturnElement'),
      pageTampering?: string(name='PageTampering'),
      processName?: string(name='ProcessName'),
      quicDomain?: string(name='QuicDomain'),
      quicVersion?: long(name='QuicVersion'),
      requestHeader?: long(name='RequestHeader'),
      slowElementThreshold?: long(name='SlowElementThreshold'),
      verifyStringBlacklist?: string(name='VerifyStringBlacklist'),
      verifyStringWhitelist?: string(name='VerifyStringWhitelist'),
      waitCompletionTime?: long(name='WaitCompletionTime'),
    }(name='Nav'),
    net?: {
      netDigSwitch?: long(name='NetDigSwitch'),
      netDnsNs?: string(name='NetDnsNs'),
      netDnsQueryMethod?: string(name='NetDnsQueryMethod'),
      netDnsServer?: long(name='NetDnsServer'),
      netDnsSwitch?: long(name='NetDnsSwitch'),
      netIcmpActive?: long(name='NetIcmpActive'),
      netIcmpDataCut?: long(name='NetIcmpDataCut'),
      netIcmpInterval?: long(name='NetIcmpInterval'),
      netIcmpNum?: long(name='NetIcmpNum'),
      netIcmpSize?: long(name='NetIcmpSize'),
      netIcmpSwitch?: long(name='NetIcmpSwitch'),
      netIcmpTimeout?: long(name='NetIcmpTimeout'),
      netTraceRouteNum?: long(name='NetTraceRouteNum'),
      netTraceRouteSwitch?: long(name='NetTraceRouteSwitch'),
      netTraceRouteTimeout?: long(name='NetTraceRouteTimeout'),
      whiteList?: string(name='WhiteList'),
    }(name='Net'),
    protocol?: {
      characterEncoding?: long(name='CharacterEncoding'),
      customHost?: long(name='CustomHost'),
      customHostIp?: string(name='CustomHostIp'),
      protocolConnectionTimeout?: long(name='ProtocolConnectionTimeout'),
      protocolMonitorTimeout?: long(name='ProtocolMonitorTimeout'),
      receivedDataSize?: long(name='ReceivedDataSize'),
      requestContent?: {
        body?: {
          formdata?: {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }(name='Formdata'),
          language?: string(name='Language'),
          mode?: string(name='Mode'),
          raw?: string(name='Raw'),
          urlencoded?: {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }(name='Urlencoded'),
        }(name='Body'),
        header?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Header'),
        method?: string(name='Method'),
      }(name='RequestContent'),
      verifyContent?: string(name='VerifyContent'),
      verifyWay?: long(name='VerifyWay'),
    }(name='Protocol'),
    taskId?: long(name='TaskId'),
    taskName?: string(name='TaskName'),
    taskType?: long(name='TaskType'),
    url?: string(name='Url'),
  }(name='TaskDetail'),
}

model GetSyntheticTaskDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSyntheticTaskDetailResponseBody(name='body'),
}

async function getSyntheticTaskDetailWithOptions(request: GetSyntheticTaskDetailRequest, runtime: Util.RuntimeOptions): GetSyntheticTaskDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSyntheticTaskDetail',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSyntheticTaskDetail(request: GetSyntheticTaskDetailRequest): GetSyntheticTaskDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSyntheticTaskDetailWithOptions(request, runtime);
}

model GetSyntheticTaskListRequest {
  direction?: string(name='Direction'),
  order?: string(name='Order'),
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
  regionId?: string(name='RegionId'),
  taskName?: string(name='TaskName'),
  taskStatus?: string(name='TaskStatus'),
  taskType?: string(name='TaskType'),
  url?: string(name='Url'),
}

model GetSyntheticTaskListResponseBody = {
  pageInfo?: {
    hasNextPage?: string(name='HasNextPage'),
    hasPreviousPage?: boolean(name='HasPreviousPage'),
    isFirstPage?: boolean(name='IsFirstPage'),
    isLastPage?: boolean(name='IsLastPage'),
    list?: [ 
      {
        createTime?: string(name='CreateTime'),
        monitorNumber?: long(name='MonitorNumber'),
        taskId?: string(name='TaskId'),
        taskName?: string(name='TaskName'),
        taskStatus?: string(name='TaskStatus'),
        taskType?: long(name='TaskType'),
        taskTypeName?: string(name='TaskTypeName'),
        url?: string(name='Url'),
        usable?: float(name='Usable'),
      }
    ](name='List'),
    navigateFirstPage?: string(name='NavigateFirstPage'),
    navigateLastPage?: string(name='NavigateLastPage'),
    navigatePageNums?: string(name='NavigatePageNums'),
    nextPage?: string(name='NextPage'),
    pages?: string(name='Pages'),
    prepage?: string(name='Prepage'),
    size?: long(name='Size'),
    total?: long(name='Total'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model GetSyntheticTaskListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSyntheticTaskListResponseBody(name='body'),
}

async function getSyntheticTaskListWithOptions(request: GetSyntheticTaskListRequest, runtime: Util.RuntimeOptions): GetSyntheticTaskListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskStatus)) {
    query['TaskStatus'] = request.taskStatus;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  if (!Util.isUnset(request.url)) {
    query['Url'] = request.url;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSyntheticTaskList',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSyntheticTaskList(request: GetSyntheticTaskListRequest): GetSyntheticTaskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSyntheticTaskListWithOptions(request, runtime);
}

model GetSyntheticTaskMonitorsRequest {
  regionId?: string(name='RegionId'),
}

model GetSyntheticTaskMonitorsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      busy?: long(name='Busy'),
      city?: string(name='City'),
      cityCode?: long(name='CityCode'),
      clientType?: long(name='ClientType'),
      district?: string(name='District'),
      netServiceId?: long(name='NetServiceId'),
      netServiceName?: string(name='NetServiceName'),
    }
  ](name='Data'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
}

model GetSyntheticTaskMonitorsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSyntheticTaskMonitorsResponseBody(name='body'),
}

async function getSyntheticTaskMonitorsWithOptions(request: GetSyntheticTaskMonitorsRequest, runtime: Util.RuntimeOptions): GetSyntheticTaskMonitorsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSyntheticTaskMonitors',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSyntheticTaskMonitors(request: GetSyntheticTaskMonitorsRequest): GetSyntheticTaskMonitorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSyntheticTaskMonitorsWithOptions(request, runtime);
}

model GetTraceRequest {
  endTime?: long(name='EndTime'),
  regionId?: string(name='RegionId'),
  startTime?: long(name='StartTime'),
  traceID?: string(name='TraceID'),
}

model GetTraceResponseBody = {
  requestId?: string(name='RequestId'),
  spans?: [ 
    {
      children?: [  map[string]any ](name='Children'),
      duration?: long(name='Duration'),
      haveStack?: boolean(name='HaveStack'),
      logEventList?: [ 
        {
          tagEntryList?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
            }
          ](name='TagEntryList'),
          timestamp?: long(name='Timestamp'),
        }
      ](name='LogEventList'),
      operationName?: string(name='OperationName'),
      parentSpanId?: string(name='ParentSpanId'),
      resultCode?: string(name='ResultCode'),
      rpcId?: string(name='RpcId'),
      rpcType?: int32(name='RpcType'),
      serviceIp?: string(name='ServiceIp'),
      serviceName?: string(name='ServiceName'),
      spanId?: string(name='SpanId'),
      tagEntryList?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='TagEntryList'),
      timestamp?: long(name='Timestamp'),
      traceID?: string(name='TraceID'),
    }
  ](name='Spans'),
}

model GetTraceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTraceResponseBody(name='body'),
}

async function getTraceWithOptions(request: GetTraceRequest, runtime: Util.RuntimeOptions): GetTraceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.traceID)) {
    query['TraceID'] = request.traceID;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTrace',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTrace(request: GetTraceRequest): GetTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTraceWithOptions(request, runtime);
}

model GetTraceAppRequest {
  pid?: string(name='Pid'),
  regionId?: string(name='RegionId'),
}

model GetTraceAppResponseBody = {
  requestId?: string(name='RequestId'),
  traceApp?: {
    appId?: long(name='AppId'),
    appName?: string(name='AppName'),
    createTime?: long(name='CreateTime'),
    labels?: [ string ](name='Labels'),
    pid?: string(name='Pid'),
    regionId?: string(name='RegionId'),
    show?: boolean(name='Show'),
    type?: string(name='Type'),
    updateTime?: long(name='UpdateTime'),
    userId?: string(name='UserId'),
  }(name='TraceApp'),
}

model GetTraceAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTraceAppResponseBody(name='body'),
}

async function getTraceAppWithOptions(request: GetTraceAppRequest, runtime: Util.RuntimeOptions): GetTraceAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTraceApp',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTraceApp(request: GetTraceAppRequest): GetTraceAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTraceAppWithOptions(request, runtime);
}

model ImportAppAlertRulesRequest {
  contactGroupIds?: string(name='ContactGroupIds'),
  isAutoStart?: boolean(name='IsAutoStart'),
  pids?: string(name='Pids'),
  regionId?: string(name='RegionId'),
  templageAlertConfig?: string(name='TemplageAlertConfig'),
  templateAlertId?: string(name='TemplateAlertId'),
}

model ImportAppAlertRulesResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ImportAppAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ImportAppAlertRulesResponseBody(name='body'),
}

async function importAppAlertRulesWithOptions(request: ImportAppAlertRulesRequest, runtime: Util.RuntimeOptions): ImportAppAlertRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupIds)) {
    query['ContactGroupIds'] = request.contactGroupIds;
  }
  if (!Util.isUnset(request.isAutoStart)) {
    query['IsAutoStart'] = request.isAutoStart;
  }
  if (!Util.isUnset(request.pids)) {
    query['Pids'] = request.pids;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.templageAlertConfig)) {
    query['TemplageAlertConfig'] = request.templageAlertConfig;
  }
  if (!Util.isUnset(request.templateAlertId)) {
    query['TemplateAlertId'] = request.templateAlertId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportAppAlertRules',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importAppAlertRules(request: ImportAppAlertRulesRequest): ImportAppAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return importAppAlertRulesWithOptions(request, runtime);
}

model InstallCmsExporterRequest {
  clusterId?: string(name='ClusterId'),
  cmsArgs?: string(name='CmsArgs'),
  directArgs?: string(name='DirectArgs'),
  enableTag?: boolean(name='EnableTag'),
  regionId?: string(name='RegionId'),
}

model InstallCmsExporterResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model InstallCmsExporterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallCmsExporterResponseBody(name='body'),
}

async function installCmsExporterWithOptions(request: InstallCmsExporterRequest, runtime: Util.RuntimeOptions): InstallCmsExporterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.cmsArgs)) {
    query['CmsArgs'] = request.cmsArgs;
  }
  if (!Util.isUnset(request.directArgs)) {
    query['DirectArgs'] = request.directArgs;
  }
  if (!Util.isUnset(request.enableTag)) {
    query['EnableTag'] = request.enableTag;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallCmsExporter',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installCmsExporter(request: InstallCmsExporterRequest): InstallCmsExporterResponse {
  var runtime = new Util.RuntimeOptions{};
  return installCmsExporterWithOptions(request, runtime);
}

model InstallManagedPrometheusRequest {
  clusterId?: string(name='ClusterId'),
  clusterType?: string(name='ClusterType'),
  kubeConfig?: string(name='KubeConfig'),
  regionId?: string(name='RegionId'),
  securityGroupId?: string(name='SecurityGroupId'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model InstallManagedPrometheusResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InstallManagedPrometheusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallManagedPrometheusResponseBody(name='body'),
}

async function installManagedPrometheusWithOptions(request: InstallManagedPrometheusRequest, runtime: Util.RuntimeOptions): InstallManagedPrometheusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.kubeConfig)) {
    query['KubeConfig'] = request.kubeConfig;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallManagedPrometheus',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installManagedPrometheus(request: InstallManagedPrometheusRequest): InstallManagedPrometheusResponse {
  var runtime = new Util.RuntimeOptions{};
  return installManagedPrometheusWithOptions(request, runtime);
}

model ListActivatedAlertsRequest {
  currentPage?: int32(name='CurrentPage'),
  filter?: string(name='Filter'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model ListActivatedAlertsResponseBody = {
  page?: {
    alerts?: [ 
      {
        alertId?: string(name='AlertId'),
        alertName?: string(name='AlertName'),
        alertType?: string(name='AlertType'),
        count?: int32(name='Count'),
        createTime?: long(name='CreateTime'),
        dispatchRules?: [ 
          {
            ruleId?: int32(name='RuleId'),
            ruleName?: string(name='RuleName'),
          }
        ](name='DispatchRules'),
        endsAt?: long(name='EndsAt'),
        expandFields?: map[string]any(name='ExpandFields'),
        integrationName?: string(name='IntegrationName'),
        integrationType?: string(name='IntegrationType'),
        involvedObjectKind?: string(name='InvolvedObjectKind'),
        involvedObjectName?: string(name='InvolvedObjectName'),
        message?: string(name='Message'),
        severity?: string(name='Severity'),
        startsAt?: long(name='StartsAt'),
        status?: string(name='Status'),
      }
    ](name='Alerts'),
    page?: int32(name='Page'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Page'),
  requestId?: string(name='RequestId'),
}

model ListActivatedAlertsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListActivatedAlertsResponseBody(name='body'),
}

async function listActivatedAlertsWithOptions(request: ListActivatedAlertsRequest, runtime: Util.RuntimeOptions): ListActivatedAlertsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListActivatedAlerts',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listActivatedAlerts(request: ListActivatedAlertsRequest): ListActivatedAlertsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listActivatedAlertsWithOptions(request, runtime);
}

model ListAlertEventsRequest {
  alertName?: string(name='AlertName'),
  endTime?: string(name='EndTime'),
  matchingConditions?: string(name='MatchingConditions'),
  page?: long(name='Page'),
  size?: long(name='Size'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
}

model ListAlertEventsResponseBody = {
  pageBean?: {
    events?: [ 
      {
        alarms?: [ 
          {
            alarmId?: long(name='AlarmId'),
            alarmName?: string(name='AlarmName'),
            createTime?: string(name='CreateTime'),
            state?: int32(name='State'),
          }
        ](name='Alarms'),
        alertName?: string(name='AlertName'),
        annotations?: string(name='Annotations'),
        description?: string(name='Description'),
        endTime?: string(name='EndTime'),
        generatorURL?: string(name='GeneratorURL'),
        integrationName?: string(name='IntegrationName'),
        integrationType?: string(name='IntegrationType'),
        labels?: string(name='Labels'),
        receiveTime?: string(name='ReceiveTime'),
        severity?: string(name='Severity'),
        startTime?: string(name='StartTime'),
        status?: string(name='Status'),
      }
    ](name='Events'),
    page?: long(name='Page'),
    size?: long(name='Size'),
    total?: long(name='Total'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model ListAlertEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlertEventsResponseBody(name='body'),
}

async function listAlertEventsWithOptions(request: ListAlertEventsRequest, runtime: Util.RuntimeOptions): ListAlertEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertName)) {
    query['AlertName'] = request.alertName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.matchingConditions)) {
    query['MatchingConditions'] = request.matchingConditions;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlertEvents',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlertEvents(request: ListAlertEventsRequest): ListAlertEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlertEventsWithOptions(request, runtime);
}

model ListAlertsRequest {
  alertName?: string(name='AlertName'),
  dispatchRuleId?: long(name='DispatchRuleId'),
  endTime?: string(name='EndTime'),
  integrationType?: string(name='IntegrationType'),
  page?: long(name='Page'),
  severity?: string(name='Severity'),
  showActivities?: boolean(name='ShowActivities'),
  showEvents?: boolean(name='ShowEvents'),
  size?: long(name='Size'),
  startTime?: string(name='StartTime'),
  state?: long(name='State'),
}

model ListAlertsResponseBody = {
  pageBean?: {
    listAlerts?: [ 
      {
        activities?: [ 
          {
            content?: string(name='Content'),
            description?: string(name='Description'),
            handlerName?: string(name='HandlerName'),
            time?: string(name='Time'),
            type?: long(name='Type'),
          }
        ](name='Activities'),
        alertEvents?: [ 
          {
            alertName?: string(name='AlertName'),
            annotations?: string(name='Annotations'),
            description?: string(name='Description'),
            endTime?: string(name='EndTime'),
            generatorURL?: string(name='GeneratorURL'),
            integrationName?: string(name='IntegrationName'),
            integrationType?: string(name='IntegrationType'),
            labels?: string(name='Labels'),
            receiveTime?: string(name='ReceiveTime'),
            severity?: string(name='Severity'),
            startTime?: string(name='StartTime'),
            state?: string(name='State'),
          }
        ](name='AlertEvents'),
        alertId?: long(name='AlertId'),
        alertName?: string(name='AlertName'),
        createTime?: string(name='CreateTime'),
        dispatchRuleId?: float(name='DispatchRuleId'),
        dispatchRuleName?: string(name='DispatchRuleName'),
        severity?: string(name='Severity'),
        state?: long(name='State'),
      }
    ](name='ListAlerts'),
    page?: long(name='Page'),
    size?: long(name='Size'),
    total?: long(name='Total'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model ListAlertsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlertsResponseBody(name='body'),
}

async function listAlertsWithOptions(request: ListAlertsRequest, runtime: Util.RuntimeOptions): ListAlertsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertName)) {
    query['AlertName'] = request.alertName;
  }
  if (!Util.isUnset(request.dispatchRuleId)) {
    query['DispatchRuleId'] = request.dispatchRuleId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.integrationType)) {
    query['IntegrationType'] = request.integrationType;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.severity)) {
    query['Severity'] = request.severity;
  }
  if (!Util.isUnset(request.showActivities)) {
    query['ShowActivities'] = request.showActivities;
  }
  if (!Util.isUnset(request.showEvents)) {
    query['ShowEvents'] = request.showEvents;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlerts',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlerts(request: ListAlertsRequest): ListAlertsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlertsWithOptions(request, runtime);
}

model ListClusterFromGrafanaRequest {
  regionId?: string(name='RegionId'),
}

model ListClusterFromGrafanaResponseBody = {
  promClusterList?: [ 
    {
      agentStatus?: string(name='AgentStatus'),
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      controllerId?: string(name='ControllerId'),
      createTime?: long(name='CreateTime'),
      extra?: string(name='Extra'),
      id?: long(name='Id'),
      installTime?: long(name='InstallTime'),
      isControllerInstalled?: boolean(name='IsControllerInstalled'),
      lastHeartBeatTime?: long(name='LastHeartBeatTime'),
      nodeNum?: int32(name='NodeNum'),
      options?: string(name='Options'),
      pluginsJsonArray?: string(name='PluginsJsonArray'),
      regionId?: string(name='RegionId'),
      stateJson?: string(name='StateJson'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='PromClusterList'),
  requestId?: string(name='RequestId'),
}

model ListClusterFromGrafanaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClusterFromGrafanaResponseBody(name='body'),
}

async function listClusterFromGrafanaWithOptions(request: ListClusterFromGrafanaRequest, runtime: Util.RuntimeOptions): ListClusterFromGrafanaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterFromGrafana',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterFromGrafana(request: ListClusterFromGrafanaRequest): ListClusterFromGrafanaResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterFromGrafanaWithOptions(request, runtime);
}

model ListCmsInstancesRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
  typeFilter?: string(name='TypeFilter'),
}

model ListCmsInstancesResponseBody = {
  data?: {
    enableTag?: boolean(name='EnableTag'),
    products?: [ 
      {
        descr?: string(name='Descr'),
        id?: string(name='Id'),
        instance?: string(name='Instance'),
        name?: string(name='Name'),
        prod?: string(name='Prod'),
        source?: string(name='Source'),
        state?: string(name='State'),
        time?: string(name='Time'),
        type?: string(name='Type'),
        url?: string(name='Url'),
      }
    ](name='Products'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListCmsInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCmsInstancesResponseBody(name='body'),
}

async function listCmsInstancesWithOptions(request: ListCmsInstancesRequest, runtime: Util.RuntimeOptions): ListCmsInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.typeFilter)) {
    query['TypeFilter'] = request.typeFilter;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCmsInstances',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCmsInstances(request: ListCmsInstancesRequest): ListCmsInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCmsInstancesWithOptions(request, runtime);
}

model ListDashboardsRequest {
  clusterId?: string(name='ClusterId'),
  clusterType?: string(name='ClusterType'),
  dashboardName?: string(name='DashboardName'),
  language?: string(name='Language'),
  product?: string(name='Product'),
  recreateSwitch?: boolean(name='RecreateSwitch'),
  regionId?: string(name='RegionId'),
  title?: string(name='Title'),
}

model ListDashboardsResponseBody = {
  dashboardVos?: [ 
    {
      dashboardType?: string(name='DashboardType'),
      exporter?: string(name='Exporter'),
      httpUrl?: string(name='HttpUrl'),
      httpsUrl?: string(name='HttpsUrl'),
      i18nChild?: {
        dashboardType?: string(name='DashboardType'),
        exporter?: string(name='Exporter'),
        httpUrl?: string(name='HttpUrl'),
        httpsUrl?: string(name='HttpsUrl'),
        id?: string(name='Id'),
        isArmsExporter?: boolean(name='IsArmsExporter'),
        kind?: string(name='Kind'),
        language?: string(name='Language'),
        name?: string(name='Name'),
        needUpdate?: boolean(name='NeedUpdate'),
        tags?: [ string ](name='Tags'),
        time?: string(name='Time'),
        title?: string(name='Title'),
        type?: string(name='Type'),
        uid?: string(name='Uid'),
        url?: string(name='Url'),
        version?: string(name='Version'),
      }(name='I18nChild'),
      id?: string(name='Id'),
      isArmsExporter?: boolean(name='IsArmsExporter'),
      kind?: string(name='Kind'),
      language?: string(name='Language'),
      name?: string(name='Name'),
      needUpdate?: boolean(name='NeedUpdate'),
      tags?: [ string ](name='Tags'),
      time?: string(name='Time'),
      title?: string(name='Title'),
      type?: string(name='Type'),
      uid?: string(name='Uid'),
      url?: string(name='Url'),
      version?: string(name='Version'),
    }
  ](name='DashboardVos'),
  requestId?: string(name='RequestId'),
}

model ListDashboardsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDashboardsResponseBody(name='body'),
}

async function listDashboardsWithOptions(request: ListDashboardsRequest, runtime: Util.RuntimeOptions): ListDashboardsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.dashboardName)) {
    query['DashboardName'] = request.dashboardName;
  }
  if (!Util.isUnset(request.language)) {
    query['Language'] = request.language;
  }
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  if (!Util.isUnset(request.recreateSwitch)) {
    query['RecreateSwitch'] = request.recreateSwitch;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDashboards',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDashboards(request: ListDashboardsRequest): ListDashboardsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDashboardsWithOptions(request, runtime);
}

model ListDashboardsByNameRequest {
  clusterId?: string(name='ClusterId'),
  clusterType?: string(name='ClusterType'),
  dashBoardName?: string(name='DashBoardName'),
  dashBoardVersion?: string(name='DashBoardVersion'),
  dataSourceType?: string(name='DataSourceType'),
  groupName?: string(name='GroupName'),
  onlyQuery?: boolean(name='OnlyQuery'),
  productCode?: string(name='ProductCode'),
  regionId?: string(name='RegionId'),
}

model ListDashboardsByNameResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListDashboardsByNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDashboardsByNameResponseBody(name='body'),
}

async function listDashboardsByNameWithOptions(request: ListDashboardsByNameRequest, runtime: Util.RuntimeOptions): ListDashboardsByNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.dashBoardName)) {
    query['DashBoardName'] = request.dashBoardName;
  }
  if (!Util.isUnset(request.dashBoardVersion)) {
    query['DashBoardVersion'] = request.dashBoardVersion;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    query['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.onlyQuery)) {
    query['OnlyQuery'] = request.onlyQuery;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDashboardsByName',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDashboardsByName(request: ListDashboardsByNameRequest): ListDashboardsByNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDashboardsByNameWithOptions(request, runtime);
}

model ListDispatchRuleRequest {
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  system?: boolean(name='System'),
}

model ListDispatchRuleResponseBody = {
  dispatchRules?: [ 
    {
      name?: string(name='Name'),
      ruleId?: long(name='RuleId'),
      state?: string(name='State'),
    }
  ](name='DispatchRules'),
  requestId?: string(name='RequestId'),
}

model ListDispatchRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDispatchRuleResponseBody(name='body'),
}

async function listDispatchRuleWithOptions(request: ListDispatchRuleRequest, runtime: Util.RuntimeOptions): ListDispatchRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.system)) {
    query['System'] = request.system;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDispatchRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDispatchRule(request: ListDispatchRuleRequest): ListDispatchRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDispatchRuleWithOptions(request, runtime);
}

model ListEscalationPoliciesRequest {
  name?: string(name='Name'),
  page?: long(name='Page'),
  size?: long(name='Size'),
}

model ListEscalationPoliciesResponseBody = {
  pageBean?: {
    escalationPolicies?: [ 
      {
        id?: long(name='Id'),
        name?: string(name='Name'),
      }
    ](name='EscalationPolicies'),
    page?: long(name='Page'),
    size?: long(name='Size'),
    total?: long(name='Total'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model ListEscalationPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEscalationPoliciesResponseBody(name='body'),
}

async function listEscalationPoliciesWithOptions(request: ListEscalationPoliciesRequest, runtime: Util.RuntimeOptions): ListEscalationPoliciesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEscalationPolicies',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEscalationPolicies(request: ListEscalationPoliciesRequest): ListEscalationPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEscalationPoliciesWithOptions(request, runtime);
}

model ListEventBridgeIntegrationsRequest {
  name?: string(name='Name'),
  page?: long(name='Page'),
  size?: long(name='Size'),
}

model ListEventBridgeIntegrationsResponseBody = {
  pageBean?: {
    eventBridgeIntegrations?: [ 
      {
        description?: string(name='Description'),
        id?: long(name='Id'),
        name?: string(name='Name'),
      }
    ](name='EventBridgeIntegrations'),
    page?: long(name='Page'),
    size?: long(name='Size'),
    total?: long(name='Total'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model ListEventBridgeIntegrationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventBridgeIntegrationsResponseBody(name='body'),
}

async function listEventBridgeIntegrationsWithOptions(request: ListEventBridgeIntegrationsRequest, runtime: Util.RuntimeOptions): ListEventBridgeIntegrationsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEventBridgeIntegrations',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEventBridgeIntegrations(request: ListEventBridgeIntegrationsRequest): ListEventBridgeIntegrationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventBridgeIntegrationsWithOptions(request, runtime);
}

model ListInsightsEventsRequest {
  endTime?: string(name='EndTime'),
  insightsTypes?: string(name='InsightsTypes'),
  pid?: string(name='Pid'),
  regionId?: string(name='RegionId'),
  startTime?: string(name='StartTime'),
}

model ListInsightsEventsResponseBody = {
  insightsEvents?: [ 
    {
      date?: long(name='Date'),
      desc?: string(name='Desc'),
      level?: string(name='Level'),
      pid?: string(name='Pid'),
      title?: string(name='Title'),
      type?: string(name='Type'),
    }
  ](name='InsightsEvents'),
  requestId?: string(name='RequestId'),
}

model ListInsightsEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInsightsEventsResponseBody(name='body'),
}

async function listInsightsEventsWithOptions(request: ListInsightsEventsRequest, runtime: Util.RuntimeOptions): ListInsightsEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.insightsTypes)) {
    query['InsightsTypes'] = request.insightsTypes;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInsightsEvents',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInsightsEvents(request: ListInsightsEventsRequest): ListInsightsEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInsightsEventsWithOptions(request, runtime);
}

model ListIntegrationRequest {
  integrationName?: string(name='IntegrationName'),
  integrationProductType?: string(name='IntegrationProductType'),
  isDetail?: boolean(name='IsDetail'),
  page?: long(name='Page'),
  size?: long(name='Size'),
}

model ListIntegrationResponseBody = {
  pageInfo?: {
    integrations?: [ 
      {
        apiEndpoint?: string(name='ApiEndpoint'),
        createTime?: string(name='CreateTime'),
        integrationDetail?: {
          autoRecover?: boolean(name='AutoRecover'),
          description?: string(name='Description'),
          duplicateKey?: string(name='DuplicateKey'),
          extendedFieldRedefineRules?: [  map[string]any ](name='ExtendedFieldRedefineRules'),
          fieldRedefineRules?: [  map[string]any ](name='FieldRedefineRules'),
          initiativeRecoverField?: string(name='InitiativeRecoverField'),
          initiativeRecoverValue?: string(name='InitiativeRecoverValue'),
          recoverTime?: long(name='RecoverTime'),
          stat?: [ long ](name='Stat'),
        }(name='IntegrationDetail'),
        integrationId?: long(name='IntegrationId'),
        integrationName?: string(name='IntegrationName'),
        integrationProductType?: string(name='IntegrationProductType'),
        liveness?: string(name='Liveness'),
        shortToken?: string(name='ShortToken'),
        state?: boolean(name='State'),
      }
    ](name='Integrations'),
    page?: long(name='Page'),
    size?: long(name='Size'),
    total?: long(name='Total'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model ListIntegrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIntegrationResponseBody(name='body'),
}

async function listIntegrationWithOptions(request: ListIntegrationRequest, runtime: Util.RuntimeOptions): ListIntegrationResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIntegration',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listIntegration(request: ListIntegrationRequest): ListIntegrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIntegrationWithOptions(request, runtime);
}

model ListNotificationPoliciesRequest {
  isDetail?: boolean(name='IsDetail'),
  name?: string(name='Name'),
  page?: long(name='Page'),
  regionId?: string(name='RegionId'),
  size?: long(name='Size'),
}

model ListNotificationPoliciesResponseBody = {
  pageBean?: {
    notificationPolicies?: [ 
      {
        escalationPolicyId?: long(name='EscalationPolicyId'),
        groupRule?: {
          groupInterval?: long(name='GroupInterval'),
          groupWait?: long(name='GroupWait'),
          groupingFields?: [ string ](name='GroupingFields'),
        }(name='GroupRule'),
        id?: long(name='Id'),
        integrationId?: long(name='IntegrationId'),
        matchingRules?: [ 
          {
            matchingConditions?: [ 
              {
                key?: string(name='Key'),
                operator?: string(name='Operator'),
                value?: string(name='Value'),
              }
            ](name='MatchingConditions'),
          }
        ](name='MatchingRules'),
        name?: string(name='Name'),
        notifyRule?: {
          notifyChannels?: [ string ](name='NotifyChannels'),
          notifyEndTime?: string(name='NotifyEndTime'),
          notifyObjects?: [ 
            {
              notifyObjectId?: long(name='NotifyObjectId'),
              notifyObjectName?: string(name='NotifyObjectName'),
              notifyObjectType?: string(name='NotifyObjectType'),
            }
          ](name='NotifyObjects'),
          notifyStartTime?: string(name='NotifyStartTime'),
        }(name='NotifyRule'),
        notifyTemplate?: {
          emailContent?: string(name='EmailContent'),
          emailRecoverContent?: string(name='EmailRecoverContent'),
          emailRecoverTitle?: string(name='EmailRecoverTitle'),
          emailTitle?: string(name='EmailTitle'),
          robotContent?: string(name='RobotContent'),
          smsContent?: string(name='SmsContent'),
          smsRecoverContent?: string(name='SmsRecoverContent'),
          ttsContent?: string(name='TtsContent'),
          ttsRecoverContent?: string(name='TtsRecoverContent'),
        }(name='NotifyTemplate'),
        repeat?: boolean(name='Repeat'),
        repeatInterval?: long(name='RepeatInterval'),
        sendRecoverMessage?: boolean(name='SendRecoverMessage'),
      }
    ](name='NotificationPolicies'),
    page?: long(name='Page'),
    size?: long(name='Size'),
    total?: long(name='Total'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model ListNotificationPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNotificationPoliciesResponseBody(name='body'),
}

async function listNotificationPoliciesWithOptions(request: ListNotificationPoliciesRequest, runtime: Util.RuntimeOptions): ListNotificationPoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.isDetail)) {
    query['IsDetail'] = request.isDetail;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNotificationPolicies',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNotificationPolicies(request: ListNotificationPoliciesRequest): ListNotificationPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNotificationPoliciesWithOptions(request, runtime);
}

model ListOnCallSchedulesRequest {
  name?: string(name='Name'),
  page?: long(name='Page'),
  size?: long(name='Size'),
}

model ListOnCallSchedulesResponseBody = {
  pageBean?: {
    onCallSchedules?: [ 
      {
        description?: string(name='Description'),
        id?: long(name='Id'),
        name?: string(name='Name'),
      }
    ](name='OnCallSchedules'),
    page?: long(name='Page'),
    size?: long(name='Size'),
    total?: long(name='Total'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model ListOnCallSchedulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOnCallSchedulesResponseBody(name='body'),
}

async function listOnCallSchedulesWithOptions(request: ListOnCallSchedulesRequest, runtime: Util.RuntimeOptions): ListOnCallSchedulesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOnCallSchedules',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOnCallSchedules(request: ListOnCallSchedulesRequest): ListOnCallSchedulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOnCallSchedulesWithOptions(request, runtime);
}

model ListPrometheusAlertRulesRequest {
  clusterId?: string(name='ClusterId'),
  matchExpressions?: string(name='MatchExpressions'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  status?: int32(name='Status'),
  type?: string(name='Type'),
}

model ListPrometheusAlertRulesResponseBody = {
  prometheusAlertRules?: [ 
    {
      alertId?: long(name='AlertId'),
      alertName?: string(name='AlertName'),
      annotations?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='Annotations'),
      clusterId?: string(name='ClusterId'),
      dispatchRuleId?: long(name='DispatchRuleId'),
      duration?: string(name='Duration'),
      expression?: string(name='Expression'),
      labels?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='Labels'),
      message?: string(name='Message'),
      notifyType?: string(name='NotifyType'),
      status?: int32(name='Status'),
      type?: string(name='Type'),
    }
  ](name='PrometheusAlertRules'),
  requestId?: string(name='RequestId'),
}

model ListPrometheusAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPrometheusAlertRulesResponseBody(name='body'),
}

async function listPrometheusAlertRulesWithOptions(request: ListPrometheusAlertRulesRequest, runtime: Util.RuntimeOptions): ListPrometheusAlertRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.matchExpressions)) {
    query['MatchExpressions'] = request.matchExpressions;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrometheusAlertRules',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPrometheusAlertRules(request: ListPrometheusAlertRulesRequest): ListPrometheusAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPrometheusAlertRulesWithOptions(request, runtime);
}

model ListPrometheusAlertTemplatesRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
}

model ListPrometheusAlertTemplatesResponseBody = {
  prometheusAlertTemplates?: [ 
    {
      alertName?: string(name='AlertName'),
      annotations?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='Annotations'),
      description?: string(name='Description'),
      duration?: string(name='Duration'),
      expression?: string(name='Expression'),
      labels?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='Labels'),
      type?: string(name='Type'),
      version?: string(name='Version'),
    }
  ](name='PrometheusAlertTemplates'),
  requestId?: string(name='RequestId'),
}

model ListPrometheusAlertTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPrometheusAlertTemplatesResponseBody(name='body'),
}

async function listPrometheusAlertTemplatesWithOptions(request: ListPrometheusAlertTemplatesRequest, runtime: Util.RuntimeOptions): ListPrometheusAlertTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrometheusAlertTemplates',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPrometheusAlertTemplates(request: ListPrometheusAlertTemplatesRequest): ListPrometheusAlertTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPrometheusAlertTemplatesWithOptions(request, runtime);
}

model ListPrometheusGlobalViewRequest {
  regionId?: string(name='RegionId'),
}

model ListPrometheusGlobalViewResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListPrometheusGlobalViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPrometheusGlobalViewResponseBody(name='body'),
}

async function listPrometheusGlobalViewWithOptions(request: ListPrometheusGlobalViewRequest, runtime: Util.RuntimeOptions): ListPrometheusGlobalViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrometheusGlobalView',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPrometheusGlobalView(request: ListPrometheusGlobalViewRequest): ListPrometheusGlobalViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPrometheusGlobalViewWithOptions(request, runtime);
}

model ListPrometheusInstancesRequest {
  regionId?: string(name='RegionId'),
  showGlobalView?: boolean(name='ShowGlobalView'),
}

model ListPrometheusInstancesResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListPrometheusInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPrometheusInstancesResponseBody(name='body'),
}

async function listPrometheusInstancesWithOptions(request: ListPrometheusInstancesRequest, runtime: Util.RuntimeOptions): ListPrometheusInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.showGlobalView)) {
    query['ShowGlobalView'] = request.showGlobalView;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrometheusInstances',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPrometheusInstances(request: ListPrometheusInstancesRequest): ListPrometheusInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPrometheusInstancesWithOptions(request, runtime);
}

model ListRetcodeAppsRequest {
  regionId?: string(name='RegionId'),
  securityToken?: string(name='SecurityToken'),
}

model ListRetcodeAppsResponseBody = {
  requestId?: string(name='RequestId'),
  retcodeApps?: [ 
    {
      appId?: long(name='AppId'),
      appName?: string(name='AppName'),
      pid?: string(name='Pid'),
      retcodeAppType?: string(name='RetcodeAppType'),
    }
  ](name='RetcodeApps'),
}

model ListRetcodeAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRetcodeAppsResponseBody(name='body'),
}

async function listRetcodeAppsWithOptions(request: ListRetcodeAppsRequest, runtime: Util.RuntimeOptions): ListRetcodeAppsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRetcodeApps',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRetcodeApps(request: ListRetcodeAppsRequest): ListRetcodeAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRetcodeAppsWithOptions(request, runtime);
}

model ListScenarioRequest {
  appId?: string(name='AppId'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  scenario?: string(name='Scenario'),
  sign?: string(name='Sign'),
}

model ListScenarioResponseBody = {
  armsScenarios?: [ 
    {
      appId?: string(name='AppId'),
      createTime?: string(name='CreateTime'),
      extensions?: string(name='Extensions'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      sign?: string(name='Sign'),
      updateTime?: string(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='ArmsScenarios'),
  requestId?: string(name='RequestId'),
}

model ListScenarioResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListScenarioResponseBody(name='body'),
}

async function listScenarioWithOptions(request: ListScenarioRequest, runtime: Util.RuntimeOptions): ListScenarioResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.scenario)) {
    query['Scenario'] = request.scenario;
  }
  if (!Util.isUnset(request.sign)) {
    query['Sign'] = request.sign;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListScenario',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listScenario(request: ListScenarioRequest): ListScenarioResponse {
  var runtime = new Util.RuntimeOptions{};
  return listScenarioWithOptions(request, runtime);
}

model ListSilencePoliciesRequest {
  isDetail?: boolean(name='IsDetail'),
  name?: string(name='Name'),
  page?: long(name='Page'),
  regionId?: string(name='RegionId'),
  size?: long(name='Size'),
}

model ListSilencePoliciesResponseBody = {
  pageBean?: {
    page?: long(name='Page'),
    silencePolicies?: [ 
      {
        id?: long(name='Id'),
        matchingRules?: [ 
          {
            matchingConditions?: [ 
              {
                key?: string(name='Key'),
                operator?: string(name='Operator'),
                value?: string(name='Value'),
              }
            ](name='MatchingConditions'),
          }
        ](name='MatchingRules'),
        name?: string(name='Name'),
      }
    ](name='SilencePolicies'),
    size?: long(name='Size'),
    total?: long(name='Total'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model ListSilencePoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSilencePoliciesResponseBody(name='body'),
}

async function listSilencePoliciesWithOptions(request: ListSilencePoliciesRequest, runtime: Util.RuntimeOptions): ListSilencePoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.isDetail)) {
    query['IsDetail'] = request.isDetail;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSilencePolicies',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSilencePolicies(request: ListSilencePoliciesRequest): ListSilencePoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSilencePoliciesWithOptions(request, runtime);
}

model ListTraceAppsRequest {
  regionId?: string(name='RegionId'),
}

model ListTraceAppsResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceApps?: [ 
    {
      appId?: long(name='AppId'),
      appName?: string(name='AppName'),
      createTime?: long(name='CreateTime'),
      labels?: [ string ](name='Labels'),
      pid?: string(name='Pid'),
      regionId?: string(name='RegionId'),
      show?: boolean(name='Show'),
      type?: string(name='Type'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='TraceApps'),
}

model ListTraceAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTraceAppsResponseBody(name='body'),
}

async function listTraceAppsWithOptions(request: ListTraceAppsRequest, runtime: Util.RuntimeOptions): ListTraceAppsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTraceApps',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTraceApps(request: ListTraceAppsRequest): ListTraceAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTraceAppsWithOptions(request, runtime);
}

model ManageGetRecordingRuleRequest {
  clusterId?: string(name='ClusterId'),
  queryUserId?: string(name='QueryUserId'),
  regionId?: string(name='RegionId'),
}

model ManageGetRecordingRuleResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ManageGetRecordingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ManageGetRecordingRuleResponseBody(name='body'),
}

async function manageGetRecordingRuleWithOptions(request: ManageGetRecordingRuleRequest, runtime: Util.RuntimeOptions): ManageGetRecordingRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.queryUserId)) {
    query['QueryUserId'] = request.queryUserId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ManageGetRecordingRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function manageGetRecordingRule(request: ManageGetRecordingRuleRequest): ManageGetRecordingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return manageGetRecordingRuleWithOptions(request, runtime);
}

model ManageRecordingRuleRequest {
  clusterId?: string(name='ClusterId'),
  queryUserId?: string(name='QueryUserId'),
  regionId?: string(name='RegionId'),
  ruleYaml?: string(name='RuleYaml'),
}

model ManageRecordingRuleResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ManageRecordingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ManageRecordingRuleResponseBody(name='body'),
}

async function manageRecordingRuleWithOptions(request: ManageRecordingRuleRequest, runtime: Util.RuntimeOptions): ManageRecordingRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.queryUserId)) {
    query['QueryUserId'] = request.queryUserId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.ruleYaml)) {
    query['RuleYaml'] = request.ruleYaml;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ManageRecordingRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function manageRecordingRule(request: ManageRecordingRuleRequest): ManageRecordingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return manageRecordingRuleWithOptions(request, runtime);
}

model OpenArmsDefaultSLRRequest {
  regionId?: string(name='RegionId'),
}

model OpenArmsDefaultSLRResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model OpenArmsDefaultSLRResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenArmsDefaultSLRResponseBody(name='body'),
}

async function openArmsDefaultSLRWithOptions(request: OpenArmsDefaultSLRRequest, runtime: Util.RuntimeOptions): OpenArmsDefaultSLRResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenArmsDefaultSLR',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openArmsDefaultSLR(request: OpenArmsDefaultSLRRequest): OpenArmsDefaultSLRResponse {
  var runtime = new Util.RuntimeOptions{};
  return openArmsDefaultSLRWithOptions(request, runtime);
}

model OpenArmsServiceSecondVersionRequest {
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
}

model OpenArmsServiceSecondVersionResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenArmsServiceSecondVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenArmsServiceSecondVersionResponseBody(name='body'),
}

async function openArmsServiceSecondVersionWithOptions(request: OpenArmsServiceSecondVersionRequest, runtime: Util.RuntimeOptions): OpenArmsServiceSecondVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenArmsServiceSecondVersion',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openArmsServiceSecondVersion(request: OpenArmsServiceSecondVersionRequest): OpenArmsServiceSecondVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return openArmsServiceSecondVersionWithOptions(request, runtime);
}

model OpenVClusterRequest {
  clusterType?: string(name='ClusterType'),
  length?: int32(name='Length'),
  product?: string(name='Product'),
  recreateSwitch?: boolean(name='RecreateSwitch'),
  regionId?: string(name='RegionId'),
}

model OpenVClusterResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model OpenVClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenVClusterResponseBody(name='body'),
}

async function openVClusterWithOptions(request: OpenVClusterRequest, runtime: Util.RuntimeOptions): OpenVClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.length)) {
    query['Length'] = request.length;
  }
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  if (!Util.isUnset(request.recreateSwitch)) {
    query['RecreateSwitch'] = request.recreateSwitch;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenVCluster',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openVCluster(request: OpenVClusterRequest): OpenVClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return openVClusterWithOptions(request, runtime);
}

model OpenXtraceDefaultSLRRequest {
  regionId?: string(name='RegionId'),
}

model OpenXtraceDefaultSLRResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model OpenXtraceDefaultSLRResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenXtraceDefaultSLRResponseBody(name='body'),
}

async function openXtraceDefaultSLRWithOptions(request: OpenXtraceDefaultSLRRequest, runtime: Util.RuntimeOptions): OpenXtraceDefaultSLRResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenXtraceDefaultSLR',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openXtraceDefaultSLR(request: OpenXtraceDefaultSLRRequest): OpenXtraceDefaultSLRResponse {
  var runtime = new Util.RuntimeOptions{};
  return openXtraceDefaultSLRWithOptions(request, runtime);
}

model QueryMetricByPageRequest {
  currentPage?: int32(name='CurrentPage'),
  customFilters?: [ string ](name='CustomFilters'),
  dimensions?: [ string ](name='Dimensions'),
  endTime?: long(name='EndTime'),
  filters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filters'),
  intervalInSec?: int32(name='IntervalInSec'),
  measures?: [ string ](name='Measures'),
  metric?: string(name='Metric'),
  order?: string(name='Order'),
  orderBy?: string(name='OrderBy'),
  pageSize?: int32(name='PageSize'),
  startTime?: long(name='StartTime'),
}

model QueryMetricByPageResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [  map[string]any ](name='Items'),
    page?: int32(name='Page'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryMetricByPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMetricByPageResponseBody(name='body'),
}

async function queryMetricByPageWithOptions(request: QueryMetricByPageRequest, runtime: Util.RuntimeOptions): QueryMetricByPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.customFilters)) {
    query['CustomFilters'] = request.customFilters;
  }
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!Util.isUnset(request.intervalInSec)) {
    query['IntervalInSec'] = request.intervalInSec;
  }
  if (!Util.isUnset(request.measures)) {
    query['Measures'] = request.measures;
  }
  if (!Util.isUnset(request.metric)) {
    query['Metric'] = request.metric;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMetricByPage',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMetricByPage(request: QueryMetricByPageRequest): QueryMetricByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMetricByPageWithOptions(request, runtime);
}

model QueryPromInstallStatusRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
}

model QueryPromInstallStatusResponseBody = {
  data?: {
    isControllerInstalled?: boolean(name='isControllerInstalled'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryPromInstallStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryPromInstallStatusResponseBody(name='body'),
}

async function queryPromInstallStatusWithOptions(request: QueryPromInstallStatusRequest, runtime: Util.RuntimeOptions): QueryPromInstallStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryPromInstallStatus',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryPromInstallStatus(request: QueryPromInstallStatusRequest): QueryPromInstallStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPromInstallStatusWithOptions(request, runtime);
}

model QueryReleaseMetricRequest {
  changeOrderId?: string(name='ChangeOrderId'),
  createTime?: long(name='CreateTime'),
  metricType?: string(name='MetricType'),
  pid?: string(name='Pid'),
  proxyUserId?: string(name='ProxyUserId'),
  releaseEndTime?: long(name='ReleaseEndTime'),
  releaseStartTime?: long(name='ReleaseStartTime'),
  service?: string(name='Service'),
}

model QueryReleaseMetricResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryReleaseMetricResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryReleaseMetricResponseBody(name='body'),
}

async function queryReleaseMetricWithOptions(request: QueryReleaseMetricRequest, runtime: Util.RuntimeOptions): QueryReleaseMetricResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.changeOrderId)) {
    query['ChangeOrderId'] = request.changeOrderId;
  }
  if (!Util.isUnset(request.createTime)) {
    query['CreateTime'] = request.createTime;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.proxyUserId)) {
    query['ProxyUserId'] = request.proxyUserId;
  }
  if (!Util.isUnset(request.releaseEndTime)) {
    query['ReleaseEndTime'] = request.releaseEndTime;
  }
  if (!Util.isUnset(request.releaseStartTime)) {
    query['ReleaseStartTime'] = request.releaseStartTime;
  }
  if (!Util.isUnset(request.service)) {
    query['Service'] = request.service;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryReleaseMetric',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryReleaseMetric(request: QueryReleaseMetricRequest): QueryReleaseMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryReleaseMetricWithOptions(request, runtime);
}

model RemoveAliClusterIdsFromPrometheusGlobalViewRequest {
  clusterIds?: string(name='ClusterIds'),
  globalViewClusterId?: string(name='GlobalViewClusterId'),
  groupName?: string(name='GroupName'),
  regionId?: string(name='RegionId'),
}

model RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody = {
  data?: {
    info?: string(name='Info'),
    msg?: string(name='Msg'),
    success?: boolean(name='Success'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RemoveAliClusterIdsFromPrometheusGlobalViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody(name='body'),
}

async function removeAliClusterIdsFromPrometheusGlobalViewWithOptions(request: RemoveAliClusterIdsFromPrometheusGlobalViewRequest, runtime: Util.RuntimeOptions): RemoveAliClusterIdsFromPrometheusGlobalViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterIds)) {
    query['ClusterIds'] = request.clusterIds;
  }
  if (!Util.isUnset(request.globalViewClusterId)) {
    query['GlobalViewClusterId'] = request.globalViewClusterId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveAliClusterIdsFromPrometheusGlobalView',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeAliClusterIdsFromPrometheusGlobalView(request: RemoveAliClusterIdsFromPrometheusGlobalViewRequest): RemoveAliClusterIdsFromPrometheusGlobalViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeAliClusterIdsFromPrometheusGlobalViewWithOptions(request, runtime);
}

model RemoveSourcesFromPrometheusGlobalViewRequest {
  globalViewClusterId?: string(name='GlobalViewClusterId'),
  groupName?: string(name='GroupName'),
  regionId?: string(name='RegionId'),
  sourceNames?: string(name='SourceNames'),
}

model RemoveSourcesFromPrometheusGlobalViewResponseBody = {
  data?: {
    info?: string(name='Info'),
    msg?: string(name='Msg'),
    success?: boolean(name='Success'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RemoveSourcesFromPrometheusGlobalViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveSourcesFromPrometheusGlobalViewResponseBody(name='body'),
}

async function removeSourcesFromPrometheusGlobalViewWithOptions(request: RemoveSourcesFromPrometheusGlobalViewRequest, runtime: Util.RuntimeOptions): RemoveSourcesFromPrometheusGlobalViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalViewClusterId)) {
    query['GlobalViewClusterId'] = request.globalViewClusterId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sourceNames)) {
    query['SourceNames'] = request.sourceNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveSourcesFromPrometheusGlobalView',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeSourcesFromPrometheusGlobalView(request: RemoveSourcesFromPrometheusGlobalViewRequest): RemoveSourcesFromPrometheusGlobalViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeSourcesFromPrometheusGlobalViewWithOptions(request, runtime);
}

model SaveTraceAppConfigRequest {
  pid?: string(name='Pid'),
  settings?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Settings'),
}

model SaveTraceAppConfigResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model SaveTraceAppConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTraceAppConfigResponseBody(name='body'),
}

async function saveTraceAppConfigWithOptions(request: SaveTraceAppConfigRequest, runtime: Util.RuntimeOptions): SaveTraceAppConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.settings)) {
    query['Settings'] = request.settings;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveTraceAppConfig',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveTraceAppConfig(request: SaveTraceAppConfigRequest): SaveTraceAppConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTraceAppConfigWithOptions(request, runtime);
}

model SearchAlertContactRequest {
  contactIds?: string(name='ContactIds'),
  contactName?: string(name='ContactName'),
  currentPage?: string(name='CurrentPage'),
  email?: string(name='Email'),
  pageSize?: string(name='PageSize'),
  phone?: string(name='Phone'),
  regionId?: string(name='RegionId'),
}

model SearchAlertContactResponseBody = {
  pageBean?: {
    contacts?: [ 
      {
        contactId?: long(name='ContactId'),
        contactName?: string(name='ContactName'),
        content?: string(name='Content'),
        createTime?: long(name='CreateTime'),
        dingRobot?: string(name='DingRobot'),
        email?: string(name='Email'),
        phone?: string(name='Phone'),
        systemNoc?: boolean(name='SystemNoc'),
        updateTime?: long(name='UpdateTime'),
        userId?: string(name='UserId'),
        webhook?: string(name='Webhook'),
      }
    ](name='Contacts'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchAlertContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchAlertContactResponseBody(name='body'),
}

async function searchAlertContactWithOptions(request: SearchAlertContactRequest, runtime: Util.RuntimeOptions): SearchAlertContactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactIds)) {
    query['ContactIds'] = request.contactIds;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.phone)) {
    query['Phone'] = request.phone;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchAlertContact',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchAlertContact(request: SearchAlertContactRequest): SearchAlertContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAlertContactWithOptions(request, runtime);
}

model SearchAlertContactGroupRequest {
  contactGroupIds?: string(name='ContactGroupIds'),
  contactGroupName?: string(name='ContactGroupName'),
  contactId?: long(name='ContactId'),
  contactName?: string(name='ContactName'),
  isDetail?: boolean(name='IsDetail'),
  regionId?: string(name='RegionId'),
}

model SearchAlertContactGroupResponseBody = {
  contactGroups?: [ 
    {
      contactGroupId?: long(name='ContactGroupId'),
      contactGroupName?: string(name='ContactGroupName'),
      contacts?: [ 
        {
          contactId?: long(name='ContactId'),
          contactName?: string(name='ContactName'),
          createTime?: long(name='CreateTime'),
          dingRobot?: string(name='DingRobot'),
          email?: string(name='Email'),
          phone?: string(name='Phone'),
          systemNoc?: boolean(name='SystemNoc'),
          updateTime?: long(name='UpdateTime'),
          userId?: string(name='UserId'),
        }
      ](name='Contacts'),
      createTime?: long(name='CreateTime'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='ContactGroups'),
  requestId?: string(name='RequestId'),
}

model SearchAlertContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchAlertContactGroupResponseBody(name='body'),
}

async function searchAlertContactGroupWithOptions(request: SearchAlertContactGroupRequest, runtime: Util.RuntimeOptions): SearchAlertContactGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupIds)) {
    query['ContactGroupIds'] = request.contactGroupIds;
  }
  if (!Util.isUnset(request.contactGroupName)) {
    query['ContactGroupName'] = request.contactGroupName;
  }
  if (!Util.isUnset(request.contactId)) {
    query['ContactId'] = request.contactId;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.isDetail)) {
    query['IsDetail'] = request.isDetail;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchAlertContactGroup',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchAlertContactGroup(request: SearchAlertContactGroupRequest): SearchAlertContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAlertContactGroupWithOptions(request, runtime);
}

model SearchAlertHistoriesRequest {
  alertId?: long(name='AlertId'),
  alertType?: int32(name='AlertType'),
  currentPage?: int32(name='CurrentPage'),
  endTime?: long(name='EndTime'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  startTime?: long(name='StartTime'),
}

model SearchAlertHistoriesResponseBody = {
  pageBean?: {
    alarmHistories?: [ 
      {
        alarmContent?: string(name='AlarmContent'),
        alarmResponseCode?: int32(name='AlarmResponseCode'),
        alarmSources?: string(name='AlarmSources'),
        alarmTime?: long(name='AlarmTime'),
        alarmType?: int32(name='AlarmType'),
        emails?: string(name='Emails'),
        id?: long(name='Id'),
        phones?: string(name='Phones'),
        strategyId?: string(name='StrategyId'),
        target?: string(name='Target'),
        userId?: string(name='UserId'),
      }
    ](name='AlarmHistories'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchAlertHistoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchAlertHistoriesResponseBody(name='body'),
}

async function searchAlertHistoriesWithOptions(request: SearchAlertHistoriesRequest, runtime: Util.RuntimeOptions): SearchAlertHistoriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!Util.isUnset(request.alertType)) {
    query['AlertType'] = request.alertType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchAlertHistories',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchAlertHistories(request: SearchAlertHistoriesRequest): SearchAlertHistoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAlertHistoriesWithOptions(request, runtime);
}

model SearchAlertRulesRequest {
  appType?: string(name='AppType'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  pid?: string(name='Pid'),
  regionId?: string(name='RegionId'),
  systemRegionId?: string(name='SystemRegionId'),
  title?: string(name='Title'),
  type?: string(name='Type'),
}

model SearchAlertRulesResponseBody = {
  pageBean?: {
    alertRules?: [ 
      {
        alarmContext?: {
          alarmContentSubTitle?: string(name='AlarmContentSubTitle'),
          alarmContentTemplate?: string(name='AlarmContentTemplate'),
          content?: string(name='Content'),
          subTitle?: string(name='SubTitle'),
        }(name='AlarmContext'),
        alertLevel?: string(name='AlertLevel'),
        alertRule?: {
          operator?: string(name='Operator'),
          rules?: [ 
            {
              aggregates?: string(name='Aggregates'),
              alias?: string(name='Alias'),
              measure?: string(name='Measure'),
              NValue?: int32(name='NValue'),
              operator?: string(name='Operator'),
              value?: float(name='Value'),
            }
          ](name='Rules'),
        }(name='AlertRule'),
        alertTitle?: string(name='AlertTitle'),
        alertType?: int32(name='AlertType'),
        alertVersion?: int32(name='AlertVersion'),
        alertWays?: [ string ](name='AlertWays'),
        config?: string(name='Config'),
        contactGroupIdList?: string(name='ContactGroupIdList'),
        contactGroupIds?: string(name='ContactGroupIds'),
        createTime?: long(name='CreateTime'),
        hostByAlertManager?: boolean(name='HostByAlertManager'),
        id?: long(name='Id'),
        metricParam?: {
          appGroupId?: string(name='AppGroupId'),
          appId?: string(name='AppId'),
          dimensions?: [ 
            {
              key?: string(name='Key'),
              type?: string(name='Type'),
              value?: string(name='Value'),
            }
          ](name='Dimensions'),
          pid?: string(name='Pid'),
          type?: string(name='Type'),
        }(name='MetricParam'),
        notice?: {
          endTime?: long(name='EndTime'),
          noticeEndTime?: long(name='NoticeEndTime'),
          noticeStartTime?: long(name='NoticeStartTime'),
          startTime?: long(name='StartTime'),
        }(name='Notice'),
        regionId?: string(name='RegionId'),
        status?: string(name='Status'),
        taskId?: long(name='TaskId'),
        taskStatus?: string(name='TaskStatus'),
        title?: string(name='Title'),
        updateTime?: long(name='UpdateTime'),
        userId?: string(name='UserId'),
      }
    ](name='AlertRules'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchAlertRulesResponseBody(name='body'),
}

async function searchAlertRulesWithOptions(request: SearchAlertRulesRequest, runtime: Util.RuntimeOptions): SearchAlertRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appType)) {
    query['AppType'] = request.appType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.systemRegionId)) {
    query['SystemRegionId'] = request.systemRegionId;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchAlertRules',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchAlertRules(request: SearchAlertRulesRequest): SearchAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAlertRulesWithOptions(request, runtime);
}

model SearchEventsRequest {
  alertId?: long(name='AlertId'),
  alertType?: int32(name='AlertType'),
  appType?: string(name='AppType'),
  currentPage?: int32(name='CurrentPage'),
  endTime?: long(name='EndTime'),
  isTrigger?: int32(name='IsTrigger'),
  pageSize?: int32(name='PageSize'),
  pid?: string(name='Pid'),
  regionId?: string(name='RegionId'),
  startTime?: long(name='StartTime'),
}

model SearchEventsResponseBody = {
  isTrigger?: int32(name='IsTrigger'),
  pageBean?: {
    event?: [ 
      {
        alertId?: long(name='AlertId'),
        alertName?: string(name='AlertName'),
        alertRule?: string(name='AlertRule'),
        alertType?: int32(name='AlertType'),
        eventLevel?: string(name='EventLevel'),
        eventTime?: long(name='EventTime'),
        id?: long(name='Id'),
        links?: [ string ](name='Links'),
        message?: string(name='Message'),
      }
    ](name='Event'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchEventsResponseBody(name='body'),
}

async function searchEventsWithOptions(request: SearchEventsRequest, runtime: Util.RuntimeOptions): SearchEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!Util.isUnset(request.alertType)) {
    query['AlertType'] = request.alertType;
  }
  if (!Util.isUnset(request.appType)) {
    query['AppType'] = request.appType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.isTrigger)) {
    query['IsTrigger'] = request.isTrigger;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchEvents',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchEvents(request: SearchEventsRequest): SearchEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchEventsWithOptions(request, runtime);
}

model SearchRetcodeAppByPageRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  retcodeAppName?: string(name='RetcodeAppName'),
}

model SearchRetcodeAppByPageResponseBody = {
  pageBean?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    retcodeApps?: [ 
      {
        appId?: long(name='AppId'),
        appName?: string(name='AppName'),
        createTime?: long(name='CreateTime'),
        pid?: string(name='Pid'),
        regionId?: string(name='RegionId'),
        retcodeAppType?: string(name='RetcodeAppType'),
        type?: string(name='Type'),
        updateTime?: long(name='UpdateTime'),
        userId?: string(name='UserId'),
      }
    ](name='RetcodeApps'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchRetcodeAppByPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchRetcodeAppByPageResponseBody(name='body'),
}

async function searchRetcodeAppByPageWithOptions(request: SearchRetcodeAppByPageRequest, runtime: Util.RuntimeOptions): SearchRetcodeAppByPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.retcodeAppName)) {
    query['RetcodeAppName'] = request.retcodeAppName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchRetcodeAppByPage',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchRetcodeAppByPage(request: SearchRetcodeAppByPageRequest): SearchRetcodeAppByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchRetcodeAppByPageWithOptions(request, runtime);
}

model SearchTraceAppByNameRequest {
  regionId?: string(name='RegionId'),
  traceAppName?: string(name='TraceAppName'),
}

model SearchTraceAppByNameResponseBody = {
  requestId?: string(name='RequestId'),
  traceApps?: [ 
    {
      appId?: long(name='AppId'),
      appName?: string(name='AppName'),
      createTime?: long(name='CreateTime'),
      labels?: [ string ](name='Labels'),
      pid?: string(name='Pid'),
      regionId?: string(name='RegionId'),
      show?: boolean(name='Show'),
      type?: string(name='Type'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='TraceApps'),
}

model SearchTraceAppByNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchTraceAppByNameResponseBody(name='body'),
}

async function searchTraceAppByNameWithOptions(request: SearchTraceAppByNameRequest, runtime: Util.RuntimeOptions): SearchTraceAppByNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.traceAppName)) {
    query['TraceAppName'] = request.traceAppName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchTraceAppByName',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchTraceAppByName(request: SearchTraceAppByNameRequest): SearchTraceAppByNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTraceAppByNameWithOptions(request, runtime);
}

model SearchTraceAppByPageRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  traceAppName?: string(name='TraceAppName'),
}

model SearchTraceAppByPageResponseBody = {
  pageBean?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    traceApps?: [ 
      {
        appId?: long(name='AppId'),
        appName?: string(name='AppName'),
        createTime?: long(name='CreateTime'),
        labels?: [ string ](name='Labels'),
        pid?: string(name='Pid'),
        regionId?: string(name='RegionId'),
        show?: boolean(name='Show'),
        type?: string(name='Type'),
        updateTime?: long(name='UpdateTime'),
        userId?: string(name='UserId'),
      }
    ](name='TraceApps'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchTraceAppByPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchTraceAppByPageResponseBody(name='body'),
}

async function searchTraceAppByPageWithOptions(request: SearchTraceAppByPageRequest, runtime: Util.RuntimeOptions): SearchTraceAppByPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.traceAppName)) {
    query['TraceAppName'] = request.traceAppName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchTraceAppByPage',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchTraceAppByPage(request: SearchTraceAppByPageRequest): SearchTraceAppByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTraceAppByPageWithOptions(request, runtime);
}

model SearchTracesRequest {
  endTime?: long(name='EndTime'),
  exclusionFilters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='ExclusionFilters'),
  minDuration?: long(name='MinDuration'),
  operationName?: string(name='OperationName'),
  pid?: string(name='Pid'),
  regionId?: string(name='RegionId'),
  reverse?: boolean(name='Reverse'),
  serviceIp?: string(name='ServiceIp'),
  serviceName?: string(name='ServiceName'),
  startTime?: long(name='StartTime'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model SearchTracesResponseBody = {
  requestId?: string(name='RequestId'),
  traceInfos?: [ 
    {
      duration?: long(name='Duration'),
      operationName?: string(name='OperationName'),
      serviceIp?: string(name='ServiceIp'),
      serviceName?: string(name='ServiceName'),
      timestamp?: long(name='Timestamp'),
      traceID?: string(name='TraceID'),
    }
  ](name='TraceInfos'),
}

model SearchTracesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchTracesResponseBody(name='body'),
}

async function searchTracesWithOptions(request: SearchTracesRequest, runtime: Util.RuntimeOptions): SearchTracesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.exclusionFilters)) {
    query['ExclusionFilters'] = request.exclusionFilters;
  }
  if (!Util.isUnset(request.minDuration)) {
    query['MinDuration'] = request.minDuration;
  }
  if (!Util.isUnset(request.operationName)) {
    query['OperationName'] = request.operationName;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.reverse)) {
    query['Reverse'] = request.reverse;
  }
  if (!Util.isUnset(request.serviceIp)) {
    query['ServiceIp'] = request.serviceIp;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchTraces',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchTraces(request: SearchTracesRequest): SearchTracesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTracesWithOptions(request, runtime);
}

model SearchTracesByPageRequest {
  endTime?: long(name='EndTime'),
  exclusionFilters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='ExclusionFilters'),
  minDuration?: long(name='MinDuration'),
  operationName?: string(name='OperationName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  pid?: string(name='Pid'),
  regionId?: string(name='RegionId'),
  reverse?: boolean(name='Reverse'),
  serviceIp?: string(name='ServiceIp'),
  serviceName?: string(name='ServiceName'),
  startTime?: long(name='StartTime'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
}

model SearchTracesByPageResponseBody = {
  pageBean?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
    traceInfos?: [ 
      {
        duration?: long(name='Duration'),
        operationName?: string(name='OperationName'),
        serviceIp?: string(name='ServiceIp'),
        serviceName?: string(name='ServiceName'),
        timestamp?: long(name='Timestamp'),
        traceID?: string(name='TraceID'),
      }
    ](name='TraceInfos'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchTracesByPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchTracesByPageResponseBody(name='body'),
}

async function searchTracesByPageWithOptions(request: SearchTracesByPageRequest, runtime: Util.RuntimeOptions): SearchTracesByPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.exclusionFilters)) {
    query['ExclusionFilters'] = request.exclusionFilters;
  }
  if (!Util.isUnset(request.minDuration)) {
    query['MinDuration'] = request.minDuration;
  }
  if (!Util.isUnset(request.operationName)) {
    query['OperationName'] = request.operationName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.reverse)) {
    query['Reverse'] = request.reverse;
  }
  if (!Util.isUnset(request.serviceIp)) {
    query['ServiceIp'] = request.serviceIp;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchTracesByPage',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchTracesByPage(request: SearchTracesByPageRequest): SearchTracesByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTracesByPageWithOptions(request, runtime);
}

model SendTTSVerifyLinkRequest {
  contactId?: long(name='ContactId'),
  phone?: string(name='Phone'),
}

model SendTTSVerifyLinkResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model SendTTSVerifyLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SendTTSVerifyLinkResponseBody(name='body'),
}

async function sendTTSVerifyLinkWithOptions(request: SendTTSVerifyLinkRequest, runtime: Util.RuntimeOptions): SendTTSVerifyLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.contactId)) {
    body['ContactId'] = request.contactId;
  }
  if (!Util.isUnset(request.phone)) {
    body['Phone'] = request.phone;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SendTTSVerifyLink',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendTTSVerifyLink(request: SendTTSVerifyLinkRequest): SendTTSVerifyLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendTTSVerifyLinkWithOptions(request, runtime);
}

model SetRetcodeShareStatusRequest {
  pid?: string(name='Pid'),
  status?: boolean(name='Status'),
}

model SetRetcodeShareStatusResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model SetRetcodeShareStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetRetcodeShareStatusResponseBody(name='body'),
}

async function setRetcodeShareStatusWithOptions(request: SetRetcodeShareStatusRequest, runtime: Util.RuntimeOptions): SetRetcodeShareStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetRetcodeShareStatus',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setRetcodeShareStatus(request: SetRetcodeShareStatusRequest): SetRetcodeShareStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setRetcodeShareStatusWithOptions(request, runtime);
}

model StartAlertRequest {
  alertId?: string(name='AlertId'),
  regionId?: string(name='RegionId'),
}

model StartAlertResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model StartAlertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartAlertResponseBody(name='body'),
}

async function startAlertWithOptions(request: StartAlertRequest, runtime: Util.RuntimeOptions): StartAlertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartAlert',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startAlert(request: StartAlertRequest): StartAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  return startAlertWithOptions(request, runtime);
}

model StopAlertRequest {
  alertId?: string(name='AlertId'),
  regionId?: string(name='RegionId'),
}

model StopAlertResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model StopAlertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopAlertResponseBody(name='body'),
}

async function stopAlertWithOptions(request: StopAlertRequest, runtime: Util.RuntimeOptions): StopAlertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopAlert',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopAlert(request: StopAlertRequest): StopAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopAlertWithOptions(request, runtime);
}

model SwitchSyntheticTaskStatusRequest {
  switchStatus?: long(name='SwitchStatus'),
  taskIds?: [ long ](name='TaskIds'),
}

model SwitchSyntheticTaskStatusResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model SwitchSyntheticTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SwitchSyntheticTaskStatusResponseBody(name='body'),
}

async function switchSyntheticTaskStatusWithOptions(request: SwitchSyntheticTaskStatusRequest, runtime: Util.RuntimeOptions): SwitchSyntheticTaskStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.switchStatus)) {
    query['SwitchStatus'] = request.switchStatus;
  }
  if (!Util.isUnset(request.taskIds)) {
    query['TaskIds'] = request.taskIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SwitchSyntheticTaskStatus',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function switchSyntheticTaskStatus(request: SwitchSyntheticTaskStatusRequest): SwitchSyntheticTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchSyntheticTaskStatusWithOptions(request, runtime);
}

model SyncRecordingRulesRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
  targetClusters?: string(name='TargetClusters'),
}

model SyncRecordingRulesResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model SyncRecordingRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SyncRecordingRulesResponseBody(name='body'),
}

async function syncRecordingRulesWithOptions(request: SyncRecordingRulesRequest, runtime: Util.RuntimeOptions): SyncRecordingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.targetClusters)) {
    query['TargetClusters'] = request.targetClusters;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SyncRecordingRules',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function syncRecordingRules(request: SyncRecordingRulesRequest): SyncRecordingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncRecordingRulesWithOptions(request, runtime);
}

model TurnOnSecondSwitchRequest {
  pid?: string(name='Pid'),
  proxyUserId?: string(name='ProxyUserId'),
  releaseStartTime?: long(name='ReleaseStartTime'),
}

model TurnOnSecondSwitchResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model TurnOnSecondSwitchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TurnOnSecondSwitchResponseBody(name='body'),
}

async function turnOnSecondSwitchWithOptions(request: TurnOnSecondSwitchRequest, runtime: Util.RuntimeOptions): TurnOnSecondSwitchResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TurnOnSecondSwitch',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function turnOnSecondSwitch(request: TurnOnSecondSwitchRequest): TurnOnSecondSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return turnOnSecondSwitchWithOptions(request, runtime);
}

model UninstallManagedPrometheusRequest {
  clusterId?: string(name='ClusterId'),
  clusterType?: string(name='ClusterType'),
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
}

model UninstallManagedPrometheusResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UninstallManagedPrometheusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallManagedPrometheusResponseBody(name='body'),
}

async function uninstallManagedPrometheusWithOptions(request: UninstallManagedPrometheusRequest, runtime: Util.RuntimeOptions): UninstallManagedPrometheusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallManagedPrometheus',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uninstallManagedPrometheus(request: UninstallManagedPrometheusRequest): UninstallManagedPrometheusResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallManagedPrometheusWithOptions(request, runtime);
}

model UninstallPromClusterRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
}

model UninstallPromClusterResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model UninstallPromClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallPromClusterResponseBody(name='body'),
}

async function uninstallPromClusterWithOptions(request: UninstallPromClusterRequest, runtime: Util.RuntimeOptions): UninstallPromClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallPromCluster',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uninstallPromCluster(request: UninstallPromClusterRequest): UninstallPromClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallPromClusterWithOptions(request, runtime);
}

model UpdateAlertContactRequest {
  contactId?: long(name='ContactId'),
  contactName?: string(name='ContactName'),
  dingRobotWebhookUrl?: string(name='DingRobotWebhookUrl'),
  email?: string(name='Email'),
  phoneNum?: string(name='PhoneNum'),
  regionId?: string(name='RegionId'),
  systemNoc?: boolean(name='SystemNoc'),
}

model UpdateAlertContactResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateAlertContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAlertContactResponseBody(name='body'),
}

async function updateAlertContactWithOptions(request: UpdateAlertContactRequest, runtime: Util.RuntimeOptions): UpdateAlertContactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactId)) {
    query['ContactId'] = request.contactId;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.dingRobotWebhookUrl)) {
    query['DingRobotWebhookUrl'] = request.dingRobotWebhookUrl;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.phoneNum)) {
    query['PhoneNum'] = request.phoneNum;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.systemNoc)) {
    query['SystemNoc'] = request.systemNoc;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlertContact',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAlertContact(request: UpdateAlertContactRequest): UpdateAlertContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAlertContactWithOptions(request, runtime);
}

model UpdateAlertContactGroupRequest {
  contactGroupId?: long(name='ContactGroupId'),
  contactGroupName?: string(name='ContactGroupName'),
  contactIds?: string(name='ContactIds'),
  regionId?: string(name='RegionId'),
}

model UpdateAlertContactGroupResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateAlertContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAlertContactGroupResponseBody(name='body'),
}

async function updateAlertContactGroupWithOptions(request: UpdateAlertContactGroupRequest, runtime: Util.RuntimeOptions): UpdateAlertContactGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupId)) {
    query['ContactGroupId'] = request.contactGroupId;
  }
  if (!Util.isUnset(request.contactGroupName)) {
    query['ContactGroupName'] = request.contactGroupName;
  }
  if (!Util.isUnset(request.contactIds)) {
    query['ContactIds'] = request.contactIds;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlertContactGroup',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAlertContactGroup(request: UpdateAlertContactGroupRequest): UpdateAlertContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAlertContactGroupWithOptions(request, runtime);
}

model UpdateAlertRuleRequest {
  alertId?: long(name='AlertId'),
  contactGroupIds?: string(name='ContactGroupIds'),
  isAutoStart?: boolean(name='IsAutoStart'),
  regionId?: string(name='RegionId'),
  templageAlertConfig?: string(name='TemplageAlertConfig'),
}

model UpdateAlertRuleResponseBody = {
  alertId?: long(name='AlertId'),
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAlertRuleResponseBody(name='body'),
}

async function updateAlertRuleWithOptions(request: UpdateAlertRuleRequest, runtime: Util.RuntimeOptions): UpdateAlertRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!Util.isUnset(request.contactGroupIds)) {
    query['ContactGroupIds'] = request.contactGroupIds;
  }
  if (!Util.isUnset(request.isAutoStart)) {
    query['IsAutoStart'] = request.isAutoStart;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.templageAlertConfig)) {
    query['TemplageAlertConfig'] = request.templageAlertConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlertRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAlertRule(request: UpdateAlertRuleRequest): UpdateAlertRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAlertRuleWithOptions(request, runtime);
}

model UpdateDispatchRuleRequest {
  dispatchRule?: string(name='DispatchRule'),
  regionId?: string(name='RegionId'),
}

model UpdateDispatchRuleResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDispatchRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDispatchRuleResponseBody(name='body'),
}

async function updateDispatchRuleWithOptions(request: UpdateDispatchRuleRequest, runtime: Util.RuntimeOptions): UpdateDispatchRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dispatchRule)) {
    query['DispatchRule'] = request.dispatchRule;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDispatchRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDispatchRule(request: UpdateDispatchRuleRequest): UpdateDispatchRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDispatchRuleWithOptions(request, runtime);
}

model UpdateIntegrationRequest {
  apiEndpoint?: string(name='ApiEndpoint'),
  autoRecover?: boolean(name='AutoRecover'),
  description?: string(name='Description'),
  duplicateKey?: string(name='DuplicateKey'),
  extendedFieldRedefineRules?: string(name='ExtendedFieldRedefineRules'),
  fieldRedefineRules?: string(name='FieldRedefineRules'),
  initiativeRecoverField?: string(name='InitiativeRecoverField'),
  initiativeRecoverValue?: string(name='InitiativeRecoverValue'),
  integrationId?: long(name='IntegrationId'),
  integrationName?: string(name='IntegrationName'),
  integrationProductType?: string(name='IntegrationProductType'),
  liveness?: string(name='Liveness'),
  recoverTime?: long(name='RecoverTime'),
  shortToken?: string(name='ShortToken'),
  stat?: string(name='Stat'),
  state?: boolean(name='State'),
}

model UpdateIntegrationResponseBody = {
  integration?: {
    apiEndpoint?: string(name='ApiEndpoint'),
    autoRecover?: boolean(name='AutoRecover'),
    description?: string(name='Description'),
    duplicateKey?: string(name='DuplicateKey'),
    extendedFieldRedefineRules?: [  map[string]any ](name='ExtendedFieldRedefineRules'),
    fieldRedefineRules?: [  map[string]any ](name='FieldRedefineRules'),
    initiativeRecoverField?: string(name='InitiativeRecoverField'),
    initiativeRecoverValue?: string(name='InitiativeRecoverValue'),
    integrationId?: long(name='IntegrationId'),
    integrationName?: string(name='IntegrationName'),
    integrationProductType?: string(name='IntegrationProductType'),
    liveness?: string(name='Liveness'),
    recoverTime?: long(name='RecoverTime'),
    shortToken?: string(name='ShortToken'),
    stat?: [ long ](name='Stat'),
    state?: boolean(name='State'),
  }(name='Integration'),
  requestId?: string(name='RequestId'),
}

model UpdateIntegrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIntegrationResponseBody(name='body'),
}

async function updateIntegrationWithOptions(request: UpdateIntegrationRequest, runtime: Util.RuntimeOptions): UpdateIntegrationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apiEndpoint)) {
    body['ApiEndpoint'] = request.apiEndpoint;
  }
  if (!Util.isUnset(request.autoRecover)) {
    body['AutoRecover'] = request.autoRecover;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.duplicateKey)) {
    body['DuplicateKey'] = request.duplicateKey;
  }
  if (!Util.isUnset(request.extendedFieldRedefineRules)) {
    body['ExtendedFieldRedefineRules'] = request.extendedFieldRedefineRules;
  }
  if (!Util.isUnset(request.fieldRedefineRules)) {
    body['FieldRedefineRules'] = request.fieldRedefineRules;
  }
  if (!Util.isUnset(request.initiativeRecoverField)) {
    body['InitiativeRecoverField'] = request.initiativeRecoverField;
  }
  if (!Util.isUnset(request.initiativeRecoverValue)) {
    body['InitiativeRecoverValue'] = request.initiativeRecoverValue;
  }
  if (!Util.isUnset(request.integrationId)) {
    body['IntegrationId'] = request.integrationId;
  }
  if (!Util.isUnset(request.integrationName)) {
    body['IntegrationName'] = request.integrationName;
  }
  if (!Util.isUnset(request.integrationProductType)) {
    body['IntegrationProductType'] = request.integrationProductType;
  }
  if (!Util.isUnset(request.liveness)) {
    body['Liveness'] = request.liveness;
  }
  if (!Util.isUnset(request.recoverTime)) {
    body['RecoverTime'] = request.recoverTime;
  }
  if (!Util.isUnset(request.shortToken)) {
    body['ShortToken'] = request.shortToken;
  }
  if (!Util.isUnset(request.stat)) {
    body['Stat'] = request.stat;
  }
  if (!Util.isUnset(request.state)) {
    body['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIntegration',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateIntegration(request: UpdateIntegrationRequest): UpdateIntegrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIntegrationWithOptions(request, runtime);
}

model UpdatePrometheusAlertRuleRequest {
  alertId?: long(name='AlertId'),
  alertName?: string(name='AlertName'),
  annotations?: string(name='Annotations'),
  clusterId?: string(name='ClusterId'),
  dispatchRuleId?: long(name='DispatchRuleId'),
  duration?: string(name='Duration'),
  expression?: string(name='Expression'),
  labels?: string(name='Labels'),
  message?: string(name='Message'),
  notifyType?: string(name='NotifyType'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
}

model UpdatePrometheusAlertRuleResponseBody = {
  prometheusAlertRule?: {
    alertId?: long(name='AlertId'),
    alertName?: string(name='AlertName'),
    annotations?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Annotations'),
    clusterId?: string(name='ClusterId'),
    dispatchRuleId?: long(name='DispatchRuleId'),
    duration?: string(name='Duration'),
    expression?: string(name='Expression'),
    labels?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Labels'),
    message?: string(name='Message'),
    notifyType?: string(name='NotifyType'),
    status?: int32(name='Status'),
    type?: string(name='Type'),
  }(name='PrometheusAlertRule'),
  requestId?: string(name='RequestId'),
}

model UpdatePrometheusAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePrometheusAlertRuleResponseBody(name='body'),
}

async function updatePrometheusAlertRuleWithOptions(request: UpdatePrometheusAlertRuleRequest, runtime: Util.RuntimeOptions): UpdatePrometheusAlertRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!Util.isUnset(request.alertName)) {
    query['AlertName'] = request.alertName;
  }
  if (!Util.isUnset(request.annotations)) {
    query['Annotations'] = request.annotations;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dispatchRuleId)) {
    query['DispatchRuleId'] = request.dispatchRuleId;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.expression)) {
    query['Expression'] = request.expression;
  }
  if (!Util.isUnset(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  if (!Util.isUnset(request.notifyType)) {
    query['NotifyType'] = request.notifyType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePrometheusAlertRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePrometheusAlertRule(request: UpdatePrometheusAlertRuleRequest): UpdatePrometheusAlertRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePrometheusAlertRuleWithOptions(request, runtime);
}

model UpdateWebhookRequest {
  body?: string(name='Body'),
  contactId?: long(name='ContactId'),
  contactName?: string(name='ContactName'),
  httpHeaders?: string(name='HttpHeaders'),
  httpParams?: string(name='HttpParams'),
  method?: string(name='Method'),
  recoverBody?: string(name='RecoverBody'),
  regionId?: string(name='RegionId'),
  url?: string(name='Url'),
}

model UpdateWebhookResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateWebhookResponseBody(name='body'),
}

async function updateWebhookWithOptions(request: UpdateWebhookRequest, runtime: Util.RuntimeOptions): UpdateWebhookResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.body)) {
    query['Body'] = request.body;
  }
  if (!Util.isUnset(request.contactId)) {
    query['ContactId'] = request.contactId;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.httpHeaders)) {
    query['HttpHeaders'] = request.httpHeaders;
  }
  if (!Util.isUnset(request.httpParams)) {
    query['HttpParams'] = request.httpParams;
  }
  if (!Util.isUnset(request.method)) {
    query['Method'] = request.method;
  }
  if (!Util.isUnset(request.recoverBody)) {
    query['RecoverBody'] = request.recoverBody;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.url)) {
    query['Url'] = request.url;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWebhook',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateWebhook(request: UpdateWebhookRequest): UpdateWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWebhookWithOptions(request, runtime);
}

model UploadRequest {
  edition?: string(name='Edition'),
  file?: string(name='File'),
  fileName?: string(name='FileName'),
  pid?: string(name='Pid'),
  regionId?: string(name='RegionId'),
  version?: string(name='Version'),
}

model UploadResponseBody = {
  requestId?: string(name='RequestId'),
  uploadResult?: {
    fid?: string(name='Fid'),
    fileName?: string(name='FileName'),
    uploadTime?: string(name='UploadTime'),
  }(name='UploadResult'),
}

model UploadResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadResponseBody(name='body'),
}

async function uploadWithOptions(request: UploadRequest, runtime: Util.RuntimeOptions): UploadResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.edition)) {
    query['Edition'] = request.edition;
  }
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.file)) {
    body['File'] = request.file;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'Upload',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upload(request: UploadRequest): UploadResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadWithOptions(request, runtime);
}

