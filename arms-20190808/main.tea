/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'arms.aliyuncs.com',
    cn-beijing-finance-1 = 'arms.aliyuncs.com',
    cn-beijing-finance-pop = 'arms.aliyuncs.com',
    cn-beijing-gov-1 = 'arms.aliyuncs.com',
    cn-beijing-nu16-b01 = 'arms.aliyuncs.com',
    cn-edge-1 = 'arms.aliyuncs.com',
    cn-fujian = 'arms.aliyuncs.com',
    cn-haidian-cm12-c01 = 'arms.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'arms.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'arms.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'arms.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'arms.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'arms.aliyuncs.com',
    cn-hangzhou-test-306 = 'arms.aliyuncs.com',
    cn-hongkong-finance-pop = 'arms.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'arms.aliyuncs.com',
    cn-qingdao-nebula = 'arms.aliyuncs.com',
    cn-shanghai-et15-b01 = 'arms.aliyuncs.com',
    cn-shanghai-et2-b01 = 'arms.aliyuncs.com',
    cn-shanghai-inner = 'arms.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'arms.aliyuncs.com',
    cn-shenzhen-inner = 'arms.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'arms.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'arms.aliyuncs.com',
    cn-wuhan = 'arms.aliyuncs.com',
    cn-yushanfang = 'arms.aliyuncs.com',
    cn-zhangbei = 'arms.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'arms.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'arms.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'arms.aliyuncs.com',
    eu-west-1-oxs = 'arms.aliyuncs.com',
    me-east-1 = 'arms.aliyuncs.com',
    rus-west-1-pop = 'arms.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('arms', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CallChainInfo {
  additionalInfo?: string(name='AdditionalInfo'),
  appName?: string(name='AppName'),
  appType?: string(name='AppType'),
  children?: [
    CallChainInfo
  ](name='Children'),
  haveSpan?: boolean(name='HaveSpan'),
  logMap?: map[string]object(name='LogMap'),
  logTime?: long(name='LogTime'),
  parentSpanId?: string(name='ParentSpanId'),
  pid?: string(name='Pid'),
  regionId?: string(name='RegionId'),
  resultCode?: string(name='ResultCode'),
  rpc?: string(name='Rpc'),
  rpcId?: string(name='RpcId'),
  rpcType?: long(name='RpcType'),
  serverIp?: string(name='ServerIp'),
  span?: long(name='Span'),
  spanId?: string(name='SpanId'),
  tagMap?: map[string]string(name='TagMap'),
  traceId?: string(name='TraceId'),
}

model AddAliClusterIdsToPrometheusGlobalViewRequest {
  clusterIds?: string(name='ClusterIds', description='The list of cluster IDs. You can specify multiple cluster IDs and separate them with commas (,).', example='cd1d55bef19904324a20ed0ebb86caa5c,c5b48729918ab4745a24482ac29d0973a, c00a94896641449098bf24931e4166003, cd174485c09384060ba542bc1be1185a4'),
  globalViewClusterId?: string(name='GlobalViewClusterId', description='The ID of the aggregation instance.', example='global-v2-cn-1478326682034601-vss8pd0i'),
  groupName?: string(name='GroupName', description='The name of the aggregation instance.', example='zyGlobalView'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model AddAliClusterIdsToPrometheusGlobalViewResponseBody = {
  data?: {
    info?: string(name='Info', description='The Info-level information.', example='{regionId: the region where the aggregation instance resides. globalViewClusterId: the ID of the aggregation instance. failedClusterIds: the ID of the cluster that failed to be added. A cluster may fail to be added because the specified cluster ID is invalid or the cluster is added across continents.}'),
    msg?: string(name='Msg', description='The additional information.', example='OK'),
    success?: boolean(name='Success', description='Indicates whether the data sources are added.

*   `true`: yes
*   `false`: no', example='true'),
  }(name='Data', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request. You can use the ID to query logs and troubleshoot issues.', example='F7781D4A-2818-41E7-B7BB-79D809E9****'),
}

model AddAliClusterIdsToPrometheusGlobalViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddAliClusterIdsToPrometheusGlobalViewResponseBody(name='body'),
}

async function addAliClusterIdsToPrometheusGlobalViewWithOptions(request: AddAliClusterIdsToPrometheusGlobalViewRequest, runtime: Util.RuntimeOptions): AddAliClusterIdsToPrometheusGlobalViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterIds)) {
    query['ClusterIds'] = request.clusterIds;
  }
  if (!Util.isUnset(request.globalViewClusterId)) {
    query['GlobalViewClusterId'] = request.globalViewClusterId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddAliClusterIdsToPrometheusGlobalView',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addAliClusterIdsToPrometheusGlobalView(request: AddAliClusterIdsToPrometheusGlobalViewRequest): AddAliClusterIdsToPrometheusGlobalViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAliClusterIdsToPrometheusGlobalViewWithOptions(request, runtime);
}

model AddGrafanaRequest {
  clusterId?: string(name='ClusterId', description='The ID of a Container Service for Kubernetes cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  integration?: string(name='Integration', description='The software abbreviation that is supported by ARMS. Valid values (case-insensitive): `ASM`, `IoT`, and `Flink`.', example='asm'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model AddGrafanaResponseBody = {
  data?: string(name='Data', description='Indicates whether the integration was successful.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1A9C645C-C83F-4C9D-8CCB-29BEC9E1****'),
}

model AddGrafanaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGrafanaResponseBody(name='body'),
}

async function addGrafanaWithOptions(request: AddGrafanaRequest, runtime: Util.RuntimeOptions): AddGrafanaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.integration)) {
    query['Integration'] = request.integration;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGrafana',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGrafana(request: AddGrafanaRequest): AddGrafanaResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGrafanaWithOptions(request, runtime);
}

model AddIntegrationRequest {
  clusterId?: string(name='ClusterId', description='The ID of an Alibaba Cloud Container Service for Kubernetes cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  integration?: string(name='Integration', description='The software abbreviation that is supported by ARMS. Valid values (case-insensitive): `ASM`, `IoT`, and `Flink`.', example='asm'),
  regionId?: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou'),
}

model AddIntegrationResponseBody = {
  data?: string(name='Data', description='Indicates whether the integration was successful.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1A9C645C-C83F-4C9D-8CCB-29BEC9E1****'),
}

model AddIntegrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddIntegrationResponseBody(name='body'),
}

async function addIntegrationWithOptions(request: AddIntegrationRequest, runtime: Util.RuntimeOptions): AddIntegrationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.integration)) {
    query['Integration'] = request.integration;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddIntegration',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addIntegration(request: AddIntegrationRequest): AddIntegrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return addIntegrationWithOptions(request, runtime);
}

model AddPrometheusGlobalViewRequest {
  clusters?: string(name='Clusters'),
  groupName?: string(name='GroupName', example='zyGlobalView'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model AddPrometheusGlobalViewResponseBody = {
  data?: {
    info?: {
      failedInstances?: string(name='FailedInstances'),
      globalViewClusterId?: string(name='GlobalViewClusterId'),
      regionId?: string(name='RegionId'),
    }(name='Info'),
    msg?: string(name='Msg', example='OK'),
    success?: boolean(name='Success', example='true'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='34ED024E-9E31-434A-9E4E-D9D15C3****'),
}

model AddPrometheusGlobalViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddPrometheusGlobalViewResponseBody(name='body'),
}

async function addPrometheusGlobalViewWithOptions(request: AddPrometheusGlobalViewRequest, runtime: Util.RuntimeOptions): AddPrometheusGlobalViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusters)) {
    query['Clusters'] = request.clusters;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddPrometheusGlobalView',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addPrometheusGlobalView(request: AddPrometheusGlobalViewRequest): AddPrometheusGlobalViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPrometheusGlobalViewWithOptions(request, runtime);
}

model AddPrometheusGlobalViewByAliClusterIdsRequest {
  clusterIds?: string(name='ClusterIds', description='The list of cluster IDs. You can specify multiple cluster IDs and separate them with commas (,).', example='cd1d55bef19904324a20ed0ebb86caa5c,c5b48729918ab4745a24482ac29d0973a, c00a94896641449098bf24931e4166003, cd174485c09384060ba542bc1be1185a4'),
  groupName?: string(name='GroupName', description='The name of the aggregation instance.', example='zyGlobalView'),
  productCode?: string(name='ProductCode', description='The identifier to identify the service if custom dashboards are created for the specified clusters.', example='adcp'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model AddPrometheusGlobalViewByAliClusterIdsResponseBody = {
  data?: {
    info?: string(name='Info', description='The Info-level information.', example='{regionId: the region where the aggregation instance resides. globalViewClusterId: the ID of the aggregation instance. failedClusterIds: the ID of the cluster that failed to be added. A cluster may fail to be added because the specified cluster ID is invalid or the cluster is added across continents.}'),
    msg?: string(name='Msg', description='The additional information.', example='success'),
    success?: boolean(name='Success', description='Indicates whether the call was successful. Valid values:

*   `true`: The call was successful.
*   `false`: The call failed.', example='true'),
  }(name='Data', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request. You can query logs and troubleshoot issues based on the ID.', example='3A0EA2AF-C9B3-555C-B9D5-5DD8F5EF98A9'),
}

model AddPrometheusGlobalViewByAliClusterIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddPrometheusGlobalViewByAliClusterIdsResponseBody(name='body'),
}

async function addPrometheusGlobalViewByAliClusterIdsWithOptions(request: AddPrometheusGlobalViewByAliClusterIdsRequest, runtime: Util.RuntimeOptions): AddPrometheusGlobalViewByAliClusterIdsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterIds)) {
    query['ClusterIds'] = request.clusterIds;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddPrometheusGlobalViewByAliClusterIds',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addPrometheusGlobalViewByAliClusterIds(request: AddPrometheusGlobalViewByAliClusterIdsRequest): AddPrometheusGlobalViewByAliClusterIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPrometheusGlobalViewByAliClusterIdsWithOptions(request, runtime);
}

model AddPrometheusInstanceRequest {
  name?: string(name='Name', description='The name of the Prometheus instance for Remote Write.', example='notificationpolicy_test'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  type?: string(name='Type', description='The type of the Prometheus instance. Only the Prometheus for Remote Write type is supported. Set the value to RW.', example='RW'),
}

model AddPrometheusInstanceResponseBody = {
  data?: string(name='Data', description='The struct returned.', example='{
  "RequestId": "1293091C-54AD-50FE-B787-E314B94B35AB",
  "Data": "{
  "clusterType":"remote-write-prometheus",
  "remoteWriteUrl":"http://cn-hu/api/v3/write",
  "internetGrafanaUrl":"https://cn-hanga/cn-hangzhou",
  "authToken":false,
  "internetPushGatewayUrl":"https://cangzhou/api/v2",
  "clusterId":"vrju1lj3sa|123456",
  "internetRemoteReadUrl":"https://cn-hangzh67cn-hangzhou/api/v1/read",
  "remoteReadUrl":"http://cn-hanou/api/v1/read",
  "grafanaUrl":"http://cn-angzhou",
  "pushGatewayUrl":"htt1lj3sa/cn-hangzhou/api/v2",
  "internetRemoteWriteUrl":"httpsngzhou/api/v3/write"}"
}'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9319A57D-2D9E-472A-B69B-CF3CD16D****'),
}

model AddPrometheusInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddPrometheusInstanceResponseBody(name='body'),
}

async function addPrometheusInstanceWithOptions(request: AddPrometheusInstanceRequest, runtime: Util.RuntimeOptions): AddPrometheusInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddPrometheusInstance',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addPrometheusInstance(request: AddPrometheusInstanceRequest): AddPrometheusInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPrometheusInstanceWithOptions(request, runtime);
}

model AddPrometheusRemoteWriteRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  remoteWriteYaml?: string(name='RemoteWriteYaml', example='remote_write:
  - name: rw1
    url: "http://cn-hangzhou-intranet.arms.aliyuncs.com/prometheus/uid/xx/cn-hangzhou/api/v3/write"
    basic_auth:
      username: xxx
      password: xxx
    write_relabel_configs:
      - source_labels: [ instance_id ]
        separator: ;
        regex: si
        replacement: $1
        action: keep
  - name: rw2
    url: "http://cn-hangzhou-intranet.arms.aliyuncs.com/prometheus/uid/xx/cn-hangzhou/api/v3/write"
    basic_auth:
      username: xxx
      password: xxx
    write_relabel_configs:
      - source_labels: [ xx ]
        separator: ;
        regex: yyy
        replacement: $1
        action: keep'),
}

model AddPrometheusRemoteWriteResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddPrometheusRemoteWriteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddPrometheusRemoteWriteResponseBody(name='body'),
}

async function addPrometheusRemoteWriteWithOptions(request: AddPrometheusRemoteWriteRequest, runtime: Util.RuntimeOptions): AddPrometheusRemoteWriteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.remoteWriteYaml)) {
    body['RemoteWriteYaml'] = request.remoteWriteYaml;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddPrometheusRemoteWrite',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addPrometheusRemoteWrite(request: AddPrometheusRemoteWriteRequest): AddPrometheusRemoteWriteResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPrometheusRemoteWriteWithOptions(request, runtime);
}

model AddRecordingRuleRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  ruleYaml?: string(name='RuleYaml', description='The recording rule.', example='groups: - name: "recording_demo"   rules:   - expr: "sum(jvm_memory_max_bytes)"     record: "rate_coredns_demo"'),
}

model AddRecordingRuleResponseBody = {
  data?: string(name='Data', description='The status of the response.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9FEA6D00-317F-45E3-9004-7FB8B0B7****'),
}

model AddRecordingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddRecordingRuleResponseBody(name='body'),
}

async function addRecordingRuleWithOptions(request: AddRecordingRuleRequest, runtime: Util.RuntimeOptions): AddRecordingRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.ruleYaml)) {
    query['RuleYaml'] = request.ruleYaml;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddRecordingRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addRecordingRule(request: AddRecordingRuleRequest): AddRecordingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addRecordingRuleWithOptions(request, runtime);
}

model AppendInstancesToPrometheusGlobalViewRequest {
  clusters?: string(name='Clusters'),
  globalViewClusterId?: string(name='GlobalViewClusterId', example='global-v2-cn-1670100631025794-6gjc0qgb'),
  groupName?: string(name='GroupName', example='zyGlobalView'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model AppendInstancesToPrometheusGlobalViewResponseBody = {
  data?: {
    info?: string(name='Info'),
    msg?: string(name='Msg', example='OK'),
    success?: boolean(name='Success', example='True'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='27E653FA-5958-45BE-8AA9-14D884DC****'),
}

model AppendInstancesToPrometheusGlobalViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AppendInstancesToPrometheusGlobalViewResponseBody(name='body'),
}

async function appendInstancesToPrometheusGlobalViewWithOptions(request: AppendInstancesToPrometheusGlobalViewRequest, runtime: Util.RuntimeOptions): AppendInstancesToPrometheusGlobalViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusters)) {
    query['Clusters'] = request.clusters;
  }
  if (!Util.isUnset(request.globalViewClusterId)) {
    query['GlobalViewClusterId'] = request.globalViewClusterId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AppendInstancesToPrometheusGlobalView',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function appendInstancesToPrometheusGlobalView(request: AppendInstancesToPrometheusGlobalViewRequest): AppendInstancesToPrometheusGlobalViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return appendInstancesToPrometheusGlobalViewWithOptions(request, runtime);
}

model ApplyScenarioRequest {
  appId?: string(name='AppId', description='The ID of the application.', example='b590lhguqs@28f515462f******'),
  config?: map[string]any(name='Config', description='The configuration of the business monitoring job. The value is a JSON string. For more information about this parameter, see the following additional information about the **Config** parameter.', example='{"rpcType":"0","nameMatchType":"EQUALS","service":"/api/pop/test","operator":"and","filterItems":[{"type":"HttpHeaders","key":"uid","opt":"==","value":"123456789"}],"group":{"type":"HttpRequestParameters","key":"name"}}'),
  name?: string(name='Name', description='The name of the business monitoring job.'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-zhangjaikou'),
  scenario?: string(name='Scenario', description='The scenario where you want to use the business monitoring job. Valid values:

*   `USER-DEFINED`: user-defined. This is the default value.
*   `EDAS-ROLLOUT`: application release in Enterprise Distributed Application Service (EDAS)
*   `OAM-ROLLOUT`: application release based on Open Application Model (OAM)
*   `MSC-CANARY`: canary release based on Microservice Engine (MSE)', example='USER-DEFINED'),
  sign?: string(name='Sign', description='The code of the business monitoring job. This parameter is not required when you create a business monitoring job. However, this parameter is required when you update a business monitoring job.', example='a9f8****'),
  snDump?: boolean(name='SnDump', description='Specifies whether to record business parameters to the trace marked with the coloring sign.

*   `true`
*   `false`: This is the default value.', example='false'),
  snForce?: boolean(name='SnForce', description='Specifies whether traffic in the trace marked with the coloring sign is all collected.

*   `true`
*   `false`: This is the default value.', example='false'),
  snStat?: boolean(name='SnStat', description='Specifies whether to count traffic based on the coloring sign.

*   `true`
*   `false`: This is the default value.', example='false'),
  snTransfer?: boolean(name='SnTransfer', description='Specifies whether the coloring sign is transparently passed down to downstream application nodes in the trace.

*   `true`
*   `false`: This is the default value.', example='false'),
  updateOption?: boolean(name='UpdateOption', description='Specifies whether the operation is an update operation.

*   `true`: update
*   `false`: insert', example='false'),
}

model ApplyScenarioShrinkRequest {
  appId?: string(name='AppId', description='The ID of the application.', example='b590lhguqs@28f515462f******'),
  configShrink?: string(name='Config', description='The configuration of the business monitoring job. The value is a JSON string. For more information about this parameter, see the following additional information about the **Config** parameter.', example='{"rpcType":"0","nameMatchType":"EQUALS","service":"/api/pop/test","operator":"and","filterItems":[{"type":"HttpHeaders","key":"uid","opt":"==","value":"123456789"}],"group":{"type":"HttpRequestParameters","key":"name"}}'),
  name?: string(name='Name', description='The name of the business monitoring job.'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-zhangjaikou'),
  scenario?: string(name='Scenario', description='The scenario where you want to use the business monitoring job. Valid values:

*   `USER-DEFINED`: user-defined. This is the default value.
*   `EDAS-ROLLOUT`: application release in Enterprise Distributed Application Service (EDAS)
*   `OAM-ROLLOUT`: application release based on Open Application Model (OAM)
*   `MSC-CANARY`: canary release based on Microservice Engine (MSE)', example='USER-DEFINED'),
  sign?: string(name='Sign', description='The code of the business monitoring job. This parameter is not required when you create a business monitoring job. However, this parameter is required when you update a business monitoring job.', example='a9f8****'),
  snDump?: boolean(name='SnDump', description='Specifies whether to record business parameters to the trace marked with the coloring sign.

*   `true`
*   `false`: This is the default value.', example='false'),
  snForce?: boolean(name='SnForce', description='Specifies whether traffic in the trace marked with the coloring sign is all collected.

*   `true`
*   `false`: This is the default value.', example='false'),
  snStat?: boolean(name='SnStat', description='Specifies whether to count traffic based on the coloring sign.

*   `true`
*   `false`: This is the default value.', example='false'),
  snTransfer?: boolean(name='SnTransfer', description='Specifies whether the coloring sign is transparently passed down to downstream application nodes in the trace.

*   `true`
*   `false`: This is the default value.', example='false'),
  updateOption?: boolean(name='UpdateOption', description='Specifies whether the operation is an update operation.

*   `true`: update
*   `false`: insert', example='false'),
}

model ApplyScenarioResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='EA24D522-AD35-47B8-8CB2-ADBC38******'),
  result?: string(name='Result', description='The code of the business monitoring job, which is the coloring sign.', example='2b97****'),
}

model ApplyScenarioResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyScenarioResponseBody(name='body'),
}

async function applyScenarioWithOptions(tmpReq: ApplyScenarioRequest, runtime: Util.RuntimeOptions): ApplyScenarioResponse {
  Util.validateModel(tmpReq);
  var request = new ApplyScenarioShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.config)) {
    request.configShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.config, 'Config', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.configShrink)) {
    query['Config'] = request.configShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.scenario)) {
    query['Scenario'] = request.scenario;
  }
  if (!Util.isUnset(request.sign)) {
    query['Sign'] = request.sign;
  }
  if (!Util.isUnset(request.snDump)) {
    query['SnDump'] = request.snDump;
  }
  if (!Util.isUnset(request.snForce)) {
    query['SnForce'] = request.snForce;
  }
  if (!Util.isUnset(request.snStat)) {
    query['SnStat'] = request.snStat;
  }
  if (!Util.isUnset(request.snTransfer)) {
    query['SnTransfer'] = request.snTransfer;
  }
  if (!Util.isUnset(request.updateOption)) {
    query['UpdateOption'] = request.updateOption;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyScenario',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyScenario(request: ApplyScenarioRequest): ApplyScenarioResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyScenarioWithOptions(request, runtime);
}

model ChangeResourceGroupRequest {
  newResourceGroupId?: string(name='NewResourceGroupId', example='rg-aek2vezarezgoki'),
  regionId?: string(name='RegionId'),
  resourceId?: string(name='ResourceId', example='ggxw4lnjuz@cfd34a78ff2abff'),
  resourceType?: string(name='ResourceType', example='APPLICATION'),
}

model ChangeResourceGroupResponseBody = {
  data?: {
    resourceGroupId?: string(name='ResourceGroupId'),
    resourceId?: string(name='ResourceId'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request', example='46355DD8-FC56-40C5-BFC6-269DE4F9****'),
}

model ChangeResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeResourceGroupResponseBody(name='body'),
}

async function changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, runtime: Util.RuntimeOptions): ChangeResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeResourceGroup',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeResourceGroupWithOptions(request, runtime);
}

model CheckServiceStatusRequest {
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-beijing'),
  svcCode?: string(name='SvcCode', description='The service code of an Alibaba Cloud service. The service code of Prometheus Service is prometheus.', example='prometheus'),
}

model CheckServiceStatusResponseBody = {
  data?: string(name='Data', description='Indicates whether the request was successful.

*   true: The request was successful.
*   false: The request failed.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request. You can query logs and troubleshoot issues based on the ID.', example='5710C923-AD09-4293-9E11-DCBE3D15F8D4'),
}

model CheckServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckServiceStatusResponseBody(name='body'),
}

async function checkServiceStatusWithOptions(request: CheckServiceStatusRequest, runtime: Util.RuntimeOptions): CheckServiceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.svcCode)) {
    query['SvcCode'] = request.svcCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckServiceStatus',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkServiceStatus(request: CheckServiceStatusRequest): CheckServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkServiceStatusWithOptions(request, runtime);
}

model ConfigAppRequest {
  appIds?: string(name='AppIds', description='The process identifier (PID) of the application. Separate multiple PIDs with commas (,).', example='iioe7jcnuk@582846f37******,atc889zkcf@d8deedfa9bf******'),
  enable?: string(name='Enable', description='Specifies whether to turns on or off the main switch of the agent. The monitoring stops after the switch is turned off. If you do not specify this parameter, the main switch status of the agent is queried.  

- `true`: Turn on the switch.
- `false`: Turn off the switch.', example='true'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  type?: string(name='Type'),
}

model ConfigAppResponseBody = {
  data?: string(name='Data', description='The result of turning on or turning off the main switch of the ARMS agent or the main switch status of the ARMS agent.', example='abc@def success\\nghi@jkl success\\n'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='16AF921B-8187-489F-9913-43C808B4****'),
}

model ConfigAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfigAppResponseBody(name='body'),
}

/**
  * ****
  *
  * @param request ConfigAppRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ConfigAppResponse
 */
async function configAppWithOptions(request: ConfigAppRequest, runtime: Util.RuntimeOptions): ConfigAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appIds)) {
    query['AppIds'] = request.appIds;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfigApp',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ****
  *
  * @param request ConfigAppRequest
  * @return ConfigAppResponse
 */
async function configApp(request: ConfigAppRequest): ConfigAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return configAppWithOptions(request, runtime);
}

model CreateAlertContactRequest {
  contactName?: string(name='ContactName', description='The name of the alert contact.', example='JohnDoe'),
  dingRobotWebhookUrl?: string(name='DingRobotWebhookUrl', description='The webhook URL of the DingTalk chatbot. For more information about how to obtain the URL, see [Configure a DingTalk chatbot to send alert notifications](https://www.alibabacloud.com/help/zh/doc-detail/106247.htm). You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.

>  Enter `alert` in the custom keyword field of DingTalk chatbot security settings.', example='https://oapi.dingtalk.com/robot/send?access_token=91f2f6****'),
  email?: string(name='Email', description='The email address of the alert contact. You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.', example='someone@example.com'),
  phoneNum?: string(name='PhoneNum', description='The mobile number of the alert contact. You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.', example='1381111****'),
  regionId?: string(name='RegionId', description='The ID of the region. Set the value to `cn-hangzhou`.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId'),
  systemNoc?: boolean(name='SystemNoc', description='Specifies whether the alert contact receives system notifications. Valid values:

*   `true`: receives system notifications.
*   `false`: does not receive system notifications.', example='true'),
}

model CreateAlertContactResponseBody = {
  contactId?: string(name='ContactId', description='The ID of the alert contact.', example='102**'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E9C9DA3D-10FE-472E-9EEF-2D0A3E41****'),
}

model CreateAlertContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAlertContactResponseBody(name='body'),
}

/**
  * ****
  *
  * @param request CreateAlertContactRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateAlertContactResponse
 */
async function createAlertContactWithOptions(request: CreateAlertContactRequest, runtime: Util.RuntimeOptions): CreateAlertContactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.dingRobotWebhookUrl)) {
    query['DingRobotWebhookUrl'] = request.dingRobotWebhookUrl;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.phoneNum)) {
    query['PhoneNum'] = request.phoneNum;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.systemNoc)) {
    query['SystemNoc'] = request.systemNoc;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlertContact',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ****
  *
  * @param request CreateAlertContactRequest
  * @return CreateAlertContactResponse
 */
async function createAlertContact(request: CreateAlertContactRequest): CreateAlertContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAlertContactWithOptions(request, runtime);
}

model CreateAlertContactGroupRequest {
  contactGroupName?: string(name='ContactGroupName', description='The name of the alert contact group.', example='TestGroup'),
  contactIds?: string(name='ContactIds', description='The IDs of contacts in the contact group. Separate multiple contact IDs with spaces. You can call the SearchAlertContact operation to query the contact IDs. For more information, see [SearchAlertContact](~~130703~~).', example='12* 23* 34*'),
  regionId?: string(name='RegionId', description='The ID of the region. Default value: `cn-hangzhou`.', example='cn-hangzhou'),
}

model CreateAlertContactGroupResponseBody = {
  contactGroupId?: string(name='ContactGroupId', description='The ID of the alert contact group.', example='446*'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='70675725-8F11-4817-8106-CFE0AD71****'),
}

model CreateAlertContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAlertContactGroupResponseBody(name='body'),
}

/**
  * ************
  *
  * @param request CreateAlertContactGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateAlertContactGroupResponse
 */
async function createAlertContactGroupWithOptions(request: CreateAlertContactGroupRequest, runtime: Util.RuntimeOptions): CreateAlertContactGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupName)) {
    query['ContactGroupName'] = request.contactGroupName;
  }
  if (!Util.isUnset(request.contactIds)) {
    query['ContactIds'] = request.contactIds;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlertContactGroup',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ************
  *
  * @param request CreateAlertContactGroupRequest
  * @return CreateAlertContactGroupResponse
 */
async function createAlertContactGroup(request: CreateAlertContactGroupRequest): CreateAlertContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAlertContactGroupWithOptions(request, runtime);
}

model CreateDispatchRuleRequest {
  dispatchRule?: string(name='DispatchRule', description='The dispatch rule configuration. The value is a JSON string. For more information about this parameter, see the following **additional information about the DispatchRule parameter**.', example='{   "system": false,   "ruleid": 10282,   "name": "Prometheus Alert",   "labelMatchExpressionGrid": {     "labelMatchExpressionGroups": [       {         "labelMatchExpressions": [           {             "key": "_aliyun_arms_involvedObject_kind",             "value": "app",             "operator": "eq"           }         ]       }     ]   },   "dispatchType": "CREATE_ALERT/DISCARD_ALERT",   "isRecover": true,   "groupRules": [     {       "groupId": 1,       "groupingFields": [         "alertname"       ],       "groupWait": 10,       "groupInterval": 15,       "repeatInterval": 20     }   ],   "notifyRules": [     {       "notifyObjects": [         {           "notifyType": "ARMS_CONTACT",           "name": "JohnDoe",           "notifyObjectId": 1         },         {           "notifyType": "ARMS_CONTACT_GROUP",           "name": "JohnDoe_group",           "notifyObjectId": 2         }       ],       "notifyChannels":["dingTalk","wechat","webhook","email"]     },   ], }'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model CreateDispatchRuleResponseBody = {
  dispatchRuleId?: long(name='DispatchRuleId', description='The ID of the dispatch policy.', example='10413'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A5EC8221-08F2-4C95-9AF1-49FD998C****'),
}

model CreateDispatchRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDispatchRuleResponseBody(name='body'),
}

async function createDispatchRuleWithOptions(request: CreateDispatchRuleRequest, runtime: Util.RuntimeOptions): CreateDispatchRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dispatchRule)) {
    query['DispatchRule'] = request.dispatchRule;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDispatchRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDispatchRule(request: CreateDispatchRuleRequest): CreateDispatchRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDispatchRuleWithOptions(request, runtime);
}

model CreateIntegrationRequest {
  autoRecover?: boolean(name='AutoRecover', description='Specifies whether to automatically clear alert events. Valid values:

*   true (default)
*   false', example='true'),
  description?: string(name='Description', description='The description of the alert integration.', example='Test'),
  integrationName?: string(name='IntegrationName', description='The name of the alert integration.', example='CloudMonitor integration'),
  integrationProductType?: string(name='IntegrationProductType', description='The service of the alert integration. Valid values:

*   CLOUD_MONITOR: CloudMonitor
*   LOG_SERVICE: Log Service', example='CLOUD_MONITOR'),
  recoverTime?: long(name='RecoverTime', description='The time when alert events are automatically cleared. Unit: seconds. Default value: 300.', example='300'),
}

model CreateIntegrationResponseBody = {
  integration?: {
    autoRecover?: boolean(name='AutoRecover', description='Indicates whether alert events are automatically cleared. Valid values:

*   true (default)
*   false', example='true'),
    description?: string(name='Description', description='The description of the alert integration.', example='Test'),
    integrationId?: long(name='IntegrationId', description='The ID of the alert integration.', example='1234'),
    integrationName?: string(name='IntegrationName', description='The name of the alert integration.', example='CloudMonitor integration'),
    integrationProductType?: string(name='IntegrationProductType', description='The service of the alert integration. Valid values:

*   CLOUD_MONITOR: CloudMonitor
*   LOG_SERVICE: Log Service', example='CLOUD_MONITOR'),
    recoverTime?: long(name='RecoverTime', description='The time when alert events are automatically cleared. Unit: seconds. Default value: 300.', example='300'),
  }(name='Integration', description='The returned information about the alert integration.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='34ED024E-9E31-434A-9E4E-D9D15C3****'),
}

model CreateIntegrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIntegrationResponseBody(name='body'),
}

async function createIntegrationWithOptions(request: CreateIntegrationRequest, runtime: Util.RuntimeOptions): CreateIntegrationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoRecover)) {
    body['AutoRecover'] = request.autoRecover;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.integrationName)) {
    body['IntegrationName'] = request.integrationName;
  }
  if (!Util.isUnset(request.integrationProductType)) {
    body['IntegrationProductType'] = request.integrationProductType;
  }
  if (!Util.isUnset(request.recoverTime)) {
    body['RecoverTime'] = request.recoverTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIntegration',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIntegration(request: CreateIntegrationRequest): CreateIntegrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIntegrationWithOptions(request, runtime);
}

model CreateOrUpdateAlertRuleRequest {
  alertCheckType?: string(name='AlertCheckType', description='The alert check type of the Prometheus alert rule.

*   STATIC: a static threshold value. If you set the parameter to STATIC, you must specify the **MetricsKey** parameter. For more information, see the **Correspondence between AlertGroup and MetricsKey for Prometheus Service** table.
*   CUSTOM: a custom PromQL statement. If you set the parameter to CUSTOM, you must specify the **PromQL**, **Duration**, and **Message** parameters to create a Prometheus alert rule.', example='STATIC'),
  alertGroup?: long(name='AlertGroup', description='The alert contact group ID of the Prometheus alert rule.

*   \\-1: custom PromQL
*   1: Kubernetes load
*   15: Kubernetes node', example='-1'),
  alertId?: long(name='AlertId', description='The ID of the alert rule.

*   If you do not specify this parameter, a new alert rule is created.
*   If you specify this parameter, the specified alert rule is modified.', example='546xxx'),
  alertName?: string(name='AlertName', description='The name of the alert rule.', example='Alert Rule Demo'),
  alertRuleContent?: string(name='AlertRuleContent', description='The content of the Application Monitoring or Browser Monitoring alert rule. The following code provides an example of the **AlertRuleContent** parameter. For more information about the meaning of each field, see the supplementary description.

`{ "Condition": "OR", "AlertRuleItems": [ { "Operator": "CURRENT_LTE", "MetricKey": "appstat.jvm.threadcount", "Value": 1000, "Aggregate": "AVG", "N": 1 } ] }`

>  The conditional fields vary depending on the values of the **MetricsType** and **AlertRuleItems.MetricKey** parameters. For more information about the types of metrics supported by Application Monitoring and Browser Monitoring and the alert rule fields corresponding to each metric, see the supplementary description.', example='{ "Condition": "OR", "AlertRuleItems": [ { "Operator": "CURRENT_LTE",  "MetricKey": "appstat.jvm.threadcount",  "Value": 1000,  "Aggregate": "AVG",   "N": 1  }  ]  }'),
  alertStatus?: string(name='AlertStatus', description='The status of the alert rule.

*   RUNNING (default)
*   STOPPED', example='RUNNING'),
  alertType?: string(name='AlertType', description='The type of the alert rule. Valid values:

*   APPLICATION_MONITORING_ALERT_RULE: alert rule for Application Monitoring
*   BROWSER_MONITORING_ALERT_RULE: alert rule for Browser Monitoring
*   PROMETHEUS_MONITORING_ALERT_RULE: alert rule for Prometheus Service', example='APPLICATION_MONITORING_ALERT_RULE'),
  annotations?: string(name='Annotations', description='The annotations of the Prometheus alert rule.'),
  autoAddNewApplication?: boolean(name='AutoAddNewApplication', description='Specifies whether to apply the alert rule to new applications that are created in Application Monitoring or Browser Monitoring.

*   `true`: yes
*   `false`: no', example='false'),
  clusterId?: string(name='ClusterId', description='The cluster ID of the Prometheus alert rule.', example='ceba9b9ea5b924dd0b6726d2de6******'),
  duration?: long(name='Duration', description='The duration of the Prometheus alert rule. Unit: minutes.', example='1'),
  filters?: string(name='Filters', description='The filter conditions of the Application Monitoring or Browser Monitoring alert rule.

Format:

```

"DimFilters": [ 
{ 
 "FilterOpt": "ALL",
 "FilterValues": [],         //The value of the filter condition. 
 "FilterKey": "rootIp"     //The Key of the filter condition. 
}
]
                                
```

Valid values of **FilterOpt**:

*   STATIC: matches the value of the specified dimension.
*   ALL: matches the values of all dimensions.
*   DISABLE: aggregates the values of all dimensions.', example='{"DimFilters": [             {               "FilterOpt": "ALL",               "FilterValues": [],               "FilterKey": "rootIp"             }           ]         }'),
  labels?: string(name='Labels', description='The tags of the Prometheus alert rule.', example='[  {  Value": "cms_polardb",             "Name": "_aliyun_cloud_product"           }         ]'),
  level?: string(name='Level', description='The level of the Prometheus alert rule.

*   P1: Alert notifications are sent for major issues that affect the availability of core business, have huge impact, and may lead to serious consequences.
*   P2: Alert notifications are sent for service errors that affect the system availability with relatively limited impact.
*   P3: Alert notifications are sent for issues that may cause service errors or negative effects, or alert notifications for services that are relatively less important.
*   P4: Alert notifications are sent for low-priority issues that do not affect your business.
*   Default: Alert notifications are sent without distinguishing between alert levels.', example='P2'),
  message?: string(name='Message', description='The alert message of the Prometheus alert rule.'),
  metricsKey?: string(name='MetricsKey', description='The alert metrics. If you set the **AlertCheckType** parameter to **STATIC** when you create a Prometheus alert rule, you must specify the **MetricsKey** parameter.

>  Alert metrics vary depending on the value of the **AlertGroup** parameter. For more information about the correspondence between **AlertGroup** and **MetricsKey**, see the supplementary description.', example='pop.status.error'),
  metricsType?: string(name='MetricsType', description='The metric type of the Application Monitoring or Browser Monitoring alert rule. For more information, see the following tables.', example='jvm'),
  notifyStrategy?: string(name='NotifyStrategy', description='The notification policy.

*   If you set this parameter to null, no notification policy is specified. After you create an alert rule, you can create a notification policy and specify match rules and match conditions. For example, you can specify an alert rule name as the match condition. When the alert rule is triggered, an alert event is generated and an alert notification is sent to the contacts or contact groups that are specified in the notification policy.
*   To specify a notification policy, set this parameter to the ID of the notification policy. Application Real-Time Monitoring Service (ARMS) automatically adds a match rule to the notification policy and specifies the ID of the alert rule as the match condition. The name of the alert rule is also displayed. This way, the alert events that are generated based on the alert rule can be matched by the specified notification policy.', example='569xxx'),
  pids?: string(name='Pids', description='The process ID (PID) that is associated with the Application Monitoring or Browser Monitoring alert rule.', example='["b590lhguqs@40d8deedfa9******"]'),
  promQL?: string(name='PromQL', description='The PromQL statement of the Prometheus alert rule.', example='node_memory_MemAvailable_bytes{} / node_memory_MemTotal_bytes{} * 100'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model CreateOrUpdateAlertRuleResponseBody = {
  alertRule?: {
    alertCheckType?: string(name='AlertCheckType', description='The alert check type of the Prometheus alert rule. 

- STATIC: a static threshold value.
- CUSTOM: a custom PromQL statement.', example='STATIC'),
    alertGroup?: long(name='AlertGroup', description='The alert contact group ID of the Prometheus alert rule. 

- -1: custom PromQL
- 1: Kubernetes load
- 15: Kubernetes node', example='-1'),
    alertId?: float(name='AlertId', description='The ID of the alert rule.', example='5510445'),
    alertName?: string(name='AlertName', description='The name of the alert rule.', example='arms-test'),
    alertRuleContent?: {
      alertRuleItems?: [ 
        {
          aggregate?: string(name='Aggregate', description='The aggregation method of the alert condition.

*   AVG: calculates the average value
*   SUM: calculates the total value
*   MAX: selects the maximum value
*   MIN: selects the minimum value', example='AVG'),
          metricKey?: string(name='MetricKey', description='The metric of the alert condition.'),
          n?: float(name='N', description='Indicates the last N minutes.', example='1'),
          operator?: string(name='Operator', description='The comparison operator that is used to compare the metric value with the threshold.

*   CURRENT_GTE: greater than or equal to
*   CURRENT_LTE: less than or equal to
*   PREVIOUS_UP: the minute-to-minute increase percentage
*   PREVIOUS_DOWN: the minute-to-minute decrease percentage
*   HOH_UP: the increase percentage compared with the previous hour
*   HOH_DOWN: the decrease percentage compared with the previous hour
*   DOD_UP: the increase percentage compared with the last day
*   DOD_DOWN: the decrease percentage compared with the last day', example='CURRENT_GTE'),
          value?: string(name='Value', description='The threshold of the alert condition.', example='1'),
        }
      ](name='AlertRuleItems', description='The trigger conditions of the Application Monitoring or Browser Monitoring alert rule.'),
      condition?: string(name='Condition', description='The relationship between multiple alert conditions specified for the Application Monitoring or Browser Monitoring alert rule.

*   OR: meets any of the specified conditions.
*   AND: meets all the specified conditions.', example='"|"'),
    }(name='AlertRuleContent', description='The content of the Application Monitoring or Browser Monitoring alert rule.'),
    alertStatus?: string(name='AlertStatus', description='The status of the alert rule.

*   RUNNING
*   STOPPED
*   PAUSED

>  The **PAUSED** status indicates that the alert rule is abnormal and is actively paused by the system. The alert rule may be paused because that it is not unique or the associated cluster has been deleted.', example='RUNNING'),
    alertType?: string(name='AlertType', description='The type of the alert rule. Valid values:

*   APPLICATION_MONITORING_ALERT_RULE: alert rule for Application Monitoring
*   BROWSER_MONITORING_ALERT_RULE: alert rule for Browser Monitoring
*   PROMETHEUS_MONITORING_ALERT_RULE: alert rule for Prometheus Service', example='APPLICATION_MONITORING_ALERT_RULE'),
    annotations?: [ 
      {
        name?: string(name='Name', description='The key of the annotation.', example='123'),
        value?: string(name='Value', description='The value of the annotation.', example='abc'),
      }
    ](name='Annotations', description='The annotations of the Prometheus alert rule.'),
    autoAddNewApplication?: boolean(name='AutoAddNewApplication', description='Indicates whether the alert rule is applied to new applications that are created in Application Monitoring or Browser Monitoring.

*   `true`: yes
*   `false`: no', example='false'),
    clusterId?: string(name='ClusterId', description='The cluster ID of the Prometheus alert rule.', example='ceba9b9ea5b924dd0b6726d2de6******'),
    createdTime?: long(name='CreatedTime', description='The time when the alert rule was created.', example='1641438611000'),
    duration?: string(name='Duration', description='The duration of the Prometheus alert rule. Unit: minutes.', example='1'),
    extend?: string(name='Extend', description='The extended field.'),
    filters?: {
      customSLSFilters?: [ 
        {
          key?: string(name='Key', description='The key of the filter condition.', example='username'),
          opt?: string(name='Opt', description='The logical operator of the filter condition. 

- =: equal to
- not: not equal to', example='='),
          show?: boolean(name='Show', description='Indicates whether this filter condition is displayed on the frontend.', example='false'),
          t?: string(name='T', description='This field is used only to distinguish the type of Browser Monitoring logs. Other filter conditions do not include this field.', example='null'),
          value?: string(name='Value', description='The value of the filter condition.', example='test'),
        }
      ](name='CustomSLSFilters', description='The custom filter condition of the Browser Monitoring alert rule.'),
      customSLSGroupByDimensions?: [ string ](name='CustomSLSGroupByDimensions', description='The value of the aggregation dimension.'),
      customSLSWheres?: [ string ](name='CustomSLSWheres', description='The value of the custom filter condition.'),
      dimFilters?: [ 
        {
          filterKey?: string(name='FilterKey', description='The key of the filter condition.', example='rootIp'),
          filterOpt?: string(name='FilterOpt', description='The logical operator of the filter condition.', example='ALL'),
          filterValues?: [ string ](name='FilterValues', description='The value of the filter condition.'),
        }
      ](name='DimFilters', description='The information about each filter condition of the Application Monitoring or Browser Monitoring alert rule.'),
    }(name='Filters', description='The filter conditions of the Application Monitoring or Browser Monitoring alert rule.'),
    labels?: [ 
      {
        name?: string(name='Name', description='The key of the tag.', example='123'),
        value?: string(name='Value', description='The value of the tag.', example='abc'),
      }
    ](name='Labels', description='The tags of the Prometheus alert rule.'),
    level?: string(name='Level', description='The level of the Prometheus alert rule. 

- P1: Alert notifications are sent for major issues that affect the availability of core business, have huge impact, and may lead to serious consequences.
- P2: Alert notifications are sent for service errors that affect the system availability with relatively limited impact.
- P3: Alert notifications are sent for issues that may cause service errors or negative effects, or alert notifications for services that are relatively less important.
- P4: Alert notifications are sent for low-priority issues that do not affect your business.
- Default: Alert notifications are sent without distinguishing between alert levels.', example='P2'),
    message?: string(name='Message', description='The alert message of the Prometheus alert rule.'),
    metricsType?: string(name='MetricsType', description='The metric type of the Application Monitoring or Browser Monitoring alert rule.', example='JVM'),
    notifyStrategy?: string(name='NotifyStrategy', description='The name of the notification policy.', example='ALERT_MANAGER'),
    pids?: [ string ](name='Pids', description='The PID of the application.'),
    promQL?: string(name='PromQL', description='The PromQL statement of the Prometheus alert rule.', example='node_memory_MemAvailable_bytes{} / node_memory_MemTotal_bytes{} * 100'),
    regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    updatedTime?: long(name='UpdatedTime', description='The time when the alert rule was updated.', example='1641438611000'),
    userId?: string(name='UserId', description='The ID of the Alibaba Cloud account.', example='1131971649******'),
  }(name='AlertRule', description='The object of the alert rule.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='337B8F7E-0A64-5768-9225-E9B3CF******'),
}

model CreateOrUpdateAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateAlertRuleResponseBody(name='body'),
}

async function createOrUpdateAlertRuleWithOptions(request: CreateOrUpdateAlertRuleRequest, runtime: Util.RuntimeOptions): CreateOrUpdateAlertRuleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alertCheckType)) {
    body['AlertCheckType'] = request.alertCheckType;
  }
  if (!Util.isUnset(request.alertGroup)) {
    body['AlertGroup'] = request.alertGroup;
  }
  if (!Util.isUnset(request.alertId)) {
    body['AlertId'] = request.alertId;
  }
  if (!Util.isUnset(request.alertName)) {
    body['AlertName'] = request.alertName;
  }
  if (!Util.isUnset(request.alertRuleContent)) {
    body['AlertRuleContent'] = request.alertRuleContent;
  }
  if (!Util.isUnset(request.alertStatus)) {
    body['AlertStatus'] = request.alertStatus;
  }
  if (!Util.isUnset(request.alertType)) {
    body['AlertType'] = request.alertType;
  }
  if (!Util.isUnset(request.annotations)) {
    body['Annotations'] = request.annotations;
  }
  if (!Util.isUnset(request.autoAddNewApplication)) {
    body['AutoAddNewApplication'] = request.autoAddNewApplication;
  }
  if (!Util.isUnset(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.duration)) {
    body['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.filters)) {
    body['Filters'] = request.filters;
  }
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.level)) {
    body['Level'] = request.level;
  }
  if (!Util.isUnset(request.message)) {
    body['Message'] = request.message;
  }
  if (!Util.isUnset(request.metricsKey)) {
    body['MetricsKey'] = request.metricsKey;
  }
  if (!Util.isUnset(request.metricsType)) {
    body['MetricsType'] = request.metricsType;
  }
  if (!Util.isUnset(request.notifyStrategy)) {
    body['NotifyStrategy'] = request.notifyStrategy;
  }
  if (!Util.isUnset(request.pids)) {
    body['Pids'] = request.pids;
  }
  if (!Util.isUnset(request.promQL)) {
    body['PromQL'] = request.promQL;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateAlertRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateAlertRule(request: CreateOrUpdateAlertRuleRequest): CreateOrUpdateAlertRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateAlertRuleWithOptions(request, runtime);
}

model CreateOrUpdateContactRequest {
  contactId?: long(name='ContactId', description='The ID of the alert contact.

*   If you do not specify this parameter, an alert contact is created.
*   If you specify this parameter, the specified alert contact is modified.', example='123'),
  contactName?: string(name='ContactName', description='The name of the alert contact.', example='JohnDoe'),
  dingRobotUrl?: string(name='DingRobotUrl'),
  email?: string(name='Email', description='The email address of the alert contact.

> You must specify at least one of the **Phone** and **Email** parameters. Each mobile number or email address can be used for only one alert contact.', example='someone@example.com'),
  isEmailVerify?: boolean(name='IsEmailVerify'),
  phone?: string(name='Phone', description='The mobile number of the alert contact.

> You must specify at least one of the **Phone** and **Email** parameters. Each mobile number or email address can be used for only one alert contact.', example='1381111****'),
  reissueSendNotice?: long(name='ReissueSendNotice', description='The method to resend notifications if phone notifications fail. Valid values:

*   0: do not resend notifications
*   1: make a phone call again
*   2: send a text message
*   3 (default value): use the global default value', example='3'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateOrUpdateContactResponseBody = {
  alertContact?: {
    contactId?: float(name='ContactId', description='The ID of the alert contact.', example='123'),
    contactName?: string(name='ContactName', description='The name of the alert contact.', example='JohnDoe'),
    dingRobotUrl?: string(name='DingRobotUrl'),
    email?: string(name='Email', description='The email address of the alert contact.', example='someone@example.com'),
    isVerify?: boolean(name='IsVerify', description='Indicates whether the mobile number is verified. Valid values:

*   `false` (default value): The mobile number is not verified.
*   `true`: The mobile number is verified.

You can call the **SendTTSVerifyLink** operation to verify the mobile number of an alert contact. Only verified mobile numbers can be specified in a notification policy.', example='false'),
    phone?: string(name='Phone', description='The mobile number of the alert contact.', example='1381111****'),
    reissueSendNotice?: long(name='ReissueSendNotice', description='The method to resend notifications if phone notifications fail. Valid values: 0: do not resend notifications. 1: make a phone call again. 2: send a text message. 3 (default value): use the global default value.', example='3'),
    isEmailVerify?: boolean(name='isEmailVerify'),
  }(name='AlertContact', description='The object of the alert contact.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E9C9DA3D-10FE-472E-9EEF-2D0A3E41****'),
}

model CreateOrUpdateContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateContactResponseBody(name='body'),
}

async function createOrUpdateContactWithOptions(request: CreateOrUpdateContactRequest, runtime: Util.RuntimeOptions): CreateOrUpdateContactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dingRobotUrl)) {
    query['DingRobotUrl'] = request.dingRobotUrl;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.contactId)) {
    body['ContactId'] = request.contactId;
  }
  if (!Util.isUnset(request.contactName)) {
    body['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.email)) {
    body['Email'] = request.email;
  }
  if (!Util.isUnset(request.isEmailVerify)) {
    body['IsEmailVerify'] = request.isEmailVerify;
  }
  if (!Util.isUnset(request.phone)) {
    body['Phone'] = request.phone;
  }
  if (!Util.isUnset(request.reissueSendNotice)) {
    body['ReissueSendNotice'] = request.reissueSendNotice;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateContact',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateContact(request: CreateOrUpdateContactRequest): CreateOrUpdateContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateContactWithOptions(request, runtime);
}

model CreateOrUpdateContactGroupRequest {
  contactGroupId?: long(name='ContactGroupId', description='The ID of the alert contact group.

*   If you do not specify this parameter, an alert contact group is created.
*   If you specify this parameter, the specified alert contact group is modified.', example='123'),
  contactGroupName?: string(name='ContactGroupName', description='The name of the alert contact group.', example='TestGroup'),
  contactIds?: string(name='ContactIds', description='The ID of the contact that you want to add to the contact group. Separate multiple IDs with commas (,).', example='[1,2,3]'),
}

model CreateOrUpdateContactGroupResponseBody = {
  alertContactGroup?: {
    contactGroupId?: float(name='ContactGroupId', description='The ID of the alert contact group.', example='123'),
    contactGroupName?: string(name='ContactGroupName', description='The name of the alert contact group.', example='TestGroup'),
    contactIds?: string(name='ContactIds', description='The IDs of the contacts that are included in the alert contact group.', example='[1,2,3]'),
  }(name='AlertContactGroup', description='The object.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9319A57D-2D9E-472A-B69B-CF3CD16D****'),
}

model CreateOrUpdateContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateContactGroupResponseBody(name='body'),
}

async function createOrUpdateContactGroupWithOptions(request: CreateOrUpdateContactGroupRequest, runtime: Util.RuntimeOptions): CreateOrUpdateContactGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.contactGroupId)) {
    body['ContactGroupId'] = request.contactGroupId;
  }
  if (!Util.isUnset(request.contactGroupName)) {
    body['ContactGroupName'] = request.contactGroupName;
  }
  if (!Util.isUnset(request.contactIds)) {
    body['ContactIds'] = request.contactIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateContactGroup',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateContactGroup(request: CreateOrUpdateContactGroupRequest): CreateOrUpdateContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateContactGroupWithOptions(request, runtime);
}

model CreateOrUpdateEventBridgeIntegrationRequest {
  accessKey?: string(name='AccessKey', description='The AccessKey ID that is used to connect to EventBridge.', example='abc******************'),
  accessSecret?: string(name='AccessSecret', description='The AccessKey secret that is used to connect to EventBridge.', example='abc******************'),
  description?: string(name='Description', description='The description of the EventBridge integration.', example='test'),
  endpoint?: string(name='Endpoint', description='The public endpoint of EventBridge.', example='http://xxxxx'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='EventBus_Test'),
  eventBusRegionId?: string(name='EventBusRegionId', description='The region ID of the event bus.', example='cn-hangzhou'),
  id?: long(name='Id', description='The ID of the EventBridge integration.

*   If you do not specify this parameter, an EventBridge integration is created.
*   If you specify this parameter, the specified EventBridge integration is modified.', example='123'),
  name?: string(name='Name', description='The name of the EventBridge integration.', example='EventBridge_Test'),
  source?: string(name='Source', description='The event source.', example='arms'),
}

model CreateOrUpdateEventBridgeIntegrationResponseBody = {
  eventBridgeIntegration?: {
    accessKey?: string(name='AccessKey', description='The AccessKey ID that is used to connect to EventBridge.', example='abc******************'),
    accessSecret?: string(name='AccessSecret', description='The AccessKey secret that is used to connect to EventBridge.', example='abc******************'),
    description?: string(name='Description', description='The description of the EventBridge integration.', example='test'),
    endpoint?: string(name='Endpoint', description='The public endpoint of EventBridge.', example='http://xxxxx'),
    eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='EventBus_Test'),
    eventBusRegionId?: string(name='EventBusRegionId', description='The region ID of the event bus.', example='cn-hangzhou'),
    id?: long(name='Id', description='The ID of the EventBridge integration.', example='123'),
    name?: string(name='Name', description='The name of the EventBridge integration.', example='EventBridge_Test'),
    source?: string(name='Source', description='The event source.', example='arms'),
  }(name='EventBridgeIntegration', description='The information about the EventBridge integration.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2B289756-E791-5842-BCBD-AD414C******'),
}

model CreateOrUpdateEventBridgeIntegrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateEventBridgeIntegrationResponseBody(name='body'),
}

async function createOrUpdateEventBridgeIntegrationWithOptions(request: CreateOrUpdateEventBridgeIntegrationRequest, runtime: Util.RuntimeOptions): CreateOrUpdateEventBridgeIntegrationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessKey)) {
    body['AccessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.accessSecret)) {
    body['AccessSecret'] = request.accessSecret;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.endpoint)) {
    body['Endpoint'] = request.endpoint;
  }
  if (!Util.isUnset(request.eventBusName)) {
    body['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventBusRegionId)) {
    body['EventBusRegionId'] = request.eventBusRegionId;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.source)) {
    body['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateEventBridgeIntegration',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateEventBridgeIntegration(request: CreateOrUpdateEventBridgeIntegrationRequest): CreateOrUpdateEventBridgeIntegrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateEventBridgeIntegrationWithOptions(request, runtime);
}

model CreateOrUpdateIMRobotRequest {
  cardTemplate?: string(name='CardTemplate', example='{     "button": [         "claim",         "close",         "follow",         "send_itsm",         "block",         "unResolvedIncident"     ],     "field": [         {             "fieldName": "alarmName",             "visible": true         },         {             "fieldName": "notificationPolicy",             "visible": true         },         {             "fieldName": "alarmContent",             "visible": true         },         {             "fieldName": "alarmTime",             "visible": true         },         {             "fieldName": "seriesChart",             "visible": true         },         {             "fieldName": "includeEvent",             "visible": true         },         {             "fieldName": "assigned",             "visible": true         },         {             "fieldName": "similarAlarm",             "visible": true         },         {             "fieldName": "operator",             "visible": true         }     ] }'),
  dailyNoc?: boolean(name='DailyNoc', description='Specifies whether to send daily statistics.

*   `false` (default): does not send statistics.
*   `true`: sends statistics. After you select `true`, **DailyNocTime** parameters are required.', example='true'),
  dailyNocTime?: string(name='DailyNocTime', description='The time point at which the daily statistics are sent. Separate multiple sending time points with commas (,). The time point is in the HH:SS format. ARMS Alert Management sends the total number of alerts generated today, the number of resolved alerts, and the number of pending alerts at the specified time point.', example='09:30,17:00'),
  dingSignKey?: string(name='DingSignKey', example='******'),
  enableOutgoing?: boolean(name='EnableOutgoing', example='true'),
  robotAddress?: string(name='RobotAddress', description='The webhook address of the IM bot.', example='https://oapi.dingtalk.com/robot/send?access_token=e1a049121******'),
  robotId?: long(name='RobotId', description='The ID of the IM bot.

*   If you do not specify this parameter, a new IM bot is created.
*   Enter information that represents modifying the specified IM bot.', example='123'),
  robotName?: string(name='RobotName', description='The name of the IM robot.'),
  token?: string(name='Token', example='1656558719183be1245ab44********'),
  type?: string(name='Type', description='IM Robot Type:

*   `dingding`: DingTalk robot.
*   `wechat`: Enterprise WeChat Robot.', example='dingding'),
}

model CreateOrUpdateIMRobotResponseBody = {
  alertRobot?: {
    cardTemplate?: string(name='CardTemplate', example='{     "button": [         "claim",         "close",         "follow",         "send_itsm",         "block",         "unResolvedIncident"     ],     "field": [         {             "fieldName": "alarmName",             "visible": true         },         {             "fieldName": "notificationPolicy",             "visible": true         },         {             "fieldName": "alarmContent",             "visible": true         },         {             "fieldName": "alarmTime",             "visible": true         },         {             "fieldName": "seriesChart",             "visible": true         },         {             "fieldName": "includeEvent",             "visible": true         },         {             "fieldName": "assigned",             "visible": true         },         {             "fieldName": "similarAlarm",             "visible": true         },         {             "fieldName": "operator",             "visible": true         }     ] }'),
    dailyNoc?: boolean(name='DailyNoc', description='Specifies whether to send daily statistics.

*   `false` (default): does not send statistics.
*   `true`: sends statistics.', example='true'),
    dailyNocTime?: string(name='DailyNocTime', description='The time when the daily statistics are sent. ARMS Alert Management sends the total number of alerts generated today, the number of resolved alerts, and the number of pending alerts at the specified time point.', example='09:30,17:00'),
    enableOutgoing?: boolean(name='EnableOutgoing', example='true'),
    robotAddress?: string(name='RobotAddress', description='The webhook address of the IM bot.', example='https://oapi.dingtalk.com/robot/send?access_token=e1a049121******'),
    robotId?: float(name='RobotId', description='The ID of the IM bot.', example='123'),
    robotName?: string(name='RobotName', description='The name of the IM robot.'),
    token?: string(name='Token', example='1656558719183be1245ab44********'),
    type?: string(name='Type', description='IM Robot Type:

*   `dingding`: DingTalk robot.
*   `wechat`: Enterprise WeChat Robot.', example='dingding'),
  }(name='AlertRobot', description='Returns an AlertRobot object.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='16AF921B-8187-489F-9913-43C808B4****'),
}

model CreateOrUpdateIMRobotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateIMRobotResponseBody(name='body'),
}

async function createOrUpdateIMRobotWithOptions(request: CreateOrUpdateIMRobotRequest, runtime: Util.RuntimeOptions): CreateOrUpdateIMRobotResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.cardTemplate)) {
    body['CardTemplate'] = request.cardTemplate;
  }
  if (!Util.isUnset(request.dailyNoc)) {
    body['DailyNoc'] = request.dailyNoc;
  }
  if (!Util.isUnset(request.dailyNocTime)) {
    body['DailyNocTime'] = request.dailyNocTime;
  }
  if (!Util.isUnset(request.dingSignKey)) {
    body['DingSignKey'] = request.dingSignKey;
  }
  if (!Util.isUnset(request.enableOutgoing)) {
    body['EnableOutgoing'] = request.enableOutgoing;
  }
  if (!Util.isUnset(request.robotAddress)) {
    body['RobotAddress'] = request.robotAddress;
  }
  if (!Util.isUnset(request.robotId)) {
    body['RobotId'] = request.robotId;
  }
  if (!Util.isUnset(request.robotName)) {
    body['RobotName'] = request.robotName;
  }
  if (!Util.isUnset(request.token)) {
    body['Token'] = request.token;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateIMRobot',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateIMRobot(request: CreateOrUpdateIMRobotRequest): CreateOrUpdateIMRobotResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateIMRobotWithOptions(request, runtime);
}

model CreateOrUpdateNotificationPolicyRequest {
  escalationPolicyId?: long(name='EscalationPolicyId', description='The ID of the escalation policy.', example='123'),
  groupRule?: string(name='GroupRule', description='An array of alert event group objects.

*   If you do not specify the groupingFields field, all alerts will be sent to contacts based on `alertname`.

*   If you specify the groupingFields field, alerts with the same field will be sent to contacts in one notification.

    Sample statement:

```

{ 
"groupWait":5,    // The waiting time for grouping. 
"groupInterval":30,     // The time interval of grouping. 
"groupingFields":["alertname"]       // The field that is used to group alert events. 
}
```', example='{ 	"groupWait":5, 	"groupInterval":30, 	"groupingFields":["alertname"] }'),
  id?: long(name='Id', description='The ID of the notification policy.

*   If you do not specify this parameter, a new notification policy is created.
*   If you specify this parameter, the specified notification policy is modified.', example='1234'),
  integrationId?: long(name='IntegrationId', description='The integration ID of the ticket system to which alerts are pushed.', example='34'),
  matchingRules?: string(name='MatchingRules', description='The matching rules. Sample statement:

```

[
 {
 "matchingConditions": [
 { 
 "value": "test",    // The value of the matching condition. 
 "key": "alertname",     // The key of the matching condition. 
 "operator": "eq"   // The logical operator of the matching condition, including eq (equal to), neq (not equal to), in (contains), nin (does not contain), re (regular expression match), and nre (regular expression mismatch).   
 }
 ]
 } 
 ]
```', example='[ 		 { 		 "matchingConditions": [          { 		 "value": "test", 		 "key": "alertname", 		 "operator": "eq"         }       ]     }   ]'),
  name?: string(name='Name', description='The name of the notification policy.', example='notificationpolicy_test'),
  notifyRule?: string(name='NotifyRule', description='An array of notification rule objects. Sample statement:

```

{ 
 "notifyStartTime":"00:00",      // The start time of the notification window. 
 "notifyEndTime":"23:59",       // The end time of the notification window. 
 "notifyChannels":["dingTalk", "email", "sms", "tts", "webhook"],       // The notification methods. Valid values: dingTalk, email, sms, tts, and webhook. 
 "notifyObjects":[{       // An array of notification contact objects. 
 "notifyObjectType":"CONTACT",       // The type of the notification contact. Valid values: CONTACT (individual contacts), CONTACT_GROUP (contact groups), DING_ROBOT (the instant message robot), and CONTACT_SCHEDULE (the person on duty based on an established schedule). 
 "notifyObjectId":123,       // The ID of the notification contact. 
 "notifyObjectName":"test"       // The name of the notification contact. 
 }]
```', example='{     "notifyStartTime":"00:00",     "notifyEndTime":"23:59",     "notifyChannels":[         "dingTalk",         "email",         "sms",         "tts",         "webhook"     ],     "notifyObjects":[         {             "notifyObjectType":"CONTACT",             "notifyObjectId":123,             "notifyObjectName":"test"         }     ] }'),
  notifyTemplate?: string(name='NotifyTemplate', description='The notification template. The default notification template is provided below the table.'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  repeat?: boolean(name='Repeat', description='Specifies whether to resend a notification for a long-lasting unresolved alert. Default value: true. Valid values:

*   `true`: If you set this parameter to `true`, you must set **RepeatInterval**.
*   `false`: If you set this parameter to `false`, you must set **EscalationPolicyId**.', example='true'),
  repeatInterval?: long(name='RepeatInterval', description='The time interval at which a notification is resent for a long-lasting unresolved alert. Unit: seconds.', example='600'),
  sendRecoverMessage?: boolean(name='SendRecoverMessage', description='Indicates whether the system sends a notification to the contacts when the status of an alert changes to Resolved. Default value: true. Valid values:

*   `true`: The system sends a notification.
*   `false`: The system does not send a notification.', example='true'),
}

model CreateOrUpdateNotificationPolicyResponseBody = {
  notificationPolicy?: {
    escalationPolicyId?: long(name='EscalationPolicyId', description='The ID of the escalation policy.', example='123'),
    groupRule?: {
      groupInterval?: long(name='GroupInterval', description='The time interval of grouping. Unit: seconds. Default value: 30.', example='30'),
      groupWait?: long(name='GroupWait', description='The waiting time for grouping. Unit: seconds. Default value: 5.', example='5'),
      groupingFields?: [ string ](name='GroupingFields', description='The field that is used for grouping.'),
    }(name='GroupRule', description='An array of alert event group objects.'),
    id?: long(name='Id', description='The ID of the notification policy.', example='1234'),
    integrationId?: long(name='IntegrationId', description='The integration ID of the ticket system to which alerts are pushed.', example='34'),
    matchingRules?: [ 
      {
        matchingConditions?: [ 
          {
            key?: string(name='Key', description='The key of the matching condition.', example='altertname'),
            operator?: string(name='Operator', description='The logical operator of the matching condition. Valid values:

*   `eq`: equal to
*   `neq`: not equal to
*   `in`: contains
*   `nin`: does not contain
*   `re`: regular expression match
*   `nre`: regular expression mismatch', example='eq'),
            value?: string(name='Value', description='The value of the matching condition.', example='test'),
          }
        ](name='MatchingConditions', description='An array of alert event matching condition objects.'),
      }
    ](name='MatchingRules', description='An array of alert event matching rule objects.'),
    name?: string(name='Name', description='The name of the notification policy.', example='notificationpolicy_test'),
    notifyRule?: {
      notifyChannels?: [ string ](name='NotifyChannels', description='The notification methods. Valid values: 

- `dingTalk`: DingTalk
- `email`: email
- `sms`: text message
- `tts`: phone call
- `webhook`: webhook'),
      notifyEndTime?: string(name='NotifyEndTime', description='The end time of the notification window.', example='23:59'),
      notifyObjects?: [ 
        {
          notifyObjectId?: long(name='NotifyObjectId', description='The ID of the notification contact.', example='123'),
          notifyObjectName?: string(name='NotifyObjectName', description='The name of the notification contact.', example='test'),
          notifyObjectType?: string(name='NotifyObjectType', description='The type of the notification contact. Valid values: 

- CONTACT: an individual contact
- CONTACT_GROUP: a contact group
- DING_ROBOT: an instant messaging (IM) robot
- CONTACT_SCHEDULE: a person on duty based on an established schedule', example='CONTACT'),
        }
      ](name='NotifyObjects', description='An array of notification contact objects.'),
      notifyStartTime?: string(name='NotifyStartTime', description='The start time of the notification window.', example='00:00'),
    }(name='NotifyRule', description='An array of notification rule objects.'),
    notifyTemplate?: {
      emailContent?: string(name='EmailContent', description='The content of the alert notification sent through email.'),
      emailRecoverContent?: string(name='EmailRecoverContent', description='The content of the alert resolution notification sent through email.'),
      emailRecoverTitle?: string(name='EmailRecoverTitle', description='The title of the alert resolution notification sent through email.', example='{{ .commonLabels.alertname }}'),
      emailTitle?: string(name='EmailTitle', description='The title of the alert notification sent through email.', example='{{ .commonLabels.alertname }}'),
      robotContent?: string(name='RobotContent', description='The content of the alert notification sent by the IM robot.'),
      smsContent?: string(name='SmsContent', description='The content of the alert notification sent through text message.'),
      smsRecoverContent?: string(name='SmsRecoverContent', description='The content of the alert resolution notification sent through text message.'),
      ttsContent?: string(name='TtsContent', description='The content of the alert notification by phone.'),
      ttsRecoverContent?: string(name='TtsRecoverContent', description='The content of the alert resolution notification by phone.'),
    }(name='NotifyTemplate', description='An array of notification template objects.'),
    repeat?: boolean(name='Repeat', description='Indicates whether a notification is resent for a long-lasting unresolved alert. Default value: true. Valid values:  

- `true`: The system resends a notification for a long-lasting unresolved alert at a specified time interval.
- `false`: The system sends a notification for a long-lasting unresolved alert based on an escalation policy.', example='true'),
    repeatInterval?: long(name='RepeatInterval', description='The time interval at which a notification is resent for a long-lasting unresolved alert. Unit: seconds.', example='600'),
    sendRecoverMessage?: boolean(name='SendRecoverMessage', description='Indicates whether the system sends a notification to the contacts when the status of an alert changes to Resolved. Default value: true. Valid values:   

- `true`: The system sends a notification.
- `false`: The system does not send a notification.', example='true'),
  }(name='NotificationPolicy', description='An array of notification policy objects.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A5EC8221-08F2-4C95-9AF1-49FD998C****'),
}

model CreateOrUpdateNotificationPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateNotificationPolicyResponseBody(name='body'),
}

async function createOrUpdateNotificationPolicyWithOptions(request: CreateOrUpdateNotificationPolicyRequest, runtime: Util.RuntimeOptions): CreateOrUpdateNotificationPolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.escalationPolicyId)) {
    body['EscalationPolicyId'] = request.escalationPolicyId;
  }
  if (!Util.isUnset(request.groupRule)) {
    body['GroupRule'] = request.groupRule;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.integrationId)) {
    body['IntegrationId'] = request.integrationId;
  }
  if (!Util.isUnset(request.matchingRules)) {
    body['MatchingRules'] = request.matchingRules;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.notifyRule)) {
    body['NotifyRule'] = request.notifyRule;
  }
  if (!Util.isUnset(request.notifyTemplate)) {
    body['NotifyTemplate'] = request.notifyTemplate;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.repeat)) {
    body['Repeat'] = request.repeat;
  }
  if (!Util.isUnset(request.repeatInterval)) {
    body['RepeatInterval'] = request.repeatInterval;
  }
  if (!Util.isUnset(request.sendRecoverMessage)) {
    body['SendRecoverMessage'] = request.sendRecoverMessage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateNotificationPolicy',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateNotificationPolicy(request: CreateOrUpdateNotificationPolicyRequest): CreateOrUpdateNotificationPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateNotificationPolicyWithOptions(request, runtime);
}

model CreateOrUpdateSilencePolicyRequest {
  id?: long(name='Id', description='The ID of the silence policy.

*   If you do not specify this parameter, a new silence policy is created.
*   If you specify this parameter, the specified silence policy is modified.', example='1234'),
  matchingRules?: string(name='MatchingRules', description='The matching rules. Sample statement:

```

[
     {
	 "matchingConditions": [
	 {
	 "value": "test", // The value of the matching condition. 
	 "key": "altertname", // The key of the matching condition. 
	 "operator": "eq" // The logical operator of the matching condition, including eq (equal to), neq (not equal to), in (contains), nin (does not contain), re (regular expression match), and nre (regular expression mismatch).   
	 }
	 ]
     }
	 ]
```', example='[ 	 { 	 "matchingConditions": [ 	 { 	 "value": "test", 	 "key": "altertname", 	 "operator": "eq" 	 } 	 ]      } 	 ]'),
  name?: string(name='Name', description='The name of the silence policy.', example='silencepolicy_test'),
  regionId?: string(name='RegionId'),
}

model CreateOrUpdateSilencePolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='A5EC8221-08F2-4C95-9AF1-49FD998C****'),
  silencePolicy?: {
    id?: long(name='Id', description='The ID of the silence policy.', example='1234'),
    matchingRules?: [ 
      {
        matchingConditions?: [ 
          {
            key?: string(name='Key', description='The key of the matching condition.', example='altertname'),
            operator?: string(name='Operator', description='The logical operator of the matching condition. Valid values:

*   `eq`: equal to.
*   `neq`: not equal to.
*   `in`: contains.
*   `nin`: does not contain.
*   `re`: regular expression match.
*   `nre`: regular expression mismatch.', example='eq'),
            value?: string(name='Value', description='The value of the matching condition.', example='test'),
          }
        ](name='MatchingConditions', description='An array of matching condition objects.'),
      }
    ](name='MatchingRules', description='An array of matching rule objects.'),
    name?: string(name='Name', description='The name of the silence policy.', example='silencepolicy_test'),
  }(name='SilencePolicy', description='An array of silence policy objects.'),
}

model CreateOrUpdateSilencePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateSilencePolicyResponseBody(name='body'),
}

async function createOrUpdateSilencePolicyWithOptions(request: CreateOrUpdateSilencePolicyRequest, runtime: Util.RuntimeOptions): CreateOrUpdateSilencePolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.matchingRules)) {
    body['MatchingRules'] = request.matchingRules;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateSilencePolicy',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateSilencePolicy(request: CreateOrUpdateSilencePolicyRequest): CreateOrUpdateSilencePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateSilencePolicyWithOptions(request, runtime);
}

model CreateOrUpdateWebhookContactRequest {
  bizHeaders?: string(name='BizHeaders', description='The header of the HTTP request.', example='[{"Content-Type":"application/json;charset=utf-8"}]'),
  bizParams?: string(name='BizParams', description='The parameters in the HTTP request.', example='[{"content":"mike"}]'),
  body?: string(name='Body', description='The notification template that is sent when an alert is triggered. This parameter is required when the **Method** is set to **Post**. You can use `$content` placeholders to output the notification content. The notification content cannot exceed 500 characters in length. For more information, see [Notification template variables](~~251834~~).', example='{ "":"{{ .commonLabels.alertname }}{{if .commonLabels.clustername }}", "":"{{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }}", "":"{{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }}", "":"{{ .dispatchRuleName }}", "":"{{ .startTime }}", "":"{{ for .alerts }} {{ .annotations.message }} {{ end }}" }'),
  method?: string(name='Method', description='The HTTP request method. Valid values:

*   Post
*   Get', example='Post'),
  recoverBody?: string(name='RecoverBody', description='The notification template that is sent when the alert resumes. This parameter is required when the **Method** is set to **Post**. You can use `$content` placeholders to output the notification content. The notification content cannot exceed 500 characters in length. For more information, see [Notification template variables](~~251834~~).', example='{ "":"{{ .commonLabels.alertname }}{{if .commonLabels.clustername }}", "":"{{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }}", "":"{{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }}", "":"{{ .dispatchRuleName }}", "":"{{ .endTime }}", "":"{{ for .alerts }} {{ .annotations.message }} {{ end }}" }'),
  url?: string(name='Url', description='The URL of the request method.', example='https://oapi.dingtalk.com/robot/send?access_token=e1a049121******'),
  webhookId?: long(name='WebhookId', description='The ID of the contact for webhook alerts.

*   If you do not specify this parameter, a new webhook alert contact is created.
*   Enter information that represents modifying the contact information of the specified Webhook alert.', example='123'),
  webhookName?: string(name='WebhookName', description='The name of the webhook alert contact.', example='webhook_contact'),
}

model CreateOrUpdateWebhookContactResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16AF921B-8187-489F-9913-43C808B4****'),
  webhookContact?: {
    webhook?: {
      bizHeaders?: string(name='BizHeaders', description='The header of the HTTP request.', example='[{"Content-Type":"application/json;charset=utf-8"}]'),
      bizParams?: string(name='BizParams', description='The parameters in the HTTP request.', example='[{"content":"mike"}]'),
      body?: string(name='Body', description='The alert notification template.'),
      method?: string(name='Method', description='The HTTP request method. Valid values:

*   Post
*   Get', example='Post'),
      recoverBody?: string(name='RecoverBody', description='The alert recovery template.'),
      url?: string(name='Url', description='The URL of the request method.', example='https://oapi.dingtalk.com/robot/send?access_token=e1a049121******'),
    }(name='Webhook', description='The returned Webhook object.'),
    webhookId?: float(name='WebhookId', description='The ID of the contact for webhook alerts.', example='123'),
    webhookName?: string(name='WebhookName', description='The name of the webhook alert contact.'),
  }(name='WebhookContact', description='The returned WebhookContact object.'),
}

model CreateOrUpdateWebhookContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateWebhookContactResponseBody(name='body'),
}

async function createOrUpdateWebhookContactWithOptions(request: CreateOrUpdateWebhookContactRequest, runtime: Util.RuntimeOptions): CreateOrUpdateWebhookContactResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizHeaders)) {
    body['BizHeaders'] = request.bizHeaders;
  }
  if (!Util.isUnset(request.bizParams)) {
    body['BizParams'] = request.bizParams;
  }
  if (!Util.isUnset(request.body)) {
    body['Body'] = request.body;
  }
  if (!Util.isUnset(request.method)) {
    body['Method'] = request.method;
  }
  if (!Util.isUnset(request.recoverBody)) {
    body['RecoverBody'] = request.recoverBody;
  }
  if (!Util.isUnset(request.url)) {
    body['Url'] = request.url;
  }
  if (!Util.isUnset(request.webhookId)) {
    body['WebhookId'] = request.webhookId;
  }
  if (!Util.isUnset(request.webhookName)) {
    body['WebhookName'] = request.webhookName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateWebhookContact',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateWebhookContact(request: CreateOrUpdateWebhookContactRequest): CreateOrUpdateWebhookContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateWebhookContactWithOptions(request, runtime);
}

model CreatePrometheusAlertRuleRequest {
  alertName?: string(name='AlertName', description='The name of the alert rule.', example='Prometheus_Alert'),
  annotations?: string(name='Annotations', description='The annotations that are described in a JSON string. You must specify the name and value of each annotation.', example='[{"Value": "xxx","Name": "description"}]'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c0bad479465464e1d8c1e641b0afb****'),
  dispatchRuleId?: long(name='DispatchRuleId', description='The ID of the notification policy. This parameter is required if the **NotifyType** parameter is set to `DISPATCH_RULE`.', example='10282'),
  duration?: string(name='Duration', description='The duration of the alert. Valid values: 1 to 1440. Unit: minutes.', example='1'),
  expression?: string(name='Expression', description='The alert rule expression that follows the PromQL syntax.', example='100 * (sum(rate(container_cpu_usage_seconds_total[1m])) by (pod_name) / sum(label_replace(kube_pod_container_resource_limits_cpu_cores, \\"pod_name\\", \\"$1\\", \\"pod\\", \\"(.*)\\")) by (pod_name))>75'),
  labels?: string(name='Labels', description='The tags that are described in a JSON string. You must specify the name and value of each tag.', example='[{"Value": "critical","Name": "severity"}]'),
  message?: string(name='Message', description='The message of the alert notification. Tags can be referenced in the {{$labels.xxx}} format.'),
  notifyType?: string(name='NotifyType', description='The method of that is used to send alert notifications. Valid values:

*   `ALERT_MANAGER`: Alert notifications are sent by Operation Center. This is the default value.
*   `DISPATCH_RULE`: Alert notifications are sent based on the specified notification policy.', example='ALERT_MANAGER'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  type?: string(name='Type', description='The type of the alert rule.'),
}

model CreatePrometheusAlertRuleResponseBody = {
  prometheusAlertRule?: {
    alertId?: long(name='AlertId', description='The ID of the alert rule.', example='3888704'),
    alertName?: string(name='AlertName', description='The name of the alert rule.', example='Prometheus_Alert'),
    annotations?: [ 
      {
        name?: string(name='Name', description='The name of the annotation.', example='message'),
        value?: string(name='Value', description='The value of the annotation.'),
      }
    ](name='Annotations', description='The annotations of the alert rule.'),
    clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c0bad479465464e1d8c1e641b0afb****'),
    dispatchRuleId?: long(name='DispatchRuleId', description='The ID of the notification policy.', example='10282'),
    duration?: string(name='Duration', description='The duration of the alert. Valid values: 1 to 1440. Unit: minutes.', example='1'),
    expression?: string(name='Expression', description='The expression of the alert rule.', example='100 * (sum(rate(container_cpu_usage_seconds_total[1m])) by (pod_name) / sum(label_replace(kube_pod_container_resource_limits_cpu_cores, \\"pod_name\\", \\"$1\\", \\"pod\\", \\"(.*)\\")) by (pod_name))>75'),
    labels?: [ 
      {
        name?: string(name='Name', description='The name of the tag.', example='severity'),
        value?: string(name='Value', description='The value of the tag.', example='critical'),
      }
    ](name='Labels', description='The tags of the alert rule.'),
    message?: string(name='Message', description='The message of the alert notification. Tags can be referenced in the {{$labels.xxx}} format.'),
    notifyType?: string(name='NotifyType', description='The method of that is used to send alert notifications. Valid values:

*   `ALERT_MANAGER`: Alert notifications are sent by Operation Center.
*   `DISPATCH_RULE`: Alert notifications are sent based on the specified notification policy.', example='ALERT_MANAGER'),
    status?: int32(name='Status', description='Indicates whether the alert rule is enabled. Valid values:

*   `1`: The alert rule is enabled.
*   `0`: The alert rule is disabled.', example='1'),
    type?: string(name='Type', description='The type of the alert rule.'),
  }(name='PrometheusAlertRule', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9FEA6D00-317F-45E3-9004-7FB8B0B7****'),
}

model CreatePrometheusAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePrometheusAlertRuleResponseBody(name='body'),
}

async function createPrometheusAlertRuleWithOptions(request: CreatePrometheusAlertRuleRequest, runtime: Util.RuntimeOptions): CreatePrometheusAlertRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertName)) {
    query['AlertName'] = request.alertName;
  }
  if (!Util.isUnset(request.annotations)) {
    query['Annotations'] = request.annotations;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dispatchRuleId)) {
    query['DispatchRuleId'] = request.dispatchRuleId;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.expression)) {
    query['Expression'] = request.expression;
  }
  if (!Util.isUnset(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  if (!Util.isUnset(request.notifyType)) {
    query['NotifyType'] = request.notifyType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePrometheusAlertRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPrometheusAlertRule(request: CreatePrometheusAlertRuleRequest): CreatePrometheusAlertRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPrometheusAlertRuleWithOptions(request, runtime);
}

model CreateRetcodeAppRequest {
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId'),
  retcodeAppName?: string(name='RetcodeAppName', description='The name of the application that you want to monitor by using Browser Monitoring.', example='SdkTest'),
  retcodeAppType?: string(name='RetcodeAppType', description='The type of the application. Valid values:

*   `web`: web application
*   `weex`: Weex mobile app
*   `mini_dd`: DingTalk mini program
*   `mini_alipay`: Alipay mini program
*   `mini_wx`: WeChat mini program
*   `mini_common`: mini program on other platforms', example='mini_dd'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
}

model CreateRetcodeAppResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='A5EC8221-08F2-4C95-9AF1-49FD998C647A'),
  retcodeAppDataBean?: {
    appId?: long(name='AppId', description='The ID of the application.', example='135143'),
    pid?: string(name='Pid', description='PID', example='aokcdqn3ly@a195c6d6421****'),
    resourceGroupId?: string(name='ResourceGroupId'),
    tags?: {
      tags?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='Tags')
    }(name='Tags'),
  }(name='RetcodeAppDataBean', description='The information of the browser monitoring task.'),
}

model CreateRetcodeAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRetcodeAppResponseBody(name='body'),
}

async function createRetcodeAppWithOptions(request: CreateRetcodeAppRequest, runtime: Util.RuntimeOptions): CreateRetcodeAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.retcodeAppName)) {
    query['RetcodeAppName'] = request.retcodeAppName;
  }
  if (!Util.isUnset(request.retcodeAppType)) {
    query['RetcodeAppType'] = request.retcodeAppType;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRetcodeApp',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRetcodeApp(request: CreateRetcodeAppRequest): CreateRetcodeAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRetcodeAppWithOptions(request, runtime);
}

model CreateSyntheticTaskRequest {
  commonParam?: {
    alarmFlag?: string(name='AlarmFlag', example='1'),
    alertList?: [ 
      {
        isCritical?: long(name='IsCritical', example='true'),
        name?: string(name='Name', example='PING_SET'),
        symbols?: long(name='Symbols', example='1'),
      }
    ](name='AlertList'),
    alertNotifierId?: string(name='AlertNotifierId', example='123'),
    alertPolicyId?: string(name='AlertPolicyId', example='1234'),
    monitorSamples?: long(name='MonitorSamples', example='0'),
    startExecutionTime?: long(name='StartExecutionTime', example='2022-07-20 10'),
  }(name='CommonParam'),
  download?: {
    connectionTimeout?: double(name='ConnectionTimeout', example='200'),
    downloadCustomHeaderContent?: string(name='DownloadCustomHeaderContent'),
    downloadCustomHost?: long(name='DownloadCustomHost', example='1'),
    downloadCustomHostIp?: string(name='DownloadCustomHostIp', example='ipv4:192.168.2.1,192.168.2.5:img.a.com|192.168.2.1[8080]:img.a.com'),
    downloadIgnoreCertificateError?: string(name='DownloadIgnoreCertificateError'),
    downloadKernel?: long(name='DownloadKernel', example='1'),
    downloadRedirection?: long(name='DownloadRedirection'),
    downloadTransmissionSize?: long(name='DownloadTransmissionSize'),
    monitorTimeout?: long(name='MonitorTimeout'),
    quickProtocol?: string(name='QuickProtocol', example='1'),
    validateKeywords?: string(name='ValidateKeywords'),
    verifyWay?: long(name='VerifyWay', example='0'),
    whiteList?: string(name='WhiteList', example='[{\\"src\\":\\"211.154.166.174\\"}]'),
  }(name='Download'),
  extendInterval?: {
    days?: [ long ](name='Days'),
    endHour?: long(name='EndHour', example='23'),
    endMinute?: long(name='EndMinute', example='00'),
    endTime?: string(name='EndTime', example='2022-08-20 10'),
    startHour?: long(name='StartHour', example='00'),
    startMinute?: long(name='StartMinute', example='00'),
    startTime?: string(name='StartTime', example='2022-07-20 10'),
  }(name='ExtendInterval'),
  intervalTime?: string(name='IntervalTime', example='5'),
  intervalType?: string(name='IntervalType', example='0'),
  ipType?: long(name='IpType', example='0'),
  monitorList?: [ 
    {
      cityCode?: long(name='CityCode', example='1100101'),
      monitorType?: long(name='MonitorType', example='IDC'),
      netServiceId?: long(name='NetServiceId', example='18'),
    }
  ](name='MonitorList'),
  navigation?: {
    DNSHijackWhiteList?: string(name='DNSHijackWhiteList'),
    elementBlacklist?: string(name='ElementBlacklist'),
    executeActiveX?: long(name='ExecuteActiveX', example='3'),
    executeApplication?: long(name='ExecuteApplication', example='1'),
    executeScript?: long(name='ExecuteScript', example='1'),
    filterInvalidIP?: long(name='FilterInvalidIP', example='1'),
    flowHijackJumpTimes?: long(name='FlowHijackJumpTimes'),
    flowHijackLogo?: string(name='FlowHijackLogo'),
    monitorTimeout?: string(name='MonitorTimeout', example='20'),
    navAutomaticScrolling?: string(name='NavAutomaticScrolling', example='1'),
    navCustomHeader?: string(name='NavCustomHeader', example='0'),
    navCustomHeaderContent?: string(name='NavCustomHeaderContent', example='Host:www.example.com|Referer:www.example.com'),
    navCustomHost?: long(name='NavCustomHost', example='1'),
    navCustomHostIp?: string(name='NavCustomHostIp', example='ipv4:192.168.2.1,192.168.2.5:img.a.com|192.168.2.1[8080]:img.a.com'),
    navDisableCache?: long(name='NavDisableCache', example='1'),
    navDisableCompression?: string(name='NavDisableCompression', example='1'),
    navIgnoreCertificateError?: long(name='NavIgnoreCertificateError', example='1'),
    navRedirection?: long(name='NavRedirection', example='1'),
    navReturnElement?: long(name='NavReturnElement', example='2'),
    pageTamper?: string(name='PageTamper'),
    processName?: string(name='ProcessName', example='ssh'),
    QUICDomain?: string(name='QUICDomain', example='www.example.com'),
    QUICVersion?: long(name='QUICVersion', example='0'),
    requestHeader?: long(name='RequestHeader', example='0'),
    responseHeader?: long(name='ResponseHeader', example='0'),
    slowElementThreshold?: double(name='SlowElementThreshold', example='5'),
    verifyStringBlacklist?: string(name='VerifyStringBlacklist'),
    verifyStringWhiteList?: string(name='VerifyStringWhiteList'),
    waitCompletionTime?: double(name='WaitCompletionTime'),
  }(name='Navigation'),
  net?: {
    netDNSNs?: string(name='NetDNSNs', example='114.114.XX.XX'),
    netDNSQueryMethod?: long(name='NetDNSQueryMethod', example='1'),
    netDNSServer?: long(name='NetDNSServer', example='0'),
    netDNSSwitch?: long(name='NetDNSSwitch', example='1'),
    netDNSTimeout?: long(name='NetDNSTimeout', example='5'),
    netDigSwitch?: long(name='NetDigSwitch', example='0'),
    netICMPActive?: long(name='NetICMPActive', example='0'),
    netICMPDataCut?: long(name='NetICMPDataCut', example='0'),
    netICMPInterval?: long(name='NetICMPInterval', example='1'),
    netICMPNum?: long(name='NetICMPNum', example='4'),
    netICMPSize?: long(name='NetICMPSize', example='32'),
    netICMPSwitch?: long(name='NetICMPSwitch', example='1'),
    netICMPTimeout?: long(name='NetICMPTimeout'),
    netTraceRouteNum?: long(name='NetTraceRouteNum', example='20'),
    netTraceRouteSwitch?: long(name='NetTraceRouteSwitch', example='1'),
    netTraceRouteTimeout?: long(name='NetTraceRouteTimeout', example='60'),
    whiteList?: string(name='WhiteList', example='www.aliyun.com:202.0.3.55|203.3.44.67'),
  }(name='Net'),
  protocol?: {
    characterEncoding?: long(name='CharacterEncoding', example='0'),
    customHost?: long(name='CustomHost', example='1'),
    customHostIp?: string(name='CustomHostIp', example='ipv4:192.168.2.1,192.168.2.5:img.a.com|192.168.2.1[8080]:img.a.com'),
    protocolConnectionTime?: long(name='ProtocolConnectionTime', example='3'),
    protocolMonitorTimeout?: string(name='ProtocolMonitorTimeout', example='30'),
    receivedDataSize?: long(name='ReceivedDataSize'),
    requestContent?: {
      body?: {
        formData?: [ 
          {
            key?: string(name='Key', example='appId'),
            value?: string(name='Value', example='3425'),
          }
        ](name='FormData'),
        language?: string(name='Language', example='json'),
        mode?: string(name='Mode', example='form-data'),
        raw?: string(name='Raw', example='content'),
        urlEncoding?: [ 
          {
            key?: string(name='Key', example='appId'),
            value?: string(name='Value', example='11080'),
          }
        ](name='UrlEncoding'),
      }(name='Body'),
      header?: [ 
        {
          key?: string(name='Key', example='regionId'),
          value?: string(name='Value', example='cn-hangzhou'),
        }
      ](name='Header'),
      method?: string(name='Method', example='POST'),
    }(name='RequestContent'),
    verifyContent?: string(name='VerifyContent'),
    verifyWay?: long(name='VerifyWay', example='0'),
  }(name='Protocol'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  taskName?: string(name='TaskName'),
  taskType?: long(name='TaskType', example='0'),
  updateTask?: boolean(name='UpdateTask', example='false'),
  url?: string(name='Url', example='https://www.example.com'),
}

model CreateSyntheticTaskShrinkRequest {
  commonParamShrink?: string(name='CommonParam'),
  downloadShrink?: string(name='Download'),
  extendIntervalShrink?: string(name='ExtendInterval'),
  intervalTime?: string(name='IntervalTime', example='5'),
  intervalType?: string(name='IntervalType', example='0'),
  ipType?: long(name='IpType', example='0'),
  monitorListShrink?: string(name='MonitorList'),
  navigationShrink?: string(name='Navigation'),
  netShrink?: string(name='Net'),
  protocolShrink?: string(name='Protocol'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  taskName?: string(name='TaskName'),
  taskType?: long(name='TaskType', example='0'),
  updateTask?: boolean(name='UpdateTask', example='false'),
  url?: string(name='Url', example='https://www.example.com'),
}

model CreateSyntheticTaskResponseBody = {
  code?: string(name='Code', example='1001'),
  data?: {
    taskId?: long(name='TaskId', example='1234'),
  }(name='Data'),
  msg?: string(name='Msg', example='null'),
  requestId?: string(name='RequestId', example='A5EC8221-08F2-4C95-9AF1-49FD998C****'),
}

model CreateSyntheticTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSyntheticTaskResponseBody(name='body'),
}

async function createSyntheticTaskWithOptions(tmpReq: CreateSyntheticTaskRequest, runtime: Util.RuntimeOptions): CreateSyntheticTaskResponse {
  Util.validateModel(tmpReq);
  var request = new CreateSyntheticTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.commonParam)) {
    request.commonParamShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.commonParam, 'CommonParam', 'json');
  }
  if (!Util.isUnset(tmpReq.download)) {
    request.downloadShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.download, 'Download', 'json');
  }
  if (!Util.isUnset(tmpReq.extendInterval)) {
    request.extendIntervalShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extendInterval, 'ExtendInterval', 'json');
  }
  if (!Util.isUnset(tmpReq.monitorList)) {
    request.monitorListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.monitorList, 'MonitorList', 'json');
  }
  if (!Util.isUnset(tmpReq.navigation)) {
    request.navigationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.navigation, 'Navigation', 'json');
  }
  if (!Util.isUnset(tmpReq.net)) {
    request.netShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.net, 'Net', 'json');
  }
  if (!Util.isUnset(tmpReq.protocol)) {
    request.protocolShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.protocol, 'Protocol', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.commonParamShrink)) {
    query['CommonParam'] = request.commonParamShrink;
  }
  if (!Util.isUnset(request.downloadShrink)) {
    query['Download'] = request.downloadShrink;
  }
  if (!Util.isUnset(request.extendIntervalShrink)) {
    query['ExtendInterval'] = request.extendIntervalShrink;
  }
  if (!Util.isUnset(request.intervalTime)) {
    query['IntervalTime'] = request.intervalTime;
  }
  if (!Util.isUnset(request.intervalType)) {
    query['IntervalType'] = request.intervalType;
  }
  if (!Util.isUnset(request.ipType)) {
    query['IpType'] = request.ipType;
  }
  if (!Util.isUnset(request.monitorListShrink)) {
    query['MonitorList'] = request.monitorListShrink;
  }
  if (!Util.isUnset(request.navigationShrink)) {
    query['Navigation'] = request.navigationShrink;
  }
  if (!Util.isUnset(request.netShrink)) {
    query['Net'] = request.netShrink;
  }
  if (!Util.isUnset(request.protocolShrink)) {
    query['Protocol'] = request.protocolShrink;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  if (!Util.isUnset(request.updateTask)) {
    query['UpdateTask'] = request.updateTask;
  }
  if (!Util.isUnset(request.url)) {
    query['Url'] = request.url;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSyntheticTask',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSyntheticTask(request: CreateSyntheticTaskRequest): CreateSyntheticTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSyntheticTaskWithOptions(request, runtime);
}

model CreateWebhookRequest {
  body?: string(name='Body', description='The notification template that is sent when an alert is triggered. This parameter is required if the **Method** parameter is set to **Post**. You can use the $content placeholder to specify the notification content. The content cannot exceed 500 characters in length.'),
  contactName?: string(name='ContactName', description='The name of the contact.'),
  httpHeaders?: string(name='HttpHeaders', description='The HTTP request header.', example='[{"Content-Type":"application/json"}]'),
  httpParams?: string(name='HttpParams', description='The parameters in the HTTP request.', example='[{"name":"mike"}]'),
  method?: string(name='Method', description='The HTTP request method.

*   `Get`
*   `Post`', example='Post'),
  recoverBody?: string(name='RecoverBody', description='The notification template that is sent when an alert is resolved. This parameter is required if the **Method** parameter is set to **Post**. You can use the $content placeholder to specify the notification content. The content cannot exceed 500 characters in length.'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  url?: string(name='Url', description='The URL of the request **method**.', example='https://oapi.dingtalk.com/robot/send?access_token=e1a049121ddbfce1ca963d115ef88cc7219583c4fb79fe6e398fbfb688******'),
}

model CreateWebhookResponseBody = {
  contactId?: string(name='ContactId', description='The ID of the contact for webhook alerts.', example='48716'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='16AF921B-8187-489F-9913-43C808B4****'),
}

model CreateWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateWebhookResponseBody(name='body'),
}

async function createWebhookWithOptions(request: CreateWebhookRequest, runtime: Util.RuntimeOptions): CreateWebhookResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.body)) {
    query['Body'] = request.body;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.httpHeaders)) {
    query['HttpHeaders'] = request.httpHeaders;
  }
  if (!Util.isUnset(request.httpParams)) {
    query['HttpParams'] = request.httpParams;
  }
  if (!Util.isUnset(request.method)) {
    query['Method'] = request.method;
  }
  if (!Util.isUnset(request.recoverBody)) {
    query['RecoverBody'] = request.recoverBody;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.url)) {
    query['Url'] = request.url;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateWebhook',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createWebhook(request: CreateWebhookRequest): CreateWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  return createWebhookWithOptions(request, runtime);
}

model DelAuthTokenRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model DelAuthTokenResponseBody = {
  data?: string(name='Data', description='Indicates whether the request was successful.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A5EC8221-08F2-4C95-9AF1-49FD998C647A'),
}

model DelAuthTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DelAuthTokenResponseBody(name='body'),
}

async function delAuthTokenWithOptions(request: DelAuthTokenRequest, runtime: Util.RuntimeOptions): DelAuthTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DelAuthToken',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function delAuthToken(request: DelAuthTokenRequest): DelAuthTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return delAuthTokenWithOptions(request, runtime);
}

model DeleteAlertContactRequest {
  contactId?: long(name='ContactId', example='123'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model DeleteAlertContactResponseBody = {
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='78901766-3806-4E96-8E47-CFEF59E4****'),
}

model DeleteAlertContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAlertContactResponseBody(name='body'),
}

/**
  * ********
  *
  * @param request DeleteAlertContactRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteAlertContactResponse
 */
async function deleteAlertContactWithOptions(request: DeleteAlertContactRequest, runtime: Util.RuntimeOptions): DeleteAlertContactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactId)) {
    query['ContactId'] = request.contactId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlertContact',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ********
  *
  * @param request DeleteAlertContactRequest
  * @return DeleteAlertContactResponse
 */
async function deleteAlertContact(request: DeleteAlertContactRequest): DeleteAlertContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlertContactWithOptions(request, runtime);
}

model DeleteAlertContactGroupRequest {
  contactGroupId?: long(name='ContactGroupId', example='123'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model DeleteAlertContactGroupResponseBody = {
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='C21AB7CF-B7AF-410F-BD61-82D1567F****'),
}

model DeleteAlertContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAlertContactGroupResponseBody(name='body'),
}

/**
  * ********
  *
  * @param request DeleteAlertContactGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteAlertContactGroupResponse
 */
async function deleteAlertContactGroupWithOptions(request: DeleteAlertContactGroupRequest, runtime: Util.RuntimeOptions): DeleteAlertContactGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupId)) {
    query['ContactGroupId'] = request.contactGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlertContactGroup',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ********
  *
  * @param request DeleteAlertContactGroupRequest
  * @return DeleteAlertContactGroupResponse
 */
async function deleteAlertContactGroup(request: DeleteAlertContactGroupRequest): DeleteAlertContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlertContactGroupWithOptions(request, runtime);
}

model DeleteAlertRuleRequest {
  alertId?: long(name='AlertId', description='The ID of the alert rule.', example='123'),
}

model DeleteAlertRuleResponseBody = {
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the alert rule was successfully deleted.

*   `true`: The specified data is deleted.
*   `false`: The specified data fails to be deleted.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C21AB7CF-B7AF-410F-BD61-82D1567F****'),
}

model DeleteAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAlertRuleResponseBody(name='body'),
}

async function deleteAlertRuleWithOptions(request: DeleteAlertRuleRequest, runtime: Util.RuntimeOptions): DeleteAlertRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlertRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAlertRule(request: DeleteAlertRuleRequest): DeleteAlertRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlertRuleWithOptions(request, runtime);
}

model DeleteAlertRulesRequest {
  alertIds?: string(name='AlertIds', description='The IDs of the alert rules that you want to delete. The value is a JSON array, for example, `[123, 234]`. You can call the SearchAlertRules operation and view the `Id` parameter in the response parameters. For more information, see [SearchAlertRules](https://www.alibabacloud.com/help/en/application-real-time-monitoring-service/latest/searchalertrules).', example='[123, 234]'),
  regionId?: string(name='RegionId', description='The ID of the region. Default value: `cn-hangzhou`.', example='cn-hangzhou'),
}

model DeleteAlertRulesResponseBody = {
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the alert rule was deleted.

*   `true`: The alert rule was deleted.
*   `false`: The alert rule failed to be deleted.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C21AB7CF-B7AF-410F-BD61-82D1567F****'),
}

model DeleteAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAlertRulesResponseBody(name='body'),
}

/**
  * ****
  *
  * @param request DeleteAlertRulesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteAlertRulesResponse
 */
async function deleteAlertRulesWithOptions(request: DeleteAlertRulesRequest, runtime: Util.RuntimeOptions): DeleteAlertRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertIds)) {
    query['AlertIds'] = request.alertIds;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlertRules',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ****
  *
  * @param request DeleteAlertRulesRequest
  * @return DeleteAlertRulesResponse
 */
async function deleteAlertRules(request: DeleteAlertRulesRequest): DeleteAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlertRulesWithOptions(request, runtime);
}

model DeleteCmsExporterRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model DeleteCmsExporterResponseBody = {
  data?: string(name='Data', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='27E653FA-5958-45BE-8AA9-14D884DC****'),
}

model DeleteCmsExporterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCmsExporterResponseBody(name='body'),
}

async function deleteCmsExporterWithOptions(request: DeleteCmsExporterRequest, runtime: Util.RuntimeOptions): DeleteCmsExporterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCmsExporter',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCmsExporter(request: DeleteCmsExporterRequest): DeleteCmsExporterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCmsExporterWithOptions(request, runtime);
}

model DeleteContactRequest {
  contactId?: long(name='ContactId', description='The ID of the alert contact.', example='123'),
}

model DeleteContactResponseBody = {
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the alert contact was successfully deleted.

*   `true`: The specified data is deleted.
*   `false`: The specified data fails to be deleted.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C21AB7CF-B7AF-410F-BD61-82D1567F****'),
}

model DeleteContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteContactResponseBody(name='body'),
}

async function deleteContactWithOptions(request: DeleteContactRequest, runtime: Util.RuntimeOptions): DeleteContactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactId)) {
    query['ContactId'] = request.contactId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteContact',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteContact(request: DeleteContactRequest): DeleteContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContactWithOptions(request, runtime);
}

model DeleteContactGroupRequest {
  contactGroupId?: long(name='ContactGroupId', description='The ID of the alert contact group.', example='123'),
}

model DeleteContactGroupResponseBody = {
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the alert contact group was successfully deleted.

*   `true`: The specified data is deleted.
*   `false`: The specified data fails to be deleted.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C21AB7CF-B7AF-410F-BD61-82D1567F****'),
}

model DeleteContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteContactGroupResponseBody(name='body'),
}

async function deleteContactGroupWithOptions(request: DeleteContactGroupRequest, runtime: Util.RuntimeOptions): DeleteContactGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupId)) {
    query['ContactGroupId'] = request.contactGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteContactGroup',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteContactGroup(request: DeleteContactGroupRequest): DeleteContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContactGroupWithOptions(request, runtime);
}

model DeleteDispatchRuleRequest {
  id?: string(name='Id', description='The ID of the dispatch policy.', example='12345'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model DeleteDispatchRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16AF921B-8187-489F-9913-43C808B4****'),
  success?: boolean(name='Success', description='Indicates whether the request is successful.

*   `true`: successful
*   `false`: failed', example='true'),
}

model DeleteDispatchRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDispatchRuleResponseBody(name='body'),
}

/**
  * ********
  *
  * @param request DeleteDispatchRuleRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDispatchRuleResponse
 */
async function deleteDispatchRuleWithOptions(request: DeleteDispatchRuleRequest, runtime: Util.RuntimeOptions): DeleteDispatchRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDispatchRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ********
  *
  * @param request DeleteDispatchRuleRequest
  * @return DeleteDispatchRuleResponse
 */
async function deleteDispatchRule(request: DeleteDispatchRuleRequest): DeleteDispatchRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDispatchRuleWithOptions(request, runtime);
}

model DeleteEventBridgeIntegrationRequest {
  id?: long(name='Id', description='The ID of the EventBridge integration.', example='123'),
}

model DeleteEventBridgeIntegrationResponseBody = {
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the EventBridge integration is deleted.

*   `true`: The EventBridge integration is deleted.
*   `false`: The EventBridge integration fails to be deleted.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2B289756-E791-5842-BCBD-AD414C******'),
}

model DeleteEventBridgeIntegrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEventBridgeIntegrationResponseBody(name='body'),
}

async function deleteEventBridgeIntegrationWithOptions(request: DeleteEventBridgeIntegrationRequest, runtime: Util.RuntimeOptions): DeleteEventBridgeIntegrationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEventBridgeIntegration',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEventBridgeIntegration(request: DeleteEventBridgeIntegrationRequest): DeleteEventBridgeIntegrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventBridgeIntegrationWithOptions(request, runtime);
}

model DeleteGrafanaResourceRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  clusterName?: string(name='ClusterName', description='The name of the cluster.', example='clusterNameOfTest'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model DeleteGrafanaResourceResponseBody = {
  data?: string(name='Data', description='The returned message.', example='delete success.'),
  requestId?: string(name='RequestId', description='The ID of the request. You can use the ID to query logs and troubleshoot issues.', example='771DC66C-C5E0-59BC-A983-DD18FEE9EFFA'),
}

model DeleteGrafanaResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGrafanaResourceResponseBody(name='body'),
}

async function deleteGrafanaResourceWithOptions(request: DeleteGrafanaResourceRequest, runtime: Util.RuntimeOptions): DeleteGrafanaResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    body['ClusterName'] = request.clusterName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGrafanaResource',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGrafanaResource(request: DeleteGrafanaResourceRequest): DeleteGrafanaResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGrafanaResourceWithOptions(request, runtime);
}

model DeleteIMRobotRequest {
  robotId?: long(name='RobotId', description='The ID of the IM bot.', example='123'),
}

model DeleteIMRobotResponseBody = {
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the IM bot was successfully deleted.

*   `true`: The specified data is deleted.
*   `false`: The specified data fails to be deleted.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C21AB7CF-B7AF-410F-BD61-82D1567F****'),
}

model DeleteIMRobotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIMRobotResponseBody(name='body'),
}

async function deleteIMRobotWithOptions(request: DeleteIMRobotRequest, runtime: Util.RuntimeOptions): DeleteIMRobotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.robotId)) {
    query['RobotId'] = request.robotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIMRobot',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIMRobot(request: DeleteIMRobotRequest): DeleteIMRobotResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIMRobotWithOptions(request, runtime);
}

model DeleteIntegrationRequest {
  clusterId?: string(name='ClusterId', description='The ID of the Container Service for Kubernetes cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  integration?: string(name='Integration', description='The abbreviation of the software that is supported by Application Real-Time Monitoring Service (ARMS). Valid values (case-insensitive): `ASM`, `IoT`, and `Flink`.', example='asm'),
  regionId?: string(name='RegionId', description='The region ID of the ARMS instance.', example='cn-hangzhou'),
}

model DeleteIntegrationResponseBody = {
  data?: string(name='Data', description='Indicates whether the call was successful.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1A9C645C-C83F-4C9D-8CCB-29BEC9E1****'),
}

model DeleteIntegrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIntegrationResponseBody(name='body'),
}

async function deleteIntegrationWithOptions(request: DeleteIntegrationRequest, runtime: Util.RuntimeOptions): DeleteIntegrationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.integration)) {
    query['Integration'] = request.integration;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIntegration',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIntegration(request: DeleteIntegrationRequest): DeleteIntegrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIntegrationWithOptions(request, runtime);
}

model DeleteIntegrationsRequest {
  integrationId?: long(name='IntegrationId', description='The ID of the alert integration.', example='1234'),
}

model DeleteIntegrationsResponseBody = {
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the alert integration was deleted. Valid values:

*   true
*   false', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='34ED024E-9E31-434A-9E4E-D9D15C3****'),
}

model DeleteIntegrationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIntegrationsResponseBody(name='body'),
}

async function deleteIntegrationsWithOptions(request: DeleteIntegrationsRequest, runtime: Util.RuntimeOptions): DeleteIntegrationsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIntegrations',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIntegrations(request: DeleteIntegrationsRequest): DeleteIntegrationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIntegrationsWithOptions(request, runtime);
}

model DeleteNotificationPolicyRequest {
  id?: long(name='Id', description='The ID of the notification policy.', example='1234'),
}

model DeleteNotificationPolicyResponseBody = {
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the notification policy was deleted successfully. Valid values:

*   `true`: The notification policy was deleted successfully.
*   `false`: The notification policy failed to be deleted.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A5EC8221-08F2-4C95-9AF1-49FD998C****'),
}

model DeleteNotificationPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNotificationPolicyResponseBody(name='body'),
}

async function deleteNotificationPolicyWithOptions(request: DeleteNotificationPolicyRequest, runtime: Util.RuntimeOptions): DeleteNotificationPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNotificationPolicy',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNotificationPolicy(request: DeleteNotificationPolicyRequest): DeleteNotificationPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNotificationPolicyWithOptions(request, runtime);
}

model DeletePrometheusAlertRuleRequest {
  alertId?: long(name='AlertId', description='The ID of the alert rule. You can call the ListPrometheusAlertRules operation to query the ID of the alert rule.', example='3888704'),
}

model DeletePrometheusAlertRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='9FEA6D00-317F-45E3-9004-7FB8B0B7****'),
  success?: boolean(name='Success', description='Indicates whether the alert rule was deleted. Valid values:

*   `true`: The alert rule was deleted.
*   `false`: The alert rule failed to be deleted.', example='true'),
}

model DeletePrometheusAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePrometheusAlertRuleResponseBody(name='body'),
}

async function deletePrometheusAlertRuleWithOptions(request: DeletePrometheusAlertRuleRequest, runtime: Util.RuntimeOptions): DeletePrometheusAlertRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePrometheusAlertRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePrometheusAlertRule(request: DeletePrometheusAlertRuleRequest): DeletePrometheusAlertRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePrometheusAlertRuleWithOptions(request, runtime);
}

model DeletePrometheusGlobalViewRequest {
  globalViewClusterId?: string(name='GlobalViewClusterId', description='The ID of the aggregation instance.', example='global-v2-cn-1670100631025794-amaykca4'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model DeletePrometheusGlobalViewResponseBody = {
  data?: string(name='Data', description='The response parameters in the JSON format.', example='{"Success":true,"Msg":"OK"}'),
  requestId?: string(name='RequestId', description='The ID of the request. You can use the ID to query logs and troubleshoot issues.', example='337B8F7E-0A64-5768-9225-E9B3CF******'),
}

model DeletePrometheusGlobalViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePrometheusGlobalViewResponseBody(name='body'),
}

async function deletePrometheusGlobalViewWithOptions(request: DeletePrometheusGlobalViewRequest, runtime: Util.RuntimeOptions): DeletePrometheusGlobalViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalViewClusterId)) {
    query['GlobalViewClusterId'] = request.globalViewClusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePrometheusGlobalView',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePrometheusGlobalView(request: DeletePrometheusGlobalViewRequest): DeletePrometheusGlobalViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePrometheusGlobalViewWithOptions(request, runtime);
}

model DeletePrometheusRemoteWriteRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  remoteWriteNames?: string(name='RemoteWriteNames', example='name1,name2'),
}

model DeletePrometheusRemoteWriteResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeletePrometheusRemoteWriteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePrometheusRemoteWriteResponseBody(name='body'),
}

async function deletePrometheusRemoteWriteWithOptions(request: DeletePrometheusRemoteWriteRequest, runtime: Util.RuntimeOptions): DeletePrometheusRemoteWriteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.remoteWriteNames)) {
    query['RemoteWriteNames'] = request.remoteWriteNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePrometheusRemoteWrite',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePrometheusRemoteWrite(request: DeletePrometheusRemoteWriteRequest): DeletePrometheusRemoteWriteResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePrometheusRemoteWriteWithOptions(request, runtime);
}

model DeleteRetcodeAppRequest {
  appId?: string(name='AppId', description='The ID of the application.', example='1231'),
  appName?: string(name='AppName'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model DeleteRetcodeAppResponseBody = {
  data?: string(name='Data', description='Indicates whether the browser monitoring task was deleted. Valid values:

*   `true`: The browser monitoring task was deleted.
*   `false`: The browser monitoring task failed to be deleted.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='01FF8DD9-A09C-47A1-895A-B6E321BE77B6'),
}

model DeleteRetcodeAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRetcodeAppResponseBody(name='body'),
}

async function deleteRetcodeAppWithOptions(request: DeleteRetcodeAppRequest, runtime: Util.RuntimeOptions): DeleteRetcodeAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRetcodeApp',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRetcodeApp(request: DeleteRetcodeAppRequest): DeleteRetcodeAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRetcodeAppWithOptions(request, runtime);
}

model DeleteScenarioRequest {
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-zhangjaikou'),
  scenarioId?: long(name='ScenarioId', description='The ID of the business monitoring job. You can obtain the ID by calling the ListScenario operation.', example='132'),
}

model DeleteScenarioResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='EA24D522-AD35-47B8-8CB2-ADBC382B****'),
  result?: boolean(name='Result', description='Indicates whether the request is successful.

*   `true`: successful
*   `false`: failed', example='true'),
}

model DeleteScenarioResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteScenarioResponseBody(name='body'),
}

async function deleteScenarioWithOptions(request: DeleteScenarioRequest, runtime: Util.RuntimeOptions): DeleteScenarioResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.scenarioId)) {
    query['ScenarioId'] = request.scenarioId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteScenario',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteScenario(request: DeleteScenarioRequest): DeleteScenarioResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteScenarioWithOptions(request, runtime);
}

model DeleteSilencePolicyRequest {
  id?: long(name='Id', description='The ID of the silence policy.', example='1234'),
}

model DeleteSilencePolicyResponseBody = {
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the silence policy was deleted successfully. Valid values:

*   `true`: The silence policy was deleted successfully.
*   `false`: The silence policy failed to be deleted.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A5EC8221-08F2-4C95-9AF1-49FD998C****'),
}

model DeleteSilencePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSilencePolicyResponseBody(name='body'),
}

async function deleteSilencePolicyWithOptions(request: DeleteSilencePolicyRequest, runtime: Util.RuntimeOptions): DeleteSilencePolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSilencePolicy',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSilencePolicy(request: DeleteSilencePolicyRequest): DeleteSilencePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSilencePolicyWithOptions(request, runtime);
}

model DeleteSourceMapRequest {
  fidList?: [ string ](name='FidList', description='The IDs of the SourceMap files.'),
  pid?: string(name='Pid', description='The process identifier (PID) of the application.', example='atc889zkcf@d8deedfa9bf****'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model DeleteSourceMapShrinkRequest {
  fidListShrink?: string(name='FidList', description='The IDs of the SourceMap files.'),
  pid?: string(name='Pid', description='The process identifier (PID) of the application.', example='atc889zkcf@d8deedfa9bf****'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model DeleteSourceMapResponseBody = {
  data?: string(name='Data', description='Indicates whether the SourceMap files are deleted. Valid values:

*   success: The SourceMap files are deleted.
*   false: The SourceMap files fail to be deleted.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1A9C645C-C83F-4C9D-8CCB-29BEC9E1****'),
}

model DeleteSourceMapResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSourceMapResponseBody(name='body'),
}

async function deleteSourceMapWithOptions(tmpReq: DeleteSourceMapRequest, runtime: Util.RuntimeOptions): DeleteSourceMapResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteSourceMapShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.fidList)) {
    request.fidListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fidList, 'FidList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.fidListShrink)) {
    query['FidList'] = request.fidListShrink;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSourceMap',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSourceMap(request: DeleteSourceMapRequest): DeleteSourceMapResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSourceMapWithOptions(request, runtime);
}

model DeleteSyntheticTaskRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  taskIds?: [ string ](name='TaskIds'),
}

model DeleteSyntheticTaskResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='1A9C645C-C83F-4C9D-8CCB-29BEC9E1****'),
  result?: string(name='Result', example='true'),
}

model DeleteSyntheticTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSyntheticTaskResponseBody(name='body'),
}

async function deleteSyntheticTaskWithOptions(request: DeleteSyntheticTaskRequest, runtime: Util.RuntimeOptions): DeleteSyntheticTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskIds)) {
    query['TaskIds'] = request.taskIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSyntheticTask',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSyntheticTask(request: DeleteSyntheticTaskRequest): DeleteSyntheticTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSyntheticTaskWithOptions(request, runtime);
}

model DeleteTraceAppRequest {
  appId?: string(name='AppId', description='The ID of the application that you want to delete. You can call the SearchTraceAppByName operation to query the application ID. For more information, see [SearchTraceAppByName](~~130676~~).', example='5406**'),
  pid?: string(name='Pid', description='The PID of the application that you want to delete. For more information about how to obtain the PID, see [Obtain the PID of an application](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).', example='9w0sc5gxxz@edcsd447c2f****'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  type?: string(name='Type', description='The type of the application that you want to delete. You can call the SearchTraceAppByName operation to query the application type. For more information, see [SearchTraceAppByName](~~130676~~). Valid values:

*   `TRACE`: application monitoring
*   `RETCODE`: frontend monitoring', example='TRACE'),
}

model DeleteTraceAppResponseBody = {
  data?: string(name='Data', description='The response in JSON format, including the HTTP status code, error code, response message, and trace ID.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='46355DD8-FC56-40C5-BFC6-269DE4F9****'),
}

model DeleteTraceAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTraceAppResponseBody(name='body'),
}

async function deleteTraceAppWithOptions(request: DeleteTraceAppRequest, runtime: Util.RuntimeOptions): DeleteTraceAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTraceApp',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTraceApp(request: DeleteTraceAppRequest): DeleteTraceAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTraceAppWithOptions(request, runtime);
}

model DeleteWebhookContactRequest {
  webhookId?: long(name='WebhookId', description='The ID of the contact for webhook alerts.', example='123'),
}

model DeleteWebhookContactResponseBody = {
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the webhook alert contact was successfully deleted.

*   `true`: The specified data is deleted.
*   `false`: The specified data fails to be deleted.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C21AB7CF-B7AF-410F-BD61-82D1567F****'),
}

model DeleteWebhookContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteWebhookContactResponseBody(name='body'),
}

async function deleteWebhookContactWithOptions(request: DeleteWebhookContactRequest, runtime: Util.RuntimeOptions): DeleteWebhookContactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.webhookId)) {
    query['WebhookId'] = request.webhookId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWebhookContact',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWebhookContact(request: DeleteWebhookContactRequest): DeleteWebhookContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWebhookContactWithOptions(request, runtime);
}

model DescribeContactGroupsRequest {
  contactGroupName?: string(name='ContactGroupName', description='The name of the alert contact group.', example='TestGroup'),
  groupIds?: string(name='GroupIds'),
  isDetail?: boolean(name='IsDetail', description='Indicates whether all contacts are included in the returned contact group information.

*   `fasle` (default): does not return all contacts.
*   `true`: All contacts are returned.', example='true'),
  page?: long(name='Page', description='The number of pages to query.', example='1'),
  size?: long(name='Size', description='The number of contact groups displayed on each page.', example='20'),
}

model DescribeContactGroupsResponseBody = {
  pageBean?: {
    alertContactGroups?: [ 
      {
        armsContactGroupId?: long(name='ArmsContactGroupId'),
        contactGroupId?: float(name='ContactGroupId', description='The ID of the alert contact group.', example='123'),
        contactGroupName?: string(name='ContactGroupName', description='The name of the alert contact group.', example='TestGroup'),
        contacts?: [ 
          {
            armsContactId?: long(name='ArmsContactId'),
            contactId?: float(name='ContactId', description='The ID of the alert contact.', example='456'),
            contactName?: string(name='ContactName', description='The name of the contact.', example='John Doe'),
            email?: string(name='Email', description='The email address of the alert contact.', example='someone@example.com'),
            phone?: string(name='Phone', description='The mobile number of the alert contact.', example='1381111****'),
          }
        ](name='Contacts', description='The contact information. No **Contacts** is displayed when the **IsDetail** is set to `false`.'),
      }
    ](name='AlertContactGroups', description='The list of alert contact groups.'),
    page?: long(name='Page', description='The number of pages to query.', example='1'),
    size?: long(name='Size', description='The number of contact groups on each page.', example='20'),
    total?: long(name='Total', description='The total number of contact groups queried.', example='1'),
  }(name='PageBean', description='Paging object.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4D6C358A-A58B-4F4B-94CE-F5AAF023****'),
}

model DescribeContactGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContactGroupsResponseBody(name='body'),
}

async function describeContactGroupsWithOptions(request: DescribeContactGroupsRequest, runtime: Util.RuntimeOptions): DescribeContactGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupName)) {
    query['ContactGroupName'] = request.contactGroupName;
  }
  if (!Util.isUnset(request.groupIds)) {
    query['GroupIds'] = request.groupIds;
  }
  if (!Util.isUnset(request.isDetail)) {
    query['IsDetail'] = request.isDetail;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContactGroups',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContactGroups(request: DescribeContactGroupsRequest): DescribeContactGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContactGroupsWithOptions(request, runtime);
}

model DescribeContactsRequest {
  contactIds?: string(name='ContactIds'),
  contactName?: string(name='ContactName', description='The name of the alert contact.', example='John Doe'),
  email?: string(name='Email', description='The email address of the alert contact.', example='someone@example.com'),
  page?: long(name='Page', description='The number of the page to return.', example='1'),
  phone?: string(name='Phone', description='The mobile number of the alert contact.', example='1381111*****'),
  size?: long(name='Size', description='The number of alert contacts to return on each page.', example='20'),
  verbose?: string(name='Verbose'),
}

model DescribeContactsResponseBody = {
  pageBean?: {
    alertContacts?: [ 
      {
        armsContactId?: long(name='ArmsContactId'),
        contactId?: float(name='ContactId', description='The ID of the alert contact.', example='123'),
        contactName?: string(name='ContactName', description='The name of the alert contact.', example='John Doe'),
        email?: string(name='Email', description='The email address of the alert contact.', example='someone@example.com'),
        isEmailVerify?: boolean(name='IsEmailVerify'),
        isVerify?: boolean(name='IsVerify', description='Indicates whether the mobile number is verified. Valid values:

*   `false`: The mobile number is not verified.
*   `true`: The mobile number is verified.', example='false'),
        phone?: string(name='Phone', description='The mobile number of the alert contact.', example='1381111****'),
        reissueSendNotice?: long(name='ReissueSendNotice', description='The method to resend notifications if phone notifications fail. Valid values:

*   0: do not resend notifications
*   1: make a phone call again
*   2: send a text message
*   3 (default value): use the global default value', example='3'),
      }
    ](name='AlertContacts', description='The alert contacts.'),
    page?: long(name='Page', description='The page number of the returned page.', example='1'),
    size?: long(name='Size', description='The number of alert contacts returned per page.', example='20'),
    total?: long(name='Total', description='The total number of alert contacts.', example='1'),
  }(name='PageBean', description='The objects that were returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='21E85B16-75A6-429A-9F65-8AAC9A54****'),
}

model DescribeContactsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContactsResponseBody(name='body'),
}

async function describeContactsWithOptions(request: DescribeContactsRequest, runtime: Util.RuntimeOptions): DescribeContactsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactIds)) {
    query['ContactIds'] = request.contactIds;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.phone)) {
    query['Phone'] = request.phone;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  if (!Util.isUnset(request.verbose)) {
    query['Verbose'] = request.verbose;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContacts',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContacts(request: DescribeContactsRequest): DescribeContactsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContactsWithOptions(request, runtime);
}

model DescribeDispatchRuleRequest {
  id?: string(name='Id', description='The ID of the dispatch policy.', example='12345'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model DescribeDispatchRuleResponseBody = {
  dispatchRule?: {
    dispatchType?: string(name='DispatchType', example='CREATE_ALERT'),
    groupRules?: [ 
      {
        groupId?: long(name='GroupId', description='The ID of the group.', example='1'),
        groupInterval?: long(name='GroupInterval', description='The grouping interval.', example='15'),
        groupWaitTime?: long(name='GroupWaitTime', description='The waiting time for grouping.', example='10'),
        groupingFields?: [ string ](name='GroupingFields', description='The grouping fields.'),
        repeatInterval?: long(name='RepeatInterval', example='20'),
      }
    ](name='GroupRules', description='The information about groups.'),
    isRecover?: boolean(name='IsRecover', example='true'),
    labelMatchExpressionGrid?: {
      labelMatchExpressionGroups?: [ 
        {
          labelMatchExpressions?: [ 
            {
              key?: string(name='Key', description='The key of the tag of the dispatch rule. Valid values:

*   `_aliyun_arms_userid`: user ID
*   `_aliyun_arms_involvedObject_kind`: type of the associated object
*   `_aliyun_arms_involvedObject_id`: ID of the associated object
*   `_aliyun_arms_involvedObject_name`: name of the associated object
*   `_aliyun_arms_alert_name`: alert name
*   `_aliyun_arms_alert_rule_id`: alert rule ID
*   `_aliyun_arms_alert_type`: alert type
*   `_aliyun_arms_alert_level`: alert severity', example='_aliyun_arms_involvedObject_kind'),
              operator?: string(name='Operator', description='The operator used in the dispatch rule. Valid values:

*   `eq`: equals to.
*   `re`: matches a regular expression.', example='eq'),
              value?: string(name='Value', description='The value of the tag.', example='app'),
            }
          ](name='LabelMatchExpressions', description='The collection of conditions of the dispatch rule.'),
        }
      ](name='LabelMatchExpressionGroups', description='The collection of dispatch rules.'),
    }(name='LabelMatchExpressionGrid', description='The information about the dispatch rule.'),
    name?: string(name='Name', description='The name of the dispatch policy.', example='Prometheus Alert'),
    notifyRules?: [ 
      {
        notifyChannels?: [ string ](name='NotifyChannels', description='The notification method. Valid values:

- `dingTalk`
- `sms`
- `webhook`
- `email`
- `wechat`'),
        notifyObjects?: [ 
          {
            name?: string(name='Name', description='The name of the contact or contact group.', example='JohnDoe'),
            notifyObjectId?: string(name='NotifyObjectId', description='The ID of the contact or contact group.', example='1'),
            notifyType?: string(name='NotifyType', description='The type of the alert contact. Valid values:

- `CONTACT`: contact
- `CONTACT_GROUP`: contact group', example='CONTACT'),
          }
        ](name='NotifyObjects', description='The collection of alert contacts.'),
      }
    ](name='NotifyRules', description='The collection of notification methods.'),
    ruleId?: long(name='RuleId', description='The ID of the dispatch rule.', example='10282'),
    state?: string(name='State', description='Indicates whether the dispatch policy is enabled. Valid values: 

- `true`: enabled
- `false`: disabled', example='true'),
  }(name='DispatchRule', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='34ED024E-9E31-434A-9E4E-D9D15C3****'),
}

model DescribeDispatchRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDispatchRuleResponseBody(name='body'),
}

async function describeDispatchRuleWithOptions(request: DescribeDispatchRuleRequest, runtime: Util.RuntimeOptions): DescribeDispatchRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDispatchRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDispatchRule(request: DescribeDispatchRuleRequest): DescribeDispatchRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDispatchRuleWithOptions(request, runtime);
}

model DescribeIMRobotsRequest {
  page?: long(name='Page', description='The number of pages to query.', example='1'),
  robotIds?: string(name='RobotIds'),
  robotName?: string(name='RobotName', description='The name of the IM robot.'),
  size?: long(name='Size', description='The number of IM robots displayed on each page.', example='20'),
}

model DescribeIMRobotsResponseBody = {
  pageBean?: {
    alertIMRobots?: [ 
      {
        dailyNoc?: boolean(name='DailyNoc', description='Specifies whether to send daily statistics.

*   `false` (default): does not send statistics.
*   `true`: sends statistics.', example='true'),
        dailyNocTime?: string(name='DailyNocTime', description='The time when the daily statistics are sent. ARMS Alert Management sends the total number of alerts generated today, the number of resolved alerts, and the number of pending alerts at the specified time point.', example='09:30,17:30'),
        dingSignKey?: string(name='DingSignKey', example='******'),
        robotAddr?: string(name='RobotAddr', description='The webhook address of the IM bot.', example='https://oapi.dingtalk.com/robot/send?access_token=e1a049121******'),
        robotId?: float(name='RobotId', description='The ID of the IM bot.', example='123'),
        robotName?: string(name='RobotName', description='The name of the IM robot.'),
        type?: string(name='Type', description='IM Robot Type:

*   `dingding`: DingTalk robot.
*   `wechat`: Enterprise WeChat Robot.', example='dingding'),
      }
    ](name='AlertIMRobots', description='The details of the IM robot.'),
    page?: long(name='Page', description='The number of pages to query.', example='1'),
    size?: long(name='Size', description='Number of IM robots per page.', example='20'),
    total?: long(name='Total', description='The total number of IM robots queried.', example='1'),
  }(name='PageBean', description='Paging object.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4D6C358A-A58B-4F4B-94CE-F5AAF023****'),
}

model DescribeIMRobotsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIMRobotsResponseBody(name='body'),
}

async function describeIMRobotsWithOptions(request: DescribeIMRobotsRequest, runtime: Util.RuntimeOptions): DescribeIMRobotsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.robotIds)) {
    query['RobotIds'] = request.robotIds;
  }
  if (!Util.isUnset(request.robotName)) {
    query['RobotName'] = request.robotName;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIMRobots',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIMRobots(request: DescribeIMRobotsRequest): DescribeIMRobotsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIMRobotsWithOptions(request, runtime);
}

model DescribePrometheusAlertRuleRequest {
  alertId?: long(name='AlertId', description='The ID of the alert rule. You can call the ListPrometheusAlertRules operation to query the ID of the alert rule.', example='3888704'),
}

model DescribePrometheusAlertRuleResponseBody = {
  prometheusAlertRule?: {
    alertId?: long(name='AlertId', description='The ID of the alert rule.', example='3888704'),
    alertName?: string(name='AlertName', description='The name of the alert rule.', example='Prometheus_Alert'),
    annotations?: [ 
      {
        name?: string(name='Name', description='The name of the annotation.', example='message'),
        value?: string(name='Value', description='The value of the annotation.'),
      }
    ](name='Annotations', description='The annotations of the alert rule.'),
    clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c0bad479465464e1d8c1e641b0afb****'),
    dispatchRuleId?: long(name='DispatchRuleId', description='The ID of the notification policy. This parameter is returned if the **NotifyType** parameter is set to `DISPATCH_RULE`.', example='10282'),
    duration?: string(name='Duration', description='The duration of the alert. Valid values: 1 to 1440. Unit: minutes.', example='1m'),
    expression?: string(name='Expression', description='The expression of the alert rule.', example='100 * (sum(rate(container_cpu_usage_seconds_total[1m])) by (pod_name) / sum(label_replace(kube_pod_container_resource_limits_cpu_cores, \\"pod_name\\", \\"$1\\", \\"pod\\", \\"(.*)\\")) by (pod_name))>75'),
    labels?: [ 
      {
        name?: string(name='Name', description='The name of the tag.', example='severity'),
        value?: string(name='Value', description='The value of the tag.', example='critical'),
      }
    ](name='Labels', description='The tags of the alert rule.'),
    message?: string(name='Message', description='The message of the alert notification. Tags can be referenced in the {{$labels.xxx}} format.'),
    notifyType?: string(name='NotifyType', description='The method of that is used to send alert notifications. Valid values:

*   `ALERT_MANAGER`: Alert notifications are sent by Operation Center.
*   `DISPATCH_RULE`: Alert notifications are sent based on the specified notification policy.', example='ALERT_MANAGER'),
    status?: int32(name='Status', description='Indicates whether the alert rule is enabled. Valid values:

*   `1`: The alert rule is enabled.
*   `0`: The alert rule is disabled.', example='1'),
    type?: string(name='Type', description='The type of the alert rule.'),
  }(name='PrometheusAlertRule', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9FEA6D00-317F-45E3-9004-7FB8B0B7****'),
}

model DescribePrometheusAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePrometheusAlertRuleResponseBody(name='body'),
}

async function describePrometheusAlertRuleWithOptions(request: DescribePrometheusAlertRuleRequest, runtime: Util.RuntimeOptions): DescribePrometheusAlertRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePrometheusAlertRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePrometheusAlertRule(request: DescribePrometheusAlertRuleRequest): DescribePrometheusAlertRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePrometheusAlertRuleWithOptions(request, runtime);
}

model DescribeTraceLicenseKeyRequest {
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model DescribeTraceLicenseKeyResponseBody = {
  licenseKey?: string(name='LicenseKey', description='The license key for the application.', example='b590lhguqs@3a75d95f218****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='29053944-6FE5-4240-8927-10095ECE****'),
}

model DescribeTraceLicenseKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTraceLicenseKeyResponseBody(name='body'),
}

async function describeTraceLicenseKeyWithOptions(request: DescribeTraceLicenseKeyRequest, runtime: Util.RuntimeOptions): DescribeTraceLicenseKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTraceLicenseKey',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTraceLicenseKey(request: DescribeTraceLicenseKeyRequest): DescribeTraceLicenseKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTraceLicenseKeyWithOptions(request, runtime);
}

model DescribeWebhookContactsRequest {
  contactIds?: string(name='ContactIds'),
  page?: long(name='Page', description='The number of pages to query.', example='1'),
  size?: long(name='Size', description='The number of webhook alert contacts displayed on each page.', example='20'),
  webhookName?: string(name='WebhookName', description='The name of the webhook alert contact.'),
}

model DescribeWebhookContactsResponseBody = {
  pageBean?: {
    page?: long(name='Page', description='The number of pages to query.', example='1'),
    size?: long(name='Size', description='The number of webhook alert contacts on each page.', example='20'),
    total?: long(name='Total', description='The total number of webhook alert contacts that were queried.', example='1'),
    webhookContacts?: [ 
      {
        webhook?: {
          bizHeaders?: map[string]any(name='BizHeaders', description='The header of the HTTP request.', example='[{"Content-Type":"application/json"}]'),
          bizParams?: map[string]any(name='BizParams', description='The parameters in the HTTP request.', example='[{"content:"mike"}]'),
          body?: string(name='Body', description='The alert notification template.'),
          method?: string(name='Method', description='The HTTP request method. Valid values:

*   Get
*   Post', example='Post'),
          recoverBody?: string(name='RecoverBody', description='The alert recovery template.'),
          url?: string(name='Url', description='The URL of the request method.', example='https://oapi.dingtalk.com/robot/send?access_token=91f2f6****'),
        }(name='Webhook', description='Webhook alert contact details.'),
        webhookId?: float(name='WebhookId', description='The ID of the contact for webhook alerts.', example='123'),
        webhookName?: string(name='WebhookName', description='The name of the webhook alert contact.'),
      }
    ](name='WebhookContacts', description='Webhook alert contacts.'),
  }(name='PageBean', description='Paging object.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4D6C358A-A58B-4F4B-94CE-F5AAF023****'),
}

model DescribeWebhookContactsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebhookContactsResponseBody(name='body'),
}

async function describeWebhookContactsWithOptions(request: DescribeWebhookContactsRequest, runtime: Util.RuntimeOptions): DescribeWebhookContactsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebhookContacts',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebhookContacts(request: DescribeWebhookContactsRequest): DescribeWebhookContactsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebhookContactsWithOptions(request, runtime);
}

model GetAgentDownloadUrlRequest {
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model GetAgentDownloadUrlResponseBody = {
  armsAgentDownloadUrl?: string(name='ArmsAgentDownloadUrl', description='The download URL of the ARMS agent.', example='http://arms-apm-hangzhou.oss-cn-hangzhou-internal.aliyuncs.com/2.7.1.1/'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='14043452-D486-4EA1-80C9-BA73FB81****'),
}

model GetAgentDownloadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAgentDownloadUrlResponseBody(name='body'),
}

async function getAgentDownloadUrlWithOptions(request: GetAgentDownloadUrlRequest, runtime: Util.RuntimeOptions): GetAgentDownloadUrlResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAgentDownloadUrl',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAgentDownloadUrl(request: GetAgentDownloadUrlRequest): GetAgentDownloadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAgentDownloadUrlWithOptions(request, runtime);
}

model GetAlertRulesRequest {
  alertIds?: string(name='AlertIds', description='The unique identifiers (IDs) of alert rules.

*   If you do not specify this parameter, the API operation does not filter alert rules based on their IDs.
*   If you specify this parameter, the API operation returns only the information of the specified alert rules. Other filter conditions also take effect.

> When you call the GetAlertRules operation, you can specify other request parameters to obtain the AlertIds parameter from the response. Then, you can specify the AlertIds parameter to query the specified alert rules.', example='["12345"]'),
  alertNames?: string(name='AlertNames', description='The names of alert rules. When you create alert rules of the new version, you cannot specify duplicate names. However, existing alert rules may have duplicate names. Therefore, the **AlertName** parameter does not uniquely identify an alert rule.

*   If you do not specify this parameter, the API operation does not filter alert rules based on their names.
*   If you specify this parameter, the API operation returns only the information of the specified alert rules. Other filter conditions also take effect.', example='["test"]'),
  alertStatus?: string(name='AlertStatus', description='The status of the alert rule. Valid values:

*   RUNNING
*   STOPPED
*   PAUSED

> The **PAUSED** status indicates that the alert rule is abnormal and is actively paused by the system. The alert rule may be paused because that it is not unique or the associated cluster has been deleted.', example='RUNNING'),
  alertType?: string(name='AlertType', description='The type of the alert rule. Valid values:

*   APPLICATION_MONITORING_ALERT_RULE: an alert rule of Application Monitoring
*   BROWSER_MONITORING_ALERT_RULE: an alert rule of Browser Monitoring
*   PROMETHEUS_MONITORING_ALERT_RULE: an alert rule of Prometheus Service', example='APPLICATION_MONITORING_ALERT_RULE'),
  clusterId?: string(name='ClusterId', example='ceba9b9ea5b924dd0b6726d2de6******'),
  page?: long(name='Page', description='The number of the page to return.', example='1'),
  productCode?: string(name='ProductCode', example='null'),
  regionId?: string(name='RegionId', description='The ID of the region', example='cn-hangzhou'),
  size?: long(name='Size', description='The number of alert rules to return on each page.', example='20'),
}

model GetAlertRulesResponseBody = {
  pageBean?: {
    alertRules?: [ 
      {
        alertCheckType?: string(name='AlertCheckType', description='The alert check type of the Prometheus alert rule. 

- STATIC: a static threshold value.
- CUSTOM: a custom PromQL statement.', example='STATIC'),
        alertGroup?: long(name='AlertGroup', description='The alert contact group ID of the Prometheus alert rule. Valid values:

*   \\-1: custom PromQL
*   1: Kubernetes load
*   15: Kubernetes node', example='1'),
        alertId?: float(name='AlertId', description='The ID of the alert rule.', example='5730***'),
        alertName?: string(name='AlertName', description='The name of the alert rule.', example='arms-test'),
        alertRuleContent?: {
          alertRuleItems?: [ 
            {
              aggregate?: string(name='Aggregate', description='The aggregation method of the alert condition. Valid values:

*   AVG: calculates the average value
*   SUM: calculates the total value
*   MAX: selects the maximum value
*   MIN: selects the minimum value', example='AVG'),
              metricKey?: string(name='MetricKey', description='The metric of the alert condition.', example='appstat.jvm.non_heap_used'),
              n?: float(name='N', description='Indicates the last N minutes.', example='1'),
              operator?: string(name='Operator', description='The comparison operator that is used to compare the metric value with the threshold. 

- CURRENT_GTE: greater than or equal to
- CURRENT_LTE: less than or equal to
- PREVIOUS_UP: the minute-to-minute increase percentage
- PREVIOUS_DOWN: the minute-to-minute decrease percentage
- HOH_UP: the increase percentage compared with the previous hour
- HOH_DOWN: the decrease percentage compared with the previous hour
- DOD_UP: the increase percentage compared with the last day
- DOD_DOWN: the decrease percentage compared with the last day', example='CURRENT_GTE'),
              value?: string(name='Value', description='The threshold of the alert condition.', example='1'),
            }
          ](name='AlertRuleItems', description='The trigger conditions of the Application Monitoring or Browser Monitoring alert rule.'),
          condition?: string(name='Condition', description='The relationship between multiple alert conditions specified for the Application Monitoring or Browser Monitoring alert rule. Valid values:

*   OR: meets any of the specified conditions.
*   AND: meets all the specified conditions.', example='OR'),
        }(name='AlertRuleContent', description='The content of the Application Monitoring or Browser Monitoring alert rule.'),
        alertStatus?: string(name='AlertStatus', description='The status of the alert rule. 

- RUNNING
- STOPPED
- PAUSED

>  The **PAUSED** status indicates that the alert rule is abnormal and is actively paused by the system. The alert rule may be paused because that it is not unique or the associated cluster has been deleted.', example='RUNNING'),
        alertType?: string(name='AlertType', description='The type of the alert rule. Valid values:

*   APPLICATION_MONITORING_ALERT_RULE: an alert rule of Application Monitoring
*   BROWSER_MONITORING_ALERT_RULE: an alert rule of Browser Monitoring
*   PROMETHEUS_MONITORING_ALERT_RULE: an alert rule of Prometheus Service', example='APPLICATION_MONITORING_ALERT_RULE'),
        annotations?: [ 
          {
            name?: string(name='Name', description='The key of the annotation.', example='123'),
            value?: string(name='Value', description='The value of the annotation.', example='abc'),
          }
        ](name='Annotations', description='The annotations of the Prometheus alert rule.'),
        autoAddNewApplication?: boolean(name='AutoAddNewApplication', description='Indicates whether the alert rule was applied to new applications that were created in Application Monitoring or Browser Monitoring. Valid values:

*   `true`: yes
*   `false`: no', example='false'),
        clusterId?: string(name='ClusterId', description='The cluster ID of the Prometheus alert rule.', example='ceba9b9ea5b924dd0b6726d2de6******'),
        createdTime?: long(name='CreatedTime', description='The time when the alert rule was created. The value is a timestamp. Unit: milliseconds.', example='1640333981000'),
        duration?: string(name='Duration', description='The duration of the Prometheus alert rule.', example='1'),
        extend?: string(name='Extend', description='The extended field. 

>  For existing Application Monitoring alert rules, the field contains information such as contacts, alert template, and notification content.', example='{\\\\"alarmContext\\\\":\\\\"{\\\\\\\\\\"content\\\\\\\\\\":\\\\\\\\Alert name: $Alert name\\\\\\\\\\\\nFilter condition: $Filter condition\\\\\\\\\\\\nAlert time: $Alert time\\\\\\\\\\\\nAlert content: $Alert content\\\\\\\\\\\\nNote: Before you receive an email to clear the alert, the alert is still active and we will remind you again 24 hours later. \\\\\\\\\\",\\\\\\\\\\"subTitle\\\\\\\\\\":\\\\\\\\\\"\\\\\\\\\\"}\\\\",\\\\"alertWays\\\\":\\\\"\\[0,1]\\\\",\\\\"contactGroupIds\\\\":\\\\"381,5075\\\\",\\\\"notice\\\\":\\\\"{\\\\\\\\\\"endTime\\\\\\\\\\":1480607940000,\\\\\\\\\\"noticeEndTime\\\\\\\\\\":1480607940000,\\\\\\\\\\"noticeStartTime\\\\\\\\\\":1480521600000,\\\\\\\\\\"startTime\\\\\\\\\\":1480521600000}\\\\"}'),
        filters?: {
          customSLSFilters?: [ 
            {
              key?: string(name='Key', description='The key of the filter condition.', example='username'),
              opt?: string(name='Opt', description='The logical operator of the filter condition. Valid values:

*   \\=: equal to
*   not: not equal to', example='='),
              show?: boolean(name='Show', description='Indicates whether this filter condition was displayed on the frontend.', example='false'),
              t?: string(name='T', description='This field is used only to distinguish the type of Browser Monitoring logs. Other filter conditions do not include this field.', example='null'),
              value?: string(name='Value', description='The value of the filter condition.', example='test'),
            }
          ](name='CustomSLSFilters', description='The custom filter condition of the Browser Monitoring alert rule.'),
          customSLSGroupByDimensions?: [ string ](name='CustomSLSGroupByDimensions', description='The information of the aggregation dimension.'),
          customSLSWheres?: [ string ](name='CustomSLSWheres', description='The details of the custom filter condition.'),
          dimFilters?: [ 
            {
              filterKey?: string(name='FilterKey', description='The key of the filter condition.', example='rootIp'),
              filterOpt?: string(name='FilterOpt', description='The logical operator of the filter condition.', example='ALL'),
              filterValues?: [ string ](name='FilterValues', description='The details of the filter condition.'),
            }
          ](name='DimFilters', description='The information about each filter condition of the Application Monitoring or Browser Monitoring alert rule.'),
        }(name='Filters', description='The filter conditions of the Application Monitoring or Browser Monitoring alert rule.'),
        labels?: [ 
          {
            name?: string(name='Name', description='The key of the tag.', example='123'),
            value?: string(name='Value', description='The value of the tag.', example='abc'),
          }
        ](name='Labels', description='The tags of the Prometheus alert rule.'),
        level?: string(name='Level', description='The severity level of the Prometheus alert rule.

*   P1: Alert notifications are sent for major issues that affect the availability of core business, have huge impact, and may lead to serious consequences.
*   P2: Alert notifications are sent for service errors that affect the system availability with relatively limited impact.
*   P3: Alert notifications are sent for issues that may cause service errors or negative effects, or alert notifications for services that are relatively less important.
*   P4: Alert notifications are sent for low-priority issues that do not affect your business.
*   Default: Alert notifications are sent without distinguishing between alert levels.', example='P2'),
        message?: string(name='Message', description='The alert message of the Prometheus alert rule.', example='Namespace: {{$labels.namespace}} / Pod: {{$labels.pod_name}} / Container: {{$labels.container}} CPU utilization: {{$labels.metrics_params_opt_label_value}} {{$labels.metrics_params_value}}%. Current value: {{ printf "%.2f" $value }}%'),
        metricsType?: string(name='MetricsType', description='The metric type of the Application Monitoring or Browser Monitoring alert rule.', example='JVM'),
        notifyStrategy?: string(name='NotifyStrategy', description='The name of the notification policy.', example='ALERT_MANAGER'),
        pids?: [ string ](name='Pids', description='The process ID (PID) that was associated with the Application Monitoring or Browser Monitoring alert rule.'),
        promQL?: string(name='PromQL', description='The PromQL statement of the Prometheus alert rule.', example='node_memory_MemAvailable_bytes{} / node_memory_MemTotal_bytes{} * 100'),
        regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
        updatedTime?: long(name='UpdatedTime', description='The time when the alert rule was updated. The value is a timestamp. Unit: milliseconds.', example='1640333981000'),
        userId?: string(name='UserId', description='The ID of the Alibaba Cloud account.', example='1131971649******'),
      }
    ](name='AlertRules', description='The type of the alert rule. 

- APPLICATION_MONITORING_ALERT_RULE: alert rule for Application Monitoring
- BROWSER_MONITORING_ALERT_RULE: alert rule for Browser Monitoring
- PROMETHEUS_MONITORING_ALERT_RULE: alert rule for Prometheus Service'),
    page?: long(name='Page', description='The page number of the returned page.', example='1'),
    size?: long(name='Size', description='The number of alert rules returned per page.', example='20'),
    total?: long(name='Total', description='The total number of queried alert rules.', example='1'),
  }(name='PageBean', description='The pages that are returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='337B8F7E-0A64-5768-9225-E9B3CF******'),
}

model GetAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlertRulesResponseBody(name='body'),
}

async function getAlertRulesWithOptions(request: GetAlertRulesRequest, runtime: Util.RuntimeOptions): GetAlertRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertIds)) {
    query['AlertIds'] = request.alertIds;
  }
  if (!Util.isUnset(request.alertNames)) {
    query['AlertNames'] = request.alertNames;
  }
  if (!Util.isUnset(request.alertStatus)) {
    query['AlertStatus'] = request.alertStatus;
  }
  if (!Util.isUnset(request.alertType)) {
    query['AlertType'] = request.alertType;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAlertRules',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAlertRules(request: GetAlertRulesRequest): GetAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAlertRulesWithOptions(request, runtime);
}

model GetAppApiByPageRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  endTime?: long(name='EndTime', description='The end of the time range to query. Unit: milliseconds.', example='1600066800000'),
  intervalMills?: int32(name='IntervalMills', description='The time interval between the data shards to be queried. Unit: milliseconds. Minimum value: 60000.', example='60000'),
  PId?: string(name='PId', description='The process identifier (PID) of the application. For more information about how to obtain the PID, see [Obtain the PID of an application](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).', example='a2n80plglh@745eddxxx'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='10'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. Unit: milliseconds.', example='1600063200000'),
}

model GetAppApiByPageResponseBody = {
  code?: int32(name='Code', description='The HTTP status code returned for the request. Valid values:

*   2XX: The request is successful.
*   3XX: A redirection message is returned.
*   4XX: The request is invalid.
*   5XX: A server error occurs.', example='200'),
  data?: {
    items?: [  map[string]any ](name='Items', description='The information about the API operation.'),
    page?: int32(name='Page', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
    total?: string(name='Total', description='The total number of entries returned.', example='0'),
  }(name='Data', description='The struct returned.'),
  message?: string(name='Message', description='The message returned.', example='message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B6A00968-82A8-4F14-9D1B-B53827DB****'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   `true`: The call is successful.
*   `false`: The call fails.', example='true'),
}

model GetAppApiByPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAppApiByPageResponseBody(name='body'),
}

async function getAppApiByPageWithOptions(request: GetAppApiByPageRequest, runtime: Util.RuntimeOptions): GetAppApiByPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.intervalMills)) {
    query['IntervalMills'] = request.intervalMills;
  }
  if (!Util.isUnset(request.PId)) {
    query['PId'] = request.PId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAppApiByPage',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAppApiByPage(request: GetAppApiByPageRequest): GetAppApiByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppApiByPageWithOptions(request, runtime);
}

model GetAuthTokenRequest {
  clusterId?: string(name='ClusterId', description='The ID of the ACK cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  regionId?: string(name='RegionId', description='The region ID of the cluster.', example='cn-hangzhou'),
}

model GetAuthTokenResponseBody = {
  data?: string(name='Data', description='The returned authentication token.', example='eyJhbGciOiJIUzI1NiJ9******'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1A9C645C-C83F-4C9D-8CCB-29BEC9E1****'),
}

model GetAuthTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAuthTokenResponseBody(name='body'),
}

async function getAuthTokenWithOptions(request: GetAuthTokenRequest, runtime: Util.RuntimeOptions): GetAuthTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAuthToken',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAuthToken(request: GetAuthTokenRequest): GetAuthTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuthTokenWithOptions(request, runtime);
}

model GetClusterAllUrlRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  regionId?: string(name='RegionId', description='The ID of the region. Default value: cn-hangzhou.', example='cn-hangzhou'),
}

model GetClusterAllUrlResponseBody = {
  data?: string(name='Data', description='The response parameters in the JSON format.', example='{
  "RequestId": "41877338-646B-5DD6-BFBE-F89F1E7245AD",
  "Data": "{\\"clusterType\\":\\"ManagedKubernetes\\",\\"remoteWriteUrl\\":\\"http:/" }'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='40B10E04-81E8-4643-970D-F1B38F2E****'),
}

model GetClusterAllUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClusterAllUrlResponseBody(name='body'),
}

async function getClusterAllUrlWithOptions(request: GetClusterAllUrlRequest, runtime: Util.RuntimeOptions): GetClusterAllUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClusterAllUrl',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getClusterAllUrl(request: GetClusterAllUrlRequest): GetClusterAllUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClusterAllUrlWithOptions(request, runtime);
}

model GetExploreUrlRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c9cc4c5e220f8461f9d71b6ec6e******'),
  expression?: string(name='Expression', description='The query language corresponding to the data source.', example='{app="buy2"}'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  type?: string(name='Type', description='The type of the Grafana data source.', example='prometheus'),
}

model GetExploreUrlResponseBody = {
  data?: string(name='Data', description='Response parameters', example='-'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='34ED024E-9E31-434A-9E4E-D9D15C3****'),
}

model GetExploreUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExploreUrlResponseBody(name='body'),
}

async function getExploreUrlWithOptions(request: GetExploreUrlRequest, runtime: Util.RuntimeOptions): GetExploreUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.expression)) {
    query['Expression'] = request.expression;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExploreUrl',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getExploreUrl(request: GetExploreUrlRequest): GetExploreUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getExploreUrlWithOptions(request, runtime);
}

model GetIntegrationStateRequest {
  clusterId?: string(name='ClusterId', description='The abbreviation of the software that is supported by Application Real-Time Monitoring Service (ARMS). Valid values (case-insensitive): `ASM`, `IoT`, and `Flink`.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  integration?: string(name='Integration', description='The integration state of Prometheus dashboards and collection rules. Valid values:

*   `true`: Prometheus dashboards and collection rules are integrated.
*   `false`: Prometheus dashboards and collection rules are not integrated.', example='asm'),
  regionId?: string(name='RegionId', description='The ID of the request.', example='cn-hangzhou'),
}

model GetIntegrationStateResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='1A9C645C-C83F-4C9D-8CCB-29BEC9E1****'),
  state?: boolean(name='State', description='Queries the integration state of Prometheus dashboards and collection rules for a Container Service for Kubernetes (ACK) cluster.', example='true'),
}

model GetIntegrationStateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIntegrationStateResponseBody(name='body'),
}

async function getIntegrationStateWithOptions(request: GetIntegrationStateRequest, runtime: Util.RuntimeOptions): GetIntegrationStateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.integration)) {
    query['Integration'] = request.integration;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetIntegrationState',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getIntegrationState(request: GetIntegrationStateRequest): GetIntegrationStateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIntegrationStateWithOptions(request, runtime);
}

model GetManagedPrometheusStatusRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  clusterType?: string(name='ClusterType', description='The type of the cluster. Set the value to ask.', example='ask'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  vpcId?: string(name='VpcId', description='ClusterTypeecs', example='vpc-***'),
}

model GetManagedPrometheusStatusResponseBody = {
  code?: int32(name='Code', description='The HTTP status code returned.', example='200'),
  data?: string(name='Data', description='The status of the Prometheus instance. Installing: The Prometheus agent is installed and no registration information is available. Success: The Prometheus agent is installed and registered. Failure: The Prometheus agent failed to be installed or registered. Unknow: The status of the Prometheus agent is unknown.', example='Installing'),
  message?: string(name='Message', description='The returned message.', example='Successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F7781D4A-2818-41E7-B7BB-79D809E9****'),
  success?: boolean(name='Success', description='Indicates whether the query was successful.

*   `true`
*   `false`', example='true'),
}

model GetManagedPrometheusStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetManagedPrometheusStatusResponseBody(name='body'),
}

async function getManagedPrometheusStatusWithOptions(request: GetManagedPrometheusStatusRequest, runtime: Util.RuntimeOptions): GetManagedPrometheusStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetManagedPrometheusStatus',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getManagedPrometheusStatus(request: GetManagedPrometheusStatusRequest): GetManagedPrometheusStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getManagedPrometheusStatusWithOptions(request, runtime);
}

model GetMultipleTraceRequest {
  endTime?: long(name='EndTime'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  startTime?: long(name='StartTime'),
  traceIDs?: [ string ](name='TraceIDs', description='The IDs of the traces. You can log on to the [Application Real-Time Monitoring Service (ARMS) console](https://arms.console.aliyun.com/#/home) and obtain trace IDs on the Trace Query page or Interface Snapshot tab.', example='ac1400a115951745017447033d****'),
}

model GetMultipleTraceResponseBody = {
  multiCallChainInfos?: [ 
    {
      spans?: [ 
        {
          duration?: long(name='Duration', description='The amount of time consumed by the trace. Unit: milliseconds.', example='11'),
          haveStack?: boolean(name='HaveStack', description='Indicates whether a method stack was provided.

- `true`: A method stack was provided.
- `false` : No method stack was provided.', example='true'),
          logEventList?: [ 
            {
              tagEntryList?: [ 
                {
                  key?: string(name='Key', description='The key of the tag.', example='http.status.code'),
                  value?: string(name='Value', description='The value of the tag.', example='200'),
                }
              ](name='TagEntryList', description='The tags of the trace.'),
              timestamp?: long(name='Timestamp', description='The timestamp when the trace was returned.', example='1595174501747'),
            }
          ](name='LogEventList', description='The log events in the trace.'),
          operationName?: string(name='OperationName', description='The name of the traced span.', example='/demo/queryNotExistDB/11'),
          parentSpanId?: string(name='ParentSpanId', description='The ID of the parent span.', example='18'),
          resultCode?: string(name='ResultCode', description='The response code.', example='1'),
          rpcId?: string(name='RpcId', description='The ID of the remote procedure call (RPC).', example='0.1'),
          rpcType?: int32(name='RpcType', description='The type of the remote procedure call (RPC) mode.

*   0: HTTP entry
*   25: HTTP call
*   1: High-speed Service Framework (HSF) call
*   2: HSF provision
*   40: on-premises API call
*   60: MySQL call
*   62: Oracle call
*   63: PostgreSQL call
*   70: Redis call
*   4: Taobao Distributed Data Layer (TDDL) call
*   5: Tair call
*   13: MetaQ message sending
*   252: MetaQ message receiving
*   3: notification sending
*   254: notification receiving
*   7: Apache Dubbo call
*   8: Apache Dubbo provision
*   19: SOFARPC call
*   18: SOFARPC provision
*   11: Distributed Service Framework (DSF) call
*   12: DSF provision
*   \\-1: unknown call', example='0'),
          serviceIp?: string(name='ServiceIp', description='The IP address of the host where the application resides.', example='172.20.XX.XX'),
          serviceName?: string(name='ServiceName', description='The name of the application.', example='arms-k8s-demo-subcomponent'),
          spanId?: string(name='SpanId', description='Span ID', example='1234'),
          tagEntryList?: [ 
            {
              key?: string(name='Key', description='The key of the tag.', example='http.status.code'),
              value?: string(name='Value', description='The value of the tag.', example='200'),
            }
          ](name='TagEntryList', description='The tags of the trace.'),
          timestamp?: long(name='Timestamp', description='The timestamp when the trace was returned.', example='1595174501747'),
          traceID?: string(name='TraceID', description='The ID of the trace.', example='ac1400a115951745017447033d****'),
        }
      ](name='Spans', description='The information about the trace.'),
      traceID?: string(name='TraceID', description='The ID of the trace.', example='ac1400a115951745017447033d****'),
    }
  ](name='MultiCallChainInfos', description='The information about the queried traces.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2983BEF7-4A0D-47A2-94A2-8E9C5E63****'),
}

model GetMultipleTraceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMultipleTraceResponseBody(name='body'),
}

async function getMultipleTraceWithOptions(request: GetMultipleTraceRequest, runtime: Util.RuntimeOptions): GetMultipleTraceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.traceIDs)) {
    query['TraceIDs'] = request.traceIDs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMultipleTrace',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMultipleTrace(request: GetMultipleTraceRequest): GetMultipleTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMultipleTraceWithOptions(request, runtime);
}

model GetOnCallSchedulesDetailRequest {
  endTime?: string(name='EndTime', example='2022-10-30'),
  id?: long(name='Id', example='1234'),
  startTime?: string(name='StartTime', example='2022-10-01'),
}

model GetOnCallSchedulesDetailResponseBody = {
  data?: {
    alertRobotId?: long(name='AlertRobotId', example='https://oapi.dingtalk.com/robot/send?access_token=69d4e009547e11069c6513309414937b7bf0482fb9284125b5******'),
    description?: string(name='Description', example=''),
    id?: long(name='Id', example='1234'),
    name?: string(name='Name', example=''),
    renderedFinnalEntries?: [ 
      {
        end?: string(name='End', example='2022-10-30'),
        simpleContact?: {
          id?: long(name='Id', example='123'),
          name?: string(name='Name'),
        }(name='SimpleContact'),
        start?: string(name='Start', example='2022-10-01'),
      }
    ](name='RenderedFinnalEntries'),
    renderedLayerEntries?: [[ 
      {
        start?: string(name='Start', example='2022-10-01'),
        end?: string(name='End', example='2022-10-30'),
        simpleContact?: {
          id?: long(name='Id', example='123'),
          name?: string(name='Name'),
        }(name='SimpleContact'),
      }
    ]    ](name='RenderedLayerEntries'),
    renderedSubstitudeEntries?: [ 
      {
        end?: string(name='End', example='2022-10-30'),
        simpleContact?: {
          id?: long(name='Id', example='234'),
          name?: string(name='Name'),
        }(name='SimpleContact'),
        start?: string(name='Start', example='2022-10-01'),
      }
    ](name='RenderedSubstitudeEntries'),
    scheduleLayers?: [ 
      {
        contactIds?: [ long ](name='ContactIds'),
        restrictions?: [ 
          {
            endTimeOfDay?: string(name='EndTimeOfDay', example='18:00'),
            restrictionType?: string(name='RestrictionType', example='daily_restriction'),
            startTimeOfDay?: string(name='StartTimeOfDay', example='09:00'),
          }
        ](name='Restrictions'),
        rotationType?: string(name='RotationType', example='DAY'),
        shiftLength?: long(name='ShiftLength', example='8'),
        startTime?: string(name='StartTime', example='2022-10-01'),
      }
    ](name='ScheduleLayers'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='21E85B16-75A6-429A-9F65-8AAC9A54****'),
}

model GetOnCallSchedulesDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOnCallSchedulesDetailResponseBody(name='body'),
}

async function getOnCallSchedulesDetailWithOptions(request: GetOnCallSchedulesDetailRequest, runtime: Util.RuntimeOptions): GetOnCallSchedulesDetailResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOnCallSchedulesDetail',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOnCallSchedulesDetail(request: GetOnCallSchedulesDetailRequest): GetOnCallSchedulesDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOnCallSchedulesDetailWithOptions(request, runtime);
}

model GetPrometheusApiTokenRequest {
  regionId?: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou'),
}

model GetPrometheusApiTokenResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='1A9C645C-C83F-4C9D-8CCB-29BEC9E1****'),
  token?: string(name='Token', description='The token required for integrating ARMS Prometheus Monitoring.', example='6dcbb77ef4ba6ef5466b5debf9e2****'),
}

model GetPrometheusApiTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPrometheusApiTokenResponseBody(name='body'),
}

/**
  * ****
  *
  * @param request GetPrometheusApiTokenRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetPrometheusApiTokenResponse
 */
async function getPrometheusApiTokenWithOptions(request: GetPrometheusApiTokenRequest, runtime: Util.RuntimeOptions): GetPrometheusApiTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPrometheusApiToken',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ****
  *
  * @param request GetPrometheusApiTokenRequest
  * @return GetPrometheusApiTokenResponse
 */
async function getPrometheusApiToken(request: GetPrometheusApiTokenRequest): GetPrometheusApiTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPrometheusApiTokenWithOptions(request, runtime);
}

model GetPrometheusGlobalViewRequest {
  globalViewClusterId?: string(name='GlobalViewClusterId', example='global-v2-cn-1478326682034601-vss8pd0i'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model GetPrometheusGlobalViewResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId', example='743AD493-D006-53BD-AAEC-DDCE7FB68EA7'),
}

model GetPrometheusGlobalViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPrometheusGlobalViewResponseBody(name='body'),
}

async function getPrometheusGlobalViewWithOptions(request: GetPrometheusGlobalViewRequest, runtime: Util.RuntimeOptions): GetPrometheusGlobalViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalViewClusterId)) {
    query['GlobalViewClusterId'] = request.globalViewClusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPrometheusGlobalView',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPrometheusGlobalView(request: GetPrometheusGlobalViewRequest): GetPrometheusGlobalViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPrometheusGlobalViewWithOptions(request, runtime);
}

model GetPrometheusRemoteWriteRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  remoteWriteName?: string(name='RemoteWriteName', example='rw1'),
}

model GetPrometheusRemoteWriteResponseBody = {
  code?: int32(name='Code', example='200'),
  data?: string(name='Data', example='remote_write:
  - name: rw1
    url: "http://cn-hangzhou-intranet.arms.aliyuncs.com/prometheus/uid/xx/cn-hangzhou/api/v3/write"
    basic_auth:
      username: xxx
      password: xxx
    write_relabel_configs:
      - source_labels: [ instance_id ]
        separator: ;
        regex: si
        replacement: $1
        action: keep'),
  message?: string(name='Message', example='message'),
  requestId?: string(name='RequestId', example='40B10E04-81E8-4643-970D-F1B38F2E****'),
  success?: boolean(name='Success', example='true'),
}

model GetPrometheusRemoteWriteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPrometheusRemoteWriteResponseBody(name='body'),
}

async function getPrometheusRemoteWriteWithOptions(request: GetPrometheusRemoteWriteRequest, runtime: Util.RuntimeOptions): GetPrometheusRemoteWriteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.remoteWriteName)) {
    query['RemoteWriteName'] = request.remoteWriteName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPrometheusRemoteWrite',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPrometheusRemoteWrite(request: GetPrometheusRemoteWriteRequest): GetPrometheusRemoteWriteResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPrometheusRemoteWriteWithOptions(request, runtime);
}

model GetRecordingRuleRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model GetRecordingRuleResponseBody = {
  data?: string(name='Data', description='The recording rule.', example='--- groups: - name: "recording_demo"   rules:   - expr: "sum(jvm_memory_max_bytes)"     record: "rate_coredns_demo"'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9FEA6D00-317F-45E3-9004-7FB8B0B7****'),
}

model GetRecordingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRecordingRuleResponseBody(name='body'),
}

async function getRecordingRuleWithOptions(request: GetRecordingRuleRequest, runtime: Util.RuntimeOptions): GetRecordingRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRecordingRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRecordingRule(request: GetRecordingRuleRequest): GetRecordingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRecordingRuleWithOptions(request, runtime);
}

model GetRetcodeDataByQueryRequest {
  from?: long(name='From', example='1668687302'),
  pid?: string(name='Pid', example='atc889zkcf@d8deedfa9bf****'),
  query?: string(name='Query', example='t : pv|select sum(times) as pv , approx_distinct(uid) as uv , (date-date%3600000) as date  group by date'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  to?: long(name='To', example='1668688000'),
}

model GetRetcodeDataByQueryResponseBody = {
  code?: string(name='Code', example='200'),
  data?: string(name='Data', example='{"total":0,"auth":false,"pageSize":20,"completed":true,"page":1,"items":[]}'),
  message?: string(name='Message', example='Internal error. Please try again. Contact the DingTalk service account if the issue                              persists after multiple retries.'),
  requestId?: string(name='RequestId', example='2A0CEDF1-06FE-44AC-8E21-21A5BE65****'),
  success?: boolean(name='Success', example='true'),
}

model GetRetcodeDataByQueryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRetcodeDataByQueryResponseBody(name='body'),
}

async function getRetcodeDataByQueryWithOptions(request: GetRetcodeDataByQueryRequest, runtime: Util.RuntimeOptions): GetRetcodeDataByQueryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.query)) {
    query['Query'] = request.query;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.to)) {
    query['To'] = request.to;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRetcodeDataByQuery',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRetcodeDataByQuery(request: GetRetcodeDataByQueryRequest): GetRetcodeDataByQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRetcodeDataByQueryWithOptions(request, runtime);
}

model GetRetcodeLogstoreRequest {
  pid?: string(name='Pid', example='atc889zkcf@d8deedfa9bf****'),
  regionId?: string(name='RegionId'),
}

model GetRetcodeLogstoreResponseBody = {
  data?: {
    message?: string(name='Message', example='retcode app or task can not be found!'),
    retcodeSLSConfig?: {
      logstore?: string(name='Logstore', example='log-test-220431'),
      project?: string(name='Project', example='test-project'),
      regionId?: string(name='RegionId', example='cn-hangzhou'),
    }(name='RetcodeSLSConfig'),
    status?: string(name='Status', example='true'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='1A9C645C-C83F-4C9D-8CCB-29BEC9E1****'),
}

model GetRetcodeLogstoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRetcodeLogstoreResponseBody(name='body'),
}

async function getRetcodeLogstoreWithOptions(request: GetRetcodeLogstoreRequest, runtime: Util.RuntimeOptions): GetRetcodeLogstoreResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRetcodeLogstore',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRetcodeLogstore(request: GetRetcodeLogstoreRequest): GetRetcodeLogstoreResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRetcodeLogstoreWithOptions(request, runtime);
}

model GetRetcodeShareUrlRequest {
  pid?: string(name='Pid', description='The process identifier (PID) of the application. For more information about how to obtain the PID, see [Obtain the PID of an application](~~186100~~#title-imy-7gj-qhr).', example='iioe7jcnuk@582846f37******'),
}

model GetRetcodeShareUrlResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='01FF8DD9-A09C-47A1-895A-B6E321BE77B6'),
  url?: string(name='Url', description='The logon-free URL of the application.', example='http://arms-daily.console.aliyun.com:8080/shareapi/retcode.json?login_arms_t3h_token=XXXxxx&action=RetcodeAction&eventSubmitDoGetData=1'),
}

model GetRetcodeShareUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRetcodeShareUrlResponseBody(name='body'),
}

async function getRetcodeShareUrlWithOptions(request: GetRetcodeShareUrlRequest, runtime: Util.RuntimeOptions): GetRetcodeShareUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRetcodeShareUrl',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRetcodeShareUrl(request: GetRetcodeShareUrlRequest): GetRetcodeShareUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRetcodeShareUrlWithOptions(request, runtime);
}

model GetSourceMapInfoRequest {
  ascendingSequence?: boolean(name='AscendingSequence', description='The order in which the files are sorted. Valid values:

*   true: ascending order
*   false: descending order', example='true'),
  edition?: string(name='Edition', description='The version of the SourceMap file.', example='0.0.0'),
  ID?: string(name='ID', description='The IDs of the SourceMap files.', example='atc889zkcf@d8deedfa9bf****/0.0.0/test.sourcemap.js'),
  keyword?: string(name='Keyword', description='The keyword in the file name. The files are searched by keyword.', example='test'),
  orderField?: string(name='OrderField', description='The criterion by which the files are sorted. Valid values:

*   version: The files are sorted by version.
*   uploadTime: The files are sorted by upload time.', example='version'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model GetSourceMapInfoResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C21AB7CF-B7AF-410F-BD61-82D1567F****'),
  sourceMapList?: [ 
    {
      fid?: string(name='Fid', description='The ID of the SourceMap file.', example='atc889zkcf@d8deedfa9bf****/0.0.0/test.sourcemap.js'),
      fileName?: string(name='FileName', description='The name of the SourceMap file.', example='test.sourcemap.js'),
      size?: string(name='Size', description='The size of the file. Unit: KB.', example='201223'),
      uploadTime?: string(name='UploadTime', description='The timestamp when the file was uploaded.', example='1590657842000'),
      version?: string(name='Version', description='The version of the file.', example='0.0.0'),
    }
  ](name='SourceMapList', description='The details of the SourceMap files.'),
}

model GetSourceMapInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSourceMapInfoResponseBody(name='body'),
}

async function getSourceMapInfoWithOptions(request: GetSourceMapInfoRequest, runtime: Util.RuntimeOptions): GetSourceMapInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ascendingSequence)) {
    query['AscendingSequence'] = request.ascendingSequence;
  }
  if (!Util.isUnset(request.edition)) {
    query['Edition'] = request.edition;
  }
  if (!Util.isUnset(request.ID)) {
    query['ID'] = request.ID;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.orderField)) {
    query['OrderField'] = request.orderField;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSourceMapInfo',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSourceMapInfo(request: GetSourceMapInfoRequest): GetSourceMapInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSourceMapInfoWithOptions(request, runtime);
}

model GetStackRequest {
  endTime?: long(name='EndTime', description='The end time of the call method.', example='1653641800'),
  pid?: string(name='Pid', description='The process identifier (PID) of the application. For more information about how to obtain the PID, see [Obtain the PID of an application](https://help.aliyun.com/document_detail/186100.html?spm=a2c4g.11186623.6.792.1b50654cqcDPyk#title-imy-7gj-qhr).', example='eb4zdose6v@36bab313a******'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  rpcID?: string(name='RpcID', description='The ID of the remote procedure call (RPC) mode. You can obtain the ID by calling the **GetTrace** operation.', example='0.1'),
  startTime?: long(name='StartTime', description='The start time of the call method.', example='1653555396'),
  traceID?: string(name='TraceID', description='The ID of the trace. You can log on to the Application Real-Time Monitoring Service (ARMS) console and obtain the trace ID on the **Trace Query** page.', example='0a5800611641470044457853******'),
}

model GetStackResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='B34C3A43-A901-5F94-9DAD-758CE4******'),
  stackInfo?: [ 
    {
      api?: string(name='Api', description='The name of the operation.', example='Tomcat Servlet Process'),
      duration?: long(name='Duration', description='The duration. Unit: milliseconds.', example='32'),
      exception?: string(name='Exception', description='The error message.', example='java.lang.NullPointerException'),
      extInfo?: {
        info?: string(name='Info', description='The content of the custom parameter.', example='input=254275&amp;'),
        type?: string(name='Type', description='The type of the custom parameter.', example='41'),
      }(name='ExtInfo', description='The extended information.'),
      line?: string(name='Line', description='The number of rows in the method stack information.', example='34'),
      rpcId?: string(name='RpcId', description='RPC ID', example='0.1'),
      serviceName?: string(name='ServiceName', description='The name of the service.', example='/com/test'),
      startTime?: long(name='StartTime', description='The start time of the call method.', example='1653555396'),
    }
  ](name='StackInfo', description='The information of the method stack.'),
}

model GetStackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetStackResponseBody(name='body'),
}

async function getStackWithOptions(request: GetStackRequest, runtime: Util.RuntimeOptions): GetStackResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.rpcID)) {
    query['RpcID'] = request.rpcID;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.traceID)) {
    query['TraceID'] = request.traceID;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetStack',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getStack(request: GetStackRequest): GetStackResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStackWithOptions(request, runtime);
}

model GetSyntheticTaskDetailRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  taskId?: string(name='TaskId', example='123'),
}

model GetSyntheticTaskDetailResponseBody = {
  requestId?: string(name='RequestId', example='4D6C358A-A58B-4F4B-94CE-F5AAF023****'),
  taskDetail?: {
    commonParam?: {
      alarmFlag?: long(name='AlarmFlag'),
      alertList?: [ 
        {
          generalAlert?: string(name='GeneralAlert'),
          isCritical?: string(name='IsCritical'),
          name?: string(name='Name'),
          seriousAlert?: string(name='SeriousAlert'),
          symbols?: string(name='Symbols'),
        }
      ](name='AlertList'),
      alertNotifierId?: string(name='AlertNotifierId'),
      alertPolicyId?: string(name='AlertPolicyId'),
      monitorSamples?: string(name='MonitorSamples'),
      startExecutionTime?: string(name='StartExecutionTime'),
    }(name='CommonParam'),
    download?: {
      connectionTimeout?: long(name='ConnectionTimeout', example='200'),
      downloadCustomHeaderContent?: string(name='DownloadCustomHeaderContent', example='char'),
      downloadCustomHost?: long(name='DownloadCustomHost', example='0'),
      downloadCustomHostIp?: string(name='DownloadCustomHostIp', example='168.23.45.1'),
      downloadKernel?: long(name='DownloadKernel', example='1'),
      downloadRedirect?: long(name='DownloadRedirect', example='1'),
      downloadTransmissionSize?: long(name='DownloadTransmissionSize', example='20'),
      monitorTimeout?: long(name='MonitorTimeout', example='12'),
      quickProtocol?: string(name='QuickProtocol', example='1'),
      validateKeywords?: string(name='ValidateKeywords', example='test'),
      verifyWay?: long(name='VerifyWay', example='0'),
      whiteList?: string(name='WhiteList', example='[{\\"src\\":\\"211.154.166.174\\"}]'),
    }(name='Download'),
    extendInterval?: {
      days?: [ long ](name='Days'),
      endMinute?: long(name='EndMinute', example='20'),
      endTime?: string(name='EndTime', example='2022-05-03 11:40'),
      endhour?: long(name='Endhour', example='12'),
      startHour?: long(name='StartHour', example='9'),
      startMinute?: long(name='StartMinute', example='20'),
      startTime?: string(name='StartTime', example='2022-02-26 11:40'),
    }(name='ExtendInterval'),
    intervalTime?: long(name='IntervalTime', example='20'),
    intervalType?: long(name='IntervalType', example='0'),
    ipType?: long(name='IpType', example='0'),
    monitorList?: [ 
      {
        cityCode?: long(name='CityCode'),
        monitorType?: long(name='MonitorType'),
        netServiceId?: long(name='NetServiceId'),
        sendCount?: long(name='SendCount'),
      }
    ](name='MonitorList'),
    monitorListString?: string(name='MonitorListString'),
    nav?: {
      dnsHijackWhitelist?: string(name='DnsHijackWhitelist', example='119.119.53.156'),
      elementBlacklist?: string(name='ElementBlacklist', example='test'),
      executeActiveX?: long(name='ExecuteActiveX', example='3'),
      executeApplet?: long(name='ExecuteApplet', example='1'),
      executeScript?: long(name='ExecuteScript', example='1'),
      filterInvalidIP?: long(name='FilterInvalidIP', example='1'),
      flowHijackJumpTimes?: long(name='FlowHijackJumpTimes', example='12'),
      flowHijackLogo?: string(name='FlowHijackLogo', example='target'),
      monitorTimeout?: long(name='MonitorTimeout', example='20'),
      navAutomaticScrolling?: long(name='NavAutomaticScrolling', example='1'),
      navCustomHeader?: string(name='NavCustomHeader', example='0'),
      navCustomHeaderContent?: string(name='NavCustomHeaderContent', example='content'),
      navCustomHost?: long(name='NavCustomHost', example='1'),
      navCustomHostIp?: string(name='NavCustomHostIp', example='119.119.53.156/32'),
      navDisableCache?: long(name='NavDisableCache', example='1'),
      navDisableCompression?: long(name='NavDisableCompression', example='0'),
      navIgnoreCertificateError?: long(name='NavIgnoreCertificateError', example='1'),
      navRedirect?: long(name='NavRedirect', example='1'),
      navReturnElement?: long(name='NavReturnElement', example='1'),
      pageTampering?: string(name='PageTampering', example='content'),
      processName?: string(name='ProcessName', example='ssh'),
      quicDomain?: string(name='QuicDomain', example='www.example.com'),
      quicVersion?: long(name='QuicVersion', example='0'),
      requestHeader?: long(name='RequestHeader', example='0'),
      slowElementThreshold?: long(name='SlowElementThreshold', example='30'),
      verifyStringBlacklist?: string(name='VerifyStringBlacklist', example='test'),
      verifyStringWhitelist?: string(name='VerifyStringWhitelist', example='test'),
      waitCompletionTime?: long(name='WaitCompletionTime', example='20'),
    }(name='Nav'),
    net?: {
      netDigSwitch?: long(name='NetDigSwitch', example='0'),
      netDnsNs?: string(name='NetDnsNs', example='189.12.32.124'),
      netDnsQueryMethod?: string(name='NetDnsQueryMethod', example='1'),
      netDnsServer?: long(name='NetDnsServer', example='0'),
      netDnsSwitch?: long(name='NetDnsSwitch', example='0'),
      netDnsTimeout?: string(name='NetDnsTimeout'),
      netIcmpActive?: long(name='NetIcmpActive', example='0'),
      netIcmpDataCut?: long(name='NetIcmpDataCut', example='0'),
      netIcmpInterval?: long(name='NetIcmpInterval', example='10'),
      netIcmpNum?: long(name='NetIcmpNum', example='10'),
      netIcmpSize?: long(name='NetIcmpSize', example='30'),
      netIcmpSwitch?: long(name='NetIcmpSwitch', example='0'),
      netIcmpTimeout?: long(name='NetIcmpTimeout', example='20'),
      netTraceRouteNum?: long(name='NetTraceRouteNum', example='30'),
      netTraceRouteSwitch?: long(name='NetTraceRouteSwitch', example='0'),
      netTraceRouteTimeout?: long(name='NetTraceRouteTimeout', example='20'),
      whiteList?: string(name='WhiteList', example='119.119.53.156/32'),
    }(name='Net'),
    protocol?: {
      characterEncoding?: long(name='CharacterEncoding', example='0'),
      customHost?: long(name='CustomHost', example='1'),
      customHostIp?: string(name='CustomHostIp', example='119.119.53.156'),
      protocolConnectionTimeout?: long(name='ProtocolConnectionTimeout', example='20'),
      protocolMonitorTimeout?: long(name='ProtocolMonitorTimeout', example='30'),
      receivedDataSize?: long(name='ReceivedDataSize', example='30'),
      requestContent?: {
        body?: {
          formdata?: {
            key?: string(name='Key', example='appId'),
            value?: string(name='Value', example='3425'),
          }(name='Formdata'),
          language?: string(name='Language', example='xml'),
          mode?: string(name='Mode', example='form-data'),
          raw?: string(name='Raw', example='content'),
          urlencoded?: {
            key?: string(name='Key', example='appId'),
            value?: string(name='Value', example='11080'),
          }(name='Urlencoded'),
        }(name='Body'),
        header?: [ 
          {
            key?: string(name='Key', example='regionId'),
            value?: string(name='Value', example='cn-hangzhou'),
          }
        ](name='Header'),
        method?: string(name='Method', example='POST'),
      }(name='RequestContent'),
      verifyContent?: string(name='VerifyContent', example='list'),
      verifyWay?: long(name='VerifyWay', example='0'),
    }(name='Protocol'),
    taskId?: long(name='TaskId', example='19584'),
    taskName?: string(name='TaskName', example='net-test'),
    taskType?: long(name='TaskType', example='0'),
    url?: string(name='Url', example='www.example.com'),
  }(name='TaskDetail'),
}

model GetSyntheticTaskDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSyntheticTaskDetailResponseBody(name='body'),
}

async function getSyntheticTaskDetailWithOptions(request: GetSyntheticTaskDetailRequest, runtime: Util.RuntimeOptions): GetSyntheticTaskDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSyntheticTaskDetail',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSyntheticTaskDetail(request: GetSyntheticTaskDetailRequest): GetSyntheticTaskDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSyntheticTaskDetailWithOptions(request, runtime);
}

model GetSyntheticTaskListRequest {
  direction?: string(name='Direction', example='asc'),
  order?: string(name='Order', example='CreateTime'),
  pageNum?: long(name='PageNum', example='1'),
  pageSize?: long(name='PageSize', example='10'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  taskName?: string(name='TaskName', example='net-test'),
  taskStatus?: string(name='TaskStatus', example='1'),
  taskType?: string(name='TaskType', example='0'),
  url?: string(name='Url', example='https://www.example.com'),
}

model GetSyntheticTaskListResponseBody = {
  pageInfo?: {
    hasNextPage?: string(name='HasNextPage', example='false'),
    hasPreviousPage?: boolean(name='HasPreviousPage', example='true'),
    isFirstPage?: boolean(name='IsFirstPage', example='true'),
    isLastPage?: boolean(name='IsLastPage', example='true'),
    list?: [ 
      {
        createTime?: string(name='CreateTime', example='1634005438000'),
        monitorNumber?: long(name='MonitorNumber', example='2'),
        taskId?: string(name='TaskId', example='2118709'),
        taskName?: string(name='TaskName', example='net-test'),
        taskStatus?: string(name='TaskStatus', example='0'),
        taskType?: long(name='TaskType', example='0'),
        taskTypeName?: string(name='TaskTypeName'),
        url?: string(name='Url', example='www.example.com'),
        usable?: float(name='Usable', example='0.80'),
      }
    ](name='List'),
    navigateFirstPage?: string(name='NavigateFirstPage', example='1'),
    navigateLastPage?: string(name='NavigateLastPage', example='3'),
    navigatePageNums?: string(name='NavigatePageNums', example='1,2,3'),
    nextPage?: string(name='NextPage', example='3'),
    pages?: string(name='Pages', example='10'),
    prepage?: string(name='Prepage', example='1'),
    size?: long(name='Size', example='10'),
    total?: long(name='Total', example='15'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId', example='A5EC8221-08F2-4C95-9AF1-49FD998C****'),
}

model GetSyntheticTaskListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSyntheticTaskListResponseBody(name='body'),
}

async function getSyntheticTaskListWithOptions(request: GetSyntheticTaskListRequest, runtime: Util.RuntimeOptions): GetSyntheticTaskListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskStatus)) {
    query['TaskStatus'] = request.taskStatus;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  if (!Util.isUnset(request.url)) {
    query['Url'] = request.url;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSyntheticTaskList',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSyntheticTaskList(request: GetSyntheticTaskListRequest): GetSyntheticTaskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSyntheticTaskListWithOptions(request, runtime);
}

model GetSyntheticTaskMonitorsRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model GetSyntheticTaskMonitorsResponseBody = {
  code?: string(name='Code', example='1001'),
  data?: [ 
    {
      busy?: long(name='Busy', example='0'),
      city?: string(name='City'),
      cityCode?: long(name='CityCode', example='1100101'),
      clientType?: long(name='ClientType', example='1'),
      district?: string(name='District'),
      netServiceId?: long(name='NetServiceId', example='18'),
      netServiceName?: string(name='NetServiceName', example='XXX'),
    }
  ](name='Data'),
  msg?: string(name='Msg', example='null'),
  requestId?: string(name='RequestId', example='21E85B16-75A6-429A-9F65-8AAC9A54****'),
}

model GetSyntheticTaskMonitorsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSyntheticTaskMonitorsResponseBody(name='body'),
}

async function getSyntheticTaskMonitorsWithOptions(request: GetSyntheticTaskMonitorsRequest, runtime: Util.RuntimeOptions): GetSyntheticTaskMonitorsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSyntheticTaskMonitors',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSyntheticTaskMonitors(request: GetSyntheticTaskMonitorsRequest): GetSyntheticTaskMonitorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSyntheticTaskMonitorsWithOptions(request, runtime);
}

model GetTraceRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. Unit: milliseconds.

> If the ID of the trace is 30 characters in length, this parameter is optional. Otherwise, this parameter is required.', example='1623827603000'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. Unit: milliseconds.

> If the ID of the trace is 30 characters in length, this parameter is optional. Otherwise, this parameter is required.', example='1623827602000'),
  traceID?: string(name='TraceID', description='The ID of the trace. You can log on to the ARMS console and obtain the trace ID on the **Trace Query** page or **Interface Snapshot** tab.', example='ac14001a15954493811405707d****'),
}

model GetTraceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6A9AEA84-7186-4D8D-B498-4585C6A2****'),
  spans?: [ 
    {
      children?: [  map[string]any ](name='Children', description='The child spans of the current span.'),
      duration?: long(name='Duration', description='The amount of time consumed by the trace. Unit: milliseconds.', example='1000'),
      haveStack?: boolean(name='HaveStack', description='Indicates whether a method stack was provided.

- `true`: A method stack was provided.
- `false` : No method stack was provided.', example='false'),
      logEventList?: [ 
        {
          tagEntryList?: [ 
            {
              key?: string(name='Key', description='The key of the tag.', example='http.status.code'),
              value?: string(name='Value', description='The value of the tag.', example='200'),
            }
          ](name='TagEntryList', description='The tags of the trace.'),
          timestamp?: long(name='Timestamp', description='The timestamp when the log event was generated.', example='1590388651'),
        }
      ](name='LogEventList', description='The log events in the trace.'),
      operationName?: string(name='OperationName', description='The name of the traced span.', example='/api/demo'),
      parentSpanId?: string(name='ParentSpanId', description='The ID of the parent span.', example='18'),
      resultCode?: string(name='ResultCode', description='The returned code.', example='222'),
      rpcId?: string(name='RpcId', description='The ID of the remote procedure call (RPC) mode.', example='0'),
      rpcType?: int32(name='RpcType', description='The type of the remote procedure call (RPC) mode.', example='1'),
      serviceIp?: string(name='ServiceIp', description='The IP address of the host where the application resides.', example='172.20.XX.XX'),
      serviceName?: string(name='ServiceName', description='The name of the application.', example='arms-demo'),
      spanId?: string(name='SpanId', description='Span ID', example='1234'),
      tagEntryList?: [ 
        {
          key?: string(name='Key', description='The key of the tag.', example='http.status.code'),
          value?: string(name='Value', description='The value of the tag.', example='200'),
        }
      ](name='TagEntryList', description='The tags of the trace.'),
      timestamp?: long(name='Timestamp', description='The timestamp when the span was generated.', example='1590388651'),
      traceID?: string(name='TraceID', description='The ID of the trace.', example='ac14001a15954493811405707d****'),
    }
  ](name='Spans', description='The details of the trace.'),
}

model GetTraceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTraceResponseBody(name='body'),
}

/**
  * > You must use Application Real-Time Monitoring Service (ARMS) SDK for Java V2.7.24.
  *
  * @param request GetTraceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetTraceResponse
 */
async function getTraceWithOptions(request: GetTraceRequest, runtime: Util.RuntimeOptions): GetTraceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.traceID)) {
    query['TraceID'] = request.traceID;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTrace',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > You must use Application Real-Time Monitoring Service (ARMS) SDK for Java V2.7.24.
  *
  * @param request GetTraceRequest
  * @return GetTraceResponse
 */
async function getTrace(request: GetTraceRequest): GetTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTraceWithOptions(request, runtime);
}

model GetTraceAppRequest {
  pid?: string(name='Pid', description='The process identifier (PID) of the application. For more information about how to obtain the PID, see [Obtain the PID of an application](~~186100~~#title-imy-7gj-qhr).', example='b590lhguqs@d8deedfa9bf****'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model GetTraceAppResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D80ADAAC-8C32-5479-BD14-C28CF832****'),
  resourceGroupId?: string(name='ResourceGroupId'),
  traceApp?: {
    appId?: long(name='AppId', description='The ID of the application.', example='123'),
    appName?: string(name='AppName', description='The name of the application.', example='arms-k8s-demo'),
    createTime?: long(name='CreateTime', description='The timestamp generated when the monitoring task was created.', example='1576599253000'),
    labels?: [ string ](name='Labels', description='The labels of the application.'),
    pid?: string(name='Pid', description='The PID of the application.', example='b590lhguqs@d8deedfa9bf****'),
    regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    show?: boolean(name='Show', description='Indicates whether the application was displayed in the Application Real-Time Monitoring Service (ARMS) console. Valid values:

*   `true`: The application was displayed in the ARMS console.
*   `false`: The application was not displayed in the ARMS console.', example='true'),
    source?: string(name='Source'),
    tags?: [ 
      {
        tagKey?: string(name='TagKey', description='The key of the tag.', example='env'),
        tagValue?: string(name='TagValue', description='The value of the tag.', example='test'),
      }
    ](name='Tags', description='The tags of the application.'),
    type?: string(name='Type', description='The type of the monitoring task. Valid values:

*   `TRACE`: application monitoring
*   `RETCODE`: browser monitoring', example='TRACE'),
    updateTime?: long(name='UpdateTime', description='The timestamp generated when the monitoring task was updated.', example='1635700348000'),
    userId?: string(name='UserId', description='The ID of the user.', example='113197164949****'),
  }(name='TraceApp', description='The struct returned.'),
}

model GetTraceAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTraceAppResponseBody(name='body'),
}

async function getTraceAppWithOptions(request: GetTraceAppRequest, runtime: Util.RuntimeOptions): GetTraceAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTraceApp',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTraceApp(request: GetTraceAppRequest): GetTraceAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTraceAppWithOptions(request, runtime);
}

model ImportAppAlertRulesRequest {
  contactGroupIds?: string(name='ContactGroupIds', description='The IDs of the alert contact groups. The value must be a JSON array.', example='[123, 234]'),
  isAutoStart?: boolean(name='IsAutoStart', description='Specifies whether to enable the alert rule after it is created. Default value: `false`.

*   `true`: enables the alert rule.
*   `false`: disables the alert rule.', example='true'),
  pids?: string(name='Pids', description='The process identifiers (PIDs) of the applications associated with the alert rule. The value must be a JSON array. For more information about how to obtain the PID, see [Obtain the PID of an application](~~186100#section-bkl-3j6-ezg~~).', example='["atc889zkcf@d8deedfa9bfxxxx", "acd129bfcf@d5daebfa6cdxxxx"]'),
  regionId?: string(name='RegionId', description='The ID of the region where the associated applications reside.', example='cn-hangzhou'),
  templageAlertConfig?: string(name='TemplageAlertConfig', description='The configurations of the alert template based on which you want to create an alert rule. The value must be a JSON string. You must set at least one of the **TemplateAlertId** and **TemplageAlertConfig** parameters. If you set both parameters, the **TemplateAlertId** parameter prevails. For more information about the TemplageAlertConfig parameter, see the following **additional information about the TemplageAlertConfig parameter**.'),
  templateAlertId?: string(name='TemplateAlertId', description='The ID of the alert template. You must set at least one of the **TemplateAlertId** and **TemplageAlertConfig** parameters. If you set both parameters, the **TemplateAlertId** parameter prevails.', example='324324234'),
}

model ImportAppAlertRulesResponseBody = {
  data?: string(name='Data', description='The ID of the alert rule.', example='[12174**]'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A5EC8221-08F2-4C95-9AF1-49FD998C****'),
}

model ImportAppAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ImportAppAlertRulesResponseBody(name='body'),
}

/**
  * >  You can call the **ImportAppAlertRules** operation to import only the alert rules that are generated by Application Real-Time Monitoring Service (ARMS) for application monitoring and browser monitoring. This operation cannot be used to import custom alert rules, alert rules for Prometheus monitoring, or default emergency alert rules.
  *
  * @param request ImportAppAlertRulesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ImportAppAlertRulesResponse
 */
async function importAppAlertRulesWithOptions(request: ImportAppAlertRulesRequest, runtime: Util.RuntimeOptions): ImportAppAlertRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupIds)) {
    query['ContactGroupIds'] = request.contactGroupIds;
  }
  if (!Util.isUnset(request.isAutoStart)) {
    query['IsAutoStart'] = request.isAutoStart;
  }
  if (!Util.isUnset(request.pids)) {
    query['Pids'] = request.pids;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.templageAlertConfig)) {
    query['TemplageAlertConfig'] = request.templageAlertConfig;
  }
  if (!Util.isUnset(request.templateAlertId)) {
    query['TemplateAlertId'] = request.templateAlertId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportAppAlertRules',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call the **ImportAppAlertRules** operation to import only the alert rules that are generated by Application Real-Time Monitoring Service (ARMS) for application monitoring and browser monitoring. This operation cannot be used to import custom alert rules, alert rules for Prometheus monitoring, or default emergency alert rules.
  *
  * @param request ImportAppAlertRulesRequest
  * @return ImportAppAlertRulesResponse
 */
async function importAppAlertRules(request: ImportAppAlertRulesRequest): ImportAppAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return importAppAlertRulesWithOptions(request, runtime);
}

model InstallCmsExporterRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  cmsArgs?: string(name='CmsArgs', description='The cloud services that you want to monitor. The CmsArgs parameter is the startup parameter of the cms-exporter collector. Separate multiple cloud services with number signs (`#`).', example='hologres#cen'),
  directArgs?: string(name='DirectArgs', description='The recently monitored cloud services. Separate multiple cloud services with number signs (`#`).', example='hologres#cen'),
  enableTag?: boolean(name='EnableTag', description='Specifies whether to collect the aliyun tags attached to each cloud service. Default value: false.', example='false'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-beijing'),
}

model InstallCmsExporterResponseBody = {
  data?: string(name='Data', description='Indicates whether the request was successful.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request. You can query logs and troubleshoot issues based on the ID.', example='E7A04B0D-E2CA-59BB-8A9D-D5D349C22BF1'),
}

model InstallCmsExporterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallCmsExporterResponseBody(name='body'),
}

async function installCmsExporterWithOptions(request: InstallCmsExporterRequest, runtime: Util.RuntimeOptions): InstallCmsExporterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.cmsArgs)) {
    query['CmsArgs'] = request.cmsArgs;
  }
  if (!Util.isUnset(request.directArgs)) {
    query['DirectArgs'] = request.directArgs;
  }
  if (!Util.isUnset(request.enableTag)) {
    query['EnableTag'] = request.enableTag;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallCmsExporter',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installCmsExporter(request: InstallCmsExporterRequest): InstallCmsExporterResponse {
  var runtime = new Util.RuntimeOptions{};
  return installCmsExporterWithOptions(request, runtime);
}

model InstallManagedPrometheusRequest {
  clusterId?: string(name='ClusterId', description='The ID of the ASK cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  clusterName?: string(name='ClusterName', description='ClusterTypeecs', example='prd-ecs'),
  clusterType?: string(name='ClusterType', description='The type of the cluster. Only ASK clusters are supported.', example='ask'),
  grafanaInstanceId?: string(name='GrafanaInstanceId', description='GrafanaId"free"Grafana', example='grafana-bp1*****'),
  kubeConfig?: string(name='KubeConfig', description='The parameter is not supported.', example='not use'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  securityGroupId?: string(name='SecurityGroupId', description='The security group to which the ASK cluster belongs.', example='sg-bp1********'),
  vSwitchId?: string(name='VSwitchId', description='The vSwitch of the ASK cluster.', example='vsw-bp1*********'),
  vpcId?: string(name='VpcId', description='The VPC of the ASK cluster.', example='vpc-xxxxxx'),
}

model InstallManagedPrometheusResponseBody = {
  code?: int32(name='Code', description='The status code returned. 200 indicates that the Prometheus agent was installed. Otherwise, the Prometheus agent fails to be installed.', example='200'),
  data?: string(name='Data', description='The content of the response. The installation status of the Prometheus agent was returned.', example='success'),
  message?: string(name='Message', description='The error message returned if the Prometheus agent fails to be installed.', example='vpcId is blank'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='String	2A0CEDF1-06FE-44AC-8E21-21A5BE65****'),
  success?: boolean(name='Success', description='Indicates whether the Prometheus agent was installed.', example='true'),
}

model InstallManagedPrometheusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallManagedPrometheusResponseBody(name='body'),
}

/**
  * You can call the API operation to install a Prometheus agent to monitor a serverless Kubernetes (ASK) cluster. You can manage the agent in Application Real-Time Monitoring Service (ARMS), but you cannot view the agent in the ASK cluster.
  *
  * @param request InstallManagedPrometheusRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return InstallManagedPrometheusResponse
 */
async function installManagedPrometheusWithOptions(request: InstallManagedPrometheusRequest, runtime: Util.RuntimeOptions): InstallManagedPrometheusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.grafanaInstanceId)) {
    query['GrafanaInstanceId'] = request.grafanaInstanceId;
  }
  if (!Util.isUnset(request.kubeConfig)) {
    query['KubeConfig'] = request.kubeConfig;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallManagedPrometheus',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call the API operation to install a Prometheus agent to monitor a serverless Kubernetes (ASK) cluster. You can manage the agent in Application Real-Time Monitoring Service (ARMS), but you cannot view the agent in the ASK cluster.
  *
  * @param request InstallManagedPrometheusRequest
  * @return InstallManagedPrometheusResponse
 */
async function installManagedPrometheus(request: InstallManagedPrometheusRequest): InstallManagedPrometheusResponse {
  var runtime = new Util.RuntimeOptions{};
  return installManagedPrometheusWithOptions(request, runtime);
}

model ListActivatedAlertsRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: `1`.', example='1'),
  filter?: string(name='Filter', description='The filter condition in the `{"key":"value"}`format. You must specify the `key` and `value` of the filter condition.'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: `10`.', example='10'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model ListActivatedAlertsResponseBody = {
  page?: {
    alerts?: [ 
      {
        alertId?: string(name='AlertId', description='The ID of the alert rule.', example='3888704'),
        alertName?: string(name='AlertName', description='The name of the alert rule.'),
        alertType?: string(name='AlertType', description='The type of the alert.'),
        count?: int32(name='Count', description='The number of times that the alert event was received.', example='598'),
        createTime?: long(name='CreateTime', description='The timestamp when the alert rule was created.', example='1616466300000'),
        dispatchRules?: [ 
          {
            ruleId?: int32(name='RuleId', description='The ID of the notification policy.', example='7021'),
            ruleName?: string(name='RuleName', description='The name of the notification policy.'),
          }
        ](name='DispatchRules', description='The notification policies.'),
        endsAt?: long(name='EndsAt', description='The timestamp when the alert was ended.', example='1616502540000'),
        expandFields?: map[string]any(name='ExpandFields', description='The extended fields that indicate the following tags:

*   The tags that are carried in the metrics of the alert rule expression.
*   The tags that are created based on the alert rule.
*   The default tags of Application Real-Time Monitoring Service (ARMS).'),
        integrationName?: string(name='IntegrationName', description='The name of the object that is associated with the alert.', example='testphp2'),
        integrationType?: string(name='IntegrationType', description='The type of the service integration that generated the alert.', example='PROMETHEUS'),
        involvedObjectKind?: string(name='InvolvedObjectKind', description='The type of the object that is associated with the alert.', example='cluster'),
        involvedObjectName?: string(name='InvolvedObjectName', description='The name of the service integration that generated the alert.'),
        message?: string(name='Message', description='The description of the alert.'),
        severity?: string(name='Severity', description='The level of the alert. Valid values:

*   `critical`
*   `error`
*   `warn`
*   `page`', example='critical'),
        startsAt?: long(name='StartsAt', description='The timestamp when the alert was generated.', example='1616466300000'),
        status?: string(name='Status', description='The status of the alert. Valid values:

*   `Active`
*   `Inhibited`
*   `Silenced`
*   `Resolved`', example='Active'),
      }
    ](name='Alerts', description='The alerts that have been triggered.'),
    page?: int32(name='Page', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    total?: int32(name='Total', description='The total number of entries returned.', example='5'),
  }(name='Page', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BDB74B8F-4123-482A-ABB7-7F440349****'),
}

model ListActivatedAlertsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListActivatedAlertsResponseBody(name='body'),
}

async function listActivatedAlertsWithOptions(request: ListActivatedAlertsRequest, runtime: Util.RuntimeOptions): ListActivatedAlertsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListActivatedAlerts',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listActivatedAlerts(request: ListActivatedAlertsRequest): ListActivatedAlertsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listActivatedAlertsWithOptions(request, runtime);
}

model ListAlertEventsRequest {
  alertName?: string(name='AlertName', example=''),
  endTime?: string(name='EndTime', example='2021-12-22 23:59:59'),
  matchingConditions?: string(name='MatchingConditions', example='[         {           "value": "ARMS_NOTIFICATION",           "key": "clustername",           "operator": "eq"         }       ]     },{       "matchingConditions": [         {           "value": "test",           "key": "alertname",           "operator": "eq"         }       ]'),
  page?: long(name='Page', example='1'),
  size?: long(name='Size', example='20'),
  startTime?: string(name='StartTime', example='2021-12-19 00:00:00'),
  status?: string(name='Status', example='Active'),
}

model ListAlertEventsResponseBody = {
  pageBean?: {
    events?: [ 
      {
        alarms?: [ 
          {
            alarmId?: long(name='AlarmId', example='77444'),
            alarmName?: string(name='AlarmName'),
            createTime?: string(name='CreateTime', example='2021-12-20 07:10:18'),
            state?: int32(name='State', example='0'),
          }
        ](name='Alarms'),
        alertName?: string(name='AlertName', example=''),
        annotations?: string(name='Annotations', example='[{\\"Name\\":\\"annotation-a\\",\\"Value\\":\\"annotation a value\\"}]'),
        description?: string(name='Description'),
        endTime?: string(name='EndTime', example='2021-12-20 17:42:16'),
        generatorURL?: string(name='GeneratorURL', example='https://xxx.xx/'),
        handlerName?: string(name='HandlerName'),
        integrationName?: string(name='IntegrationName'),
        integrationType?: string(name='IntegrationType', example='CUSTOM'),
        labels?: string(name='Labels', example='[{\\"name\\":\\"severity\\",\\"value\\":\\"error\\"}]'),
        receiveTime?: string(name='ReceiveTime', example='2021-12-20 17:42:16'),
        severity?: string(name='Severity', example='critical'),
        startTime?: string(name='StartTime', example='2021-12-20 17:42:16'),
        status?: string(name='Status', example='Active'),
      }
    ](name='Events'),
    page?: long(name='Page', example='1'),
    size?: long(name='Size', example='20'),
    total?: long(name='Total', example='24'),
  }(name='PageBean'),
  requestId?: string(name='RequestId', example='2FC13182-B9AF-4E6B-BE51-72669B7C****'),
}

model ListAlertEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlertEventsResponseBody(name='body'),
}

async function listAlertEventsWithOptions(request: ListAlertEventsRequest, runtime: Util.RuntimeOptions): ListAlertEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertName)) {
    query['AlertName'] = request.alertName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.matchingConditions)) {
    query['MatchingConditions'] = request.matchingConditions;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlertEvents',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlertEvents(request: ListAlertEventsRequest): ListAlertEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlertEventsWithOptions(request, runtime);
}

model ListAlertsRequest {
  alertName?: string(name='AlertName', description='The name of the alert rule.', example='Test alert'),
  dispatchRuleId?: long(name='DispatchRuleId', description='The ID of the notification policy.', example='12345'),
  endTime?: string(name='EndTime', description='The end time of the alert sending history that you want to query. Specify the time in the `YYYY-MM-DD HH:mm:ss` format.', example='2021-12-22 23:59:59'),
  integrationType?: string(name='IntegrationType', description='The type of the integration. Valid values:

*   ARMS
*   CLOUD_MONITOR
*   MSE
*   ARMS_CLOUD_DIALTEST
*   PROMETHEUS
*   LOG_SERVICE
*   CUSTOM
*   ARMS_PROMETHEUS
*   ARMS_APP_MON
*   ARMS_FRONT_MON
*   ARMS_CUSTOM
*   XTRACE
*   GRAFANA
*   ZABBIX
*   SKYWALKING
*   EVENT_BRIDGE
*   NAGIOS
*   OPENFALCON
*   ARMS_INSIGHTS', example='ARMS_APP_MON'),
  page?: long(name='Page', description='The number of the page to return.', example='1'),
  severity?: string(name='Severity', description='The severity level of the alert. Valid values: P6, P5, P4, P3, P2, and P1. The preceding values are listed in ascending order of severity.', example='P6'),
  showActivities?: boolean(name='ShowActivities', description='Specifies whether to query the activities that correspond to alerts. Valid values:

*   `false` (default value): The activities are not queried.
*   `true`: The activities in the last three days are queried.', example='true'),
  showEvents?: boolean(name='ShowEvents', description='Specifies whether to query the events that correspond to alerts. Valid values:

*   `false` (default value): The events are not queried.
*   `true`: The events are queried.', example='true'),
  size?: long(name='Size', description='The number of alerts to return on each page.', example='20'),
  startTime?: string(name='StartTime', description='The start time of the alert sending history that you want to query. Specify the time in the `YYYY-MM-DD HH:mm:ss` format.', example='2021-12-10 00:00:00'),
  state?: long(name='State', description='The status of the alert. Valid values:

*   0: The alert is waiting to be handled.
*   1: The alert is being handled.
*   2: The alert is handled.', example='2'),
}

model ListAlertsResponseBody = {
  pageBean?: {
    listAlerts?: [ 
      {
        activities?: [ 
          {
            content?: string(name='Content', description='The content of the alert notification.', example='\\[Notification policy: Send notifications to DingTalk groups] Host monitoring. Host IP address: 10.76.XX.XX. Average memory usage of the host in the last 1 minute  1.0%. Current value: 84.7454%.'),
            description?: string(name='Description', description='The description of the activity.', example='\\[Alert Claimed] The alert is claimed'),
            handlerName?: string(name='HandlerName', description='The name of the handler.', example='O\\&M Engineer A'),
            time?: string(name='Time', description='The operation time of the activity.', example='2021-12-20 19:08:57'),
            type?: long(name='Type', description='The type of the activity. Valid values:

*   1: The alert is claimed.
*   2: The alert is disclaimed.
*   3: A comment is added for the alert.
*   4: The alert is disabled.
*   5: An alert notification is sent.', example='1'),
          }
        ](name='Activities', description='The list of activities.'),
        alertEvents?: [ 
          {
            alertName?: string(name='AlertName', description='The name of the event.', example='Test-triggered alert'),
            annotations?: string(name='Annotations', description='The list of annotations.', example='{ "_aliyun_arms_alert_value":"4.0" "_aliyun_arms_alert_traceId":"ac10c43116421327442277073d5461-105075299"}'),
            description?: string(name='Description', description='The description of the event.', example='Host monitoring. Host IP address: 10.76.XX.XX. Average memory usage of the host in the last 1 minute  1.0%. Current value: 84.7454%.'),
            endTime?: string(name='EndTime', description='The time when the event ended.', example='2022-01-19 17:10:31'),
            generatorURL?: string(name='GeneratorURL', description='The URL of the event.', example='http://arms.console.aliyun.com'),
            integrationName?: string(name='IntegrationName', description='The name of the integration that corresponds to the alert event.', example='ARMS'),
            integrationType?: string(name='IntegrationType', description='The type of the integration that corresponds to the alert event. Valid values:

*   ARMS
*   CLOUD_MONITOR
*   MSE
*   ARMS_CLOUD_DIALTEST
*   PROMETHEUS
*   LOG_SERVICE
*   CUSTOM
*   ARMS_PROMETHEUS
*   ARMS_APP_MON
*   ARMS_FRONT_MON
*   ARMS_CUSTOM
*   XTRACE
*   GRAFANA
*   ZABBIX
*   SKYWALKING
*   EVENT_BRIDGE
*   NAGIOS
*   OPENFALCON
*   ARMS_INSIGHTS', example='ARMS_APP_MON'),
            labels?: string(name='Labels', description='The list of tags.', example='{ "severity":"warning" "_aliyun_arms_alert_level":"ERROR" "_aliyun_arms_entropy":"0.30170457417889235"}'),
            receiveTime?: string(name='ReceiveTime', description='The time when the event was created.', example='2022-01-19 17:05:42'),
            severity?: string(name='Severity', description='The severity level of the event. Valid values:

*   critical
*   error
*   warning
*   info', example='warning'),
            startTime?: string(name='StartTime', description='The time when the event started.', example='2022-01-18 00:14:00'),
            state?: string(name='State', description='The status of the event. Valid values:

*   Active: The event is not cleared.
*   Silenced: The event is silenced.
*   Resolved: The event is cleared.', example='Active'),
          }
        ](name='AlertEvents', description='The list of events.'),
        alertId?: long(name='AlertId', description='The ID of the alert.', example='2279'),
        alertName?: string(name='AlertName', description='The name of the alert.', example='Test alert'),
        createTime?: string(name='CreateTime', description='The time when the alert was created.', example='2022-01-18 00:21:35'),
        dispatchRuleId?: float(name='DispatchRuleId', description='The ID of the notification policy.', example='12345'),
        dispatchRuleName?: string(name='DispatchRuleName', description='The name of the notification policy.', example='Send notifications to DingTalk groups'),
        severity?: string(name='Severity', description='The severity level of the alert. Valid values: P6, P5, P4, P3, P2, and P1. The preceding values are listed in ascending order of severity.', example='P6'),
        state?: long(name='State', description='The status of the alert. Valid values:

*   0: The alert is waiting to be handled.
*   1: The alert is being handled.
*   2: The alert is handled.', example='0'),
      }
    ](name='ListAlerts', description='The alerts for which the alert sending history is queried.'),
    page?: long(name='Page', description='The page number of the returned page.', example='1'),
    size?: long(name='Size', description='The number of alerts returned per page.', example='20'),
    total?: long(name='Total', description='The total number of queried alerts.', example='1'),
  }(name='PageBean', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FC13182-B9AF-4E6B-BE51-72669B7C****'),
}

model ListAlertsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlertsResponseBody(name='body'),
}

async function listAlertsWithOptions(request: ListAlertsRequest, runtime: Util.RuntimeOptions): ListAlertsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertName)) {
    query['AlertName'] = request.alertName;
  }
  if (!Util.isUnset(request.dispatchRuleId)) {
    query['DispatchRuleId'] = request.dispatchRuleId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.integrationType)) {
    query['IntegrationType'] = request.integrationType;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.severity)) {
    query['Severity'] = request.severity;
  }
  if (!Util.isUnset(request.showActivities)) {
    query['ShowActivities'] = request.showActivities;
  }
  if (!Util.isUnset(request.showEvents)) {
    query['ShowEvents'] = request.showEvents;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlerts',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlerts(request: ListAlertsRequest): ListAlertsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlertsWithOptions(request, runtime);
}

model ListClusterFromGrafanaRequest {
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model ListClusterFromGrafanaResponseBody = {
  promClusterList?: [ 
    {
      agentStatus?: string(name='AgentStatus', description='The status of the Prometheus agent on the cluster.', example='INSTALL_FAILED'),
      clusterId?: string(name='ClusterId', description='The ID of cluster.', example='c0df7ad9db0ed43128925ca04774c469e'),
      clusterName?: string(name='ClusterName', description='The name of the cluster.', example='ay-ads-hangzhou'),
      clusterType?: string(name='ClusterType', description='The type of the instance.', example='cloud-product-prometheus'),
      controllerId?: string(name='ControllerId', description='The ID of the controller.', example='1092'),
      createTime?: long(name='CreateTime', description='The time when the dashboard was created.', example='2021-12-09T02:05:04Z'),
      extra?: string(name='Extra', description='The extended fields. This parameter is a JSON string.', example='{\\"app_id\\":\\"bbd\\",\\"task_id\\":\\"4305ba5bf14942daa6e553ed91f46988\\"}'),
      id?: long(name='Id', description='The ID of a database in the cluster.', example='16136'),
      installTime?: long(name='InstallTime', description='The timestamp when the Prometheus agent was installed.', example='1653532518000'),
      isControllerInstalled?: boolean(name='IsControllerInstalled', description='Indicates whether the Prometheus agent was installed. Valid values:

*   true: The Prometheus agent was installed.
*   false: The Prometheus agent was not installed.', example='true'),
      lastHeartBeatTime?: long(name='LastHeartBeatTime', description='The time when the last heartbeat was reported.', example='1653532518000'),
      nodeNum?: int32(name='NodeNum', description='The number of nodes.', example='3'),
      options?: string(name='Options', description='The custom parameters.', example='{\\"Option\\": [\\"betaTestApproved\\"]}'),
      pluginsJsonArray?: string(name='PluginsJsonArray', description='The list of nodejsonar logs.', example='{}'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-beijing'),
      stateJson?: string(name='StateJson', description='The information about applications deployed in the cluster.', example='{}'),
      updateTime?: long(name='UpdateTime', description='The time when the dashboard was updated.', example='2021-11-16T08:49:34Z'),
      userId?: string(name='UserId', description='The ID of the Alibaba Cloud account to which the cluster belongs.', example='1247285**'),
    }
  ](name='PromClusterList', description='The cluster information.'),
  requestId?: string(name='RequestId', description='The ID of the request. You can query logs and troubleshoot issues based on the ID.', example='6849D41E-EED4-5C00-89F9-6047BBD9DCB4'),
}

model ListClusterFromGrafanaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClusterFromGrafanaResponseBody(name='body'),
}

async function listClusterFromGrafanaWithOptions(request: ListClusterFromGrafanaRequest, runtime: Util.RuntimeOptions): ListClusterFromGrafanaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterFromGrafana',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterFromGrafana(request: ListClusterFromGrafanaRequest): ListClusterFromGrafanaResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterFromGrafanaWithOptions(request, runtime);
}

model ListCmsInstancesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='n9p9o9o3se'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  typeFilter?: string(name='TypeFilter', description='The filter condition. Format: \\[unk]{"key":"value"}\\[unk]. You must set the \\[unk]key\\[unk] and \\[unk]value\\[unk] fields.', example='direct'),
}

model ListCmsInstancesResponseBody = {
  data?: {
    enableTag?: boolean(name='EnableTag', description='Indicates whether to collect the aliyun tags attached to each cloud service.', example='true'),
    products?: [ 
      {
        descr?: string(name='Descr', description='The description of the cloud service.', example='-'),
        id?: string(name='Id', description='The ID of the instance.', example='20210'),
        instance?: string(name='Instance', description='The name of the instance.', example='cloudserver'),
        name?: string(name='Name', description='The name of the cloud service.', example='hologres'),
        prod?: string(name='Prod', description='The code of the cloud service.', example='face'),
        source?: string(name='Source', description='The event source.', example='arms'),
        state?: string(name='State', description='The status of the integration. Valid values:

*   `true`: The integration was enabled.
*   `false`: The integration was disabled.', example='true'),
        time?: string(name='Time', description='The timestamp when the Grafana dashboard was created.', example='1647852021000'),
        type?: string(name='Type', description='The type of the cloud service.', example='HOLOGRES'),
        url?: string(name='Url', description='The complete URL of the Grafana dashboard.', example='https://g.console.aliyun.com/d/1098370038733503-35894-565/cms-hologres?orgId\\u003d9\\u0026refresh\\u003d60s'),
      }
    ](name='Products', description='The struct returned.'),
  }(name='Data', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E7A04B0D-E2CA-59BB-8A9D-D5D349C22BF1'),
}

model ListCmsInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCmsInstancesResponseBody(name='body'),
}

async function listCmsInstancesWithOptions(request: ListCmsInstancesRequest, runtime: Util.RuntimeOptions): ListCmsInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.typeFilter)) {
    query['TypeFilter'] = request.typeFilter;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCmsInstances',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCmsInstances(request: ListCmsInstancesRequest): ListCmsInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCmsInstancesWithOptions(request, runtime);
}

model ListDashboardsRequest {
  clusterId?: string(name='ClusterId', description='The ID of the Container Service for Kubernetes cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  clusterType?: string(name='ClusterType', description='The type of the cluster. Valid values: ACK, ASK, cloud-product-prometheus, and Node. You can query the dashboards of a virtual cluster by specifying the cluster type. For InfluxDB, set this parameter to `cloud-product-prometheus`.', example='Node'),
  dashboardName?: string(name='DashboardName', description='The unique names of the dashboards. You can query dashboards by specifying their names. The **dashboard title** can be changed whereas the **dashboard name** cannot. You can specify multiple names and separate them with commas (,), for example, `k8s-event,k8s-overview`. A dashboard may have multiple versions. If you want to specify a version, you can add version information after the name, for example, `k8s-event:v1,k8s-overview:latest`.', example='k8s-node-overview'),
  language?: string(name='Language', description='The language of the Grafana dashboards.', example='en'),
  product?: string(name='Product', description='The product code. This parameter is required if you set the ClusterType parameter to `cloud-product-prometheus`. Valid values:

*   InfluxDB
*   MongoDB
*   DLA
*   SAE', example='xxxx'),
  recreateSwitch?: boolean(name='RecreateSwitch', description='Specifies whether to create or query a virtual cluster. This parameter provides backward compatibility.', example='false'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  title?: string(name='Title', description='The dashboard title. The dashboard title can be changed. We recommend that you specify the **DashboardName** parameter.', example='ApiServer'),
}

model ListDashboardsResponseBody = {
  dashboardVos?: [ 
    {
      dashboardType?: string(name='DashboardType', description='The type of the Grafana dashboard. This parameter has the same effect as the Exporter parameter whereas provides clearer implication.', example='Node'),
      exporter?: string(name='Exporter', description='The type of the exporter access source. Valid values:

*   Prometheus
*   Node
*   GPU
*   Redis
*   MySQL
*   Kafka
*   NGINX V2
*   Nginx
*   ZooKeeper
*   MongoDB
*   RabbitMQ
*   PostgreSQL
*   Kubernetes
*   Client Library
*   Elasticsearch
*   RocketMQ', example='Nginx'),
      httpUrl?: string(name='HttpUrl', description='The URL of the Grafana dashboard.', example='http://g.console.aliyun.com/d/1131971649496228-*****-59/ApiServer?orgId=3**&refresh=60s'),
      httpsUrl?: string(name='HttpsUrl', description='The URL of the Grafana dashboard.', example='http://g.console.aliyun.com/d/1131971649496228-*****-59/ApiServer?orgId=3**&refresh=60s'),
      i18nChild?: {
        dashboardType?: string(name='DashboardType', description='The type of the Grafana dashboard. This parameter has the same effect as the Exporter parameter whereas provides clearer implication.', example='Node'),
        exporter?: string(name='Exporter', description='The type of the exporter access source. Valid values:

*   Prometheus
*   Node
*   GPU
*   Redis
*   MySQL
*   Kafka
*   NGINX V2
*   Nginx
*   ZooKeeper
*   MongoDB
*   RabbitMQ
*   PostgreSQL
*   Kubernetes
*   Client Library
*   Elasticsearch
*   RocketMQ', example='Nginx'),
        httpUrl?: string(name='HttpUrl', description='The URL of the Grafana dashboard.', example='http://g.console.aliyun.com/d/1131971649496228-*****-59/ApiServer?orgId=3**&refresh=60s'),
        httpsUrl?: string(name='HttpsUrl', description='The URL of the Grafana dashboard.', example='http://g.console.aliyun.com/d/1131971649496228-*****-59/ApiServer?orgId=3**&refresh=60s'),
        id?: string(name='Id', description='The ID of the Grafana dashboard. The value is unique only when you install the Grafana dashboard.', example='1100**'),
        isArmsExporter?: boolean(name='IsArmsExporter', description='Indicates whether the exporter was provided by ARMS. Valid values:

*   `true`: The exporter is provided by ARMS.
*   `false`: The exporter is not provided by ARMS.', example='false'),
        kind?: string(name='Kind', description='The category of the Grafana dashboard. Valid values: BASIC, THIRD, LIMIT, and CUSTOM.', example='BASIC'),
        language?: string(name='Language', description='The language of the Grafana dashboard.', example='zh'),
        name?: string(name='Name', description='The name of the Grafana dashboard. This parameter is different from the **Title** parameter as this parameter cannot be changed.', example='k8s-node-overview'),
        needUpdate?: boolean(name='NeedUpdate', description='Indicates whether the Grafana dashboard had a new version that was available for upgrade.', example='false'),
        tags?: [ string ](name='Tags', description='The tags of the Grafana dashboard.'),
        time?: string(name='Time', description='The timestamp when the Grafana dashboard was created.', example='1590136924'),
        title?: string(name='Title', description='The title of the Grafana dashboard.', example='ApiServer'),
        type?: string(name='Type', description='The type of the Grafana dashboard. Valid values:

*   `dash-db`: a dashboard
*   `dash-folder`: a folder that can include a dashboard', example='dash-db'),
        uid?: string(name='Uid', description='The unique identifier of a dashboard when multiple Grafana dashboards were installed. It is a unique business ID displayed on the page.', example='1131971649496228-*****-59'),
        url?: string(name='Url', description='The complete URL of the Grafana dashboard.', example='http://g.console.aliyun.com/d/1131971649496228-*****-59/ApiServer?orgId=3**&refresh=60s'),
        version?: string(name='Version', description='The version of the Grafana dashboard. The combination of version and name uniquely identifies a dashboard.', example='v2'),
      }(name='I18nChild', description='The information about the Grafana dashboard.'),
      id?: string(name='Id', description='The ID of the Grafana dashboard. The value is unique only when you install the Grafana dashboard.', example='1100**'),
      isArmsExporter?: boolean(name='IsArmsExporter', description='Indicates whether the exporter was provided by ARMS. Valid values:

*   `true`: The exporter is provided by ARMS.
*   `false`: The exporter is not provided by ARMS.', example='false'),
      kind?: string(name='Kind', description='The type of the dashboard. Valid values: BASIC, THIRD, LIMIT, and CUSTOM. BASIC indicates a basic dashboard. THIRD indicates a third-party dashboard. LIMIT indicates a time-limited free dashboard. CUSTOM indicates a custom dashboard.', example='BASIC'),
      language?: string(name='Language', description='The language of the Grafana dashboard.', example='en'),
      name?: string(name='Name', description='The name of the Grafana dashboard. This parameter is different from the **Title** parameter as this parameter cannot be changed.', example='k8s-node-overview'),
      needUpdate?: boolean(name='NeedUpdate', description='Indicates whether the Grafana dashboard had a new version that was available for upgrade.', example='false'),
      tags?: [ string ](name='Tags', description='The tags of the Grafana dashboard.'),
      time?: string(name='Time', description='The timestamp when the Grafana dashboard was created.', example='1590136924'),
      title?: string(name='Title', description='The title of the Grafana dashboard.', example='ApiServer'),
      type?: string(name='Type', description='The type of the Grafana dashboard. Valid values:

*   `dash-db`: a dashboard
*   `dash-folder`: a folder that can include a dashboard', example='dash-db'),
      uid?: string(name='Uid', description='The unique identifier of a dashboard when multiple Grafana dashboards were installed. It is a unique business ID displayed on the page.', example='1131971649496228-*****-59'),
      url?: string(name='Url', description='The complete URL of the Grafana dashboard.', example='http://g.console.aliyun.com/d/1131971649496228-*****-59/ApiServer?orgId=3**&refresh=60s'),
      version?: string(name='Version', description='The version of the Grafana dashboard. The combination of version and name uniquely identifies a dashboard.', example='v2'),
    }
  ](name='DashboardVos', description='The information about the Grafana dashboards.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2A0CEDF1-06FE-44AC-8E21-21A5BE65****'),
}

model ListDashboardsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDashboardsResponseBody(name='body'),
}

/**
  * ********
  *
  * @param request ListDashboardsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListDashboardsResponse
 */
async function listDashboardsWithOptions(request: ListDashboardsRequest, runtime: Util.RuntimeOptions): ListDashboardsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.dashboardName)) {
    query['DashboardName'] = request.dashboardName;
  }
  if (!Util.isUnset(request.language)) {
    query['Language'] = request.language;
  }
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  if (!Util.isUnset(request.recreateSwitch)) {
    query['RecreateSwitch'] = request.recreateSwitch;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDashboards',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ********
  *
  * @param request ListDashboardsRequest
  * @return ListDashboardsResponse
 */
async function listDashboards(request: ListDashboardsRequest): ListDashboardsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDashboardsWithOptions(request, runtime);
}

model ListDashboardsByNameRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  clusterType?: string(name='ClusterType', description='The type of the cluster.', example='cloud-product-prometheus'),
  dashBoardName?: string(name='DashBoardName', description='The name of the dashboard.', example='edas-ingress-url'),
  dashBoardVersion?: string(name='DashBoardVersion', description='The version of the dashboard.', example='lastest'),
  dataSourceType?: string(name='DataSourceType', description='The type of the data source.', example='loki'),
  groupName?: string(name='GroupName', description='The name of the dashboard group.', example='EDAS'),
  onlyQuery?: boolean(name='OnlyQuery', description='Specifies whether to display the Grafana dashboard only in the Application Real-Time Monitoring Service (ARMS) console.', example='true'),
  productCode?: string(name='ProductCode', description='The abbreviation of the Alibaba Cloud service name.', example='edas'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model ListDashboardsByNameResponseBody = {
  data?: string(name='Data', description='The struct returned.', example='[{"name":"Edas Ingress Url Analysis","type":"edas-ingress-url-analysis","url":"https://g.console.aliyun.com/d/1036052989950239-11040375-66-3/edas-ingress-url-analysis?var-clusterId=29ksa&var-regionId=cn-hangzhou"}]'),
  requestId?: string(name='RequestId', description='The ID of the request. You can query logs and troubleshoot issues based on the ID.', example='2983BEF7-4A0D-47A2-94A2-8E9C5E63****'),
}

model ListDashboardsByNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDashboardsByNameResponseBody(name='body'),
}

async function listDashboardsByNameWithOptions(request: ListDashboardsByNameRequest, runtime: Util.RuntimeOptions): ListDashboardsByNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.dashBoardName)) {
    query['DashBoardName'] = request.dashBoardName;
  }
  if (!Util.isUnset(request.dashBoardVersion)) {
    query['DashBoardVersion'] = request.dashBoardVersion;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    query['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.onlyQuery)) {
    query['OnlyQuery'] = request.onlyQuery;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDashboardsByName',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDashboardsByName(request: ListDashboardsByNameRequest): ListDashboardsByNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDashboardsByNameWithOptions(request, runtime);
}

model ListDispatchRuleRequest {
  name?: string(name='Name', description='The name of the notification policy to be queried. Fuzzy match is supported.', example='Prod'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  system?: boolean(name='System', description='*   The type of notification policies to be queried. Valid values: `false`: notification policies created in Application Real-Time Monitoring Service (ARMS). This is the default value.

*   `true`: notification policies created in an external system.

> You cannot use the ARMS console to modify the dispatch rules of a notification policy that is created in an external system.', example='true'),
}

model ListDispatchRuleResponseBody = {
  dispatchRules?: [ 
    {
      name?: string(name='Name', description='The name of the notification policy.', example='Prod'),
      ruleId?: long(name='RuleId', description='The ID of the notification policy.', example='10282'),
      state?: string(name='State', description='Indicates whether the notification policy is enabled.

*   `true`: The notification policy is enabled.
*   `false`: The notification policy is disabled.', example='true'),
    }
  ](name='DispatchRules', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='34ED024E-9E31-434A-9E4E-D9D15C3****'),
}

model ListDispatchRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDispatchRuleResponseBody(name='body'),
}

async function listDispatchRuleWithOptions(request: ListDispatchRuleRequest, runtime: Util.RuntimeOptions): ListDispatchRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.system)) {
    query['System'] = request.system;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDispatchRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDispatchRule(request: ListDispatchRuleRequest): ListDispatchRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDispatchRuleWithOptions(request, runtime);
}

model ListEscalationPoliciesRequest {
  name?: string(name='Name', description='The name of the escalation policy.', example='prod escalation policy'),
  page?: long(name='Page', description='The number of the page to return.', example='1'),
  size?: long(name='Size', description='The number of entries to return on each page.', example='20'),
}

model ListEscalationPoliciesResponseBody = {
  pageBean?: {
    escalationPolicies?: [ 
      {
        id?: long(name='Id', description='The ID of the escalation policy.', example='1234'),
        name?: string(name='Name', description='The name of the escalation policy.', example='prod escalation policy'),
      }
    ](name='EscalationPolicies', description='The list of escalation policies.'),
    page?: long(name='Page', description='The page number of the returned page.', example='1'),
    size?: long(name='Size', description='The number of entries returned per page.', example='20'),
    total?: long(name='Total', description='The total number of returned entries.', example='1'),
  }(name='PageBean', description='The objects that were returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='78901766-3806-4E96-8E47-CFEF59E4****'),
}

model ListEscalationPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEscalationPoliciesResponseBody(name='body'),
}

async function listEscalationPoliciesWithOptions(request: ListEscalationPoliciesRequest, runtime: Util.RuntimeOptions): ListEscalationPoliciesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEscalationPolicies',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEscalationPolicies(request: ListEscalationPoliciesRequest): ListEscalationPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEscalationPoliciesWithOptions(request, runtime);
}

model ListEventBridgeIntegrationsRequest {
  name?: string(name='Name', description='The name of the EventBridge integration.', example='EventBridge_Test'),
  page?: long(name='Page', description='The number of the page to return.', example='1'),
  size?: long(name='Size', description='The number of entries to return on each page.', example='15'),
}

model ListEventBridgeIntegrationsResponseBody = {
  pageBean?: {
    eventBridgeIntegrations?: [ 
      {
        description?: string(name='Description', description='The description of the EventBridge integration.', example='test'),
        id?: long(name='Id', description='The ID of the EventBridge integration.', example='123'),
        name?: string(name='Name', description='The name of the EventBridge integration.', example='EventBridge_Test'),
      }
    ](name='EventBridgeIntegrations', description='The EventBridge integrations.'),
    page?: long(name='Page', description='The number of the page returned.', example='1'),
    size?: long(name='Size', description='The number of entries that are returned on each page.', example='15'),
    total?: long(name='Total', description='The total number of EventBridge integrations that are returned.', example='1'),
  }(name='PageBean', description='The information about EventBridge integrations on each page.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2B289756-E791-5842-BCBD-AD414C******'),
}

model ListEventBridgeIntegrationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventBridgeIntegrationsResponseBody(name='body'),
}

async function listEventBridgeIntegrationsWithOptions(request: ListEventBridgeIntegrationsRequest, runtime: Util.RuntimeOptions): ListEventBridgeIntegrationsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEventBridgeIntegrations',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEventBridgeIntegrations(request: ListEventBridgeIntegrationsRequest): ListEventBridgeIntegrationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventBridgeIntegrationsWithOptions(request, runtime);
}

model ListInsightsEventsRequest {
  endTime?: string(name='EndTime', description='The ID of the request.', example='1480607940000'),
  insightsTypes?: string(name='InsightsTypes', description='The details of the event.', example='errorIncrease,topErrorIncrease,topExceptionIncrease,topRtIncrease,rtIncrease'),
  pid?: string(name='Pid', description='The end of the time range to query. The value is a timestamp.', example='aokcdqn3ly@a195c6d6421****'),
  regionId?: string(name='RegionId', description='The ID of the application.', example='cn-hangzhou'),
  startTime?: string(name='StartTime', description='The types of the events that you want to query. Separate multiple event types with commas (,). If you do not specify this parameter, all events are queried.

*   errorIncrease: API error-rate spike events. Examples: HTTP API error-rate spike events and Dubbo API error-rate spike events.
*   topErrorIncrease: the top five API error-rate spike events with the highest traffic.
*   topRtIncrease: API response-time spike events. Examples: HTTP API response-time spike events and Dubbo API response-time spike events.
*   rtIncrease: the top five API response-time spike events with the highest traffic.', example='1595174400000'),
}

model ListInsightsEventsResponseBody = {
  insightsEvents?: [ 
    {
      date?: long(name='Date', example='1658890560'),
      desc?: string(name='Desc', description='The ID of the application associated with the event.', example='The severity of the event.'),
      level?: string(name='Level', description='Queries the abnormal Insights events within a specified period of time.', example='P3'),
      pid?: string(name='Pid', description='auditing', example='dsv9zcel92@7da413b******'),
      title?: string(name='Title', description='The overall response time of the \\[HTTP] service of the application \\[sd] spikes at \\[2022-07-27 10:57:00]', example='The type of the event.'),
      type?: string(name='Type', description='The time at which the event occurred. The value is a timestamp.', example='rtIncrease'),
    }
  ](name='InsightsEvents', description='The description of the event.'),
  requestId?: string(name='RequestId', description='The title of the event.', example='6F1174DC-6085-5353-AAE7-D4ADCD******'),
}

model ListInsightsEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInsightsEventsResponseBody(name='body'),
}

async function listInsightsEventsWithOptions(request: ListInsightsEventsRequest, runtime: Util.RuntimeOptions): ListInsightsEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.insightsTypes)) {
    query['InsightsTypes'] = request.insightsTypes;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInsightsEvents',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInsightsEvents(request: ListInsightsEventsRequest): ListInsightsEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInsightsEventsWithOptions(request, runtime);
}

model ListIntegrationRequest {
  integrationName?: string(name='IntegrationName', description='The name of the alert integration.', example='CloudMonitor integration'),
  integrationProductType?: string(name='IntegrationProductType', description='The service of the alert integration. Valid values:

*   CLOUD_MONITOR: CloudMonitor
*   LOG_SERVICE: Log Service', example='CLOUD_MONITOR'),
  isDetail?: boolean(name='IsDetail', description='Specifies whether to display the details of each alert integration:

*   true
*   false', example='true'),
  page?: long(name='Page', description='The number of the page to return.', example='1'),
  size?: long(name='Size', description='The number of alert integrations to return on each page.', example='10'),
}

model ListIntegrationResponseBody = {
  pageInfo?: {
    integrations?: [ 
      {
        apiEndpoint?: string(name='ApiEndpoint', description='The endpoint of the alert integration.', example='https://alerts.aliyuncs.com/api/v1/integrations/custom/ymQBN******'),
        createTime?: string(name='CreateTime', description='The time when the alert integration was created.', example='2022-06-18'),
        integrationDetail?: {
          autoRecover?: boolean(name='AutoRecover', description='Indicates whether alert events are automatically cleared. Valid values:

*   true (default)
*   false', example='true'),
          description?: string(name='Description', description='The description of the alert integration.', example='Test'),
          duplicateKey?: string(name='DuplicateKey', description='The fields whose values are deduplicated.', example='LABEL.alertname::LABEL.severity'),
          extendedFieldRedefineRules?: [  map[string]any ](name='ExtendedFieldRedefineRules', description='The extended mapped fields of the alert source.'),
          fieldRedefineRules?: [  map[string]any ](name='FieldRedefineRules', description='The predefined mapped fields of the alert source.'),
          initiativeRecoverField?: string(name='InitiativeRecoverField', description='The field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.

> Only the Log Service alert integration supports the parameter.', example='$.status'),
          initiativeRecoverValue?: string(name='InitiativeRecoverValue', description='The value of the field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.

> Only the Log Service alert integration supports the parameter.', example='ok'),
          recoverTime?: long(name='RecoverTime', description='The time when alert events are automatically cleared. Unit: seconds. Default value: 300.', example='300'),
          stat?: [ long ](name='Stat', description='The total number of alert events and the number of abnormal alert events in the last hour.'),
        }(name='IntegrationDetail', description='The information about the alert events.'),
        integrationId?: long(name='IntegrationId', description='The ID of the alert integration.', example='1234'),
        integrationName?: string(name='IntegrationName', description='The name of the alert integration.', example='CloudMonitor integration'),
        integrationProductType?: string(name='IntegrationProductType', description='The service of the alert integration. Valid values:

*   CLOUD_MONITOR: CloudMonitor
*   LOG_SERVICE: Log Service', example='CLOUD_MONITOR'),
        liveness?: string(name='Liveness', description='The activity of the alert integration', example='ready'),
        shortToken?: string(name='ShortToken', description='The authentication token of the alert integration.', example='ymQBN******'),
        state?: boolean(name='State', description='Indicates whether the alert integration was enabled. Valid values:

*   true
*   false', example='true'),
      }
    ](name='Integrations', description='The information about each alert integration.'),
    page?: long(name='Page', description='The page number of the returned page.', example='1'),
    size?: long(name='Size', description='The number of alert integrations returned per page.', example='10'),
    total?: long(name='Total', description='The total number of alert integrations.', example='1'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='34ED024E-9E31-434A-9E4E-D9D15C3****'),
}

model ListIntegrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIntegrationResponseBody(name='body'),
}

async function listIntegrationWithOptions(request: ListIntegrationRequest, runtime: Util.RuntimeOptions): ListIntegrationResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIntegration',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listIntegration(request: ListIntegrationRequest): ListIntegrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIntegrationWithOptions(request, runtime);
}

model ListNotificationPoliciesRequest {
  ids?: string(name='Ids'),
  isDetail?: boolean(name='IsDetail', description='Specifies whether to query the details about notification policies. Valid values:

*   `true`: Details about notification policies are queried.
*   `false`: Details about notification policies are not queried.', example='false'),
  name?: string(name='Name', description='The name of the notification policy.', example='notificationpolicy_test'),
  page?: long(name='Page', description='The number of the page to return.', example='1'),
  regionId?: string(name='RegionId'),
  size?: long(name='Size', description='The number of entries to return on each page.', example='20'),
}

model ListNotificationPoliciesResponseBody = {
  pageBean?: {
    notificationPolicies?: [ 
      {
        escalationPolicyId?: long(name='EscalationPolicyId', description='The ID of the escalation rule.', example='123'),
        groupRule?: {
          groupInterval?: long(name='GroupInterval', description='The time interval for grouping. Unit: seconds. Default value: 30.', example='30'),
          groupWait?: long(name='GroupWait', description='The waiting time for grouping. Unit: seconds. Default value: 5.', example='5'),
          groupingFields?: [ string ](name='GroupingFields', description='The fields that are used to group events.'),
        }(name='GroupRule', description='The grouping rule for alert events.'),
        id?: long(name='Id', description='The ID of the notification policy.', example='1234'),
        integrationId?: long(name='IntegrationId', description='The integration ID of the ticket system to which alerts are pushed.', example='34'),
        matchingRules?: [ 
          {
            matchingConditions?: [ 
              {
                key?: string(name='Key', description='The key of the matching condition.', example='altertname'),
                operator?: string(name='Operator', description='The logical operator of the matching condition. Valid values:

*   `eq`: equal to.
*   `neq`: not equal to.
*   `in`: contains.
*   `nin`: does not contain.
*   `re`: regular expression match.
*   `nre`: regular expression mismatch.', example='eq'),
                value?: string(name='Value', description='The value of the matching condition.', example='test'),
              }
            ](name='MatchingConditions', description='The alert event matching conditions.'),
          }
        ](name='MatchingRules', description='The alert event matching rules.'),
        name?: string(name='Name', description='The name of the notification policy.', example='notificationpolicy_test'),
        notifyRule?: {
          notifyChannels?: [ string ](name='NotifyChannels', description='The notification method. Valid values: 

- `dingTalk`: notification by DingTalk.
- `email`: notification by email.
- `sms`: notification by text message.
- `tts`: notification by phone.
- `webhook`: notification by webhook.'),
          notifyEndTime?: string(name='NotifyEndTime', description='The end time of the notification window.', example='23:59'),
          notifyObjects?: [ 
            {
              notifyObjectId?: long(name='NotifyObjectId', description='The ID of the contact.', example='123'),
              notifyObjectName?: string(name='NotifyObjectName', description='The name of the contact.', example='test'),
              notifyObjectType?: string(name='NotifyObjectType', description='The type of the contact. Valid values: 

- CONTACT: an individual contact
- CONTACT_GROUP: a contact group
- DING_ROBOT: an instant messaging (IM) robot
- CONTACT_SCHEDULE: a person on duty based on an established schedule', example='CONTACT'),
            }
          ](name='NotifyObjects', description='The contacts.'),
          notifyStartTime?: string(name='NotifyStartTime', description='The start time of the notification window.', example='00:00'),
        }(name='NotifyRule', description='The notification rules.'),
        notifyTemplate?: {
          emailContent?: string(name='EmailContent', description='The content of the alert notification sent by email.'),
          emailRecoverContent?: string(name='EmailRecoverContent', description='The content of the alert resolution notification sent by email.'),
          emailRecoverTitle?: string(name='EmailRecoverTitle', description='The title of the alert resolution notification sent by email.', example='{{ .commonLabels.alertname }}'),
          emailTitle?: string(name='EmailTitle', description='The title of the alert notification sent by email.', example='{{ .commonLabels.alertname }}'),
          robotContent?: string(name='RobotContent', description='The content of the alert notification sent by an IM robot.'),
          smsContent?: string(name='SmsContent', description='The content of the alert notification sent by text message.'),
          smsRecoverContent?: string(name='SmsRecoverContent', description='The content of the alert resolution notification sent by text message.'),
          ttsContent?: string(name='TtsContent', description='The content of the alert notification sent by phone.'),
          ttsRecoverContent?: string(name='TtsRecoverContent', description='The content of the alert resolution notification sent by phone.'),
        }(name='NotifyTemplate', description='The notification templates.'),
        repeat?: boolean(name='Repeat', description='Indicates whether the system repeatedly sends notifications for a long-lasting unresolved alert. Default value: true. Valid values:  

- `true`: The system repeatedly sends notifications for a long-lasting unresolved alert at a specified time interval.
- `false`: The system sends a notification for a long-lasting unresolved alert based on an escalation policy.', example='true'),
        repeatInterval?: long(name='RepeatInterval', description='The time interval at which notifications are sent for a long-lasting unresolved alert. Unit: seconds.', example='600'),
        sendRecoverMessage?: boolean(name='SendRecoverMessage', description='Specifies whether the status of an alert automatically changes to Resolved when all events related to the alert change to the Restored state. The system notifies contacts when the alert status changes to Resolved.  

- `true`: The system sends a notification. This is the default value.
- `false`: The system does not send a notification.', example='true'),
      }
    ](name='NotificationPolicies', description='The information about the notification policies.'),
    page?: long(name='Page', description='The number of the page returned.', example='1'),
    size?: long(name='Size', description='The number of entries that are returned on each page.', example='20'),
    total?: long(name='Total', description='The number of notification policies that are returned.', example='24'),
  }(name='PageBean', description='The pages that are returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='78901766-3806-4E96-8E47-CFEF59E4****'),
}

model ListNotificationPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNotificationPoliciesResponseBody(name='body'),
}

async function listNotificationPoliciesWithOptions(request: ListNotificationPoliciesRequest, runtime: Util.RuntimeOptions): ListNotificationPoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.isDetail)) {
    query['IsDetail'] = request.isDetail;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNotificationPolicies',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNotificationPolicies(request: ListNotificationPoliciesRequest): ListNotificationPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNotificationPoliciesWithOptions(request, runtime);
}

model ListOnCallSchedulesRequest {
  name?: string(name='Name', example='OnCallSchedule_test'),
  page?: long(name='Page', example='1'),
  size?: long(name='Size', example='20'),
}

model ListOnCallSchedulesResponseBody = {
  pageBean?: {
    onCallSchedules?: [ 
      {
        description?: string(name='Description'),
        id?: long(name='Id', example='1234'),
        name?: string(name='Name', example='OnCallSchedule_test'),
      }
    ](name='OnCallSchedules'),
    page?: long(name='Page', example='1'),
    size?: long(name='Size', example='20'),
    total?: long(name='Total', example='1'),
  }(name='PageBean'),
  requestId?: string(name='RequestId', example='78901766-3806-4E96-8E47-CFEF59E4****'),
}

model ListOnCallSchedulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOnCallSchedulesResponseBody(name='body'),
}

async function listOnCallSchedulesWithOptions(request: ListOnCallSchedulesRequest, runtime: Util.RuntimeOptions): ListOnCallSchedulesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOnCallSchedules',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOnCallSchedules(request: ListOnCallSchedulesRequest): ListOnCallSchedulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOnCallSchedulesWithOptions(request, runtime);
}

model ListPrometheusAlertRulesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c0bad479465464e1d8c1e641b0afb****'),
  matchExpressions?: string(name='MatchExpressions', description='The tag match conditions that are described in a JSON string. For more information about this parameter, see the **Additional description of the MatchExpressions parameter** section.', example='[{"key":"severity","value":"critical","operator":"re"}]'),
  name?: string(name='Name', description='The name of the alert rule.', example='Prometheus_Alert'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  status?: int32(name='Status', description='Specifies whether the alert rule is enabled. Valid values:

*   `1`: The alert rule is enabled.
*   `0`: The alert rule is disabled.', example='1'),
  type?: string(name='Type', description='The type of the alert rule.'),
}

model ListPrometheusAlertRulesResponseBody = {
  prometheusAlertRules?: [ 
    {
      alertId?: long(name='AlertId', description='The ID of the alert rule.', example='3888704'),
      alertName?: string(name='AlertName', description='The name of the alert rule.', example='Prometheus_Alert'),
      annotations?: [ 
        {
          name?: string(name='Name', description='The name of the annotation.', example='message'),
          value?: string(name='Value', description='The value of the annotation.'),
        }
      ](name='Annotations', description='The annotations of the alert rule.'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c0bad479465464e1d8c1e641b0afb****'),
      dispatchRuleId?: long(name='DispatchRuleId', description='The ID of the notification policy. This parameter is returned if the **NotifyType** parameter is set to `DISPATCH_RULE`.', example='10282'),
      duration?: string(name='Duration', description='The duration of the alert. Valid values: 1 to 1440. Unit: minutes.', example='1m'),
      expression?: string(name='Expression', description='The expression of the alert rule.', example='100 * (sum(rate(container_cpu_usage_seconds_total[1m])) by (pod_name) / sum(label_replace(kube_pod_container_resource_limits_cpu_cores, \\"pod_name\\", \\"$1\\", \\"pod\\", \\"(.*)\\")) by (pod_name))>75'),
      labels?: [ 
        {
          name?: string(name='Name', description='The name of the tag.', example='severity'),
          value?: string(name='Value', description='The value of the tag.', example='critical'),
        }
      ](name='Labels', description='The tags of the alert rule.'),
      message?: string(name='Message', description='The message of the alert notification. Tags can be referenced in the {{$labels.xxx}} format.'),
      notifyType?: string(name='NotifyType', description='The method of that is used to send alert notifications. Valid values:

*   `ALERT_MANAGER`: Alert notifications are sent by Operation Center.
*   `DISPATCH_RULE`: Alert notifications are sent based on the specified notification policy.', example='ALERT_MANAGER'),
      status?: int32(name='Status', description='Indicates whether the alert rule is enabled. Valid values:

*   `1`: The alert rule is enabled.
*   `0`: The alert rule is disabled.', example='1'),
      type?: string(name='Type', description='The type of the alert rule.'),
    }
  ](name='PrometheusAlertRules', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9FEA6D00-317F-45E3-9004-7FB8B0B7****'),
}

model ListPrometheusAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPrometheusAlertRulesResponseBody(name='body'),
}

async function listPrometheusAlertRulesWithOptions(request: ListPrometheusAlertRulesRequest, runtime: Util.RuntimeOptions): ListPrometheusAlertRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.matchExpressions)) {
    query['MatchExpressions'] = request.matchExpressions;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrometheusAlertRules',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPrometheusAlertRules(request: ListPrometheusAlertRulesRequest): ListPrometheusAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPrometheusAlertRulesWithOptions(request, runtime);
}

model ListPrometheusAlertTemplatesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c0bad479465464e1d8c1e641b0afb****'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model ListPrometheusAlertTemplatesResponseBody = {
  prometheusAlertTemplates?: [ 
    {
      alertName?: string(name='AlertName', description='The name of the alert rule.'),
      annotations?: [ 
        {
          name?: string(name='Name', description='The name of the annotation.', example='message'),
          value?: string(name='Value', description='The value of the annotation.'),
        }
      ](name='Annotations', description='The annotations of the alert rule.'),
      description?: string(name='Description', description='The message of the alert notification. Tags can be referenced in the {{$labels.xxx}} format.'),
      duration?: string(name='Duration', description='The duration of the alert. Valid values: 1 to 1440. Unit: minutes.', example='1m'),
      expression?: string(name='Expression', description='The expression of the alert rule.', example='node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes * 100 < 10'),
      labels?: [ 
        {
          name?: string(name='Name', description='The name of the tag.', example='severity'),
          value?: string(name='Value', description='The value of the tag.', example='warning'),
        }
      ](name='Labels', description='The tags of the alert rule.'),
      type?: string(name='Type', description='The type of the alert rule.'),
      version?: string(name='Version', description='The version of the alert rule.', example='1.0'),
    }
  ](name='PrometheusAlertTemplates', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9FEA6D00-317F-45E3-9004-7FB8B0B7****'),
}

model ListPrometheusAlertTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPrometheusAlertTemplatesResponseBody(name='body'),
}

async function listPrometheusAlertTemplatesWithOptions(request: ListPrometheusAlertTemplatesRequest, runtime: Util.RuntimeOptions): ListPrometheusAlertTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrometheusAlertTemplates',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPrometheusAlertTemplates(request: ListPrometheusAlertTemplatesRequest): ListPrometheusAlertTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPrometheusAlertTemplatesWithOptions(request, runtime);
}

model ListPrometheusGlobalViewRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model ListPrometheusGlobalViewResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId', example='DBDCE95A-A0DD-5FC5-97CC-EEFC3D814385'),
}

model ListPrometheusGlobalViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPrometheusGlobalViewResponseBody(name='body'),
}

async function listPrometheusGlobalViewWithOptions(request: ListPrometheusGlobalViewRequest, runtime: Util.RuntimeOptions): ListPrometheusGlobalViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrometheusGlobalView',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPrometheusGlobalView(request: ListPrometheusGlobalViewRequest): ListPrometheusGlobalViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPrometheusGlobalViewWithOptions(request, runtime);
}

model ListPrometheusInstancesRequest {
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  showGlobalView?: boolean(name='ShowGlobalView', description='Specifies whether to obtain global aggregation instances. Valid values:

*   true
*   false', example='true'),
}

model ListPrometheusInstancesResponseBody = {
  data?: string(name='Data', description='The Prometheus instances in the region in the JSON format.', example='[{"agentStatus":"0","clusterId":"global-v2-cn-1672753017899-dmjnwtzz","clusterName":"test-GlobalView","clusterType":"GlobalViewV2","commercialConfig":{},"createTime":1656579981000,"id":13785300,"isAdvancedClusterInstalled":false,"isClusterRunning":true,"isControllerInstalled":true,"isIntegrationCenter":false,"regionId":"cn-hongkong","updateTime":1657616273000,"userId":"1672753017899"},{"agentStatus":"0","clusterId":"51a123a61a8f31f0","clusterName":"cloud-product-prometheus_cn-qingdao","clusterType":"cloud-product-prometheus","commercialConfig":{},"controllerId":"51a123a61a8f31f0","createTime":1653532488000,"id":13746658,"isAdvancedClusterInstalled":false,"isClusterRunning":true,"isControllerInstalled":true,"isIntegrationCenter":false,"regionId":"cn-qingdao","updateTime":1653532518000,"userId":"1672753017899"}]'),
  requestId?: string(name='RequestId', description='The ID of the request. You can use the ID to query logs and troubleshoot issues.', example='E9C9DA3D-10FE-472E-9EEF-2D0A3E41****'),
}

model ListPrometheusInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPrometheusInstancesResponseBody(name='body'),
}

async function listPrometheusInstancesWithOptions(request: ListPrometheusInstancesRequest, runtime: Util.RuntimeOptions): ListPrometheusInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.showGlobalView)) {
    query['ShowGlobalView'] = request.showGlobalView;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrometheusInstances',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPrometheusInstances(request: ListPrometheusInstancesRequest): ListPrometheusInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPrometheusInstancesWithOptions(request, runtime);
}

model ListPrometheusRemoteWritesRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model ListPrometheusRemoteWritesResponseBody = {
  code?: int32(name='Code', example='200'),
  data?: string(name='Data', example='remote_write:
  - name: rw1
    url: "http://cn-hangzhou-intranet.arms.aliyuncs.com/prometheus/uid/xx/cn-hangzhou/api/v3/write"
    basic_auth:
      username: xxx
      password: xxx
    write_relabel_configs:
      - source_labels: [ instance_id ]
        separator: ;
        regex: si
        replacement: $1
        action: keep
  - name: rw2
    url: "http://cn-hangzhou-intranet.arms.aliyuncs.com/prometheus/uid/xx/cn-hangzhou/api/v3/write"
    basic_auth:
      username: xxx
      password: xxx
    write_relabel_configs:
      - source_labels: [ xx ]
        separator: ;
        regex: yyy
        replacement: $1
        action: keep'),
  message?: string(name='Message', example='message'),
  requestId?: string(name='RequestId', example='9319A57D-2D9E-472A-B69B-CF3CD16D****'),
  success?: boolean(name='Success', example='true'),
}

model ListPrometheusRemoteWritesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPrometheusRemoteWritesResponseBody(name='body'),
}

async function listPrometheusRemoteWritesWithOptions(request: ListPrometheusRemoteWritesRequest, runtime: Util.RuntimeOptions): ListPrometheusRemoteWritesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrometheusRemoteWrites',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPrometheusRemoteWrites(request: ListPrometheusRemoteWritesRequest): ListPrometheusRemoteWritesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPrometheusRemoteWritesWithOptions(request, runtime);
}

model ListRetcodeAppsRequest {
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
}

model ListRetcodeAppsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='99A663CB-8D7B-4B0D-A006-03C8EE38E7BB'),
  retcodeApps?: [ 
    {
      appId?: long(name='AppId', description='The ID of the application. The parameter is an auto-increment parameter.', example='16064'),
      appName?: string(name='AppName', description='The name of the application.', example='A1'),
      nickName?: string(name='NickName', description='The name of the application that is monitored by Browser Monitoring.', example='B1'),
      pid?: string(name='Pid', description='The PID of the application.', example='atc889zkcf@d8deedfa9bf****'),
      resourceGroupId?: string(name='ResourceGroupId'),
      retcodeAppType?: string(name='RetcodeAppType', description='The type of the application. Valid values:

*   `web`: web application
*   `weex`: Weex mobile app
*   `mini_dd`: DingTalk mini program
*   `mini_alipay`: Alipay mini program
*   `mini_wx`: WeChat mini program
*   `mini_common`: mini program on other platforms', example='web'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
    }
  ](name='RetcodeApps', description='The information about monitored applications.'),
}

model ListRetcodeAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRetcodeAppsResponseBody(name='body'),
}

/**
  * ****
  *
  * @param request ListRetcodeAppsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListRetcodeAppsResponse
 */
async function listRetcodeAppsWithOptions(request: ListRetcodeAppsRequest, runtime: Util.RuntimeOptions): ListRetcodeAppsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRetcodeApps',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ****
  *
  * @param request ListRetcodeAppsRequest
  * @return ListRetcodeAppsResponse
 */
async function listRetcodeApps(request: ListRetcodeAppsRequest): ListRetcodeAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRetcodeAppsWithOptions(request, runtime);
}

model ListScenarioRequest {
  appId?: string(name='AppId', description='The ID of the application.', example='b590lhguqs@28f515462******'),
  name?: string(name='Name', description='The name of the business monitoring job.'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-zhangjaikou'),
  scenario?: string(name='Scenario', description='The scenario where the business monitoring job is used. Valid values:

*   `USER-DEFINED`: user-defined. This is the default value.
*   `EDAS-ROLLOUT`: application release in Enterprise Distributed Application Service (EDAS)
*   `OAM-ROLLOUT`: application release based on Open Application Model (OAM)
*   `MSC-CANARY`: canary release based on Microservice Engine (MSE)', example='USER-DEFINED'),
  sign?: string(name='Sign', description='The code of the business monitoring job. Set this parameter when you know the code of the business monitoring job you want to query.', example='a9f8****'),
}

model ListScenarioResponseBody = {
  armsScenarios?: [ 
    {
      appId?: string(name='AppId', description='The ID of the application.', example='b590lhguqs@28f515462******'),
      createTime?: string(name='CreateTime', description='The time when the business monitoring job was created.', example='1585214916000'),
      extensions?: string(name='Extensions', description='The extended information. The value is a JSON string.', example='{"_MODE": "CUSTOM-TRANSACTION","_SCENARIO": "USER-DEFINED"}'),
      id?: long(name='Id', description='The ID of the business monitoring job.', example='132'),
      name?: string(name='Name', description='The name of the business monitoring job.'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-zhangjiakou'),
      sign?: string(name='Sign', description='The code of the business monitoring job.', example='a9f8****'),
      updateTime?: string(name='UpdateTime', description='The time when the business monitoring job was updated.', example='1585214916000'),
      userId?: string(name='UserId', description='The ID of the user.', example='113197164949****'),
    }
  ](name='ArmsScenarios', description='The detailed information of the business monitoring job.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='98027D1F-3AEB-492C-A4AA-E9217992****'),
}

model ListScenarioResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListScenarioResponseBody(name='body'),
}

async function listScenarioWithOptions(request: ListScenarioRequest, runtime: Util.RuntimeOptions): ListScenarioResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.scenario)) {
    query['Scenario'] = request.scenario;
  }
  if (!Util.isUnset(request.sign)) {
    query['Sign'] = request.sign;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListScenario',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listScenario(request: ListScenarioRequest): ListScenarioResponse {
  var runtime = new Util.RuntimeOptions{};
  return listScenarioWithOptions(request, runtime);
}

model ListSilencePoliciesRequest {
  isDetail?: boolean(name='IsDetail', description='Specifies whether to query the details of a silence policy. Valid values:

*   `true`: Details of the silence policy are queried.
*   `false`: Details of the silence policy are not queried.', example='true'),
  name?: string(name='Name', description='The name of the silence policy.', example='silencepolicy_test'),
  page?: long(name='Page', description='The number of pages to return.', example='1'),
  regionId?: string(name='RegionId'),
  size?: long(name='Size', description='The number of entries to return on each page.', example='20'),
}

model ListSilencePoliciesResponseBody = {
  pageBean?: {
    page?: long(name='Page', description='The number of pages that were returned.', example='1'),
    silencePolicies?: [ 
      {
        id?: long(name='Id', description='The ID of the silence policy.', example='123'),
        matchingRules?: [ 
          {
            matchingConditions?: [ 
              {
                key?: string(name='Key', description='The key of the matching condition.', example='altertname'),
                operator?: string(name='Operator', description='The logical operator of the matching condition. Valid values:

*   `eq`: equal to.
*   `neq`: not equal to.
*   `in`: contains.
*   `nin`: does not contain.
*   `re`: regular expression match.
*   `nre`: regular expression mismatch.', example='eq'),
                value?: string(name='Value', description='The value of the matching condition.', example='test'),
              }
            ](name='MatchingConditions', description='An array of matching condition objects.'),
          }
        ](name='MatchingRules', description='An array of matching rule objects.'),
        name?: string(name='Name', description='The name of the silence policy.', example='silencepolicy_test'),
      }
    ](name='SilencePolicies', description='An array of silence policy objects.'),
    size?: long(name='Size', description='The number of entries that were returned on each page.', example='20'),
    total?: long(name='Total', description='The number of silence policies that were returned.', example='1'),
  }(name='PageBean', description='An array of returned objects.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='78901766-3806-4E96-8E47-CFEF59E4****'),
}

model ListSilencePoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSilencePoliciesResponseBody(name='body'),
}

async function listSilencePoliciesWithOptions(request: ListSilencePoliciesRequest, runtime: Util.RuntimeOptions): ListSilencePoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.isDetail)) {
    query['IsDetail'] = request.isDetail;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSilencePolicies',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSilencePolicies(request: ListSilencePoliciesRequest): ListSilencePoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSilencePoliciesWithOptions(request, runtime);
}

model ListTraceAppsRequest {
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
}

model ListTraceAppsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code returned for the request. Valid values:

*   `2XX`: The request is successful.
*   `3XX`: A redirection message is returned.
*   `4XX`: The request is invalid.
*   `5XX`: A server error occurs.', example='200'),
  message?: string(name='Message', description='The error message returned when the request parameters are invalid.', example='Internal error. Please try again. Contact the DingTalk service account if the issue persists after multiple retries.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='40B10E04-81E8-4643-970D-F1B38F2E****'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   `true`: The call is successful.
*   `false`: The call fails.', example='true'),
  traceApps?: [ 
    {
      appId?: long(name='AppId', description='The ID of the application.', example='123'),
      appName?: string(name='AppName', description='The name of the application.', example='test-app'),
      createTime?: long(name='CreateTime', description='The timestamp when the application was created. Unit: milliseconds.', example='1529667762000'),
      labels?: [ string ](name='Labels', description='The tag of the application.'),
      pid?: string(name='Pid', description='The process identifier (PID) of the application.', example='a5f9bdeb-2627-4dbe-9247-****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      resourceGroupId?: string(name='ResourceGroupId'),
      show?: boolean(name='Show', description='Indicates whether the application is displayed in the Application Real-Time Monitoring Service (ARMS) console. Valid values:

*   `true`: The application is displayed in the ARMS console.
*   `false`: The application is not displayed in the ARMS console.', example='true'),
      source?: string(name='Source'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      type?: string(name='Type', description='The type of the monitoring task. Valid values:

*   `TRACE`: application monitoring
*   `RETCODE`: frontend monitoring', example='TRACE'),
      updateTime?: long(name='UpdateTime', description='The timestamp when the task was updated. Unit: milliseconds.', example='1529667762000'),
      userId?: string(name='UserId', description='The ID of the user.', example='113197164949****'),
    }
  ](name='TraceApps', description='The list of application monitoring tasks.'),
}

model ListTraceAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTraceAppsResponseBody(name='body'),
}

async function listTraceAppsWithOptions(request: ListTraceAppsRequest, runtime: Util.RuntimeOptions): ListTraceAppsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTraceApps',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTraceApps(request: ListTraceAppsRequest): ListTraceAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTraceAppsWithOptions(request, runtime);
}

model ManageGetRecordingRuleRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  queryUserId?: string(name='QueryUserId', description='The ID of the user.', example='876345234'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model ManageGetRecordingRuleResponseBody = {
  data?: string(name='Data', description='The returned message.', example='--- groups: - name: "recording_demo"   rules:   - expr: "sum(jvm_memory_max_bytes)"     record: "rate_coredns_demo"'),
  requestId?: string(name='RequestId', description='The ID of the request. You can use the ID to query logs and troubleshoot issues.', example='34ED024E-9E31-434A-9E4E-D9D15C3****'),
}

model ManageGetRecordingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ManageGetRecordingRuleResponseBody(name='body'),
}

async function manageGetRecordingRuleWithOptions(request: ManageGetRecordingRuleRequest, runtime: Util.RuntimeOptions): ManageGetRecordingRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.queryUserId)) {
    query['QueryUserId'] = request.queryUserId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ManageGetRecordingRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function manageGetRecordingRule(request: ManageGetRecordingRuleRequest): ManageGetRecordingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return manageGetRecordingRuleWithOptions(request, runtime);
}

model ManageRecordingRuleRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='cf09705f5a82f454db0d50420b6b4e904'),
  queryUserId?: string(name='QueryUserId', description='The ID of the user.', example='87348589207'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  ruleYaml?: string(name='RuleYaml', description='The recording rule.', example='groups:\\n- interval: 60s\\n  name: auto_analyzer_recording_rule_60s\\n  rules:\\n  - expr: sum(node_cpu_seconds_total)\\n    record: sum:node_cpu_seconds_total:recording_rule_hash_f341458c0f7d\\n'),
}

model ManageRecordingRuleResponseBody = {
  data?: string(name='Data', description='The result of the operation.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request. You can use the ID to troubleshoot issues.', example='CD782AEC-A676-529F-8F26-0ED0FF0EF1EA'),
}

model ManageRecordingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ManageRecordingRuleResponseBody(name='body'),
}

async function manageRecordingRuleWithOptions(request: ManageRecordingRuleRequest, runtime: Util.RuntimeOptions): ManageRecordingRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.queryUserId)) {
    query['QueryUserId'] = request.queryUserId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.ruleYaml)) {
    query['RuleYaml'] = request.ruleYaml;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ManageRecordingRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function manageRecordingRule(request: ManageRecordingRuleRequest): ManageRecordingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return manageRecordingRuleWithOptions(request, runtime);
}

model OpenArmsDefaultSLRRequest {
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model OpenArmsDefaultSLRResponseBody = {
  data?: string(name='Data', description='Indicates whether the request was successful. Valid values:

*   `true`: The request was successful.
*   `false`: The request failed.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='53CACA70-2CF7-490C-BD06-1A2AE4EB****'),
}

model OpenArmsDefaultSLRResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenArmsDefaultSLRResponseBody(name='body'),
}

async function openArmsDefaultSLRWithOptions(request: OpenArmsDefaultSLRRequest, runtime: Util.RuntimeOptions): OpenArmsDefaultSLRResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenArmsDefaultSLR',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openArmsDefaultSLR(request: OpenArmsDefaultSLRRequest): OpenArmsDefaultSLRResponse {
  var runtime = new Util.RuntimeOptions{};
  return openArmsDefaultSLRWithOptions(request, runtime);
}

model OpenArmsServiceSecondVersionRequest {
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  type?: string(name='Type', description='The type of the service. Valid values:

*   `arms`: ARMS
*   `arms_app`: Application Monitoring
*   `arms_web`: Browser Monitoring
*   `prometheus_monitor`: Prometheus Service
*   `synthetic_post`: Synthetic Monitoring', example='arms'),
}

model OpenArmsServiceSecondVersionResponseBody = {
  orderId?: string(name='OrderId', description='The service ID returned if the service is activated.', example='20896874992****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9ED50893-F3C4-42DF-ABB2-C200BE******'),
}

model OpenArmsServiceSecondVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenArmsServiceSecondVersionResponseBody(name='body'),
}

/**
  * The **OpenArmsServiceSecondVersion** operation supports the following sub-service editions:
  * *   Application Monitoring: Basic Edition
  * *   Browser Monitoring: Basic Edition
  * *   Synthetic Monitoring: Pro Edition (pay-as-you-go)
  * *   Prometheus Service: Pro Edition
  *
  * @param request OpenArmsServiceSecondVersionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return OpenArmsServiceSecondVersionResponse
 */
async function openArmsServiceSecondVersionWithOptions(request: OpenArmsServiceSecondVersionRequest, runtime: Util.RuntimeOptions): OpenArmsServiceSecondVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenArmsServiceSecondVersion',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The **OpenArmsServiceSecondVersion** operation supports the following sub-service editions:
  * *   Application Monitoring: Basic Edition
  * *   Browser Monitoring: Basic Edition
  * *   Synthetic Monitoring: Pro Edition (pay-as-you-go)
  * *   Prometheus Service: Pro Edition
  *
  * @param request OpenArmsServiceSecondVersionRequest
  * @return OpenArmsServiceSecondVersionResponse
 */
async function openArmsServiceSecondVersion(request: OpenArmsServiceSecondVersionRequest): OpenArmsServiceSecondVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return openArmsServiceSecondVersionWithOptions(request, runtime);
}

model OpenVClusterRequest {
  clusterType?: string(name='ClusterType', description='The type of the cluster. For cloud services, set this parameter to `cloud-product-prometheus`.', example='cloud-product-prometheus'),
  length?: int32(name='Length', description='The length of the cluster ID. Default value: 10.', example='10'),
  product?: string(name='Product', description='The name of the cloud service. This parameter is required if you set the ClusterType parameter to `cloud-product-prometheus`. Valid values: influxdb, mongodb, and DLA.', example='influxdb'),
  recreateSwitch?: boolean(name='RecreateSwitch', description='Specifies whether to create or query a virtual cluster. This parameter provides backward compatibility.', example='false'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model OpenVClusterResponseBody = {
  data?: string(name='Data', description='The response parameters in the JSON format.', example='rre59xelcx'),
  requestId?: string(name='RequestId', description='The ID of the request. You can query logs and troubleshoot issues based on the ID.', example='42E58E4D-ACAD-4400-8FAF-F762340AE5B3'),
}

model OpenVClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenVClusterResponseBody(name='body'),
}

async function openVClusterWithOptions(request: OpenVClusterRequest, runtime: Util.RuntimeOptions): OpenVClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.length)) {
    query['Length'] = request.length;
  }
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  if (!Util.isUnset(request.recreateSwitch)) {
    query['RecreateSwitch'] = request.recreateSwitch;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenVCluster',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openVCluster(request: OpenVClusterRequest): OpenVClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return openVClusterWithOptions(request, runtime);
}

model OpenXtraceDefaultSLRRequest {
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model OpenXtraceDefaultSLRResponseBody = {
  data?: string(name='Data', description='Indicates whether the request was successful. Valid values:

*   `true`: The request was successful.
*   `false`: The request failed.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='53CACA70-2CF7-490C-BD06-1A2AE4EB****'),
}

model OpenXtraceDefaultSLRResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenXtraceDefaultSLRResponseBody(name='body'),
}

async function openXtraceDefaultSLRWithOptions(request: OpenXtraceDefaultSLRRequest, runtime: Util.RuntimeOptions): OpenXtraceDefaultSLRResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenXtraceDefaultSLR',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openXtraceDefaultSLR(request: OpenXtraceDefaultSLRRequest): OpenXtraceDefaultSLRResponse {
  var runtime = new Util.RuntimeOptions{};
  return openXtraceDefaultSLRWithOptions(request, runtime);
}

model QueryMetricByPageRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: `1`.', example='1'),
  customFilters?: [ string ](name='CustomFilters', description='Custom filter conditions.'),
  dimensions?: [ string ](name='Dimensions', description='The dimensions of the metric that you want to query.', example='["detector_browser","detector_device"]'),
  endTime?: long(name='EndTime', description='The end of the time range to query. Unit: milliseconds.', example='1667546895000'),
  filters?: [ 
    {
      key?: string(name='Key', description='The key of the filter condition. You must set the key to `pid` or `regionId`.', example='pid'),
      value?: string(name='Value', description='The value of the filter condition. You must set the value of the `pid` or `regionId` condition. For information about how to obtain the `pid`, see the "Obtain the PID of an application" section.', example='xxx@74xxx'),
    }
  ](name='Filters', description='The filter conditions.'),
  intervalInSec?: int32(name='IntervalInSec', description='The time interval at which data entries are aggregated. Unit: milliseconds. Minimum value: 60000.', example='100000'),
  measures?: [ string ](name='Measures', description='The measures of the metric that you want to query.', example='pv'),
  metric?: string(name='Metric', description='The metric that you want to query. You cannot specify a custom metric. For more information, see the "Application monitoring metrics that can be queried" section.', example='appstat.host'),
  order?: string(name='Order', description='The order in which measures are sorted. Valid values:

*   `ASC`: ascending order
*   `DESC`: descending order

> If you do not specify the parameter, data is not sorted.', example='ASC'),
  orderBy?: string(name='OrderBy', description='The dimension from which metrics are sorted. You can set this parameter to a supported dimension.', example='pid'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. This parameter is no longer supported. The number of entries to return on each page.', example='10'),
  startTime?: long(name='StartTime', description='The start of the time range to query. Unit: milliseconds.', example='1667287695000'),
}

model QueryMetricByPageResponseBody = {
  code?: string(name='Code', description='The HTTP status code returned for the request. Valid values:

*   2XX: The request was successful.
*   3XX: A redirection message was returned.
*   4XX: The request was invalid.
*   5XX: A server error occurred.', example='200'),
  data?: {
    items?: [  map[string]any ](name='Items', description='The data entries returned.'),
    page?: int32(name='Page', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
    total?: int32(name='Total', description='The total number of entries returned.', example='2'),
  }(name='Data', description='The struct returned.'),
  message?: string(name='Message', description='The error message returned if the call fails.', example='StartTime is mandatory for this action.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='687F9CB7-4798-57BF-A6EE-E6CC76******'),
  success?: boolean(name='Success', description='Indicates whether the call was successful. Valid values:

*   `true`: The call was successful.
*   `false`: The call failed.', example='true'),
}

model QueryMetricByPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMetricByPageResponseBody(name='body'),
}

async function queryMetricByPageWithOptions(request: QueryMetricByPageRequest, runtime: Util.RuntimeOptions): QueryMetricByPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.customFilters)) {
    query['CustomFilters'] = request.customFilters;
  }
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!Util.isUnset(request.intervalInSec)) {
    query['IntervalInSec'] = request.intervalInSec;
  }
  if (!Util.isUnset(request.measures)) {
    query['Measures'] = request.measures;
  }
  if (!Util.isUnset(request.metric)) {
    query['Metric'] = request.metric;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMetricByPage',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMetricByPage(request: QueryMetricByPageRequest): QueryMetricByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMetricByPageWithOptions(request, runtime);
}

model QueryPromInstallStatusRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model QueryPromInstallStatusResponseBody = {
  data?: {
    isControllerInstalled?: boolean(name='isControllerInstalled', description='Indicates whether the call was successful. Valid values:

true: The call was successful. false: The call failed.', example='true'),
  }(name='Data', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='27E653FA-5958-45BE-8AA9-14D884DC****'),
}

model QueryPromInstallStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryPromInstallStatusResponseBody(name='body'),
}

async function queryPromInstallStatusWithOptions(request: QueryPromInstallStatusRequest, runtime: Util.RuntimeOptions): QueryPromInstallStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryPromInstallStatus',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryPromInstallStatus(request: QueryPromInstallStatusRequest): QueryPromInstallStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPromInstallStatusWithOptions(request, runtime);
}

model QueryReleaseMetricRequest {
  changeOrderId?: string(name='ChangeOrderId', description='The ID of the change order.', example='a341a2f2-ed07-4257-aae9-dfb1be******'),
  createTime?: long(name='CreateTime', description='The time when the change order was created.', example='1634005438000'),
  metricType?: string(name='MetricType', description='The type of the metric that you want to query.', example='SystemContrast'),
  pid?: string(name='Pid', description='The ID of the Enterprise Distributed Application Service (EDAS) or Kubernetes application.', example='8b46d03f-5947-449d-90fd-3a96c2******'),
  proxyUserId?: string(name='ProxyUserId', description='This parameter is not in use.', example='null'),
  releaseEndTime?: long(name='ReleaseEndTime', description='The end time of the version release.', example='1632798718632'),
  releaseStartTime?: long(name='ReleaseStartTime', description='The start time of the version release.', example='1632798686692'),
  service?: string(name='Service', description='The service that you want to query.', example='clothservice'),
}

model QueryReleaseMetricResponseBody = {
  data?: string(name='Data', description='The returned metric data.', example='{"data":{"SystemCpuUser":{"all":[{"date":1632798718000,"val":4.3277,"dim":"SystemCpuUser"},{"date":1632798733000,"val":8.1091,"dim":"SystemCpuUser"}]},"SystemMemUtil":{"all":[{"date":1632798718000,"val":73.4227,"dim":"SystemMemUtil"},{"date":1632798733000,"val":93.0977,"dim":"SystemMemUtil"}]}},"success":true}'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='46355DD8-FC56-40C5-BFC6-269DE4F9****'),
}

model QueryReleaseMetricResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryReleaseMetricResponseBody(name='body'),
}

async function queryReleaseMetricWithOptions(request: QueryReleaseMetricRequest, runtime: Util.RuntimeOptions): QueryReleaseMetricResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.changeOrderId)) {
    query['ChangeOrderId'] = request.changeOrderId;
  }
  if (!Util.isUnset(request.createTime)) {
    query['CreateTime'] = request.createTime;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.proxyUserId)) {
    query['ProxyUserId'] = request.proxyUserId;
  }
  if (!Util.isUnset(request.releaseEndTime)) {
    query['ReleaseEndTime'] = request.releaseEndTime;
  }
  if (!Util.isUnset(request.releaseStartTime)) {
    query['ReleaseStartTime'] = request.releaseStartTime;
  }
  if (!Util.isUnset(request.service)) {
    query['Service'] = request.service;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryReleaseMetric',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryReleaseMetric(request: QueryReleaseMetricRequest): QueryReleaseMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryReleaseMetricWithOptions(request, runtime);
}

model RemoveAliClusterIdsFromPrometheusGlobalViewRequest {
  clusterIds?: string(name='ClusterIds', description='The list of cluster IDs. You can specify multiple cluster IDs and separate them with commas (,).', example='cd1d55bef19904324a20ed0ebb86caa5c,c5b48729918ab4745a24482ac29d0973a, c00a94896641449098bf24931e4166003, cd174485c09384060ba542bc1be1185a4'),
  globalViewClusterId?: string(name='GlobalViewClusterId', description='The ID of the aggregation instance.', example='global-v2-cn-1670100631025794-amaykca4'),
  groupName?: string(name='GroupName', description='The name of the aggregation instance.', example='zyGlobalView'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody = {
  data?: {
    info?: string(name='Info', description='The Info-level information.', example='{regionId: the region where the aggregation instance resides. globalViewClusterId: the ID of the aggregation instance. failedClusterIds: the ID of the cluster that failed to be added. A cluster may fail to be added if the specified cluster ID is invalid.}'),
    msg?: string(name='Msg', description='The additional information.', example='OK'),
    success?: boolean(name='Success', description='Indicates whether the call was successful. Valid values:

*   `true`: The call was successful.
*   `false`: The call failed.', example='true'),
  }(name='Data', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request. You can use the ID to query logs and troubleshoot issues.', example='F7781D4A-2818-41E7-B7BB-79D809E9****'),
}

model RemoveAliClusterIdsFromPrometheusGlobalViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody(name='body'),
}

async function removeAliClusterIdsFromPrometheusGlobalViewWithOptions(request: RemoveAliClusterIdsFromPrometheusGlobalViewRequest, runtime: Util.RuntimeOptions): RemoveAliClusterIdsFromPrometheusGlobalViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterIds)) {
    query['ClusterIds'] = request.clusterIds;
  }
  if (!Util.isUnset(request.globalViewClusterId)) {
    query['GlobalViewClusterId'] = request.globalViewClusterId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveAliClusterIdsFromPrometheusGlobalView',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeAliClusterIdsFromPrometheusGlobalView(request: RemoveAliClusterIdsFromPrometheusGlobalViewRequest): RemoveAliClusterIdsFromPrometheusGlobalViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeAliClusterIdsFromPrometheusGlobalViewWithOptions(request, runtime);
}

model RemoveSourcesFromPrometheusGlobalViewRequest {
  globalViewClusterId?: string(name='GlobalViewClusterId', description='The ID of the aggregation instance.', example='global-v2-cn-1478326682034601-vss8pd0i'),
  groupName?: string(name='GroupName', description='The name of the aggregation instance.', example='zyGlobalView'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  sourceNames?: string(name='SourceNames', description='The list of custom data sources. You can specify multiple data sources and separate them with commas (,).', example='localPrometheusClusterName,testCumterPrometheusName'),
}

model RemoveSourcesFromPrometheusGlobalViewResponseBody = {
  data?: {
    info?: string(name='Info', description='The Info-level information.', example='{regionId: the region where the aggregation instance resides. globalViewClusterId: the ID of the aggregation instance.'),
    msg?: string(name='Msg', description='The additional information.', example='OK'),
    success?: boolean(name='Success', description='Indicates whether the call was successful. Valid values:

*   `true`: The call was successful.
*   `false`: The call failed.', example='True'),
  }(name='Data', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request. You can use the ID to query logs and troubleshoot issues.', example='9319A57D-2D9E-472A-B69B-CF3CD16D****'),
}

model RemoveSourcesFromPrometheusGlobalViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveSourcesFromPrometheusGlobalViewResponseBody(name='body'),
}

async function removeSourcesFromPrometheusGlobalViewWithOptions(request: RemoveSourcesFromPrometheusGlobalViewRequest, runtime: Util.RuntimeOptions): RemoveSourcesFromPrometheusGlobalViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalViewClusterId)) {
    query['GlobalViewClusterId'] = request.globalViewClusterId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sourceNames)) {
    query['SourceNames'] = request.sourceNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveSourcesFromPrometheusGlobalView',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeSourcesFromPrometheusGlobalView(request: RemoveSourcesFromPrometheusGlobalViewRequest): RemoveSourcesFromPrometheusGlobalViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeSourcesFromPrometheusGlobalViewWithOptions(request, runtime);
}

model SaveTraceAppConfigRequest {
  pid?: string(name='Pid', description='The process identifier (PID) of the application. For more information about how to obtain the PID, see [Obtain the PID of an application](~~186100~~#title-imy-7gj-qhr).', example='a2n80plglh@745eddxxx'),
  settings?: [ 
    {
      key?: string(name='Key', description='The value of the settings that you want to modify. For more information about the supported settings, see the following sections.

*   Trace sampling settings
*   Main switch settings
*   Threshold settings
*   Advanced setting
*   Thread settings
*   Memory snapshot settings
*   URL convergence settings
*   Business log association settings
*   Business monitoring settings', example='sampling.enable'),
      value?: string(name='Value', description='The value of the settings that you want to modify. For more information about the supported settings, see the following sections.

*   Trace sampling settings
*   Main switch settings
*   Threshold settings
*   Advanced setting
*   Thread settings
*   Memory snapshot settings
*   URL convergence settings
*   Business log association settings
*   Business monitoring settings', example='true'),
    }
  ](name='Settings', description='The settings of Application Monitoring.'),
}

model SaveTraceAppConfigResponseBody = {
  data?: string(name='Data', description='Indicates whether the call was successful.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='78901766-3806-4E96-8E47-CFEF59E4****'),
}

model SaveTraceAppConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTraceAppConfigResponseBody(name='body'),
}

async function saveTraceAppConfigWithOptions(request: SaveTraceAppConfigRequest, runtime: Util.RuntimeOptions): SaveTraceAppConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.settings)) {
    query['Settings'] = request.settings;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveTraceAppConfig',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveTraceAppConfig(request: SaveTraceAppConfigRequest): SaveTraceAppConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTraceAppConfigWithOptions(request, runtime);
}

model SearchAlertContactRequest {
  contactIds?: string(name='ContactIds', description='The ID of the alert contact.', example='[12345]'),
  contactName?: string(name='ContactName', description='The name of the alert contact.', example='John Doe'),
  currentPage?: string(name='CurrentPage', description='The number of the page to return.', example='1'),
  email?: string(name='Email', description='The email address of the alert contact.', example='someone@example.com'),
  pageSize?: string(name='PageSize', description='The number of entries to return on each page.', example='20'),
  phone?: string(name='Phone', description='The mobile number of the alert contact.', example='1381111*****'),
  regionId?: string(name='RegionId', description='The ID of the region. Set the value to `cn-hangzhou`.', example='cn-hangzhou'),
}

model SearchAlertContactResponseBody = {
  pageBean?: {
    contacts?: [ 
      {
        contactId?: long(name='ContactId', description='The ID of the alert contact.', example='123'),
        contactName?: string(name='ContactName', description='The name of the alert contact.', example='John Doe'),
        content?: string(name='Content', description='The contact group to which the contact belongs. If your contacts are added to multiple contact groups, the contact groups are separated by vertical bars (|).'),
        createTime?: long(name='CreateTime', description='The timestamp when the alert contact was created.', example='1572349025000'),
        dingRobot?: string(name='DingRobot', description='The webhook URL of the DingTalk chatbot.', example='https://oapi.dingtalk.com/robot/send?access_token=91f2f6****'),
        email?: string(name='Email', description='The email address of the alert contact.', example='someone@example.com'),
        phone?: string(name='Phone', description='The mobile number of the alert contact.', example='1381111*****'),
        resourceGroupId?: string(name='ResourceGroupId'),
        systemNoc?: boolean(name='SystemNoc', description='Indicates whether the alert contact receives system notifications. Valid values:

*   `true`: The alert contact receives system notifications.
*   `false`: The alert contact does not receive system notifications.', example='false'),
        updateTime?: long(name='UpdateTime', description='The timestamp when the alert contact was updated.', example='1580258717000'),
        userId?: string(name='UserId', description='The ID of the user.', example='113197164949****'),
        webhook?: string(name='Webhook', description='The information about the webhook.', example='{\\"body\\":\\"{   \\\\\\"msg_type\\\\\\": \\\\\\"text\\\\\\",   \\\\\\"content\\\\\\": {     \\\\\\"text\\\\\\": \\\\\\"$content\\\\\\"   } }\\",\\"header\\":{\\"Arms-Content-Type\\":\\"json\\"},\\"method\\":\\"post\\",\\"params\\":{},\\"url\\":\\"https://***",\\"userId\\":\\"1131971649***\\"}",'),
      }
    ](name='Contacts', description='The information about the alert contacts.'),
    pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='23'),
  }(name='PageBean', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='21E85B16-75A6-429A-9F65-8AAC9A54****'),
}

model SearchAlertContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchAlertContactResponseBody(name='body'),
}

/**
  * ************
  *
  * @param request SearchAlertContactRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SearchAlertContactResponse
 */
async function searchAlertContactWithOptions(request: SearchAlertContactRequest, runtime: Util.RuntimeOptions): SearchAlertContactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactIds)) {
    query['ContactIds'] = request.contactIds;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.phone)) {
    query['Phone'] = request.phone;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchAlertContact',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ************
  *
  * @param request SearchAlertContactRequest
  * @return SearchAlertContactResponse
 */
async function searchAlertContact(request: SearchAlertContactRequest): SearchAlertContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAlertContactWithOptions(request, runtime);
}

model SearchAlertContactGroupRequest {
  contactGroupIds?: string(name='ContactGroupIds', description='The ID of the alert contact group. You can query multiple alert contact groups at a time. Separate multiple group IDs with commas (,).', example='746'),
  contactGroupName?: string(name='ContactGroupName', description='The name of the alert contact group.', example='TestGroup'),
  contactId?: long(name='ContactId', description='The ID of the alert contact. You can call the SearchAlertContact operation to query the contact IDs. For more information, see [SearchAlertContact](~~130703~~).', example='123'),
  contactName?: string(name='ContactName', description='The name of the alert contact.', example='John Doe'),
  isDetail?: boolean(name='IsDetail', description='Specifies whether to return all the alert contacts in the queried alert contact group. Default value: false.', example='true'),
  regionId?: string(name='RegionId', description='The ID of the region. Default value: `cn-hangzhou`.', example='cn-hangzhou'),
}

model SearchAlertContactGroupResponseBody = {
  contactGroups?: [ 
    {
      contactGroupId?: long(name='ContactGroupId', description='The ID of the alert contact group.', example='746'),
      contactGroupName?: string(name='ContactGroupName', description='The name of the alert contact group.', example='TestGroup'),
      contacts?: [ 
        {
          contactId?: long(name='ContactId', description='The ID of the alert contact.', example='123'),
          contactName?: string(name='ContactName', description='The name of the alert contact.', example='John Doe'),
          createTime?: long(name='CreateTime', description='The timestamp when the alert contact was created.', example='1572349025000'),
          dingRobot?: string(name='DingRobot', description='The webhook URL of the DingTalk chatbot.', example='https://oapi.dingtalk.com/robot/send?access_token=91f2f6****'),
          email?: string(name='Email', description='The email address of the alert contact.', example='someone@example.com'),
          phone?: string(name='Phone', description='The mobile number of the alert contact.', example='1381111*****'),
          systemNoc?: boolean(name='SystemNoc', description='Indicates whether the alert contact receives system notifications. Valid values:

*   true: receives system notifications.
*   false: does not receive system notifications.', example='false'),
          updateTime?: long(name='UpdateTime', description='The timestamp when the alert contact was updated.', example='1580258717000'),
          userId?: string(name='UserId', description='The ID of the user.', example='113197164949****'),
        }
      ](name='Contacts', description='The information about the alert contacts.'),
      createTime?: long(name='CreateTime', description='The timestamp when the alert contact group was created.', example='1529668855000'),
      updateTime?: long(name='UpdateTime', description='The timestamp when the alert contact group was updated.', example='1529668855000'),
      userId?: string(name='UserId', description='The ID of the user.', example='113197164949****'),
    }
  ](name='ContactGroups', description='The information about the alert contact groups.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4D6C358A-A58B-4F4B-94CE-F5AAF023****'),
}

model SearchAlertContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchAlertContactGroupResponseBody(name='body'),
}

/**
  * ************
  *
  * @param request SearchAlertContactGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SearchAlertContactGroupResponse
 */
async function searchAlertContactGroupWithOptions(request: SearchAlertContactGroupRequest, runtime: Util.RuntimeOptions): SearchAlertContactGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupIds)) {
    query['ContactGroupIds'] = request.contactGroupIds;
  }
  if (!Util.isUnset(request.contactGroupName)) {
    query['ContactGroupName'] = request.contactGroupName;
  }
  if (!Util.isUnset(request.contactId)) {
    query['ContactId'] = request.contactId;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.isDetail)) {
    query['IsDetail'] = request.isDetail;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchAlertContactGroup',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ************
  *
  * @param request SearchAlertContactGroupRequest
  * @return SearchAlertContactGroupResponse
 */
async function searchAlertContactGroup(request: SearchAlertContactGroupRequest): SearchAlertContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAlertContactGroupWithOptions(request, runtime);
}

model SearchAlertHistoriesRequest {
  alertId?: long(name='AlertId', description='The ID of the alert rule. You can call the SearchAlertRules operation and view the `Id` parameter in the response. For more information, see [SearchAlertRules](~~175825~~).', example='123'),
  alertType?: int32(name='AlertType', description='The type of the alert rule. Valid values:

*   `1`: custom alert rules to monitor drill-down data sets
*   `3`: custom alert rules to monitor tiled data sets
*   `4`: alert rules to monitor the frontend, including the default frontend alert rules
*   `5`: alert rules to monitor applications, including the default application alert rules
*   `6`: the default frontend alert rules
*   `7`: the default application alert rules
*   `8`: Tracing Analysis alert rules
*   `101`: Prometheus alert rules', example='4'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: `1`.', example='1'),
  endTime?: long(name='EndTime', description='The end of the time range to query. Specify a UNIX timestamp of the LONG data type, in milliseconds. The default value is the current time.', example='1579499626000'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: `10`.', example='10'),
  regionId?: string(name='RegionId', description='The ID of the region. Default value: `cn-hangzhou`.', example='cn-hangzhou'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. Specify a UNIX timestamp of the LONG data type, in milliseconds. The default value is 10 minutes before the current time.', example='1595568910000'),
}

model SearchAlertHistoriesResponseBody = {
  pageBean?: {
    alarmHistories?: [ 
      {
        alarmContent?: string(name='AlarmContent', description='The content of the alert notification.'),
        alarmResponseCode?: int32(name='AlarmResponseCode', description='The response code returned after the alert notification was sent.', example='200'),
        alarmSources?: string(name='AlarmSources', description='The webhook URL used for the alert contact, such as that of a DingTalk chatbot.', example='https://oapi.dingtalk.com/robot/send?access_token=91f2f65002fefe0ab9b71e6590c5ca504348cad742ff01e9c8ab204439ca****'),
        alarmTime?: long(name='AlarmTime', description='The time when the alert notification was sent.', example='1595564179000'),
        alarmType?: int32(name='AlarmType', description='The type of the alert rule. Default value: 4. Valid values:

*   `1`: custom alert rules to monitor drill-down data sets
*   `3`: custom alert rules to monitor tiled data sets
*   `4`: alert rules to monitor the frontend, including the default frontend alert rules
*   `5`: alert rules to monitor applications, including the default application alert rules
*   `6`: the default frontend alert rules
*   `7`: the default application alert rules
*   `8`: Tracing Analysis alert rules
*   `101`: Prometheus alert rules', example='4'),
        emails?: string(name='Emails', description='The email address of the alert contact.', example='someone@example.com'),
        id?: long(name='Id', description='The ID of the alert notification.', example='123'),
        phones?: string(name='Phones', description='The mobile number of the alert contact.', example='1381111****'),
        strategyId?: string(name='StrategyId', description='An internal parameter.', example='""'),
        target?: string(name='Target', description='An internal parameter.', example='""'),
        userId?: string(name='UserId', description='The ID of the user.', example='113197164949****'),
      }
    ](name='AlarmHistories', description='The information about alert records.'),
    pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
  }(name='PageBean', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FC13182-B9AF-4E6B-BE51-72669B7C****'),
}

model SearchAlertHistoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchAlertHistoriesResponseBody(name='body'),
}

/**
  * ********
  *
  * @param request SearchAlertHistoriesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SearchAlertHistoriesResponse
 */
async function searchAlertHistoriesWithOptions(request: SearchAlertHistoriesRequest, runtime: Util.RuntimeOptions): SearchAlertHistoriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!Util.isUnset(request.alertType)) {
    query['AlertType'] = request.alertType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchAlertHistories',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ********
  *
  * @param request SearchAlertHistoriesRequest
  * @return SearchAlertHistoriesResponse
 */
async function searchAlertHistories(request: SearchAlertHistoriesRequest): SearchAlertHistoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAlertHistoriesWithOptions(request, runtime);
}

model SearchAlertRulesRequest {
  appType?: string(name='AppType', description='The type of the application that is associated with the alert rule. Valid values:

*   `TRACE`: application.
*   `RETCODE`: browser.', example='TRACE'),
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page. Default value: `1`.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: `10`.', example='20'),
  pid?: string(name='Pid', description='The process identifier (PID) of the application that is associated with the alert rule. For more information about how to obtain the PID, see [Obtain the PID of an application](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).', example='atc889zkcf@d8deedfa9bf****'),
  regionId?: string(name='RegionId', description='The region ID of the alert data. For more information about the mappings between **RegionId** and **SystemRegionId**, see the detailed description below the table.', example='cn-hangzhou'),
  systemRegionId?: string(name='SystemRegionId', description='The region ID of the alert rule. For more information about the mappings between **RegionId** and **SystemRegionId**, see the detailed description below the table.', example='cn-hangzhou'),
  title?: string(name='Title', description='The alert rule name.', example='AlertRuleTitle'),
  type?: string(name='Type', description='The alert rule type. Valid values:

*   `1`: custom alert rules to monitor drill-down data sets.
*   `3`: custom alert rules to monitor tiled data sets.
*   `4`: alert rules to monitor the browser, including the default frontend alert rules.
*   `5`: alert rules to monitor applications, including the default application alert rules.
*   `6`: the default browser alert rules.
*   `7`: the default application alert rules.
*   `8`: Tracing Analysis alert rules.
*   `101`: Prometheus Service alert rules.', example='4'),
}

model SearchAlertRulesResponseBody = {
  pageBean?: {
    alertRules?: [ 
      {
        alarmContext?: {
          alarmContentSubTitle?: string(name='AlarmContentSubTitle', description='The sub-title of the alert notification content.', example='TestSubTitle'),
          alarmContentTemplate?: string(name='AlarmContentTemplate', description='The template of the alert notification.'),
          content?: string(name='Content', description='The content of the alert notification.'),
          subTitle?: string(name='SubTitle', description='The sub-title of the alert notification.', example='test'),
        }(name='AlarmContext', description='The format of the alert notification.'),
        alertLevel?: string(name='AlertLevel', description='The severity of the alerts. Only the value `WARN` is supported.', example='WARN'),
        alertRule?: {
          operator?: string(name='Operator', description='The logical operator between conditions. Valid values: `&`: AND. `|`: OR.', example='|'),
          rules?: [ 
            {
              aggregates?: string(name='Aggregates', description='The aggregation logic of the metric data of the alert rule. Valid values:

*   `AVG`: calculates the average value for each minute.
*   `SUM`: calculates the total value for each minute.
*   `MAX`: calculates the maximum value for each minute.
*   `MIN`: calculates the minimum value for each minute.', example='AVG'),
              alias?: string(name='Alias', description='The displayed description of the alert metric.'),
              measure?: string(name='Measure', description='The metric based on which alerts are triggered. For more information, see the "[Alert metrics](https://www.alibabacloud.com/help/zh/doc-detail/175825.htm?spm=a2c63.p38356.b99.373.61d25830rs3HHm#h2-url-4)" section in this topic.', example='appstat.jvm.SystemDiskFree'),
              NValue?: int32(name='NValue', description='The time range to query. Unit: minutes. For example, a value of 5 indicates that the alert rule applies to the data in the last 5 minutes.', example='5'),
              operator?: string(name='Operator', description='The operation logic of the condition. Valid values:

*   CURRENT_GTE: greater than or equal to.
*   CURRENT_LTE: less than or equal to.
*   PREVIOUS_UP: the minute-to-minute increase percentage.
*   PREVIOUS_DOWN: the minute-to-minute decrease percentage.
*   HOH_UP: the increase percentage compared with the previous hour.
*   HOH_DOWN: the decrease percentage compared with the previous hour.
*   DOD_UP: the increase percentage compared with the last day.
*   DOD_DOWN: the decrease percentage compared with the last day.', example='CURRENT_GTE'),
              value?: float(name='Value', description='The threshold of the condition.', example='30'),
            }
          ](name='Rules', description='The condition of the alert rule.'),
        }(name='AlertRule', description='The conditions of the alert rule. Multiple conditions are separated by the AND or OR logical operators.'),
        alertTitle?: string(name='AlertTitle', description='The name of the alert rule.', example='TestAlertRule'),
        alertType?: int32(name='AlertType', description='The type of the alert rule. Valid values:

*   `1`: custom alert rules to monitor drill-down data sets.
*   `3`: custom alert rules to monitor tiled data sets.
*   `4`: alert rules to monitor the browser, including the default frontend alert rules.
*   `5`: alert rules to monitor applications, including the default application alert rules.
*   `6`: the default browser alert rules.
*   `7`: the default application alert rules.
*   `8`: Tracing Analysis alert rules.
*   `101`: Prometheus alert rules.', example='4'),
        alertVersion?: int32(name='AlertVersion', description='The version of the alert rule. Default value: `1`.', example='1'),
        alertWays?: [ string ](name='AlertWays', description='The notification method of the alerts. Valid values:

*   `SMS`: text message.
*   `MAIL`: email.
*   `DING_ROBOT`: DingTalk chatbot.'),
        config?: string(name='Config', description='The configuration items of the alert rule. The value is a JSON string.

The configuration item **continuous** specifies whether to continuously send alert notifications. Valid values:

*   `true`: Alert notifications are sent every minute.
*   `false`: The alert silence feature is enabled.

The configuration item **dataRevision** specifies the data revision policy to be used if no data is obtained or the data is null. Default value: 2. Valid values:

*   `0`: overwrites the data by using the value 0.
*   `1`: overwrites the data by using the value 1.
*   `2`: overwrites the data by using the value null. This value indicates that no alert is triggered if no data exists.', example='{\\"continuous\\":true,\\"dataRevision\\":2}'),
        contactGroupIdList?: string(name='ContactGroupIdList', description='The ID of the contact group. Multiple IDs are separated by commas (,).', example='381*,572*'),
        contactGroupIds?: string(name='ContactGroupIds', description='The IDs of the alert contact groups. The value is a JSON array.', example='[123, 234]'),
        createTime?: long(name='CreateTime', description='The timestamp showing when the alert rule was created.', example='1579508519683'),
        hostByAlertManager?: boolean(name='HostByAlertManager', description='Indicates whether the alert is sent through the alert center. Valid values:

*   `true`
*   `false`', example='true'),
        id?: long(name='Id', description='The ID of the alert rule.', example='123'),
        metricParam?: {
          appGroupId?: string(name='AppGroupId', description='The ID of the application group that is associated with the alert rule. This parameter is applicable to Enterprise Distributed Application Service (EDAS) applications.', example='DEFAULT'),
          appId?: string(name='AppId', description='The auto-increment ID of the ARMS application. You can ignore this ID.', example='123'),
          dimensions?: [ 
            {
              key?: string(name='Key', description='The key of the dimension. Valid values:

- `rpc`: the name of the API.
- `rpcType`: the type of the API call, such as HTTP or DUBBO.
- `endpoint`: the name of the database.
- `rootIp`: the IP address of the host.', example='rootIp'),
              type?: string(name='Type', description='The type of the dimension. Valid values:

- `STATIC`: checks only the value of this dimension. In this case, you must set the **dimensions.value** parameter.
- `ALL`: checks the values of all dimensions. The metrics of all API calls are checked. If an API call triggers an alert, the name of the API is displayed in the alert notification. In this case, you do not need to set the **dimensions.value** parameter.
- `DISABLE`: aggregates the values of all dimensions. In this case, you do not need to set the **dimensions.value** parameter.', example='DISABLE'),
              value?: string(name='Value', description='The value of the dimension.', example='"127.0.0.1"'),
            }
          ](name='Dimensions', description='The dimensions in the condition.'),
          pid?: string(name='Pid', description='The PID of the application that is associated with the alert rule.', example='9870ca99-8105-4da7-a3a4-d72dd1b1****'),
          type?: string(name='Type', description='The type of the metric. Valid values: 

- `txn`: the number of API calls during application monitoring.
- `txn_type`: the types of API calls during application monitoring.
- `db`: database metrics.
- `jvm`: Java virtual machine (JVM) metrics.
- `host`: host metrics.
- `exception`: API call errors.', example='DB'),
        }(name='MetricParam', description='The information about the application that is associated with the alert rule.'),
        notice?: {
          endTime?: long(name='EndTime', description='The end of the time range when the alert rule takes effect within the 24 hours per day. This value is a UNIX timestamp. The year, month, and day that are indicated by the timestamp are not displayed in this value. Only the hour, minute, and second are displayed.', example='1480607940000'),
          noticeEndTime?: long(name='NoticeEndTime', description='The end of the time range when alert notifications are sent based on the alert rule within the 24 hours per day. This value is a UNIX timestamp. The year, month, and day that are indicated by the timestamp are not displayed in this value. Only the hour, minute, and second are displayed.', example='1480607940000'),
          noticeStartTime?: long(name='NoticeStartTime', description='The beginning of the time range when alert notifications are sent based on the alert rule within the 24 hours per day. This value is a UNIX timestamp. The year, month, and day that are indicated by the timestamp are not displayed in this value. Only the hour, minute, and second are displayed.', example='1480521600000'),
          startTime?: long(name='StartTime', description='The beginning of the time range when the alert rule takes effect within the 24 hours per day. This value is a UNIX timestamp. The year, month, and day that are indicated by the timestamp are not displayed in this value. Only the hour, minute, and second are displayed.', example='1480521600000'),
        }(name='Notice', description='The time ranges when the alert rule takes effect and when alert notifications are sent.'),
        regionId?: string(name='RegionId', description='The ID of the region to which the alert rule belongs.', example='cn-hangzhou'),
        status?: string(name='Status', description='The status of the alert rule. `RUNNING`: The alert rule is enabled. `STOPPED`: The alert rule is disabled.', example='RUNNING'),
        taskId?: long(name='TaskId', description='The ID of the Application Real-Time Monitoring Service (ARMS) task that is associated with the alert rule.', example='123'),
        taskStatus?: string(name='TaskStatus', description='The status of the task. This parameter is hidden from users.', example='""'),
        title?: string(name='Title', description='The name of the alert.', example='AlertTest'),
        updateTime?: long(name='UpdateTime', description='The timestamp showing when the alert rule was updated.', example='1480521600000'),
        userId?: string(name='UserId', description='The ID of the user to which the alert rule belongs.', example='113197164949****'),
      }
    ](name='AlertRules', description='The details of the alert rules.'),
    pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='23'),
  }(name='PageBean', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='34ED024E-9E31-434A-9E4E-D9D15C3****'),
}

model SearchAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchAlertRulesResponseBody(name='body'),
}

/**
  * ************
  *
  * @param request SearchAlertRulesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SearchAlertRulesResponse
 */
async function searchAlertRulesWithOptions(request: SearchAlertRulesRequest, runtime: Util.RuntimeOptions): SearchAlertRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appType)) {
    query['AppType'] = request.appType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.systemRegionId)) {
    query['SystemRegionId'] = request.systemRegionId;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchAlertRules',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ************
  *
  * @param request SearchAlertRulesRequest
  * @return SearchAlertRulesResponse
 */
async function searchAlertRules(request: SearchAlertRulesRequest): SearchAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAlertRulesWithOptions(request, runtime);
}

model SearchEventsRequest {
  alertId?: long(name='AlertId', description='The ID of the alert rule. You can call the SearchAlertRules operation and view the `Id` parameter in the response. For more information, see [SearchAlertRules](~~175825~~).', example='123'),
  alertType?: int32(name='AlertType', description='The type of the alert rule. Valid values:

*   `1`: custom alert rules to monitor drill-down data sets
*   `3`: custom alert rules to monitor tiled data sets
*   `4`: alert rules to monitor the frontend, including the default frontend alert rules
*   `5`: alert rules to monitor applications, including the default application alert rules
*   `6`: the default frontend alert rules
*   `7`: the default application alert rules
*   `8`: Tracing Analysis alert rules
*   `101`: Prometheus alert rules', example='4'),
  appType?: string(name='AppType', description='The type of the application that is associated with the alert rule. Valid values:

*   `TRACE`: application monitoring
*   `RETCODE`: frontend monitoring', example='TRACE'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: `1`.', example='1'),
  endTime?: long(name='EndTime', description='The end of the time range to query. Specify a UNIX timestamp of the LONG data type, in milliseconds. The default value is the current time.', example='1595568970000'),
  isTrigger?: int32(name='IsTrigger', description='Specifies whether the alert event is triggered. If you do not set this parameter, all alert events are queried. Valid values:

*   `1`: The event is triggered.
*   `0`: The event is not triggered.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: `10`.', example='10'),
  pid?: string(name='Pid', description='The process identifier (PID) of the application that is associated with the alert rule.', example='atc889zkcf@d8deedfa9bf****'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. Specify a UNIX timestamp of the LONG data type, in milliseconds. The default value is 10 minutes before the current time.', example='1595565300000'),
}

model SearchEventsResponseBody = {
  isTrigger?: int32(name='IsTrigger', description='Specifies whether the alert event is triggered. If you do not set this parameter, all alert events are queried. Valid values:

*   `1`: The event is triggered.
*   `0`: The event is not triggered.', example='0'),
  pageBean?: {
    event?: [ 
      {
        alertId?: long(name='AlertId', description='The ID of the alert rule that is associated with the event.', example='123'),
        alertName?: string(name='AlertName', description='The name of the alert rule that is associated with the event.', example='alertName'),
        alertRule?: string(name='AlertRule', description='The condition of the alert rule.'),
        alertType?: int32(name='AlertType', description='The type of the alert rule. This parameter is not returned. Valid values:

*   `1`: custom alert rules to monitor drill-down data sets
*   `3`: custom alert rules to monitor tiled data sets
*   `4`: alert rules to monitor the frontend, including the default frontend alert rules
*   `5`: alert rules to monitor applications, including the default application alert rules
*   `6`: the default frontend alert rules
*   `7`: the default application alert rules
*   `8`: Tracing Analysis alert rules
*   `101`: Prometheus alert rules', example='4'),
        eventLevel?: string(name='EventLevel', description='The severity of the event.', example='1'),
        eventTime?: long(name='EventTime', description='The timestamp when the event occurred.', example='1595569020000'),
        id?: long(name='Id', description='The ID of the event record.', example='123'),
        links?: [ string ](name='Links', description='The list of event URLs.'),
        message?: string(name='Message', description='The event content. The parameter value is a JSON string. Each key indicates a dimension and each value indicates the alert content in the dimension.'),
      }
    ](name='Event', description='The information about the alert events.'),
    pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
  }(name='PageBean', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='32940175-181B-4B93-966E-4BB69176****'),
}

model SearchEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchEventsResponseBody(name='body'),
}

/**
  * Alert event records are different from alert notification records. Alert events are recorded every minute after an alert rule filters data. Alert events can be classified based on whether they are triggered or not. If a triggered event is not in the silence period, an alert notification is sent.
  *
  * @param request SearchEventsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SearchEventsResponse
 */
async function searchEventsWithOptions(request: SearchEventsRequest, runtime: Util.RuntimeOptions): SearchEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!Util.isUnset(request.alertType)) {
    query['AlertType'] = request.alertType;
  }
  if (!Util.isUnset(request.appType)) {
    query['AppType'] = request.appType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.isTrigger)) {
    query['IsTrigger'] = request.isTrigger;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchEvents',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Alert event records are different from alert notification records. Alert events are recorded every minute after an alert rule filters data. Alert events can be classified based on whether they are triggered or not. If a triggered event is not in the silence period, an alert notification is sent.
  *
  * @param request SearchEventsRequest
  * @return SearchEventsResponse
 */
async function searchEvents(request: SearchEventsRequest): SearchEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchEventsWithOptions(request, runtime);
}

model SearchRetcodeAppByPageRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='5'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId'),
  retcodeAppId?: string(name='RetcodeAppId'),
  retcodeAppName?: string(name='RetcodeAppName', description='The name of the application that is monitored by Browser Monitoring.', example='App1'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
}

model SearchRetcodeAppByPageResponseBody = {
  pageBean?: {
    pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='2'),
    retcodeApps?: [ 
      {
        appId?: long(name='AppId', description='The ID of the application. The parameter is an auto-increment parameter.', example='16064'),
        appName?: string(name='AppName', description='The name of the application.', example='a3'),
        createTime?: long(name='CreateTime', description='The time when the task was created.', example='1545363321000'),
        nickName?: string(name='NickName', description='The alias of the application.', example='c1'),
        pid?: string(name='Pid', description='The PID of the application.', example='aokcdqn3ly@741623b4e91****'),
        regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
        resourceGroupId?: string(name='ResourceGroupId'),
        retcodeAppType?: string(name='RetcodeAppType', description='The type of the application. Valid values:

*   `web`: web application
*   `weex`: Weex mobile app
*   `mini_dd`: DingTalk mini program
*   `mini_alipay`: Alipay mini program
*   `mini_wx`: WeChat mini program
*   `mini_common`: mini program on other platforms', example='web'),
        tags?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Tags'),
        type?: string(name='Type', description='The monitoring type. Valid values:

*   `TRACE`: application monitoring
*   `RETCODE`: browser monitoring', example='RETCODE'),
        updateTime?: long(name='UpdateTime', description='The time when the task was updated.', example='1545363321000'),
        userId?: string(name='UserId', description='The ID of the user.', example='12341234'),
      }
    ](name='RetcodeApps', description='The browser monitoring tasks that are returned.'),
    totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='8'),
  }(name='PageBean', description='The returned page information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='626037F5-FDEB-45B0-804C-B3C92797A64E'),
}

model SearchRetcodeAppByPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchRetcodeAppByPageResponseBody(name='body'),
}

async function searchRetcodeAppByPageWithOptions(request: SearchRetcodeAppByPageRequest, runtime: Util.RuntimeOptions): SearchRetcodeAppByPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.retcodeAppId)) {
    query['RetcodeAppId'] = request.retcodeAppId;
  }
  if (!Util.isUnset(request.retcodeAppName)) {
    query['RetcodeAppName'] = request.retcodeAppName;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchRetcodeAppByPage',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchRetcodeAppByPage(request: SearchRetcodeAppByPageRequest): SearchRetcodeAppByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchRetcodeAppByPageWithOptions(request, runtime);
}

model SearchTraceAppByNameRequest {
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  traceAppName?: string(name='TraceAppName', description='The name of the application for which you want to query application monitoring jobs.', example='test-app'),
}

model SearchTraceAppByNameResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F7781D4A-2818-41E7-B7BB-79D809E9****'),
  traceApps?: [ 
    {
      appId?: long(name='AppId', description='The ID of the application.', example='123'),
      appName?: string(name='AppName', description='The name of the application.', example='test-app'),
      createTime?: long(name='CreateTime', description='The timestamp when the application was created.', example='1593486786000'),
      labels?: [ string ](name='Labels', description='The tag of the application.'),
      pid?: string(name='Pid', description='The process identifier (PID) of the application.', example='a5f9bdeb-2627-4dbe-9247-****'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      show?: boolean(name='Show', description='Indicates whether the application is displayed in the Application Real-Time Monitoring Service (ARMS) console. Valid values:

*   `true`: The application is displayed in the ARMS console.
*   `false`: The application is not displayed in the ARMS console.', example='true'),
      type?: string(name='Type', description='The type of the monitoring job. Valid values:

*   `TRACE`: application monitoring
*   `RETCODE`: frontend monitoring', example='TRACE'),
      updateTime?: long(name='UpdateTime', description='The timestamp when the application was updated.', example='1593486786000'),
      userId?: string(name='UserId', description='The ID of the user.', example='113197164949****'),
    }
  ](name='TraceApps', description='The information about the application monitoring job.'),
}

model SearchTraceAppByNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchTraceAppByNameResponseBody(name='body'),
}

/**
  * ****
  *
  * @param request SearchTraceAppByNameRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SearchTraceAppByNameResponse
 */
async function searchTraceAppByNameWithOptions(request: SearchTraceAppByNameRequest, runtime: Util.RuntimeOptions): SearchTraceAppByNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.traceAppName)) {
    query['TraceAppName'] = request.traceAppName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchTraceAppByName',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ****
  *
  * @param request SearchTraceAppByNameRequest
  * @return SearchTraceAppByNameResponse
 */
async function searchTraceAppByName(request: SearchTraceAppByNameRequest): SearchTraceAppByNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTraceAppByNameWithOptions(request, runtime);
}

model SearchTraceAppByPageRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Default value: `1`.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: `10`.', example='10'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  traceAppName?: string(name='TraceAppName', description='The name of the application.', example='test-app'),
}

model SearchTraceAppByPageResponseBody = {
  pageBean?: {
    pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='3'),
    traceApps?: [ 
      {
        appId?: long(name='AppId', description='The ID of the application.', example='123'),
        appName?: string(name='AppName', description='The name of the application.', example='test-app'),
        createTime?: long(name='CreateTime', description='The timestamp generated when the monitoring task was created.', example='1531291867000'),
        labels?: [ string ](name='Labels'),
        pid?: string(name='Pid', description='The PID of the application.', example='atc889zkcf@d8deedfa9bf****'),
        regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
        resourceGroupId?: string(name='ResourceGroupId'),
        show?: boolean(name='Show', description='Indicates whether the application was displayed in the Application Real-Time Monitoring Service (ARMS) console. Valid values:

*   `true`: The application was displayed in the ARMS console.
*   `false`: The application was not displayed in the ARMS console.', example='true'),
        tags?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Tags'),
        type?: string(name='Type', description='The type of the monitoring task. Valid values:

*   `TRACE`: application monitoring
*   `RETCODE`: browser monitoring', example='TRACE'),
        updateTime?: long(name='UpdateTime', description='The timestamp generated when the monitoring task was updated.', example='1531291867000'),
        userId?: string(name='UserId', description='The ID of the user.', example='113197164949****'),
      }
    ](name='TraceApps', description='The information about the application monitoring task.'),
  }(name='PageBean', description='The returned page information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4B446DF2-3DDD-4B5B-8E3F-D5225120****'),
}

model SearchTraceAppByPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchTraceAppByPageResponseBody(name='body'),
}

async function searchTraceAppByPageWithOptions(request: SearchTraceAppByPageRequest, runtime: Util.RuntimeOptions): SearchTraceAppByPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.traceAppName)) {
    query['TraceAppName'] = request.traceAppName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchTraceAppByPage',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchTraceAppByPage(request: SearchTraceAppByPageRequest): SearchTraceAppByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTraceAppByPageWithOptions(request, runtime);
}

model SearchTracesRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. Unit: milliseconds.', example='1595210400000'),
  exclusionFilters?: [ 
    {
      key?: string(name='Key', description='The key that is used to filter the query results.', example='http.status_code'),
      value?: string(name='Value', description='The value of the key that is used to filter the query results.', example='404'),
    }
  ](name='ExclusionFilters'),
  minDuration?: long(name='MinDuration', description='The minimum amount of time consumed by traces. Unit: milliseconds.', example='2'),
  operationName?: string(name='OperationName', description='The name of the traced span.', example='/demo/queryNotExistDB/11'),
  pid?: string(name='Pid', description='The ID of the application.', example='b590lhguqs@9781be0f44dXXXX'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  reverse?: boolean(name='Reverse', description='Specifies whether to sort the query results in chronological order or reverse chronological order. Default value: `false`.

*   `true`: sorts the query results in reverse chronological order.
*   `false`: sorts the query results in chronological order.', example='false'),
  serviceIp?: string(name='ServiceIp', description='The IP address of the host where the application resides.', example='172.20.XX.XX'),
  serviceName?: string(name='ServiceName', description='The name of the application.', example='arms-k8s-demo-subcomponent'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. Unit: milliseconds.', example='1595174400000'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='http.status_code'),
      value?: string(name='Value', description='The value of the tag.', example='200'),
    }
  ](name='Tag'),
}

model SearchTracesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='4C518054-852F-4023-ABC1-4AF95FF7****'),
  traceInfos?: [ 
    {
      duration?: long(name='Duration', description='The amount of time consumed by the trace. Unit: milliseconds.', example='6'),
      operationName?: string(name='OperationName', description='The name of the traced span.', example='get***'),
      serviceIp?: string(name='ServiceIp', description='The IP address of the host where the application resides.', example='172.20.**.**'),
      serviceName?: string(name='ServiceName', description='The name of the application.', example='arms-k8s-demo-subcomponent'),
      timestamp?: long(name='Timestamp', description='The timestamp.', example='1595174436993'),
      traceID?: string(name='TraceID', description='The ID of the trace.', example='ac1400a115951744369937024d****'),
    }
  ](name='TraceInfos', description='The details of the returned traces.'),
}

model SearchTracesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchTracesResponseBody(name='body'),
}

/**
  * >  A maximum of 100 data entries can be returned each time this operation is called. If you want to query all existing traces, we recommend that you call the SearchTracesByPage operation. For more information, see [SearchTracesByPage](~~175866~~).
  *
  * @param request SearchTracesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SearchTracesResponse
 */
async function searchTracesWithOptions(request: SearchTracesRequest, runtime: Util.RuntimeOptions): SearchTracesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.exclusionFilters)) {
    query['ExclusionFilters'] = request.exclusionFilters;
  }
  if (!Util.isUnset(request.minDuration)) {
    query['MinDuration'] = request.minDuration;
  }
  if (!Util.isUnset(request.operationName)) {
    query['OperationName'] = request.operationName;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.reverse)) {
    query['Reverse'] = request.reverse;
  }
  if (!Util.isUnset(request.serviceIp)) {
    query['ServiceIp'] = request.serviceIp;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchTraces',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  A maximum of 100 data entries can be returned each time this operation is called. If you want to query all existing traces, we recommend that you call the SearchTracesByPage operation. For more information, see [SearchTracesByPage](~~175866~~).
  *
  * @param request SearchTracesRequest
  * @return SearchTracesResponse
 */
async function searchTraces(request: SearchTracesRequest): SearchTracesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTracesWithOptions(request, runtime);
}

model SearchTracesByPageRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. Unit: milliseconds.', example='1595210400000'),
  exclusionFilters?: [ 
    {
      key?: string(name='Key', description='The key that is used to filter the query results.', example='http.status_code'),
      value?: string(name='Value', description='The value of the key that is used to filter the query results.', example='404'),
    }
  ](name='ExclusionFilters', description='The filter conditions.'),
  minDuration?: long(name='MinDuration', description='The minimum amount of time consumed by traces. Unit: milliseconds.', example='2'),
  operationName?: string(name='OperationName', description='The name of the traced span.', example='/demo/queryNotExistDB/11'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 100.', example='5'),
  pid?: string(name='Pid', description='The ID of the application.', example='b590lhguqs@9781be0f44dXXXX'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  reverse?: boolean(name='Reverse', description='Specifies whether to sort the query results in chronological order or reverse chronological order. Default value: `false`.

*   `true`: sorts the query results in reverse chronological order.
*   `false`: sorts the query results in chronological order.', example='false'),
  serviceIp?: string(name='ServiceIp', description='The IP address of the host where the application resides.', example='172.20.XX.XX'),
  serviceName?: string(name='ServiceName', description='The name of the application.', example='arms-k8s-demo-subcomponent'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. Unit: milliseconds.', example='1595174400000'),
  tags?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='http.status_code'),
      value?: string(name='Value', description='The value of the tag.', example='200'),
    }
  ](name='Tags', description='The tags of the instances you want to query.'),
}

model SearchTracesByPageResponseBody = {
  pageBean?: {
    pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='5'),
    total?: int32(name='Total', description='The total number of returned entries.', example='1601'),
    traceInfos?: [ 
      {
        duration?: long(name='Duration', description='The amount of time consumed by the trace. Unit: milliseconds.', example='679'),
        operationName?: string(name='OperationName', description='The name of the traced span.', example='/demo/queryException/12'),
        serviceIp?: string(name='ServiceIp', description='The IP address of the host where the application resides.', example='172.20.XX.XX'),
        serviceName?: string(name='ServiceName', description='The name of the application.', example='arms-k8s-demo-subcomponent'),
        timestamp?: long(name='Timestamp', description='The timestamp.', example='1595174436994'),
        traceID?: string(name='TraceID', description='The ID of the trace.', example='ac1400a115951744369947025d****'),
      }
    ](name='TraceInfos', description='The details of the returned traces.'),
  }(name='PageBean', description='The struct returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4C518054-852F-4023-ABC1-4AF95FF7****'),
}

model SearchTracesByPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchTracesByPageResponseBody(name='body'),
}

async function searchTracesByPageWithOptions(request: SearchTracesByPageRequest, runtime: Util.RuntimeOptions): SearchTracesByPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.exclusionFilters)) {
    query['ExclusionFilters'] = request.exclusionFilters;
  }
  if (!Util.isUnset(request.minDuration)) {
    query['MinDuration'] = request.minDuration;
  }
  if (!Util.isUnset(request.operationName)) {
    query['OperationName'] = request.operationName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.reverse)) {
    query['Reverse'] = request.reverse;
  }
  if (!Util.isUnset(request.serviceIp)) {
    query['ServiceIp'] = request.serviceIp;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchTracesByPage',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchTracesByPage(request: SearchTracesByPageRequest): SearchTracesByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTracesByPageWithOptions(request, runtime);
}

model SendTTSVerifyLinkRequest {
  contactId?: long(name='ContactId', description='The ID of the alert contact.', example='123'),
  phone?: string(name='Phone', description='The mobile number of the alert contact.', example='1381111****'),
}

model SendTTSVerifyLinkResponseBody = {
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the mobile phone number verification text message was successfully sent.

*   `true`: Sent successfully
*   `false`: Failed to send', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='21E85B16-75A6-429A-9F65-8AAC9A54****'),
}

model SendTTSVerifyLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SendTTSVerifyLinkResponseBody(name='body'),
}

/**
  * After receiving the mobile phone number verification SMS, please complete the mobile phone number verification according to the SMS prompt. Only verified mobile phone numbers can use the notification method of the phone in the notification policy.
  *
  * @param request SendTTSVerifyLinkRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SendTTSVerifyLinkResponse
 */
async function sendTTSVerifyLinkWithOptions(request: SendTTSVerifyLinkRequest, runtime: Util.RuntimeOptions): SendTTSVerifyLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.contactId)) {
    body['ContactId'] = request.contactId;
  }
  if (!Util.isUnset(request.phone)) {
    body['Phone'] = request.phone;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SendTTSVerifyLink',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * After receiving the mobile phone number verification SMS, please complete the mobile phone number verification according to the SMS prompt. Only verified mobile phone numbers can use the notification method of the phone in the notification policy.
  *
  * @param request SendTTSVerifyLinkRequest
  * @return SendTTSVerifyLinkResponse
 */
async function sendTTSVerifyLink(request: SendTTSVerifyLinkRequest): SendTTSVerifyLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendTTSVerifyLinkWithOptions(request, runtime);
}

model SetRetcodeShareStatusRequest {
  pid?: string(name='Pid', description='The process identifier (PID) of the application. For more information about how to obtain the PID, see [Obtain the PID of an application](~~186100~~#title-imy-7gj-qhr).', example='atc889zkcf@d8deedfa9bf****'),
  status?: boolean(name='Status', description='Specifies whether to turn on or turn off Logon-free Sharing. Valid values:

*   `true`: turns on Logon-free Sharing
*   `false`: turns off Logon-free Sharing', example='true'),
}

model SetRetcodeShareStatusResponseBody = {
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the call was successful. Valid values:

*   `true`: The call was successful.
*   `false`: The call failed.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='40B10E04-81E8-4643-970D-F1B38F2E****'),
}

model SetRetcodeShareStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetRetcodeShareStatusResponseBody(name='body'),
}

async function setRetcodeShareStatusWithOptions(request: SetRetcodeShareStatusRequest, runtime: Util.RuntimeOptions): SetRetcodeShareStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetRetcodeShareStatus',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setRetcodeShareStatus(request: SetRetcodeShareStatusRequest): SetRetcodeShareStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setRetcodeShareStatusWithOptions(request, runtime);
}

model StartAlertRequest {
  alertId?: string(name='AlertId', description='The ID of the alert rule. You can call the SearchAlertRules operation and view the `Id` parameter in the response. For more information, see [SearchAlertRules](~~175825~~).', example='1610***'),
  regionId?: string(name='RegionId', description='The ID of the region. Set the value to `cn-hangzhou`.', example='cn-hangzhou'),
}

model StartAlertResponseBody = {
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the call was successful.

*   `true`: The call was successful.
*   `false`: The call failed.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='27E653FA-5958-45BE-8AA9-14D884DC****'),
}

model StartAlertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartAlertResponseBody(name='body'),
}

async function startAlertWithOptions(request: StartAlertRequest, runtime: Util.RuntimeOptions): StartAlertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartAlert',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startAlert(request: StartAlertRequest): StartAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  return startAlertWithOptions(request, runtime);
}

model StopAlertRequest {
  alertId?: string(name='AlertId', example='1610***'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model StopAlertResponseBody = {
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='27E653FA-5958-45BE-8AA9-14D884DC****'),
}

model StopAlertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopAlertResponseBody(name='body'),
}

async function stopAlertWithOptions(request: StopAlertRequest, runtime: Util.RuntimeOptions): StopAlertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopAlert',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopAlert(request: StopAlertRequest): StopAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopAlertWithOptions(request, runtime);
}

model SwitchSyntheticTaskStatusRequest {
  switchStatus?: long(name='SwitchStatus', example='0'),
  taskIds?: [ long ](name='TaskIds'),
}

model SwitchSyntheticTaskStatusResponseBody = {
  requestId?: string(name='RequestId', example='1A9C645C-C83F-4C9D-8CCB-29BEC9E1****'),
  result?: string(name='Result', example='true'),
}

model SwitchSyntheticTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SwitchSyntheticTaskStatusResponseBody(name='body'),
}

async function switchSyntheticTaskStatusWithOptions(request: SwitchSyntheticTaskStatusRequest, runtime: Util.RuntimeOptions): SwitchSyntheticTaskStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.switchStatus)) {
    query['SwitchStatus'] = request.switchStatus;
  }
  if (!Util.isUnset(request.taskIds)) {
    query['TaskIds'] = request.taskIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SwitchSyntheticTaskStatus',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function switchSyntheticTaskStatus(request: SwitchSyntheticTaskStatusRequest): SwitchSyntheticTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchSyntheticTaskStatusWithOptions(request, runtime);
}

model SyncRecordingRulesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster whose aggregation rule you want to synchronize.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  regionId?: string(name='RegionId', description='The ID of the region. The destination region can be the same as the source region.', example='cn-hangzhou'),
  targetClusters?: string(name='TargetClusters', description='The IDs of clusters to which you want to synchronize the aggregation rule.', example='{     "cn":[         "c06ca68cd16f14f52bb07772eda***",         "c33dd70a0ac184c1b879d807ab2***",         "c384cf7e4dcb543e6ac8c7d4dd3***"     ],     "us":[         "ce30f833bc4a04a56a06b070319***"     ],     "jp":[      ],     "ap":[      ],     "gov":[      ],     "finance":[      ] }'),
}

model SyncRecordingRulesResponseBody = {
  data?: string(name='Data', description='The struct returned.', example='{ "data":\\[ "c06ca68cd16f14f52bb07772eda\\*\\*\\*", "c33dd70a0ac184c1b879d807ab2\\*\\*\\*", "c384cf7e4dcb543e6ac8c7d4dd3\\*\\*\\*", "ce30f833bc4a04a56a06b070319\\*\\*\\*" ], "message":"IDs of Clusters to which the aggregation rule failed to be synchronized", "success":true }'),
  requestId?: string(name='RequestId', description='The ID of the request. You can use the ID to query logs and troubleshoot issues.', example='1A9C645C-C83F-4C9D-8CCB-29BEC9E1****'),
}

model SyncRecordingRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SyncRecordingRulesResponseBody(name='body'),
}

async function syncRecordingRulesWithOptions(request: SyncRecordingRulesRequest, runtime: Util.RuntimeOptions): SyncRecordingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.targetClusters)) {
    query['TargetClusters'] = request.targetClusters;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SyncRecordingRules',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function syncRecordingRules(request: SyncRecordingRulesRequest): SyncRecordingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncRecordingRulesWithOptions(request, runtime);
}

model UninstallManagedPrometheusRequest {
  clusterId?: string(name='ClusterId', description='The ID of the ASK cluster.', example='cc7a37ee31aea4ed1a059eff8034b****'),
  clusterType?: string(name='ClusterType', description='The type of the cluster. You can query the dashboards of a virtual cluster by specifying the cluster type.', example='ask'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  vpcId?: string(name='VpcId', description='The VPC of the ASK cluster.', example='vpc-rpn**********'),
}

model UninstallManagedPrometheusResponseBody = {
  code?: int32(name='Code', description='The status code returned. 200 indicates that the Prometheus agent was uninstalled. Otherwise, the Prometheus agent fails to be uninstalled.', example='200'),
  data?: string(name='Data', description='The content of the response. The installation status of the Prometheus agent was returned.', example='success'),
  message?: string(name='Message', description='The error message returned if the Prometheus agent fails to be uninstalled.', example='vpcId is blank'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2A0CEDF1-06FE-44AC-8E21-21A5BE65****'),
  success?: boolean(name='Success', description='Indicates whether the Prometheus agent was uninstalled.', example='true'),
}

model UninstallManagedPrometheusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallManagedPrometheusResponseBody(name='body'),
}

/**
  * You can call the API operation to uninstall a Prometheus agent only from a serverless Kubernetes (ASK) cluster.
  *
  * @param request UninstallManagedPrometheusRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UninstallManagedPrometheusResponse
 */
async function uninstallManagedPrometheusWithOptions(request: UninstallManagedPrometheusRequest, runtime: Util.RuntimeOptions): UninstallManagedPrometheusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallManagedPrometheus',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call the API operation to uninstall a Prometheus agent only from a serverless Kubernetes (ASK) cluster.
  *
  * @param request UninstallManagedPrometheusRequest
  * @return UninstallManagedPrometheusResponse
 */
async function uninstallManagedPrometheus(request: UninstallManagedPrometheusRequest): UninstallManagedPrometheusResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallManagedPrometheusWithOptions(request, runtime);
}

model UninstallPromClusterRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c0bad479465464e1d8c1e641b0afb****'),
  regionId?: string(name='RegionId', description='The ID of the region. default value: cn-hangzhou.', example='cn-hangzhou'),
}

model UninstallPromClusterResponseBody = {
  data?: boolean(name='Data', description='Indicates whether the call was successful. Valid values:

true: The call was successful. false: The call failed.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request. You can query logs and troubleshoot issues based on the ID.', example='53980F48-DE82-53A1-9ADE-D2629226DD9A'),
}

model UninstallPromClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallPromClusterResponseBody(name='body'),
}

async function uninstallPromClusterWithOptions(request: UninstallPromClusterRequest, runtime: Util.RuntimeOptions): UninstallPromClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallPromCluster',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uninstallPromCluster(request: UninstallPromClusterRequest): UninstallPromClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallPromClusterWithOptions(request, runtime);
}

model UpdateAlertContactRequest {
  contactId?: long(name='ContactId', description='The ID of the alert contact to be updated. You can call the SearchAlertContact operation to query the contact ID. For more information, see [SearchAlertContact](~~130703~~).', example='123'),
  contactName?: string(name='ContactName', description='The new name of the alert contact.', example='John Doe'),
  dingRobotWebhookUrl?: string(name='DingRobotWebhookUrl', description='The new webhook URL of the DingTalk bot. For more information, see [Configure a DingTalk chatbot to send alert notifications](~~106247~~). You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.

>  If you do not specify this parameter, the original webhook URL of the DingTalk bot is deleted. If you specify this parameter, the original webhook URL of the DingTalk bot is updated.', example='https://oapi.dingtalk.com/robot/send?access_token=91f2f6****'),
  email?: string(name='Email', description='The new email address of the alert contact. You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.

>  If you do not specify this parameter, the original email address of the alert contact is deleted. If you specify this parameter, the original email address of the alert contact is updated.', example='someone@example.com'),
  phoneNum?: string(name='PhoneNum', description='The new mobile phone number of the alert contact. You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.

>  If you do not specify this parameter, the original mobile phone number of the alert contact is deleted. If you specify this parameter, the original mobile phone number of the alert contact is updated.', example='1381111****'),
  regionId?: string(name='RegionId', description='The ID of the region. Set the value to `cn-hangzhou`.', example='cn-hangzhou'),
  systemNoc?: boolean(name='SystemNoc', description='Specifies whether the alert contact receives system notifications. Valid values:

*   `true`: receives system notifications.
*   `false`: does not receive system notifications.', example='true'),
}

model UpdateAlertContactResponseBody = {
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the update was successful. Valid values:

*   true: The update was successful.
*   false: The update failed.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1A474FF8-7861-4D00-81B5-5BC3DA4E****'),
}

model UpdateAlertContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAlertContactResponseBody(name='body'),
}

/**
  * ****
  *
  * @param request UpdateAlertContactRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateAlertContactResponse
 */
async function updateAlertContactWithOptions(request: UpdateAlertContactRequest, runtime: Util.RuntimeOptions): UpdateAlertContactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactId)) {
    query['ContactId'] = request.contactId;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.dingRobotWebhookUrl)) {
    query['DingRobotWebhookUrl'] = request.dingRobotWebhookUrl;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.phoneNum)) {
    query['PhoneNum'] = request.phoneNum;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.systemNoc)) {
    query['SystemNoc'] = request.systemNoc;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlertContact',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ****
  *
  * @param request UpdateAlertContactRequest
  * @return UpdateAlertContactResponse
 */
async function updateAlertContact(request: UpdateAlertContactRequest): UpdateAlertContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAlertContactWithOptions(request, runtime);
}

model UpdateAlertContactGroupRequest {
  contactGroupId?: long(name='ContactGroupId', example='123'),
  contactGroupName?: string(name='ContactGroupName', example='TestGroup'),
  contactIds?: string(name='ContactIds', example='123 234 345'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model UpdateAlertContactGroupResponseBody = {
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='9319A57D-2D9E-472A-B69B-CF3CD16D****'),
}

model UpdateAlertContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAlertContactGroupResponseBody(name='body'),
}

async function updateAlertContactGroupWithOptions(request: UpdateAlertContactGroupRequest, runtime: Util.RuntimeOptions): UpdateAlertContactGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupId)) {
    query['ContactGroupId'] = request.contactGroupId;
  }
  if (!Util.isUnset(request.contactGroupName)) {
    query['ContactGroupName'] = request.contactGroupName;
  }
  if (!Util.isUnset(request.contactIds)) {
    query['ContactIds'] = request.contactIds;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlertContactGroup',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAlertContactGroup(request: UpdateAlertContactGroupRequest): UpdateAlertContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAlertContactGroupWithOptions(request, runtime);
}

model UpdateAlertRuleRequest {
  alertId?: long(name='AlertId', example='1234567'),
  contactGroupIds?: string(name='ContactGroupIds', example='[123, 234]'),
  isAutoStart?: boolean(name='IsAutoStart', example='true'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  templageAlertConfig?: string(name='TemplageAlertConfig'),
}

model UpdateAlertRuleResponseBody = {
  alertId?: long(name='AlertId', example='1234567'),
  data?: string(name='Data', example='-'),
  requestId?: string(name='RequestId', example='6A9AEA84-7186-4D8D-B498-4585C6A2****'),
}

model UpdateAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAlertRuleResponseBody(name='body'),
}

async function updateAlertRuleWithOptions(request: UpdateAlertRuleRequest, runtime: Util.RuntimeOptions): UpdateAlertRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!Util.isUnset(request.contactGroupIds)) {
    query['ContactGroupIds'] = request.contactGroupIds;
  }
  if (!Util.isUnset(request.isAutoStart)) {
    query['IsAutoStart'] = request.isAutoStart;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.templageAlertConfig)) {
    query['TemplageAlertConfig'] = request.templageAlertConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlertRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAlertRule(request: UpdateAlertRuleRequest): UpdateAlertRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAlertRuleWithOptions(request, runtime);
}

model UpdateDispatchRuleRequest {
  dispatchRule?: string(name='DispatchRule', description='The dispatch rule configuration. The value is a JSON string. For more information about this parameter, see the following **additional information about the DispatchRule parameter**.', example='{   "id": 123,     "system": false,   "ruleid": 10282,   "name": "Prometheus Alert",   "labelMatchExpressionGrid": {     "labelMatchExpressionGroups": [       {         "labelMatchExpressions": [           {             "key": "_aliyun_arms_involvedObject_kind",             "value": "app",             "operator": "eq"           }         ]       }     ]   },   "dispatchType": "CREATE_ALERT/DISCARD_ALERT",   "isRecover": true,   "groupRules": [     {       "groupId": 1,       "groupingFields": [         "alertname"       ],       "groupWait": 10,       "groupInterval": 15,       "repeatInterval": 20     }   ],   "notifyRules": [     {       "notifyObjects": [         {           "notifyType": "ARMS_CONTACT",           "name": "JohnDoe",           "notifyObjectId": 1         },         {           "notifyType": "ARMS_CONTACT_GROUP",           "name": "JohnDoe_group",           "notifyObjectId": 2         }       ],       "notifyChannels":["dingTalk","wechat","webhook","email"]     },   ], }'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model UpdateDispatchRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='A5EC8221-08F2-4C95-9AF1-49FD998C****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.

*   `true`: The request was successful.
*   `false`: The request failed.', example='true'),
}

model UpdateDispatchRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDispatchRuleResponseBody(name='body'),
}

async function updateDispatchRuleWithOptions(request: UpdateDispatchRuleRequest, runtime: Util.RuntimeOptions): UpdateDispatchRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dispatchRule)) {
    query['DispatchRule'] = request.dispatchRule;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDispatchRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDispatchRule(request: UpdateDispatchRuleRequest): UpdateDispatchRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDispatchRuleWithOptions(request, runtime);
}

model UpdateIntegrationRequest {
  apiEndpoint?: string(name='ApiEndpoint', description='The endpoint of the alert integration.', example='https://alerts.aliyuncs.com/api/v1/integrations/custom/ymQBN******'),
  autoRecover?: boolean(name='AutoRecover', description='Specifies whether to automatically clear alert events. Valid values:

*   true (default)
*   false', example='true'),
  description?: string(name='Description', description='The description of the alert integration.', example='Test'),
  duplicateKey?: string(name='DuplicateKey', description='The fields whose values are deduplicated.', example='LABEL.dimensions::LABEL.ruleId'),
  extendedFieldRedefineRules?: string(name='ExtendedFieldRedefineRules', description='The extended mapped fields are mapped to the fields of ARMS alerts. For more information, see the description of the ExtendedFieldRedefineRules parameter.', example='[
    {
        "redefineType":"EXTRACT",
        "matchExpression":null,
        "fieldName":"dimensions",
        "expression":null,
        "mappingRuleList":[

        ],
        "name":"dimensions",
        "integrationId":1234,
        "jsonPath":"$.dimensions",
        "id":10013,
        "fieldType":"LABEL"
    },
    {
        "redefineType":"EXTRACT",
        "matchExpression":null,
        "fieldName":"expression",
        "expression":null,
        "mappingRuleList":[

        ],
        "name":"expression",
        "integrationId":1234,
        "jsonPath":"$.expression",
        "id":10014,
        "fieldType":"LABEL"
    }
]'),
  fieldRedefineRules?: string(name='FieldRedefineRules', description='The predefined mapped fields are mapped to the fields of ARMS alerts. The predefined mapped fields were generated when the alert integration was created. For more information, see the description of the FieldRedefineRules parameter.', example='\\[ { "redefineType":"EXTRACT", "matchExpression":null, "fieldName":"alertname", "expression":null, "mappingRuleList":\\[ ], "name":"Alert name", "integrationId":1234, "jsonPath":"$.alertName", "id":10001, "fieldType":"LABEL" }, { "redefineType":"MAP", "matchExpression":null, "fieldName":"severity", "expression":null, "mappingRuleList":\\[ { "mappingValue":"critical", "mappingName":"P1", "mappingType":"MAP", "originValue":"CRITICAL" }, { "mappingValue":"error", "mappingName":"P2", "mappingType":"MAP", "originValue":"WARN" }, { "mappingValue":"warning", "mappingName":"P3", "mappingType":"MAP", "originValue":"INFO" } ], "name":"Alert level", "integrationId":1234, "jsonPath":"$.triggerLevel", "id":10002, "fieldType":"LABEL" }, { "redefineType":"EXTRACT", "matchExpression":null, "fieldName":"message", "expression":"{{$labels.namespace}} / {{$labels.dimensions}} Alert content {{ $labels.alertname }}, Current value {{$value}}.", "mappingRuleList":\\[ ], "name":"Alert description", "integrationId":1234, "jsonPath":null, "id":10003, "fieldType":"ANNOTATION" }, { "redefineType":"EXTRACT", "matchExpression":null, "fieldName":"value", "expression":null, "mappingRuleList":\\[ ], "name":"Alert sample value", "integrationId":1234, "jsonPath":"$.curValue", "id":10004, "fieldType":"ANNOTATION" }, { "redefineType":"EXTRACT", "matchExpression":null, "fieldName":"source", "expression":null, "mappingRuleList":\\[ ], "name":"Source", "integrationId":1234, "jsonPath":null, "id":10007, "fieldType":"LABEL" }, { "redefineType":"ADD", "matchExpression":null, "fieldName":"generatorUrl", "expression":"https://cloudmonitor.console.aliyun.com/index.htm#/alarmInfo/name={{$labels.ruleId}}\\&searchValue=\\&searchType=name\\&searchProduct=/history/all/searchKey:{{$labels.ruleId}},startTime:{{sub $startsAt 300000}},endTime:{{$endsAt}}", "mappingRuleList":\\[ ], "name":"Event URL", "integrationId":1234, "jsonPath":"https://cloudmonitor.console.aliyun.com/index.htm#/alarmInfo/name={{$labels.ruleId}}\\&searchValue=\\&searchType=name\\&searchProduct=/history/all/searchKey:{{$labels.ruleId}},startTime:{{sub $startsAt 300000}},endTime:{{$endsAt}}", "id":10012, "fieldType":"GENERATE_URL" } ]'),
  initiativeRecoverField?: string(name='InitiativeRecoverField', description='The field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.

> Only the Log Service alert integration supports the parameter.', example='$.status'),
  initiativeRecoverValue?: string(name='InitiativeRecoverValue', description='The value of the field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.

> Only the Log Service alert integration supports the parameter.', example='ok'),
  integrationId?: long(name='IntegrationId', description='The ID of the alert integration.', example='1234'),
  integrationName?: string(name='IntegrationName', description='The name of the alert integration.', example='CloudMonitor integration'),
  integrationProductType?: string(name='IntegrationProductType', description='The service of the alert integration. Valid values:

*   CLOUD_MONITOR: CloudMonitor
*   LOG_SERVICE: Log Service', example='CLOUD_MONITOR'),
  liveness?: string(name='Liveness', description='The activity of the alert integration', example='ready'),
  recoverTime?: long(name='RecoverTime', description='The period of time within which alert events are automatically cleared. Unit: seconds. Default value: 300.', example='300'),
  shortToken?: string(name='ShortToken', description='The authentication token of the alert integration.', example='ymQBN******'),
  stat?: string(name='Stat', description='The total number of alert events and the number of abnormal alert events in the last hour.', example='[0,0]'),
  state?: boolean(name='State', description='Indicates whether the alert integration was enabled. Valid values:

*   true
*   false', example='true'),
}

model UpdateIntegrationResponseBody = {
  integration?: {
    apiEndpoint?: string(name='ApiEndpoint', description='The endpoint of the alert integration.', example='https://alerts.aliyuncs.com/api/v1/integrations/custom/ymQBN******'),
    autoRecover?: boolean(name='AutoRecover', description='Indicates whether alert events are automatically cleared. Valid values:

*   true (default)
*   false', example='true'),
    description?: string(name='Description', description='The description of the alert integration.', example='Test'),
    duplicateKey?: string(name='DuplicateKey', description='The fields whose values are deduplicated.', example='LABEL.dimensions::LABEL.ruleId'),
    extendedFieldRedefineRules?: [  map[string]any ](name='ExtendedFieldRedefineRules', description='The extended mapped fields of the alert source.'),
    fieldRedefineRules?: [  map[string]any ](name='FieldRedefineRules', description='The predefined mapped fields of the alert source.'),
    initiativeRecoverField?: string(name='InitiativeRecoverField', description='The field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.

> Only Log Service supports this parameter.', example='$.status'),
    initiativeRecoverValue?: string(name='InitiativeRecoverValue', description='The value of the field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.

> Only Log Service supports this parameter.', example='ok'),
    integrationId?: long(name='IntegrationId', description='The ID of the alert integration.', example='1234'),
    integrationName?: string(name='IntegrationName', description='The name of the alert integration.', example='CloudMonitor integration'),
    integrationProductType?: string(name='IntegrationProductType', description='The service of the alert integration. Valid values:

*   CLOUD_MONITOR: CloudMonitor
*   LOG_SERVICE: Log Service', example='CLOUD_MONITOR'),
    liveness?: string(name='Liveness', description='The activity of the alert integration', example='ready'),
    recoverTime?: long(name='RecoverTime', description='The period of time within which alert events are automatically cleared. Unit: seconds. Default value: 300.', example='300'),
    shortToken?: string(name='ShortToken', description='The authentication token of the alert integration.', example='ymQBN******'),
    stat?: [ long ](name='Stat', description='The total number of alert events and the number of abnormal alert events in the last hour.'),
    state?: boolean(name='State', description='Indicates whether the alert integration is enabled. Valid values:

*   true
*   false', example='true'),
  }(name='Integration', description='The Information about the alert integration.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='34ED024E-9E31-434A-9E4E-D9D15C3****'),
}

model UpdateIntegrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIntegrationResponseBody(name='body'),
}

async function updateIntegrationWithOptions(request: UpdateIntegrationRequest, runtime: Util.RuntimeOptions): UpdateIntegrationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apiEndpoint)) {
    body['ApiEndpoint'] = request.apiEndpoint;
  }
  if (!Util.isUnset(request.autoRecover)) {
    body['AutoRecover'] = request.autoRecover;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.duplicateKey)) {
    body['DuplicateKey'] = request.duplicateKey;
  }
  if (!Util.isUnset(request.extendedFieldRedefineRules)) {
    body['ExtendedFieldRedefineRules'] = request.extendedFieldRedefineRules;
  }
  if (!Util.isUnset(request.fieldRedefineRules)) {
    body['FieldRedefineRules'] = request.fieldRedefineRules;
  }
  if (!Util.isUnset(request.initiativeRecoverField)) {
    body['InitiativeRecoverField'] = request.initiativeRecoverField;
  }
  if (!Util.isUnset(request.initiativeRecoverValue)) {
    body['InitiativeRecoverValue'] = request.initiativeRecoverValue;
  }
  if (!Util.isUnset(request.integrationId)) {
    body['IntegrationId'] = request.integrationId;
  }
  if (!Util.isUnset(request.integrationName)) {
    body['IntegrationName'] = request.integrationName;
  }
  if (!Util.isUnset(request.integrationProductType)) {
    body['IntegrationProductType'] = request.integrationProductType;
  }
  if (!Util.isUnset(request.liveness)) {
    body['Liveness'] = request.liveness;
  }
  if (!Util.isUnset(request.recoverTime)) {
    body['RecoverTime'] = request.recoverTime;
  }
  if (!Util.isUnset(request.shortToken)) {
    body['ShortToken'] = request.shortToken;
  }
  if (!Util.isUnset(request.stat)) {
    body['Stat'] = request.stat;
  }
  if (!Util.isUnset(request.state)) {
    body['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIntegration',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateIntegration(request: UpdateIntegrationRequest): UpdateIntegrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIntegrationWithOptions(request, runtime);
}

model UpdatePrometheusAlertRuleRequest {
  alertId?: long(name='AlertId', example='3888704'),
  alertName?: string(name='AlertName', example='Prometheus_Alert'),
  annotations?: string(name='Annotations', example='[{"Value": "xxx","Name": "description"}]'),
  clusterId?: string(name='ClusterId', example='c0bad479465464e1d8c1e641b0afb****'),
  dispatchRuleId?: long(name='DispatchRuleId', example='10282'),
  duration?: string(name='Duration', example='1'),
  expression?: string(name='Expression', example='100 * (sum(rate(container_cpu_usage_seconds_total[1m])) by (pod_name) / sum(label_replace(kube_pod_container_resource_limits_cpu_cores, \\"pod_name\\", \\"$1\\", \\"pod\\", \\"(.*)\\")) by (pod_name))>75'),
  labels?: string(name='Labels', example='[{"Value": "critical","Name": "severity"}]'),
  message?: string(name='Message'),
  notifyType?: string(name='NotifyType', example='ALERT_MANAGER'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  type?: string(name='Type'),
}

model UpdatePrometheusAlertRuleResponseBody = {
  prometheusAlertRule?: {
    alertId?: long(name='AlertId', example='3888704'),
    alertName?: string(name='AlertName', example='Prometheus_Alert'),
    annotations?: [ 
      {
        name?: string(name='Name', example='message'),
        value?: string(name='Value'),
      }
    ](name='Annotations'),
    clusterId?: string(name='ClusterId', example='c0bad479465464e1d8c1e641b0afb****'),
    dispatchRuleId?: long(name='DispatchRuleId', example='10282'),
    duration?: string(name='Duration', example='1'),
    expression?: string(name='Expression', example='100 * (sum(rate(container_cpu_usage_seconds_total[1m])) by (pod_name) / sum(label_replace(kube_pod_container_resource_limits_cpu_cores, \\"pod_name\\", \\"$1\\", \\"pod\\", \\"(.*)\\")) by (pod_name))>75'),
    labels?: [ 
      {
        name?: string(name='Name', example='severity'),
        value?: string(name='Value', example='critical'),
      }
    ](name='Labels'),
    message?: string(name='Message'),
    notifyType?: string(name='NotifyType', example='ALERT_MANAGER'),
    status?: int32(name='Status', example='1'),
    type?: string(name='Type'),
  }(name='PrometheusAlertRule'),
  requestId?: string(name='RequestId', example='9FEA6D00-317F-45E3-9004-7FB8B0B7****'),
}

model UpdatePrometheusAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePrometheusAlertRuleResponseBody(name='body'),
}

async function updatePrometheusAlertRuleWithOptions(request: UpdatePrometheusAlertRuleRequest, runtime: Util.RuntimeOptions): UpdatePrometheusAlertRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!Util.isUnset(request.alertName)) {
    query['AlertName'] = request.alertName;
  }
  if (!Util.isUnset(request.annotations)) {
    query['Annotations'] = request.annotations;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dispatchRuleId)) {
    query['DispatchRuleId'] = request.dispatchRuleId;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.expression)) {
    query['Expression'] = request.expression;
  }
  if (!Util.isUnset(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  if (!Util.isUnset(request.notifyType)) {
    query['NotifyType'] = request.notifyType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePrometheusAlertRule',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePrometheusAlertRule(request: UpdatePrometheusAlertRuleRequest): UpdatePrometheusAlertRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePrometheusAlertRuleWithOptions(request, runtime);
}

model UpdateWebhookRequest {
  body?: string(name='Body', description='The notification template that is sent when an alert is triggered. This parameter is required if the **Method** parameter is set to **Post**. You can use the $content placeholder to specify the notification content. The content cannot exceed 500 characters in length.'),
  contactId?: long(name='ContactId', description='The ID of the contact for webhook alerts.', example='48716'),
  contactName?: string(name='ContactName', description='The name of the contact.'),
  httpHeaders?: string(name='HttpHeaders', description='The header of the HTTP request.', example='[{"Content-Type":"application/json"}]'),
  httpParams?: string(name='HttpParams', description='The parameters in the HTTP request.', example='[{"name":"mike"}]'),
  method?: string(name='Method', description='The HTTP request method. Valid values:

*   `Get`
*   `Post`', example='Post'),
  recoverBody?: string(name='RecoverBody', description='The notification template that is sent when an alert is resolved. This parameter is required if the **Method** parameter is set to **Post**. You can use the $content placeholder to specify the notification content. The content cannot exceed 500 characters in length.'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  url?: string(name='Url', description='The URL of the request method.', example='https://oapi.dingtalk.com/robot/send?access_token=e1a049121ddbfce1ca963d115ef88cc7219583c4fb79fe6e398fbfb688******'),
}

model UpdateWebhookResponseBody = {
  isSuccess?: boolean(name='IsSuccess', description='The result of the request. Valid values:

*   `true`: The request was successful.
*   `false`: The request failed.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='16AF921B-8187-489F-9913-43C808B4****'),
}

model UpdateWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateWebhookResponseBody(name='body'),
}

async function updateWebhookWithOptions(request: UpdateWebhookRequest, runtime: Util.RuntimeOptions): UpdateWebhookResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.body)) {
    query['Body'] = request.body;
  }
  if (!Util.isUnset(request.contactId)) {
    query['ContactId'] = request.contactId;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.httpHeaders)) {
    query['HttpHeaders'] = request.httpHeaders;
  }
  if (!Util.isUnset(request.httpParams)) {
    query['HttpParams'] = request.httpParams;
  }
  if (!Util.isUnset(request.method)) {
    query['Method'] = request.method;
  }
  if (!Util.isUnset(request.recoverBody)) {
    query['RecoverBody'] = request.recoverBody;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.url)) {
    query['Url'] = request.url;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWebhook',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateWebhook(request: UpdateWebhookRequest): UpdateWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWebhookWithOptions(request, runtime);
}

model UploadRequest {
  edition?: string(name='Edition', description='The version of the SourceMap file.', example='0.0.0'),
  file?: string(name='File', description='The content of the SourceMap file.', example='test file content'),
  fileName?: string(name='FileName', description='The name of the SourceMap file.', example='test.js.map'),
  pid?: string(name='Pid', description='The ID of the application.

Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is eb4zdose6v%409781be0f44d\\*\\*\\*\\*, you must replace %40 with @ to obtain eb4zdose6v@9781be0f44d\\*\\*\\*\\*.', example='b590lhguqs@8cc3f6354******'),
  regionId?: string(name='RegionId', description='The ID of the region to which the SourceMap file is uploaded.', example='cn-hangzhou'),
  version?: string(name='Version', description='We recommend that you do not specify this parameter.', example='null'),
}

model UploadResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='A5EC8221-08F2-4C95-9AF1-49FD998C****'),
  uploadResult?: {
    fid?: string(name='Fid', description='The ID of the SourceMap file.', example='123'),
    fileName?: string(name='FileName', description='The name of the SourceMap file.', example='test.js.map'),
    uploadTime?: string(name='UploadTime', description='The time when the file was uploaded.', example='1650272251'),
  }(name='UploadResult', description='The returned data.'),
}

model UploadResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadResponseBody(name='body'),
}

async function uploadWithOptions(request: UploadRequest, runtime: Util.RuntimeOptions): UploadResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.edition)) {
    query['Edition'] = request.edition;
  }
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.file)) {
    body['File'] = request.file;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'Upload',
    version = '2019-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upload(request: UploadRequest): UploadResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadWithOptions(request, runtime);
}

