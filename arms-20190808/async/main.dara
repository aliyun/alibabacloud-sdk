/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'ARMS';
  @version = '2019-08-08';
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'arms.aliyuncs.com',
    cn-beijing-finance-1 = 'arms.aliyuncs.com',
    cn-beijing-finance-pop = 'arms.aliyuncs.com',
    cn-beijing-gov-1 = 'arms.aliyuncs.com',
    cn-beijing-nu16-b01 = 'arms.aliyuncs.com',
    cn-edge-1 = 'arms.aliyuncs.com',
    cn-fujian = 'arms.aliyuncs.com',
    cn-haidian-cm12-c01 = 'arms.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'arms.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'arms.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'arms.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'arms.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'arms.aliyuncs.com',
    cn-hangzhou-test-306 = 'arms.aliyuncs.com',
    cn-hongkong-finance-pop = 'arms.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'arms.aliyuncs.com',
    cn-qingdao-nebula = 'arms.aliyuncs.com',
    cn-shanghai-et15-b01 = 'arms.aliyuncs.com',
    cn-shanghai-et2-b01 = 'arms.aliyuncs.com',
    cn-shanghai-inner = 'arms.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'arms.aliyuncs.com',
    cn-shenzhen-inner = 'arms.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'arms.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'arms.aliyuncs.com',
    cn-wuhan = 'arms.aliyuncs.com',
    cn-yushanfang = 'arms.aliyuncs.com',
    cn-zhangbei = 'arms.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'arms.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'arms.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'arms.aliyuncs.com',
    eu-west-1-oxs = 'arms.aliyuncs.com',
    me-east-1 = 'arms.aliyuncs.com',
    rus-west-1-pop = 'arms.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model AddASMIntegrationRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model AddASMIntegrationResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  state?: boolean(name='State'),
}

model AddASMIntegrationResponse = {
  headers: map[string]string(name='headers'),
  body: AddASMIntegrationResponseBody(name='body'),
}

async function addASMIntegration(request: AddASMIntegrationRequest): AddASMIntegrationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddASMIntegration', 'POST', '/', 'json', false, 'json', request);
}

model AddGrafanaRequest {
  clusterId: string(name='ClusterId', position='Query'),
  integration: string(name='Integration', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model AddGrafanaResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddGrafanaResponse = {
  headers: map[string]string(name='headers'),
  body: AddGrafanaResponseBody(name='body'),
}

async function addGrafana(request: AddGrafanaRequest): AddGrafanaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddGrafana', 'POST', '/', 'json', false, 'json', request);
}

model AddIntegrationRequest {
  clusterId: string(name='ClusterId', position='Query'),
  integration: string(name='Integration', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model AddIntegrationResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddIntegrationResponse = {
  headers: map[string]string(name='headers'),
  body: AddIntegrationResponseBody(name='body'),
}

async function addIntegration(request: AddIntegrationRequest): AddIntegrationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddIntegration', 'POST', '/', 'json', false, 'json', request);
}

model AddRecordingRuleRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  ruleYaml: string(name='RuleYaml', position='Query'),
}

model AddRecordingRuleResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AddRecordingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: AddRecordingRuleResponseBody(name='body'),
}

async function addRecordingRule(request: AddRecordingRuleRequest): AddRecordingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddRecordingRule', 'POST', '/', 'json', false, 'json', request);
}

model ApplyScenarioRequest {
  appId: string(name='AppId', position='Query'),
  config: map[string]any(name='Config', position='Query'),
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  scenario?: string(name='Scenario', position='Query'),
  sign?: string(name='Sign', position='Query'),
  snDump?: boolean(name='SnDump', position='Query'),
  snForce?: boolean(name='SnForce', position='Query'),
  snStat?: boolean(name='SnStat', position='Query'),
  snTransfer?: boolean(name='SnTransfer', position='Query'),
  updateOption: boolean(name='UpdateOption', position='Query'),
}

model ApplyScenarioResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model ApplyScenarioResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyScenarioResponseBody(name='body'),
}

async function applyScenario(request: ApplyScenarioRequest): ApplyScenarioResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ApplyScenario', 'POST', '/', 'json', false, 'json', request);
}

model CMonitorAlertEventRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  kind?: string(name='Kind', position='Query'),
  name?: string(name='Name', position='Query'),
  namespace?: string(name='Namespace', position='Query'),
  page?: string(name='Page', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  proxyUserId?: string(name='ProxyUserId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
}

model CMonitorAlertEventResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CMonitorAlertEventResponse = {
  headers: map[string]string(name='headers'),
  body: CMonitorAlertEventResponseBody(name='body'),
}

async function cMonitorAlertEvent(request: CMonitorAlertEventRequest): CMonitorAlertEventResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CMonitorAlertEvent', 'GET', '/', 'json', false, 'json', request);
}

model CheckServiceStatusRequest {
  regionId?: string(name='RegionId', position='Query'),
  svcCode: string(name='SvcCode', position='Query'),
}

model CheckServiceStatusResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model CheckServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: CheckServiceStatusResponseBody(name='body'),
}

async function checkServiceStatus(request: CheckServiceStatusRequest): CheckServiceStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckServiceStatus', 'POST', '/', 'json', false, 'json', request);
}

model ConfigAppRequest {
  appIds: string(name='AppIds', position='Query'),
  enable?: string(name='Enable', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ConfigAppResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ConfigAppResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigAppResponseBody(name='body'),
}

async function configApp(request: ConfigAppRequest): ConfigAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfigApp', 'POST', '/', 'json', false, 'json', request);
}

model CreateAlertContactRequest {
  contactName?: string(name='ContactName', position='Query'),
  dingRobotWebhookUrl?: string(name='DingRobotWebhookUrl', position='Query'),
  email?: string(name='Email', position='Query'),
  phoneNum?: string(name='PhoneNum', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  systemNoc?: boolean(name='SystemNoc', position='Query'),
}

model CreateAlertContactResponseBody = {
  contactId?: string(name='ContactId'),
  requestId?: string(name='RequestId'),
}

model CreateAlertContactResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAlertContactResponseBody(name='body'),
}

async function createAlertContact(request: CreateAlertContactRequest): CreateAlertContactResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAlertContact', 'POST', '/', 'json', false, 'json', request);
}

model CreateAlertContactGroupRequest {
  contactGroupName: string(name='ContactGroupName', position='Query'),
  contactIds?: string(name='ContactIds', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CreateAlertContactGroupResponseBody = {
  contactGroupId?: string(name='ContactGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateAlertContactGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAlertContactGroupResponseBody(name='body'),
}

async function createAlertContactGroup(request: CreateAlertContactGroupRequest): CreateAlertContactGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAlertContactGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateDispatchRuleRequest {
  dispatchRule: string(name='DispatchRule', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CreateDispatchRuleResponseBody = {
  dispatchRuleId?: long(name='DispatchRuleId'),
  requestId?: string(name='RequestId'),
}

model CreateDispatchRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDispatchRuleResponseBody(name='body'),
}

async function createDispatchRule(request: CreateDispatchRuleRequest): CreateDispatchRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDispatchRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateOrUpdateAlertRuleRequest {
  alertCheckType?: string(name='AlertCheckType', position='Body'),
  alertGroup?: long(name='AlertGroup', position='Body'),
  alertId?: long(name='AlertId', description='告警规则ID', position='Body'),
  alertName: string(name='AlertName', description='告警规则名称', position='Body'),
  alertRuleContent?: string(name='AlertRuleContent', position='Body'),
  alertStatus?: string(name='AlertStatus', position='Body'),
  alertType: string(name='AlertType', description='告警规则类型', position='Body'),
  annotations?: string(name='Annotations', position='Body'),
  autoAddNewApplication?: boolean(name='AutoAddNewApplication', position='Body'),
  clusterId?: string(name='ClusterId', position='Body'),
  duration?: long(name='Duration', position='Body'),
  filters?: string(name='Filters', position='Body'),
  labels?: string(name='Labels', position='Body'),
  level?: string(name='Level', position='Body'),
  message?: string(name='Message', position='Body'),
  metricsKey?: string(name='MetricsKey', position='Body'),
  metricsType?: string(name='MetricsType', position='Body'),
  notifyStrategy?: string(name='NotifyStrategy', position='Body'),
  pids?: string(name='Pids', position='Body'),
  promQL?: string(name='PromQL', position='Body'),
  regionId: string(name='RegionId', description='地域', position='Body'),
}

model CreateOrUpdateAlertRuleResponseBody = {
  alertRule?: {
    alertCheckType?: string(name='AlertCheckType', description='Prometheus告警-告警检查类型'),
    alertGroup?: long(name='AlertGroup', description='Prometheus告警-告警分组ID'),
    alertId?: float(name='AlertId', description='告警规则ID'),
    alertName?: string(name='AlertName', description='告警规则名称'),
    alertRuleContent?: {
      alertRuleItems?: [ 
        {
          aggregate?: string(name='Aggregate', description='应用监控/前端监控-聚合方式'),
          metricKey?: string(name='MetricKey', description='应用监控/前端监控-具体告警条件的指标'),
          n?: float(name='N', description='应用监控/前端监控-最近N分钟'),
          operator?: string(name='Operator', description='应用监控/前端监控-判断条件'),
          value?: string(name='Value', description='应用监控/前端监控-阈值'),
        }
      ](name='AlertRuleItems', description='应用监控/前端监控-告警条件'),
      condition?: string(name='Condition', description='应用监控/前端监控-多个告警条件触发逻辑'),
    }(name='AlertRuleContent', description='应用监控/前端监控-告警规则内容'),
    alertStatus?: string(name='AlertStatus', description='告警规则状态'),
    alertType?: string(name='AlertType', description='告警规则类型'),
    annotations?: [ 
      {
        name?: string(name='Name', description='键'),
        value?: string(name='Value', description='值'),
      }
    ](name='Annotations', description='Prometheus告警-Annotation'),
    autoAddNewApplication?: boolean(name='AutoAddNewApplication', description='应用监控/前端监控-是否开启新创建应用追加到此告警规则'),
    clusterId?: string(name='ClusterId', description='Prometheus告警-集群ID'),
    createdTime?: long(name='CreatedTime', description='创建时间'),
    duration?: string(name='Duration', description='Prometheus告警-持续时间'),
    extend?: string(name='Extend', description='扩展字段'),
    filters?: {
      customSLSFilters?: [ 
        {
          key?: string(name='Key'),
          opt?: string(name='Opt'),
          show?: boolean(name='Show'),
          t?: string(name='T'),
          value?: string(name='Value'),
        }
      ](name='CustomSLSFilters'),
      customSLSGroupByDimensions?: [ string ](name='CustomSLSGroupByDimensions'),
      customSLSWheres?: [ string ](name='CustomSLSWheres'),
      dimFilters?: [ 
        {
          filterKey?: string(name='FilterKey'),
          filterOpt?: string(name='FilterOpt'),
          filterValues?: [ string ](name='FilterValues'),
        }
      ](name='DimFilters'),
    }(name='Filters', description='应用监控/前端监控-告警条件-过滤项'),
    labels?: [ 
      {
        name?: string(name='Name', description='键'),
        value?: string(name='Value', description='值'),
      }
    ](name='Labels', description='Prometheus告警-Label'),
    level?: string(name='Level', description='Prometheus告警-等级'),
    message?: string(name='Message', description='Prometheus告警-告警内容'),
    metricsType?: string(name='MetricsType', description='应用监控/前端监控-告警指标类型'),
    notifyStrategy?: string(name='NotifyStrategy', description='通知策略ID'),
    pids?: [ string ](name='Pids', description='应用监控/前端监控-告警关联应用ID'),
    promQL?: string(name='PromQL', description='Prometheus告警-PromQL语句'),
    regionId?: string(name='RegionId', description='地域'),
    updatedTime?: long(name='UpdatedTime', description='更新时间'),
    userId?: string(name='UserId', description='用户UID'),
  }(name='AlertRule'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateOrUpdateAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOrUpdateAlertRuleResponseBody(name='body'),
}

async function createOrUpdateAlertRule(request: CreateOrUpdateAlertRuleRequest): CreateOrUpdateAlertRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOrUpdateAlertRule', 'POST', '/', 'json', true, 'form', request);
}

model CreateOrUpdateContactRequest {
  contactId?: long(name='ContactId', description='告警联系人ID', position='Body'),
  contactName: string(name='ContactName', description='告警联系人名称', position='Body'),
  email?: string(name='Email', description='告警联系人邮箱', position='Body'),
  phone?: string(name='Phone', description='告警联系人手机号码', position='Body'),
}

model CreateOrUpdateContactResponseBody = {
  alertContact?: {
    contactId?: float(name='ContactId', description='告警联系人ID'),
    contactName?: string(name='ContactName', description='告警联系人名称'),
    email?: string(name='Email', description='告警联系人邮箱'),
    isVerify?: boolean(name='IsVerify', description='手机号码验证标识'),
    phone?: string(name='Phone', description='告警联系人手机号'),
  }(name='AlertContact'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateOrUpdateContactResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOrUpdateContactResponseBody(name='body'),
}

async function createOrUpdateContact(request: CreateOrUpdateContactRequest): CreateOrUpdateContactResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOrUpdateContact', 'POST', '/', 'json', true, 'form', request);
}

model CreateOrUpdateContactGroupRequest {
  contactGroupId?: long(name='ContactGroupId', description='告警联系人组ID', position='Body'),
  contactGroupName: string(name='ContactGroupName', description='告警联系人组名称', position='Body'),
  contactIds?: string(name='ContactIds', description='告警联系人ids', position='Body'),
}

model CreateOrUpdateContactGroupResponseBody = {
  alertContactGroup?: {
    contactGroupId?: float(name='ContactGroupId', description='告警联系人组ID'),
    contactGroupName?: string(name='ContactGroupName', description='告警联系人组名称'),
    contactIds?: string(name='ContactIds', description='告警联系人ids'),
  }(name='AlertContactGroup'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateOrUpdateContactGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOrUpdateContactGroupResponseBody(name='body'),
}

async function createOrUpdateContactGroup(request: CreateOrUpdateContactGroupRequest): CreateOrUpdateContactGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOrUpdateContactGroup', 'POST', '/', 'json', true, 'form', request);
}

model CreateOrUpdateIMRobotRequest {
  dailyNoc?: boolean(name='DailyNoc', description='是否发送每日统计信息', position='Body'),
  dailyNocTime?: string(name='DailyNocTime', description='每日统计发送时间', position='Body'),
  robotAddress: string(name='RobotAddress', description='告警机器人地址', position='Body'),
  robotId?: long(name='RobotId', description='告警机器人ID', position='Body'),
  robotName: string(name='RobotName', description='告警机器人名称', position='Body'),
  type: string(name='Type', description='告警机器人类型:dingding/wechat', position='Body'),
}

model CreateOrUpdateIMRobotResponseBody = {
  alertRobot?: {
    dailyNoc?: boolean(name='DailyNoc', description='是否发送每日统计信息'),
    dailyNocTime?: string(name='DailyNocTime', description='每日统计发送时间'),
    robotAddress?: string(name='RobotAddress', description='告警机器人地址'),
    robotId?: float(name='RobotId', description='告警机器人ID'),
    robotName?: string(name='RobotName', description='告警机器人名称'),
    type?: string(name='Type', description='告警机器人类型:dingding/wechat'),
  }(name='AlertRobot'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateOrUpdateIMRobotResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOrUpdateIMRobotResponseBody(name='body'),
}

async function createOrUpdateIMRobot(request: CreateOrUpdateIMRobotRequest): CreateOrUpdateIMRobotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOrUpdateIMRobot', 'POST', '/', 'json', true, 'form', request);
}

model CreateOrUpdateWebhookContactRequest {
  bizHeaders?: string(name='BizHeaders', description='http请求头', position='Body'),
  bizParams?: string(name='BizParams', description='http请求参数', position='Body'),
  body: string(name='Body', description='告警通知模板', position='Body'),
  method: string(name='Method', description='Http请求方法', position='Body'),
  recoverBody: string(name='RecoverBody', description='告警恢复模板', position='Body'),
  url: string(name='Url', description='Url', position='Body'),
  webhookId?: long(name='WebhookId', description='告警webhook ID', position='Body'),
  webhookName: string(name='WebhookName', description='告警webhook名称', position='Body'),
}

model CreateOrUpdateWebhookContactResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  webhookContact?: {
    webhook?: {
      bizHeaders?: string(name='BizHeaders', description='http请求头'),
      bizParams?: string(name='BizParams', description='http请求参数'),
      body?: string(name='Body', description='告警通知模板'),
      method?: string(name='Method', description='Http请求方法'),
      recoverBody?: string(name='RecoverBody', description='告警恢复模板'),
      url?: string(name='Url', description='url'),
    }(name='Webhook'),
    webhookId?: float(name='WebhookId', description='告警webhook ID'),
    webhookName?: string(name='WebhookName', description='告警webhook名称'),
  }(name='WebhookContact'),
}

model CreateOrUpdateWebhookContactResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOrUpdateWebhookContactResponseBody(name='body'),
}

async function createOrUpdateWebhookContact(request: CreateOrUpdateWebhookContactRequest): CreateOrUpdateWebhookContactResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOrUpdateWebhookContact', 'POST', '/', 'json', true, 'form', request);
}

model CreatePrometheusAlertRuleRequest {
  alertName: string(name='AlertName', position='Query'),
  annotations?: string(name='Annotations', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  dispatchRuleId?: long(name='DispatchRuleId', position='Query'),
  duration: string(name='Duration', position='Query'),
  expression: string(name='Expression', position='Query'),
  labels?: string(name='Labels', position='Query'),
  message: string(name='Message', position='Query'),
  notifyType?: string(name='NotifyType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type?: string(name='Type', position='Query'),
}

model CreatePrometheusAlertRuleResponseBody = {
  prometheusAlertRule?: {
    alertId?: long(name='AlertId'),
    alertName?: string(name='AlertName'),
    annotations?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Annotations'),
    clusterId?: string(name='ClusterId'),
    dispatchRuleId?: long(name='DispatchRuleId'),
    duration?: string(name='Duration'),
    expression?: string(name='Expression'),
    labels?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Labels'),
    message?: string(name='Message'),
    notifyType?: string(name='NotifyType'),
    status?: int32(name='Status'),
    type?: string(name='Type'),
  }(name='PrometheusAlertRule'),
  requestId?: string(name='RequestId'),
}

model CreatePrometheusAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePrometheusAlertRuleResponseBody(name='body'),
}

async function createPrometheusAlertRule(request: CreatePrometheusAlertRuleRequest): CreatePrometheusAlertRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePrometheusAlertRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateRetcodeAppRequest {
  regionId: string(name='RegionId', position='Query'),
  retcodeAppName: string(name='RetcodeAppName', position='Query'),
  retcodeAppType: string(name='RetcodeAppType', position='Query'),
}

model CreateRetcodeAppResponseBody = {
  requestId?: string(name='RequestId'),
  retcodeAppDataBean?: {
    appId?: long(name='AppId'),
    pid?: string(name='Pid'),
  }(name='RetcodeAppDataBean'),
}

model CreateRetcodeAppResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRetcodeAppResponseBody(name='body'),
}

async function createRetcodeApp(request: CreateRetcodeAppRequest): CreateRetcodeAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRetcodeApp', 'POST', '/', 'json', false, 'json', request);
}

model CreateWebhookRequest {
  body?: string(name='Body', position='Query'),
  contactName: string(name='ContactName', position='Query'),
  httpHeaders?: string(name='HttpHeaders', position='Query'),
  httpParams?: string(name='HttpParams', position='Query'),
  method?: string(name='Method', position='Query'),
  recoverBody?: string(name='RecoverBody', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  url: string(name='Url', position='Query'),
}

model CreateWebhookResponseBody = {
  contactId?: string(name='ContactId'),
  requestId?: string(name='RequestId'),
}

model CreateWebhookResponse = {
  headers: map[string]string(name='headers'),
  body: CreateWebhookResponseBody(name='body'),
}

async function createWebhook(request: CreateWebhookRequest): CreateWebhookResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateWebhook', 'POST', '/', 'json', false, 'json', request);
}

model DeleteASMIntegrationRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteASMIntegrationResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  state?: boolean(name='State'),
}

model DeleteASMIntegrationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteASMIntegrationResponseBody(name='body'),
}

async function deleteASMIntegration(request: DeleteASMIntegrationRequest): DeleteASMIntegrationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteASMIntegration', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAlertContactRequest {
  contactId: long(name='ContactId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteAlertContactResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteAlertContactResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAlertContactResponseBody(name='body'),
}

async function deleteAlertContact(request: DeleteAlertContactRequest): DeleteAlertContactResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAlertContact', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAlertContactGroupRequest {
  contactGroupId: long(name='ContactGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteAlertContactGroupResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteAlertContactGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAlertContactGroupResponseBody(name='body'),
}

async function deleteAlertContactGroup(request: DeleteAlertContactGroupRequest): DeleteAlertContactGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAlertContactGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAlertRuleRequest {
  alertId: long(name='AlertId', description='告警规则ID', position='Query'),
}

model DeleteAlertRuleResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAlertRuleResponseBody(name='body'),
}

async function deleteAlertRule(request: DeleteAlertRuleRequest): DeleteAlertRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAlertRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAlertRulesRequest {
  alertIds: string(name='AlertIds', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteAlertRulesResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAlertRulesResponseBody(name='body'),
}

async function deleteAlertRules(request: DeleteAlertRulesRequest): DeleteAlertRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAlertRules', 'POST', '/', 'json', false, 'json', request);
}

model DeleteContactRequest {
  contactId: long(name='ContactId', description='告警联系人ID', position='Query'),
}

model DeleteContactResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteContactResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteContactResponseBody(name='body'),
}

async function deleteContact(request: DeleteContactRequest): DeleteContactResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteContact', 'POST', '/', 'json', false, 'json', request);
}

model DeleteContactGroupRequest {
  contactGroupId: long(name='ContactGroupId', description='告警联系人组ID', position='Query'),
}

model DeleteContactGroupResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteContactGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteContactGroupResponseBody(name='body'),
}

async function deleteContactGroup(request: DeleteContactGroupRequest): DeleteContactGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteContactGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDispatchRuleRequest {
  id: string(name='Id', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteDispatchRuleResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDispatchRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDispatchRuleResponseBody(name='body'),
}

async function deleteDispatchRule(request: DeleteDispatchRuleRequest): DeleteDispatchRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDispatchRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIMRobotRequest {
  robotId: long(name='RobotId', description='告警机器人ID', position='Query'),
}

model DeleteIMRobotResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteIMRobotResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIMRobotResponseBody(name='body'),
}

async function deleteIMRobot(request: DeleteIMRobotRequest): DeleteIMRobotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIMRobot', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIntegrationRequest {
  clusterId: string(name='ClusterId', position='Query'),
  integration: string(name='Integration', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteIntegrationResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteIntegrationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIntegrationResponseBody(name='body'),
}

async function deleteIntegration(request: DeleteIntegrationRequest): DeleteIntegrationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIntegration', 'POST', '/', 'json', false, 'json', request);
}

model DeletePrometheusAlertRuleRequest {
  alertId: long(name='AlertId', minimum=0, position='Query'),
}

model DeletePrometheusAlertRuleResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeletePrometheusAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePrometheusAlertRuleResponseBody(name='body'),
}

async function deletePrometheusAlertRule(request: DeletePrometheusAlertRuleRequest): DeletePrometheusAlertRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePrometheusAlertRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteRetcodeAppRequest {
  appId: string(name='AppId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteRetcodeAppResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteRetcodeAppResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRetcodeAppResponseBody(name='body'),
}

async function deleteRetcodeApp(request: DeleteRetcodeAppRequest): DeleteRetcodeAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRetcodeApp', 'POST', '/', 'json', false, 'json', request);
}

model DeleteScenarioRequest {
  regionId?: string(name='RegionId', position='Query'),
  scenarioId: long(name='ScenarioId', minimum=1, position='Query'),
}

model DeleteScenarioResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteScenarioResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteScenarioResponseBody(name='body'),
}

async function deleteScenario(request: DeleteScenarioRequest): DeleteScenarioResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteScenario', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTraceAppRequest {
  appId?: string(name='AppId', position='Query'),
  pid: string(name='Pid', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
}

model DeleteTraceAppResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteTraceAppResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTraceAppResponseBody(name='body'),
}

async function deleteTraceApp(request: DeleteTraceAppRequest): DeleteTraceAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTraceApp', 'POST', '/', 'json', false, 'json', request);
}

model DeleteWebhookContactRequest {
  webhookId: long(name='WebhookId', description='告警webhookID', position='Query'),
}

model DeleteWebhookContactResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteWebhookContactResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteWebhookContactResponseBody(name='body'),
}

async function deleteWebhookContact(request: DeleteWebhookContactRequest): DeleteWebhookContactResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWebhookContact', 'POST', '/', 'json', false, 'json', request);
}

model DescribeContactGroupsRequest {
  contactGroupName?: string(name='ContactGroupName', description='告警联系人组名称', position='Query'),
  isDetail?: boolean(name='IsDetail', description='是否返回联系人分组中包含的所有联系人。默认不返回所有联系人。', position='Query'),
  page: long(name='Page', position='Query'),
  size: long(name='Size', position='Query'),
}

model DescribeContactGroupsResponseBody = {
  pageBean?: {
    alertContactGroups?: [ 
      {
        contactGroupId?: float(name='ContactGroupId', description='告警联系人组ID'),
        contactGroupName?: string(name='ContactGroupName', description='告警联系人组名称'),
        contacts?: [ 
          {
            contactId?: float(name='ContactId', description='联系人ID'),
            contactName?: string(name='ContactName', description='联系人名称'),
            email?: string(name='Email', description='联系人邮箱'),
            phone?: string(name='Phone', description='联系人手机号码'),
          }
        ](name='Contacts', description='联系人对象'),
      }
    ](name='AlertContactGroups', description='告警联系人组列表'),
    page?: long(name='Page', description='页数'),
    size?: long(name='Size', description='每一页数目'),
    total?: long(name='Total', description='总数'),
  }(name='PageBean', description='分页对象'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DescribeContactGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeContactGroupsResponseBody(name='body'),
}

async function describeContactGroups(request: DescribeContactGroupsRequest): DescribeContactGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeContactGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeContactsRequest {
  contactName?: string(name='ContactName', description='告警联系人名称', position='Query'),
  email?: string(name='Email', description='告警联系人邮箱', position='Query'),
  page: long(name='Page', position='Query'),
  phone?: string(name='Phone', description='告警联系人手机号码', position='Query'),
  size: long(name='Size', position='Query'),
}

model DescribeContactsResponseBody = {
  pageBean?: {
    alertContacts?: [ 
      {
        contactId?: float(name='ContactId', description='告警联系人ID'),
        contactName?: string(name='ContactName', description='告警联系人名称'),
        email?: string(name='Email', description='告警联系人邮箱'),
        isVerify?: boolean(name='IsVerify', description='手机号码是否验证标识'),
        phone?: string(name='Phone', description='告警联系人手机号码'),
      }
    ](name='AlertContacts', description='告警联系人列表'),
    page?: long(name='Page', description='页数'),
    size?: long(name='Size', description='每一页大小'),
    total?: long(name='Total', description='总数'),
  }(name='PageBean', description='分页对象'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DescribeContactsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeContactsResponseBody(name='body'),
}

async function describeContacts(request: DescribeContactsRequest): DescribeContactsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeContacts', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDispatchRuleRequest {
  id?: string(name='Id', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeDispatchRuleResponseBody = {
  dispatchRule?: {
    dispatchType?: string(name='DispatchType'),
    groupRules?: [ 
      {
        groupId?: long(name='GroupId'),
        groupInterval?: long(name='GroupInterval'),
        groupWaitTime?: long(name='GroupWaitTime'),
        groupingFields?: [ string ](name='GroupingFields'),
        repeatInterval?: long(name='RepeatInterval'),
      }
    ](name='GroupRules'),
    isRecover?: boolean(name='IsRecover'),
    labelMatchExpressionGrid?: {
      labelMatchExpressionGroups?: [ 
        {
          labelMatchExpressions?: [ 
            {
              key?: string(name='Key'),
              operator?: string(name='Operator'),
              value?: string(name='Value'),
            }
          ](name='LabelMatchExpressions'),
        }
      ](name='LabelMatchExpressionGroups'),
    }(name='LabelMatchExpressionGrid'),
    name?: string(name='Name'),
    notifyRules?: [ 
      {
        notifyChannels?: [ string ](name='NotifyChannels'),
        notifyObjects?: [ 
          {
            name?: string(name='Name'),
            notifyObjectId?: string(name='NotifyObjectId'),
            notifyType?: string(name='NotifyType'),
          }
        ](name='NotifyObjects'),
      }
    ](name='NotifyRules'),
    ruleId?: long(name='RuleId'),
    state?: string(name='State'),
  }(name='DispatchRule'),
  requestId?: string(name='RequestId'),
}

model DescribeDispatchRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDispatchRuleResponseBody(name='body'),
}

async function describeDispatchRule(request: DescribeDispatchRuleRequest): DescribeDispatchRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDispatchRule', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIMRobotsRequest {
  page: long(name='Page', position='Query'),
  robotName?: string(name='RobotName', description='告警机器人名称', position='Query'),
  size: long(name='Size', position='Query'),
}

model DescribeIMRobotsResponseBody = {
  pageBean?: {
    alertIMRobots?: [ 
      {
        dailyNoc?: boolean(name='DailyNoc', description='是否发送每日统计信息'),
        dailyNocTime?: string(name='DailyNocTime', description='每日统计发送时间'),
        robotAddr?: string(name='RobotAddr', description='告警机器人地址'),
        robotId?: float(name='RobotId', description='告警机器人ID'),
        robotName?: string(name='RobotName', description='告警机器人名称'),
        type?: string(name='Type', description='告警机器人类型'),
      }
    ](name='AlertIMRobots'),
    page?: long(name='Page', description='页数'),
    size?: long(name='Size', description='每一页数目'),
    total?: long(name='Total', description='总数'),
  }(name='PageBean', description='分页对象'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DescribeIMRobotsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIMRobotsResponseBody(name='body'),
}

async function describeIMRobots(request: DescribeIMRobotsRequest): DescribeIMRobotsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIMRobots', 'POST', '/', 'json', false, 'json', request);
}

model DescribePrometheusAlertRuleRequest {
  alertId: long(name='AlertId', position='Query'),
}

model DescribePrometheusAlertRuleResponseBody = {
  prometheusAlertRule?: {
    alertId?: long(name='AlertId'),
    alertName?: string(name='AlertName'),
    annotations?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Annotations'),
    clusterId?: string(name='ClusterId'),
    dispatchRuleId?: long(name='DispatchRuleId'),
    duration?: string(name='Duration'),
    expression?: string(name='Expression'),
    labels?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Labels'),
    message?: string(name='Message'),
    notifyType?: string(name='NotifyType'),
    status?: int32(name='Status'),
    type?: string(name='Type'),
  }(name='PrometheusAlertRule'),
  requestId?: string(name='RequestId'),
}

model DescribePrometheusAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePrometheusAlertRuleResponseBody(name='body'),
}

async function describePrometheusAlertRule(request: DescribePrometheusAlertRuleRequest): DescribePrometheusAlertRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePrometheusAlertRule', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTraceLicenseKeyRequest {
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeTraceLicenseKeyResponseBody = {
  licenseKey?: string(name='LicenseKey'),
  requestId?: string(name='RequestId'),
}

model DescribeTraceLicenseKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTraceLicenseKeyResponseBody(name='body'),
}

async function describeTraceLicenseKey(request: DescribeTraceLicenseKeyRequest): DescribeTraceLicenseKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTraceLicenseKey', 'POST', '/', 'json', false, 'json', request);
}

model DescribeWebhookContactsRequest {
  page: long(name='Page', position='Query'),
  size: long(name='Size', position='Query'),
  webhookName?: string(name='WebhookName', description='告警webhook名称', position='Query'),
}

model DescribeWebhookContactsResponseBody = {
  pageBean?: {
    page?: long(name='Page', description='页数'),
    size?: long(name='Size', description='每一页数目'),
    total?: long(name='Total', description='总数'),
    webhookContacts?: [ 
      {
        webhook?: {
          bizHeaders?: string(name='BizHeaders', description='HTTP请求头'),
          bizParams?: string(name='BizParams', description='HTTP请求参数'),
          body?: string(name='Body', description='告警通知模板'),
          method?: string(name='Method', description='http请求方式'),
          recoverBody?: string(name='RecoverBody', description='告警恢复模板'),
          url?: string(name='Url', description='Url'),
        }(name='Webhook', description='webhook对象'),
        webhookId?: float(name='WebhookId', description='告警webhookID'),
        webhookName?: string(name='WebhookName', description='告警webhook名称'),
      }
    ](name='WebhookContacts', description='告警webhook联系人列表'),
  }(name='PageBean', description='分页对象'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DescribeWebhookContactsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeWebhookContactsResponseBody(name='body'),
}

async function describeWebhookContacts(request: DescribeWebhookContactsRequest): DescribeWebhookContactsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeWebhookContacts', 'GET', '/', 'json', false, 'json', request);
}

model GetASMIntegrationStateRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetASMIntegrationStateResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  state?: boolean(name='State'),
}

model GetASMIntegrationStateResponse = {
  headers: map[string]string(name='headers'),
  body: GetASMIntegrationStateResponseBody(name='body'),
}

async function getASMIntegrationState(request: GetASMIntegrationStateRequest): GetASMIntegrationStateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetASMIntegrationState', 'POST', '/', 'json', false, 'json', request);
}

model GetAgentDownloadUrlRequest {
  regionId: string(name='RegionId', position='Query'),
}

model GetAgentDownloadUrlResponseBody = {
  armsAgentDownloadUrl?: string(name='ArmsAgentDownloadUrl'),
  requestId?: string(name='RequestId'),
}

model GetAgentDownloadUrlResponse = {
  headers: map[string]string(name='headers'),
  body: GetAgentDownloadUrlResponseBody(name='body'),
}

async function getAgentDownloadUrl(request: GetAgentDownloadUrlRequest): GetAgentDownloadUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAgentDownloadUrl', 'GET', '/', 'json', false, 'json', request);
}

model GetAlertRulesRequest {
  alertIds?: string(name='AlertIds', description='告警规则ID', position='Query'),
  alertNames?: string(name='AlertNames', description='告警规则名称', position='Query'),
  alertStatus?: string(name='AlertStatus', description='告警规则运行状态', position='Query'),
  alertType: string(name='AlertType', description='告警规则类型', position='Query'),
  page: long(name='Page', description='页数', position='Query'),
  regionId: string(name='RegionId', description='地域', position='Query'),
  size: long(name='Size', description='每一页大小', position='Query'),
}

model GetAlertRulesResponseBody = {
  pageBean?: {
    alertRules?: [ 
      {
        alertCheckType?: string(name='AlertCheckType', description='Prometheus告警-告警检查类型'),
        alertGroup?: long(name='AlertGroup', description='Prometheus告警-告警分组ID'),
        alertId?: float(name='AlertId', description='告警规则ID'),
        alertName?: string(name='AlertName', description='告警规则名称'),
        alertRuleContent?: {
          alertRuleItems?: [ 
            {
              aggregate?: string(name='Aggregate', description='应用监控/前端监控-聚合方式'),
              metricKey?: string(name='MetricKey', description='应用监控/前端监控-具体告警条件的指标'),
              n?: float(name='N', description='应用监控/前端监控-最近N分钟'),
              operator?: string(name='Operator', description='应用监控/前端监控-判断条件'),
              value?: string(name='Value', description='应用监控/前端监控-阈值'),
            }
          ](name='AlertRuleItems', description='应用监控/前端监控-告警条件'),
          condition?: string(name='Condition', description='应用监控/前端监控-多个告警条件触发逻辑'),
        }(name='AlertRuleContent', description='应用监控/前端监控-告警规则内容'),
        alertStatus?: string(name='AlertStatus', description='告警规则状态'),
        alertType?: string(name='AlertType', description='告警规则类型'),
        annotations?: [ 
          {
            name?: string(name='Name', description='键'),
            value?: string(name='Value', description='值'),
          }
        ](name='Annotations', description='Prometheus告警-Annotation'),
        autoAddNewApplication?: boolean(name='AutoAddNewApplication', description='应用监控/前端监控-是否开启新创建应用追加到此告警规则'),
        clusterId?: string(name='ClusterId', description='Prometheus告警-集群ID'),
        createdTime?: long(name='CreatedTime', description='创建时间'),
        duration?: string(name='Duration', description='Prometheus告警-持续时间'),
        extend?: string(name='Extend', description='扩展字段'),
        filters?: {
          customSLSFilters?: [ 
            {
              key?: string(name='Key'),
              opt?: string(name='Opt'),
              show?: boolean(name='Show'),
              t?: string(name='T'),
              value?: string(name='Value'),
            }
          ](name='CustomSLSFilters'),
          customSLSGroupByDimensions?: [ string ](name='CustomSLSGroupByDimensions'),
          customSLSWheres?: [ string ](name='CustomSLSWheres'),
          dimFilters?: [ 
            {
              filterKey?: string(name='FilterKey'),
              filterOpt?: string(name='FilterOpt'),
              filterValues?: [ string ](name='FilterValues'),
            }
          ](name='DimFilters'),
        }(name='Filters', description='应用监控/前端监控-告警条件-过滤项'),
        labels?: [ 
          {
            name?: string(name='Name', description='键'),
            value?: string(name='Value', description='值'),
          }
        ](name='Labels', description='Prometheus告警-Label'),
        level?: string(name='Level', description='Prometheus告警-等级'),
        message?: string(name='Message', description='Prometheus告警-告警内容'),
        metricsType?: string(name='MetricsType', description='应用监控/前端监控-告警指标类型'),
        notifyStrategy?: string(name='NotifyStrategy', description='通知策略ID'),
        pids?: [ string ](name='Pids', description='应用监控/前端监控-告警关联应用ID'),
        promQL?: string(name='PromQL', description='Prometheus告警-PromQL语句'),
        regionId?: string(name='RegionId', description='地域'),
        updatedTime?: long(name='UpdatedTime', description='更新时间'),
        userId?: string(name='UserId', description='用户UID'),
      }
    ](name='AlertRules', description='告警规则列表'),
    page?: long(name='Page', description='页数'),
    size?: long(name='Size', description='每一页大小'),
    total?: long(name='Total', description='总数'),
  }(name='PageBean', description='分页对象'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model GetAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  body: GetAlertRulesResponseBody(name='body'),
}

async function getAlertRules(request: GetAlertRulesRequest): GetAlertRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAlertRules', 'GET', '/', 'json', false, 'json', request);
}

model GetAppApiByPageRequest {
  currentPage?: int32(name='CurrentPage', minimum=1, maximum=2147483647, position='Query'),
  endTime?: long(name='EndTime', minimum=0, maximum=9223372036854775806, position='Query'),
  intervalMills?: int32(name='IntervalMills', minimum=0, maximum=2147483647, position='Query'),
  PId: string(name='PId', position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=2147483647, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  startTime?: long(name='StartTime', minimum=0, maximum=9223372036854775806, position='Query'),
}

model GetAppApiByPageResponseBody = {
  code?: int32(name='Code'),
  data?: {
    items?: [  map[string]any ](name='Items'),
    page?: int32(name='Page'),
    pageSize?: int32(name='PageSize'),
    total?: string(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAppApiByPageResponse = {
  headers: map[string]string(name='headers'),
  body: GetAppApiByPageResponseBody(name='body'),
}

async function getAppApiByPage(request: GetAppApiByPageRequest): GetAppApiByPageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAppApiByPage', 'POST', '/', 'json', false, 'json', request);
}

model GetArmsAgentDownLoadUrlRequest {
  regionId: string(name='RegionId', position='Query'),
}

model GetArmsAgentDownLoadUrlResponseBody = {
  armsAgentDownloadUrl?: string(name='ArmsAgentDownloadUrl'),
  requestId?: string(name='RequestId'),
}

model GetArmsAgentDownLoadUrlResponse = {
  headers: map[string]string(name='headers'),
  body: GetArmsAgentDownLoadUrlResponseBody(name='body'),
}

async function getArmsAgentDownLoadUrl(request: GetArmsAgentDownLoadUrlRequest): GetArmsAgentDownLoadUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetArmsAgentDownLoadUrl', 'GET', '/', 'json', false, 'json', request);
}

model GetClusterInfoRequest {
  clusterId: string(name='ClusterId', position='Query'),
  queryUserId: string(name='QueryUserId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetClusterInfoResponseBody = {
  data?: {
    ackNotRunning?: boolean(name='AckNotRunning'),
    agentHelmNotExist?: boolean(name='AgentHelmNotExist'),
    agentServiceNotExist?: boolean(name='AgentServiceNotExist'),
    armsDBNotExist?: boolean(name='ArmsDBNotExist'),
    checkType?: string(name='CheckType'),
    getClusterInfo?: string(name='GetClusterInfo'),
    haveAgentNodeIsNotReady?: boolean(name='HaveAgentNodeIsNotReady'),
    isFlink?: boolean(name='IsFlink'),
    needIntervention?: boolean(name='NeedIntervention'),
    nodeSizeIsZero?: boolean(name='NodeSizeIsZero'),
    podIsNotRestart?: boolean(name='PodIsNotRestart'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetClusterInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetClusterInfoResponseBody(name='body'),
}

async function getClusterInfo(request: GetClusterInfoRequest): GetClusterInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetClusterInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetClusterStateRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  puserId?: string(name='PuserId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model GetClusterStateResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  result?: {
    agentState?: boolean(name='agentState'),
    clusterState?: string(name='clusterState'),
    isFlink?: boolean(name='isFlink'),
  }(name='result'),
}

model GetClusterStateResponse = {
  headers: map[string]string(name='headers'),
  body: GetClusterStateResponseBody(name='body'),
}

async function getClusterState(request: GetClusterStateRequest): GetClusterStateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetClusterState', 'POST', '/', 'json', false, 'json', request);
}

model GetEstimateFeeInfoRequest {
  regionId?: string(name='RegionId', position='Host'),
  targetUserId?: string(name='TargetUserId', position='Query'),
  usageCn?: long(name='UsageCn', position='Query'),
  usageFn?: long(name='UsageFn', position='Query'),
}

model GetEstimateFeeInfoResponseBody = {
  data?: string(name='Data', description='data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetEstimateFeeInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetEstimateFeeInfoResponseBody(name='body'),
}

async function getEstimateFeeInfo(request: GetEstimateFeeInfoRequest): GetEstimateFeeInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEstimateFeeInfo', 'GET', '/', 'json', false, 'json', request);
}

model GetExploreUrlRequest {
  clusterId: string(name='ClusterId', position='Query'),
  expression?: string(name='Expression', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
}

model GetExploreUrlResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetExploreUrlResponse = {
  headers: map[string]string(name='headers'),
  body: GetExploreUrlResponseBody(name='body'),
}

async function getExploreUrl(request: GetExploreUrlRequest): GetExploreUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetExploreUrl', 'POST', '/', 'json', false, 'json', request);
}

model GetIntegrationStateRequest {
  clusterId: string(name='ClusterId', position='Query'),
  integration: string(name='Integration', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetIntegrationStateResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  state?: boolean(name='State'),
}

model GetIntegrationStateResponse = {
  headers: map[string]string(name='headers'),
  body: GetIntegrationStateResponseBody(name='body'),
}

async function getIntegrationState(request: GetIntegrationStateRequest): GetIntegrationStateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetIntegrationState', 'POST', '/', 'json', false, 'json', request);
}

model GetMultipleTraceRequest {
  regionId: string(name='RegionId', position='Query'),
  traceIDs?: [ string ](name='TraceIDs', position='Query'),
}

model GetMultipleTraceResponseBody = {
  multiCallChainInfos?: [ 
    {
      spans?: [ 
        {
          duration?: long(name='Duration'),
          haveStack?: boolean(name='HaveStack'),
          logEventList?: [ 
            {
              tagEntryList?: [ 
                {
                  key?: string(name='Key'),
                  value?: string(name='Value'),
                }
              ](name='TagEntryList'),
              timestamp?: long(name='Timestamp'),
            }
          ](name='LogEventList'),
          operationName?: string(name='OperationName'),
          parentSpanId?: string(name='ParentSpanId'),
          resultCode?: string(name='ResultCode'),
          rpcId?: string(name='RpcId'),
          rpcType?: int32(name='RpcType'),
          serviceIp?: string(name='ServiceIp'),
          serviceName?: string(name='ServiceName'),
          spanId?: string(name='SpanId'),
          tagEntryList?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
            }
          ](name='TagEntryList'),
          timestamp?: long(name='Timestamp'),
          traceID?: string(name='TraceID'),
        }
      ](name='Spans'),
      traceID?: string(name='TraceID'),
    }
  ](name='MultiCallChainInfos'),
  requestId?: string(name='RequestId'),
}

model GetMultipleTraceResponse = {
  headers: map[string]string(name='headers'),
  body: GetMultipleTraceResponseBody(name='body'),
}

async function getMultipleTrace(request: GetMultipleTraceRequest): GetMultipleTraceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMultipleTrace', 'POST', '/', 'json', false, 'json', request);
}

model GetPrometheusApiTokenRequest {
  regionId: string(name='RegionId', position='Query'),
}

model GetPrometheusApiTokenResponseBody = {
  requestId?: string(name='RequestId'),
  token?: string(name='Token'),
}

model GetPrometheusApiTokenResponse = {
  headers: map[string]string(name='headers'),
  body: GetPrometheusApiTokenResponseBody(name='body'),
}

async function getPrometheusApiToken(request: GetPrometheusApiTokenRequest): GetPrometheusApiTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPrometheusApiToken', 'POST', '/', 'json', false, 'json', request);
}

model GetRecordingRuleRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetRecordingRuleResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetRecordingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: GetRecordingRuleResponseBody(name='body'),
}

async function getRecordingRule(request: GetRecordingRuleRequest): GetRecordingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetRecordingRule', 'POST', '/', 'json', false, 'json', request);
}

model GetRetcodeShareUrlRequest {
  pid: string(name='Pid', position='Query'),
}

model GetRetcodeShareUrlResponseBody = {
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model GetRetcodeShareUrlResponse = {
  headers: map[string]string(name='headers'),
  body: GetRetcodeShareUrlResponseBody(name='body'),
}

async function getRetcodeShareUrl(request: GetRetcodeShareUrlRequest): GetRetcodeShareUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetRetcodeShareUrl', 'POST', '/', 'json', false, 'json', request);
}

model GetStackRequest {
  pid?: string(name='Pid', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  rpcID: string(name='RpcID', position='Query'),
  traceID: string(name='TraceID', position='Query'),
}

model GetStackResponseBody = {
  requestId?: string(name='RequestId'),
  stackInfo?: [ 
    {
      api?: string(name='Api'),
      duration?: long(name='Duration'),
      exception?: string(name='Exception'),
      extInfo?: {
        info?: string(name='Info'),
        type?: string(name='Type'),
      }(name='ExtInfo'),
      line?: string(name='Line'),
      rpcId?: string(name='RpcId'),
      serviceName?: string(name='ServiceName'),
      startTime?: long(name='StartTime'),
    }
  ](name='StackInfo'),
}

model GetStackResponse = {
  headers: map[string]string(name='headers'),
  body: GetStackResponseBody(name='body'),
}

async function getStack(request: GetStackRequest): GetStackResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetStack', 'POST', '/', 'json', false, 'json', request);
}

model GetTraceRequest {
  endTime?: long(name='EndTime', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  startTime?: long(name='StartTime', position='Query'),
  traceID: string(name='TraceID', position='Query'),
}

model GetTraceResponseBody = {
  requestId?: string(name='RequestId'),
  spans?: [ 
    {
      children?: [  map[string]any ](name='Children'),
      duration?: long(name='Duration'),
      haveStack?: boolean(name='HaveStack'),
      logEventList?: [ 
        {
          tagEntryList?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
            }
          ](name='TagEntryList'),
          timestamp?: long(name='Timestamp'),
        }
      ](name='LogEventList'),
      operationName?: string(name='OperationName'),
      parentSpanId?: string(name='ParentSpanId'),
      resultCode?: string(name='ResultCode'),
      rpcId?: string(name='RpcId'),
      rpcType?: int32(name='RpcType'),
      serviceIp?: string(name='ServiceIp'),
      serviceName?: string(name='ServiceName'),
      spanId?: string(name='SpanId'),
      tagEntryList?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='TagEntryList'),
      timestamp?: long(name='Timestamp'),
      traceID?: string(name='TraceID'),
    }
  ](name='Spans'),
}

model GetTraceResponse = {
  headers: map[string]string(name='headers'),
  body: GetTraceResponseBody(name='body'),
}

async function getTrace(request: GetTraceRequest): GetTraceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTrace', 'POST', '/', 'json', false, 'json', request);
}

model GetTraceAppRequest {
  pid: string(name='Pid', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetTraceAppResponseBody = {
  requestId?: string(name='RequestId'),
  traceApp?: {
    appId?: long(name='AppId'),
    appName?: string(name='AppName'),
    createTime?: long(name='CreateTime'),
    labels?: [ string ](name='Labels'),
    pid?: string(name='Pid'),
    regionId?: string(name='RegionId'),
    show?: boolean(name='Show'),
    type?: string(name='Type'),
    updateTime?: long(name='UpdateTime'),
    userId?: string(name='UserId'),
  }(name='TraceApp'),
}

model GetTraceAppResponse = {
  headers: map[string]string(name='headers'),
  body: GetTraceAppResponseBody(name='body'),
}

async function getTraceApp(request: GetTraceAppRequest): GetTraceAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTraceApp', 'POST', '/', 'json', false, 'json', request);
}

model GetUserCommercialStatusRequest {
  parentId?: string(name='ParentId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  targetUserId?: string(name='TargetUserId', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model GetUserCommercialStatusResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetUserCommercialStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserCommercialStatusResponseBody(name='body'),
}

async function getUserCommercialStatus(request: GetUserCommercialStatusRequest): GetUserCommercialStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserCommercialStatus', 'POST', '/', 'json', false, 'json', request);
}

model ImportAppAlertRulesRequest {
  contactGroupIds?: string(name='ContactGroupIds', position='Query'),
  isAutoStart?: boolean(name='IsAutoStart', position='Query'),
  pids: string(name='Pids', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  templageAlertConfig?: string(name='TemplageAlertConfig', position='Query'),
  templateAlertId?: string(name='TemplateAlertId', position='Query'),
}

model ImportAppAlertRulesResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ImportAppAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ImportAppAlertRulesResponseBody(name='body'),
}

async function importAppAlertRules(request: ImportAppAlertRulesRequest): ImportAppAlertRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportAppAlertRules', 'POST', '/', 'json', false, 'json', request);
}

model InstallManagedPrometheusRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  clusterType?: string(name='ClusterType', position='Query'),
  kubeConfig?: string(name='KubeConfig', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model InstallManagedPrometheusResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model InstallManagedPrometheusResponse = {
  headers: map[string]string(name='headers'),
  body: InstallManagedPrometheusResponseBody(name='body'),
}

async function installManagedPrometheus(request: InstallManagedPrometheusRequest): InstallManagedPrometheusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'InstallManagedPrometheus', 'POST', '/', 'json', false, 'json', request);
}

model ListActivatedAlertsRequest {
  currentPage: int32(name='CurrentPage', position='Query'),
  filter?: string(name='Filter', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListActivatedAlertsResponseBody = {
  page?: {
    alerts?: [ 
      {
        alertId?: string(name='AlertId'),
        alertName?: string(name='AlertName'),
        alertType?: string(name='AlertType'),
        count?: int32(name='Count'),
        createTime?: long(name='CreateTime'),
        dispatchRules?: [ 
          {
            ruleId?: int32(name='RuleId'),
            ruleName?: string(name='RuleName'),
          }
        ](name='DispatchRules'),
        endsAt?: long(name='EndsAt'),
        expandFields?: map[string]any(name='ExpandFields'),
        integrationName?: string(name='IntegrationName'),
        integrationType?: string(name='IntegrationType'),
        involvedObjectKind?: string(name='InvolvedObjectKind'),
        involvedObjectName?: string(name='InvolvedObjectName'),
        message?: string(name='Message'),
        severity?: string(name='Severity'),
        startsAt?: long(name='StartsAt'),
        status?: string(name='Status'),
      }
    ](name='Alerts'),
    page?: int32(name='Page'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Page'),
  requestId?: string(name='RequestId'),
}

model ListActivatedAlertsResponse = {
  headers: map[string]string(name='headers'),
  body: ListActivatedAlertsResponseBody(name='body'),
}

async function listActivatedAlerts(request: ListActivatedAlertsRequest): ListActivatedAlertsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListActivatedAlerts', 'POST', '/', 'json', false, 'json', request);
}

model ListAlertsRequest {
  alertName?: string(name='AlertName', description='告警名称', position='Query'),
  dispatchRuleId?: long(name='DispatchRuleId', description='通知策略ID', position='Query'),
  endTime?: string(name='EndTime', description='查询告警发送历史记录的开始时间，时间格式：YYYY-MM-DD HH:mm:ss', position='Query'),
  integrationType?: string(name='IntegrationType', description='集成类型', position='Query'),
  page: long(name='Page', description='页数', position='Query'),
  severity?: string(name='Severity', description='告警等级(P1~P6)', position='Query'),
  showActivities?: boolean(name='ShowActivities', description='默认不查活动记录，showActivities=true才查，只查最近3天的内容', position='Query'),
  showEvents?: boolean(name='ShowEvents', description='默认不查事件，showEvents=true才查', position='Query'),
  size: long(name='Size', description='每页展示数目', position='Query'),
  startTime?: string(name='StartTime', description='查询告警发送历史记录的开始时间，时间格式：YYYY-MM-DD HH:mm:ss', position='Query'),
  state?: long(name='State', description='告警状态(0 - 待处理， 1 - 处理中， 2 - 已处理)', position='Query'),
}

model ListAlertsResponseBody = {
  pageBean?: {
    listAlerts?: [ 
      {
        activities?: [ 
          {
            content?: string(name='Content', description='通知内容'),
            description?: string(name='Description', description='描述'),
            handlerName?: string(name='HandlerName', description='处理人名称'),
            time?: string(name='Time', description='时间'),
            type?: long(name='Type', description='活动类型'),
          }
        ](name='Activities', description='活动列表'),
        alertEvents?: [ 
          {
            alertName?: string(name='AlertName', description='事件名称'),
            annotations?: string(name='Annotations', description='注释列表'),
            description?: string(name='Description', description='事件描述'),
            endTime?: string(name='EndTime', description='结束时间'),
            generatorURL?: string(name='GeneratorURL', description='事件地址'),
            integrationName?: string(name='IntegrationName', description='集成名称'),
            integrationType?: string(name='IntegrationType', description='集成类型'),
            labels?: string(name='Labels', description='标签列表'),
            receiveTime?: string(name='ReceiveTime', description='事件接受时间'),
            severity?: string(name='Severity', description='事件等级'),
            startTime?: string(name='StartTime', description='开始时间'),
            state?: string(name='State', description='告警状态Active("Active"),      * Inhibited("Inhibited"),      * Silenced("Silenced"),      * Resolved("Resolved")'),
          }
        ](name='AlertEvents', description='事件列表'),
        alertName?: string(name='AlertName', description='告警名称'),
        createTime?: string(name='CreateTime', description='创建时间'),
        dispatchRuleId?: float(name='DispatchRuleId', description='通知策略ID'),
        dispatchRuleName?: string(name='DispatchRuleName', description='通知策略名称'),
        severity?: string(name='Severity', description='告警等级(P1~P6)'),
        state?: long(name='State', description='告警状态(0 - 待处理， 1 - 处理中， 2 - 已处理)'),
      }
    ](name='ListAlerts', description='告警发送历史信息组'),
    page?: long(name='Page', description='页数'),
    size?: long(name='Size', description='每页展示数目'),
    total?: long(name='Total', description='总数'),
  }(name='PageBean', description='返回结构体'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model ListAlertsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlertsResponseBody(name='body'),
}

async function listAlerts(request: ListAlertsRequest): ListAlertsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAlerts', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterFromGrafanaRequest {
  regionId: string(name='RegionId', position='Query'),
}

model ListClusterFromGrafanaResponseBody = {
  promClusterList?: [ 
    {
      agentStatus?: string(name='AgentStatus'),
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      controllerId?: string(name='ControllerId'),
      createTime?: long(name='CreateTime'),
      extra?: string(name='Extra'),
      id?: long(name='Id'),
      installTime?: long(name='InstallTime'),
      isControllerInstalled?: boolean(name='IsControllerInstalled'),
      lastHeartBeatTime?: long(name='LastHeartBeatTime'),
      nodeNum?: int32(name='NodeNum'),
      options?: string(name='Options'),
      pluginsJsonArray?: string(name='PluginsJsonArray'),
      regionId?: string(name='RegionId'),
      stateJson?: string(name='StateJson'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='PromClusterList'),
  requestId?: string(name='RequestId'),
}

model ListClusterFromGrafanaResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterFromGrafanaResponseBody(name='body'),
}

async function listClusterFromGrafana(request: ListClusterFromGrafanaRequest): ListClusterFromGrafanaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterFromGrafana', 'POST', '/', 'json', false, 'json', request);
}

model ListDashboardsRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  clusterType?: string(name='ClusterType', position='Query'),
  dashboardName?: string(name='DashboardName', position='Query'),
  product?: string(name='Product', position='Query'),
  recreateSwitch?: boolean(name='RecreateSwitch', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  title?: string(name='Title', position='Query'),
}

model ListDashboardsResponseBody = {
  dashboardVos?: [ 
    {
      dashboardType?: string(name='DashboardType'),
      exporter?: string(name='Exporter'),
      httpUrl?: string(name='HttpUrl'),
      httpsUrl?: string(name='HttpsUrl'),
      id?: string(name='Id'),
      isArmsExporter?: boolean(name='IsArmsExporter'),
      kind?: string(name='Kind'),
      name?: string(name='Name'),
      needUpdate?: boolean(name='NeedUpdate'),
      tags?: [ string ](name='Tags'),
      time?: string(name='Time'),
      title?: string(name='Title'),
      type?: string(name='Type'),
      uid?: string(name='Uid'),
      url?: string(name='Url'),
      version?: string(name='Version'),
    }
  ](name='DashboardVos'),
  requestId?: string(name='RequestId'),
}

model ListDashboardsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDashboardsResponseBody(name='body'),
}

async function listDashboards(request: ListDashboardsRequest): ListDashboardsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDashboards', 'POST', '/', 'json', false, 'json', request);
}

model ListDispatchRuleRequest {
  name?: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  system?: boolean(name='System', position='Query'),
}

model ListDispatchRuleResponseBody = {
  dispatchRules?: [ 
    {
      name?: string(name='Name'),
      ruleId?: long(name='RuleId'),
      state?: string(name='State'),
    }
  ](name='DispatchRules'),
  requestId?: string(name='RequestId'),
}

model ListDispatchRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ListDispatchRuleResponseBody(name='body'),
}

async function listDispatchRule(request: ListDispatchRuleRequest): ListDispatchRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDispatchRule', 'POST', '/', 'json', false, 'json', request);
}

model ListPrometheusAlertRulesRequest {
  clusterId: string(name='ClusterId', position='Query'),
  matchExpressions?: string(name='MatchExpressions', position='Query'),
  name?: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  status?: int32(name='Status', position='Query'),
  type?: string(name='Type', position='Query'),
}

model ListPrometheusAlertRulesResponseBody = {
  prometheusAlertRules?: [ 
    {
      alertId?: long(name='AlertId'),
      alertName?: string(name='AlertName'),
      annotations?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='Annotations'),
      clusterId?: string(name='ClusterId'),
      dispatchRuleId?: long(name='DispatchRuleId'),
      duration?: string(name='Duration'),
      expression?: string(name='Expression'),
      labels?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='Labels'),
      message?: string(name='Message'),
      notifyType?: string(name='NotifyType'),
      status?: int32(name='Status'),
      type?: string(name='Type'),
    }
  ](name='PrometheusAlertRules'),
  requestId?: string(name='RequestId'),
}

model ListPrometheusAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPrometheusAlertRulesResponseBody(name='body'),
}

async function listPrometheusAlertRules(request: ListPrometheusAlertRulesRequest): ListPrometheusAlertRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPrometheusAlertRules', 'POST', '/', 'json', false, 'json', request);
}

model ListPrometheusAlertTemplatesRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListPrometheusAlertTemplatesResponseBody = {
  prometheusAlertTemplates?: [ 
    {
      alertName?: string(name='AlertName'),
      annotations?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='Annotations'),
      description?: string(name='Description'),
      duration?: string(name='Duration'),
      expression?: string(name='Expression'),
      labels?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='Labels'),
      type?: string(name='Type'),
      version?: string(name='Version'),
    }
  ](name='PrometheusAlertTemplates'),
  requestId?: string(name='RequestId'),
}

model ListPrometheusAlertTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPrometheusAlertTemplatesResponseBody(name='body'),
}

async function listPrometheusAlertTemplates(request: ListPrometheusAlertTemplatesRequest): ListPrometheusAlertTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPrometheusAlertTemplates', 'POST', '/', 'json', false, 'json', request);
}

model ListRetcodeAppsRequest {
  regionId: string(name='RegionId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ListRetcodeAppsResponseBody = {
  requestId?: string(name='RequestId'),
  retcodeApps?: [ 
    {
      appId?: long(name='AppId'),
      appName?: string(name='AppName'),
      pid?: string(name='Pid'),
      retcodeAppType?: string(name='RetcodeAppType'),
    }
  ](name='RetcodeApps'),
}

model ListRetcodeAppsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRetcodeAppsResponseBody(name='body'),
}

async function listRetcodeApps(request: ListRetcodeAppsRequest): ListRetcodeAppsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListRetcodeApps', 'POST', '/', 'json', false, 'json', request);
}

model ListScenarioRequest {
  appId: string(name='AppId', position='Query'),
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  scenario?: string(name='Scenario', position='Query'),
  sign?: string(name='Sign', position='Query'),
}

model ListScenarioResponseBody = {
  armsScenarios?: [ 
    {
      appId?: string(name='AppId'),
      createTime?: string(name='CreateTime'),
      extensions?: string(name='Extensions'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      sign?: string(name='Sign'),
      updateTime?: string(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='ArmsScenarios'),
  requestId?: string(name='RequestId'),
}

model ListScenarioResponse = {
  headers: map[string]string(name='headers'),
  body: ListScenarioResponseBody(name='body'),
}

async function listScenario(request: ListScenarioRequest): ListScenarioResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListScenario', 'POST', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
  tagResources?: [ 
    {
      resouceId?: string(name='ResouceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResources', description='TagResource'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ListTraceAppsRequest {
  regionId: string(name='RegionId', position='Query'),
}

model ListTraceAppsResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceApps?: [ 
    {
      appId?: long(name='AppId'),
      appName?: string(name='AppName'),
      createTime?: long(name='CreateTime'),
      labels?: [ string ](name='Labels'),
      pid?: string(name='Pid'),
      regionId?: string(name='RegionId'),
      show?: boolean(name='Show'),
      type?: string(name='Type'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='TraceApps'),
}

model ListTraceAppsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTraceAppsResponseBody(name='body'),
}

async function listTraceApps(request: ListTraceAppsRequest): ListTraceAppsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTraceApps', 'POST', '/', 'json', false, 'json', request);
}

model OpenArmsDefaultSLRRequest {
  regionId: string(name='RegionId', position='Query'),
}

model OpenArmsDefaultSLRResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model OpenArmsDefaultSLRResponse = {
  headers: map[string]string(name='headers'),
  body: OpenArmsDefaultSLRResponseBody(name='body'),
}

async function openArmsDefaultSLR(request: OpenArmsDefaultSLRRequest): OpenArmsDefaultSLRResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenArmsDefaultSLR', 'POST', '/', 'json', false, 'json', request);
}

model OpenArmsServiceRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  type: string(name='Type', position='Query'),
}

model OpenArmsServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenArmsServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenArmsServiceResponseBody(name='body'),
}

async function openArmsService(request: OpenArmsServiceRequest): OpenArmsServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenArmsService', 'POST', '/', 'json', false, 'json', request);
}

model OpenArmsServiceSecondVersionRequest {
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
}

model OpenArmsServiceSecondVersionResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenArmsServiceSecondVersionResponse = {
  headers: map[string]string(name='headers'),
  body: OpenArmsServiceSecondVersionResponseBody(name='body'),
}

async function openArmsServiceSecondVersion(request: OpenArmsServiceSecondVersionRequest): OpenArmsServiceSecondVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenArmsServiceSecondVersion', 'POST', '/', 'json', false, 'json', request);
}

model OpenVClusterRequest {
  clusterType: string(name='ClusterType', position='Query'),
  length?: int32(name='Length', position='Query'),
  product?: string(name='Product', position='Query'),
  recreateSwitch?: boolean(name='RecreateSwitch', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model OpenVClusterResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model OpenVClusterResponse = {
  headers: map[string]string(name='headers'),
  body: OpenVClusterResponseBody(name='body'),
}

async function openVCluster(request: OpenVClusterRequest): OpenVClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenVCluster', 'POST', '/', 'json', false, 'json', request);
}

model OpenXtraceDefaultSLRRequest {
  regionId: string(name='RegionId', position='Query'),
}

model OpenXtraceDefaultSLRResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model OpenXtraceDefaultSLRResponse = {
  headers: map[string]string(name='headers'),
  body: OpenXtraceDefaultSLRResponseBody(name='body'),
}

async function openXtraceDefaultSLR(request: OpenXtraceDefaultSLRRequest): OpenXtraceDefaultSLRResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenXtraceDefaultSLR', 'POST', '/', 'json', false, 'json', request);
}

model PromVpcExporterManagerRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  exporterConfig?: string(name='ExporterConfig', position='Query'),
  exporterType: string(name='ExporterType', position='Query'),
  method: string(name='Method', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model PromVpcExporterManagerResponseBody = {
  requestId?: string(name='RequestId'),
  token?: string(name='Token'),
}

model PromVpcExporterManagerResponse = {
  headers: map[string]string(name='headers'),
  body: PromVpcExporterManagerResponseBody(name='body'),
}

async function promVpcExporterManager(request: PromVpcExporterManagerRequest): PromVpcExporterManagerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PromVpcExporterManager', 'POST', '/', 'json', false, 'json', request);
}

model QueryDatasetRequest {
  datasetId: long(name='DatasetId', position='Query'),
  dateStr?: string(name='DateStr', position='Query'),
  dimensions?: [ 
    {
      key?: string(name='Key'),
      type?: string(name='Type'),
      value?: string(name='Value'),
    }
  ](name='Dimensions', position='Query'),
  hungryMode?: boolean(name='HungryMode', position='Query'),
  intervalInSec: int32(name='IntervalInSec', position='Query'),
  isDrillDown?: boolean(name='IsDrillDown', position='Query'),
  limit?: int32(name='Limit', position='Query'),
  maxTime: long(name='MaxTime', position='Query'),
  measures?: [ string ](name='Measures', position='Query'),
  minTime: long(name='MinTime', position='Query'),
  optionalDims?: [ 
    {
      key?: string(name='Key'),
      type?: string(name='Type'),
      value?: string(name='Value'),
    }
  ](name='OptionalDims', position='Query'),
  orderByKey?: string(name='OrderByKey', position='Query'),
  proxyUserId?: string(name='ProxyUserId', position='Query'),
  reduceTail?: boolean(name='ReduceTail', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  requiredDims?: [ 
    {
      key?: string(name='Key'),
      type?: string(name='Type'),
      value?: string(name='Value'),
    }
  ](name='RequiredDims', position='Query'),
}

model QueryDatasetResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryDatasetResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDatasetResponseBody(name='body'),
}

async function queryDataset(request: QueryDatasetRequest): QueryDatasetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDataset', 'POST', '/', 'json', false, 'json', request);
}

model QueryMetricByPageRequest {
  currentPage?: int32(name='CurrentPage', minimum=1, maximum=2147483647, position='Query'),
  customFilters?: [ string ](name='CustomFilters', position='Query'),
  dimensions?: [ string ](name='Dimensions', position='Query'),
  endTime: long(name='EndTime', minimum=0, maximum=9223372036854775806, position='Query'),
  filters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filters', position='Query'),
  intervalInSec?: int32(name='IntervalInSec', minimum=0, maximum=2147483647, position='Query'),
  measures?: [ string ](name='Measures', position='Query'),
  metric: string(name='Metric', position='Query'),
  order?: string(name='Order', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=2147483647, position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  startTime: long(name='StartTime', minimum=0, maximum=9223372036854775806, position='Query'),
}

model QueryMetricByPageResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [  map[string]any ](name='Items'),
    page?: int32(name='Page'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryMetricByPageResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMetricByPageResponseBody(name='body'),
}

async function queryMetricByPage(request: QueryMetricByPageRequest): QueryMetricByPageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMetricByPage', 'POST', '/', 'json', false, 'json', request);
}

model QueryPromInstallStatusRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model QueryPromInstallStatusResponseBody = {
  data?: {
    isControllerInstalled?: boolean(name='isControllerInstalled'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryPromInstallStatusResponse = {
  headers: map[string]string(name='headers'),
  body: QueryPromInstallStatusResponseBody(name='body'),
}

async function queryPromInstallStatus(request: QueryPromInstallStatusRequest): QueryPromInstallStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryPromInstallStatus', 'POST', '/', 'json', false, 'json', request);
}

model QueryReleaseMetricRequest {
  changeOrderId: string(name='ChangeOrderId', position='Query'),
  createTime?: long(name='CreateTime', position='Query'),
  metricType?: string(name='MetricType', position='Query'),
  pid: string(name='Pid', position='Query'),
  proxyUserId?: string(name='ProxyUserId', position='Query'),
  regionId: string(name='RegionId', position='Host'),
  releaseEndTime: long(name='ReleaseEndTime', position='Query'),
  releaseStartTime: long(name='ReleaseStartTime', position='Query'),
  service?: string(name='Service', position='Query'),
}

model QueryReleaseMetricResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryReleaseMetricResponse = {
  headers: map[string]string(name='headers'),
  body: QueryReleaseMetricResponseBody(name='body'),
}

async function queryReleaseMetric(request: QueryReleaseMetricRequest): QueryReleaseMetricResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryReleaseMetric', 'POST', '/', 'json', false, 'json', request);
}

model SaveTraceAppConfigRequest {
  pid: string(name='Pid', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  settings?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Settings', position='Query'),
}

model SaveTraceAppConfigResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model SaveTraceAppConfigResponse = {
  headers: map[string]string(name='headers'),
  body: SaveTraceAppConfigResponseBody(name='body'),
}

async function saveTraceAppConfig(request: SaveTraceAppConfigRequest): SaveTraceAppConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveTraceAppConfig', 'POST', '/', 'json', false, 'json', request);
}

model SearchAlertContactRequest {
  contactIds?: string(name='ContactIds', position='Query'),
  contactName?: string(name='ContactName', position='Query'),
  currentPage?: string(name='CurrentPage', position='Query'),
  email?: string(name='Email', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  phone?: string(name='Phone', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model SearchAlertContactResponseBody = {
  pageBean?: {
    contacts?: [ 
      {
        contactId?: long(name='ContactId'),
        contactName?: string(name='ContactName'),
        content?: string(name='Content'),
        createTime?: long(name='CreateTime'),
        dingRobot?: string(name='DingRobot'),
        email?: string(name='Email'),
        phone?: string(name='Phone'),
        systemNoc?: boolean(name='SystemNoc'),
        updateTime?: long(name='UpdateTime'),
        userId?: string(name='UserId'),
        webhook?: string(name='Webhook'),
      }
    ](name='Contacts'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchAlertContactResponse = {
  headers: map[string]string(name='headers'),
  body: SearchAlertContactResponseBody(name='body'),
}

async function searchAlertContact(request: SearchAlertContactRequest): SearchAlertContactResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchAlertContact', 'POST', '/', 'json', false, 'json', request);
}

model SearchAlertContactGroupRequest {
  contactGroupIds?: string(name='ContactGroupIds', position='Query'),
  contactGroupName?: string(name='ContactGroupName', position='Query'),
  contactId?: long(name='ContactId', position='Query'),
  contactName?: string(name='ContactName', position='Query'),
  isDetail?: boolean(name='IsDetail', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model SearchAlertContactGroupResponseBody = {
  contactGroups?: [ 
    {
      contactGroupId?: long(name='ContactGroupId'),
      contactGroupName?: string(name='ContactGroupName'),
      contacts?: [ 
        {
          contactId?: long(name='ContactId'),
          contactName?: string(name='ContactName'),
          createTime?: long(name='CreateTime'),
          dingRobot?: string(name='DingRobot'),
          email?: string(name='Email'),
          phone?: string(name='Phone'),
          systemNoc?: boolean(name='SystemNoc'),
          updateTime?: long(name='UpdateTime'),
          userId?: string(name='UserId'),
        }
      ](name='Contacts'),
      createTime?: long(name='CreateTime'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='ContactGroups'),
  requestId?: string(name='RequestId'),
}

model SearchAlertContactGroupResponse = {
  headers: map[string]string(name='headers'),
  body: SearchAlertContactGroupResponseBody(name='body'),
}

async function searchAlertContactGroup(request: SearchAlertContactGroupRequest): SearchAlertContactGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchAlertContactGroup', 'POST', '/', 'json', false, 'json', request);
}

model SearchAlertHistoriesRequest {
  alertId?: long(name='AlertId', position='Query'),
  alertType?: int32(name='AlertType', position='Query'),
  currentPage?: int32(name='CurrentPage', position='Query'),
  endTime?: long(name='EndTime', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  startTime?: long(name='StartTime', position='Query'),
}

model SearchAlertHistoriesResponseBody = {
  pageBean?: {
    alarmHistories?: [ 
      {
        alarmContent?: string(name='AlarmContent'),
        alarmResponseCode?: int32(name='AlarmResponseCode'),
        alarmSources?: string(name='AlarmSources'),
        alarmTime?: long(name='AlarmTime'),
        alarmType?: int32(name='AlarmType'),
        emails?: string(name='Emails'),
        id?: long(name='Id'),
        phones?: string(name='Phones'),
        strategyId?: string(name='StrategyId'),
        target?: string(name='Target'),
        userId?: string(name='UserId'),
      }
    ](name='AlarmHistories'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchAlertHistoriesResponse = {
  headers: map[string]string(name='headers'),
  body: SearchAlertHistoriesResponseBody(name='body'),
}

async function searchAlertHistories(request: SearchAlertHistoriesRequest): SearchAlertHistoriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchAlertHistories', 'POST', '/', 'json', false, 'json', request);
}

model SearchAlertHistorysRequest {
  alertId?: long(name='AlertId', position='Query'),
  alertType?: int32(name='AlertType', position='Query'),
  currentPage?: int32(name='CurrentPage', position='Query'),
  endTime?: long(name='EndTime', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  proxyUserId?: string(name='ProxyUserId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  startTime?: long(name='StartTime', position='Query'),
}

model SearchAlertHistorysResponseBody = {
  pageBean?: {
    alertHistory?: [ 
      {
        alarmContent?: string(name='AlarmContent'),
        alarmResponseCode?: string(name='AlarmResponseCode'),
        alarmTime?: long(name='AlarmTime'),
        alarmType?: int32(name='AlarmType'),
        alertId?: long(name='AlertId'),
        id?: int32(name='Id'),
        phones?: string(name='Phones'),
        tenant?: string(name='Tenant'),
      }
    ](name='AlertHistory'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchAlertHistorysResponse = {
  headers: map[string]string(name='headers'),
  body: SearchAlertHistorysResponseBody(name='body'),
}

async function searchAlertHistorys(request: SearchAlertHistorysRequest): SearchAlertHistorysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchAlertHistorys', 'POST', '/', 'json', false, 'json', request);
}

model SearchAlertRulesRequest {
  appType?: string(name='AppType', position='Query'),
  currentPage?: int32(name='CurrentPage', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  pid?: string(name='Pid', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  systemRegionId?: string(name='SystemRegionId', position='Query'),
  title?: string(name='Title', position='Query'),
  type?: string(name='Type', position='Query'),
}

model SearchAlertRulesResponseBody = {
  pageBean?: {
    alertRules?: [ 
      {
        alarmContext?: {
          alarmContentSubTitle?: string(name='AlarmContentSubTitle'),
          alarmContentTemplate?: string(name='AlarmContentTemplate'),
          content?: string(name='Content'),
          subTitle?: string(name='SubTitle'),
        }(name='AlarmContext'),
        alertLevel?: string(name='AlertLevel'),
        alertRule?: {
          operator?: string(name='Operator'),
          rules?: [ 
            {
              aggregates?: string(name='Aggregates'),
              alias?: string(name='Alias'),
              measure?: string(name='Measure'),
              NValue?: int32(name='NValue'),
              operator?: string(name='Operator'),
              value?: float(name='Value'),
            }
          ](name='Rules'),
        }(name='AlertRule'),
        alertTitle?: string(name='AlertTitle'),
        alertType?: int32(name='AlertType'),
        alertVersion?: int32(name='AlertVersion'),
        alertWay?: [ string ](name='AlertWay'),
        alertWays?: [ string ](name='AlertWays'),
        config?: string(name='Config'),
        contactGroupIdList?: string(name='ContactGroupIdList'),
        contactGroupIds?: string(name='ContactGroupIds'),
        createTime?: long(name='CreateTime'),
        hostByAlertManager?: boolean(name='HostByAlertManager'),
        id?: long(name='Id'),
        metricParam?: {
          appGroupId?: string(name='AppGroupId'),
          appId?: string(name='AppId'),
          dimensions?: [ 
            {
              key?: string(name='Key'),
              type?: string(name='Type'),
              value?: string(name='Value'),
            }
          ](name='Dimensions'),
          pid?: string(name='Pid'),
          type?: string(name='Type'),
        }(name='MetricParam'),
        notice?: {
          endTime?: long(name='EndTime'),
          noticeEndTime?: long(name='NoticeEndTime'),
          noticeStartTime?: long(name='NoticeStartTime'),
          startTime?: long(name='StartTime'),
        }(name='Notice'),
        regionId?: string(name='RegionId'),
        status?: string(name='Status'),
        taskId?: long(name='TaskId'),
        taskStatus?: string(name='TaskStatus'),
        title?: string(name='Title'),
        updateTime?: long(name='UpdateTime'),
        userId?: string(name='UserId'),
      }
    ](name='AlertRules'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  body: SearchAlertRulesResponseBody(name='body'),
}

async function searchAlertRules(request: SearchAlertRulesRequest): SearchAlertRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchAlertRules', 'POST', '/', 'json', false, 'json', request);
}

model SearchEventsRequest {
  alertId?: long(name='AlertId', position='Query'),
  alertType?: int32(name='AlertType', position='Query'),
  appType?: string(name='AppType', position='Query'),
  currentPage?: int32(name='CurrentPage', position='Query'),
  endTime?: long(name='EndTime', position='Query'),
  isTrigger?: int32(name='IsTrigger', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  pid?: string(name='Pid', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  startTime?: long(name='StartTime', position='Query'),
}

model SearchEventsResponseBody = {
  isTrigger?: int32(name='IsTrigger'),
  pageBean?: {
    event?: [ 
      {
        alertId?: long(name='AlertId'),
        alertName?: string(name='AlertName'),
        alertRule?: string(name='AlertRule'),
        alertType?: int32(name='AlertType'),
        eventLevel?: string(name='EventLevel'),
        eventTime?: long(name='EventTime'),
        id?: long(name='Id'),
        links?: [ string ](name='Links'),
        message?: string(name='Message'),
      }
    ](name='Event'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchEventsResponse = {
  headers: map[string]string(name='headers'),
  body: SearchEventsResponseBody(name='body'),
}

async function searchEvents(request: SearchEventsRequest): SearchEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchEvents', 'POST', '/', 'json', false, 'json', request);
}

model SearchRetcodeAppByPageRequest {
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  retcodeAppName?: string(name='RetcodeAppName', position='Query'),
}

model SearchRetcodeAppByPageResponseBody = {
  pageBean?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    retcodeApps?: [ 
      {
        appId?: long(name='AppId'),
        appName?: string(name='AppName'),
        createTime?: long(name='CreateTime'),
        pid?: string(name='Pid'),
        regionId?: string(name='RegionId'),
        retcodeAppType?: string(name='RetcodeAppType'),
        type?: string(name='Type'),
        updateTime?: long(name='UpdateTime'),
        userId?: string(name='UserId'),
      }
    ](name='RetcodeApps'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchRetcodeAppByPageResponse = {
  headers: map[string]string(name='headers'),
  body: SearchRetcodeAppByPageResponseBody(name='body'),
}

async function searchRetcodeAppByPage(request: SearchRetcodeAppByPageRequest): SearchRetcodeAppByPageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchRetcodeAppByPage', 'POST', '/', 'json', false, 'json', request);
}

model SearchTraceAppByNameRequest {
  regionId: string(name='RegionId', position='Query'),
  traceAppName?: string(name='TraceAppName', position='Query'),
}

model SearchTraceAppByNameResponseBody = {
  requestId?: string(name='RequestId'),
  traceApps?: [ 
    {
      appId?: long(name='AppId'),
      appName?: string(name='AppName'),
      createTime?: long(name='CreateTime'),
      labels?: [ string ](name='Labels'),
      pid?: string(name='Pid'),
      regionId?: string(name='RegionId'),
      show?: boolean(name='Show'),
      type?: string(name='Type'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='TraceApps'),
}

model SearchTraceAppByNameResponse = {
  headers: map[string]string(name='headers'),
  body: SearchTraceAppByNameResponseBody(name='body'),
}

async function searchTraceAppByName(request: SearchTraceAppByNameRequest): SearchTraceAppByNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchTraceAppByName', 'POST', '/', 'json', false, 'json', request);
}

model SearchTraceAppByPageRequest {
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  traceAppName?: string(name='TraceAppName', position='Query'),
}

model SearchTraceAppByPageResponseBody = {
  pageBean?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    traceApps?: [ 
      {
        appId?: long(name='AppId'),
        appName?: string(name='AppName'),
        createTime?: long(name='CreateTime'),
        labels?: [ string ](name='Labels'),
        pid?: string(name='Pid'),
        regionId?: string(name='RegionId'),
        show?: boolean(name='Show'),
        type?: string(name='Type'),
        updateTime?: long(name='UpdateTime'),
        userId?: string(name='UserId'),
      }
    ](name='TraceApps'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchTraceAppByPageResponse = {
  headers: map[string]string(name='headers'),
  body: SearchTraceAppByPageResponseBody(name='body'),
}

async function searchTraceAppByPage(request: SearchTraceAppByPageRequest): SearchTraceAppByPageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchTraceAppByPage', 'POST', '/', 'json', false, 'json', request);
}

model SearchTracesRequest {
  endTime: long(name='EndTime', position='Query'),
  exclusionFilters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='ExclusionFilters', position='Query'),
  minDuration?: long(name='MinDuration', position='Query'),
  operationName?: string(name='OperationName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  reverse?: boolean(name='Reverse', position='Query'),
  serviceIp?: string(name='ServiceIp', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
  startTime: long(name='StartTime', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model SearchTracesResponseBody = {
  requestId?: string(name='RequestId'),
  traceInfos?: [ 
    {
      duration?: long(name='Duration'),
      operationName?: string(name='OperationName'),
      serviceIp?: string(name='ServiceIp'),
      serviceName?: string(name='ServiceName'),
      timestamp?: long(name='Timestamp'),
      traceID?: string(name='TraceID'),
    }
  ](name='TraceInfos'),
}

model SearchTracesResponse = {
  headers: map[string]string(name='headers'),
  body: SearchTracesResponseBody(name='body'),
}

async function searchTraces(request: SearchTracesRequest): SearchTracesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchTraces', 'POST', '/', 'json', false, 'json', request);
}

model SearchTracesByPageRequest {
  endTime: long(name='EndTime', position='Query'),
  exclusionFilters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='ExclusionFilters', position='Query'),
  minDuration?: long(name='MinDuration', position='Query'),
  operationName?: string(name='OperationName', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  reverse?: boolean(name='Reverse', position='Query'),
  serviceIp?: string(name='ServiceIp', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
  startTime: long(name='StartTime', position='Query'),
}

model SearchTracesByPageResponseBody = {
  pageBean?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
    traceInfos?: [ 
      {
        duration?: long(name='Duration'),
        operationName?: string(name='OperationName'),
        serviceIp?: string(name='ServiceIp'),
        serviceName?: string(name='ServiceName'),
        timestamp?: long(name='Timestamp'),
        traceID?: string(name='TraceID'),
      }
    ](name='TraceInfos'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchTracesByPageResponse = {
  headers: map[string]string(name='headers'),
  body: SearchTracesByPageResponseBody(name='body'),
}

async function searchTracesByPage(request: SearchTracesByPageRequest): SearchTracesByPageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchTracesByPage', 'POST', '/', 'json', false, 'json', request);
}

model SendTTSVerifyLinkRequest {
  contactId: long(name='ContactId', description='告警联系人ID', position='Body'),
  phone: string(name='Phone', description='告警联系人手机号码', position='Body'),
}

model SendTTSVerifyLinkResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SendTTSVerifyLinkResponse = {
  headers: map[string]string(name='headers'),
  body: SendTTSVerifyLinkResponseBody(name='body'),
}

async function sendTTSVerifyLink(request: SendTTSVerifyLinkRequest): SendTTSVerifyLinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SendTTSVerifyLink', 'POST', '/', 'json', true, 'form', request);
}

model SetRetcodeShareStatusRequest {
  pid: string(name='Pid', position='Query'),
  status: boolean(name='Status', position='Query'),
}

model SetRetcodeShareStatusResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model SetRetcodeShareStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetRetcodeShareStatusResponseBody(name='body'),
}

async function setRetcodeShareStatus(request: SetRetcodeShareStatusRequest): SetRetcodeShareStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetRetcodeShareStatus', 'POST', '/', 'json', false, 'json', request);
}

model StartAlertRequest {
  alertId: string(name='AlertId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model StartAlertResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model StartAlertResponse = {
  headers: map[string]string(name='headers'),
  body: StartAlertResponseBody(name='body'),
}

async function startAlert(request: StartAlertRequest): StartAlertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartAlert', 'POST', '/', 'json', false, 'json', request);
}

model StopAlertRequest {
  alertId: string(name='AlertId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model StopAlertResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model StopAlertResponse = {
  headers: map[string]string(name='headers'),
  body: StopAlertResponseBody(name='body'),
}

async function stopAlert(request: StopAlertRequest): StopAlertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopAlert', 'POST', '/', 'json', false, 'json', request);
}

model TurnOnSecondSwitchRequest {
  pid: string(name='Pid', position='Query'),
  proxyUserId?: string(name='ProxyUserId', position='Query'),
  regionId: string(name='RegionId', position='Host'),
  releaseStartTime: long(name='ReleaseStartTime', position='Query'),
}

model TurnOnSecondSwitchResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model TurnOnSecondSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: TurnOnSecondSwitchResponseBody(name='body'),
}

async function turnOnSecondSwitch(request: TurnOnSecondSwitchRequest): TurnOnSecondSwitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TurnOnSecondSwitch', 'GET', '/', 'json', false, 'json', request);
}

model UninstallManagedPrometheusRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  clusterType?: string(name='ClusterType', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model UninstallManagedPrometheusResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UninstallManagedPrometheusResponse = {
  headers: map[string]string(name='headers'),
  body: UninstallManagedPrometheusResponseBody(name='body'),
}

async function uninstallManagedPrometheus(request: UninstallManagedPrometheusRequest): UninstallManagedPrometheusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UninstallManagedPrometheus', 'POST', '/', 'json', false, 'json', request);
}

model UninstallPromClusterRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model UninstallPromClusterResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model UninstallPromClusterResponse = {
  headers: map[string]string(name='headers'),
  body: UninstallPromClusterResponseBody(name='body'),
}

async function uninstallPromCluster(request: UninstallPromClusterRequest): UninstallPromClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UninstallPromCluster', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  regionId: string(name='RegionId', position='Host'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tagKey?: [ string ](name='TagKey', position='Query'),
}

model UntagResourcesResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAlertContactRequest {
  contactId: long(name='ContactId', position='Query'),
  contactName?: string(name='ContactName', position='Query'),
  dingRobotWebhookUrl?: string(name='DingRobotWebhookUrl', position='Query'),
  email?: string(name='Email', position='Query'),
  phoneNum?: string(name='PhoneNum', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  systemNoc?: boolean(name='SystemNoc', position='Query'),
}

model UpdateAlertContactResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateAlertContactResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAlertContactResponseBody(name='body'),
}

async function updateAlertContact(request: UpdateAlertContactRequest): UpdateAlertContactResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAlertContact', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAlertContactGroupRequest {
  contactGroupId: long(name='ContactGroupId', position='Query'),
  contactGroupName: string(name='ContactGroupName', position='Query'),
  contactIds?: string(name='ContactIds', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UpdateAlertContactGroupResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateAlertContactGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAlertContactGroupResponseBody(name='body'),
}

async function updateAlertContactGroup(request: UpdateAlertContactGroupRequest): UpdateAlertContactGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAlertContactGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAlertRuleRequest {
  alertId: long(name='AlertId', position='Query'),
  contactGroupIds?: string(name='ContactGroupIds', position='Query'),
  isAutoStart?: boolean(name='IsAutoStart', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  templageAlertConfig: string(name='TemplageAlertConfig', position='Query'),
}

model UpdateAlertRuleResponseBody = {
  alertId?: long(name='AlertId'),
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAlertRuleResponseBody(name='body'),
}

async function updateAlertRule(request: UpdateAlertRuleRequest): UpdateAlertRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAlertRule', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDispatchRuleRequest {
  dispatchRule: string(name='DispatchRule', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UpdateDispatchRuleResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDispatchRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDispatchRuleResponseBody(name='body'),
}

async function updateDispatchRule(request: UpdateDispatchRuleRequest): UpdateDispatchRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDispatchRule', 'POST', '/', 'json', false, 'json', request);
}

model UpdatePrometheusAlertRuleRequest {
  alertId: long(name='AlertId', position='Query'),
  alertName: string(name='AlertName', position='Query'),
  annotations?: string(name='Annotations', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  dispatchRuleId?: long(name='DispatchRuleId', position='Query'),
  duration: string(name='Duration', position='Query'),
  expression: string(name='Expression', position='Query'),
  labels?: string(name='Labels', position='Query'),
  message: string(name='Message', position='Query'),
  notifyType?: string(name='NotifyType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type?: string(name='Type', position='Query'),
}

model UpdatePrometheusAlertRuleResponseBody = {
  prometheusAlertRule?: {
    alertId?: long(name='AlertId'),
    alertName?: string(name='AlertName'),
    annotations?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Annotations'),
    clusterId?: string(name='ClusterId'),
    dispatchRuleId?: long(name='DispatchRuleId'),
    duration?: string(name='Duration'),
    expression?: string(name='Expression'),
    labels?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Labels'),
    message?: string(name='Message'),
    notifyType?: string(name='NotifyType'),
    status?: int32(name='Status'),
    type?: string(name='Type'),
  }(name='PrometheusAlertRule'),
  requestId?: string(name='RequestId'),
}

model UpdatePrometheusAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePrometheusAlertRuleResponseBody(name='body'),
}

async function updatePrometheusAlertRule(request: UpdatePrometheusAlertRuleRequest): UpdatePrometheusAlertRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdatePrometheusAlertRule', 'POST', '/', 'json', false, 'json', request);
}

model UpdateWebhookRequest {
  body?: string(name='Body', position='Query'),
  contactId: long(name='ContactId', minimum=0, maximum=9223372036854775807, position='Query'),
  contactName?: string(name='ContactName', position='Query'),
  httpHeaders?: string(name='HttpHeaders', position='Query'),
  httpParams?: string(name='HttpParams', position='Query'),
  method?: string(name='Method', position='Query'),
  recoverBody?: string(name='RecoverBody', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  url?: string(name='Url', position='Query'),
}

model UpdateWebhookResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateWebhookResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWebhookResponseBody(name='body'),
}

async function updateWebhook(request: UpdateWebhookRequest): UpdateWebhookResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateWebhook', 'POST', '/', 'json', false, 'json', request);
}

