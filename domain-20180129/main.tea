/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  

  checkConfig(config);
  @endpoint = getEndpoint('domain', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AcknowledgeTaskResultRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  taskDetailNo?: [ string ](name='TaskDetailNo'),
}

model AcknowledgeTaskResultResponseBody = {
  requestId?: string(name='RequestId'),
  result?: int32(name='Result'),
}

model AcknowledgeTaskResultResponse = {
  headers: map[string]string(name='headers'),
  body: AcknowledgeTaskResultResponseBody(name='body'),
}

async function acknowledgeTaskResultWithOptions(request: AcknowledgeTaskResultRequest, runtime: Util.RuntimeOptions): AcknowledgeTaskResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AcknowledgeTaskResult', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function acknowledgeTaskResult(request: AcknowledgeTaskResultRequest): AcknowledgeTaskResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return acknowledgeTaskResultWithOptions(request, runtime);
}

model BatchFuzzyMatchDomainSensitiveWordRequest {
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model BatchFuzzyMatchDomainSensitiveWordResponseBody = {
  requestId?: string(name='RequestId'),
  sensitiveWordMatchResultList?: {
    sensitiveWordMatchResult?: [ 
    {
      keyword?: string(name='Keyword'),
      exist?: boolean(name='Exist'),
      matchedSentiveWords?: {
        matchedSensitiveWord?: [ 
        {
          word?: string(name='Word'),
        }
      ](name='MatchedSensitiveWord')
      }(name='MatchedSentiveWords'),
    }
  ](name='SensitiveWordMatchResult')
  }(name='SensitiveWordMatchResultList'),
}

model BatchFuzzyMatchDomainSensitiveWordResponse = {
  headers: map[string]string(name='headers'),
  body: BatchFuzzyMatchDomainSensitiveWordResponseBody(name='body'),
}

async function batchFuzzyMatchDomainSensitiveWordWithOptions(request: BatchFuzzyMatchDomainSensitiveWordRequest, runtime: Util.RuntimeOptions): BatchFuzzyMatchDomainSensitiveWordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('BatchFuzzyMatchDomainSensitiveWord', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function batchFuzzyMatchDomainSensitiveWord(request: BatchFuzzyMatchDomainSensitiveWordRequest): BatchFuzzyMatchDomainSensitiveWordResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchFuzzyMatchDomainSensitiveWordWithOptions(request, runtime);
}

model CancelDomainVerificationRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  instanceId?: string(name='InstanceId'),
  actionType?: string(name='ActionType'),
}

model CancelDomainVerificationResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelDomainVerificationResponse = {
  headers: map[string]string(name='headers'),
  body: CancelDomainVerificationResponseBody(name='body'),
}

async function cancelDomainVerificationWithOptions(request: CancelDomainVerificationRequest, runtime: Util.RuntimeOptions): CancelDomainVerificationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelDomainVerification', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelDomainVerification(request: CancelDomainVerificationRequest): CancelDomainVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelDomainVerificationWithOptions(request, runtime);
}

model CancelOperationAuditRequest {
  lang?: string(name='Lang'),
  auditRecordId?: long(name='AuditRecordId'),
}

model CancelOperationAuditResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelOperationAuditResponse = {
  headers: map[string]string(name='headers'),
  body: CancelOperationAuditResponseBody(name='body'),
}

async function cancelOperationAuditWithOptions(request: CancelOperationAuditRequest, runtime: Util.RuntimeOptions): CancelOperationAuditResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelOperationAudit', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelOperationAudit(request: CancelOperationAuditRequest): CancelOperationAuditResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelOperationAuditWithOptions(request, runtime);
}

model CancelQualificationVerificationRequest {
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
  instanceId?: string(name='InstanceId'),
  qualificationType?: string(name='QualificationType'),
}

model CancelQualificationVerificationResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelQualificationVerificationResponse = {
  headers: map[string]string(name='headers'),
  body: CancelQualificationVerificationResponseBody(name='body'),
}

async function cancelQualificationVerificationWithOptions(request: CancelQualificationVerificationRequest, runtime: Util.RuntimeOptions): CancelQualificationVerificationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelQualificationVerification', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelQualificationVerification(request: CancelQualificationVerificationRequest): CancelQualificationVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelQualificationVerificationWithOptions(request, runtime);
}

model CancelTaskRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  taskNo?: string(name='TaskNo'),
}

model CancelTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CancelTaskResponseBody(name='body'),
}

async function cancelTaskWithOptions(request: CancelTaskRequest, runtime: Util.RuntimeOptions): CancelTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelTask', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelTask(request: CancelTaskRequest): CancelTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelTaskWithOptions(request, runtime);
}

model CheckDomainRequest {
  domainName?: string(name='DomainName'),
  feeCommand?: string(name='FeeCommand'),
  feeCurrency?: string(name='FeeCurrency'),
  feePeriod?: int32(name='FeePeriod'),
  lang?: string(name='Lang'),
}

model CheckDomainResponseBody = {
  requestId?: string(name='RequestId'),
  avail?: string(name='Avail'),
  price?: long(name='Price'),
  domainName?: string(name='DomainName'),
  premium?: string(name='Premium'),
  dynamicCheck?: boolean(name='DynamicCheck'),
  reason?: string(name='Reason'),
}

model CheckDomainResponse = {
  headers: map[string]string(name='headers'),
  body: CheckDomainResponseBody(name='body'),
}

async function checkDomainWithOptions(request: CheckDomainRequest, runtime: Util.RuntimeOptions): CheckDomainResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CheckDomain', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function checkDomain(request: CheckDomainRequest): CheckDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkDomainWithOptions(request, runtime);
}

model CheckDomainSunriseClaimRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model CheckDomainSunriseClaimResponseBody = {
  claimKey?: string(name='ClaimKey'),
  requestId?: string(name='RequestId'),
  result?: int32(name='Result'),
}

model CheckDomainSunriseClaimResponse = {
  headers: map[string]string(name='headers'),
  body: CheckDomainSunriseClaimResponseBody(name='body'),
}

async function checkDomainSunriseClaimWithOptions(request: CheckDomainSunriseClaimRequest, runtime: Util.RuntimeOptions): CheckDomainSunriseClaimResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CheckDomainSunriseClaim', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function checkDomainSunriseClaim(request: CheckDomainSunriseClaimRequest): CheckDomainSunriseClaimResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkDomainSunriseClaimWithOptions(request, runtime);
}

model CheckMaxYearOfServerLockRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
  checkAction?: string(name='CheckAction'),
}

model CheckMaxYearOfServerLockResponseBody = {
  requestId?: string(name='RequestId'),
  maxYear?: int32(name='MaxYear'),
}

model CheckMaxYearOfServerLockResponse = {
  headers: map[string]string(name='headers'),
  body: CheckMaxYearOfServerLockResponseBody(name='body'),
}

async function checkMaxYearOfServerLockWithOptions(request: CheckMaxYearOfServerLockRequest, runtime: Util.RuntimeOptions): CheckMaxYearOfServerLockResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CheckMaxYearOfServerLock', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function checkMaxYearOfServerLock(request: CheckMaxYearOfServerLockRequest): CheckMaxYearOfServerLockResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkMaxYearOfServerLockWithOptions(request, runtime);
}

model CheckProcessingServerLockApplyRequest {
  feePeriod?: int32(name='FeePeriod'),
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model CheckProcessingServerLockApplyResponseBody = {
  requestId?: string(name='RequestId'),
  exists?: boolean(name='Exists'),
}

model CheckProcessingServerLockApplyResponse = {
  headers: map[string]string(name='headers'),
  body: CheckProcessingServerLockApplyResponseBody(name='body'),
}

async function checkProcessingServerLockApplyWithOptions(request: CheckProcessingServerLockApplyRequest, runtime: Util.RuntimeOptions): CheckProcessingServerLockApplyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CheckProcessingServerLockApply', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function checkProcessingServerLockApply(request: CheckProcessingServerLockApplyRequest): CheckProcessingServerLockApplyResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkProcessingServerLockApplyWithOptions(request, runtime);
}

model CheckTransferInFeasibilityRequest {
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
  domainName?: string(name='DomainName'),
  transferAuthorizationCode?: string(name='TransferAuthorizationCode'),
}

model CheckTransferInFeasibilityResponseBody = {
  canTransfer?: boolean(name='CanTransfer'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  productId?: string(name='ProductId'),
  code?: string(name='Code'),
}

model CheckTransferInFeasibilityResponse = {
  headers: map[string]string(name='headers'),
  body: CheckTransferInFeasibilityResponseBody(name='body'),
}

async function checkTransferInFeasibilityWithOptions(request: CheckTransferInFeasibilityRequest, runtime: Util.RuntimeOptions): CheckTransferInFeasibilityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CheckTransferInFeasibility', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function checkTransferInFeasibility(request: CheckTransferInFeasibilityRequest): CheckTransferInFeasibilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkTransferInFeasibilityWithOptions(request, runtime);
}

model ConfirmTransferInEmailRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  email?: string(name='Email'),
  domainName?: [ string ](name='DomainName'),
}

model ConfirmTransferInEmailResponseBody = {
  requestId?: string(name='RequestId'),
  successList?: {
    successDomain?: [ string ](name='SuccessDomain')
  }(name='SuccessList'),
  failList?: {
    failDomain?: [ string ](name='FailDomain')
  }(name='FailList'),
}

model ConfirmTransferInEmailResponse = {
  headers: map[string]string(name='headers'),
  body: ConfirmTransferInEmailResponseBody(name='body'),
}

async function confirmTransferInEmailWithOptions(request: ConfirmTransferInEmailRequest, runtime: Util.RuntimeOptions): ConfirmTransferInEmailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConfirmTransferInEmail', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function confirmTransferInEmail(request: ConfirmTransferInEmailRequest): ConfirmTransferInEmailResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmTransferInEmailWithOptions(request, runtime);
}

model DeleteDomainGroupRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  domainGroupId?: long(name='DomainGroupId'),
}

model DeleteDomainGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDomainGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDomainGroupResponseBody(name='body'),
}

async function deleteDomainGroupWithOptions(request: DeleteDomainGroupRequest, runtime: Util.RuntimeOptions): DeleteDomainGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteDomainGroup', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteDomainGroup(request: DeleteDomainGroupRequest): DeleteDomainGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDomainGroupWithOptions(request, runtime);
}

model DeleteEmailVerificationRequest {
  lang?: string(name='Lang'),
  email?: string(name='Email'),
  userClientIp?: string(name='UserClientIp'),
}

model DeleteEmailVerificationResponseBody = {
  requestId?: string(name='RequestId'),
  successList?: [ 
    {
      email?: string(name='Email'),
      code?: string(name='Code'),
      message?: string(name='Message'),
    }
  ](name='SuccessList'),
  failList?: [ 
    {
      email?: string(name='Email'),
      code?: string(name='Code'),
      message?: string(name='Message'),
    }
  ](name='FailList'),
}

model DeleteEmailVerificationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEmailVerificationResponseBody(name='body'),
}

async function deleteEmailVerificationWithOptions(request: DeleteEmailVerificationRequest, runtime: Util.RuntimeOptions): DeleteEmailVerificationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteEmailVerification', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteEmailVerification(request: DeleteEmailVerificationRequest): DeleteEmailVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEmailVerificationWithOptions(request, runtime);
}

model DeleteRegistrantProfileRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  registrantProfileId?: long(name='RegistrantProfileId'),
}

model DeleteRegistrantProfileResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRegistrantProfileResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRegistrantProfileResponseBody(name='body'),
}

async function deleteRegistrantProfileWithOptions(request: DeleteRegistrantProfileRequest, runtime: Util.RuntimeOptions): DeleteRegistrantProfileResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteRegistrantProfile', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteRegistrantProfile(request: DeleteRegistrantProfileRequest): DeleteRegistrantProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRegistrantProfileWithOptions(request, runtime);
}

model EmailVerifiedRequest {
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
  email?: string(name='Email'),
}

model EmailVerifiedResponseBody = {
  requestId?: string(name='RequestId'),
}

model EmailVerifiedResponse = {
  headers: map[string]string(name='headers'),
  body: EmailVerifiedResponseBody(name='body'),
}

async function emailVerifiedWithOptions(request: EmailVerifiedRequest, runtime: Util.RuntimeOptions): EmailVerifiedResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EmailVerified', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function emailVerified(request: EmailVerifiedRequest): EmailVerifiedResponse {
  var runtime = new Util.RuntimeOptions{};
  return emailVerifiedWithOptions(request, runtime);
}

model FuzzyMatchDomainSensitiveWordRequest {
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model FuzzyMatchDomainSensitiveWordResponseBody = {
  exist?: boolean(name='Exist'),
  requestId?: string(name='RequestId'),
  keyword?: string(name='Keyword'),
  matchedSentiveWords?: {
    matchedSensitiveWord?: [ 
    {
      word?: string(name='Word'),
    }
  ](name='MatchedSensitiveWord')
  }(name='MatchedSentiveWords'),
}

model FuzzyMatchDomainSensitiveWordResponse = {
  headers: map[string]string(name='headers'),
  body: FuzzyMatchDomainSensitiveWordResponseBody(name='body'),
}

async function fuzzyMatchDomainSensitiveWordWithOptions(request: FuzzyMatchDomainSensitiveWordRequest, runtime: Util.RuntimeOptions): FuzzyMatchDomainSensitiveWordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('FuzzyMatchDomainSensitiveWord', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function fuzzyMatchDomainSensitiveWord(request: FuzzyMatchDomainSensitiveWordRequest): FuzzyMatchDomainSensitiveWordResponse {
  var runtime = new Util.RuntimeOptions{};
  return fuzzyMatchDomainSensitiveWordWithOptions(request, runtime);
}

model GetOperationOssUploadPolicyRequest {
  lang?: string(name='Lang'),
  auditType?: int32(name='AuditType'),
}

model GetOperationOssUploadPolicyResponseBody = {
  fileDir?: string(name='FileDir'),
  encodedPolicy?: string(name='EncodedPolicy'),
  requestId?: string(name='RequestId'),
  accessid?: string(name='Accessid'),
  signature?: string(name='Signature'),
  host?: string(name='Host'),
  expireTime?: string(name='ExpireTime'),
}

model GetOperationOssUploadPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: GetOperationOssUploadPolicyResponseBody(name='body'),
}

async function getOperationOssUploadPolicyWithOptions(request: GetOperationOssUploadPolicyRequest, runtime: Util.RuntimeOptions): GetOperationOssUploadPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetOperationOssUploadPolicy', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getOperationOssUploadPolicy(request: GetOperationOssUploadPolicyRequest): GetOperationOssUploadPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOperationOssUploadPolicyWithOptions(request, runtime);
}

model GetQualificationUploadPolicyRequest {
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model GetQualificationUploadPolicyResponseBody = {
  policy?: string(name='Policy'),
  expire?: string(name='Expire'),
  requestId?: string(name='RequestId'),
  accessid?: string(name='Accessid'),
  signature?: string(name='Signature'),
  host?: string(name='Host'),
  prefix?: string(name='Prefix'),
  dir?: string(name='Dir'),
}

model GetQualificationUploadPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: GetQualificationUploadPolicyResponseBody(name='body'),
}

async function getQualificationUploadPolicyWithOptions(request: GetQualificationUploadPolicyRequest, runtime: Util.RuntimeOptions): GetQualificationUploadPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetQualificationUploadPolicy', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getQualificationUploadPolicy(request: GetQualificationUploadPolicyRequest): GetQualificationUploadPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQualificationUploadPolicyWithOptions(request, runtime);
}

model ListEmailVerificationRequest {
  lang?: string(name='Lang'),
  beginCreateTime?: long(name='BeginCreateTime'),
  endCreateTime?: long(name='EndCreateTime'),
  email?: string(name='Email'),
  verificationStatus?: int32(name='VerificationStatus'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  userClientIp?: string(name='UserClientIp'),
}

model ListEmailVerificationResponseBody = {
  prePage?: boolean(name='PrePage'),
  currentPageNum?: int32(name='CurrentPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalPageNum?: int32(name='TotalPageNum'),
  data?: [ 
    {
      verificationTime?: string(name='VerificationTime'),
      email?: string(name='Email'),
      emailVerificationNo?: string(name='EmailVerificationNo'),
      userId?: string(name='UserId'),
      gmtCreate?: string(name='GmtCreate'),
      verificationStatus?: int32(name='VerificationStatus'),
      tokenSendTime?: string(name='TokenSendTime'),
      sendIp?: string(name='SendIp'),
      gmtModified?: string(name='GmtModified'),
      confirmIp?: string(name='ConfirmIp'),
    }
  ](name='Data'),
  totalItemNum?: int32(name='TotalItemNum'),
  nextPage?: boolean(name='NextPage'),
}

model ListEmailVerificationResponse = {
  headers: map[string]string(name='headers'),
  body: ListEmailVerificationResponseBody(name='body'),
}

async function listEmailVerificationWithOptions(request: ListEmailVerificationRequest, runtime: Util.RuntimeOptions): ListEmailVerificationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListEmailVerification', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listEmailVerification(request: ListEmailVerificationRequest): ListEmailVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEmailVerificationWithOptions(request, runtime);
}

model ListServerLockRequest {
  domainName?: string(name='DomainName'),
  endStartDate?: long(name='EndStartDate'),
  beginStartDate?: long(name='BeginStartDate'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  lang?: string(name='Lang'),
  lockProductId?: string(name='LockProductId'),
  serverLockStatus?: int32(name='ServerLockStatus'),
  startExpireDate?: long(name='StartExpireDate'),
  endExpireDate?: long(name='EndExpireDate'),
  userClientIp?: string(name='UserClientIp'),
}

model ListServerLockResponseBody = {
  prePage?: boolean(name='PrePage'),
  currentPageNum?: int32(name='CurrentPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalPageNum?: int32(name='TotalPageNum'),
  data?: [ 
    {
      serverLockStatus?: string(name='ServerLockStatus'),
      lockInstanceId?: string(name='LockInstanceId'),
      userId?: string(name='UserId'),
      gmtCreate?: string(name='GmtCreate'),
      expireDate?: string(name='ExpireDate'),
      startDate?: string(name='StartDate'),
      lockProductId?: string(name='LockProductId'),
      domainInstanceId?: string(name='DomainInstanceId'),
      gmtModified?: string(name='GmtModified'),
      domainName?: string(name='DomainName'),
    }
  ](name='Data'),
  totalItemNum?: int32(name='TotalItemNum'),
  nextPage?: boolean(name='NextPage'),
}

model ListServerLockResponse = {
  headers: map[string]string(name='headers'),
  body: ListServerLockResponseBody(name='body'),
}

async function listServerLockWithOptions(request: ListServerLockRequest, runtime: Util.RuntimeOptions): ListServerLockResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListServerLock', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listServerLock(request: ListServerLockRequest): ListServerLockResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServerLockWithOptions(request, runtime);
}

model LookupTmchNoticeRequest {
  claimKey?: string(name='ClaimKey'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model LookupTmchNoticeResponseBody = {
  claims?: {
    claim?: [ 
    {
      goodsAndServices?: string(name='GoodsAndServices'),
      contacts?: {
        contact?: [ 
        {
          type?: string(name='Type'),
          voice?: string(name='Voice'),
          email?: string(name='Email'),
          fax?: string(name='Fax'),
          addr?: {
            cc?: string(name='Cc'),
            sp?: string(name='Sp'),
            pc?: string(name='Pc'),
            city?: string(name='City'),
            street?: {
              street?: [ string ](name='Street')
            }(name='Street'),
          }(name='Addr'),
          org?: string(name='Org'),
          name?: string(name='Name'),
        }
      ](name='Contact')
      }(name='Contacts'),
      markName?: string(name='MarkName'),
      classDescs?: {
        classDesc?: [ 
        {
          classNum?: int32(name='ClassNum'),
          desc?: string(name='Desc'),
        }
      ](name='ClassDesc')
      }(name='ClassDescs'),
      holders?: {
        holder?: [ 
        {
          entitlement?: string(name='Entitlement'),
          addr?: {
            cc?: string(name='Cc'),
            sp?: string(name='Sp'),
            pc?: string(name='Pc'),
            city?: string(name='City'),
            street?: {
              street?: [ string ](name='Street')
            }(name='Street'),
          }(name='Addr'),
          org?: string(name='Org'),
        }
      ](name='Holder')
      }(name='Holders'),
      jurDesc?: {
        jurCC?: string(name='JurCC'),
        desc?: string(name='Desc'),
      }(name='JurDesc'),
    }
  ](name='Claim')
  }(name='Claims'),
  requestId?: string(name='RequestId'),
  label?: string(name='Label'),
  id?: long(name='Id'),
  notBefore?: string(name='NotBefore'),
  notAfter?: string(name='NotAfter'),
}

model LookupTmchNoticeResponse = {
  headers: map[string]string(name='headers'),
  body: LookupTmchNoticeResponseBody(name='body'),
}

async function lookupTmchNoticeWithOptions(request: LookupTmchNoticeRequest, runtime: Util.RuntimeOptions): LookupTmchNoticeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('LookupTmchNotice', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function lookupTmchNotice(request: LookupTmchNoticeRequest): LookupTmchNoticeResponse {
  var runtime = new Util.RuntimeOptions{};
  return lookupTmchNoticeWithOptions(request, runtime);
}

model PollTaskResultRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  taskNo?: string(name='TaskNo'),
  domainName?: string(name='DomainName'),
  instanceId?: string(name='InstanceId'),
  taskResultStatus?: int32(name='TaskResultStatus'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model PollTaskResultResponseBody = {
  prePage?: boolean(name='PrePage'),
  currentPageNum?: int32(name='CurrentPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalPageNum?: int32(name='TotalPageNum'),
  data?: {
    taskDetail?: [ 
    {
      updateTime?: string(name='UpdateTime'),
      taskDetailNo?: string(name='TaskDetailNo'),
      createTime?: string(name='CreateTime'),
      instanceId?: string(name='InstanceId'),
      domainName?: string(name='DomainName'),
      taskType?: string(name='TaskType'),
      taskNo?: string(name='TaskNo'),
      taskResult?: string(name='TaskResult'),
      taskStatusCode?: int32(name='TaskStatusCode'),
      taskStatus?: string(name='TaskStatus'),
      taskTypeDescription?: string(name='TaskTypeDescription'),
      tryCount?: int32(name='TryCount'),
      errorMsg?: string(name='ErrorMsg'),
    }
  ](name='TaskDetail')
  }(name='Data'),
  totalItemNum?: int32(name='TotalItemNum'),
  nextPage?: boolean(name='NextPage'),
}

model PollTaskResultResponse = {
  headers: map[string]string(name='headers'),
  body: PollTaskResultResponseBody(name='body'),
}

async function pollTaskResultWithOptions(request: PollTaskResultRequest, runtime: Util.RuntimeOptions): PollTaskResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PollTaskResult', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function pollTaskResult(request: PollTaskResultRequest): PollTaskResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return pollTaskResultWithOptions(request, runtime);
}

model QueryAdvancedDomainListRequest {
  endExpirationDate?: long(name='EndExpirationDate'),
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  startExpirationDate?: long(name='StartExpirationDate'),
  productDomainType?: string(name='ProductDomainType'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  domainGroupId?: long(name='DomainGroupId'),
  domainNameSort?: boolean(name='DomainNameSort'),
  domainStatus?: int32(name='DomainStatus'),
  endLength?: int32(name='EndLength'),
  excluded?: string(name='Excluded'),
  excludedPrefix?: boolean(name='ExcludedPrefix'),
  excludedSuffix?: boolean(name='ExcludedSuffix'),
  expirationDateSort?: boolean(name='ExpirationDateSort'),
  form?: int32(name='Form'),
  keyWord?: string(name='KeyWord'),
  keyWordPrefix?: boolean(name='KeyWordPrefix'),
  keyWordSuffix?: boolean(name='KeyWordSuffix'),
  productDomainTypeSort?: boolean(name='ProductDomainTypeSort'),
  registrationDateSort?: boolean(name='RegistrationDateSort'),
  startLength?: int32(name='StartLength'),
  tradeType?: int32(name='TradeType'),
  suffixs?: string(name='Suffixs'),
  startRegistrationDate?: long(name='StartRegistrationDate'),
  endRegistrationDate?: long(name='EndRegistrationDate'),
}

model QueryAdvancedDomainListResponseBody = {
  prePage?: boolean(name='PrePage'),
  currentPageNum?: int32(name='CurrentPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalPageNum?: int32(name='TotalPageNum'),
  data?: {
    domain?: [ 
    {
      domainAuditStatus?: string(name='DomainAuditStatus'),
      domainGroupId?: string(name='DomainGroupId'),
      remark?: string(name='Remark'),
      domainGroupName?: string(name='DomainGroupName'),
      zhRegistrantOrganization?: string(name='ZhRegistrantOrganization'),
      registrantOrganization?: string(name='RegistrantOrganization'),
      registrationDate?: string(name='RegistrationDate'),
      instanceId?: string(name='InstanceId'),
      domainName?: string(name='DomainName'),
      expirationDateStatus?: string(name='ExpirationDateStatus'),
      expirationDate?: string(name='ExpirationDate'),
      dnsList?: {
        dns?: [ string ](name='Dns')
      }(name='DnsList'),
      email?: string(name='Email'),
      registrantType?: string(name='RegistrantType'),
      expirationDateLong?: long(name='ExpirationDateLong'),
      expirationCurrDateDiff?: int32(name='ExpirationCurrDateDiff'),
      premium?: boolean(name='Premium'),
      registrationDateLong?: long(name='RegistrationDateLong'),
      productId?: string(name='ProductId'),
      domainStatus?: string(name='DomainStatus'),
      domainType?: string(name='DomainType'),
    }
  ](name='Domain')
  }(name='Data'),
  totalItemNum?: int32(name='TotalItemNum'),
  nextPage?: boolean(name='NextPage'),
}

model QueryAdvancedDomainListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAdvancedDomainListResponseBody(name='body'),
}

async function queryAdvancedDomainListWithOptions(request: QueryAdvancedDomainListRequest, runtime: Util.RuntimeOptions): QueryAdvancedDomainListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryAdvancedDomainList', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryAdvancedDomainList(request: QueryAdvancedDomainListRequest): QueryAdvancedDomainListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAdvancedDomainListWithOptions(request, runtime);
}

model QueryArtExtensionRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryArtExtensionResponseBody = {
  objectType?: string(name='ObjectType'),
  materialsAndTechniques?: string(name='MaterialsAndTechniques'),
  inscriptionsAndMarkings?: string(name='InscriptionsAndMarkings'),
  requestId?: string(name='RequestId'),
  reference?: string(name='Reference'),
  dateOrPeriod?: string(name='DateOrPeriod'),
  dimensions?: string(name='Dimensions'),
  title?: string(name='Title'),
  features?: string(name='Features'),
  subject?: string(name='Subject'),
  maker?: string(name='Maker'),
}

model QueryArtExtensionResponse = {
  headers: map[string]string(name='headers'),
  body: QueryArtExtensionResponseBody(name='body'),
}

async function queryArtExtensionWithOptions(request: QueryArtExtensionRequest, runtime: Util.RuntimeOptions): QueryArtExtensionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryArtExtension', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryArtExtension(request: QueryArtExtensionRequest): QueryArtExtensionResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryArtExtensionWithOptions(request, runtime);
}

model QueryChangeLogListRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  domainName?: string(name='DomainName'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  startDate?: long(name='StartDate'),
  endDate?: long(name='EndDate'),
}

model QueryChangeLogListResponseBody = {
  prePage?: boolean(name='PrePage'),
  currentPageNum?: int32(name='CurrentPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalPageNum?: int32(name='TotalPageNum'),
  data?: {
    changeLog?: [ 
    {
      operation?: string(name='Operation'),
      time?: string(name='Time'),
      result?: string(name='Result'),
      domainName?: string(name='DomainName'),
      operationIPAddress?: string(name='OperationIPAddress'),
      details?: string(name='Details'),
    }
  ](name='ChangeLog')
  }(name='Data'),
  resultLimit?: boolean(name='ResultLimit'),
  totalItemNum?: int32(name='TotalItemNum'),
  nextPage?: boolean(name='NextPage'),
}

model QueryChangeLogListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryChangeLogListResponseBody(name='body'),
}

async function queryChangeLogListWithOptions(request: QueryChangeLogListRequest, runtime: Util.RuntimeOptions): QueryChangeLogListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryChangeLogList', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryChangeLogList(request: QueryChangeLogListRequest): QueryChangeLogListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryChangeLogListWithOptions(request, runtime);
}

model QueryContactInfoRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  domainName?: string(name='DomainName'),
  contactType?: string(name='ContactType'),
}

model QueryContactInfoResponseBody = {
  zhProvince?: string(name='ZhProvince'),
  email?: string(name='Email'),
  telephone?: string(name='Telephone'),
  requestId?: string(name='RequestId'),
  address?: string(name='Address'),
  postalCode?: string(name='PostalCode'),
  zhRegistrantName?: string(name='ZhRegistrantName'),
  city?: string(name='City'),
  createDate?: string(name='CreateDate'),
  province?: string(name='Province'),
  zhCity?: string(name='ZhCity'),
  registrantName?: string(name='RegistrantName'),
  zhRegistrantOrganization?: string(name='ZhRegistrantOrganization'),
  country?: string(name='Country'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  telExt?: string(name='TelExt'),
  telArea?: string(name='TelArea'),
  zhAddress?: string(name='ZhAddress'),
}

model QueryContactInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryContactInfoResponseBody(name='body'),
}

async function queryContactInfoWithOptions(request: QueryContactInfoRequest, runtime: Util.RuntimeOptions): QueryContactInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryContactInfo', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryContactInfo(request: QueryContactInfoRequest): QueryContactInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryContactInfoWithOptions(request, runtime);
}

model QueryDnsHostRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryDnsHostResponseBody = {
  requestId?: string(name='RequestId'),
  dnsHostList?: [ 
    {
      dnsName?: string(name='DnsName'),
      ipList?: [ string ](name='IpList'),
    }
  ](name='DnsHostList'),
}

model QueryDnsHostResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDnsHostResponseBody(name='body'),
}

async function queryDnsHostWithOptions(request: QueryDnsHostRequest, runtime: Util.RuntimeOptions): QueryDnsHostResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryDnsHost', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryDnsHost(request: QueryDnsHostRequest): QueryDnsHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDnsHostWithOptions(request, runtime);
}

model QueryDomainAdminDivisionRequest {
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryDomainAdminDivisionResponseBody = {
  requestId?: string(name='RequestId'),
  adminDivisions?: {
    adminDivision?: [ 
    {
      divisionName?: string(name='DivisionName'),
      children?: {
        children?: [ 
        {
          childDivisionName?: string(name='ChildDivisionName'),
        }
      ](name='Children')
      }(name='Children'),
    }
  ](name='AdminDivision')
  }(name='AdminDivisions'),
}

model QueryDomainAdminDivisionResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDomainAdminDivisionResponseBody(name='body'),
}

async function queryDomainAdminDivisionWithOptions(request: QueryDomainAdminDivisionRequest, runtime: Util.RuntimeOptions): QueryDomainAdminDivisionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryDomainAdminDivision', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryDomainAdminDivision(request: QueryDomainAdminDivisionRequest): QueryDomainAdminDivisionResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDomainAdminDivisionWithOptions(request, runtime);
}

model QueryDomainByDomainNameRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  domainName?: string(name='DomainName'),
}

model QueryDomainByDomainNameResponseBody = {
  email?: string(name='Email'),
  registrationDate?: string(name='RegistrationDate'),
  registrationDateLong?: long(name='RegistrationDateLong'),
  realNameStatus?: string(name='RealNameStatus'),
  premium?: boolean(name='Premium'),
  domainNameVerificationStatus?: string(name='DomainNameVerificationStatus'),
  expirationDateLong?: long(name='ExpirationDateLong'),
  dnsList?: {
    dns?: [ string ](name='Dns')
  }(name='DnsList'),
  transferOutStatus?: string(name='TransferOutStatus'),
  zhRegistrantOrganization?: string(name='ZhRegistrantOrganization'),
  emailVerificationClientHold?: boolean(name='EmailVerificationClientHold'),
  emailVerificationStatus?: int32(name='EmailVerificationStatus'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  transferProhibitionLock?: string(name='TransferProhibitionLock'),
  domainNameProxyService?: boolean(name='DomainNameProxyService'),
  registrantType?: string(name='RegistrantType'),
  registrantUpdatingStatus?: string(name='RegistrantUpdatingStatus'),
  requestId?: string(name='RequestId'),
  domainName?: string(name='DomainName'),
  instanceId?: string(name='InstanceId'),
  zhRegistrantName?: string(name='ZhRegistrantName'),
  expirationDate?: string(name='ExpirationDate'),
  registrantName?: string(name='RegistrantName'),
  userId?: string(name='UserId'),
  updateProhibitionLock?: string(name='UpdateProhibitionLock'),
}

model QueryDomainByDomainNameResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDomainByDomainNameResponseBody(name='body'),
}

async function queryDomainByDomainNameWithOptions(request: QueryDomainByDomainNameRequest, runtime: Util.RuntimeOptions): QueryDomainByDomainNameResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryDomainByDomainName', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryDomainByDomainName(request: QueryDomainByDomainNameRequest): QueryDomainByDomainNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDomainByDomainNameWithOptions(request, runtime);
}

model QueryDomainByInstanceIdRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  instanceId?: string(name='InstanceId'),
}

model QueryDomainByInstanceIdResponseBody = {
  email?: string(name='Email'),
  registrationDate?: string(name='RegistrationDate'),
  registrationDateLong?: long(name='RegistrationDateLong'),
  realNameStatus?: string(name='RealNameStatus'),
  premium?: boolean(name='Premium'),
  domainNameVerificationStatus?: string(name='DomainNameVerificationStatus'),
  expirationDateLong?: long(name='ExpirationDateLong'),
  dnsList?: {
    dns?: [ string ](name='Dns')
  }(name='DnsList'),
  transferOutStatus?: string(name='TransferOutStatus'),
  zhRegistrantOrganization?: string(name='ZhRegistrantOrganization'),
  emailVerificationClientHold?: boolean(name='EmailVerificationClientHold'),
  emailVerificationStatus?: int32(name='EmailVerificationStatus'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  transferProhibitionLock?: string(name='TransferProhibitionLock'),
  domainNameProxyService?: boolean(name='DomainNameProxyService'),
  registrantType?: string(name='RegistrantType'),
  registrantUpdatingStatus?: string(name='RegistrantUpdatingStatus'),
  requestId?: string(name='RequestId'),
  domainName?: string(name='DomainName'),
  instanceId?: string(name='InstanceId'),
  zhRegistrantName?: string(name='ZhRegistrantName'),
  expirationDate?: string(name='ExpirationDate'),
  registrantName?: string(name='RegistrantName'),
  userId?: string(name='UserId'),
  updateProhibitionLock?: string(name='UpdateProhibitionLock'),
}

model QueryDomainByInstanceIdResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDomainByInstanceIdResponseBody(name='body'),
}

async function queryDomainByInstanceIdWithOptions(request: QueryDomainByInstanceIdRequest, runtime: Util.RuntimeOptions): QueryDomainByInstanceIdResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryDomainByInstanceId', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryDomainByInstanceId(request: QueryDomainByInstanceIdRequest): QueryDomainByInstanceIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDomainByInstanceIdWithOptions(request, runtime);
}

model QueryDomainGroupListRequest {
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
  domainGroupName?: string(name='DomainGroupName'),
  showDeletingGroup?: boolean(name='ShowDeletingGroup'),
}

model QueryDomainGroupListResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    domainGroup?: [ 
    {
      beingDeleted?: boolean(name='BeingDeleted'),
      domainGroupStatus?: string(name='DomainGroupStatus'),
      domainGroupId?: string(name='DomainGroupId'),
      domainGroupName?: string(name='DomainGroupName'),
      modificationDate?: string(name='ModificationDate'),
      totalNumber?: int32(name='TotalNumber'),
      creationDate?: string(name='CreationDate'),
    }
  ](name='DomainGroup')
  }(name='Data'),
}

model QueryDomainGroupListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDomainGroupListResponseBody(name='body'),
}

async function queryDomainGroupListWithOptions(request: QueryDomainGroupListRequest, runtime: Util.RuntimeOptions): QueryDomainGroupListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryDomainGroupList', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryDomainGroupList(request: QueryDomainGroupListRequest): QueryDomainGroupListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDomainGroupListWithOptions(request, runtime);
}

model QueryDomainListRequest {
  endExpirationDate?: long(name='EndExpirationDate'),
  startExpirationDate?: long(name='StartExpirationDate'),
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  queryType?: string(name='QueryType'),
  startRegistrationDate?: long(name='StartRegistrationDate'),
  endRegistrationDate?: long(name='EndRegistrationDate'),
  domainName?: string(name='DomainName'),
  orderByType?: string(name='OrderByType'),
  orderKeyType?: string(name='OrderKeyType'),
  productDomainType?: string(name='ProductDomainType'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  domainGroupId?: string(name='DomainGroupId'),
}

model QueryDomainListResponseBody = {
  prePage?: boolean(name='PrePage'),
  currentPageNum?: int32(name='CurrentPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalPageNum?: int32(name='TotalPageNum'),
  data?: {
    domain?: [ 
    {
      domainAuditStatus?: string(name='DomainAuditStatus'),
      domainGroupId?: string(name='DomainGroupId'),
      remark?: string(name='Remark'),
      domainGroupName?: string(name='DomainGroupName'),
      registrationDate?: string(name='RegistrationDate'),
      instanceId?: string(name='InstanceId'),
      domainName?: string(name='DomainName'),
      expirationDateStatus?: string(name='ExpirationDateStatus'),
      expirationDate?: string(name='ExpirationDate'),
      registrantType?: string(name='RegistrantType'),
      expirationDateLong?: long(name='ExpirationDateLong'),
      expirationCurrDateDiff?: int32(name='ExpirationCurrDateDiff'),
      premium?: boolean(name='Premium'),
      registrationDateLong?: long(name='RegistrationDateLong'),
      productId?: string(name='ProductId'),
      domainStatus?: string(name='DomainStatus'),
      domainType?: string(name='DomainType'),
    }
  ](name='Domain')
  }(name='Data'),
  totalItemNum?: int32(name='TotalItemNum'),
  nextPage?: boolean(name='NextPage'),
}

model QueryDomainListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDomainListResponseBody(name='body'),
}

async function queryDomainListWithOptions(request: QueryDomainListRequest, runtime: Util.RuntimeOptions): QueryDomainListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryDomainList', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryDomainList(request: QueryDomainListRequest): QueryDomainListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDomainListWithOptions(request, runtime);
}

model QueryDomainRealNameVerificationInfoRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  domainName?: string(name='DomainName'),
  fetchImage?: boolean(name='FetchImage'),
}

model QueryDomainRealNameVerificationInfoResponseBody = {
  identityCredentialType?: string(name='IdentityCredentialType'),
  requestId?: string(name='RequestId'),
  instanceId?: string(name='InstanceId'),
  domainName?: string(name='DomainName'),
  identityCredential?: string(name='IdentityCredential'),
  submissionDate?: string(name='SubmissionDate'),
  identityCredentialNo?: string(name='IdentityCredentialNo'),
  identityCredentialUrl?: string(name='IdentityCredentialUrl'),
}

model QueryDomainRealNameVerificationInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDomainRealNameVerificationInfoResponseBody(name='body'),
}

async function queryDomainRealNameVerificationInfoWithOptions(request: QueryDomainRealNameVerificationInfoRequest, runtime: Util.RuntimeOptions): QueryDomainRealNameVerificationInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryDomainRealNameVerificationInfo', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryDomainRealNameVerificationInfo(request: QueryDomainRealNameVerificationInfoRequest): QueryDomainRealNameVerificationInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDomainRealNameVerificationInfoWithOptions(request, runtime);
}

model QueryDomainSuffixRequest {
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryDomainSuffixResponseBody = {
  requestId?: string(name='RequestId'),
  suffixList?: {
    suffix?: [ string ](name='Suffix')
  }(name='SuffixList'),
}

model QueryDomainSuffixResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDomainSuffixResponseBody(name='body'),
}

async function queryDomainSuffixWithOptions(request: QueryDomainSuffixRequest, runtime: Util.RuntimeOptions): QueryDomainSuffixResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryDomainSuffix', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryDomainSuffix(request: QueryDomainSuffixRequest): QueryDomainSuffixResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDomainSuffixWithOptions(request, runtime);
}

model QueryDSRecordRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryDSRecordResponseBody = {
  requestId?: string(name='RequestId'),
  DSRecordList?: [ 
    {
      digestType?: int32(name='DigestType'),
      digest?: string(name='Digest'),
      algorithm?: int32(name='Algorithm'),
      keyTag?: int32(name='KeyTag'),
    }
  ](name='DSRecordList'),
}

model QueryDSRecordResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDSRecordResponseBody(name='body'),
}

async function queryDSRecordWithOptions(request: QueryDSRecordRequest, runtime: Util.RuntimeOptions): QueryDSRecordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryDSRecord', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryDSRecord(request: QueryDSRecordRequest): QueryDSRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDSRecordWithOptions(request, runtime);
}

model QueryEmailVerificationRequest {
  lang?: string(name='Lang'),
  email?: string(name='Email'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryEmailVerificationResponseBody = {
  verificationStatus?: int32(name='VerificationStatus'),
  gmtCreate?: string(name='GmtCreate'),
  email?: string(name='Email'),
  emailVerificationNo?: string(name='EmailVerificationNo'),
  confirmIp?: string(name='ConfirmIp'),
  requestId?: string(name='RequestId'),
  userId?: string(name='UserId'),
  gmtModified?: string(name='GmtModified'),
  sendIp?: string(name='SendIp'),
  verificationTime?: string(name='VerificationTime'),
  tokenSendTime?: string(name='TokenSendTime'),
}

model QueryEmailVerificationResponse = {
  headers: map[string]string(name='headers'),
  body: QueryEmailVerificationResponseBody(name='body'),
}

async function queryEmailVerificationWithOptions(request: QueryEmailVerificationRequest, runtime: Util.RuntimeOptions): QueryEmailVerificationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryEmailVerification', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryEmailVerification(request: QueryEmailVerificationRequest): QueryEmailVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEmailVerificationWithOptions(request, runtime);
}

model QueryEnsAssociationRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryEnsAssociationResponseBody = {
  address?: string(name='Address'),
  requestId?: string(name='RequestId'),
}

model QueryEnsAssociationResponse = {
  headers: map[string]string(name='headers'),
  body: QueryEnsAssociationResponseBody(name='body'),
}

async function queryEnsAssociationWithOptions(request: QueryEnsAssociationRequest, runtime: Util.RuntimeOptions): QueryEnsAssociationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryEnsAssociation', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryEnsAssociation(request: QueryEnsAssociationRequest): QueryEnsAssociationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEnsAssociationWithOptions(request, runtime);
}

model QueryFailingReasonListForQualificationRequest {
  qualificationType?: string(name='QualificationType'),
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  instanceId?: string(name='InstanceId'),
  limit?: int32(name='Limit'),
}

model QueryFailingReasonListForQualificationResponseBody = {
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      date?: string(name='Date'),
      failReason?: string(name='FailReason'),
    }
  ](name='Data'),
}

model QueryFailingReasonListForQualificationResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFailingReasonListForQualificationResponseBody(name='body'),
}

async function queryFailingReasonListForQualificationWithOptions(request: QueryFailingReasonListForQualificationRequest, runtime: Util.RuntimeOptions): QueryFailingReasonListForQualificationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryFailingReasonListForQualification', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryFailingReasonListForQualification(request: QueryFailingReasonListForQualificationRequest): QueryFailingReasonListForQualificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFailingReasonListForQualificationWithOptions(request, runtime);
}

model QueryFailReasonForDomainRealNameVerificationRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  domainName?: string(name='DomainName'),
  realNameVerificationAction?: string(name='RealNameVerificationAction'),
}

model QueryFailReasonForDomainRealNameVerificationResponseBody = {
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      date?: string(name='Date'),
      failReason?: string(name='FailReason'),
      domainNameVerificationStatus?: string(name='DomainNameVerificationStatus'),
    }
  ](name='Data'),
}

model QueryFailReasonForDomainRealNameVerificationResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFailReasonForDomainRealNameVerificationResponseBody(name='body'),
}

async function queryFailReasonForDomainRealNameVerificationWithOptions(request: QueryFailReasonForDomainRealNameVerificationRequest, runtime: Util.RuntimeOptions): QueryFailReasonForDomainRealNameVerificationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryFailReasonForDomainRealNameVerification', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryFailReasonForDomainRealNameVerification(request: QueryFailReasonForDomainRealNameVerificationRequest): QueryFailReasonForDomainRealNameVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFailReasonForDomainRealNameVerificationWithOptions(request, runtime);
}

model QueryFailReasonForRegistrantProfileRealNameVerificationRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  registrantProfileID?: long(name='RegistrantProfileID'),
}

model QueryFailReasonForRegistrantProfileRealNameVerificationResponseBody = {
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      date?: string(name='Date'),
      failReason?: string(name='FailReason'),
    }
  ](name='Data'),
}

model QueryFailReasonForRegistrantProfileRealNameVerificationResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFailReasonForRegistrantProfileRealNameVerificationResponseBody(name='body'),
}

async function queryFailReasonForRegistrantProfileRealNameVerificationWithOptions(request: QueryFailReasonForRegistrantProfileRealNameVerificationRequest, runtime: Util.RuntimeOptions): QueryFailReasonForRegistrantProfileRealNameVerificationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryFailReasonForRegistrantProfileRealNameVerification', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryFailReasonForRegistrantProfileRealNameVerification(request: QueryFailReasonForRegistrantProfileRealNameVerificationRequest): QueryFailReasonForRegistrantProfileRealNameVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFailReasonForRegistrantProfileRealNameVerificationWithOptions(request, runtime);
}

model QueryLocalEnsAssociationRequest {
  userClientIp?: string(name='UserClientIp'),
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
}

model QueryLocalEnsAssociationResponseBody = {
  address?: string(name='Address'),
  requestId?: string(name='RequestId'),
}

model QueryLocalEnsAssociationResponse = {
  headers: map[string]string(name='headers'),
  body: QueryLocalEnsAssociationResponseBody(name='body'),
}

async function queryLocalEnsAssociationWithOptions(request: QueryLocalEnsAssociationRequest, runtime: Util.RuntimeOptions): QueryLocalEnsAssociationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryLocalEnsAssociation', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryLocalEnsAssociation(request: QueryLocalEnsAssociationRequest): QueryLocalEnsAssociationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryLocalEnsAssociationWithOptions(request, runtime);
}

model QueryOperationAuditInfoDetailRequest {
  lang?: string(name='Lang'),
  auditRecordId?: long(name='AuditRecordId'),
}

model QueryOperationAuditInfoDetailResponseBody = {
  auditInfo?: string(name='AuditInfo'),
  auditStatus?: int32(name='AuditStatus'),
  requestId?: string(name='RequestId'),
  businessName?: string(name='BusinessName'),
  auditType?: int32(name='AuditType'),
  domainName?: string(name='DomainName'),
  createTime?: long(name='CreateTime'),
  updateTime?: long(name='UpdateTime'),
  id?: string(name='Id'),
  remark?: string(name='Remark'),
}

model QueryOperationAuditInfoDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QueryOperationAuditInfoDetailResponseBody(name='body'),
}

async function queryOperationAuditInfoDetailWithOptions(request: QueryOperationAuditInfoDetailRequest, runtime: Util.RuntimeOptions): QueryOperationAuditInfoDetailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryOperationAuditInfoDetail', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryOperationAuditInfoDetail(request: QueryOperationAuditInfoDetailRequest): QueryOperationAuditInfoDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOperationAuditInfoDetailWithOptions(request, runtime);
}

model QueryOperationAuditInfoListRequest {
  lang?: string(name='Lang'),
  domainName?: string(name='DomainName'),
  auditType?: int32(name='AuditType'),
  auditStatus?: int32(name='AuditStatus'),
  pageSize?: int32(name='PageSize'),
  pageNum?: int32(name='PageNum'),
}

model QueryOperationAuditInfoListResponseBody = {
  prePage?: boolean(name='PrePage'),
  currentPageNum?: int32(name='CurrentPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalPageNum?: int32(name='TotalPageNum'),
  data?: [ 
    {
      updateTime?: long(name='UpdateTime'),
      remark?: string(name='Remark'),
      createTime?: long(name='CreateTime'),
      auditType?: int32(name='AuditType'),
      businessName?: string(name='BusinessName'),
      auditInfo?: string(name='AuditInfo'),
      domainName?: string(name='DomainName'),
      auditStatus?: int32(name='AuditStatus'),
      id?: long(name='Id'),
    }
  ](name='Data'),
  totalItemNum?: int32(name='TotalItemNum'),
  nextPage?: boolean(name='NextPage'),
}

model QueryOperationAuditInfoListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryOperationAuditInfoListResponseBody(name='body'),
}

async function queryOperationAuditInfoListWithOptions(request: QueryOperationAuditInfoListRequest, runtime: Util.RuntimeOptions): QueryOperationAuditInfoListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryOperationAuditInfoList', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryOperationAuditInfoList(request: QueryOperationAuditInfoListRequest): QueryOperationAuditInfoListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOperationAuditInfoListWithOptions(request, runtime);
}

model QueryQualificationDetailRequest {
  instanceId?: string(name='InstanceId'),
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  qualificationType?: string(name='QualificationType'),
}

model QueryQualificationDetailResponseBody = {
  auditStatus?: int32(name='AuditStatus'),
  requestId?: string(name='RequestId'),
  credentials?: {
    qualificationCredential?: [ 
    {
      credentialType?: string(name='CredentialType'),
      credentialNo?: string(name='CredentialNo'),
      credentialUrl?: string(name='CredentialUrl'),
    }
  ](name='QualificationCredential')
  }(name='Credentials'),
  trackId?: string(name='TrackId'),
}

model QueryQualificationDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QueryQualificationDetailResponseBody(name='body'),
}

async function queryQualificationDetailWithOptions(request: QueryQualificationDetailRequest, runtime: Util.RuntimeOptions): QueryQualificationDetailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryQualificationDetail', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryQualificationDetail(request: QueryQualificationDetailRequest): QueryQualificationDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryQualificationDetailWithOptions(request, runtime);
}

model QueryRegistrantProfileRealNameVerificationInfoRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  fetchImage?: boolean(name='FetchImage'),
}

model QueryRegistrantProfileRealNameVerificationInfoResponseBody = {
  identityCredentialType?: string(name='IdentityCredentialType'),
  requestId?: string(name='RequestId'),
  modificationDate?: string(name='ModificationDate'),
  identityCredential?: string(name='IdentityCredential'),
  submissionDate?: string(name='SubmissionDate'),
  identityCredentialNo?: string(name='IdentityCredentialNo'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  identityCredentialUrl?: string(name='IdentityCredentialUrl'),
}

model QueryRegistrantProfileRealNameVerificationInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryRegistrantProfileRealNameVerificationInfoResponseBody(name='body'),
}

async function queryRegistrantProfileRealNameVerificationInfoWithOptions(request: QueryRegistrantProfileRealNameVerificationInfoRequest, runtime: Util.RuntimeOptions): QueryRegistrantProfileRealNameVerificationInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryRegistrantProfileRealNameVerificationInfo', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryRegistrantProfileRealNameVerificationInfo(request: QueryRegistrantProfileRealNameVerificationInfoRequest): QueryRegistrantProfileRealNameVerificationInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryRegistrantProfileRealNameVerificationInfoWithOptions(request, runtime);
}

model QueryRegistrantProfilesRequest {
  lang?: string(name='Lang'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  userClientIp?: string(name='UserClientIp'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  defaultRegistrantProfile?: boolean(name='DefaultRegistrantProfile'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  zhRegistrantOrganization?: string(name='ZhRegistrantOrganization'),
  registrantType?: string(name='RegistrantType'),
  realNameStatus?: string(name='RealNameStatus'),
  email?: string(name='Email'),
  registrantProfileType?: string(name='RegistrantProfileType'),
}

model QueryRegistrantProfilesResponseBody = {
  prePage?: boolean(name='PrePage'),
  currentPageNum?: int32(name='CurrentPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalPageNum?: int32(name='TotalPageNum'),
  registrantProfiles?: {
    registrantProfile?: [ 
    {
      telExt?: string(name='TelExt'),
      updateTime?: string(name='UpdateTime'),
      zhProvince?: string(name='ZhProvince'),
      createTime?: string(name='CreateTime'),
      telephone?: string(name='Telephone'),
      registrantOrganization?: string(name='RegistrantOrganization'),
      city?: string(name='City'),
      zhCity?: string(name='ZhCity'),
      telArea?: string(name='TelArea'),
      address?: string(name='Address'),
      realNameStatus?: string(name='RealNameStatus'),
      postalCode?: string(name='PostalCode'),
      registrantProfileType?: string(name='RegistrantProfileType'),
      registrantProfileId?: long(name='RegistrantProfileId'),
      zhRegistrantOrganization?: string(name='ZhRegistrantOrganization'),
      defaultRegistrantProfile?: boolean(name='DefaultRegistrantProfile'),
      zhRegistrantName?: string(name='ZhRegistrantName'),
      email?: string(name='Email'),
      registrantType?: string(name='RegistrantType'),
      country?: string(name='Country'),
      registrantName?: string(name='RegistrantName'),
      emailVerificationStatus?: int32(name='EmailVerificationStatus'),
      zhAddress?: string(name='ZhAddress'),
      province?: string(name='Province'),
    }
  ](name='RegistrantProfile')
  }(name='RegistrantProfiles'),
  totalItemNum?: int32(name='TotalItemNum'),
  nextPage?: boolean(name='NextPage'),
}

model QueryRegistrantProfilesResponse = {
  headers: map[string]string(name='headers'),
  body: QueryRegistrantProfilesResponseBody(name='body'),
}

async function queryRegistrantProfilesWithOptions(request: QueryRegistrantProfilesRequest, runtime: Util.RuntimeOptions): QueryRegistrantProfilesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryRegistrantProfiles', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryRegistrantProfiles(request: QueryRegistrantProfilesRequest): QueryRegistrantProfilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryRegistrantProfilesWithOptions(request, runtime);
}

model QueryServerLockRequest {
  lang?: string(name='Lang'),
  instanceId?: string(name='InstanceId'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryServerLockResponseBody = {
  startDate?: string(name='StartDate'),
  gmtCreate?: string(name='GmtCreate'),
  requestId?: string(name='RequestId'),
  expireDate?: string(name='ExpireDate'),
  domainName?: string(name='DomainName'),
  userId?: string(name='UserId'),
  gmtModified?: string(name='GmtModified'),
  domainInstanceId?: string(name='DomainInstanceId'),
  lockInstanceId?: string(name='LockInstanceId'),
  serverLockStatus?: int32(name='ServerLockStatus'),
  lockProductId?: string(name='LockProductId'),
}

model QueryServerLockResponse = {
  headers: map[string]string(name='headers'),
  body: QueryServerLockResponseBody(name='body'),
}

async function queryServerLockWithOptions(request: QueryServerLockRequest, runtime: Util.RuntimeOptions): QueryServerLockResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryServerLock', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryServerLock(request: QueryServerLockRequest): QueryServerLockResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryServerLockWithOptions(request, runtime);
}

model QueryTaskDetailHistoryRequest {
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
  taskNo?: string(name='TaskNo'),
  domainName?: string(name='DomainName'),
  domainNameCursor?: string(name='DomainNameCursor'),
  taskStatus?: int32(name='TaskStatus'),
  pageSize?: int32(name='PageSize'),
  taskDetailNoCursor?: string(name='TaskDetailNoCursor'),
}

model QueryTaskDetailHistoryResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  currentPageCursor?: {
    updateTime?: string(name='UpdateTime'),
    taskDetailNo?: string(name='TaskDetailNo'),
    createTime?: string(name='CreateTime'),
    instanceId?: string(name='InstanceId'),
    domainName?: string(name='DomainName'),
    taskType?: string(name='TaskType'),
    taskNo?: string(name='TaskNo'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskStatus?: string(name='TaskStatus'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
    tryCount?: int32(name='TryCount'),
    errorMsg?: string(name='ErrorMsg'),
  }(name='CurrentPageCursor'),
  objects?: [ 
    {
      updateTime?: string(name='UpdateTime'),
      taskDetailNo?: string(name='TaskDetailNo'),
      createTime?: string(name='CreateTime'),
      instanceId?: string(name='InstanceId'),
      domainName?: string(name='DomainName'),
      taskType?: string(name='TaskType'),
      taskNo?: string(name='TaskNo'),
      taskStatusCode?: int32(name='TaskStatusCode'),
      taskStatus?: string(name='TaskStatus'),
      taskTypeDescription?: string(name='TaskTypeDescription'),
      tryCount?: int32(name='TryCount'),
      errorMsg?: string(name='ErrorMsg'),
    }
  ](name='Objects'),
  prePageCursor?: {
    updateTime?: string(name='UpdateTime'),
    taskDetailNo?: string(name='TaskDetailNo'),
    createTime?: string(name='CreateTime'),
    instanceId?: string(name='InstanceId'),
    domainName?: string(name='DomainName'),
    taskType?: string(name='TaskType'),
    taskNo?: string(name='TaskNo'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskStatus?: string(name='TaskStatus'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
    tryCount?: int32(name='TryCount'),
    errorMsg?: string(name='ErrorMsg'),
  }(name='PrePageCursor'),
  nextPageCursor?: {
    updateTime?: string(name='UpdateTime'),
    taskDetailNo?: string(name='TaskDetailNo'),
    createTime?: string(name='CreateTime'),
    instanceId?: string(name='InstanceId'),
    domainName?: string(name='DomainName'),
    taskType?: string(name='TaskType'),
    taskNo?: string(name='TaskNo'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskStatus?: string(name='TaskStatus'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
    tryCount?: int32(name='TryCount'),
    errorMsg?: string(name='ErrorMsg'),
  }(name='NextPageCursor'),
}

model QueryTaskDetailHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTaskDetailHistoryResponseBody(name='body'),
}

async function queryTaskDetailHistoryWithOptions(request: QueryTaskDetailHistoryRequest, runtime: Util.RuntimeOptions): QueryTaskDetailHistoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTaskDetailHistory', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTaskDetailHistory(request: QueryTaskDetailHistoryRequest): QueryTaskDetailHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTaskDetailHistoryWithOptions(request, runtime);
}

model QueryTaskDetailListRequest {
  taskStatus?: int32(name='TaskStatus'),
  lang?: string(name='Lang'),
  taskNo?: string(name='TaskNo'),
  domainName?: string(name='DomainName'),
  instanceId?: string(name='InstanceId'),
  userClientIp?: string(name='UserClientIp'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model QueryTaskDetailListResponseBody = {
  prePage?: boolean(name='PrePage'),
  currentPageNum?: int32(name='CurrentPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalPageNum?: int32(name='TotalPageNum'),
  data?: {
    taskDetail?: [ 
    {
      updateTime?: string(name='UpdateTime'),
      taskDetailNo?: string(name='TaskDetailNo'),
      createTime?: string(name='CreateTime'),
      instanceId?: string(name='InstanceId'),
      domainName?: string(name='DomainName'),
      taskType?: string(name='TaskType'),
      taskNo?: string(name='TaskNo'),
      taskResult?: string(name='TaskResult'),
      taskStatusCode?: int32(name='TaskStatusCode'),
      taskStatus?: string(name='TaskStatus'),
      taskTypeDescription?: string(name='TaskTypeDescription'),
      tryCount?: int32(name='TryCount'),
      errorMsg?: string(name='ErrorMsg'),
    }
  ](name='TaskDetail')
  }(name='Data'),
  totalItemNum?: int32(name='TotalItemNum'),
  nextPage?: boolean(name='NextPage'),
}

model QueryTaskDetailListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTaskDetailListResponseBody(name='body'),
}

async function queryTaskDetailListWithOptions(request: QueryTaskDetailListRequest, runtime: Util.RuntimeOptions): QueryTaskDetailListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTaskDetailList', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTaskDetailList(request: QueryTaskDetailListRequest): QueryTaskDetailListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTaskDetailListWithOptions(request, runtime);
}

model QueryTaskInfoHistoryRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  beginCreateTime?: long(name='BeginCreateTime'),
  endCreateTime?: long(name='EndCreateTime'),
  pageSize?: int32(name='PageSize'),
  createTimeCursor?: long(name='CreateTimeCursor'),
  taskNoCursor?: string(name='TaskNoCursor'),
}

model QueryTaskInfoHistoryResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  currentPageCursor?: {
    taskType?: string(name='TaskType'),
    taskNo?: string(name='TaskNo'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskStatus?: string(name='TaskStatus'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
    taskNum?: int32(name='TaskNum'),
    createTime?: string(name='CreateTime'),
    createTimeLong?: long(name='CreateTimeLong'),
    clientip?: string(name='Clientip'),
  }(name='CurrentPageCursor'),
  objects?: [ 
    {
      taskType?: string(name='TaskType'),
      taskNo?: string(name='TaskNo'),
      taskStatusCode?: int32(name='TaskStatusCode'),
      taskStatus?: string(name='TaskStatus'),
      taskTypeDescription?: string(name='TaskTypeDescription'),
      taskNum?: int32(name='TaskNum'),
      createTime?: string(name='CreateTime'),
      createTimeLong?: long(name='CreateTimeLong'),
      clientip?: string(name='Clientip'),
    }
  ](name='Objects'),
  prePageCursor?: {
    taskType?: string(name='TaskType'),
    taskNo?: string(name='TaskNo'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskStatus?: string(name='TaskStatus'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
    taskNum?: int32(name='TaskNum'),
    createTime?: string(name='CreateTime'),
    createTimeLong?: long(name='CreateTimeLong'),
    clientip?: string(name='Clientip'),
  }(name='PrePageCursor'),
  nextPageCursor?: {
    taskType?: string(name='TaskType'),
    taskNo?: string(name='TaskNo'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskStatus?: string(name='TaskStatus'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
    taskNum?: int32(name='TaskNum'),
    createTime?: string(name='CreateTime'),
    createTimeLong?: long(name='CreateTimeLong'),
    clientip?: string(name='Clientip'),
  }(name='NextPageCursor'),
}

model QueryTaskInfoHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTaskInfoHistoryResponseBody(name='body'),
}

async function queryTaskInfoHistoryWithOptions(request: QueryTaskInfoHistoryRequest, runtime: Util.RuntimeOptions): QueryTaskInfoHistoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTaskInfoHistory', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTaskInfoHistory(request: QueryTaskInfoHistoryRequest): QueryTaskInfoHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTaskInfoHistoryWithOptions(request, runtime);
}

model QueryTaskListRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  beginCreateTime?: long(name='BeginCreateTime'),
  endCreateTime?: long(name='EndCreateTime'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model QueryTaskListResponseBody = {
  prePage?: boolean(name='PrePage'),
  currentPageNum?: int32(name='CurrentPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalPageNum?: int32(name='TotalPageNum'),
  data?: {
    taskInfo?: [ 
    {
      taskType?: string(name='TaskType'),
      taskCancelStatus?: string(name='TaskCancelStatus'),
      taskNo?: string(name='TaskNo'),
      taskCancelStatusCode?: int32(name='TaskCancelStatusCode'),
      taskStatusCode?: int32(name='TaskStatusCode'),
      taskStatus?: string(name='TaskStatus'),
      taskTypeDescription?: string(name='TaskTypeDescription'),
      taskNum?: int32(name='TaskNum'),
      createTime?: string(name='CreateTime'),
      clientip?: string(name='Clientip'),
    }
  ](name='TaskInfo')
  }(name='Data'),
  totalItemNum?: int32(name='TotalItemNum'),
  nextPage?: boolean(name='NextPage'),
}

model QueryTaskListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTaskListResponseBody(name='body'),
}

async function queryTaskListWithOptions(request: QueryTaskListRequest, runtime: Util.RuntimeOptions): QueryTaskListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTaskList', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTaskList(request: QueryTaskListRequest): QueryTaskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTaskListWithOptions(request, runtime);
}

model QueryTransferInByInstanceIdRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryTransferInByInstanceIdResponseBody = {
  status?: int32(name='Status'),
  transferAuthorizationCodeSubmissionDate?: string(name='TransferAuthorizationCodeSubmissionDate'),
  email?: string(name='Email'),
  progressBarType?: int32(name='ProgressBarType'),
  requestId?: string(name='RequestId'),
  instanceId?: string(name='InstanceId'),
  domainName?: string(name='DomainName'),
  submissionDateLong?: long(name='SubmissionDateLong'),
  submissionDate?: string(name='SubmissionDate'),
  simpleTransferInStatus?: string(name='SimpleTransferInStatus'),
  transferAuthorizationCodeSubmissionDateLong?: long(name='TransferAuthorizationCodeSubmissionDateLong'),
  expirationDateLong?: long(name='ExpirationDateLong'),
  expirationDate?: string(name='ExpirationDate'),
  needMailCheck?: boolean(name='NeedMailCheck'),
  userId?: string(name='UserId'),
  modificationDate?: string(name='ModificationDate'),
  resultDateLong?: long(name='ResultDateLong'),
  resultMsg?: string(name='ResultMsg'),
  whoisMailStatus?: boolean(name='WhoisMailStatus'),
  modificationDateLong?: long(name='ModificationDateLong'),
  resultCode?: string(name='ResultCode'),
  resultDate?: string(name='ResultDate'),
}

model QueryTransferInByInstanceIdResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTransferInByInstanceIdResponseBody(name='body'),
}

async function queryTransferInByInstanceIdWithOptions(request: QueryTransferInByInstanceIdRequest, runtime: Util.RuntimeOptions): QueryTransferInByInstanceIdResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTransferInByInstanceId', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTransferInByInstanceId(request: QueryTransferInByInstanceIdRequest): QueryTransferInByInstanceIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTransferInByInstanceIdWithOptions(request, runtime);
}

model QueryTransferInListRequest {
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
  submissionStartDate?: long(name='SubmissionStartDate'),
  submissionEndDate?: long(name='SubmissionEndDate'),
  domainName?: string(name='DomainName'),
  simpleTransferInStatus?: string(name='SimpleTransferInStatus'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model QueryTransferInListResponseBody = {
  prePage?: boolean(name='PrePage'),
  currentPageNum?: int32(name='CurrentPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalPageNum?: int32(name='TotalPageNum'),
  data?: {
    transferInInfo?: [ 
    {
      status?: int32(name='Status'),
      userId?: string(name='UserId'),
      modificationDate?: string(name='ModificationDate'),
      transferAuthorizationCodeSubmissionDateLong?: long(name='TransferAuthorizationCodeSubmissionDateLong'),
      submissionDateLong?: long(name='SubmissionDateLong'),
      resultCode?: string(name='ResultCode'),
      needMailCheck?: boolean(name='NeedMailCheck'),
      modificationDateLong?: long(name='ModificationDateLong'),
      instanceId?: string(name='InstanceId'),
      domainName?: string(name='DomainName'),
      progressBarType?: int32(name='ProgressBarType'),
      resultMsg?: string(name='ResultMsg'),
      resultDateLong?: long(name='ResultDateLong'),
      expirationDate?: string(name='ExpirationDate'),
      email?: string(name='Email'),
      whoisMailStatus?: boolean(name='WhoisMailStatus'),
      transferAuthorizationCodeSubmissionDate?: string(name='TransferAuthorizationCodeSubmissionDate'),
      submissionDate?: string(name='SubmissionDate'),
      expirationDateLong?: long(name='ExpirationDateLong'),
      simpleTransferInStatus?: string(name='SimpleTransferInStatus'),
      resultDate?: string(name='ResultDate'),
    }
  ](name='TransferInInfo')
  }(name='Data'),
  totalItemNum?: int32(name='TotalItemNum'),
  nextPage?: boolean(name='NextPage'),
}

model QueryTransferInListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTransferInListResponseBody(name='body'),
}

async function queryTransferInListWithOptions(request: QueryTransferInListRequest, runtime: Util.RuntimeOptions): QueryTransferInListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTransferInList', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTransferInList(request: QueryTransferInListRequest): QueryTransferInListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTransferInListWithOptions(request, runtime);
}

model QueryTransferOutInfoRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryTransferOutInfoResponseBody = {
  status?: int32(name='Status'),
  email?: string(name='Email'),
  expirationDate?: string(name='ExpirationDate'),
  requestId?: string(name='RequestId'),
  resultMsg?: string(name='ResultMsg'),
  pendingRequestDate?: string(name='PendingRequestDate'),
  resultCode?: string(name='ResultCode'),
  transferAuthorizationCodeSendDate?: string(name='TransferAuthorizationCodeSendDate'),
}

model QueryTransferOutInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTransferOutInfoResponseBody(name='body'),
}

async function queryTransferOutInfoWithOptions(request: QueryTransferOutInfoRequest, runtime: Util.RuntimeOptions): QueryTransferOutInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTransferOutInfo', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTransferOutInfo(request: QueryTransferOutInfoRequest): QueryTransferOutInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTransferOutInfoWithOptions(request, runtime);
}

model RegistrantProfileRealNameVerificationRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  registrantProfileID?: long(name='RegistrantProfileID'),
  identityCredential?: string(name='IdentityCredential'),
  identityCredentialNo?: string(name='IdentityCredentialNo'),
  identityCredentialType?: string(name='IdentityCredentialType'),
}

model RegistrantProfileRealNameVerificationResponseBody = {
  requestId?: string(name='RequestId'),
}

model RegistrantProfileRealNameVerificationResponse = {
  headers: map[string]string(name='headers'),
  body: RegistrantProfileRealNameVerificationResponseBody(name='body'),
}

async function registrantProfileRealNameVerificationWithOptions(request: RegistrantProfileRealNameVerificationRequest, runtime: Util.RuntimeOptions): RegistrantProfileRealNameVerificationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RegistrantProfileRealNameVerification', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function registrantProfileRealNameVerification(request: RegistrantProfileRealNameVerificationRequest): RegistrantProfileRealNameVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return registrantProfileRealNameVerificationWithOptions(request, runtime);
}

model ResendEmailVerificationRequest {
  lang?: string(name='Lang'),
  email?: string(name='Email'),
  userClientIp?: string(name='UserClientIp'),
}

model ResendEmailVerificationResponseBody = {
  requestId?: string(name='RequestId'),
  successList?: [ 
    {
      email?: string(name='Email'),
      code?: string(name='Code'),
      message?: string(name='Message'),
    }
  ](name='SuccessList'),
  failList?: [ 
    {
      email?: string(name='Email'),
      code?: string(name='Code'),
      message?: string(name='Message'),
    }
  ](name='FailList'),
}

model ResendEmailVerificationResponse = {
  headers: map[string]string(name='headers'),
  body: ResendEmailVerificationResponseBody(name='body'),
}

async function resendEmailVerificationWithOptions(request: ResendEmailVerificationRequest, runtime: Util.RuntimeOptions): ResendEmailVerificationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ResendEmailVerification', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function resendEmailVerification(request: ResendEmailVerificationRequest): ResendEmailVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return resendEmailVerificationWithOptions(request, runtime);
}

model ResetQualificationVerificationRequest {
  instanceId?: string(name='InstanceId'),
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
}

model ResetQualificationVerificationResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetQualificationVerificationResponse = {
  headers: map[string]string(name='headers'),
  body: ResetQualificationVerificationResponseBody(name='body'),
}

async function resetQualificationVerificationWithOptions(request: ResetQualificationVerificationRequest, runtime: Util.RuntimeOptions): ResetQualificationVerificationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ResetQualificationVerification', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function resetQualificationVerification(request: ResetQualificationVerificationRequest): ResetQualificationVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetQualificationVerificationWithOptions(request, runtime);
}

model SaveBatchDomainRemarkRequest {
  lang?: string(name='Lang'),
  remark?: string(name='Remark'),
  instanceIds?: string(name='InstanceIds'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveBatchDomainRemarkResponseBody = {
  requestId?: string(name='RequestId'),
}

model SaveBatchDomainRemarkResponse = {
  headers: map[string]string(name='headers'),
  body: SaveBatchDomainRemarkResponseBody(name='body'),
}

async function saveBatchDomainRemarkWithOptions(request: SaveBatchDomainRemarkRequest, runtime: Util.RuntimeOptions): SaveBatchDomainRemarkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveBatchDomainRemark', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveBatchDomainRemark(request: SaveBatchDomainRemarkRequest): SaveBatchDomainRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchDomainRemarkWithOptions(request, runtime);
}

model SaveBatchTaskForCreatingOrderActivateRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  couponNo?: string(name='CouponNo'),
  useCoupon?: boolean(name='UseCoupon'),
  promotionNo?: string(name='PromotionNo'),
  usePromotion?: boolean(name='UsePromotion'),
  orderActivateParam?: [ 
    {
      telExt?: string(name='TelExt'),
      aliyunDns?: boolean(name='AliyunDns'),
      permitPremiumActivation?: boolean(name='PermitPremiumActivation'),
      zhProvince?: string(name='ZhProvince'),
      telephone?: string(name='Telephone'),
      registrantOrganization?: string(name='RegistrantOrganization'),
      city?: string(name='City'),
      domainName?: string(name='DomainName'),
      zhCity?: string(name='ZhCity'),
      dns1?: string(name='Dns1'),
      telArea?: string(name='TelArea'),
      address?: string(name='Address'),
      enableDomainProxy?: boolean(name='EnableDomainProxy'),
      postalCode?: string(name='PostalCode'),
      registrantProfileId?: long(name='RegistrantProfileId'),
      zhRegistrantOrganization?: string(name='ZhRegistrantOrganization'),
      trademarkDomainActivation?: boolean(name='TrademarkDomainActivation'),
      dns2?: string(name='Dns2'),
      zhRegistrantName?: string(name='ZhRegistrantName'),
      email?: string(name='Email'),
      registrantType?: string(name='RegistrantType'),
      country?: string(name='Country'),
      registrantName?: string(name='RegistrantName'),
      subscriptionDuration?: int32(name='SubscriptionDuration'),
      zhAddress?: string(name='ZhAddress'),
      province?: string(name='Province'),
    }
  ](name='OrderActivateParam'),
}

model SaveBatchTaskForCreatingOrderActivateResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForCreatingOrderActivateResponse = {
  headers: map[string]string(name='headers'),
  body: SaveBatchTaskForCreatingOrderActivateResponseBody(name='body'),
}

async function saveBatchTaskForCreatingOrderActivateWithOptions(request: SaveBatchTaskForCreatingOrderActivateRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForCreatingOrderActivateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveBatchTaskForCreatingOrderActivate', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveBatchTaskForCreatingOrderActivate(request: SaveBatchTaskForCreatingOrderActivateRequest): SaveBatchTaskForCreatingOrderActivateResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForCreatingOrderActivateWithOptions(request, runtime);
}

model SaveBatchTaskForCreatingOrderRedeemRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  couponNo?: string(name='CouponNo'),
  useCoupon?: boolean(name='UseCoupon'),
  promotionNo?: string(name='PromotionNo'),
  usePromotion?: boolean(name='UsePromotion'),
  orderRedeemParam?: [ 
    {
      domainName?: string(name='DomainName'),
      currentExpirationDate?: long(name='CurrentExpirationDate'),
    }
  ](name='OrderRedeemParam'),
}

model SaveBatchTaskForCreatingOrderRedeemResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForCreatingOrderRedeemResponse = {
  headers: map[string]string(name='headers'),
  body: SaveBatchTaskForCreatingOrderRedeemResponseBody(name='body'),
}

async function saveBatchTaskForCreatingOrderRedeemWithOptions(request: SaveBatchTaskForCreatingOrderRedeemRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForCreatingOrderRedeemResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveBatchTaskForCreatingOrderRedeem', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveBatchTaskForCreatingOrderRedeem(request: SaveBatchTaskForCreatingOrderRedeemRequest): SaveBatchTaskForCreatingOrderRedeemResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForCreatingOrderRedeemWithOptions(request, runtime);
}

model SaveBatchTaskForCreatingOrderRenewRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  couponNo?: string(name='CouponNo'),
  useCoupon?: boolean(name='UseCoupon'),
  promotionNo?: string(name='PromotionNo'),
  usePromotion?: boolean(name='UsePromotion'),
  orderRenewParam?: [ 
    {
      subscriptionDuration?: int32(name='SubscriptionDuration'),
      domainName?: string(name='DomainName'),
      currentExpirationDate?: long(name='CurrentExpirationDate'),
    }
  ](name='OrderRenewParam'),
}

model SaveBatchTaskForCreatingOrderRenewResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForCreatingOrderRenewResponse = {
  headers: map[string]string(name='headers'),
  body: SaveBatchTaskForCreatingOrderRenewResponseBody(name='body'),
}

async function saveBatchTaskForCreatingOrderRenewWithOptions(request: SaveBatchTaskForCreatingOrderRenewRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForCreatingOrderRenewResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveBatchTaskForCreatingOrderRenew', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveBatchTaskForCreatingOrderRenew(request: SaveBatchTaskForCreatingOrderRenewRequest): SaveBatchTaskForCreatingOrderRenewResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForCreatingOrderRenewWithOptions(request, runtime);
}

model SaveBatchTaskForCreatingOrderTransferRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  couponNo?: string(name='CouponNo'),
  useCoupon?: boolean(name='UseCoupon'),
  promotionNo?: string(name='PromotionNo'),
  usePromotion?: boolean(name='UsePromotion'),
  orderTransferParam?: [ 
    {
      permitPremiumTransfer?: boolean(name='PermitPremiumTransfer'),
      registrantProfileId?: long(name='RegistrantProfileId'),
      authorizationCode?: string(name='AuthorizationCode'),
      domainName?: string(name='DomainName'),
    }
  ](name='OrderTransferParam'),
}

model SaveBatchTaskForCreatingOrderTransferResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForCreatingOrderTransferResponse = {
  headers: map[string]string(name='headers'),
  body: SaveBatchTaskForCreatingOrderTransferResponseBody(name='body'),
}

async function saveBatchTaskForCreatingOrderTransferWithOptions(request: SaveBatchTaskForCreatingOrderTransferRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForCreatingOrderTransferResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveBatchTaskForCreatingOrderTransfer', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveBatchTaskForCreatingOrderTransfer(request: SaveBatchTaskForCreatingOrderTransferRequest): SaveBatchTaskForCreatingOrderTransferResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForCreatingOrderTransferWithOptions(request, runtime);
}

model SaveBatchTaskForDomainNameProxyServiceRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  status?: boolean(name='Status'),
  domainName?: [ string ](name='DomainName'),
}

model SaveBatchTaskForDomainNameProxyServiceResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForDomainNameProxyServiceResponse = {
  headers: map[string]string(name='headers'),
  body: SaveBatchTaskForDomainNameProxyServiceResponseBody(name='body'),
}

async function saveBatchTaskForDomainNameProxyServiceWithOptions(request: SaveBatchTaskForDomainNameProxyServiceRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForDomainNameProxyServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveBatchTaskForDomainNameProxyService', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveBatchTaskForDomainNameProxyService(request: SaveBatchTaskForDomainNameProxyServiceRequest): SaveBatchTaskForDomainNameProxyServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForDomainNameProxyServiceWithOptions(request, runtime);
}

model SaveBatchTaskForModifyingDomainDnsRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  aliyunDns?: boolean(name='AliyunDns'),
  domainName?: [ string ](name='DomainName'),
  domainNameServer?: [ string ](name='DomainNameServer'),
}

model SaveBatchTaskForModifyingDomainDnsResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForModifyingDomainDnsResponse = {
  headers: map[string]string(name='headers'),
  body: SaveBatchTaskForModifyingDomainDnsResponseBody(name='body'),
}

async function saveBatchTaskForModifyingDomainDnsWithOptions(request: SaveBatchTaskForModifyingDomainDnsRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForModifyingDomainDnsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveBatchTaskForModifyingDomainDns', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveBatchTaskForModifyingDomainDns(request: SaveBatchTaskForModifyingDomainDnsRequest): SaveBatchTaskForModifyingDomainDnsResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForModifyingDomainDnsWithOptions(request, runtime);
}

model SaveBatchTaskForTransferProhibitionLockRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  status?: boolean(name='Status'),
  domainName?: [ string ](name='DomainName'),
}

model SaveBatchTaskForTransferProhibitionLockResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForTransferProhibitionLockResponse = {
  headers: map[string]string(name='headers'),
  body: SaveBatchTaskForTransferProhibitionLockResponseBody(name='body'),
}

async function saveBatchTaskForTransferProhibitionLockWithOptions(request: SaveBatchTaskForTransferProhibitionLockRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForTransferProhibitionLockResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveBatchTaskForTransferProhibitionLock', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveBatchTaskForTransferProhibitionLock(request: SaveBatchTaskForTransferProhibitionLockRequest): SaveBatchTaskForTransferProhibitionLockResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForTransferProhibitionLockWithOptions(request, runtime);
}

model SaveBatchTaskForUpdateProhibitionLockRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  status?: boolean(name='Status'),
  domainName?: [ string ](name='DomainName'),
}

model SaveBatchTaskForUpdateProhibitionLockResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForUpdateProhibitionLockResponse = {
  headers: map[string]string(name='headers'),
  body: SaveBatchTaskForUpdateProhibitionLockResponseBody(name='body'),
}

async function saveBatchTaskForUpdateProhibitionLockWithOptions(request: SaveBatchTaskForUpdateProhibitionLockRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForUpdateProhibitionLockResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveBatchTaskForUpdateProhibitionLock', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveBatchTaskForUpdateProhibitionLock(request: SaveBatchTaskForUpdateProhibitionLockRequest): SaveBatchTaskForUpdateProhibitionLockResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForUpdateProhibitionLockWithOptions(request, runtime);
}

model SaveBatchTaskForUpdatingContactInfoByNewContactRequest {
  address?: string(name='Address'),
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  city?: string(name='City'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  registrantName?: string(name='RegistrantName'),
  province?: string(name='Province'),
  country?: string(name='Country'),
  email?: string(name='Email'),
  postalCode?: string(name='PostalCode'),
  telArea?: string(name='TelArea'),
  telephone?: string(name='Telephone'),
  telExt?: string(name='TelExt'),
  zhCity?: string(name='ZhCity'),
  zhRegistrantOrganization?: string(name='ZhRegistrantOrganization'),
  zhRegistrantName?: string(name='ZhRegistrantName'),
  zhProvince?: string(name='ZhProvince'),
  zhAddress?: string(name='ZhAddress'),
  contactType?: string(name='ContactType'),
  registrantType?: string(name='RegistrantType'),
  transferOutProhibited?: boolean(name='TransferOutProhibited'),
  domainName?: [ string ](name='DomainName'),
}

model SaveBatchTaskForUpdatingContactInfoByNewContactResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForUpdatingContactInfoByNewContactResponse = {
  headers: map[string]string(name='headers'),
  body: SaveBatchTaskForUpdatingContactInfoByNewContactResponseBody(name='body'),
}

async function saveBatchTaskForUpdatingContactInfoByNewContactWithOptions(request: SaveBatchTaskForUpdatingContactInfoByNewContactRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForUpdatingContactInfoByNewContactResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveBatchTaskForUpdatingContactInfoByNewContact', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveBatchTaskForUpdatingContactInfoByNewContact(request: SaveBatchTaskForUpdatingContactInfoByNewContactRequest): SaveBatchTaskForUpdatingContactInfoByNewContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForUpdatingContactInfoByNewContactWithOptions(request, runtime);
}

model SaveBatchTaskForUpdatingContactInfoByRegistrantProfileIdRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  contactType?: string(name='ContactType'),
  transferOutProhibited?: boolean(name='TransferOutProhibited'),
  domainName?: [ string ](name='DomainName'),
}

model SaveBatchTaskForUpdatingContactInfoByRegistrantProfileIdResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForUpdatingContactInfoByRegistrantProfileIdResponse = {
  headers: map[string]string(name='headers'),
  body: SaveBatchTaskForUpdatingContactInfoByRegistrantProfileIdResponseBody(name='body'),
}

async function saveBatchTaskForUpdatingContactInfoByRegistrantProfileIdWithOptions(request: SaveBatchTaskForUpdatingContactInfoByRegistrantProfileIdRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForUpdatingContactInfoByRegistrantProfileIdResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveBatchTaskForUpdatingContactInfoByRegistrantProfileId', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveBatchTaskForUpdatingContactInfoByRegistrantProfileId(request: SaveBatchTaskForUpdatingContactInfoByRegistrantProfileIdRequest): SaveBatchTaskForUpdatingContactInfoByRegistrantProfileIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForUpdatingContactInfoByRegistrantProfileIdWithOptions(request, runtime);
}

model SaveDomainGroupRequest {
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
  domainGroupName?: string(name='DomainGroupName'),
  domainGroupId?: long(name='DomainGroupId'),
}

model SaveDomainGroupResponseBody = {
  beingDeleted?: boolean(name='BeingDeleted'),
  creationDate?: string(name='CreationDate'),
  requestId?: string(name='RequestId'),
  domainGroupName?: string(name='DomainGroupName'),
  modificationDate?: string(name='ModificationDate'),
  domainGroupStatus?: string(name='DomainGroupStatus'),
  domainGroupId?: long(name='DomainGroupId'),
  totalNumber?: int32(name='TotalNumber'),
}

model SaveDomainGroupResponse = {
  headers: map[string]string(name='headers'),
  body: SaveDomainGroupResponseBody(name='body'),
}

async function saveDomainGroupWithOptions(request: SaveDomainGroupRequest, runtime: Util.RuntimeOptions): SaveDomainGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveDomainGroup', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveDomainGroup(request: SaveDomainGroupRequest): SaveDomainGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveDomainGroupWithOptions(request, runtime);
}

model SaveRegistrantProfileRequest {
  defaultRegistrantProfile?: boolean(name='DefaultRegistrantProfile'),
  country?: string(name='Country'),
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  city?: string(name='City'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  registrantName?: string(name='RegistrantName'),
  province?: string(name='Province'),
  address?: string(name='Address'),
  email?: string(name='Email'),
  postalCode?: string(name='PostalCode'),
  telArea?: string(name='TelArea'),
  telephone?: string(name='Telephone'),
  telExt?: string(name='TelExt'),
  zhRegistrantOrganization?: string(name='ZhRegistrantOrganization'),
  zhRegistrantName?: string(name='ZhRegistrantName'),
  zhProvince?: string(name='ZhProvince'),
  zhAddress?: string(name='ZhAddress'),
  zhCity?: string(name='ZhCity'),
  registrantType?: string(name='RegistrantType'),
  registrantProfileType?: string(name='RegistrantProfileType'),
}

model SaveRegistrantProfileResponseBody = {
  requestId?: string(name='RequestId'),
  registrantProfileId?: long(name='RegistrantProfileId'),
}

model SaveRegistrantProfileResponse = {
  headers: map[string]string(name='headers'),
  body: SaveRegistrantProfileResponseBody(name='body'),
}

async function saveRegistrantProfileWithOptions(request: SaveRegistrantProfileRequest, runtime: Util.RuntimeOptions): SaveRegistrantProfileResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveRegistrantProfile', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveRegistrantProfile(request: SaveRegistrantProfileRequest): SaveRegistrantProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveRegistrantProfileWithOptions(request, runtime);
}

model SaveSingleTaskForAddingDSRecordRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  keyTag?: int32(name='KeyTag'),
  userClientIp?: string(name='UserClientIp'),
  algorithm?: int32(name='Algorithm'),
  digestType?: int32(name='DigestType'),
  digest?: string(name='Digest'),
}

model SaveSingleTaskForAddingDSRecordResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForAddingDSRecordResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForAddingDSRecordResponseBody(name='body'),
}

async function saveSingleTaskForAddingDSRecordWithOptions(request: SaveSingleTaskForAddingDSRecordRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForAddingDSRecordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForAddingDSRecord', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForAddingDSRecord(request: SaveSingleTaskForAddingDSRecordRequest): SaveSingleTaskForAddingDSRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForAddingDSRecordWithOptions(request, runtime);
}

model SaveSingleTaskForApprovingTransferOutRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForApprovingTransferOutResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForApprovingTransferOutResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForApprovingTransferOutResponseBody(name='body'),
}

async function saveSingleTaskForApprovingTransferOutWithOptions(request: SaveSingleTaskForApprovingTransferOutRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForApprovingTransferOutResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForApprovingTransferOut', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForApprovingTransferOut(request: SaveSingleTaskForApprovingTransferOutRequest): SaveSingleTaskForApprovingTransferOutResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForApprovingTransferOutWithOptions(request, runtime);
}

model SaveSingleTaskForAssociatingEnsRequest {
  userClientIp?: string(name='UserClientIp'),
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  address?: string(name='Address'),
}

model SaveSingleTaskForAssociatingEnsResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForAssociatingEnsResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForAssociatingEnsResponseBody(name='body'),
}

async function saveSingleTaskForAssociatingEnsWithOptions(request: SaveSingleTaskForAssociatingEnsRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForAssociatingEnsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForAssociatingEns', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForAssociatingEns(request: SaveSingleTaskForAssociatingEnsRequest): SaveSingleTaskForAssociatingEnsResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForAssociatingEnsWithOptions(request, runtime);
}

model SaveSingleTaskForCancelingTransferInRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForCancelingTransferInResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCancelingTransferInResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForCancelingTransferInResponseBody(name='body'),
}

async function saveSingleTaskForCancelingTransferInWithOptions(request: SaveSingleTaskForCancelingTransferInRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForCancelingTransferInResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForCancelingTransferIn', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForCancelingTransferIn(request: SaveSingleTaskForCancelingTransferInRequest): SaveSingleTaskForCancelingTransferInResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForCancelingTransferInWithOptions(request, runtime);
}

model SaveSingleTaskForCancelingTransferOutRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForCancelingTransferOutResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCancelingTransferOutResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForCancelingTransferOutResponseBody(name='body'),
}

async function saveSingleTaskForCancelingTransferOutWithOptions(request: SaveSingleTaskForCancelingTransferOutRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForCancelingTransferOutResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForCancelingTransferOut', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForCancelingTransferOut(request: SaveSingleTaskForCancelingTransferOutRequest): SaveSingleTaskForCancelingTransferOutResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForCancelingTransferOutWithOptions(request, runtime);
}

model SaveSingleTaskForCreatingDnsHostRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  dnsName?: string(name='DnsName'),
  userClientIp?: string(name='UserClientIp'),
  ip?: [ string ](name='Ip'),
}

model SaveSingleTaskForCreatingDnsHostResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCreatingDnsHostResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForCreatingDnsHostResponseBody(name='body'),
}

async function saveSingleTaskForCreatingDnsHostWithOptions(request: SaveSingleTaskForCreatingDnsHostRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForCreatingDnsHostResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForCreatingDnsHost', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForCreatingDnsHost(request: SaveSingleTaskForCreatingDnsHostRequest): SaveSingleTaskForCreatingDnsHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForCreatingDnsHostWithOptions(request, runtime);
}

model SaveSingleTaskForCreatingOrderActivateRequest {
  zhRegistrantName?: string(name='ZhRegistrantName'),
  lang?: string(name='Lang'),
  domainName?: string(name='DomainName'),
  subscriptionDuration?: int32(name='SubscriptionDuration'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  enableDomainProxy?: boolean(name='EnableDomainProxy'),
  permitPremiumActivation?: boolean(name='PermitPremiumActivation'),
  aliyunDns?: boolean(name='AliyunDns'),
  dns1?: string(name='Dns1'),
  userClientIp?: string(name='UserClientIp'),
  zhCity?: string(name='ZhCity'),
  zhRegistrantOrganization?: string(name='ZhRegistrantOrganization'),
  country?: string(name='Country'),
  dns2?: string(name='Dns2'),
  zhProvince?: string(name='ZhProvince'),
  zhAddress?: string(name='ZhAddress'),
  city?: string(name='City'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  registrantName?: string(name='RegistrantName'),
  province?: string(name='Province'),
  address?: string(name='Address'),
  email?: string(name='Email'),
  postalCode?: string(name='PostalCode'),
  telArea?: string(name='TelArea'),
  telephone?: string(name='Telephone'),
  telExt?: string(name='TelExt'),
  registrantType?: string(name='RegistrantType'),
  trademarkDomainActivation?: boolean(name='TrademarkDomainActivation'),
  couponNo?: string(name='CouponNo'),
  useCoupon?: boolean(name='UseCoupon'),
  promotionNo?: string(name='PromotionNo'),
  usePromotion?: boolean(name='UsePromotion'),
}

model SaveSingleTaskForCreatingOrderActivateResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCreatingOrderActivateResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForCreatingOrderActivateResponseBody(name='body'),
}

async function saveSingleTaskForCreatingOrderActivateWithOptions(request: SaveSingleTaskForCreatingOrderActivateRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForCreatingOrderActivateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForCreatingOrderActivate', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForCreatingOrderActivate(request: SaveSingleTaskForCreatingOrderActivateRequest): SaveSingleTaskForCreatingOrderActivateResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForCreatingOrderActivateWithOptions(request, runtime);
}

model SaveSingleTaskForCreatingOrderRedeemRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  domainName?: string(name='DomainName'),
  currentExpirationDate?: long(name='CurrentExpirationDate'),
  couponNo?: string(name='CouponNo'),
  useCoupon?: boolean(name='UseCoupon'),
  promotionNo?: string(name='PromotionNo'),
  usePromotion?: boolean(name='UsePromotion'),
}

model SaveSingleTaskForCreatingOrderRedeemResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCreatingOrderRedeemResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForCreatingOrderRedeemResponseBody(name='body'),
}

async function saveSingleTaskForCreatingOrderRedeemWithOptions(request: SaveSingleTaskForCreatingOrderRedeemRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForCreatingOrderRedeemResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForCreatingOrderRedeem', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForCreatingOrderRedeem(request: SaveSingleTaskForCreatingOrderRedeemRequest): SaveSingleTaskForCreatingOrderRedeemResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForCreatingOrderRedeemWithOptions(request, runtime);
}

model SaveSingleTaskForCreatingOrderRenewRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  domainName?: string(name='DomainName'),
  subscriptionDuration?: int32(name='SubscriptionDuration'),
  currentExpirationDate?: long(name='CurrentExpirationDate'),
  couponNo?: string(name='CouponNo'),
  useCoupon?: boolean(name='UseCoupon'),
  promotionNo?: string(name='PromotionNo'),
  usePromotion?: boolean(name='UsePromotion'),
}

model SaveSingleTaskForCreatingOrderRenewResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCreatingOrderRenewResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForCreatingOrderRenewResponseBody(name='body'),
}

async function saveSingleTaskForCreatingOrderRenewWithOptions(request: SaveSingleTaskForCreatingOrderRenewRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForCreatingOrderRenewResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForCreatingOrderRenew', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForCreatingOrderRenew(request: SaveSingleTaskForCreatingOrderRenewRequest): SaveSingleTaskForCreatingOrderRenewResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForCreatingOrderRenewWithOptions(request, runtime);
}

model SaveSingleTaskForCreatingOrderTransferRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  domainName?: string(name='DomainName'),
  authorizationCode?: string(name='AuthorizationCode'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  permitPremiumTransfer?: boolean(name='PermitPremiumTransfer'),
  couponNo?: string(name='CouponNo'),
  useCoupon?: boolean(name='UseCoupon'),
  promotionNo?: string(name='PromotionNo'),
  usePromotion?: boolean(name='UsePromotion'),
}

model SaveSingleTaskForCreatingOrderTransferResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCreatingOrderTransferResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForCreatingOrderTransferResponseBody(name='body'),
}

async function saveSingleTaskForCreatingOrderTransferWithOptions(request: SaveSingleTaskForCreatingOrderTransferRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForCreatingOrderTransferResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForCreatingOrderTransfer', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForCreatingOrderTransfer(request: SaveSingleTaskForCreatingOrderTransferRequest): SaveSingleTaskForCreatingOrderTransferResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForCreatingOrderTransferWithOptions(request, runtime);
}

model SaveSingleTaskForDeletingDnsHostRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  dnsName?: string(name='DnsName'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForDeletingDnsHostResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForDeletingDnsHostResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForDeletingDnsHostResponseBody(name='body'),
}

async function saveSingleTaskForDeletingDnsHostWithOptions(request: SaveSingleTaskForDeletingDnsHostRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForDeletingDnsHostResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForDeletingDnsHost', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForDeletingDnsHost(request: SaveSingleTaskForDeletingDnsHostRequest): SaveSingleTaskForDeletingDnsHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForDeletingDnsHostWithOptions(request, runtime);
}

model SaveSingleTaskForDeletingDSRecordRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  keyTag?: int32(name='KeyTag'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForDeletingDSRecordResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForDeletingDSRecordResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForDeletingDSRecordResponseBody(name='body'),
}

async function saveSingleTaskForDeletingDSRecordWithOptions(request: SaveSingleTaskForDeletingDSRecordRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForDeletingDSRecordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForDeletingDSRecord', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForDeletingDSRecord(request: SaveSingleTaskForDeletingDSRecordRequest): SaveSingleTaskForDeletingDSRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForDeletingDSRecordWithOptions(request, runtime);
}

model SaveSingleTaskForDisassociatingEnsRequest {
  userClientIp?: string(name='UserClientIp'),
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
}

model SaveSingleTaskForDisassociatingEnsResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForDisassociatingEnsResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForDisassociatingEnsResponseBody(name='body'),
}

async function saveSingleTaskForDisassociatingEnsWithOptions(request: SaveSingleTaskForDisassociatingEnsRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForDisassociatingEnsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForDisassociatingEns', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForDisassociatingEns(request: SaveSingleTaskForDisassociatingEnsRequest): SaveSingleTaskForDisassociatingEnsResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForDisassociatingEnsWithOptions(request, runtime);
}

model SaveSingleTaskForDomainNameProxyServiceRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  domainName?: string(name='DomainName'),
  status?: boolean(name='Status'),
}

model SaveSingleTaskForDomainNameProxyServiceResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForDomainNameProxyServiceResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForDomainNameProxyServiceResponseBody(name='body'),
}

async function saveSingleTaskForDomainNameProxyServiceWithOptions(request: SaveSingleTaskForDomainNameProxyServiceRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForDomainNameProxyServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForDomainNameProxyService', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForDomainNameProxyService(request: SaveSingleTaskForDomainNameProxyServiceRequest): SaveSingleTaskForDomainNameProxyServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForDomainNameProxyServiceWithOptions(request, runtime);
}

model SaveSingleTaskForModifyingDnsHostRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  dnsName?: string(name='DnsName'),
  userClientIp?: string(name='UserClientIp'),
  ip?: [ string ](name='Ip'),
}

model SaveSingleTaskForModifyingDnsHostResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForModifyingDnsHostResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForModifyingDnsHostResponseBody(name='body'),
}

async function saveSingleTaskForModifyingDnsHostWithOptions(request: SaveSingleTaskForModifyingDnsHostRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForModifyingDnsHostResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForModifyingDnsHost', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForModifyingDnsHost(request: SaveSingleTaskForModifyingDnsHostRequest): SaveSingleTaskForModifyingDnsHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForModifyingDnsHostWithOptions(request, runtime);
}

model SaveSingleTaskForModifyingDSRecordRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  keyTag?: int32(name='KeyTag'),
  userClientIp?: string(name='UserClientIp'),
  algorithm?: int32(name='Algorithm'),
  digestType?: int32(name='DigestType'),
  digest?: string(name='Digest'),
}

model SaveSingleTaskForModifyingDSRecordResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForModifyingDSRecordResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForModifyingDSRecordResponseBody(name='body'),
}

async function saveSingleTaskForModifyingDSRecordWithOptions(request: SaveSingleTaskForModifyingDSRecordRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForModifyingDSRecordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForModifyingDSRecord', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForModifyingDSRecord(request: SaveSingleTaskForModifyingDSRecordRequest): SaveSingleTaskForModifyingDSRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForModifyingDSRecordWithOptions(request, runtime);
}

model SaveSingleTaskForQueryingTransferAuthorizationCodeRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForQueryingTransferAuthorizationCodeResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForQueryingTransferAuthorizationCodeResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForQueryingTransferAuthorizationCodeResponseBody(name='body'),
}

async function saveSingleTaskForQueryingTransferAuthorizationCodeWithOptions(request: SaveSingleTaskForQueryingTransferAuthorizationCodeRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForQueryingTransferAuthorizationCodeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForQueryingTransferAuthorizationCode', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForQueryingTransferAuthorizationCode(request: SaveSingleTaskForQueryingTransferAuthorizationCodeRequest): SaveSingleTaskForQueryingTransferAuthorizationCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForQueryingTransferAuthorizationCodeWithOptions(request, runtime);
}

model SaveSingleTaskForSaveArtExtensionRequest {
  domainName?: string(name='DomainName'),
  objectType?: string(name='ObjectType'),
  materialsAndTechniques?: string(name='MaterialsAndTechniques'),
  dimensions?: string(name='Dimensions'),
  title?: string(name='Title'),
  dateOrPeriod?: string(name='DateOrPeriod'),
  maker?: string(name='Maker'),
  inscriptionsAndMarkings?: string(name='InscriptionsAndMarkings'),
  subject?: string(name='Subject'),
  features?: string(name='Features'),
  reference?: string(name='Reference'),
  lang?: string(name='Lang'),
}

model SaveSingleTaskForSaveArtExtensionResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForSaveArtExtensionResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForSaveArtExtensionResponseBody(name='body'),
}

async function saveSingleTaskForSaveArtExtensionWithOptions(request: SaveSingleTaskForSaveArtExtensionRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForSaveArtExtensionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForSaveArtExtension', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForSaveArtExtension(request: SaveSingleTaskForSaveArtExtensionRequest): SaveSingleTaskForSaveArtExtensionResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForSaveArtExtensionWithOptions(request, runtime);
}

model SaveSingleTaskForSynchronizingDnsHostRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForSynchronizingDnsHostResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForSynchronizingDnsHostResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForSynchronizingDnsHostResponseBody(name='body'),
}

async function saveSingleTaskForSynchronizingDnsHostWithOptions(request: SaveSingleTaskForSynchronizingDnsHostRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForSynchronizingDnsHostResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForSynchronizingDnsHost', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForSynchronizingDnsHost(request: SaveSingleTaskForSynchronizingDnsHostRequest): SaveSingleTaskForSynchronizingDnsHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForSynchronizingDnsHostWithOptions(request, runtime);
}

model SaveSingleTaskForSynchronizingDSRecordRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForSynchronizingDSRecordResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForSynchronizingDSRecordResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForSynchronizingDSRecordResponseBody(name='body'),
}

async function saveSingleTaskForSynchronizingDSRecordWithOptions(request: SaveSingleTaskForSynchronizingDSRecordRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForSynchronizingDSRecordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForSynchronizingDSRecord', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForSynchronizingDSRecord(request: SaveSingleTaskForSynchronizingDSRecordRequest): SaveSingleTaskForSynchronizingDSRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForSynchronizingDSRecordWithOptions(request, runtime);
}

model SaveSingleTaskForTransferProhibitionLockRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  domainName?: string(name='DomainName'),
  status?: boolean(name='Status'),
}

model SaveSingleTaskForTransferProhibitionLockResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForTransferProhibitionLockResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForTransferProhibitionLockResponseBody(name='body'),
}

async function saveSingleTaskForTransferProhibitionLockWithOptions(request: SaveSingleTaskForTransferProhibitionLockRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForTransferProhibitionLockResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForTransferProhibitionLock', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForTransferProhibitionLock(request: SaveSingleTaskForTransferProhibitionLockRequest): SaveSingleTaskForTransferProhibitionLockResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForTransferProhibitionLockWithOptions(request, runtime);
}

model SaveSingleTaskForUpdateProhibitionLockRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  domainName?: string(name='DomainName'),
  status?: boolean(name='Status'),
}

model SaveSingleTaskForUpdateProhibitionLockResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForUpdateProhibitionLockResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForUpdateProhibitionLockResponseBody(name='body'),
}

async function saveSingleTaskForUpdateProhibitionLockWithOptions(request: SaveSingleTaskForUpdateProhibitionLockRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForUpdateProhibitionLockResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForUpdateProhibitionLock', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForUpdateProhibitionLock(request: SaveSingleTaskForUpdateProhibitionLockRequest): SaveSingleTaskForUpdateProhibitionLockResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForUpdateProhibitionLockWithOptions(request, runtime);
}

model SaveSingleTaskForUpdatingContactInfoRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  domainName?: string(name='DomainName'),
  instanceId?: string(name='InstanceId'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  contactType?: string(name='ContactType'),
  addTransferLock?: boolean(name='AddTransferLock'),
}

model SaveSingleTaskForUpdatingContactInfoResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForUpdatingContactInfoResponse = {
  headers: map[string]string(name='headers'),
  body: SaveSingleTaskForUpdatingContactInfoResponseBody(name='body'),
}

async function saveSingleTaskForUpdatingContactInfoWithOptions(request: SaveSingleTaskForUpdatingContactInfoRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForUpdatingContactInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveSingleTaskForUpdatingContactInfo', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveSingleTaskForUpdatingContactInfo(request: SaveSingleTaskForUpdatingContactInfoRequest): SaveSingleTaskForUpdatingContactInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForUpdatingContactInfoWithOptions(request, runtime);
}

model SaveTaskForSubmittingDomainDeleteRequest {
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
  instanceId?: string(name='InstanceId'),
}

model SaveTaskForSubmittingDomainDeleteResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveTaskForSubmittingDomainDeleteResponse = {
  headers: map[string]string(name='headers'),
  body: SaveTaskForSubmittingDomainDeleteResponseBody(name='body'),
}

async function saveTaskForSubmittingDomainDeleteWithOptions(request: SaveTaskForSubmittingDomainDeleteRequest, runtime: Util.RuntimeOptions): SaveTaskForSubmittingDomainDeleteResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveTaskForSubmittingDomainDelete', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveTaskForSubmittingDomainDelete(request: SaveTaskForSubmittingDomainDeleteRequest): SaveTaskForSubmittingDomainDeleteResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTaskForSubmittingDomainDeleteWithOptions(request, runtime);
}

model SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  identityCredential?: string(name='IdentityCredential'),
  identityCredentialNo?: string(name='IdentityCredentialNo'),
  identityCredentialType?: string(name='IdentityCredentialType'),
  domainName?: [ string ](name='DomainName'),
}

model SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialResponse = {
  headers: map[string]string(name='headers'),
  body: SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialResponseBody(name='body'),
}

async function saveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialWithOptions(request: SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialRequest, runtime: Util.RuntimeOptions): SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredential', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveTaskForSubmittingDomainRealNameVerificationByIdentityCredential(request: SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialRequest): SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialWithOptions(request, runtime);
}

model SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  domainName?: string(name='DomainName'),
  instanceId?: string(name='InstanceId'),
  registrantProfileId?: long(name='RegistrantProfileId'),
}

model SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDResponse = {
  headers: map[string]string(name='headers'),
  body: SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDResponseBody(name='body'),
}

async function saveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDWithOptions(request: SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDRequest, runtime: Util.RuntimeOptions): SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileID', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileID(request: SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDRequest): SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDWithOptions(request, runtime);
}

model SaveTaskForUpdatingRegistrantInfoByIdentityCredentialRequest {
  postalCode?: string(name='PostalCode'),
  address?: string(name='Address'),
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  city?: string(name='City'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  registrantName?: string(name='RegistrantName'),
  province?: string(name='Province'),
  email?: string(name='Email'),
  country?: string(name='Country'),
  telArea?: string(name='TelArea'),
  telephone?: string(name='Telephone'),
  telExt?: string(name='TelExt'),
  zhCity?: string(name='ZhCity'),
  zhRegistrantOrganization?: string(name='ZhRegistrantOrganization'),
  zhRegistrantName?: string(name='ZhRegistrantName'),
  zhProvince?: string(name='ZhProvince'),
  zhAddress?: string(name='ZhAddress'),
  registrantType?: string(name='RegistrantType'),
  identityCredentialType?: string(name='IdentityCredentialType'),
  identityCredentialNo?: string(name='IdentityCredentialNo'),
  identityCredential?: string(name='IdentityCredential'),
  transferOutProhibited?: boolean(name='TransferOutProhibited'),
  domainName?: [ string ](name='DomainName'),
}

model SaveTaskForUpdatingRegistrantInfoByIdentityCredentialResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveTaskForUpdatingRegistrantInfoByIdentityCredentialResponse = {
  headers: map[string]string(name='headers'),
  body: SaveTaskForUpdatingRegistrantInfoByIdentityCredentialResponseBody(name='body'),
}

async function saveTaskForUpdatingRegistrantInfoByIdentityCredentialWithOptions(request: SaveTaskForUpdatingRegistrantInfoByIdentityCredentialRequest, runtime: Util.RuntimeOptions): SaveTaskForUpdatingRegistrantInfoByIdentityCredentialResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveTaskForUpdatingRegistrantInfoByIdentityCredential', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveTaskForUpdatingRegistrantInfoByIdentityCredential(request: SaveTaskForUpdatingRegistrantInfoByIdentityCredentialRequest): SaveTaskForUpdatingRegistrantInfoByIdentityCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTaskForUpdatingRegistrantInfoByIdentityCredentialWithOptions(request, runtime);
}

model SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  transferOutProhibited?: boolean(name='TransferOutProhibited'),
  domainName?: [ string ](name='DomainName'),
}

model SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDResponse = {
  headers: map[string]string(name='headers'),
  body: SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDResponseBody(name='body'),
}

async function saveTaskForUpdatingRegistrantInfoByRegistrantProfileIDWithOptions(request: SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDRequest, runtime: Util.RuntimeOptions): SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveTaskForUpdatingRegistrantInfoByRegistrantProfileID', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveTaskForUpdatingRegistrantInfoByRegistrantProfileID(request: SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDRequest): SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTaskForUpdatingRegistrantInfoByRegistrantProfileIDWithOptions(request, runtime);
}

model ScrollDomainListRequest {
  endExpirationDate?: long(name='EndExpirationDate'),
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  startExpirationDate?: long(name='StartExpirationDate'),
  productDomainType?: string(name='ProductDomainType'),
  pageSize?: int32(name='PageSize'),
  domainGroupId?: long(name='DomainGroupId'),
  domainStatus?: int32(name='DomainStatus'),
  endLength?: int32(name='EndLength'),
  excluded?: string(name='Excluded'),
  excludedPrefix?: boolean(name='ExcludedPrefix'),
  excludedSuffix?: boolean(name='ExcludedSuffix'),
  form?: int32(name='Form'),
  keyWord?: string(name='KeyWord'),
  keyWordPrefix?: boolean(name='KeyWordPrefix'),
  keyWordSuffix?: boolean(name='KeyWordSuffix'),
  startLength?: int32(name='StartLength'),
  tradeType?: int32(name='TradeType'),
  suffixs?: string(name='Suffixs'),
  startRegistrationDate?: long(name='StartRegistrationDate'),
  endRegistrationDate?: long(name='EndRegistrationDate'),
  scrollId?: string(name='ScrollId'),
}

model ScrollDomainListResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  scrollId?: string(name='ScrollId'),
  data?: {
    domain?: [ 
    {
      domainAuditStatus?: string(name='DomainAuditStatus'),
      domainGroupId?: string(name='DomainGroupId'),
      remark?: string(name='Remark'),
      domainGroupName?: string(name='DomainGroupName'),
      zhRegistrantOrganization?: string(name='ZhRegistrantOrganization'),
      registrantOrganization?: string(name='RegistrantOrganization'),
      registrationDate?: string(name='RegistrationDate'),
      instanceId?: string(name='InstanceId'),
      domainName?: string(name='DomainName'),
      expirationDateStatus?: string(name='ExpirationDateStatus'),
      expirationDate?: string(name='ExpirationDate'),
      dnsList?: {
        dns?: [ string ](name='Dns')
      }(name='DnsList'),
      email?: string(name='Email'),
      registrantType?: string(name='RegistrantType'),
      expirationDateLong?: long(name='ExpirationDateLong'),
      expirationCurrDateDiff?: int32(name='ExpirationCurrDateDiff'),
      premium?: boolean(name='Premium'),
      registrationDateLong?: long(name='RegistrationDateLong'),
      productId?: string(name='ProductId'),
      domainStatus?: string(name='DomainStatus'),
      domainType?: string(name='DomainType'),
    }
  ](name='Domain')
  }(name='Data'),
  totalItemNum?: int32(name='TotalItemNum'),
}

model ScrollDomainListResponse = {
  headers: map[string]string(name='headers'),
  body: ScrollDomainListResponseBody(name='body'),
}

async function scrollDomainListWithOptions(request: ScrollDomainListRequest, runtime: Util.RuntimeOptions): ScrollDomainListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ScrollDomainList', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function scrollDomainList(request: ScrollDomainListRequest): ScrollDomainListResponse {
  var runtime = new Util.RuntimeOptions{};
  return scrollDomainListWithOptions(request, runtime);
}

model SubmitEmailVerificationRequest {
  lang?: string(name='Lang'),
  email?: string(name='Email'),
  sendIfExist?: boolean(name='SendIfExist'),
  userClientIp?: string(name='UserClientIp'),
}

model SubmitEmailVerificationResponseBody = {
  requestId?: string(name='RequestId'),
  existList?: [ 
    {
      email?: string(name='Email'),
      code?: string(name='Code'),
      message?: string(name='Message'),
    }
  ](name='ExistList'),
  successList?: [ 
    {
      email?: string(name='Email'),
      code?: string(name='Code'),
      message?: string(name='Message'),
    }
  ](name='SuccessList'),
  failList?: [ 
    {
      email?: string(name='Email'),
      code?: string(name='Code'),
      message?: string(name='Message'),
    }
  ](name='FailList'),
}

model SubmitEmailVerificationResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitEmailVerificationResponseBody(name='body'),
}

async function submitEmailVerificationWithOptions(request: SubmitEmailVerificationRequest, runtime: Util.RuntimeOptions): SubmitEmailVerificationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitEmailVerification', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitEmailVerification(request: SubmitEmailVerificationRequest): SubmitEmailVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitEmailVerificationWithOptions(request, runtime);
}

model SubmitOperationAuditInfoRequest {
  lang?: string(name='Lang'),
  domainName?: string(name='DomainName'),
  auditType?: int32(name='AuditType'),
  auditInfo?: string(name='AuditInfo'),
  id?: long(name='Id'),
}

model SubmitOperationAuditInfoResponseBody = {
  requestId?: string(name='RequestId'),
  id?: long(name='Id'),
}

model SubmitOperationAuditInfoResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitOperationAuditInfoResponseBody(name='body'),
}

async function submitOperationAuditInfoWithOptions(request: SubmitOperationAuditInfoRequest, runtime: Util.RuntimeOptions): SubmitOperationAuditInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitOperationAuditInfo', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitOperationAuditInfo(request: SubmitOperationAuditInfoRequest): SubmitOperationAuditInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitOperationAuditInfoWithOptions(request, runtime);
}

model SubmitOperationCredentialsRequest {
  lang?: string(name='Lang'),
  auditRecordId?: long(name='AuditRecordId'),
  regType?: int32(name='RegType'),
  auditType?: int32(name='AuditType'),
  credentials?: string(name='Credentials'),
}

model SubmitOperationCredentialsResponseBody = {
  requestId?: string(name='RequestId'),
}

model SubmitOperationCredentialsResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitOperationCredentialsResponseBody(name='body'),
}

async function submitOperationCredentialsWithOptions(request: SubmitOperationCredentialsRequest, runtime: Util.RuntimeOptions): SubmitOperationCredentialsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitOperationCredentials', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitOperationCredentials(request: SubmitOperationCredentialsRequest): SubmitOperationCredentialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitOperationCredentialsWithOptions(request, runtime);
}

model TransferInCheckMailTokenRequest {
  token?: string(name='Token'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model TransferInCheckMailTokenResponseBody = {
  requestId?: string(name='RequestId'),
  successList?: {
    successDomain?: [ string ](name='SuccessDomain')
  }(name='SuccessList'),
  failList?: {
    failDomain?: [ string ](name='FailDomain')
  }(name='FailList'),
}

model TransferInCheckMailTokenResponse = {
  headers: map[string]string(name='headers'),
  body: TransferInCheckMailTokenResponseBody(name='body'),
}

async function transferInCheckMailTokenWithOptions(request: TransferInCheckMailTokenRequest, runtime: Util.RuntimeOptions): TransferInCheckMailTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TransferInCheckMailToken', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function transferInCheckMailToken(request: TransferInCheckMailTokenRequest): TransferInCheckMailTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return transferInCheckMailTokenWithOptions(request, runtime);
}

model TransferInReenterTransferAuthorizationCodeRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
  transferAuthorizationCode?: string(name='TransferAuthorizationCode'),
}

model TransferInReenterTransferAuthorizationCodeResponseBody = {
  requestId?: string(name='RequestId'),
}

model TransferInReenterTransferAuthorizationCodeResponse = {
  headers: map[string]string(name='headers'),
  body: TransferInReenterTransferAuthorizationCodeResponseBody(name='body'),
}

async function transferInReenterTransferAuthorizationCodeWithOptions(request: TransferInReenterTransferAuthorizationCodeRequest, runtime: Util.RuntimeOptions): TransferInReenterTransferAuthorizationCodeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TransferInReenterTransferAuthorizationCode', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function transferInReenterTransferAuthorizationCode(request: TransferInReenterTransferAuthorizationCodeRequest): TransferInReenterTransferAuthorizationCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return transferInReenterTransferAuthorizationCodeWithOptions(request, runtime);
}

model TransferInRefetchWhoisEmailRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model TransferInRefetchWhoisEmailResponseBody = {
  requestId?: string(name='RequestId'),
}

model TransferInRefetchWhoisEmailResponse = {
  headers: map[string]string(name='headers'),
  body: TransferInRefetchWhoisEmailResponseBody(name='body'),
}

async function transferInRefetchWhoisEmailWithOptions(request: TransferInRefetchWhoisEmailRequest, runtime: Util.RuntimeOptions): TransferInRefetchWhoisEmailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TransferInRefetchWhoisEmail', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function transferInRefetchWhoisEmail(request: TransferInRefetchWhoisEmailRequest): TransferInRefetchWhoisEmailResponse {
  var runtime = new Util.RuntimeOptions{};
  return transferInRefetchWhoisEmailWithOptions(request, runtime);
}

model TransferInResendMailTokenRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model TransferInResendMailTokenResponseBody = {
  requestId?: string(name='RequestId'),
}

model TransferInResendMailTokenResponse = {
  headers: map[string]string(name='headers'),
  body: TransferInResendMailTokenResponseBody(name='body'),
}

async function transferInResendMailTokenWithOptions(request: TransferInResendMailTokenRequest, runtime: Util.RuntimeOptions): TransferInResendMailTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TransferInResendMailToken', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function transferInResendMailToken(request: TransferInResendMailTokenRequest): TransferInResendMailTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return transferInResendMailTokenWithOptions(request, runtime);
}

model UpdateDomainToDomainGroupRequest {
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  fileToUpload?: string(name='FileToUpload'),
  domainGroupId?: long(name='DomainGroupId'),
  replace?: boolean(name='Replace'),
  dataSource?: int32(name='DataSource'),
  domainName?: [ string ](name='DomainName'),
}

model UpdateDomainToDomainGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDomainToDomainGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDomainToDomainGroupResponseBody(name='body'),
}

async function updateDomainToDomainGroupWithOptions(request: UpdateDomainToDomainGroupRequest, runtime: Util.RuntimeOptions): UpdateDomainToDomainGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateDomainToDomainGroup', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateDomainToDomainGroup(request: UpdateDomainToDomainGroupRequest): UpdateDomainToDomainGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDomainToDomainGroupWithOptions(request, runtime);
}

model VerifyContactFieldRequest {
  province?: string(name='Province'),
  userClientIp?: string(name='UserClientIp'),
  lang?: string(name='Lang'),
  city?: string(name='City'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  country?: string(name='Country'),
  registrantName?: string(name='RegistrantName'),
  address?: string(name='Address'),
  email?: string(name='Email'),
  postalCode?: string(name='PostalCode'),
  telArea?: string(name='TelArea'),
  telephone?: string(name='Telephone'),
  telExt?: string(name='TelExt'),
  zhRegistrantOrganization?: string(name='ZhRegistrantOrganization'),
  zhRegistrantName?: string(name='ZhRegistrantName'),
  zhProvince?: string(name='ZhProvince'),
  zhAddress?: string(name='ZhAddress'),
  zhCity?: string(name='ZhCity'),
  registrantType?: string(name='RegistrantType'),
  domainName?: string(name='DomainName'),
}

model VerifyContactFieldResponseBody = {
  requestId?: string(name='RequestId'),
}

model VerifyContactFieldResponse = {
  headers: map[string]string(name='headers'),
  body: VerifyContactFieldResponseBody(name='body'),
}

async function verifyContactFieldWithOptions(request: VerifyContactFieldRequest, runtime: Util.RuntimeOptions): VerifyContactFieldResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('VerifyContactField', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function verifyContactField(request: VerifyContactFieldRequest): VerifyContactFieldResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyContactFieldWithOptions(request, runtime);
}

model VerifyEmailRequest {
  lang?: string(name='Lang'),
  token?: string(name='Token'),
  userClientIp?: string(name='UserClientIp'),
}

model VerifyEmailResponseBody = {
  requestId?: string(name='RequestId'),
}

model VerifyEmailResponse = {
  headers: map[string]string(name='headers'),
  body: VerifyEmailResponseBody(name='body'),
}

async function verifyEmailWithOptions(request: VerifyEmailRequest, runtime: Util.RuntimeOptions): VerifyEmailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('VerifyEmail', '2018-01-29', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function verifyEmail(request: VerifyEmailRequest): VerifyEmailResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyEmailWithOptions(request, runtime);
}

