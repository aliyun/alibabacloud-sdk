/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('opensearch', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ABTestExperiment {
  name?: string(name='name'),
  online?: boolean(name='online'),
  params?: map[string]string(name='params'),
  serialNumber?: int32(name='serialNumber'),
  traffic?: int32(name='traffic'),
}

model ABTestGroup {
  name?: string(name='name'),
  status?: int32(name='status'),
}

model ABTestScene {
  name?: string(name='name'),
  status?: int32(name='status', example='0 停止实验 1 开通实验'),
  values?: [ string ](name='values'),
}

model App {
  autoSwitch?: boolean(name='autoSwitch'),
  cluster?: {
    maxQueryClauseLength?: int32(name='maxQueryClauseLength'),
    maxTimeoutMS?: int32(name='maxTimeoutMS'),
  }(name='cluster'),
  dataSources?: [
    DataSource
  ](name='dataSources'),
  description?: string(name='description'),
  domain?: Domain(name='domain'),
  fetchFields?: [ string ](name='fetchFields'),
  firstRanks?: [
    FirstRank
  ](name='firstRanks'),
  networkType?: string(name='networkType'),
  queryProcessors?: [
    QueryProcessor
  ](name='queryProcessors'),
  quota?: Quota(name='quota'),
  realtimeShared?: boolean(name='realtimeShared'),
  schema?: Schema(name='schema'),
  schemas?: [
    Schema
  ](name='schemas'),
  secondRanks?: [
    SecondRank
  ](name='secondRanks'),
  summaries?: [
    Summary
  ](name='summaries'),
  type?: string(name='type'),
}

model AppGroup {
  chargeType?: string(name='chargeType'),
  description?: string(name='description'),
  domain?: string(name='domain'),
  name?: string(name='name'),
  order?: {
    autoRenew?: boolean(name='autoRenew', example='false'),
    duration?: long(name='duration', example='1'),
    pricingCycle?: string(name='pricingCycle', example='Month'),
  }(name='order'),
  quota?: Quota(name='quota'),
  resourceGroupId?: string(name='resourceGroupId'),
  type?: string(name='type'),
}

model DataSource {
  fields?: [ map[string]string ](name='fields'),
  keyField?: string(name='keyField'),
  parameters?: map[string]any(name='parameters'),
  plugins?: map[string]DataSourcePluginsValue(name='plugins'),
  schemaName?: string(name='schemaName'),
  tableName?: string(name='tableName'),
  type?: string(name='type'),
}

model Domain {
  category?: string(name='category'),
  functions?: map[string][ string ](name='functions'),
  name?: string(name='name'),
}

model FirstRank {
  active?: boolean(name='active'),
  description?: string(name='description'),
  meta?: any(name='meta'),
  name?: string(name='name'),
  type?: string(name='type'),
}

model PrepayOrderInfo {
  autoRenew?: boolean(name='autoRenew'),
  duration?: int32(name='duration'),
  pricingCycle?: string(name='pricingCycle'),
}

model QueryProcessor {
  active?: boolean(name='active'),
  category?: string(name='category'),
  domain?: string(name='domain'),
  indexes?: [ string ](name='indexes'),
  name?: string(name='name'),
  processors?: [  map[string]any ](name='processors'),
}

model Quota {
  computeResource?: int32(name='computeResource'),
  docSize?: int32(name='docSize'),
  orderType?: string(name='orderType'),
  spec?: string(name='spec'),
}

model ScheduledTask {
  autoSwitch?: boolean(name='autoSwitch'),
  cron?: string(name='cron'),
  enabled?: boolean(name='enabled'),
  filter?: {
    days?: int32(name='days'),
    expression?: string(name='expression'),
    field?: string(name='field'),
    unit?: string(name='unit'),
  }(name='filter'),
  forkedAppId?: string(name='forkedAppId'),
  permanent?: boolean(name='permanent'),
  runNow?: boolean(name='runNow'),
  type?: string(name='type'),
  version?: string(name='version'),
}

model Schema {
  indexSortConfig?: [ 
    {
      direction?: string(name='direction'),
      field?: string(name='field'),
    }
  ](name='indexSortConfig'),
  indexes?: {
    filterFields?: [ string ](name='filterFields'),
    searchFields?: map[string]SchemaIndexesSearchFieldsValue(name='searchFields'),
  }(name='indexes'),
  name?: string(name='name'),
  routeField?: string(name='routeField'),
  routeFieldValues?: [ string ](name='routeFieldValues'),
  secondRouteField?: string(name='secondRouteField'),
  tables?: map[string]SchemaTablesValue(name='tables'),
  ttlField?: {
    name?: string(name='name'),
    ttl?: long(name='ttl'),
  }(name='ttlField'),
}

model SearchStrategy {
  description?: string(name='description'),
  isDefault?: boolean(name='isDefault'),
  mergeConfig?: {
    docCount?: int32(name='docCount'),
    rankName?: string(name='rankName'),
  }(name='mergeConfig'),
  name?: string(name='name'),
  searchConfigs?: [ 
    {
      firstRankName?: string(name='firstRankName'),
      mergeProportion?: int32(name='mergeProportion'),
      queryType?: string(name='queryType', example='keyword: 关键字查询 vector: 向量查询'),
      secondRankName?: string(name='secondRankName'),
    }
  ](name='searchConfigs'),
}

model SecondRank {
  active?: boolean(name='active'),
  description?: string(name='description'),
  meta?: any(name='meta'),
  name?: string(name='name'),
}

model Summary {
  active?: boolean(name='active'),
  meta?: {
    element?: string(name='element'),
    ellipsis?: string(name='ellipsis'),
    field?: string(name='field'),
    len?: int32(name='len'),
    snippet?: string(name='snippet'),
  }(name='meta'),
  name?: string(name='name'),
}

model DataSourcePluginsValue = {
  name?: string(name='name'),
  fromFields?: string(name='fromFields'),
  parameters?: map[string]string(name='parameters'),
}

model SchemaIndexesSearchFieldsValue = {
  analyzer?: string(name='analyzer'),
  analyzerType?: string(name='analyzerType'),
  analyzerGeneration?: string(name='analyzerGeneration'),
  fields?: [ string ](name='fields'),
  label?: string(name='label'),
}

model SchemaTablesValue = {
  name?: string(name='name'),
  primaryTable?: boolean(name='primaryTable'),
  fields?: map[string]SchemaTablesValueFieldsValue(name='fields'),
}

model SchemaTablesValueFieldsValue = {
  name?: string(name='name'),
  primaryKey?: boolean(name='primaryKey'),
  type?: string(name='type'),
  joinWith?: [ string ](name='joinWith'),
  label?: string(name='label'),
}

model BindESUserAnalyzerRequest {
  body?: any(name='body', description='The request parameters.', example='{
  "name": "kevintest-analyzer"
}'),
}

model BindESUserAnalyzerResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='3AD34CAD-9603-5251-AFF5-3916C848A1D3'),
  result?: map[string]any(name='result', description='The custom analyzer.', example='[]'),
}

model BindESUserAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindESUserAnalyzerResponseBody(name='body'),
}

/**
 * @summary Binds a custom analyzer to an Elasticsearch instance.
 *
 * @param request BindESUserAnalyzerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindESUserAnalyzerResponse
 */
async function bindESUserAnalyzerWithOptions(appGroupIdentity: string, esInstanceId: string, request: BindESUserAnalyzerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BindESUserAnalyzerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'BindESUserAnalyzer',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/es/${OpenApiUtil.getEncodeParam(esInstanceId)}/actions/bind-analyzer`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Binds a custom analyzer to an Elasticsearch instance.
 *
 * @param request BindESUserAnalyzerRequest
 * @return BindESUserAnalyzerResponse
 */
async function bindESUserAnalyzer(appGroupIdentity: string, esInstanceId: string, request: BindESUserAnalyzerRequest): BindESUserAnalyzerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return bindESUserAnalyzerWithOptions(appGroupIdentity, esInstanceId, request, headers, runtime);
}

model BindEsInstanceRequest {
  body?: map[string]any(name='body', description='The body of the request.', example='{
  "esInstanceId": "es-cn-abcde"
}'),
}

model BindEsInstanceResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='F5099063-6B86-F398-D843-905F9EFB683A'),
  result?: map[string]any(name='result', description='The result', example='[]'),
}

model BindEsInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindEsInstanceResponseBody(name='body'),
}

/**
 * @summary Binds an Elasticsearch instance.
 *
 * @param request BindEsInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindEsInstanceResponse
 */
async function bindEsInstanceWithOptions(appGroupIdentity: string, request: BindEsInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BindEsInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BindEsInstance',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/actions/bind-es-instance`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Binds an Elasticsearch instance.
 *
 * @param request BindEsInstanceRequest
 * @return BindEsInstanceResponse
 */
async function bindEsInstance(appGroupIdentity: string, request: BindEsInstanceRequest): BindEsInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return bindEsInstanceWithOptions(appGroupIdentity, request, headers, runtime);
}

model CompileSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
}

model CompileSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CompileSortScriptResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CompileSortScriptResponse
 */
async function compileSortScriptWithOptions(appGroupIdentity: string, scriptName: string, appVersionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): CompileSortScriptResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CompileSortScript',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appVersionId)}/sort-scripts/${OpenApiUtil.getEncodeParam(scriptName)}/actions/compiling`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return CompileSortScriptResponse
 */
async function compileSortScript(appGroupIdentity: string, scriptName: string, appVersionId: string): CompileSortScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return compileSortScriptWithOptions(appGroupIdentity, scriptName, appVersionId, headers, runtime);
}

model CreateABTestExperimentRequest {
  body?: ABTestExperiment(name='body', description='The request body.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run. This parameter is only used to check whether the data source is valid. Valid values: true and false.', example='false'),
}

model CreateABTestExperimentResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the experiment was created.', example='0'),
    id?: string(name='id', description='The experiment ID.', example='12889'),
    name?: string(name='name', description='The experiment alias.', example='test3'),
    online?: boolean(name='online', description='Indicates whether the experiment is in effect. Valid values:

*   true
*   false', example='true'),
    params?: map[string]any(name='params', description='The experiment parameters.', example='{"firstFormulaName": "default"}'),
    traffic?: int32(name='traffic', description='The percentage of traffic that is routed to the experiment.', example='30'),
    updated?: int32(name='updated', description='The time when the experiment was last modified.', example='1589017861'),
  }(name='result', description='The experiment details.'),
}

model CreateABTestExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateABTestExperimentResponseBody(name='body'),
}

/**
 * @summary Creates an experiment.
 *
 * @param request CreateABTestExperimentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateABTestExperimentResponse
 */
async function createABTestExperimentWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, request: CreateABTestExperimentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateABTestExperimentResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateABTestExperiment',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scenes/${OpenApiUtil.getEncodeParam(sceneId)}/groups/${OpenApiUtil.getEncodeParam(groupId)}/experiments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an experiment.
 *
 * @param request CreateABTestExperimentRequest
 * @return CreateABTestExperimentResponse
 */
async function createABTestExperiment(appGroupIdentity: string, sceneId: string, groupId: string, request: CreateABTestExperimentRequest): CreateABTestExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createABTestExperimentWithOptions(appGroupIdentity, sceneId, groupId, request, headers, runtime);
}

model CreateABTestGroupRequest {
  body?: ABTestGroup(name='body', description='The request body. For more information, see [ABTestGroup](https://help.aliyun.com/document_detail/178935.html).'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to check the validity of input parameters. Default value: false.

Valid values:

*   **true**: checks only the validity of input parameters.
*   **false**: checks the validity of input parameters and creates an attribution configuration.', example='true'),
}

model CreateABTestGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test group was created.', example='1588839490'),
    id?: string(name='id', description='The ID of the test group.', example='13466'),
    name?: string(name='name', description='The alias of the test group.', example='Group_2020-5-7_15:23:3'),
    status?: int32(name='status', description='The status of the test group.

*   0: not in effect
*   1: in effect', example='1'),
    updated?: int32(name='updated', description='The time when the test group was last updated.', example='1588839490'),
  }(name='result', description='The returned results.'),
}

model CreateABTestGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateABTestGroupResponseBody(name='body'),
}

/**
 * @summary Creates a test group.
 *
 * @param request CreateABTestGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateABTestGroupResponse
 */
async function createABTestGroupWithOptions(appGroupIdentity: string, sceneId: string, request: CreateABTestGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateABTestGroupResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateABTestGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scenes/${OpenApiUtil.getEncodeParam(sceneId)}/groups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a test group.
 *
 * @param request CreateABTestGroupRequest
 * @return CreateABTestGroupResponse
 */
async function createABTestGroup(appGroupIdentity: string, sceneId: string, request: CreateABTestGroupRequest): CreateABTestGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createABTestGroupWithOptions(appGroupIdentity, sceneId, request, headers, runtime);
}

model CreateABTestSceneRequest {
  body?: ABTestScene(name='body', description='The request body.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Default value: false.

Valid values:

*   **true**
*   **false**', example='false'),
}

model CreateABTestSceneResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test scenario was created.', example='0'),
    id?: string(name='id', description='The ID of the test group.', example='20405'),
    name?: string(name='name', description='The name of the test group.', example='kevintest_2020-5-7_15:21:48'),
    status?: int32(name='status', description='The status of the test scenario. Valid values:

*   0: not in effect
*   1: in effect', example='1'),
    updated?: int32(name='updated', description='The time when the test scenario was last modified.', example='1589012351'),
    values?: [ string ](name='values', description='The tag of the test scenario.'),
  }(name='result', description='The return result.'),
}

model CreateABTestSceneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateABTestSceneResponseBody(name='body'),
}

/**
 * @param request CreateABTestSceneRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateABTestSceneResponse
 */
async function createABTestSceneWithOptions(appGroupIdentity: string, request: CreateABTestSceneRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateABTestSceneResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateABTestScene',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scenes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateABTestSceneRequest
 * @return CreateABTestSceneResponse
 */
async function createABTestScene(appGroupIdentity: string, request: CreateABTestSceneRequest): CreateABTestSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createABTestSceneWithOptions(appGroupIdentity, request, headers, runtime);
}

model CreateAppRequest {
  autoSwitch?: boolean(name='autoSwitch'),
  cluster?: {
    maxQueryClauseLength?: int32(name='maxQueryClauseLength'),
    maxTimeoutMS?: int32(name='maxTimeoutMS'),
  }(name='cluster'),
  dataSources?: [ 
    {
      fields?: [  map[string]any ](name='fields'),
      keyField?: string(name='keyField'),
      parameters?: map[string]any(name='parameters'),
      plugins?: map[string]any(name='plugins'),
      schemaName?: string(name='schemaName'),
      tableName?: string(name='tableName'),
      type?: string(name='type'),
    }
  ](name='dataSources'),
  description?: string(name='description'),
  domain?: {
    category?: string(name='category'),
    functions?: map[string]any(name='functions'),
    name?: string(name='name'),
  }(name='domain'),
  fetchFields?: [ string ](name='fetchFields'),
  firstRanks?: [ 
    {
      active?: boolean(name='active'),
      description?: string(name='description'),
      meta?: any(name='meta'),
      name?: string(name='name'),
      type?: string(name='type'),
    }
  ](name='firstRanks'),
  networkType?: string(name='networkType'),
  queryProcessors?: [ 
    {
      active?: boolean(name='active'),
      category?: string(name='category'),
      domain?: string(name='domain'),
      indexes?: [ string ](name='indexes'),
      name?: string(name='name'),
      processors?: [  map[string]any ](name='processors'),
    }
  ](name='queryProcessors'),
  schema?: {
    indexSortConfig?: [ 
      {
        direction?: string(name='direction'),
        field?: string(name='field'),
      }
    ](name='indexSortConfig'),
    indexes?: {
      filterFields?: [ string ](name='filterFields'),
      searchFields?: map[string]any(name='searchFields'),
    }(name='indexes'),
    name?: string(name='name'),
    routeField?: string(name='routeField'),
    routeFieldValues?: [ string ](name='routeFieldValues'),
    secondRouteField?: string(name='secondRouteField'),
    tables?: map[string]any(name='tables'),
    ttlField?: {
      name?: string(name='name'),
      ttl?: long(name='ttl'),
    }(name='ttlField'),
  }(name='schema'),
  schemas?: [ 
    {
      indexSortConfig?: [ 
        {
          direction?: string(name='direction'),
          field?: string(name='field'),
        }
      ](name='indexSortConfig'),
      indexes?: {
        filterFields?: [ string ](name='filterFields'),
        searchFields?: map[string]any(name='searchFields'),
      }(name='indexes'),
      name?: string(name='name'),
      routeField?: string(name='routeField'),
      routeFieldValues?: [ string ](name='routeFieldValues'),
      secondRouteField?: string(name='secondRouteField'),
      tables?: map[string]any(name='tables'),
      ttlField?: {
        name?: string(name='name'),
        ttl?: long(name='ttl'),
      }(name='ttlField'),
    }
  ](name='schemas'),
  secondRanks?: [ 
    {
      active?: boolean(name='active'),
      description?: string(name='description'),
      meta?: any(name='meta'),
      name?: string(name='name'),
    }
  ](name='secondRanks'),
  summaries?: [ 
    {
      meta?: [ 
        {
          element?: string(name='element'),
          ellipsis?: string(name='ellipsis'),
          field?: string(name='field'),
          len?: int32(name='len'),
          snippet?: string(name='snippet'),
        }
      ](name='meta'),
      name?: string(name='name'),
    }
  ](name='summaries'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run. This parameter is only used to check whether the data source is valid. Valid values: true and false.', example='true'),
}

model CreateAppResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFG'),
  result?: {
    autoSwitch?: boolean(name='autoSwitch'),
    cluster?: {
      maxQueryClauseLength?: int32(name='maxQueryClauseLength'),
      maxTimeoutMS?: int32(name='maxTimeoutMS'),
    }(name='cluster'),
    clusterName?: string(name='clusterName'),
    dataSources?: [ 
      {
        fields?: [  map[string]any ](name='fields'),
        keyField?: string(name='keyField'),
        parameters?: map[string]any(name='parameters'),
        plugins?: map[string]any(name='plugins'),
        schemaName?: string(name='schemaName'),
        tableName?: string(name='tableName'),
        type?: string(name='type'),
      }
    ](name='dataSources'),
    description?: string(name='description'),
    domain?: {
      category?: string(name='category'),
      functions?: {
        algo?: [ string ](name='algo'),
        qp?: [ string ](name='qp'),
        service?: [ string ](name='service'),
      }(name='functions'),
      name?: string(name='name'),
    }(name='domain'),
    fetchFields?: [ string ](name='fetchFields'),
    firstRanks?: [ 
      {
        active?: boolean(name='active'),
        description?: string(name='description'),
        meta?: any(name='meta'),
        name?: string(name='name'),
        type?: string(name='type'),
      }
    ](name='firstRanks'),
    id?: string(name='id'),
    interpretations?: map[string]any(name='interpretations'),
    isCurrent?: boolean(name='isCurrent'),
    progressPercent?: int32(name='progressPercent'),
    prompts?: [  map[string]any ](name='prompts'),
    queryProcessors?: [ 
      {
        active?: boolean(name='active'),
        category?: string(name='category'),
        domain?: string(name='domain'),
        indexes?: [ string ](name='indexes'),
        name?: string(name='name'),
        processors?: [  map[string]any ](name='processors'),
      }
    ](name='queryProcessors'),
    quota?: {
      computeResource?: int32(name='computeResource'),
      docSize?: int32(name='docSize'),
      qps?: int32(name='qps'),
      spec?: string(name='spec'),
    }(name='quota'),
    schema?: {
      indexSortConfig?: [ 
        {
          direction?: string(name='direction'),
          field?: string(name='field'),
        }
      ](name='indexSortConfig'),
      indexes?: {
        filterFields?: [ string ](name='filterFields'),
        searchFields?: map[string]any(name='searchFields'),
      }(name='indexes'),
      name?: string(name='name'),
      routeField?: string(name='routeField'),
      routeFieldValues?: [ string ](name='routeFieldValues'),
      secondRouteField?: string(name='secondRouteField'),
      tables?: map[string]any(name='tables'),
      ttlField?: {
        name?: string(name='name'),
        ttl?: long(name='ttl'),
      }(name='ttlField'),
    }(name='schema'),
    schemas?: [ 
      {
        indexSortConfig?: [ 
          {
            direction?: string(name='direction'),
            field?: string(name='field'),
          }
        ](name='indexSortConfig'),
        indexes?: {
          filterFields?: [ string ](name='filterFields'),
          searchFields?: map[string]any(name='searchFields'),
        }(name='indexes'),
        name?: string(name='name'),
        routeField?: string(name='routeField'),
        routeFieldValues?: [ string ](name='routeFieldValues'),
        secondRouteField?: string(name='secondRouteField'),
        tables?: map[string]any(name='tables'),
        ttlField?: {
          name?: string(name='name'),
          ttl?: long(name='ttl'),
        }(name='ttlField'),
      }
    ](name='schemas'),
    secondRanks?: [ 
      {
        active?: boolean(name='active'),
        description?: string(name='description'),
        meta?: any(name='meta'),
        name?: string(name='name'),
      }
    ](name='secondRanks'),
    status?: string(name='status'),
    summaries?: [ 
      {
        meta?: [ 
          {
            element?: string(name='element'),
            ellipsis?: string(name='ellipsis'),
            field?: string(name='field'),
            len?: int32(name='len'),
            snippet?: string(name='snippet'),
          }
        ](name='meta'),
        name?: string(name='name'),
      }
    ](name='summaries'),
    type?: string(name='type'),
  }(name='result', description='The returned results.', example='{}'),
}

model CreateAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAppResponseBody(name='body'),
}

/**
 * @summary Creates a version for an OpenSearch application.
 *
 * @description *   When you create a standard application, a new version of the application is created if the specified application name already exists.
 * *   When you create a version of an existing application, you must specify the autoSwitch and realtimeShared parameters.
 * *   When you create a version of an existing application, the value of the quota parameter is the same as that of the quota parameter in the previous version of the application.
 * *   When you create a version of an existing application, the modification of the value of the quota parameter does not take effect.
 *
 * @param request CreateAppRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAppResponse
 */
async function createAppWithOptions(appGroupIdentity: string, request: CreateAppRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAppResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.autoSwitch)) {
    body['autoSwitch'] = request.autoSwitch;
  }
  if (!Util.isUnset(request.cluster)) {
    body['cluster'] = request.cluster;
  }
  if (!Util.isUnset(request.dataSources)) {
    body['dataSources'] = request.dataSources;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.domain)) {
    body['domain'] = request.domain;
  }
  if (!Util.isUnset(request.fetchFields)) {
    body['fetchFields'] = request.fetchFields;
  }
  if (!Util.isUnset(request.firstRanks)) {
    body['firstRanks'] = request.firstRanks;
  }
  if (!Util.isUnset(request.networkType)) {
    body['networkType'] = request.networkType;
  }
  if (!Util.isUnset(request.queryProcessors)) {
    body['queryProcessors'] = request.queryProcessors;
  }
  if (!Util.isUnset(request.schema)) {
    body['schema'] = request.schema;
  }
  if (!Util.isUnset(request.schemas)) {
    body['schemas'] = request.schemas;
  }
  if (!Util.isUnset(request.secondRanks)) {
    body['secondRanks'] = request.secondRanks;
  }
  if (!Util.isUnset(request.summaries)) {
    body['summaries'] = request.summaries;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateApp',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a version for an OpenSearch application.
 *
 * @description *   When you create a standard application, a new version of the application is created if the specified application name already exists.
 * *   When you create a version of an existing application, you must specify the autoSwitch and realtimeShared parameters.
 * *   When you create a version of an existing application, the value of the quota parameter is the same as that of the quota parameter in the previous version of the application.
 * *   When you create a version of an existing application, the modification of the value of the quota parameter does not take effect.
 *
 * @param request CreateAppRequest
 * @return CreateAppResponse
 */
async function createApp(appGroupIdentity: string, request: CreateAppRequest): CreateAppResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAppWithOptions(appGroupIdentity, request, headers, runtime);
}

model CreateAppGroupRequest {
  chargeType?: string(name='chargeType'),
  name?: string(name='name'),
  quota?: {
    computeResource?: int32(name='computeResource'),
    docSize?: int32(name='docSize'),
    spec?: string(name='spec'),
  }(name='quota'),
  resourceGroupId?: string(name='resourceGroupId'),
  type?: string(name='type'),
}

model CreateAppGroupResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='766CF6DB-CA02-3E12-7CBA-6AC21FC978FD'),
  result?: {
    chargeType?: string(name='chargeType', description='The billing method of the application. Valid values:

*   POSTPAY: pay-as-you-go
*   PREPAY: subscription', example='POSTPAY'),
    chargingWay?: int32(name='chargingWay', description='The billing model. Valid values:

*   1: computing resources
*   2: queries per second (QPS)', example='1'),
    commodityCode?: string(name='commodityCode', description='The code of the commodity.', example='opensearch'),
    created?: int32(name='created', description='The timestamp when the application was created.', example='1590139542'),
    currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='100302903'),
    description?: string(name='description', description='The description of the application.', example='-'),
    domain?: string(name='domain', description='The type of the industry. Valid values:

*   GENERAL: general.
*   ECOMMERCE: e-commerce.
*   IT_CONTENT: IT content.', example='GENERAL'),
    engineType?: string(name='engineType'),
    expireOn?: string(name='expireOn', description='The expiration time.', example='-'),
    hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval status of the quotas. Valid values:

*   0: The quotas are approved.
*   1: The quotas are being approved.', example='0'),
    id?: string(name='id', description='The ID of the application.', example='100302881'),
    instanceId?: string(name='instanceId', description='The ID of the instance.', example='-'),
    lockMode?: string(name='lockMode', description='The lock mode of the instance. Valid values:

*   Unlock: The instance is not locked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
    name?: string(name='name', description='The name of the application.', example='lsh_test_1'),
    produced?: int32(name='produced', description='Indicates whether the order is complete. Valid values:

*   0: The order is in progress.
*   1: The order is complete.', example='1'),
    projectId?: string(name='projectId', description='The name of the A/B test group.', example='-'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing units (LCUs).', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
      spec?: string(name='spec', description='The specifications of the application. Valid values:

*   opensearch.share.junior: basic
*   opensearch.share.common: shared general-purpose
*   opensearch.share.compute: shared computing
*   opensearch.share.storage: shared storage
*   opensearch.private.common: exclusive general-purpose
*   opensearch.private.compute: exclusive computing
*   opensearch.private.storage: exclusive storage', example='opensearch.share.common'),
    }(name='quota', description='The information about the quotas of the application.'),
    status?: string(name='status', description='The status of the application. Valid values:

*   producing
*   review_pending
*   config_pending
*   normal
*   frozen', example='normal'),
    switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='1590486386'),
    type?: string(name='type', description='The type of the application. Valid values:

*   standard: a standard application.
*   advance: an advanced application which is of an old application type. New applications cannot be of this type.
*   enhanced: an advanced application which is of a new application type.', example='enhanced'),
    updated?: int32(name='updated', description='The timestamp when the application was last updated.', example='1590978265'),
  }(name='result', description='N/A'),
}

model CreateAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAppGroupResponseBody(name='body'),
}

/**
 * @summary Create an OpenSearch application.
 *
 * @param request CreateAppGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAppGroupResponse
 */
async function createAppGroupWithOptions(request: CreateAppGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAppGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chargeType)) {
    body['chargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.quota)) {
    body['quota'] = request.quota;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAppGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create an OpenSearch application.
 *
 * @param request CreateAppGroupRequest
 * @return CreateAppGroupResponse
 */
async function createAppGroup(request: CreateAppGroupRequest): CreateAppGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAppGroupWithOptions(request, headers, runtime);
}

model CreateAppGroupCredentialsRequest {
  type?: string(name='type', example='api-token'),
  dryRun?: boolean(name='dryRun'),
}

model CreateAppGroupCredentialsResponseBody = {
  requestId?: string(name='requestId', example='1-2-3-4'),
  result?: {
    appGroupId?: long(name='appGroupId', example='app_group_123'),
    enabled?: boolean(name='enabled'),
    token?: string(name='token', example='generated_token_string'),
    type?: string(name='type', example='api-token'),
  }(name='result'),
}

model CreateAppGroupCredentialsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAppGroupCredentialsResponseBody(name='body'),
}

/**
 * @param request CreateAppGroupCredentialsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAppGroupCredentialsResponse
 */
async function createAppGroupCredentialsWithOptions(appGroupIdentity: string, request: CreateAppGroupCredentialsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAppGroupCredentialsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAppGroupCredentials',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/credentials`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateAppGroupCredentialsRequest
 * @return CreateAppGroupCredentialsResponse
 */
async function createAppGroupCredentials(appGroupIdentity: string, request: CreateAppGroupCredentialsRequest): CreateAppGroupCredentialsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAppGroupCredentialsWithOptions(appGroupIdentity, request, headers, runtime);
}

model CreateFirstRankRequest {
  body?: FirstRank(name='body', description='The request body that contains the parameters of the rough sort expression.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run.', example='true'),
}

model CreateFirstRankResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
    meta?: [ 
      {
        arg?: string(name='arg', description='The parameters that are used by a function in the expression.', example='1'),
        attribute?: string(name='attribute', description='The attribute, feature functions, or field to be searched for.', example='static_bm25()'),
        weight?: float(name='weight', description='The weight. Valid values: [-100000,100000]. The value cannot be 0.', example='10'),
      }
    ](name='meta', description='The content of the expression.'),
    name?: string(name='name', description='The name of the expression.', example='default'),
  }(name='result', description='The information about the rough sort expression.'),
}

model CreateFirstRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFirstRankResponseBody(name='body'),
}

/**
 * @summary Creates a rough sort expression for a version of an OpenSearch application. If you set dryRun to true, this operation checks the specified rough sort expression. By default, the value of dryRun is false if you do not set this parameter.
 *
 * @param request CreateFirstRankRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFirstRankResponse
 */
async function createFirstRankWithOptions(appGroupIdentity: string, appId: string, request: CreateFirstRankRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFirstRankResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFirstRank',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/first-ranks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a rough sort expression for a version of an OpenSearch application. If you set dryRun to true, this operation checks the specified rough sort expression. By default, the value of dryRun is false if you do not set this parameter.
 *
 * @param request CreateFirstRankRequest
 * @return CreateFirstRankResponse
 */
async function createFirstRank(appGroupIdentity: string, appId: string, request: CreateFirstRankRequest): CreateFirstRankResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFirstRankWithOptions(appGroupIdentity, appId, request, headers, runtime);
}

model CreateFunctionInstanceRequest {
  createParameters?: [ 
    {
      name?: string(name='name', description='The parameter name.', example='title_field'),
      value?: string(name='value', description='The parameter value.', example='title'),
    }
  ](name='createParameters', description='The parameters used to create the instance.', example='[   { "name": "param1", "value": "val1"   } ]'),
  cron?: string(name='cron', description='The CRON expression used to schedule periodic training, in the format of Minutes Hours DayofMonth Month DayofWeek. The default value is empty, which specifies that no periodic training is performed. A value of 0 for DayofWeek specifies Sunday.', example='0 0 ? * 0,1,2,3,4,5,6'),
  description?: string(name='description', description='The description.', example='test instance'),
  functionType?: string(name='functionType', description='The feature type.

*   Default value: PAAS. Training is required before you can use the feature.', example='PAAS'),
  instanceName?: string(name='instanceName', description='The instance name. The name must be 1 to 30 characters in length and can contain letters, digits, and underscores (_). The name is case-sensitive and must start with a letter.

This parameter is required.', example='ctr_test'),
  modelType?: string(name='modelType', description='The model type. The value varies based on the model.

*   Click-through rate (CTR) model: tf_checkpoint
*   Popularity model: pop
*   Category model: offline_inference
*   Hotword model: offline_inference
*   Hint model: offline_inference
*   Hotword model for real-time top searches: near_realtime
*   Personalized hint model: near_realtime
*   Drop-down suggestion model: offline_inference
*   Tokenization model: text
*   Term weight model: tf_checkpoint
*   Synonym model: offline_inference

This parameter is required.', example='tf_checkpoint'),
  usageParameters?: [ 
    {
      name?: string(name='name', description='The parameter name.', example='allow_dict_id'),
      value?: string(name='value', description='The parameter value.', example='123'),
    }
  ](name='usageParameters', description='The parameters used to use the instance.'),
}

model CreateFunctionInstanceResponseBody = {
  code?: string(name='Code', description='The error code.', example='Version.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message. If no error occurs, this parameter is left empty.', example='version not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='98724351-D6B2-5D8A-B089-7FFD1821A7E9'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model CreateFunctionInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFunctionInstanceResponseBody(name='body'),
}

/**
 * @summary Creates an algorithm instance of a feature.
 *
 * @description You can call the [GetFunctionCurrentVersion](https://help.aliyun.com/document_detail/421377.html) operation to query the latest version of a feature. The response of the operation includes the createParameters parameter that is used to create an algorithm instance, the usageParameters parameter, and the requirements for setting these parameters.
 *
 * @param request CreateFunctionInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFunctionInstanceResponse
 */
async function createFunctionInstanceWithOptions(appGroupIdentity: string, functionName: string, request: CreateFunctionInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFunctionInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.createParameters)) {
    body['createParameters'] = request.createParameters;
  }
  if (!Util.isUnset(request.cron)) {
    body['cron'] = request.cron;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.functionType)) {
    body['functionType'] = request.functionType;
  }
  if (!Util.isUnset(request.instanceName)) {
    body['instanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.modelType)) {
    body['modelType'] = request.modelType;
  }
  if (!Util.isUnset(request.usageParameters)) {
    body['usageParameters'] = request.usageParameters;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFunctionInstance',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/instances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an algorithm instance of a feature.
 *
 * @description You can call the [GetFunctionCurrentVersion](https://help.aliyun.com/document_detail/421377.html) operation to query the latest version of a feature. The response of the operation includes the createParameters parameter that is used to create an algorithm instance, the usageParameters parameter, and the requirements for setting these parameters.
 *
 * @param request CreateFunctionInstanceRequest
 * @return CreateFunctionInstanceResponse
 */
async function createFunctionInstance(appGroupIdentity: string, functionName: string, request: CreateFunctionInstanceRequest): CreateFunctionInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFunctionInstanceWithOptions(appGroupIdentity, functionName, request, headers, runtime);
}

model CreateFunctionResourceRequest {
  data?: {
    content?: string(name='Content', description='The content of the file that corresponds to a resource of the raw_file type.', example='"abc"'),
    generators?: [ 
      {
        generator?: string(name='Generator', description='The type of the feature generator.

Valid values:

*   lookup

    <!-- -->

    <!-- -->

    <!-- -->

*   sequence

    <!-- -->

    <!-- -->

    <!-- -->

*   overlap

    <!-- -->

    <!-- -->

    <!-- -->

*   raw

    <!-- -->

    <!-- -->

    <!-- -->

*   combo

    <!-- -->

    <!-- -->

    <!-- -->

*   id

    <!-- -->

    <!-- -->

    <!-- -->', example='id'),
        input?: {
          features?: [ 
            {
              name?: string(name='Name', description='The name of the feature.', example='system_item_id'),
              type?: string(name='Type', description='The type of the feature.

Valid values:

*   item

    <!-- -->

    <!-- -->

    <!-- -->

*   user

    <!-- -->

    <!-- -->

    <!-- -->', example='item'),
            }
          ](name='Features', description='The input features.'),
        }(name='Input', description='The input.'),
        output?: string(name='Output', description='The name of the output feature.', example='item_id_feature'),
      }
    ](name='Generators', description='The feature generators that correspond to resources of the feature_generator type.'),
  }(name='Data', description='The resource data. The data structure varies with the resource type.'),
  description?: string(name='Description', description='The description of the resource.', example='""'),
  resourceName?: string(name='ResourceName', description='The name of the resource.', example='fg_jsoon'),
  resourceType?: string(name='ResourceType', description='The resource type.

Valid values:

*   feature_generator

    <!-- -->

    <!-- -->

    <!-- -->

*   raw_file

    <!-- -->

    <!-- -->

    <!-- -->', example='feature_generator'),
}

model CreateFunctionResourceResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, this parameter is left empty.', example='""'),
  httpCode?: long(name='HttpCode', description='The HTTP status code returned.', example='200'),
  latency?: double(name='Latency', description='The time consumed for the request. Unit: milliseconds.', example='123'),
  message?: string(name='Message', description='The error message returned.', example='""'),
  requestId?: string(name='RequestId', description='The request ID.', example='A4D487A9-A456-5AA5-A9C6-B7BF2889CF74'),
  status?: string(name='Status', description='The status code. Valid values:

*   OK
*   FAIL', example='OK'),
}

model CreateFunctionResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFunctionResourceResponseBody(name='body'),
}

/**
 * @summary Creates an algorithm resource for a specific feature.
 *
 * @param request CreateFunctionResourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFunctionResourceResponse
 */
async function createFunctionResourceWithOptions(appGroupIdentity: string, functionName: string, request: CreateFunctionResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFunctionResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.data)) {
    body['Data'] = request.data;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.resourceName)) {
    body['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFunctionResource',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/resources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an algorithm resource for a specific feature.
 *
 * @param request CreateFunctionResourceRequest
 * @return CreateFunctionResourceResponse
 */
async function createFunctionResource(appGroupIdentity: string, functionName: string, request: CreateFunctionResourceRequest): CreateFunctionResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFunctionResourceWithOptions(appGroupIdentity, functionName, request, headers, runtime);
}

model CreateFunctionTaskResponseBody = {
  code?: string(name='Code', description='The error code.', example='Task.IsRunning'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1638157990724'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model CreateFunctionTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFunctionTaskResponseBody(name='body'),
}

/**
 * @summary Starts a training task for an algorithm instance.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFunctionTaskResponse
 */
async function createFunctionTaskWithOptions(appGroupIdentity: string, functionName: string, instanceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFunctionTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CreateFunctionTask',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/instances/${OpenApiUtil.getEncodeParam(instanceName)}/tasks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Starts a training task for an algorithm instance.
 *
 * @return CreateFunctionTaskResponse
 */
async function createFunctionTask(appGroupIdentity: string, functionName: string, instanceName: string): CreateFunctionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFunctionTaskWithOptions(appGroupIdentity, functionName, instanceName, headers, runtime);
}

model CreateInterventionDictionaryRequest {
  analyzerType?: string(name='analyzerType', description='The type of the analyzer. Valid values:

*   MODEL: model-based custom analyzer.
*   SYSTEM: system analyzer.
*   USER: custom analyzer.', example='SYSTEM'),
  name?: string(name='name', description='The name of the intervention dictionary.', example='ner_dict_ec'),
  type?: string(name='type', description='The type of the intervention dictionary. Valid values:

*   stopword: an intervention dictionary for stop word filtering.
*   synonym: an intervention dictionary for synonym configuration.
*   correction: an intervention dictionary for spelling correction.
*   category_prediction: an intervention dictionary for category prediction.
*   ner: an intervention dictionary for named entity recognition (NER).
*   term_weighting: an intervention dictionary for term weight analysis.
*   suggest_allowlist: a drop-down suggestion whitelist.
*   suggest_denylist: a drop-down suggestion blacklist.
*   hot_allowlist: a top search whitelist.
*   hot_denylist: a top search blacklist.
*   hint_allowlist: a hint whitelist.
*   hint_denylist: a hint blacklist.', example='ner'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Default value: false.

Valid values:

*   **true**
*   **false**', example='false'),
}

model CreateInterventionDictionaryResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='80326EFE-485F-46E7-B291-5A1DD08D2198'),
  result?: {
    analyzer?: string(name='analyzer', description='The custom analyzer.', example='dianshang'),
    created?: string(name='created', description='The time when the test scenario was created.', example='1591086323'),
    name?: string(name='name', description='The name of the test group.', example='testb'),
    type?: string(name='type', description='The type of the intervention dictionary. Valid values:

*   stopword: an intervention dictionary for stop word filtering
*   synonym: an intervention dictionary for synonym configuration
*   correction: an intervention dictionary for spelling correction
*   category_prediction: an intervention dictionary for category prediction
*   ner: an intervention dictionary for named entity recognition (NER)
*   term_weighting: an intervention dictionary for term weight analysis', example='ner'),
    updated?: string(name='updated', description='The time when the intervention dictionary was last updated.', example='1591086323'),
  }(name='result', description='The returned results.'),
}

model CreateInterventionDictionaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateInterventionDictionaryResponseBody(name='body'),
}

/**
 * @summary Create an intervention dictionary.
 *
 * @param request CreateInterventionDictionaryRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateInterventionDictionaryResponse
 */
async function createInterventionDictionaryWithOptions(request: CreateInterventionDictionaryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateInterventionDictionaryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.analyzerType)) {
    body['analyzerType'] = request.analyzerType;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateInterventionDictionary',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/intervention-dictionaries`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create an intervention dictionary.
 *
 * @param request CreateInterventionDictionaryRequest
 * @return CreateInterventionDictionaryResponse
 */
async function createInterventionDictionary(request: CreateInterventionDictionaryRequest): CreateInterventionDictionaryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createInterventionDictionaryWithOptions(request, headers, runtime);
}

model CreateQueryProcessorRequest {
  body?: any(name='body', description='The request body.', example='{}'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run.', example='true'),
}

model CreateQueryProcessorResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the query analysis rule is the default one.', example='true'),
    created?: int32(name='created', description='The time when the query analysis rule was created.', example='1587398402'),
    domain?: string(name='domain', description='The type of the industry to which the query analysis rule was applied. Valid values:

*   GENERAL: general.
*   ECOMMERCE: e-commerce.
*   IT_CONTENT: IT content.', example='GENERAL'),
    indexes?: [ string ](name='indexes', description='The indexes to which the query analysis rule was applied.'),
    name?: string(name='name', description='The name of the query analysis rule.', example='query_filter'),
    processors?: [  map[string]any ](name='processors', description='The features that are used in the query analysis rule.

For more information, see [QueryProcessor](https://help.aliyun.com/document_detail/170014.html).'),
    updated?: int32(name='updated', description='The time when the query analysis rule was last modified.', example='1587398402'),
  }(name='result', description='The information about the query analysis rule.'),
}

model CreateQueryProcessorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateQueryProcessorResponseBody(name='body'),
}

/**
 * @summary Creates a query analysis rule. If you set dryRun to true, this operation checks the specified query analysis rule. By default, the value of dryRun is false if you do not set this parameter.
 *
 * @param request CreateQueryProcessorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateQueryProcessorResponse
 */
async function createQueryProcessorWithOptions(appGroupIdentity: string, appId: string, request: CreateQueryProcessorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateQueryProcessorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateQueryProcessor',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/query-processors`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a query analysis rule. If you set dryRun to true, this operation checks the specified query analysis rule. By default, the value of dryRun is false if you do not set this parameter.
 *
 * @param request CreateQueryProcessorRequest
 * @return CreateQueryProcessorResponse
 */
async function createQueryProcessor(appGroupIdentity: string, appId: string, request: CreateQueryProcessorRequest): CreateQueryProcessorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createQueryProcessorWithOptions(appGroupIdentity, appId, request, headers, runtime);
}

model CreateScheduledTaskRequest {
  body?: ScheduledTask(name='body', description='请求体'),
}

model CreateScheduledTaskResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='The details of the scheduled task.', example='{}'),
}

model CreateScheduledTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateScheduledTaskResponseBody(name='body'),
}

/**
 * @param request CreateScheduledTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateScheduledTaskResponse
 */
async function createScheduledTaskWithOptions(appGroupIdentity: string, request: CreateScheduledTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateScheduledTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateScheduledTask',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scheduled-tasks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateScheduledTaskRequest
 * @return CreateScheduledTaskResponse
 */
async function createScheduledTask(appGroupIdentity: string, request: CreateScheduledTaskRequest): CreateScheduledTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createScheduledTaskWithOptions(appGroupIdentity, request, headers, runtime);
}

model CreateSearchStrategyRequest {
  body?: SearchStrategy(name='body', description='The query policy.'),
}

model CreateSearchStrategyResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='"abc123"'),
}

model CreateSearchStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSearchStrategyResponseBody(name='body'),
}

/**
 * @summary Creates a query policy.
 *
 * @param request CreateSearchStrategyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSearchStrategyResponse
 */
async function createSearchStrategyWithOptions(appGroupIdentity: string, appId: string, request: CreateSearchStrategyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSearchStrategyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSearchStrategy',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/search-strategies`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a query policy.
 *
 * @param request CreateSearchStrategyRequest
 * @return CreateSearchStrategyResponse
 */
async function createSearchStrategy(appGroupIdentity: string, appId: string, request: CreateSearchStrategyRequest): CreateSearchStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSearchStrategyWithOptions(appGroupIdentity, appId, request, headers, runtime);
}

model CreateSecondRankRequest {
  body?: SecondRank(name='body', description='The request body. For more information, see [SecondRank](https://help.aliyun.com/document_detail/170008.html).'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run.', example='true'),
}

model CreateSecondRankResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='The information about the fine sort expression.', example='{}'),
}

model CreateSecondRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSecondRankResponseBody(name='body'),
}

/**
 * @summary Creates a fine sort expression for a version of an OpenSearch application. If you set dryRun to true, this operation checks the specified fine sort expression. The default value of dryRun is false if you do not set this parameter.
 *
 * @param request CreateSecondRankRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSecondRankResponse
 */
async function createSecondRankWithOptions(appGroupIdentity: string, appId: string, request: CreateSecondRankRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSecondRankResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSecondRank',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/second-ranks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a fine sort expression for a version of an OpenSearch application. If you set dryRun to true, this operation checks the specified fine sort expression. The default value of dryRun is false if you do not set this parameter.
 *
 * @param request CreateSecondRankRequest
 * @return CreateSecondRankResponse
 */
async function createSecondRank(appGroupIdentity: string, appId: string, request: CreateSecondRankRequest): CreateSecondRankResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSecondRankWithOptions(appGroupIdentity, appId, request, headers, runtime);
}

model CreateSortScriptRequest {
  scope?: string(name='scope', description='The sort phase to which the script applies.', example='second_rank'),
  scriptName?: string(name='scriptName', description='The script name.', example='rank_cava_20230606_v7'),
  type?: string(name='type', description='The script type. Set the value to cava_script.', example='cava_script'),
}

model CreateSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: {
    scope?: string(name='scope', description='The sort phase to which the script applies.', example='second_rank'),
    scriptName?: string(name='scriptName', description='The script name.', example='rank_cava_20230606_v7'),
    type?: string(name='type', description='The script type.', example='cava_script'),
  }(name='result', description='The response parameters.'),
}

model CreateSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSortScriptResponseBody(name='body'),
}

/**
 * @summary Creates a sort script.
 *
 * @param request CreateSortScriptRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSortScriptResponse
 */
async function createSortScriptWithOptions(appGroupIdentity: string, appVersionId: string, request: CreateSortScriptRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSortScriptResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.scope)) {
    body['scope'] = request.scope;
  }
  if (!Util.isUnset(request.scriptName)) {
    body['scriptName'] = request.scriptName;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSortScript',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appVersionId)}/sort-scripts`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a sort script.
 *
 * @param request CreateSortScriptRequest
 * @return CreateSortScriptResponse
 */
async function createSortScript(appGroupIdentity: string, appVersionId: string, request: CreateSortScriptRequest): CreateSortScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSortScriptWithOptions(appGroupIdentity, appVersionId, request, headers, runtime);
}

model CreateUserAnalyzerRequest {
  business?: string(name='business', description='The basic analyzer.', example='chn_standard'),
  businessAppGroupId?: string(name='businessAppGroupId', description='The application ID of the custom analyzer.', example='110123123'),
  businessType?: string(name='businessType', description='The basic analyzer type. Valid values: AUTO, MODEL, SYSTEM, and USER.', example='AUTO'),
  name?: string(name='name', description='The analyzer name.', example='jmbon_analyzer'),
  type?: string(name='type', description='The engine type. Valid values: HA3 and ES.', example='HA3'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Default value: false.

Valid values:

*   **true**
*   **false**', example='false'),
}

model CreateUserAnalyzerResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='98724351-D6B2-5D8A-B089-7FFD1821A7E9'),
  result?: map[string]any(name='result', description='The custom analyzer.', example='{}'),
}

model CreateUserAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateUserAnalyzerResponseBody(name='body'),
}

/**
 * @param request CreateUserAnalyzerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUserAnalyzerResponse
 */
async function createUserAnalyzerWithOptions(request: CreateUserAnalyzerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateUserAnalyzerResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.business)) {
    body['business'] = request.business;
  }
  if (!Util.isUnset(request.businessAppGroupId)) {
    body['businessAppGroupId'] = request.businessAppGroupId;
  }
  if (!Util.isUnset(request.businessType)) {
    body['businessType'] = request.businessType;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateUserAnalyzer',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/user-analyzers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateUserAnalyzerRequest
 * @return CreateUserAnalyzerResponse
 */
async function createUserAnalyzer(request: CreateUserAnalyzerRequest): CreateUserAnalyzerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createUserAnalyzerWithOptions(request, headers, runtime);
}

model DeleteABTestExperimentResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='The result that was returned.', example='{}'),
}

model DeleteABTestExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteABTestExperimentResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteABTestExperimentResponse
 */
async function deleteABTestExperimentWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteABTestExperimentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteABTestExperiment',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scenes/${OpenApiUtil.getEncodeParam(sceneId)}/groups/${OpenApiUtil.getEncodeParam(groupId)}/experiments/${OpenApiUtil.getEncodeParam(experimentId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DeleteABTestExperimentResponse
 */
async function deleteABTestExperiment(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string): DeleteABTestExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteABTestExperimentWithOptions(appGroupIdentity, sceneId, groupId, experimentId, headers, runtime);
}

model DeleteABTestGroupResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='The return result.', example='{}'),
}

model DeleteABTestGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteABTestGroupResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteABTestGroupResponse
 */
async function deleteABTestGroupWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteABTestGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteABTestGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scenes/${OpenApiUtil.getEncodeParam(sceneId)}/groups/${OpenApiUtil.getEncodeParam(groupId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DeleteABTestGroupResponse
 */
async function deleteABTestGroup(appGroupIdentity: string, sceneId: string, groupId: string): DeleteABTestGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteABTestGroupWithOptions(appGroupIdentity, sceneId, groupId, headers, runtime);
}

model DeleteABTestSceneResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='The returned results.', example='{}'),
}

model DeleteABTestSceneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteABTestSceneResponseBody(name='body'),
}

/**
 * @summary Deletes an A/B test scenario.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteABTestSceneResponse
 */
async function deleteABTestSceneWithOptions(appGroupIdentity: string, sceneId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteABTestSceneResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteABTestScene',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scenes/${OpenApiUtil.getEncodeParam(sceneId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an A/B test scenario.
 *
 * @return DeleteABTestSceneResponse
 */
async function deleteABTestScene(appGroupIdentity: string, sceneId: string): DeleteABTestSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteABTestSceneWithOptions(appGroupIdentity, sceneId, headers, runtime);
}

model DeleteFunctionInstanceResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, this parameter is left empty.', example='"Instance.NotExist"'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='10'),
  message?: string(name='Message', description='The error message. If no error occurs, this parameter is left empty.', example='"instance not exist."'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='"1081EB05-473C-5BF4-95BE-6D7CAD5E2213"'),
  status?: string(name='Status', description='The status of the request. Valid values:

*   OK: The request is successful.
*   FAIL: The request fails.', example='"OK"'),
}

model DeleteFunctionInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFunctionInstanceResponseBody(name='body'),
}

/**
 * @summary Deletes an algorithm instance. Before you delete an instance, make sure that it is not in use to prevent service interruptions.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFunctionInstanceResponse
 */
async function deleteFunctionInstanceWithOptions(appGroupIdentity: string, functionName: string, instanceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFunctionInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunctionInstance',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/instances/${OpenApiUtil.getEncodeParam(instanceName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an algorithm instance. Before you delete an instance, make sure that it is not in use to prevent service interruptions.
 *
 * @return DeleteFunctionInstanceResponse
 */
async function deleteFunctionInstance(appGroupIdentity: string, functionName: string, instanceName: string): DeleteFunctionInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionInstanceWithOptions(appGroupIdentity, functionName, instanceName, headers, runtime);
}

model DeleteFunctionResourceResponseBody = {
  code?: string(name='Code', description='The error code returned. If no error occurs, this value is empty.', example='""'),
  httpCode?: long(name='HttpCode', description='The HTTP status code returned.', example='200'),
  latency?: double(name='Latency', description='The time consumed for the request. Unit: milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='""'),
  requestId?: string(name='RequestId', description='The request ID.', example='A4D487A9-A456-5AA5-A9C6-B7BF2889CF74'),
  status?: string(name='Status', description='The status code. Valid values:

*   OK
*   FAIL', example='OK'),
}

model DeleteFunctionResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFunctionResourceResponseBody(name='body'),
}

/**
 * @summary Deletes an algorithm resource.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFunctionResourceResponse
 */
async function deleteFunctionResourceWithOptions(appGroupIdentity: string, functionName: string, resourceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFunctionResourceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunctionResource',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/resources/${OpenApiUtil.getEncodeParam(resourceName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an algorithm resource.
 *
 * @return DeleteFunctionResourceResponse
 */
async function deleteFunctionResource(appGroupIdentity: string, functionName: string, resourceName: string): DeleteFunctionResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionResourceWithOptions(appGroupIdentity, functionName, resourceName, headers, runtime);
}

model DeleteFunctionTaskResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, this parameter is left empty.', example='Task.UnableDelete'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='operation success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='"1081EB05-473C-5BF4-95BE-6D7CAD5E2213"'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model DeleteFunctionTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFunctionTaskResponseBody(name='body'),
}

/**
 * @summary Deletes a training task. The training task in progress cannot be deleted.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFunctionTaskResponse
 */
async function deleteFunctionTaskWithOptions(appGroupIdentity: string, functionName: string, instanceName: string, generation: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFunctionTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunctionTask',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/instances/${OpenApiUtil.getEncodeParam(instanceName)}/tasks/${OpenApiUtil.getEncodeParam(generation)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a training task. The training task in progress cannot be deleted.
 *
 * @return DeleteFunctionTaskResponse
 */
async function deleteFunctionTask(appGroupIdentity: string, functionName: string, instanceName: string, generation: string): DeleteFunctionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionTaskWithOptions(appGroupIdentity, functionName, instanceName, generation, headers, runtime);
}

model DeleteSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
}

model DeleteSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSortScriptResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSortScriptResponse
 */
async function deleteSortScriptWithOptions(appGroupIdentity: string, scriptName: string, appVersionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSortScriptResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteSortScript',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appVersionId)}/sort-scripts/${OpenApiUtil.getEncodeParam(scriptName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DeleteSortScriptResponse
 */
async function deleteSortScript(appGroupIdentity: string, scriptName: string, appVersionId: string): DeleteSortScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSortScriptWithOptions(appGroupIdentity, scriptName, appVersionId, headers, runtime);
}

model DeleteSortScriptFileResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
}

model DeleteSortScriptFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSortScriptFileResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSortScriptFileResponse
 */
async function deleteSortScriptFileWithOptions(appGroupIdentity: string, appVersionId: string, scriptName: string, fileName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSortScriptFileResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteSortScriptFile',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appVersionId)}/sort-scripts/${OpenApiUtil.getEncodeParam(scriptName)}/files/src/${OpenApiUtil.getEncodeParam(fileName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DeleteSortScriptFileResponse
 */
async function deleteSortScriptFile(appGroupIdentity: string, appVersionId: string, scriptName: string, fileName: string): DeleteSortScriptFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSortScriptFileWithOptions(appGroupIdentity, appVersionId, scriptName, fileName, headers, runtime);
}

model DescribeABTestExperimentResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test was created.', example='1588842080'),
    id?: string(name='id', description='The ID of the test.', example='12888'),
    name?: string(name='name', description='The name of the test.', example='test1'),
    online?: boolean(name='online', description='The status of the test. Valid values:

*   true: in effect
*   false: not in effect', example='true'),
    params?: {
      firstFormulaName?: string(name='first_formula_name', description='The name of the rough sort policy.', example='default'),
    }(name='params', description='The parameters of the test.'),
    traffic?: int32(name='traffic', description='The percentage of traffic that is routed to the test.', example='30'),
    updated?: int32(name='updated', description='The time when the test was last modified.', example='1588842080'),
  }(name='result', description='The details of the test.'),
}

model DescribeABTestExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeABTestExperimentResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeABTestExperimentResponse
 */
async function describeABTestExperimentWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeABTestExperimentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeABTestExperiment',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scenes/${OpenApiUtil.getEncodeParam(sceneId)}/groups/${OpenApiUtil.getEncodeParam(groupId)}/experiments/${OpenApiUtil.getEncodeParam(experimentId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeABTestExperimentResponse
 */
async function describeABTestExperiment(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string): DescribeABTestExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeABTestExperimentWithOptions(appGroupIdentity, sceneId, groupId, experimentId, headers, runtime);
}

model DescribeABTestGroupResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test group was created.', example='1588839490'),
    id?: string(name='id', description='The ID of the test group.', example='13466'),
    name?: string(name='name', description='The name of the test group.', example='Group_2020-5-7_15:23:3'),
    status?: int32(name='status', description='The status of the test group. Valid values:

*   0: not in effect
*   1: in effect', example='1'),
    updated?: int32(name='updated', description='The time when the test group was last modified.', example='1588839490'),
  }(name='result', description='The details of the test group.'),
}

model DescribeABTestGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeABTestGroupResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeABTestGroupResponse
 */
async function describeABTestGroupWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeABTestGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeABTestGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scenes/${OpenApiUtil.getEncodeParam(sceneId)}/groups/${OpenApiUtil.getEncodeParam(groupId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeABTestGroupResponse
 */
async function describeABTestGroup(appGroupIdentity: string, sceneId: string, groupId: string): DescribeABTestGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeABTestGroupWithOptions(appGroupIdentity, sceneId, groupId, headers, runtime);
}

model DescribeABTestSceneResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test scenario was created.', example='1596527691'),
    id?: string(name='id', description='The ID of the test scenario.', example='20614'),
    name?: string(name='name', description='The name of the test scenario.', example='test'),
    status?: int32(name='status', description='The status of the test scenario. Valid values:

*   0: The test is stopped.
*   1: The test is started.', example='0'),
    updated?: int32(name='updated', description='The time when the test was last modified.', example='1596527691'),
    values?: [ string ](name='values', description='The indicators of the test scenarios.'),
  }(name='result', description='The details of the test scenario.'),
}

model DescribeABTestSceneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeABTestSceneResponseBody(name='body'),
}

/**
 * @summary Queries the information about an A/B test scenario.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeABTestSceneResponse
 */
async function describeABTestSceneWithOptions(appGroupIdentity: string, sceneId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeABTestSceneResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeABTestScene',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scenes/${OpenApiUtil.getEncodeParam(sceneId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about an A/B test scenario.
 *
 * @return DescribeABTestSceneResponse
 */
async function describeABTestScene(appGroupIdentity: string, sceneId: string): DescribeABTestSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeABTestSceneWithOptions(appGroupIdentity, sceneId, headers, runtime);
}

model DescribeAppResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='33477D76-C380-1D84-A4AD-043F52876CB1'),
  result?: {
    autoSwitch?: boolean(name='autoSwitch', description='Indicates whether the version is automatically published to the online environment.', example='true'),
    cluster?: {
      maxQueryClauseLength?: int32(name='maxQueryClauseLength'),
      maxTimeoutMS?: int32(name='maxTimeoutMS'),
    }(name='cluster'),
    clusterName?: string(name='clusterName', description='The name of the cluster.', example='-'),
    dataSources?: [ 
      {
        fields?: [  map[string]any ](name='fields'),
        keyField?: string(name='keyField'),
        parameters?: map[string]any(name='parameters'),
        plugins?: map[string]any(name='plugins'),
        schemaName?: string(name='schemaName'),
        tableName?: string(name='tableName'),
        type?: string(name='type'),
      }
    ](name='dataSources'),
    description?: string(name='description', description='The description of the version.', example='-'),
    domain?: {
      category?: string(name='category', description='The category. By default, this parameter is left empty.', example='-'),
      functions?: {
        algo?: [ string ](name='algo', description='Algorithm structure', example='[]'),
        qp?: [ string ](name='qp', description='Queryprocessor description', example='[]'),
        service?: [ string ](name='service', description='Function description', example='[]'),
      }(name='functions', description='search functions', example='{}'),
      name?: string(name='name', description='The name', example='test'),
    }(name='domain', description='The type of the industry. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='GENERAL'),
    fetchFields?: [ string ](name='fetchFields', description='The default display fields.', example='[]'),
    firstRanks?: [ 
      {
        active?: boolean(name='active'),
        description?: string(name='description'),
        meta?: any(name='meta'),
        name?: string(name='name'),
        type?: string(name='type'),
      }
    ](name='firstRanks'),
    id?: string(name='id', description='The ID of the version.', example='100303063'),
    interpretations?: map[string]any(name='interpretations'),
    isCurrent?: boolean(name='isCurrent'),
    progressPercent?: int32(name='progressPercent', description='The progress of data import, in percentage. For example, a value of 83 indicates 83%.', example='100'),
    prompts?: [  map[string]any ](name='prompts'),
    queryProcessors?: [ 
      {
        active?: boolean(name='active'),
        category?: string(name='category'),
        domain?: string(name='domain'),
        indexes?: [ string ](name='indexes'),
        name?: string(name='name'),
        processors?: [  map[string]any ](name='processors'),
      }
    ](name='queryProcessors'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing units (LCUs).', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
      qps?: int32(name='qps', description='The number of search requests per second. You are charged based on the number of search requests per second in the earlier billing model.', example='5'),
      spec?: string(name='spec', description='The specifications of the application. Valid values:

*   opensearch.share.junior: basic
*   opensearch.share.common: shared general-purpose
*   opensearch.share.compute: shared computing
*   opensearch.share.storage: shared storage
*   opensearch.private.common: exclusive general-purpose
*   opensearch.private.compute: exclusive computing
*   opensearch.private.storage: exclusive storage', example='opensearch.share.common'),
    }(name='quota', description='The quota information about the version.', example='{}'),
    schema?: {
      indexSortConfig?: [ 
        {
          direction?: string(name='direction'),
          field?: string(name='field'),
        }
      ](name='indexSortConfig'),
      indexes?: {
        filterFields?: [ string ](name='filterFields'),
        searchFields?: map[string]any(name='searchFields'),
      }(name='indexes'),
      name?: string(name='name'),
      routeField?: string(name='routeField'),
      routeFieldValues?: [ string ](name='routeFieldValues'),
      secondRouteField?: string(name='secondRouteField'),
      tables?: map[string]any(name='tables'),
      ttlField?: {
        name?: string(name='name'),
        ttl?: long(name='ttl'),
      }(name='ttlField'),
    }(name='schema', description='The application schema.', example='{}'),
    schemas?: [ 
      {
        indexSortConfig?: [ 
          {
            direction?: string(name='direction'),
            field?: string(name='field'),
          }
        ](name='indexSortConfig'),
        indexes?: {
          filterFields?: [ string ](name='filterFields'),
          searchFields?: map[string]any(name='searchFields'),
        }(name='indexes'),
        name?: string(name='name'),
        routeField?: string(name='routeField'),
        routeFieldValues?: [ string ](name='routeFieldValues'),
        secondRouteField?: string(name='secondRouteField'),
        tables?: map[string]any(name='tables'),
        ttlField?: {
          name?: string(name='name'),
          ttl?: long(name='ttl'),
        }(name='ttlField'),
      }
    ](name='schemas'),
    secondRanks?: [ 
      {
        active?: boolean(name='active'),
        description?: string(name='description'),
        meta?: any(name='meta'),
        name?: string(name='name'),
      }
    ](name='secondRanks'),
    status?: string(name='status', description='The status of the version. Valid values:

*   ok
*   stopped
*   frozen
*   initializing
*   unavailable
*   data_waiting
*   data_preparing', example='ok'),
    summaries?: [ 
      {
        meta?: [ 
          {
            element?: string(name='element'),
            ellipsis?: string(name='ellipsis'),
            field?: string(name='field'),
            len?: int32(name='len'),
            snippet?: string(name='snippet'),
          }
        ](name='meta'),
        name?: string(name='name'),
      }
    ](name='summaries'),
    type?: string(name='type', description='The type of the application. Valid values:

*   standard: a standard application.
*   advance: an advanced application which is of an old application type. New applications cannot be of this type.
*   enhanced: an advanced application which is of a new application type.', example='enhanced'),
  }(name='result', description='The information about the version.', example='{}'),
}

model DescribeAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAppResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAppResponse
 */
async function describeAppWithOptions(appGroupIdentity: string, appId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeAppResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeApp',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeAppResponse
 */
async function describeApp(appGroupIdentity: string, appId: string): DescribeAppResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeAppWithOptions(appGroupIdentity, appId, headers, runtime);
}

model DescribeAppGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    chargeType?: string(name='chargeType', description='The billing method. Valid values:

*   POSTPAY: pay-as-you-go.
*   PREPAY: subscription.', example='POSTPAY'),
    chargingWay?: int32(name='chargingWay', description='The billable item. Valid values:

*   1: computing resources.
*   2: queries per second (QPS).', example='1'),
    commodityCode?: string(name='commodityCode', description='The commodity code.', example='opensearch'),
    created?: int32(name='created', description='The timestamp when the application was created.', example='1575442875'),
    currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='110116134'),
    description?: string(name='description', description='The description of the application.', example='-'),
    domain?: string(name='domain', description='The industry of the application.', example='ecommerce'),
    engineType?: string(name='engineType'),
    expireOn?: string(name='expireOn', description='The expiration time.', example='-'),
    firstRankAlgoDeploymentId?: int32(name='firstRankAlgoDeploymentId', description='The ID of the created rough sort expression.', example='0'),
    hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval state of the quotas. Valid values:

*   0: The application is in service.
*   1: The quotas are being reviewed.', example='0'),
    id?: string(name='id', description='The application ID.', example='110116134'),
    instanceId?: string(name='instanceId', description='The instance ID.', example='-'),
    lockMode?: string(name='lockMode', description='The lock state. Valid values:

*   Unlock: The instance is unlocked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
    lockedByExpiration?: int32(name='lockedByExpiration', description='Indicates whether the instance is automatically locked after it expires.', example='0'),
    name?: string(name='name', description='The application name.', example='os_function_test_v1'),
    pendingSecondRankAlgoDeploymentId?: int32(name='pendingSecondRankAlgoDeploymentId', description='The ID of the fine sort expression that is being created.', example='0'),
    processingOrderId?: string(name='processingOrderId', description='The ID of the order that is not complete.', example='-'),
    produced?: int32(name='produced', description='Indicates whether the application is created. Valid values:

*   0: The application is being created.
*   1: The application is created.', example='1'),
    projectId?: string(name='projectId', description='The name of the A/B test group.', example='-'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing unit (LCU).', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
      spec?: string(name='spec', description='The specifications. Valid values:

*   opensearch.share.junior: basic.
*   opensearch.share.common: shared general-purpose.
*   opensearch.share.compute: shared computing.
*   opensearch.share.storage: shared storage.
*   opensearch.private.common: exclusive general-purpose.
*   opensearch.private.compute: exclusive computing.
*   opensearch.private.storage: exclusive storage.', example='opensearch.share.common'),
    }(name='quota', description='The information about the quotas of the application.'),
    resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group.', example='rg-acfmoiyerh6nzly'),
    secondRankAlgoDeploymentId?: int32(name='secondRankAlgoDeploymentId', description='The ID of the created fine sort expression.', example='0'),
    status?: string(name='status', description='The state of the application. Valid values:

*   producing: The application is being created.
*   review_pending: The application is being reviewed.
*   config_pending: The application is to be configured.
*   normal: The application is in service.
*   frozen: The application is frozen.', example='normal'),
    switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='0'),
    tags?: [ 
      {
        key?: string(name='key', description='The tag key.', example='foo'),
        value?: string(name='value', description='The tag value', example='bar'),
      }
    ](name='tags', description='The application tags.'),
    type?: string(name='type', description='The type of the application. Valid values:

*   standard: a High-performance Search Edition application.
*
*   enhanced: an Industry Algorithm Edition application.', example='enhanced'),
    updated?: int32(name='updated', description='The timestamp when the application was last updated.', example='1578916076'),
  }(name='result', description='The information about the application.'),
}

model DescribeAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAppGroupResponseBody(name='body'),
}

/**
 * @summary Queries the details of an OpenSearch application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAppGroupResponse
 */
async function describeAppGroupWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeAppGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeAppGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of an OpenSearch application.
 *
 * @return DescribeAppGroupResponse
 */
async function describeAppGroup(appGroupIdentity: string): DescribeAppGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeAppGroupWithOptions(appGroupIdentity, headers, runtime);
}

model DescribeAppStatisticsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='76FC45F1-4167-D3CD-6737-4F97BA503FA0'),
  result?: map[string]any(name='result', description='The statistics.', example='{}'),
}

model DescribeAppStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAppStatisticsResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAppStatisticsResponse
 */
async function describeAppStatisticsWithOptions(appGroupIdentity: string, appId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeAppStatisticsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeAppStatistics',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/statistics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeAppStatisticsResponse
 */
async function describeAppStatistics(appGroupIdentity: string, appId: string): DescribeAppStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeAppStatisticsWithOptions(appGroupIdentity, appId, headers, runtime);
}

model DescribeAppsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='77CAA411-0010-4DB9-82E2-1C384E590AFF'),
  result?: [ 
    {
      autoSwitch?: boolean(name='autoSwitch'),
      cluster?: {
        maxQueryClauseLength?: int32(name='maxQueryClauseLength'),
        maxTimeoutMS?: int32(name='maxTimeoutMS'),
      }(name='cluster'),
      clusterName?: string(name='clusterName'),
      dataSources?: [ 
        {
          fields?: [  map[string]any ](name='fields'),
          keyField?: string(name='keyField'),
          parameters?: map[string]any(name='parameters'),
          plugins?: map[string]any(name='plugins'),
          schemaName?: string(name='schemaName'),
          tableName?: string(name='tableName'),
          type?: string(name='type'),
        }
      ](name='dataSources'),
      description?: string(name='description'),
      domain?: {
        category?: string(name='category'),
        functions?: {
          algo?: [ string ](name='algo'),
          qp?: [ string ](name='qp'),
          service?: [ string ](name='service'),
        }(name='functions'),
        name?: string(name='name'),
      }(name='domain'),
      fetchFields?: [ string ](name='fetchFields'),
      firstRanks?: [ 
        {
          active?: boolean(name='active'),
          description?: string(name='description'),
          meta?: any(name='meta'),
          name?: string(name='name'),
          type?: string(name='type'),
        }
      ](name='firstRanks'),
      id?: string(name='id'),
      interpretations?: map[string]any(name='interpretations'),
      isCurrent?: boolean(name='isCurrent'),
      progressPercent?: int32(name='progressPercent'),
      prompts?: [  map[string]any ](name='prompts'),
      queryProcessors?: [ 
        {
          active?: boolean(name='active'),
          category?: string(name='category'),
          domain?: string(name='domain'),
          indexes?: [ string ](name='indexes'),
          name?: string(name='name'),
          processors?: [  map[string]any ](name='processors'),
        }
      ](name='queryProcessors'),
      quota?: {
        computeResource?: int32(name='computeResource'),
        docSize?: int32(name='docSize'),
        qps?: int32(name='qps'),
        spec?: string(name='spec'),
      }(name='quota'),
      schema?: {
        indexSortConfig?: [ 
          {
            direction?: string(name='direction'),
            field?: string(name='field'),
          }
        ](name='indexSortConfig'),
        indexes?: {
          filterFields?: [ string ](name='filterFields'),
          searchFields?: map[string]any(name='searchFields'),
        }(name='indexes'),
        name?: string(name='name'),
        routeField?: string(name='routeField'),
        routeFieldValues?: [ string ](name='routeFieldValues'),
        secondRouteField?: string(name='secondRouteField'),
        tables?: map[string]any(name='tables'),
        ttlField?: {
          name?: string(name='name'),
          ttl?: long(name='ttl'),
        }(name='ttlField'),
      }(name='schema'),
      schemas?: [ 
        {
          indexSortConfig?: [ 
            {
              direction?: string(name='direction'),
              field?: string(name='field'),
            }
          ](name='indexSortConfig'),
          indexes?: {
            filterFields?: [ string ](name='filterFields'),
            searchFields?: map[string]any(name='searchFields'),
          }(name='indexes'),
          name?: string(name='name'),
          routeField?: string(name='routeField'),
          routeFieldValues?: [ string ](name='routeFieldValues'),
          secondRouteField?: string(name='secondRouteField'),
          tables?: map[string]any(name='tables'),
          ttlField?: {
            name?: string(name='name'),
            ttl?: long(name='ttl'),
          }(name='ttlField'),
        }
      ](name='schemas'),
      secondRanks?: [ 
        {
          active?: boolean(name='active'),
          description?: string(name='description'),
          meta?: any(name='meta'),
          name?: string(name='name'),
        }
      ](name='secondRanks'),
      status?: string(name='status'),
      summaries?: [ 
        {
          meta?: [ 
            {
              element?: string(name='element'),
              ellipsis?: string(name='ellipsis'),
              field?: string(name='field'),
              len?: int32(name='len'),
              snippet?: string(name='snippet'),
            }
          ](name='meta'),
          name?: string(name='name'),
        }
      ](name='summaries'),
      type?: string(name='type'),
    }
  ](name='result', description='The information about each version.'),
}

model DescribeAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAppsResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAppsResponse
 */
async function describeAppsWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeAppsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeApps',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeAppsResponse
 */
async function describeApps(appGroupIdentity: string): DescribeAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeAppsWithOptions(appGroupIdentity, headers, runtime);
}

model DescribeDataCollctionResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='72FAD77B-83F9-F393-BA8E-5834E2427BF8'),
  result?: {
    created?: int32(name='created', description='The time when the task was created.', example='1581065837'),
    dataCollectionType?: string(name='dataCollectionType', description='The type of data collected. Valid values:

*   behavior: behavioral data.
*   item_info: project information.
*   industry_specific: industry-specific data.', example='BEHAVIOR'),
    id?: string(name='id', description='The ID of the data collection task.', example='286'),
    industryName?: string(name='industryName', description='The industry name. Valid values:

*   general
*   ecommerce', example='GENERAL'),
    name?: string(name='name', description='The name of the data collection task.', example='os_function_test_v1'),
    status?: int32(name='status', description='The status of the data collection feature. Valid values:

*   0: The feature is disabled.
*   1: The feature is being enabled.
*   2: The feature is enabled.
*   3: The feature failed to be enabled.', example='2'),
    sundialId?: string(name='sundialId', description='The sundial ID.', example='1755'),
    type?: string(name='type', description='The type of the source from which data was collected. Valid values:

*   server
*   web
*   app Note: Only server is supported.', example='server'),
    updated?: int32(name='updated', description='The time when the data collection task was updated.', example='1581065904'),
  }(name='result', description='The details of the data collection task.'),
}

model DescribeDataCollctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDataCollctionResponseBody(name='body'),
}

/**
 * @summary Queries the details of a data collection task of an application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDataCollctionResponse
 */
async function describeDataCollctionWithOptions(appGroupIdentity: string, dataCollectionIdentity: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDataCollctionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeDataCollction',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/data-collections/${OpenApiUtil.getEncodeParam(dataCollectionIdentity)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a data collection task of an application.
 *
 * @return DescribeDataCollctionResponse
 */
async function describeDataCollction(appGroupIdentity: string, dataCollectionIdentity: string): DescribeDataCollctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDataCollctionWithOptions(appGroupIdentity, dataCollectionIdentity, headers, runtime);
}

model DescribeFirstRankResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='false'),
    description?: string(name='description', description='The description of the expression.', example='-'),
    meta?: [ 
      {
        arg?: string(name='arg', description='The parameters that are used by a function in the expression.', example='ar_edit_time'),
        attribute?: string(name='attribute', description='The attribute, feature function, or field to be searched for.', example='timeliness_ms()'),
        weight?: float(name='weight', description='The weight.

Valid values: [-100000,100000] (excluding 0).', example='1'),
      }
    ](name='meta', description='The content of the expression.'),
    name?: string(name='name', description='The name of the expression.', example='ar_wear_edit_time'),
  }(name='result', description='The information about the rough sort expression.'),
}

model DescribeFirstRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFirstRankResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFirstRankResponse
 */
async function describeFirstRankWithOptions(appGroupIdentity: string, appId: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeFirstRankResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeFirstRank',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/first-ranks/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeFirstRankResponse
 */
async function describeFirstRank(appGroupIdentity: string, appId: string, name: string): DescribeFirstRankResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeFirstRankWithOptions(appGroupIdentity, appId, name, headers, runtime);
}

model DescribeInterventionDictionaryResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D7CCF454-472A-030E-F254-604520B028AA'),
  result?: {
    analyzer?: string(name='analyzer', description='The custom analyzer.', example='-'),
    created?: string(name='created', description='The time when the intervention dictionary was created.', example='1536233287'),
    name?: string(name='name', description='The name of the intervention dictionary.', example='test'),
    type?: string(name='type', description='The type of the intervention dictionary. Valid values:

*   stopword: an intervention dictionary for stop word filtering
*   synonym: an intervention dictionary for synonym configuration
*   correction: an intervention dictionary for spelling correction
*   category_prediction: an intervention dictionary for category prediction
*   ner: an intervention dictionary for named entity recognition (NER)
*   term_weighting: an intervention dictionary for term weight analysis', example='category_prediction'),
    updated?: string(name='updated', description='The time when the intervention dictionary was last updated.', example='1536233287'),
  }(name='result', description='The information the intervention dictionary.'),
}

model DescribeInterventionDictionaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInterventionDictionaryResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInterventionDictionaryResponse
 */
async function describeInterventionDictionaryWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeInterventionDictionaryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeInterventionDictionary',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/intervention-dictionaries/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeInterventionDictionaryResponse
 */
async function describeInterventionDictionary(name: string): DescribeInterventionDictionaryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeInterventionDictionaryWithOptions(name, headers, runtime);
}

model DescribeQueryProcessorResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the query analysis rule is the default one.', example='true'),
    created?: int32(name='created', description='The time when the query analysis rule was created.', example='1587398402'),
    domain?: string(name='domain', description='The type of the industry. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='GENERAL'),
    indexes?: [ string ](name='indexes', description='The indexes to which the query analysis rule applies.'),
    name?: string(name='name', description='The name of the query analysis rule.', example='test'),
    processors?: [  map[string]any ](name='processors', description='The features that are used in the query analysis rule.'),
    updated?: int32(name='updated', description='The time when the query analysis rule was last updated.', example='1587398402'),
  }(name='result', description='The information about the query analysis rule.'),
}

model DescribeQueryProcessorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeQueryProcessorResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeQueryProcessorResponse
 */
async function describeQueryProcessorWithOptions(appGroupIdentity: string, appId: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeQueryProcessorResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeQueryProcessor',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/query-processors/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeQueryProcessorResponse
 */
async function describeQueryProcessor(appGroupIdentity: string, appId: string, name: string): DescribeQueryProcessorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeQueryProcessorWithOptions(appGroupIdentity, appId, name, headers, runtime);
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='3B7E42BD-1D63-2F6B-C8E0-41BACEA76EEB'),
  result?: [ 
    {
      consoleUrl?: string(name='consoleUrl', description='The console URL.', example='https://opensearch-cn-hangzhou.console.aliyun.com'),
      endpoint?: string(name='endpoint', description='The endpoint.', example='opensearch.cn-hangzhou.aliyuncs.com'),
      localName?: string(name='localName', description='The region name.', example='China (Hangzhou)'),
      regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
    }
  ](name='result', description='The results returned.'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @summary Queries the endpoints of all regions that support OpenSearch.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
async function describeRegionsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/regions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the endpoints of all regions that support OpenSearch.
 *
 * @return DescribeRegionsResponse
 */
async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(headers, runtime);
}

model DescribeScheduledTaskResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='922DC0D9-31B5-45F9-47B7-37DC678D61A8'),
  result?: map[string]any(name='result', description='The details of the scheduled task.', example='{}'),
}

model DescribeScheduledTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeScheduledTaskResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeScheduledTaskResponse
 */
async function describeScheduledTaskWithOptions(appGroupIdentity: string, taskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeScheduledTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeScheduledTask',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scheduled-tasks/${OpenApiUtil.getEncodeParam(taskId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeScheduledTaskResponse
 */
async function describeScheduledTask(appGroupIdentity: string, taskId: string): DescribeScheduledTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeScheduledTaskWithOptions(appGroupIdentity, taskId, headers, runtime);
}

model DescribeSecondRankResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
    created?: int32(name='created', description='The time when the expression was created.', example='1587052801'),
    description?: string(name='description', description='The description of the expression.', example='-'),
    id?: string(name='id', description='The ID of the expression. This parameter appears only in the response.', example='89047'),
    isDefault?: string(name='isDefault', description='Indicates whether the expression is the default one. This parameter appears only in the response. Valid values:

*   true
*   false', example='true'),
    isSys?: string(name='isSys', description='Indicates whether the expression is a system expression. This parameter appears only in the response. Valid values:

*   true
*   false', example='false'),
    meta?: string(name='meta', description='The content of the fine sort expression.

You can define an expression that consists of fields, feature functions, and mathematical functions to implement complex sort logic.', example='random()+now()'),
    name?: string(name='name', description='The name of the expression.', example='tests'),
    updated?: int32(name='updated', description='The time when the expression was last updated.', example='1587052801'),
  }(name='result', description='The information about the fine sort expression.'),
}

model DescribeSecondRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSecondRankResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSecondRankResponse
 */
async function describeSecondRankWithOptions(appGroupIdentity: string, appId: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeSecondRankResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecondRank',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/second-ranks/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeSecondRankResponse
 */
async function describeSecondRank(appGroupIdentity: string, appId: string, name: string): DescribeSecondRankResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeSecondRankWithOptions(appGroupIdentity, appId, name, headers, runtime);
}

model DescribeSlowQueryStatusResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='5C1C1C45-C64A-AD30-565F-140871D57E5E'),
  result?: {
    appGroupId?: string(name='appGroupId', description='The ID of the application.', example='100298370'),
    region?: string(name='region', description='The network type of the slow query optimization service. Valid values:

*   outer: the Internet
*   internal: the internal network', example='internal'),
    status?: string(name='status', description='The status of the slow query optimization service. Valid values:

*   enabled
*   disabled
*   n/a', example='disabled'),
  }(name='result', description='The return result.'),
}

model DescribeSlowQueryStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSlowQueryStatusResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSlowQueryStatusResponse
 */
async function describeSlowQueryStatusWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeSlowQueryStatusResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeSlowQueryStatus',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/optimizers/slow-query`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeSlowQueryStatusResponse
 */
async function describeSlowQueryStatus(appGroupIdentity: string): DescribeSlowQueryStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeSlowQueryStatusWithOptions(appGroupIdentity, headers, runtime);
}

model DescribeUserAnalyzerRequest {
  with?: string(name='with', description='The Associated information,output properties based on hierarchy.
* **all**: Outputs associated app information', example='all'),
}

model DescribeUserAnalyzerResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='FFAEF396-10EF-53C7-1F51-518853880729'),
  result?: map[string]any(name='result', description='The details of the custom analyzer.', example='{}'),
}

model DescribeUserAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUserAnalyzerResponseBody(name='body'),
}

/**
 * @param request DescribeUserAnalyzerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserAnalyzerResponse
 */
async function describeUserAnalyzerWithOptions(name: string, request: DescribeUserAnalyzerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeUserAnalyzerResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.with)) {
    query['with'] = request.with;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserAnalyzer',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/user-analyzers/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeUserAnalyzerRequest
 * @return DescribeUserAnalyzerResponse
 */
async function describeUserAnalyzer(name: string, request: DescribeUserAnalyzerRequest): DescribeUserAnalyzerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeUserAnalyzerWithOptions(name, request, headers, runtime);
}

model DisableSlowQueryResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='728E89C6-8673-D39B-39A1-5BA2B56D448F'),
  result?: map[string]any(name='result', description='The return result.', example='{}'),
}

model DisableSlowQueryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableSlowQueryResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableSlowQueryResponse
 */
async function disableSlowQueryWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: Util.RuntimeOptions): DisableSlowQueryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DisableSlowQuery',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/optimizers/slow-query/actions/disable`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DisableSlowQueryResponse
 */
async function disableSlowQuery(appGroupIdentity: string): DisableSlowQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableSlowQueryWithOptions(appGroupIdentity, headers, runtime);
}

model EnableSlowQueryResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='728E89C6-8673-D39B-39A1-5BA2B56D448F'),
  result?: map[string]any(name='result', description='The return result.', example='{}'),
}

model EnableSlowQueryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableSlowQueryResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableSlowQueryResponse
 */
async function enableSlowQueryWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: Util.RuntimeOptions): EnableSlowQueryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'EnableSlowQuery',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/optimizers/slow-query/actions/enable`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return EnableSlowQueryResponse
 */
async function enableSlowQuery(appGroupIdentity: string): EnableSlowQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableSlowQueryWithOptions(appGroupIdentity, headers, runtime);
}

model GenerateMergedTableRequest {
  body?: Schema(name='body', description='The request body parameters.'),
  spec?: string(name='spec', description='The specifications of the OpenSearch instance. This parameter is used to check whether the OpenSearch instance meets the special limits on an exclusive instance.

Default value: opensearch.share.common.

For more information, see the description of the spec field in the Quota topic.', example='"opensearch.share.common"'),
}

model GenerateMergedTableResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: {
    fromTable?: map[string]any(name='fromTable', description='The tables on which the JOIN operation is performed.', example='-'),
    mergeTable?: map[string]any(name='mergeTable', description='The wide table that is generated after the JOIN operation is performed on multiple tables.', example='-'),
    primaryKey?: string(name='primaryKey', description='The primary key.', example='-'),
  }(name='result', description='The response parameters.'),
}

model GenerateMergedTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GenerateMergedTableResponseBody(name='body'),
}

/**
 * @summary Queries the information about a wide table that is generated after a JOIN operation is performed on multiple tables.
 *
 * @param request GenerateMergedTableRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateMergedTableResponse
 */
async function generateMergedTableWithOptions(request: GenerateMergedTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GenerateMergedTableResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.spec)) {
    query['spec'] = request.spec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'GenerateMergedTable',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/assist/schema/actions/merge`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about a wide table that is generated after a JOIN operation is performed on multiple tables.
 *
 * @param request GenerateMergedTableRequest
 * @return GenerateMergedTableResponse
 */
async function generateMergedTable(request: GenerateMergedTableRequest): GenerateMergedTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return generateMergedTableWithOptions(request, headers, runtime);
}

model GetDomainRequest {
  appGroupIdentity?: string(name='appGroupIdentity', description='The name or ID of the application.

This parameter is required.', example='my_app_group_name'),
}

model GetDomainResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='The returned result.', example='-'),
}

model GetDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDomainResponseBody(name='body'),
}

/**
 * @summary Queries the type of an industry.
 *
 * @param request GetDomainRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDomainResponse
 */
async function getDomainWithOptions(domainName: string, request: GetDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDomainResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appGroupIdentity)) {
    query['appGroupIdentity'] = request.appGroupIdentity;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDomain',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/domains/${OpenApiUtil.getEncodeParam(domainName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the type of an industry.
 *
 * @param request GetDomainRequest
 * @return GetDomainResponse
 */
async function getDomain(domainName: string, request: GetDomainRequest): GetDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDomainWithOptions(domainName, request, headers, runtime);
}

model GetFunctionCurrentVersionRequest {
  category?: string(name='category', description='The category. By default, this parameter is left empty.', example='general'),
  domain?: string(name='domain', description='The industry. By default, this parameter is left empty, which indicates General-purpose Edition.', example='ecommerce'),
  functionType?: string(name='functionType', description='The type of the feature. Valid values:

*   PAAS. This is the default value.
*   SAAS.', example='PAAS'),
  modelType?: string(name='modelType', description='The type of the model. The following features correspond to different model types:

*   CTR model: tf_checkpoint
*   Popularity model: pop
*   Category model: offline_inference
*   Hotword model: offline_inference
*   Shading model: offline_inference
*   Drop-down suggestion model: offline_inference
*   Word segmentation model: text
*   Word weight model: tf_checkpoint

This parameter is required.', example='tf_checkpoint'),
}

model GetFunctionCurrentVersionResponseBody = {
  code?: string(name='Code', description='The error code.', example='Version.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='version not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1638157479281'),
  result?: {
    functionName?: string(name='FunctionName', description='The name of the feature.', example='ctr'),
    functionType?: string(name='FunctionType', description='The type of the feature. Valid values:

*   PAAS
*   SAAS', example='PAAS'),
    modelType?: string(name='ModelType', description='The type of the model.', example='tf_checkpoint'),
    versionConfig?: {
      createParameters?: [ 
        {
          name?: string(name='Name', description='The name of the parameter.', example='params1'),
          required?: string(name='Required', description='Indicates whether the parameter is required.', example='true'),
        }
      ](name='CreateParameters', description='The parameters that are used to create the instance.', example='[                 {                     "name": "params1",                     "required": "true",                     "formItemProps": "{\\\\"required\\\\": true, \\\\"pattern?\\\\": \\\\"/^[a-zA-Z][a-zA-Z0-9_]{0,29}$/\\\\"}",                     "componentProps": "{\\\\"component\\\\": \\\\"Input\\\\", \\\\"attributes\\\\": {\\\\"defaultValue\\\\": \\\\"value1\\\\"}}"                 }             ]'),
      depends?: [ 
        {
          condition?: string(name='Condition', description='The condition.', example='""'),
          dependency?: string(name='Dependency', description='The dependency.', example='""'),
          description?: string(name='Description', description='The description.', example='""'),
        }
      ](name='Depends', description='The dependencies of the instance.'),
      usageParameters?: [ 
        {
          name?: string(name='Name', description='The name of the parameter.', example='""'),
          required?: string(name='Required', description='Indicates whether the parameter is required.', example='""'),
        }
      ](name='UsageParameters', description='The parameters that are used to use the instance online.', example='[]'),
    }(name='VersionConfig', description='The configuration information about the instance.'),
    versionId?: long(name='VersionId', description='The ID of the version.', example='101'),
    versionName?: string(name='VersionName', description='The name of the version.', example='v1'),
  }(name='Result', description='The result of the request.'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model GetFunctionCurrentVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionCurrentVersionResponseBody(name='body'),
}

/**
 * @summary Queries the version information about the current feature when you create an instance.
 *
 * @param request GetFunctionCurrentVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionCurrentVersionResponse
 */
async function getFunctionCurrentVersionWithOptions(functionName: string, request: GetFunctionCurrentVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionCurrentVersionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.category)) {
    query['category'] = request.category;
  }
  if (!Util.isUnset(request.domain)) {
    query['domain'] = request.domain;
  }
  if (!Util.isUnset(request.functionType)) {
    query['functionType'] = request.functionType;
  }
  if (!Util.isUnset(request.modelType)) {
    query['modelType'] = request.modelType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunctionCurrentVersion',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/functions/${OpenApiUtil.getEncodeParam(functionName)}/current-version`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the version information about the current feature when you create an instance.
 *
 * @param request GetFunctionCurrentVersionRequest
 * @return GetFunctionCurrentVersionResponse
 */
async function getFunctionCurrentVersion(functionName: string, request: GetFunctionCurrentVersionRequest): GetFunctionCurrentVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionCurrentVersionWithOptions(functionName, request, headers, runtime);
}

model GetFunctionDefaultInstanceResponseBody = {
  code?: string(name='Code', description='The error code.', example='DefaultInstance.NotExist'),
  functionName?: string(name='FunctionName', description='The name of the feature.', example='cdn_waf'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  instanceName?: string(name='InstanceName', description='The name of the instance.', example='sh-bp1oi31w1jn4ctdyv'),
  latency?: long(name='Latency', description='The default running time.', example='123'),
  message?: string(name='Message', description='The error message.', example='default instance not set.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='062BA91F-A568-5779-8A5B-9E62C9BB3DC1'),
  result?: {
    instanceName?: string(name='InstanceName', description='The default instance name.', example='model1'),
  }(name='Result', description='The result of the request.', example='{\\\\"Pagination\\\\": {\\\\"TotalCount\\\\": 0, \\\\"PageNumber\\\\": 1, \\\\"PageSize\\\\": 10}, \\\\"AntConsortiums\\\\": []}'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model GetFunctionDefaultInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionDefaultInstanceResponseBody(name='body'),
}

/**
 * @summary Queries the algorithm instance that an application uses by default.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionDefaultInstanceResponse
 */
async function getFunctionDefaultInstanceWithOptions(appGroupIdentity: string, functionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionDefaultInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetFunctionDefaultInstance',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/default-instance`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the algorithm instance that an application uses by default.
 *
 * @return GetFunctionDefaultInstanceResponse
 */
async function getFunctionDefaultInstance(appGroupIdentity: string, functionName: string): GetFunctionDefaultInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionDefaultInstanceWithOptions(appGroupIdentity, functionName, headers, runtime);
}

model GetFunctionInstanceRequest {
  output?: string(name='output', description='Specifies the richness of returned information. Valid values:

*   simple: displays only the basic information.
*   normal: displays information such as createParameters and cron. This is the default value.
*   detail: returns the details of the training task.', example='detail'),
}

model GetFunctionInstanceResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, this parameter is left empty.', example='Instance.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='instance not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='68ED4E1B-92B8-5821-A886-9C90686139EB'),
  result?: {
    belongs?: {
      category?: string(name='Category', description='The category.', example='general'),
      domain?: string(name='Domain', description='The industry.', example='ecommerce'),
      language?: string(name='Language', description='The abbreviation of the language that applies.', example='zh'),
    }(name='Belongs', description='The information about the instance.'),
    createParameters?: [ 
      {
        name?: string(name='Name', description='The name of the parameter.', example='param1'),
        value?: string(name='Value', description='The value of the parameter.', example='value1'),
      }
    ](name='CreateParameters', description='The parameters that are used to create the instance.'),
    createTime?: long(name='CreateTime', description='The time when the task was created. Unit: milliseconds.', example='1234'),
    cron?: string(name='Cron', description='The cron expression used to schedule training, in the format of (Minutes Hours DayofMonth Month DayofWeek). If the value is empty, it indicates that no periodic training is performed.', example='0 3 ? \\\\* 0,1,3,5 (at 3 a.m. on Sunday, Monday, Wednesday, and Friday)'),
    description?: string(name='Description', description='The description of the instance.', example='instance descriptions'),
    extendInfo?: string(name='ExtendInfo', description='The extended information, which is a JSON string.', example='{\\\\"dataReport\\\\":{},\\\\"errors\\\\":{}}'),
    functionName?: string(name='FunctionName', description='The name of the feature.', example='ctr'),
    functionType?: string(name='FunctionType', description='The type of the feature.', example='PAAS'),
    instanceName?: string(name='InstanceName', description='The name of the instance.', example='ctr_test'),
    modelType?: string(name='ModelType', description='The type of the model.', example='tf_checkpoint'),
    source?: string(name='Source', description='How the instance is created. Valid values:

*   user: The instance is created by user.
*   builtin: The instance is created by the system.', example='user'),
    status?: string(name='Status', description='The status of the instance. Valid values:

1.  unavailable: No model is available. Models must be trained before you can use them.
2.  available: Models can be used.', example='available'),
    task?: {
      dagStatus?: string(name='DagStatus', description='The status of the task. Valid values:

*   success: succeeded
*   failed: failed
*   untrained: to be trained
*   pending: being scheduled
*   running: being trained', example='success'),
      lastRunTime?: long(name='LastRunTime', description='The time consumed for the most recent run, in milliseconds.', example='1234'),
    }(name='Task', description='The information about the training task. This parameter is not displayed if no task is available.'),
    usageParameters?: [ 
      {
        name?: string(name='Name', description='The name of the parameter.', example='use_param1'),
        value?: string(name='Value', description='The value of the parameter.', example='value1'),
      }
    ](name='UsageParameters', description='The parameters that are used.'),
    versionId?: long(name='VersionId', description='The ID of the version.', example='101'),
  }(name='Result', description='The details of the instance.', example='{}'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model GetFunctionInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionInstanceResponseBody(name='body'),
}

/**
 * @summary Queries the details of an algorithm instance by instance name.
 *
 * @param request GetFunctionInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionInstanceResponse
 */
async function getFunctionInstanceWithOptions(appGroupIdentity: string, functionName: string, instanceName: string, request: GetFunctionInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.output)) {
    query['output'] = request.output;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunctionInstance',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/instances/${OpenApiUtil.getEncodeParam(instanceName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of an algorithm instance by instance name.
 *
 * @param request GetFunctionInstanceRequest
 * @return GetFunctionInstanceResponse
 */
async function getFunctionInstance(appGroupIdentity: string, functionName: string, instanceName: string, request: GetFunctionInstanceRequest): GetFunctionInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionInstanceWithOptions(appGroupIdentity, functionName, instanceName, request, headers, runtime);
}

model GetFunctionResourceRequest {
  output?: string(name='output', description='The output level.

Valid values:

*   simple
*   normal
*   detail', example='detail'),
}

model GetFunctionResourceResponseBody = {
  code?: string(name='Code', description='The error code returned. If no error occurs, this value is empty.', example='Resource.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code returned.', example='200'),
  latency?: double(name='Latency', description='The time consumed for the API request. Unit: milliseconds.', example='123'),
  message?: string(name='Message', description='The error message returned.', example='Resource not exist.'),
  requestId?: string(name='RequestId', description='The request ID.', example='E215C843-0795-5293-AC9A-14FE0723E890'),
  result?: {
    createTime?: long(name='CreateTime', description='The time when the resource was created. Unit: milliseconds.', example='1234'),
    data?: {
      content?: string(name='Content', description='The content of the file that corresponds to a resource of the raw_file type.', example='abc'),
      generators?: [ 
        {
          generator?: string(name='Generator', description='The type of the feature generator.', example='id'),
          input?: {
            features?: [ 
              {
                name?: string(name='Name', description='The name of the feature.', example='system_item_id'),
                type?: string(name='Type', description='The type of the feature.', example='item'),
              }
            ](name='Features', description='The input features.'),
          }(name='Input', description='The input.'),
          output?: string(name='Output', description='The name of the output feature.', example='output_feature_name'),
        }
      ](name='Generators', description='The feature generators that correspond to resources of the feature_generator type.'),
    }(name='Data', description='The resource data. The data structure varies with the resource type.'),
    description?: string(name='Description', description='The description of the resource.', example='""'),
    functionName?: string(name='FunctionName', description='The name of the feature.', example='rank'),
    modifyTime?: long(name='ModifyTime', description='The time when the resource was modified. Unit: milliseconds.', example='1234'),
    referencedInstances?: [ string ](name='ReferencedInstances', description='The algorithm instances that are referenced.'),
    resourceName?: string(name='ResourceName', description='The name of the resource.', example='fg_json'),
    resourceType?: string(name='ResourceType', description='The type of the resource.', example='raw_file'),
  }(name='Result', description='The returned results.'),
  status?: string(name='Status', description='The HTTP status code. Valid values:

*   OK
*   FAIL', example='OK'),
}

model GetFunctionResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionResourceResponseBody(name='body'),
}

/**
 * @summary Queries an algorithm resource.
 *
 * @param request GetFunctionResourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionResourceResponse
 */
async function getFunctionResourceWithOptions(appGroupIdentity: string, functionName: string, resourceName: string, request: GetFunctionResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionResourceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.output)) {
    query['output'] = request.output;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunctionResource',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/resources/${OpenApiUtil.getEncodeParam(resourceName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries an algorithm resource.
 *
 * @param request GetFunctionResourceRequest
 * @return GetFunctionResourceResponse
 */
async function getFunctionResource(appGroupIdentity: string, functionName: string, resourceName: string, request: GetFunctionResourceRequest): GetFunctionResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionResourceWithOptions(appGroupIdentity, functionName, resourceName, request, headers, runtime);
}

model GetFunctionTaskResponseBody = {
  code?: string(name='Code', description='The error code.', example='Task.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='operation success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A4D487A9-A456-5AA5-A9C6-B7BF2889CF74'),
  result?: {
    endTime?: long(name='EndTime', description='The timestamp that indicates the end time of the task. Unit: milliseconds.', example='1647213406267'),
    extendInfo?: string(name='ExtendInfo', description='The extended information, which is a JSON string.', example='{\\\\"recall\\\\":91,\\\\"errors\\\\":[]}'),
    functionName?: string(name='FunctionName', description='The name of the feature.', example='ctr'),
    generation?: string(name='Generation', description='The number of iterations.', example='1'),
    progress?: long(name='Progress', description='The progress. 90 indicates 90%.', example='90'),
    runId?: string(name='RunId', description='The ID of the task.', example='trigger__2021-03-05T12:18:41'),
    startTime?: long(name='StartTime', description='The timestamp that indicates the start time of the task. Unit: milliseconds.', example='1647212220000'),
    status?: string(name='Status', description='The status of the task. Valid values:

*   success
*   failed
*   running', example='success'),
  }(name='Result', description='The result of the request.'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model GetFunctionTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionTaskResponseBody(name='body'),
}

/**
 * @summary Queries the details of a training task.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionTaskResponse
 */
async function getFunctionTaskWithOptions(appGroupIdentity: string, functionName: string, instanceName: string, generation: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetFunctionTask',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/instances/${OpenApiUtil.getEncodeParam(instanceName)}/tasks/${OpenApiUtil.getEncodeParam(generation)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a training task.
 *
 * @return GetFunctionTaskResponse
 */
async function getFunctionTask(appGroupIdentity: string, functionName: string, instanceName: string, generation: string): GetFunctionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionTaskWithOptions(appGroupIdentity, functionName, instanceName, generation, headers, runtime);
}

model GetFunctionVersionResponseBody = {
  code?: string(name='Code', description='The error code.', example='Version.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The maximum duration for which a task can be executed.', example='123'),
  message?: string(name='Message', description='The error message.', example='version not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1638157479281'),
  result?: {
    functionName?: string(name='FunctionName', description='The name of the feature.', example='ctr'),
    functionType?: string(name='FunctionType', description='The type of the feature. Valid values:

*   PAAS
*   SAAS', example='PAAS'),
    modelType?: string(name='ModelType', description='The type of the model.', example='tf_checkpoint'),
    versionConfig?: {
      createParameters?: [ 
        {
          name?: string(name='Name', description='The name of the parameter.', example='params1'),
          required?: string(name='Required', description='Indicates whether the parameter is required.', example='true'),
        }
      ](name='CreateParameters', description='The parameters that are used to create the instance.', example='[                 {                     "name": "params1",                     "required": "true",                     "formItemProps": "{\\\\"required\\\\": true, \\\\"pattern?\\\\": \\\\"/^[a-zA-Z][a-zA-Z0-9_]{0,29}$/\\\\"}",                     "componentProps": "{\\\\"component\\\\": \\\\"Input\\\\", \\\\"attributes\\\\": {\\\\"defaultValue\\\\": \\\\"value1\\\\"}}"                 }             ]'),
      depends?: [ 
        {
          condition?: string(name='Condition', description='The condition.', example='""'),
          dependency?: string(name='Dependency', description='The dependency.', example='""'),
          description?: string(name='Description', description='The description.', example='""'),
        }
      ](name='Depends', description='The dependencies of the instance.'),
      usageParameters?: [ 
        {
          name?: string(name='Name', description='The name of the instance.', example='""'),
          required?: string(name='Required', description='Indicates whether the parameter is required.', example='""'),
        }
      ](name='UsageParameters', description='The parameters that are used during online use of the instance.', example='[]'),
    }(name='VersionConfig', description='The configuration information.'),
    versionId?: long(name='VersionId', description='The ID of the version.', example='101'),
    versionName?: string(name='VersionName', description='The name of the version.', example='v1'),
  }(name='Result', description='The result body.', example='[]'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model GetFunctionVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionVersionResponseBody(name='body'),
}

/**
 * @summary Queries version information by version ID.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionVersionResponse
 */
async function getFunctionVersionWithOptions(functionName: string, versionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetFunctionVersion',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/functions/${OpenApiUtil.getEncodeParam(functionName)}/versions/${OpenApiUtil.getEncodeParam(versionId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries version information by version ID.
 *
 * @return GetFunctionVersionResponse
 */
async function getFunctionVersion(functionName: string, versionId: string): GetFunctionVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionVersionWithOptions(functionName, versionId, headers, runtime);
}

model GetScriptFileNamesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
  result?: [ 
    {
      createTime?: string(name='createTime', description='The time when the script file was created.', example='2020-04-02 20:21:14'),
      fileName?: string(name='fileName', description='The name of the script file.', example='my_cava_script.cava'),
      modifyTime?: string(name='modifyTime', description='The time when the script file was last modified.', example='2020-04-02 21:21:14'),
      pathName?: string(name='pathName', description='The path name of the script file.', example='src'),
    }
  ](name='result', description='The files of the script.'),
}

model GetScriptFileNamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetScriptFileNamesResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetScriptFileNamesResponse
 */
async function getScriptFileNamesWithOptions(appGroupIdentity: string, appVersionId: string, scriptName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetScriptFileNamesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetScriptFileNames',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appVersionId)}/sort-scripts/${OpenApiUtil.getEncodeParam(scriptName)}/file-names`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return GetScriptFileNamesResponse
 */
async function getScriptFileNames(appGroupIdentity: string, appVersionId: string, scriptName: string): GetScriptFileNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getScriptFileNamesWithOptions(appGroupIdentity, appVersionId, scriptName, headers, runtime);
}

model GetSearchStrategyResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='5C1C1C45-C64A-AD30-565F-140871D57E5E'),
}

model GetSearchStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSearchStrategyResponseBody(name='body'),
}

/**
 * @summary Queries the details of a query policy.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSearchStrategyResponse
 */
async function getSearchStrategyWithOptions(appGroupIdentity: string, appId: string, strategyName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetSearchStrategyResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetSearchStrategy',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/search-strategies/${OpenApiUtil.getEncodeParam(strategyName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a query policy.
 *
 * @return GetSearchStrategyResponse
 */
async function getSearchStrategy(appGroupIdentity: string, appId: string, strategyName: string): GetSearchStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSearchStrategyWithOptions(appGroupIdentity, appId, strategyName, headers, runtime);
}

model GetSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: {
    createTime?: string(name='createTime', description='The time when the script was created.', example='2020-04-02 20:21:14'),
    modifyTime?: string(name='modifyTime', description='The time when the script was last modified.', example='2020-04-02 21:21:14'),
    scope?: string(name='scope', description='The sort phase to which the script applies.', example='second_rank'),
    scriptName?: string(name='scriptName', description='The name of the script.', example='rank_cava_20230606_v7'),
    status?: string(name='status', description='The status of the script. For more information, see the description of the status response parameter in the ListSortScripts topic.', example='released'),
    type?: string(name='type', description='The type of the script.', example='cava_script'),
  }(name='result', description='The details of the script.'),
}

model GetSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSortScriptResponseBody(name='body'),
}

/**
 * @summary Queries the details of a sort script.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSortScriptResponse
 */
async function getSortScriptWithOptions(appGroupIdentity: string, scriptName: string, appVersionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetSortScriptResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetSortScript',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appVersionId)}/sort-scripts/${OpenApiUtil.getEncodeParam(scriptName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a sort script.
 *
 * @return GetSortScriptResponse
 */
async function getSortScript(appGroupIdentity: string, scriptName: string, appVersionId: string): GetSortScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSortScriptWithOptions(appGroupIdentity, scriptName, appVersionId, headers, runtime);
}

model GetSortScriptFileResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: {
    content?: string(name='content', description='The script content that is encoded in the Base64 format.', example='YWJjZGVmZw=='),
    createTime?: string(name='createTime', description='The time when the script was created.', example='2020-04-02 20:21:14'),
    modifyTime?: string(name='modifyTime', description='The time when the script was last modified.', example='2020-04-02 21:21:14'),
    version?: long(name='version', description='The version of the script content.', example='123456'),
  }(name='result', description='The content of the sort script.'),
}

model GetSortScriptFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSortScriptFileResponseBody(name='body'),
}

/**
 * @summary Queries the content of a sort script.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSortScriptFileResponse
 */
async function getSortScriptFileWithOptions(appGroupIdentity: string, scriptName: string, appVersionId: string, fileName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetSortScriptFileResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetSortScriptFile',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appVersionId)}/sort-scripts/${OpenApiUtil.getEncodeParam(scriptName)}/files/src/${OpenApiUtil.getEncodeParam(fileName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the content of a sort script.
 *
 * @return GetSortScriptFileResponse
 */
async function getSortScriptFile(appGroupIdentity: string, scriptName: string, appVersionId: string, fileName: string): GetSortScriptFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSortScriptFileWithOptions(appGroupIdentity, scriptName, appVersionId, fileName, headers, runtime);
}

model ListABTestExperimentsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ 
    {
      created?: int32(name='created', description='The time when the experiment was created.', example='1588842080'),
      id?: string(name='id', description='The experiment ID.', example='12888'),
      name?: string(name='name', description='The group alias.', example='test1'),
      online?: boolean(name='online', description='Indicates whether the experiment is in effect. Valid values:

*   true
*   false', example='true'),
      params?: map[string]any(name='params', description='The experiment parameters.', example='1'),
      traffic?: int32(name='traffic', description='The percentage of traffic that is routed to the experiment.

Valid values: [0,100]', example='30'),
      updated?: int32(name='updated', description='The time when the experiment was last modified.', example='1588842080'),
    }
  ](name='result', description='The experiment details.\\\\
For more information, see [ABTestExperiment](https://help.aliyun.com/document_detail/173617.html).'),
}

model ListABTestExperimentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListABTestExperimentsResponseBody(name='body'),
}

/**
 * @summary Queries a list of experiments.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListABTestExperimentsResponse
 */
async function listABTestExperimentsWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListABTestExperimentsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListABTestExperiments',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scenes/${OpenApiUtil.getEncodeParam(sceneId)}/groups/${OpenApiUtil.getEncodeParam(groupId)}/experiments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of experiments.
 *
 * @return ListABTestExperimentsResponse
 */
async function listABTestExperiments(appGroupIdentity: string, sceneId: string, groupId: string): ListABTestExperimentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listABTestExperimentsWithOptions(appGroupIdentity, sceneId, groupId, headers, runtime);
}

model ListABTestFixedFlowDividersResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ string ](name='result', description='The queried whitelists.'),
}

model ListABTestFixedFlowDividersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListABTestFixedFlowDividersResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListABTestFixedFlowDividersResponse
 */
async function listABTestFixedFlowDividersWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListABTestFixedFlowDividersResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListABTestFixedFlowDividers',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scenes/${OpenApiUtil.getEncodeParam(sceneId)}/groups/${OpenApiUtil.getEncodeParam(groupId)}/experiments/${OpenApiUtil.getEncodeParam(experimentId)}/fixed-flow-dividers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return ListABTestFixedFlowDividersResponse
 */
async function listABTestFixedFlowDividers(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string): ListABTestFixedFlowDividersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listABTestFixedFlowDividersWithOptions(appGroupIdentity, sceneId, groupId, experimentId, headers, runtime);
}

model ListABTestGroupsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ 
    {
      created?: int32(name='created', description='The time when the test group was created.', example='1588839490'),
      id?: string(name='id', description='The ID of the test group.', example='13466'),
      name?: string(name='name', description='The name of the test group.', example='Group_2020-5-7_15:23:3'),
      status?: int32(name='status', description='The status of the test group. Valid values:

*   0: not in effect
*   1: in effect', example='1'),
      updated?: int32(name='updated', description='The time when the test group was last modified.', example='1588839490'),
    }
  ](name='result', description='The test groups.

For more information, see [ABTestGroup](https://help.aliyun.com/document_detail/178935.html).'),
}

model ListABTestGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListABTestGroupsResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListABTestGroupsResponse
 */
async function listABTestGroupsWithOptions(appGroupIdentity: string, sceneId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListABTestGroupsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListABTestGroups',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scenes/${OpenApiUtil.getEncodeParam(sceneId)}/groups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return ListABTestGroupsResponse
 */
async function listABTestGroups(appGroupIdentity: string, sceneId: string): ListABTestGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listABTestGroupsWithOptions(appGroupIdentity, sceneId, headers, runtime);
}

model ListABTestScenesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ 
    {
      created?: int32(name='created', description='The time when the test scenario was created.', example='1588836130'),
      id?: string(name='id', description='The ID of the test group.', example='20404'),
      name?: string(name='name', description='The name of the test group.', example='kevintest_2020-5-7_15:21:482'),
      status?: int32(name='status', description='The status of the test scenario. Valid values:

*   0: not in effect
*   1: in effect', example='1'),
      updated?: int32(name='updated', description='The time when the test scenario was last modified.', example='1588836129'),
      values?: [ string ](name='values', description='The name of the test scenario.'),
    }
  ](name='result', description='The details of the test scenarios.

For more information, see [ABTestScene](https://help.aliyun.com/document_detail/173618.html).'),
}

model ListABTestScenesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListABTestScenesResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListABTestScenesResponse
 */
async function listABTestScenesWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListABTestScenesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListABTestScenes',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scenes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return ListABTestScenesResponse
 */
async function listABTestScenes(appGroupIdentity: string): ListABTestScenesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listABTestScenesWithOptions(appGroupIdentity, headers, runtime);
}

model ListAppGroupsRequest {
  instanceId?: string(name='instanceId', description='The ID of the instance. Exact match is used.', example='ops-cn-xxxx'),
  name?: string(name='name', description='The name of the application.', example='my_name'),
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group.', example='"110123123"'),
  sortBy?: int32(name='sortBy', description='The method based on which applications are sorted. Valid values:

*   0: sorts applications in descending order by creation time.
*   1: sorts applications in descending order by modification time.

Default value: 0.', example='0'),
  tags?: [ 
    {
      key?: string(name='key', description='The tag key.', example='foo'),
      value?: string(name='value', description='The tag value.', example='bar'),
    }
  ](name='tags', description='The tags.'),
  type?: string(name='type', description='The type of the application. Valid values:

*   standard: a High-performance Search Edition application.
*   enhanced: an Industry Algorithm Edition application.', example='standard'),
}

model ListAppGroupsShrinkRequest {
  instanceId?: string(name='instanceId', description='The ID of the instance. Exact match is used.', example='ops-cn-xxxx'),
  name?: string(name='name', description='The name of the application.', example='my_name'),
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group.', example='"110123123"'),
  sortBy?: int32(name='sortBy', description='The method based on which applications are sorted. Valid values:

*   0: sorts applications in descending order by creation time.
*   1: sorts applications in descending order by modification time.

Default value: 0.', example='0'),
  tagsShrink?: string(name='tags', description='The tags.'),
  type?: string(name='type', description='The type of the application. Valid values:

*   standard: a High-performance Search Edition application.
*   enhanced: an Industry Algorithm Edition application.', example='standard'),
}

model ListAppGroupsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      chargeType?: string(name='chargeType', description='The billing method. Valid values:

*   POSTPAY: pay-as-you-go.
*   PREPAY: subscription.', example='POSTPAY'),
      chargingWay?: int32(name='chargingWay', description='The billable item. Valid values:

*   1: computing resources.
*   2: queries per second (QPS).', example='1'),
      commodityCode?: string(name='commodityCode', description='The commodity code.', example='opensearch'),
      created?: int32(name='created', description='The timestamp when the application was created.', example='1575442875'),
      currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='110116134'),
      description?: string(name='description', description='The description of the application.', example='"xxx"'),
      domain?: string(name='domain', description='The industry of the application.', example='""'),
      engineType?: string(name='engineType'),
      expireOn?: string(name='expireOn', description='The time when the application expired.', example='"xxx"'),
      hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval state of the quotas. Valid values:

*   0: The application is in service.
*   1: The quotas are being reviewed.', example='0'),
      id?: string(name='id', description='The application ID.', example='110116134'),
      instanceId?: string(name='instanceId', description='The instance ID.', example='"xxx"'),
      lockMode?: string(name='lockMode', description='The lock state. Valid values:

*   Unlock: The instance is unlocked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
      lockedByExpiration?: int32(name='lockedByExpiration', description='Indicates whether the instance is automatically locked after it expires.', example='0'),
      name?: string(name='name', description='The application name.', example='os_function_test_v1'),
      produced?: int32(name='produced', description='Indicates whether the application is created. Valid values:

*   0: The application is being created.
*   1: The application is created.', example='1'),
      projectId?: string(name='projectId', description='The name of the A/B test group.', example='"xxx"'),
      quota?: {
        computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing unit (LCU).', example='20'),
        docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
        spec?: string(name='spec', description='The specifications. Valid values:

*   opensearch.share.junior: basic.
*   opensearch.share.common: shared general-purpose.
*   opensearch.share.compute: shared computing.
*   opensearch.share.storage: shared storage.
*   opensearch.private.common: exclusive general-purpose.
*   opensearch.private.compute: exclusive computing.
*   opensearch.private.storage: exclusive storage.', example='opensearch.share.common'),
      }(name='quota', description='The information about the quotas of the application. For more information, see [Quota](https://help.aliyun.com/document_detail/170001.html).', example='{}'),
      status?: string(name='status', description='The state of the application. Valid values:

*   producing: The application is being created.
*   review_pending: The application is being reviewed.
*   config_pending: The application is to be configured.
*   normal: The application is in service.
*   frozen: The application is frozen.', example='normal'),
      switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='0'),
      tags?: [ 
        {
          key?: string(name='key', description='The tag key.', example='foo'),
          value?: string(name='value', description='The tag value.', example='bar'),
        }
      ](name='tags', description='The application tags.'),
      type?: string(name='type', description='The type of the application. Valid values:

*   standard: a High-performance Search Edition application.
*
*   enhanced: an Industry Algorithm Edition application.', example='enhanced'),
      updated?: int32(name='updated', description='The timestamp when the application was last updated.', example='1578916076'),
    }
  ](name='result', description='The information about the application.

For more information, see [AppGroup](https://help.aliyun.com/document_detail/170000.html).', example='[]'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='1'),
}

model ListAppGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAppGroupsResponseBody(name='body'),
}

/**
 * @summary Queries a list of OpenSearch applications.
 *
 * @description *   This operation allows you to query applications by application name, instance ID, and application type.
 * *   This operation allows you to sort the applications based on their creation time.
 * *   This operation supports the parameters for paging.
 *
 * @param tmpReq ListAppGroupsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAppGroupsResponse
 */
async function listAppGroupsWithOptions(tmpReq: ListAppGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAppGroupsResponse {
  Util.validateModel(tmpReq);
  var request = new ListAppGroupsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'tags', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['sortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAppGroups',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of OpenSearch applications.
 *
 * @description *   This operation allows you to query applications by application name, instance ID, and application type.
 * *   This operation allows you to sort the applications based on their creation time.
 * *   This operation supports the parameters for paging.
 *
 * @param request ListAppGroupsRequest
 * @return ListAppGroupsResponse
 */
async function listAppGroups(request: ListAppGroupsRequest): ListAppGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAppGroupsWithOptions(request, headers, runtime);
}

model ListDataCollectionsRequest {
  pageNumber?: int32(name='pageNumber', description='1', example='1'),
  pageSize?: int32(name='pageSize', description='10', example='10'),
}

model ListDataCollectionsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='959D8782-B130-95EB-86CC-1F6ED447981F'),
  result?: [ 
    {
      created?: int32(name='created', description='The time when the data collection task was created.', example='1581065837'),
      dataCollectionType?: string(name='dataCollectionType', description='The type of the data that is collected by the task. Valid values:

*   behavior: behavioral data
*   item_info: project data
*   industry_specific: industry-specific data', example='BEHAVIOR'),
      id?: string(name='id', description='The ID of the data collection task.', example='286'),
      industryName?: string(name='industryName', description='The industry to which the data collection task applies. Valid values:

*   general
*   ecommerce', example='GENERAL'),
      name?: string(name='name', description='The name of the data collection task.', example='os_function_test_v1'),
      status?: int32(name='status', description='The status of the data collection task. Valid values:

*   0: disabled
*   1: being enabled
*   2: enabled
*   3: failed to be enabled', example='2'),
      sundialId?: string(name='sundialId', description='The ID of the sundial.', example='1755'),
      type?: string(name='type', description='The type of the data source. Valid values:

*   server
*   web
*   app

Note: Only server is supported.', example='server'),
      updated?: int32(name='updated', description='The time when the data collection task was updated.', example='1581065904'),
    }
  ](name='result', description='The details of the data collection tasks.

For more information, see [DataCollection](https://help.aliyun.com/document_detail/173605.html).'),
  totalCount?: int32(name='totalCount', description='The total number of the returned data collection tasks.', example='1'),
}

model ListDataCollectionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataCollectionsResponseBody(name='body'),
}

/**
 * @param request ListDataCollectionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataCollectionsResponse
 */
async function listDataCollectionsWithOptions(appGroupIdentity: string, request: ListDataCollectionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataCollectionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDataCollections',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/data-collections`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListDataCollectionsRequest
 * @return ListDataCollectionsResponse
 */
async function listDataCollections(appGroupIdentity: string, request: ListDataCollectionsRequest): ListDataCollectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataCollectionsWithOptions(appGroupIdentity, request, headers, runtime);
}

model ListDataSourceTableFieldsRequest {
  params?: string(name='params', description='The parameters of the data source. The value of the params parameter is a JSON string. The value must be URL-encoded.

Different types of data sources use different parameters. For more information, see the following sections of the "DataSource" topic:

*   [rds](https://help.aliyun.com/document_detail/170005.html)
*   [polardb](https://help.aliyun.com/document_detail/170005.html)
*   [odps](https://help.aliyun.com/document_detail/170005.html)
*   [mysql](https://help.aliyun.com/document_detail/173627.html)
*   [drds](https://help.aliyun.com/document_detail/173627.html)

This parameter is required.', example='{}'),
  rawType?: boolean(name='rawType', description='Specifies whether to return the original field types of the data source.', example='false'),
}

model ListDataSourceTableFieldsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: map[string]any(name='result', description='The returned result.', example='{}'),
}

model ListDataSourceTableFieldsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataSourceTableFieldsResponseBody(name='body'),
}

/**
 * @summary Queries all fields in a table of a data source. This operation is for internal use only.
 *
 * @param request ListDataSourceTableFieldsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataSourceTableFieldsResponse
 */
async function listDataSourceTableFieldsWithOptions(dataSourceType: string, request: ListDataSourceTableFieldsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataSourceTableFieldsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.params)) {
    query['params'] = request.params;
  }
  if (!Util.isUnset(request.rawType)) {
    query['rawType'] = request.rawType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDataSourceTableFields',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/assist/data-sources/${OpenApiUtil.getEncodeParam(dataSourceType)}/fields`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all fields in a table of a data source. This operation is for internal use only.
 *
 * @param request ListDataSourceTableFieldsRequest
 * @return ListDataSourceTableFieldsResponse
 */
async function listDataSourceTableFields(dataSourceType: string, request: ListDataSourceTableFieldsRequest): ListDataSourceTableFieldsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataSourceTableFieldsWithOptions(dataSourceType, request, headers, runtime);
}

model ListDataSourceTablesRequest {
  params?: string(name='params', description='N/A

This parameter is required.', example='-'),
}

model ListDataSourceTablesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ string ](name='result', description='The data tables.'),
}

model ListDataSourceTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataSourceTablesResponseBody(name='body'),
}

/**
 * @param request ListDataSourceTablesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataSourceTablesResponse
 */
async function listDataSourceTablesWithOptions(dataSourceType: string, request: ListDataSourceTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataSourceTablesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.params)) {
    query['params'] = request.params;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDataSourceTables',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/assist/data-sources/${OpenApiUtil.getEncodeParam(dataSourceType)}/tables`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListDataSourceTablesRequest
 * @return ListDataSourceTablesResponse
 */
async function listDataSourceTables(dataSourceType: string, request: ListDataSourceTablesRequest): ListDataSourceTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataSourceTablesWithOptions(dataSourceType, request, headers, runtime);
}

model ListFirstRanksResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
      created?: int32(name='created', description='The time when the cluster was created.', example='0'),
      description?: string(name='description', description='The description of the expression.', example='""'),
      meta?: [ 
        {
          arg?: string(name='arg', description='The parameters that are used by a function in the expression.

For more information, see [Rough sort functions](https://help.aliyun.com/document_detail/180765.html).', example='""'),
          attribute?: string(name='attribute', description='The attribute, feature function, or field to be searched for.

For more information about supported feature functions, see [Rough sort functions](https://help.aliyun.com/document_detail/180765.html).', example='static_bm25()'),
          weight?: int32(name='weight', description='The weight.

Valid values: [-100000,100000] (excluding 0).', example='1'),
        }
      ](name='meta', description='The content of the expression.', example='[]'),
      name?: string(name='name', description='The name of the expression.', example='default'),
      updated?: int32(name='updated', description='The time when the cluster was updated.', example='0'),
    }
  ](name='result', description='The information about each rough sort expression.

For more information, see [FirstRank](https://help.aliyun.com/document_detail/170007.html).', example='[]'),
}

model ListFirstRanksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFirstRanksResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFirstRanksResponse
 */
async function listFirstRanksWithOptions(appGroupIdentity: string, appId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListFirstRanksResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListFirstRanks',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/first-ranks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return ListFirstRanksResponse
 */
async function listFirstRanks(appGroupIdentity: string, appId: string): ListFirstRanksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFirstRanksWithOptions(appGroupIdentity, appId, headers, runtime);
}

model ListFunctionInstancesRequest {
  functionType?: string(name='functionType', description='The type of the feature.', example='"PAAS"'),
  modelType?: string(name='modelType', description='The type of the model.', example='tf_checkpoint'),
  output?: string(name='output', description='The richness of the returned information. Valid values:

*   normal: displays information such as createParameters and cron. This is the default value.
*   simple: displays only the basic information.
*   detail: returns the details of the training task.', example='normal'),
  pageNumber?: int32(name='pageNumber', description='The number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries to return on each page. Default value: 10.', example='10'),
  source?: string(name='source', description='How the instance is created. Valid values:

*   builtin: The instance is created by system.
*   user: The instance is created by user. This is the default value.
*   all: all instances', example='user'),
}

model ListFunctionInstancesResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, the parameter is left empty.', example='Instance.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message. If no error occurs, the parameter is left empty.', example='instance not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A4D487A9-A456-5AA5-A9C6-B7BF2889CF74'),
  result?: [ 
    {
      belongs?: {
        category?: string(name='Category', description='The category.', example='"general"'),
        domain?: string(name='Domain', description='The industry.', example='"ecommerce"'),
        language?: string(name='Language', description='The abbreviation of the language that applies.', example='"zh"'),
      }(name='Belongs', description='The information about the instance.', example='{}'),
      createParameters?: [ 
        {
          name?: string(name='Name', description='The name of the parameter.', example='"param1"'),
          value?: string(name='Value', description='The value of the parameter.', example='"value1"'),
        }
      ](name='CreateParameters', description='The parameters of the instance.', example='[]'),
      createTime?: long(name='CreateTime', description='The time when the instance was created.', example='1234'),
      cron?: string(name='Cron', description='The cron expression used to schedule training, in the format of (Minutes Hours DayofMonth Month DayofWeek). If the value is empty, it indicates that no periodic training is performed.', example='0 3 ? \\\\* 0,1,3,5 (at 3 a.m. on Sunday, Monday, Wednesday, and Friday)'),
      description?: string(name='Description', description='The description.', example='" "'),
      extendInfo?: string(name='ExtendInfo', description='The extended information, which is a JSON string. It includes model evaluation information and error information.', example='"{\\\\"dataReport\\\\":{},\\\\"errors\\\\":{}}"'),
      functionName?: string(name='FunctionName', description='The name of the feature.', example='"ctr"'),
      functionType?: string(name='FunctionType', description='The type of the feature.', example='"PAAS"'),
      instanceName?: string(name='InstanceName', description='The name of the instance.', example='"ctr_test"'),
      modelType?: string(name='ModelType', description='The type of the model.', example='"tf_checkpoint"'),
      source?: string(name='Source', description='How the instance is created. Valid values:

*   user: The instance is created by user.
*   builtin: The instance is created by system.', example='"user"'),
      status?: string(name='Status', description='The state of the instance. Valid values:

1.  unavailable: No model is available. Models must be trained before you can use them.
2.  available: Models can be used.', example='available'),
      usageParameters?: [ 
        {
          name?: string(name='Name', description='The name of the parameter.', example='use_param1'),
          value?: string(name='Value', description='The value of the parameter.', example='value1'),
        }
      ](name='UsageParameters', description='The parameters that are used.'),
      versionId?: long(name='VersionId', description='The ID of the version.', example='123'),
    }
  ](name='Result', description='The information about the instances.', example='[]'),
  status?: string(name='Status', description='The status of the request.', example='"OK"'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model ListFunctionInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionInstancesResponseBody(name='body'),
}

/**
 * @summary Queries all algorithm instances of a user, which meet specified conditions.
 *
 * @param request ListFunctionInstancesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFunctionInstancesResponse
 */
async function listFunctionInstancesWithOptions(appGroupIdentity: string, functionName: string, request: ListFunctionInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.functionType)) {
    query['functionType'] = request.functionType;
  }
  if (!Util.isUnset(request.modelType)) {
    query['modelType'] = request.modelType;
  }
  if (!Util.isUnset(request.output)) {
    query['output'] = request.output;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.source)) {
    query['source'] = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctionInstances',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all algorithm instances of a user, which meet specified conditions.
 *
 * @param request ListFunctionInstancesRequest
 * @return ListFunctionInstancesResponse
 */
async function listFunctionInstances(appGroupIdentity: string, functionName: string, request: ListFunctionInstancesRequest): ListFunctionInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionInstancesWithOptions(appGroupIdentity, functionName, request, headers, runtime);
}

model ListFunctionResourcesRequest {
  output?: string(name='output', description='The output level.

Valid values:

*   simple
*   normal
*   detail', example='detail'),
  pageNumber?: int32(name='pageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries returned per page.', example='10'),
  resourceType?: string(name='resourceType', description='The type of the resource.

Valid values:

*   feature_generator

    <!-- -->

    <!-- -->

    <!-- -->

*   raw_file

    <!-- -->

    <!-- -->

    <!-- -->', example='feature_generator'),
}

model ListFunctionResourcesResponseBody = {
  code?: string(name='Code', description='The error code returned. If no error occurs, this value is empty.', example='Resource.InvalidResourceName'),
  httpCode?: long(name='HttpCode', description='The HTTP status code returned.', example='200'),
  latency?: double(name='Latency', description='The amount of time consumed for the request. Unit: milliseconds.', example='123'),
  message?: string(name='Message', description='The error message returned.', example='Invalid resource name.'),
  requestId?: string(name='RequestId', description='The request ID.', example='"3A809095-C554-5CF5-8FCE-BE19D4673790"'),
  result?: [ 
    {
      createTime?: long(name='CreateTime', description='The time when the resource was created. Unit: milliseconds.', example='1234'),
      data?: {
        content?: string(name='Content', description='The content of the file that corresponds to a resource of the raw_file type.', example='"abc"'),
        generators?: [ 
          {
            generator?: string(name='Generator', description='The type of the feature generator.', example='combo'),
            input?: {
              features?: [ 
                {
                  name?: string(name='Name', description='The name of the feature.', example='system_item_id'),
                  type?: string(name='Type', description='The type of the feature.

Valid values:

*   item

    <!-- -->

    <!-- -->

    <!-- -->

*   user

    <!-- -->

    <!-- -->

    <!-- -->', example='item'),
                }
              ](name='Features', description='The input features.'),
            }(name='Input', description='The input.'),
            output?: string(name='Output', description='The name of the output feature.', example='feature1'),
          }
        ](name='Generators', description='The feature generators that correspond to resources of the feature_generator type.'),
      }(name='Data', description='The resource data. The data structure varies with the resource type.'),
      description?: string(name='Description', description='The description of the resource.', example='resource description'),
      functionName?: string(name='FunctionName', description='The name of the feature.', example='rank'),
      modifyTime?: long(name='ModifyTime', description='The time when the resource was modified. Unit: milliseconds.', example='1234'),
      referencedInstances?: [ string ](name='ReferencedInstances', description='The algorithm instances that are referenced.'),
      resourceName?: string(name='ResourceName', description='The name of the resource.', example='fg_json'),
      resourceType?: string(name='ResourceType', description='The type of the resource.', example='feature_generator'),
    }
  ](name='Result', description='The results returned.'),
  status?: string(name='Status', description='The status of the request. Valid values: OK and FAIL.', example='OK'),
  totalCount?: long(name='TotalCount', description='The total number of records that meet the requirements.', example='2'),
}

model ListFunctionResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionResourcesResponseBody(name='body'),
}

/**
 * @summary Queries algorithm resources.
 *
 * @param request ListFunctionResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFunctionResourcesResponse
 */
async function listFunctionResourcesWithOptions(appGroupIdentity: string, functionName: string, request: ListFunctionResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.output)) {
    query['output'] = request.output;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctionResources',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/resources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries algorithm resources.
 *
 * @param request ListFunctionResourcesRequest
 * @return ListFunctionResourcesResponse
 */
async function listFunctionResources(appGroupIdentity: string, functionName: string, request: ListFunctionResourcesRequest): ListFunctionResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionResourcesWithOptions(appGroupIdentity, functionName, request, headers, runtime);
}

model ListFunctionTasksRequest {
  endTime?: long(name='endTime', description='The end time is less than the specified time. Specify the time in the UNIX timestamp format. Unit: milliseconds.', example='1582646399'),
  pageNumber?: int32(name='pageNumber', description='The number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries to return on each page. Default value: 1.', example='10'),
  startTime?: long(name='startTime', description='The start time is greater than the specified time. Specify the time in the UNIX timestamp format. Unit: milliseconds.', example='1582214400'),
  status?: string(name='status', description='The status of the task. Valid values:

*   success
*   failed
*   running', example='success'),
}

model ListFunctionTasksResponseBody = {
  code?: string(name='Code', description='The error code.', example='200'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='fail'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1638157479281'),
  result?: [ 
    {
      endTime?: long(name='EndTime', description='The timestamp that indicates the end time. Unit: milliseconds. 0 indicates that the task has not ended.', example='100010'),
      extendInfo?: string(name='ExtendInfo', description='The value is a JSON string. It includes model evaluation information and training error information.', example='{\\\\"recall\\\\":91,\\\\"errors\\\\":[]}'),
      functionName?: string(name='FunctionName', description='The name of the feature.', example='ctr'),
      generation?: string(name='Generation', description='The number of iterations.', example='2'),
      progress?: long(name='Progress', description='The progress. 90 indicates 90%.', example='90'),
      runId?: string(name='RunId', description='The ID of the task.', example='trigger__2021-03-05T12:18:41'),
      startTime?: long(name='StartTime', description='The timestamp that indicates the start time. Unit: milliseconds.', example='100010'),
      status?: string(name='Status', description='The status of the task. Valid values:

*   success
*   failed
*   running', example='success'),
    }
  ](name='Result', description='The returned result.', example='[         {             "functionName": "ctr",             "progress": 100,             "status": "success",             "startTime": 100010,             "endTime": 200020,             "extendInfo": "{\\\\"recall\\\\":91,\\\\"errors\\\\":[]}",             "runId": "trigger__2021-03-05T12:18:41"         }     ]'),
  status?: string(name='Status', description='The status of the request.', example='200'),
  totalCount?: long(name='TotalCount', description='The total number of records that meet the requirements.', example='2'),
}

model ListFunctionTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionTasksResponseBody(name='body'),
}

/**
 * @summary Queries the training tasks. The returned results are sorted by start time in descending order.
 *
 * @param request ListFunctionTasksRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFunctionTasksResponse
 */
async function listFunctionTasksWithOptions(appGroupIdentity: string, functionName: string, instanceName: string, request: ListFunctionTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionTasksResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctionTasks',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/instances/${OpenApiUtil.getEncodeParam(instanceName)}/tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the training tasks. The returned results are sorted by start time in descending order.
 *
 * @param request ListFunctionTasksRequest
 * @return ListFunctionTasksResponse
 */
async function listFunctionTasks(appGroupIdentity: string, functionName: string, instanceName: string, request: ListFunctionTasksRequest): ListFunctionTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionTasksWithOptions(appGroupIdentity, functionName, instanceName, request, headers, runtime);
}

model ListInterventionDictionariesRequest {
  pageNumber?: int32(name='pageNumber', description='The number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries to return on each page. Default value: 10.', example='10'),
  types?: string(name='types', description='The type of the intervention dictionary. Valid values:

*   stopword: an intervention dictionary for stop word filtering
*   synonym: an intervention dictionary for synonym configuration
*   correction: an intervention dictionary for spelling correction
*   category_prediction: an intervention dictionary for category prediction
*   ner: an intervention dictionary for named entity recognition (NER)
*   term_weighting: an intervention dictionary for term weight analysis', example='["synonym"]'),
}

model ListInterventionDictionariesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      analyzer?: string(name='analyzer', description='The custom analyzer.', example='""'),
      created?: int32(name='created', description='The time when the intervention dictionary was created.', example='1539158325'),
      id?: int32(name='id', description='The ID of the intervention dictionary.', example='1'),
      name?: string(name='name', description='The name of the intervention dictionary.', example='tongyici'),
      type?: string(name='type', description='The type of the intervention dictionary. Valid values:

*   stopword: an intervention dictionary for stop word filtering
*   synonym: an intervention dictionary for synonym configuration
*   correction: an intervention dictionary for spelling correction
*   category_prediction: an intervention dictionary for category prediction
*   ner: an intervention dictionary for named entity recognition (NER)
*   term_weighting: an intervention dictionary for term weight analysis', example='synonym'),
      updated?: int32(name='updated', description='The time when the intervention dictionary was last updated.', example='1539158313'),
    }
  ](name='result', description='The information about each intervention dictionary.

For more information, see [InterventionDictionary](https://help.aliyun.com/document_detail/173608.html).'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='2'),
}

model ListInterventionDictionariesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInterventionDictionariesResponseBody(name='body'),
}

/**
 * @param request ListInterventionDictionariesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInterventionDictionariesResponse
 */
async function listInterventionDictionariesWithOptions(request: ListInterventionDictionariesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInterventionDictionariesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.types)) {
    query['types'] = request.types;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInterventionDictionaries',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/intervention-dictionaries`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListInterventionDictionariesRequest
 * @return ListInterventionDictionariesResponse
 */
async function listInterventionDictionaries(request: ListInterventionDictionariesRequest): ListInterventionDictionariesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInterventionDictionariesWithOptions(request, headers, runtime);
}

model ListInterventionDictionaryEntriesRequest {
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries returned per page. Default value: 10.', example='10'),
  word?: string(name='word', description='The intervention entry.', example='test'),
}

model ListInterventionDictionaryEntriesResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='516A02B7-2167-8D92-12D0-B639A2A0F3C5'),
  result?: [ 
    {
      cmd?: string(name='cmd', description='The command. Valid values:

*   add
*   delete', example='add'),
      created?: long(name='created', description='The timestamp when the intervention entry was created.', example='1536690285'),
      relevance?: map[string]any(name='relevance', description='The content of an intervention entry for category prediction. The field value consists of key-value pairs. The key in a key-value pair indicates the ID of the category. The value in a key-value pair indicates the relevance to the category. A value of 0 indicates irrelevant. A value of 1 indicates slightly relevant. A value of 2 indicates relevant. Example: {"2":1, "100":0}', example='{                 "100": "0",                 "200": "2"             }'),
      status?: string(name='status', description='The status of the intervention entry. Valid value:

*   ACTIVE: The intervention entry takes effect.', example='ACTIVE'),
      tokens?: [ 
        {
          order?: int32(name='order', description='The sequence number.', example='1'),
          tag?: string(name='tag', description='The internal name of the identified entity type. Valid values:

*   brand
*   category
*   material
*   element
*   style
*   color
*   function
*   scenario
*   people
*   season
*   model
*   region
*   name
*   adjective
*   category-modifier
*   size
*   quality
*   suit
*   new-release
*   series
*   marketing
*   entertainment
*   organization
*   movie
*   game
*   number
*   unit
*   common
*   new-word
*   proper-noun
*   symbol
*   prefix
*   suffix
*   gift
*   negative
*   agent', example='category'),
          tagLabel?: string(name='tagLabel', description='The description of the internal name of the identified entity type.', example='category'),
          token?: string(name='token', description='The entity.', example='category'),
        }
      ](name='tokens', description='The content of the intervention entry for term weight analysis.'),
      updated?: long(name='updated', description='The timestamp when the intervention entry was last updated.', example='1537348987'),
      word?: string(name='word', description='The intervention entry.', example='\\\\u8fc7\\\\u513f'),
    }
  ](name='result', description='The information about intervention entries.

For more information, see [InterventionDictionaryEntry](https://help.aliyun.com/document_detail/173606.html).'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='8'),
}

model ListInterventionDictionaryEntriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInterventionDictionaryEntriesResponseBody(name='body'),
}

/**
 * @summary Queries the intervention entries in an intervention dictionary.
 *
 * @param request ListInterventionDictionaryEntriesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInterventionDictionaryEntriesResponse
 */
async function listInterventionDictionaryEntriesWithOptions(name: string, request: ListInterventionDictionaryEntriesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInterventionDictionaryEntriesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.word)) {
    query['word'] = request.word;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInterventionDictionaryEntries',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/intervention-dictionaries/${OpenApiUtil.getEncodeParam(name)}/entries`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the intervention entries in an intervention dictionary.
 *
 * @param request ListInterventionDictionaryEntriesRequest
 * @return ListInterventionDictionaryEntriesResponse
 */
async function listInterventionDictionaryEntries(name: string, request: ListInterventionDictionaryEntriesRequest): ListInterventionDictionaryEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInterventionDictionaryEntriesWithOptions(name, request, headers, runtime);
}

model ListInterventionDictionaryNerResultsRequest {
  query?: string(name='query', description='Query keywords.

This parameter is required.', example='"hello world"'),
}

model ListInterventionDictionaryNerResultsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='8F780CA8-D4D4-2FFE-B8AC-42040822C554'),
  result?: [ 
    {
      order?: int32(name='order', description='The sequence number.', example='1'),
      tag?: string(name='tag', description='The internal name of the identified entity type. Valid values:

*   brand
*   category
*   material
*   element
*   style
*   color
*   function
*   scenario
*   people
*   season
*   model
*   region
*   name
*   adjective
*   category-modifier
*   size
*   quality
*   suit
*   new-release
*   series
*   marketing
*   entertainment
*   organization
*   movie
*   game
*   number
*   unit
*   common
*   new-word
*   proper-noun
*   symbol
*   prefix
*   suffix
*   gift
*   negative
*   agent', example='category'),
      tagLabel?: string(name='tagLabel', description='The description of the internal name of the identified entity type.', example='category'),
      token?: string(name='token', description='The entity.', example='eaa73f35-007a-4be7-88c7-37dca4a04ab7'),
    }
  ](name='result', description='The NER result.

For more information, see [InterventionDictionaryEntry](https://help.aliyun.com/document_detail/173606.html).'),
}

model ListInterventionDictionaryNerResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInterventionDictionaryNerResultsResponseBody(name='body'),
}

/**
 * @param request ListInterventionDictionaryNerResultsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInterventionDictionaryNerResultsResponse
 */
async function listInterventionDictionaryNerResultsWithOptions(name: string, request: ListInterventionDictionaryNerResultsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInterventionDictionaryNerResultsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInterventionDictionaryNerResults',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/intervention-dictionaries/${OpenApiUtil.getEncodeParam(name)}/ner-results`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListInterventionDictionaryNerResultsRequest
 * @return ListInterventionDictionaryNerResultsResponse
 */
async function listInterventionDictionaryNerResults(name: string, request: ListInterventionDictionaryNerResultsRequest): ListInterventionDictionaryNerResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInterventionDictionaryNerResultsWithOptions(name, request, headers, runtime);
}

model ListInterventionDictionaryRelatedEntitiesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [  map[string]any ](name='result', description='The information about each application and each query analysis rule. If no query analysis rule references the intervention dictionary, the value of the result parameter is an empty list.'),
}

model ListInterventionDictionaryRelatedEntitiesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInterventionDictionaryRelatedEntitiesResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInterventionDictionaryRelatedEntitiesResponse
 */
async function listInterventionDictionaryRelatedEntitiesWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListInterventionDictionaryRelatedEntitiesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListInterventionDictionaryRelatedEntities',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/intervention-dictionaries/${OpenApiUtil.getEncodeParam(name)}/related`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return ListInterventionDictionaryRelatedEntitiesResponse
 */
async function listInterventionDictionaryRelatedEntities(name: string): ListInterventionDictionaryRelatedEntitiesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInterventionDictionaryRelatedEntitiesWithOptions(name, headers, runtime);
}

model ListProceedingsRequest {
  filterFinished?: boolean(name='filterFinished', description='Specifies whether the filtering is complete.', example='true'),
}

model ListProceedingsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='F5099063-6B86-F398-D843-905F9EFB683A'),
}

model ListProceedingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProceedingsResponseBody(name='body'),
}

/**
 * @summary 查看当前的处理流
 *
 * @param request ListProceedingsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListProceedingsResponse
 */
async function listProceedingsWithOptions(appGroupIdentity: string, request: ListProceedingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProceedingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.filterFinished)) {
    query['filterFinished'] = request.filterFinished;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProceedings',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/proceedings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查看当前的处理流
 *
 * @param request ListProceedingsRequest
 * @return ListProceedingsResponse
 */
async function listProceedings(appGroupIdentity: string, request: ListProceedingsRequest): ListProceedingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProceedingsWithOptions(appGroupIdentity, request, headers, runtime);
}

model ListQueryProcessorAnalyzerResultsRequest {
  text?: string(name='text', description='The text to be tested.

This parameter is required.', example='"abcde"'),
}

model ListQueryProcessorAnalyzerResultsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='98724351-D6B2-5D8A-B089-7FFD1821A7E9'),
  result?: map[string]any(name='result', description='The data returned.', example='{}'),
}

model ListQueryProcessorAnalyzerResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueryProcessorAnalyzerResultsResponseBody(name='body'),
}

/**
 * @summary Queries the results of a query analysis test. This API operation is available only to existing applications of OpenSearch Open Source Compatible Edition.
 *
 * @param request ListQueryProcessorAnalyzerResultsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQueryProcessorAnalyzerResultsResponse
 */
async function listQueryProcessorAnalyzerResultsWithOptions(appGroupIdentity: string, appId: string, name: string, request: ListQueryProcessorAnalyzerResultsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListQueryProcessorAnalyzerResultsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.text)) {
    query['text'] = request.text;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListQueryProcessorAnalyzerResults',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/query-processors/${OpenApiUtil.getEncodeParam(name)}/analyze`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the results of a query analysis test. This API operation is available only to existing applications of OpenSearch Open Source Compatible Edition.
 *
 * @param request ListQueryProcessorAnalyzerResultsRequest
 * @return ListQueryProcessorAnalyzerResultsResponse
 */
async function listQueryProcessorAnalyzerResults(appGroupIdentity: string, appId: string, name: string, request: ListQueryProcessorAnalyzerResultsRequest): ListQueryProcessorAnalyzerResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listQueryProcessorAnalyzerResultsWithOptions(appGroupIdentity, appId, name, request, headers, runtime);
}

model ListQueryProcessorNersRequest {
  domain?: string(name='domain', description='The type of the industry.

*   ECOMMERCE', example='ECOMMERCE'),
}

model ListQueryProcessorNersResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      label?: string(name='label', description='The name of the entity type.', example='brand'),
      order?: int32(name='order', description='The priority of an entity type among entity types that have the same priority level. A smaller value indicates a higher priority. Default value: 0.', example='1'),
      priority?: string(name='priority', description='The priority level of the entity type. Valid values:

*   HIGH
*   MIDDLE
*   LOW', example='HIGH'),
      tag?: string(name='tag', description='The internal name of the entity type.', example='brand'),
    }
  ](name='result', description='The priority settings of entity types.

For more information, see [Priority settings of entity types](https://help.aliyun.com/document_detail/173616.html).'),
}

model ListQueryProcessorNersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueryProcessorNersResponseBody(name='body'),
}

/**
 * @summary Queries the recommended priority settings of entity types for named entity recognition (NER).
 *
 * @param request ListQueryProcessorNersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQueryProcessorNersResponse
 */
async function listQueryProcessorNersWithOptions(request: ListQueryProcessorNersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListQueryProcessorNersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.domain)) {
    query['domain'] = request.domain;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListQueryProcessorNers',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/query-processor/ner/default-priorities`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the recommended priority settings of entity types for named entity recognition (NER).
 *
 * @param request ListQueryProcessorNersRequest
 * @return ListQueryProcessorNersResponse
 */
async function listQueryProcessorNers(request: ListQueryProcessorNersRequest): ListQueryProcessorNersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listQueryProcessorNersWithOptions(request, headers, runtime);
}

model ListQueryProcessorsRequest {
  isActive?: int32(name='isActive', description='The scope of query analysis rules to be queried. Default value: 0. Valid values:

*   0: queries all query analysis rules.
*   1: queries the default query analysis rules.
*   2: queries the query analysis rules that are not the default rules.', example='0'),
}

model ListQueryProcessorsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      active?: boolean(name='active', description='Indicates whether the query analysis rule is a default rule.', example='true'),
      created?: int32(name='created', description='The time when the query analysis rule was created.', example='1587398402'),
      domain?: string(name='domain', description='The type of the industry to which the query analysis rule is applied. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='GENERAL'),
      indexes?: [ string ](name='indexes', description='The indexes to which the query analysis rule is applied.'),
      name?: string(name='name', description='The name of the query analysis rule.', example='ner'),
      processors?: [  map[string]any ](name='processors', description='The features that are used in the query analysis rule.'),
      updated?: int32(name='updated', description='The time when the query analysis rule was last modified.', example='1587398402'),
    }
  ](name='result', description='The information about the query analysis rule.

For more information, see [QueryProcessor](https://help.aliyun.com/document_detail/170014.html).'),
}

model ListQueryProcessorsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueryProcessorsResponseBody(name='body'),
}

/**
 * @summary Queries a list of query analysis rules that are configured for a version of an OpenSearch application.
 *
 * @param request ListQueryProcessorsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQueryProcessorsResponse
 */
async function listQueryProcessorsWithOptions(appGroupIdentity: string, appId: string, request: ListQueryProcessorsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListQueryProcessorsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.isActive)) {
    query['isActive'] = request.isActive;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListQueryProcessors',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/query-processors`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of query analysis rules that are configured for a version of an OpenSearch application.
 *
 * @param request ListQueryProcessorsRequest
 * @return ListQueryProcessorsResponse
 */
async function listQueryProcessors(appGroupIdentity: string, appId: string, request: ListQueryProcessorsRequest): ListQueryProcessorsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listQueryProcessorsWithOptions(appGroupIdentity, appId, request, headers, runtime);
}

model ListQuotaReviewTasksRequest {
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries to return on each page. Default value: 10.', example='10'),
}

model ListQuotaReviewTasksResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='"3351A21F-705B-508C-9450-DA65A681547F"'),
  result?: [ 
    {
      appGroupId?: int32(name='appGroupId', description='The application ID.', example='120123456'),
      appGroupName?: string(name='appGroupName', description='The application name.', example='"td_test_os"'),
      appGroupType?: string(name='appGroupType', description='The application type.', example='"standard"'),
      approved?: boolean(name='approved', description='Indicates whether the ticket is approved.', example='true'),
      available?: boolean(name='available', description='Indicates whether the application is available.', example='true'),
      gmtCreate?: string(name='gmtCreate', description='The time when the ticket was created.', example='"2020-04-08T08:29:45+0000"'),
      gmtModified?: string(name='gmtModified', description='The time when the ticket was last updated.', example='"2020-04-08T08:36:36+0000"'),
      id?: int32(name='id', description='The ticket ID.', example='142'),
      memo?: string(name='memo', description='The remarks.', example='null'),
      newComputeResource?: int32(name='newComputeResource', description='The computing resource quota that is applied for.', example='6000'),
      newSocSize?: int32(name='newSocSize', description='The storage capacity quota that is applied for.', example='1100'),
      newSpec?: string(name='newSpec', description='The application specifications that are applied for.', example='"opensearch.private.common"'),
      oldComputeResource?: int32(name='oldComputeResource', description='The original quota of computing resources.', example='500'),
      oldDocSize?: int32(name='oldDocSize', description='The original quota of storage capacity.', example='900'),
      oldSpec?: string(name='oldSpec', description='The original specifications of the application.', example='"opensearch.private.common"'),
      pending?: boolean(name='pending', description='Indicates whether the ticket is pending.', example='false'),
    }
  ](name='result', description='The information about the tickets. For more information, see [QuotaReviewTask](https://help.aliyun.com/document_detail/173609.html).', example='[]'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='500'),
}

model ListQuotaReviewTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQuotaReviewTasksResponseBody(name='body'),
}

/**
 * @summary Queries tickets that are submitted to apply for quotas for an OpenSearch application.
 *
 * @param request ListQuotaReviewTasksRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQuotaReviewTasksResponse
 */
async function listQuotaReviewTasksWithOptions(appGroupIdentity: string, request: ListQuotaReviewTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListQuotaReviewTasksResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListQuotaReviewTasks',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/quota-review-tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries tickets that are submitted to apply for quotas for an OpenSearch application.
 *
 * @param request ListQuotaReviewTasksRequest
 * @return ListQuotaReviewTasksResponse
 */
async function listQuotaReviewTasks(appGroupIdentity: string, request: ListQuotaReviewTasksRequest): ListQuotaReviewTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listQuotaReviewTasksWithOptions(appGroupIdentity, request, headers, runtime);
}

model ListScheduledTasksRequest {
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
  type?: string(name='type', description='The scheduled task type. Valid values:

*   wipe: data cleaning.
*   fork: reindexing.
*   check-status: application status check.
*   index: reindexing.', example='wipe'),
}

model ListScheduledTasksResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [  map[string]any ](name='result'),
  totalCount?: long(name='totalCount', description='The total number of entries returned.', example='1'),
}

model ListScheduledTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListScheduledTasksResponseBody(name='body'),
}

/**
 * @summary Queries a list of scheduled tasks of an OpenSearch application.
 *
 * @param request ListScheduledTasksRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListScheduledTasksResponse
 */
async function listScheduledTasksWithOptions(appGroupIdentity: string, request: ListScheduledTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListScheduledTasksResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListScheduledTasks',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scheduled-tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of scheduled tasks of an OpenSearch application.
 *
 * @param request ListScheduledTasksRequest
 * @return ListScheduledTasksResponse
 */
async function listScheduledTasks(appGroupIdentity: string, request: ListScheduledTasksRequest): ListScheduledTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listScheduledTasksWithOptions(appGroupIdentity, request, headers, runtime);
}

model ListSearchStrategiesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='9C6351F5-2E2E-5249-888B-88A74E1B8A65'),
}

model ListSearchStrategiesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSearchStrategiesResponseBody(name='body'),
}

/**
 * @summary Queries the details of query policies.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSearchStrategiesResponse
 */
async function listSearchStrategiesWithOptions(appGroupIdentity: string, appId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListSearchStrategiesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListSearchStrategies',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/search-strategies`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of query policies.
 *
 * @return ListSearchStrategiesResponse
 */
async function listSearchStrategies(appGroupIdentity: string, appId: string): ListSearchStrategiesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSearchStrategiesWithOptions(appGroupIdentity, appId, headers, runtime);
}

model ListSecondRanksResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='false'),
      created?: int32(name='created', description='The time when the expression was created.', example='0'),
      description?: string(name='description', description='The description of the expression.', example='""'),
      id?: string(name='id', description='The ID of the expression. This parameter appears only in the response.', example='890473'),
      isDefault?: string(name='isDefault', description='Indicates whether the expression is the default one. This parameter appears only in the response. Valid values:

*   true
*   false', example='false'),
      isSys?: string(name='isSys', description='Indicates whether the expression is a system expression. This parameter appears only in the response. Valid values:

*   true
*   false', example='true'),
      meta?: string(name='meta', description='The content of the fine sort expression.

You can define an expression that consists of fields, feature functions, and mathematical functions to implement complex sort logic.', example='random()+now()'),
      name?: string(name='name', description='The name of the expression.', example='tests'),
      updated?: int32(name='updated', description='The time when the expression was last updated.', example='1587052801'),
    }
  ](name='result', description='The information about each fine sort expression.

For more information, see [SecondRank](https://help.aliyun.com/document_detail/170008.html).'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='1'),
}

model ListSecondRanksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSecondRanksResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSecondRanksResponse
 */
async function listSecondRanksWithOptions(appGroupIdentity: string, appId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListSecondRanksResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListSecondRanks',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/second-ranks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return ListSecondRanksResponse
 */
async function listSecondRanks(appGroupIdentity: string, appId: string): ListSecondRanksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSecondRanksWithOptions(appGroupIdentity, appId, headers, runtime);
}

model ListSlowQueryCategoriesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='4406F40B-A0A2-9D5D-531F-3B6936567584'),
  result?: {
    analyzeStatus?: string(name='analyzeStatus', description='The status of the analysis. Valid values:

*   PENDING: preparing
*   SUCCESS: succeeded
*   RUNNING: running
*   FAILED: failed
*   N/A: unknown', example='"PENDING"'),
    end?: int32(name='end', description='The timestamp that indicates the end of the time range to query.', example='1589990340'),
    start?: int32(name='start', description='The timestamp that indicates the beginning of the time range to query.', example='1589986800'),
  }(name='result', description='The data returned.'),
}

model ListSlowQueryCategoriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSlowQueryCategoriesResponseBody(name='body'),
}

/**
 * @summary Queries the suggestions that are provided by Optimization Master for slow queries.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSlowQueryCategoriesResponse
 */
async function listSlowQueryCategoriesWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListSlowQueryCategoriesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListSlowQueryCategories',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/optimizers/slow-query/categories`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the suggestions that are provided by Optimization Master for slow queries.
 *
 * @return ListSlowQueryCategoriesResponse
 */
async function listSlowQueryCategories(appGroupIdentity: string): ListSlowQueryCategoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSlowQueryCategoriesWithOptions(appGroupIdentity, headers, runtime);
}

model ListSlowQueryQueriesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='EB250CA0-ACFD-C5DE-17CD-01445BFE8AE5'),
  result?: {
    appQuery?: string(name='appQuery', description='The content of the optimization suggestion for the query.', example='no data'),
    end?: int32(name='end', description='The end of the time range that was queried.', example='1589990340'),
    index?: int32(name='index', description='The ID of the optimization suggestion.', example='0'),
    start?: int32(name='start', description='The beginning of the time range that was queried.', example='1589986800'),
  }(name='result', description='The return result.'),
}

model ListSlowQueryQueriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSlowQueryQueriesResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSlowQueryQueriesResponse
 */
async function listSlowQueryQueriesWithOptions(appGroupIdentity: string, categoryIndex: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListSlowQueryQueriesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListSlowQueryQueries',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/optimizers/slow-query/categories/${OpenApiUtil.getEncodeParam(categoryIndex)}/queries`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return ListSlowQueryQueriesResponse
 */
async function listSlowQueryQueries(appGroupIdentity: string, categoryIndex: string): ListSlowQueryQueriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSlowQueryQueriesWithOptions(appGroupIdentity, categoryIndex, headers, runtime);
}

model ListSortExpressionsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ 
    {
      active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
      created?: int32(name='created', description='The timestamp when the sort expression was created.', example='1655793690'),
      description?: string(name='description', description='The description of the sort expression.', example='""'),
      name?: string(name='name', description='The name of the sort expression.', example='default'),
      updated?: int32(name='updated', description='The timestamp when the sort expression was updated.', example='1655793690'),
    }
  ](name='result', description='The information about the rough sort or fine sort expressions that are returned.

For more information, see [FirstRank](https://help.aliyun.com/document_detail/170007.html) and [SecondRank](https://help.aliyun.com/document_detail/170008.html).'),
}

model ListSortExpressionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSortExpressionsResponseBody(name='body'),
}

/**
 * @summary Queries a list of sort expressions that are configured for a version of an OpenSearch application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSortExpressionsResponse
 */
async function listSortExpressionsWithOptions(appGroupIdentity: string, appId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListSortExpressionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListSortExpressions',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/sort-expressions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of sort expressions that are configured for a version of an OpenSearch application.
 *
 * @return ListSortExpressionsResponse
 */
async function listSortExpressions(appGroupIdentity: string, appId: string): ListSortExpressionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSortExpressionsWithOptions(appGroupIdentity, appId, headers, runtime);
}

model ListSortScriptsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: [ 
    {
      createTime?: string(name='createTime', description='The time when the script was created.', example='2020-04-02 20:21:14'),
      modifyTime?: string(name='modifyTime', description='The time when the script was last modified.', example='2020-04-02 21:21:14'),
      scope?: string(name='scope', description='The sort phase to which the script applies.', example='second_rank'),
      scriptName?: string(name='scriptName', description='The name of the script.', example='test'),
      status?: string(name='status', description='The status of the script. Valid values:

*   configurable: The script is created, but no script files are uploaded.
*   not compiled: The script is not compiled.
*   compile failed: The compilation of the script failed.
*   compile successful: The script is compiled.
*   released: The script is published.', example='released'),
      type?: string(name='type', description='The type of the script.', example='cava_script'),
    }
  ](name='result', description='The scripts.'),
}

model ListSortScriptsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSortScriptsResponseBody(name='body'),
}

/**
 * @summary Queries all sort scripts of an application version.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSortScriptsResponse
 */
async function listSortScriptsWithOptions(appGroupIdentity: string, appVersionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListSortScriptsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListSortScripts',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appVersionId)}/sort-scripts`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all sort scripts of an application version.
 *
 * @return ListSortScriptsResponse
 */
async function listSortScripts(appGroupIdentity: string, appVersionId: string): ListSortScriptsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSortScriptsWithOptions(appGroupIdentity, appVersionId, headers, runtime);
}

model ListStatisticLogsRequest {
  columns?: string(name='columns', description='The fields to query. Format: columns=wordsTopPv.

For more information, see [Metrics in statistical reports](https://help.aliyun.com/document_detail/187665.html).', example='wordsTopPv'),
  distinct?: boolean(name='distinct', description='Specifies whether to use the distinct clause.', example='true'),
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
  query?: string(name='query', description='The content of the query clause.', example='"default:\\\\"OpenSearch\\\\""'),
  sortBy?: string(name='sortBy', description='The content of the sort clause.', example='"-id"'),
  startTime?: int32(name='startTime', description='The beginning of the time range to query. The default value is the timestamp of 00:00:00 on the current day.', example='1582214400'),
  stopTime?: int32(name='stopTime', description='The end of the time range to query. The default value is the timestamp of 24:00:00 on the current day.', example='1682222400'),
}

model ListStatisticLogsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='F76ACE3D-E510-EE2C-B7B1-39B3136A61EE'),
  result?: [  map[string]any ](name='result', description='The returned result. For more information, see

*   [Parameters of hotwords rankings](https://help.aliyun.com/document_detail/421248.html).', example='[]'),
  totalCount?: long(name='totalCount', description='The total number of entries returned.', example='1'),
}

model ListStatisticLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListStatisticLogsResponseBody(name='body'),
}

/**
 * @summary Queries log statistics, such as application error logs, hotword rankings, and slow query logs.
 *
 * @param request ListStatisticLogsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListStatisticLogsResponse
 */
async function listStatisticLogsWithOptions(appGroupIdentity: string, moduleName: string, request: ListStatisticLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListStatisticLogsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.columns)) {
    query['columns'] = request.columns;
  }
  if (!Util.isUnset(request.distinct)) {
    query['distinct'] = request.distinct;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['sortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.stopTime)) {
    query['stopTime'] = request.stopTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListStatisticLogs',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/statistic-logs/${OpenApiUtil.getEncodeParam(moduleName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries log statistics, such as application error logs, hotword rankings, and slow query logs.
 *
 * @param request ListStatisticLogsRequest
 * @return ListStatisticLogsResponse
 */
async function listStatisticLogs(appGroupIdentity: string, moduleName: string, request: ListStatisticLogsRequest): ListStatisticLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listStatisticLogsWithOptions(appGroupIdentity, moduleName, request, headers, runtime);
}

model ListStatisticReportRequest {
  columns?: string(name='columns', description='pv,uv', example='pv,uv'),
  endTime?: int32(name='endTime', description='1582646399', example='1582646399'),
  pageNumber?: int32(name='pageNumber', description='1', example='1'),
  pageSize?: int32(name='pageSize', description='10', example='10'),
  query?: string(name='query', description='bizType:test,sceneTag:myTag', example='bizType:test,sceneTag:myTag'),
  startTime?: int32(name='startTime', description='1582214400', example='1582214400'),
}

model ListStatisticReportResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='F65C8BB2-C14F-5983-888B-41C4E082D3BC'),
  result?: [  map[string]any ](name='result', description='The queried reports. Valid values:

For more information about the metrics in data quality reports, see the Upload behavioral data section of [Data collection 2.0](https://help.aliyun.com/document_detail/131547.html).

For more information about the metrics in application and A/B test reports, see the Core metrics section of [Metrics of statistical reports](https://help.aliyun.com/document_detail/187654.html).

For more information about the metrics in query analysis reports, see the Query analysis metrics section of [Metrics of statistical reports](https://help.aliyun.com/document_detail/187654.html).', example='[]'),
  totalCount?: long(name='totalCount', description='The total number of the queried reports.', example='43'),
}

model ListStatisticReportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListStatisticReportResponseBody(name='body'),
}

/**
 * @param request ListStatisticReportRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListStatisticReportResponse
 */
async function listStatisticReportWithOptions(appGroupIdentity: string, moduleName: string, request: ListStatisticReportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListStatisticReportResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.columns)) {
    query['columns'] = request.columns;
  }
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListStatisticReport',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/statistic-report/${OpenApiUtil.getEncodeParam(moduleName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListStatisticReportRequest
 * @return ListStatisticReportResponse
 */
async function listStatisticReport(appGroupIdentity: string, moduleName: string, request: ListStatisticReportRequest): ListStatisticReportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listStatisticReportWithOptions(appGroupIdentity, moduleName, request, headers, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='nextToken', description='The token that is used to retrieve the next page.', example='60'),
  resourceId?: [ string ](name='resourceId', description='The resource IDs. You can specify a maximum number of 50 resource IDs.'),
  resourceType?: string(name='resourceType', description='The resource type.

This parameter is required.', example='BIGDATA'),
  tag?: [ 
    {
      key?: string(name='key', description='The key of the tag.', example='bm'),
      value?: string(name='value', description='The value of the tag.', example='Uefi'),
    }
  ](name='tag', description='The tags. You can specify a maximum number of 20 tags.'),
}

model ListTagResourcesShrinkRequest {
  nextToken?: string(name='nextToken', description='The token that is used to retrieve the next page.', example='60'),
  resourceIdShrink?: string(name='resourceId', description='The resource IDs. You can specify a maximum number of 50 resource IDs.'),
  resourceType?: string(name='resourceType', description='The resource type.

This parameter is required.', example='BIGDATA'),
  tagShrink?: string(name='tag', description='The tags. You can specify a maximum number of 20 tags.'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='nextToken', description='The token that is used to retrieve the next page.', example='20'),
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ 
    {
      resourceId?: string(name='resourceId', description='The ID of the resource.', example='54041'),
      resourceType?: string(name='resourceType', description='The resource type.', example='hostGroup'),
      tagKey?: string(name='tagKey', description='The key of the tag.', example='GENIE_FUNCTION'),
      tagValue?: string(name='tagValue', description='The value of the tag.', example='ALLOW'),
    }
  ](name='result', description='The resources.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
 * @summary Queries tagged resources.
 *
 * @param tmpReq ListTagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
async function listTagResourcesWithOptions(tmpReq: ListTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceId)) {
    request.resourceIdShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceId, 'resourceId', 'json');
  }
  if (!Util.isUnset(tmpReq.tag)) {
    request.tagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tag, 'tag', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceIdShrink)) {
    query['resourceId'] = request.resourceIdShrink;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagShrink)) {
    query['tag'] = request.tagShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/resource-tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries tagged resources.
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

model ListUserAnalyzerEntriesRequest {
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
  word?: string(name='word', description='The key to be used to query entries.', example='kevintest'),
}

model ListUserAnalyzerEntriesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='516A02B7-2167-8D92-12D0-B639A2A0F3C5'),
  result?: map[string]any(name='result', description='The entries of the custom analyzer. For more information, see [UserAnalyzerEntry](https://www.alibabacloud.com/help/en/open-search/industry-algorithm-edition/useranalyzerentry).', example='[]'),
}

model ListUserAnalyzerEntriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserAnalyzerEntriesResponseBody(name='body'),
}

/**
 * @summary Queries the entries of a custom analyzer.
 *
 * @param request ListUserAnalyzerEntriesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUserAnalyzerEntriesResponse
 */
async function listUserAnalyzerEntriesWithOptions(name: string, request: ListUserAnalyzerEntriesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListUserAnalyzerEntriesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.word)) {
    query['word'] = request.word;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserAnalyzerEntries',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/user-analyzers/${OpenApiUtil.getEncodeParam(name)}/entries`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the entries of a custom analyzer.
 *
 * @param request ListUserAnalyzerEntriesRequest
 * @return ListUserAnalyzerEntriesResponse
 */
async function listUserAnalyzerEntries(name: string, request: ListUserAnalyzerEntriesRequest): ListUserAnalyzerEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUserAnalyzerEntriesWithOptions(name, request, headers, runtime);
}

model ListUserAnalyzersRequest {
  pageNumber?: int32(name='pageNumber', description='The number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries to return on each page. Default value: 10.', example='10'),
}

model ListUserAnalyzersResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      available?: boolean(name='available', description='Indicates whether the application is available.', example='false'),
      business?: string(name='business', description='The basic analyzer. Valid values:

*   chn_standard: [a common analyzer in Chinese](https://help.aliyun.com/document_detail/179424.html)
*   chn_scene_name: an analyzer for person names in Chinese
*   chn_ecommerce: [an analyzer for E-commerce in Chinese](https://help.aliyun.com/document_detail/179424.html)
*   chn_it_content: [an analyzer for IT content in Chinese](https://help.aliyun.com/document_detail/179424.html)
*   en_min: a small-granularity analyzer in English
*   th_standard: a common analyzer in Thai
*   th_ecommerce: an analyzer for E-commerce in Thai
*   vn_standard: a common analyzer in Vietnamese
*   chn_community_it: an analyzer for IT community content in Chinese
*   chn_ecommerce_general: a common analyzer for the E-commerce industry in Chinese
*   chn_esports_general: a common analyzer for the gaming industry in Chinese
*   chn_edu_question: an analyzer for question search of the education industry in Chinese', example='chn_standard'),
      created?: int32(name='created', description='The timestamp when the application was created.', example='1588054131'),
      dicts?: [ 
        {
          available?: boolean(name='available', description='Indicates whether the application is available.', example='false'),
          created?: int32(name='created', description='The timestamp when the application was created.', example='1588054131'),
          entriesCount?: int32(name='entriesCount', description='The number of intervention entries.', example='-1'),
          entriesLimit?: int32(name='entriesLimit', description='The maximum number of intervention entries that can be created in the dictionary.', example='4'),
          id?: string(name='id', description='The ID of the dictionary.', example='123'),
          type?: string(name='type', description='The type. Valid value:

*   segment', example='segment'),
          updated?: int32(name='updated', description='The timestamp when the application was last updated.', example='1588054131'),
        }
      ](name='dicts', description='The dictionaries that are used by the custom analyzer.

For more information, see [UserDict](https://help.aliyun.com/document_detail/178933.html).'),
      id?: string(name='id', description='The ID of the custom analyzer.', example='1234'),
      name?: string(name='name', description='The name of the custom analyzer.', example='kevin_test2'),
      updated?: int32(name='updated', description='The timestamp when the application was last updated.', example='1588054131'),
    }
  ](name='result', description='The custom analyzer.

For more information, see [UserAnalyzer](https://help.aliyun.com/document_detail/178934.html).'),
  totalCount?: int32(name='totalCount', description='The total number.', example='1'),
}

model ListUserAnalyzersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserAnalyzersResponseBody(name='body'),
}

/**
 * @summary Queries the custom analyzers that belong to the current account.
 *
 * @param request ListUserAnalyzersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUserAnalyzersResponse
 */
async function listUserAnalyzersWithOptions(request: ListUserAnalyzersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListUserAnalyzersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserAnalyzers',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/user-analyzers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the custom analyzers that belong to the current account.
 *
 * @param request ListUserAnalyzersRequest
 * @return ListUserAnalyzersResponse
 */
async function listUserAnalyzers(request: ListUserAnalyzersRequest): ListUserAnalyzersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUserAnalyzersWithOptions(request, headers, runtime);
}

model ModifyAppGroupRequest {
  currentVersion?: string(name='currentVersion', description='The online version of the application.', example='1223232'),
  description?: string(name='description', description='The description of the application.', example='"test"'),
  domain?: string(name='domain', description='The type of the industry. Valid values:

*   general: general.
*   ecommerce: e-commerce.
*   education: education.
*   esports: electronic sports.
*   community: content community.', example='"ecommerce"'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-****'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to verify the application before modification. Valid values: true and false.', example='true'),
}

model ModifyAppGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    chargeType?: string(name='chargeType', description='The billing method. Valid values:

*   POSTPAY: pay-as-you-go.
*   PREPAY: subscription.', example='POSTPAY'),
    chargingWay?: int32(name='chargingWay', description='The billable item. Valid values:

*   1: computing resources.
*   2: QPS.', example='1'),
    commodityCode?: string(name='commodityCode', description='The code of the commodity.', example='opensearch'),
    created?: int32(name='created', description='The timestamp when the application was created.', example='1590139524'),
    currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='100302903'),
    description?: string(name='description', description='The description of the application.', example='1'),
    domain?: string(name='domain', description='The type of the industry. Valid values:

*   GENERAL: general.
*   ECOMMERCE: e-commerce.
*   IT_CONTENT: IT content.', example='GENERAL'),
    engineType?: string(name='engineType'),
    expireOn?: string(name='expireOn', description='The time when the application expired.', example='1'),
    hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval status of the quotas. Valid values:

*   0: normal.
*   1: being approved.', example='0'),
    id?: string(name='id', description='The application ID.', example='100302881'),
    instanceId?: string(name='instanceId', description='The instance ID.', example='10030288'),
    lockMode?: string(name='lockMode', description='The lock status. Valid values:

*   Unlock: The instance is unlocked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
    name?: string(name='name', description='The name of the application.', example='lsh_test_1'),
    produced?: int32(name='produced', description='Indicates whether the order is complete. Valid values:

*   0: The order is in progress.
*   1: The order is complete.', example='1'),
    projectId?: string(name='projectId', description='The name of the A/B test group.', example='1'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing unit (LCU).', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
      spec?: string(name='spec', description='The specifications. Valid values:

*   opensearch.share.junior: basic.
*   opensearch.share.common: shared general-purpose.
*   opensearch.share.compute: shared computing.
*   opensearch.share.storage: shared storage.
*   opensearch.private.common: exclusive general-purpose.
*   opensearch.private.compute: exclusive computing.
*   opensearch.private.storage: exclusive storage.', example='opensearch.share.common'),
    }(name='quota', description='The information about the quotas of the application.', example='{}'),
    resourceGroupId?: string(name='resourceGroupId'),
    status?: string(name='status', description='The state of the application. Valid values:

*   producing: being produced.
*   review_pending: being approved.
*   config_pending: to be configured.
*   normal: normal.
*   frozen: frozen.', example='normal'),
    switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='1590486386'),
    type?: string(name='type', description='The type of the application. Valid values:

*   standard: a standard edition application.
*   advance: an advanced edition application of an old version. New versions are not supported for this edition.
*   enhanced: an advanced edition application of a new version.', example='enhanced'),
    updated?: int32(name='updated', description='The timestamp when the application was last modified.', example='1590978265'),
  }(name='result', description='The returned data.', example='{}'),
}

model ModifyAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAppGroupResponseBody(name='body'),
}

/**
 * @summary Modifies the properties of an OpenSearch application or sets the online version of an OpenSearch application.
 *
 * @param request ModifyAppGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAppGroupResponse
 */
async function modifyAppGroupWithOptions(appGroupIdentity: string, request: ModifyAppGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyAppGroupResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.currentVersion)) {
    body['currentVersion'] = request.currentVersion;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.domain)) {
    body['domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAppGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the properties of an OpenSearch application or sets the online version of an OpenSearch application.
 *
 * @param request ModifyAppGroupRequest
 * @return ModifyAppGroupResponse
 */
async function modifyAppGroup(appGroupIdentity: string, request: ModifyAppGroupRequest): ModifyAppGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyAppGroupWithOptions(appGroupIdentity, request, headers, runtime);
}

model ModifyAppGroupQuotaRequest {
  body?: Quota(name='body', description='The request body.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to verify the application before modification. Valid values: true and false.', example='false'),
}

model ModifyAppGroupQuotaResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    chargeType?: string(name='chargeType', description='The billing method of the application. Valid values:

*   POSTPAY: pay-as-you-go
*   PREPAY: subscription', example='POSTPAY'),
    chargingWay?: int32(name='chargingWay', description='The billing model. Valid values:

*   1: computing resources
*   2: queries per second (QPS)', example='1'),
    commodityCode?: string(name='commodityCode', description='The code of the commodity.', example='opensearch'),
    created?: int32(name='created', description='The timestamp when the application was created.', example='1590139542'),
    currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='100302903'),
    description?: string(name='description', description='The description of the application.', example='1'),
    engineType?: string(name='engineType'),
    expireOn?: string(name='expireOn', description='The expiration time.', example='1'),
    hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval status of the quotas. Valid values:

*   0: The quotas are approved.
*   1: The quotas are being approved.', example='0'),
    id?: string(name='id', description='The ID of the application.', example='100302881'),
    instanceId?: string(name='instanceId', description='The ID of the instance.', example='1'),
    lockMode?: string(name='lockMode', description='The lock mode of the instance. Valid values:

*   Unlock: The instance is not locked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
    name?: string(name='name', description='The name of the application.', example='lsh_test_1'),
    produced?: int32(name='produced', description='Indicates whether the order is complete. Valid values:

*   0: The order is in progress.
*   1: The order is complete.', example='1'),
    projectId?: string(name='projectId', description='The name of the A/B test group.', example='1000'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing units (LCUs).', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
      spec?: string(name='spec', description='The specifications of the application. Valid values:

*   opensearch.share.junior: basic
*   opensearch.share.common: shared general-purpose
*   opensearch.share.compute: shared computing
*   opensearch.share.storage: shared storage
*   opensearch.private.common: exclusive general-purpose
*   opensearch.private.compute: exclusive computing
*   opensearch.private.storage: exclusive storage', example='opensearch.share.common'),
    }(name='quota', description='The information about the quotas of the application.'),
    resourceGroupId?: string(name='resourceGroupId'),
    status?: string(name='status', description='The status of the application. Valid values:

*   producing
*   review_pending
*   config_pending
*   normal
*   frozen', example='normal'),
    switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='1590486386'),
    type?: string(name='type', description='The type of the application. Valid values:

*   standard: a standard application.
*   advance: an advanced application which is of an old application type. New applications cannot be of this type.
*   enhanced: an advanced application which is of a new application type.', example='enhanced'),
    updated?: int32(name='updated', description='The timestamp when the application was last updated.', example='1590978265'),
  }(name='result', description='The information about the application.'),
}

model ModifyAppGroupQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAppGroupQuotaResponseBody(name='body'),
}

/**
 * @param request ModifyAppGroupQuotaRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAppGroupQuotaResponse
 */
async function modifyAppGroupQuotaWithOptions(appGroupIdentity: string, request: ModifyAppGroupQuotaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyAppGroupQuotaResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAppGroupQuota',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/quota`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ModifyAppGroupQuotaRequest
 * @return ModifyAppGroupQuotaResponse
 */
async function modifyAppGroupQuota(appGroupIdentity: string, request: ModifyAppGroupQuotaRequest): ModifyAppGroupQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyAppGroupQuotaWithOptions(appGroupIdentity, request, headers, runtime);
}

model ModifyFirstRankRequest {
  body?: FirstRank(name='body', description='The request body.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether the request is a dry run.', example='true'),
}

model ModifyFirstRankResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
    description?: string(name='description', description='The description of the rough sort expression.', example='1'),
    meta?: [ 
      {
        arg?: string(name='arg', description='The parameters that are used by a function in the expression.', example='“1 ”'),
        attribute?: string(name='attribute', description='The attribute, feature function, or field to be searched for.', example='static_bm25()'),
        weight?: float(name='weight', description='The weight. Valid values: -100000 to 100000. The value cannot be 0.', example='10'),
      }
    ](name='meta', description='The information about the expression.'),
    name?: string(name='name', description='The name of the expression.', example='default'),
  }(name='result', description='The information about the rough sort expression.'),
}

model ModifyFirstRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyFirstRankResponseBody(name='body'),
}

/**
 * @summary Modifies a rough sort expression for an OpenSearch application. If you set dryRun to true, this operation checks the rough sort expression after the expression is modified. If you do not specify this parameter, false is used by default.
 *
 * @param request ModifyFirstRankRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyFirstRankResponse
 */
async function modifyFirstRankWithOptions(appGroupIdentity: string, appId: string, name: string, request: ModifyFirstRankRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyFirstRankResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyFirstRank',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/first-ranks/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a rough sort expression for an OpenSearch application. If you set dryRun to true, this operation checks the rough sort expression after the expression is modified. If you do not specify this parameter, false is used by default.
 *
 * @param request ModifyFirstRankRequest
 * @return ModifyFirstRankResponse
 */
async function modifyFirstRank(appGroupIdentity: string, appId: string, name: string, request: ModifyFirstRankRequest): ModifyFirstRankResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyFirstRankWithOptions(appGroupIdentity, appId, name, request, headers, runtime);
}

model ModifyQueryProcessorRequest {
  body?: any(name='body', description='The request parameters.', example='{
    "domain": "GENERAL",
    "category": "",
    "processors": [
        {
            "name": "synonym",
            "useSystemDictionary": true
        },
        {
            "name": "stop_word",
            "useSystemDictionary": true
        }
    ]
}'),
  dryRun?: boolean(name='dryRun', description='Specifies whether the request is a dry run.', example='true'),
}

model ModifyQueryProcessorResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the query analysis rule is a default rule.', example='true'),
    created?: int32(name='created', description='The time when the rule was created.', example='0'),
    domain?: string(name='domain', description='The type of the industry to which the query analysis rule is applied. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='GENERAL'),
    indexes?: [ string ](name='indexes', description='The indexes to which the query analysis rule is applied.', example='["default"]'),
    name?: string(name='name', description='The name of the query analysis rule.', example='synonym'),
    processors?: [  map[string]any ](name='processors', description='The analysis rule.', example='[]'),
    updated?: int32(name='updated', description='The time when the rule was updated.', example='1'),
  }(name='result', description='The information about the query analysis rule.', example='{}'),
}

model ModifyQueryProcessorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyQueryProcessorResponseBody(name='body'),
}

/**
 * @summary Modifies a query analysis rule for a specific application version. If you set dryRun to true, this operation checks the specified query analysis rule. By default, the value of dryRun is false if you do not specify this parameter.
 *
 * @param request ModifyQueryProcessorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyQueryProcessorResponse
 */
async function modifyQueryProcessorWithOptions(appGroupIdentity: string, appId: string, name: string, request: ModifyQueryProcessorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyQueryProcessorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ModifyQueryProcessor',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/query-processors/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a query analysis rule for a specific application version. If you set dryRun to true, this operation checks the specified query analysis rule. By default, the value of dryRun is false if you do not specify this parameter.
 *
 * @param request ModifyQueryProcessorRequest
 * @return ModifyQueryProcessorResponse
 */
async function modifyQueryProcessor(appGroupIdentity: string, appId: string, name: string, request: ModifyQueryProcessorRequest): ModifyQueryProcessorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyQueryProcessorWithOptions(appGroupIdentity, appId, name, request, headers, runtime);
}

model ModifyScheduledTaskRequest {
  body?: any(name='body', description='The request parameters.', example='The request parameters.'),
}

model ModifyScheduledTaskResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: map[string]any(name='result', description='The information about the scheduled task.', example='Array'),
}

model ModifyScheduledTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyScheduledTaskResponseBody(name='body'),
}

/**
 * @summary Modifies a scheduled task.
 *
 * @param request ModifyScheduledTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyScheduledTaskResponse
 */
async function modifyScheduledTaskWithOptions(appGroupIdentity: string, taskId: string, request: ModifyScheduledTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyScheduledTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ModifyScheduledTask',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scheduled-tasks/${OpenApiUtil.getEncodeParam(taskId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a scheduled task.
 *
 * @param request ModifyScheduledTaskRequest
 * @return ModifyScheduledTaskResponse
 */
async function modifyScheduledTask(appGroupIdentity: string, taskId: string, request: ModifyScheduledTaskRequest): ModifyScheduledTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyScheduledTaskWithOptions(appGroupIdentity, taskId, request, headers, runtime);
}

model ModifySecondRankRequest {
  body?: SecondRank(name='body', description='The request parameters.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether the request is a dry run.', example='true'),
}

model ModifySecondRankResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='C5E2F73C-8241-81F8-3A62-65478C5A3111'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
    created?: int32(name='created', description='The time when the expression was created.', example='1'),
    description?: string(name='description', description='The description of the expression.', example='"11"'),
    id?: string(name='id', description='The expression ID. This parameter is displayed only in the response.', example='890473'),
    isDefault?: string(name='isDefault', description='Indicates whether the expression is the default one. This parameter is displayed only in the response. Valid values:

*   true: the expression is the default one.
*   false: the expression is not the default one.', example='true'),
    isSys?: string(name='isSys', description='Indicates whether the expression is a system expression. This parameter is displayed only in the response. Valid values:

*   true: The expression is a system expression.
*   false:The expression is not a system expression', example='false'),
    meta?: string(name='meta', description='The content of the fine sort expression. You can define an expression that consists of fields, feature functions, and mathematical functions to implement complex sort logic.', example='cate_id > 0 and cate_id < 1000'),
    name?: string(name='name', description='The expression name.', example='lsh_second_1'),
    updated?: int32(name='updated', description='The time when the expression was updated.', example='1'),
  }(name='result', description='The information about the fine sort expression.', example='{}'),
}

model ModifySecondRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySecondRankResponseBody(name='body'),
}

/**
 * @summary Modifies a fine sort expression that is configured for a specific OpenSearch application version. If you set dryRun to true, the specified fine sort expression is checked after the expression is modified. By default, the value of dryRun is false if you do not specify this parameter.
 *
 * @param request ModifySecondRankRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySecondRankResponse
 */
async function modifySecondRankWithOptions(appGroupIdentity: string, appId: string, name: string, request: ModifySecondRankRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifySecondRankResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ModifySecondRank',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/second-ranks/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a fine sort expression that is configured for a specific OpenSearch application version. If you set dryRun to true, the specified fine sort expression is checked after the expression is modified. By default, the value of dryRun is false if you do not specify this parameter.
 *
 * @param request ModifySecondRankRequest
 * @return ModifySecondRankResponse
 */
async function modifySecondRank(appGroupIdentity: string, appId: string, name: string, request: ModifySecondRankRequest): ModifySecondRankResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifySecondRankWithOptions(appGroupIdentity, appId, name, request, headers, runtime);
}

model PushInterventionDictionaryEntriesRequest {
  body?: [  map[string]any ](name='body', description='The request body.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to check the validity of input parameters. Default value: false.

Valid values:

*   **true**: checks only the validity of input parameters.
*   **false**: checks the validity of input parameters and creates an attribution configuration.', example='false'),
}

model PushInterventionDictionaryEntriesResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ string ](name='result', description='The returned results.'),
}

model PushInterventionDictionaryEntriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushInterventionDictionaryEntriesResponseBody(name='body'),
}

/**
 * @summary Accepts the changes in intervention entries.
 *
 * @param request PushInterventionDictionaryEntriesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushInterventionDictionaryEntriesResponse
 */
async function pushInterventionDictionaryEntriesWithOptions(name: string, request: PushInterventionDictionaryEntriesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PushInterventionDictionaryEntriesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PushInterventionDictionaryEntries',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/intervention-dictionaries/${OpenApiUtil.getEncodeParam(name)}/entries/actions/bulk`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Accepts the changes in intervention entries.
 *
 * @param request PushInterventionDictionaryEntriesRequest
 * @return PushInterventionDictionaryEntriesResponse
 */
async function pushInterventionDictionaryEntries(name: string, request: PushInterventionDictionaryEntriesRequest): PushInterventionDictionaryEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return pushInterventionDictionaryEntriesWithOptions(name, request, headers, runtime);
}

model PushUserAnalyzerEntriesRequest {
  entries?: [ 
    {
      cmd?: string(name='cmd', description='The operation to be performed on the entries.

Valid values:

*   add
*   delete', example='"add"'),
      key?: string(name='key', description='The key to be used to query entries.', example='"testvalue"'),
      splitEnabled?: boolean(name='splitEnabled', description='Specifies whether to further analyze the terms that are generated after the search query is analyzed.

Default value: true.', example='true'),
      value?: string(name='value', description='The analysis result.', example='"test value"'),
    }
  ](name='entries', description='The entries of the custom analyzer.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run. This parameter is only used to check whether the data source is valid. Valid values: true and false.', example='true'),
}

model PushUserAnalyzerEntriesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: map[string]any(name='result', description='The result returned.', example='{}'),
}

model PushUserAnalyzerEntriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushUserAnalyzerEntriesResponseBody(name='body'),
}

/**
 * @summary Accepts the changes in the entries of a custom analyzer.
 *
 * @param request PushUserAnalyzerEntriesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushUserAnalyzerEntriesResponse
 */
async function pushUserAnalyzerEntriesWithOptions(name: string, request: PushUserAnalyzerEntriesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PushUserAnalyzerEntriesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.entries)) {
    body['entries'] = request.entries;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PushUserAnalyzerEntries',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/user-analyzers/${OpenApiUtil.getEncodeParam(name)}/entries/actions/bulk`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Accepts the changes in the entries of a custom analyzer.
 *
 * @param request PushUserAnalyzerEntriesRequest
 * @return PushUserAnalyzerEntriesResponse
 */
async function pushUserAnalyzerEntries(name: string, request: PushUserAnalyzerEntriesRequest): PushUserAnalyzerEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return pushUserAnalyzerEntriesWithOptions(name, request, headers, runtime);
}

model ReleaseSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
}

model ReleaseSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleaseSortScriptResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseSortScriptResponse
 */
async function releaseSortScriptWithOptions(appGroupIdentity: string, scriptName: string, appVersionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ReleaseSortScriptResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ReleaseSortScript',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appVersionId)}/sort-scripts/${OpenApiUtil.getEncodeParam(scriptName)}/actions/release`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return ReleaseSortScriptResponse
 */
async function releaseSortScript(appGroupIdentity: string, scriptName: string, appVersionId: string): ReleaseSortScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return releaseSortScriptWithOptions(appGroupIdentity, scriptName, appVersionId, headers, runtime);
}

model RemoveAppResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='33477D76-C380-2D84-A4AD-043F52876CB1'),
  result?: [ int32 ](name='result', description='The return result.'),
}

model RemoveAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveAppResponseBody(name='body'),
}

/**
 * @summary Deletes a version of an OpenSearch application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveAppResponse
 */
async function removeAppWithOptions(appGroupIdentity: string, appId: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveAppResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveApp',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a version of an OpenSearch application.
 *
 * @return RemoveAppResponse
 */
async function removeApp(appGroupIdentity: string, appId: string): RemoveAppResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeAppWithOptions(appGroupIdentity, appId, headers, runtime);
}

model RemoveAppGroupResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='3AA29D02-54F3-8569-F71A-90E1B7BE4E7E'),
  result?: [ int32 ](name='result', description='N/A'),
}

model RemoveAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveAppGroupResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveAppGroupResponse
 */
async function removeAppGroupWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveAppGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveAppGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return RemoveAppGroupResponse
 */
async function removeAppGroup(appGroupIdentity: string): RemoveAppGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeAppGroupWithOptions(appGroupIdentity, headers, runtime);
}

model RemoveDataCollectionResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: string(name='result', description='—', example='{}'),
}

model RemoveDataCollectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveDataCollectionResponseBody(name='body'),
}

/**
 * @summary Disables data collection.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveDataCollectionResponse
 */
async function removeDataCollectionWithOptions(appGroupIdentity: string, dataCollectionIdentity: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveDataCollectionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveDataCollection',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/data-collections/${OpenApiUtil.getEncodeParam(dataCollectionIdentity)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disables data collection.
 *
 * @return RemoveDataCollectionResponse
 */
async function removeDataCollection(appGroupIdentity: string, dataCollectionIdentity: string): RemoveDataCollectionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeDataCollectionWithOptions(appGroupIdentity, dataCollectionIdentity, headers, runtime);
}

model RemoveFirstRankResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='E676FAB6-A0AC-64D9-F9D7-D0D33C930CFF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
    description?: string(name='description', description='The description of the expression.', example='""'),
    meta?: [ 
      {
        arg?: string(name='arg', description='The parameters that are used by a function in the expression.

For more information, see Rough sort functions.', example='""'),
        attribute?: string(name='attribute', description='The attribute, feature function, or field to be searched for.

For more information about supported feature functions, see Rough sort functions.', example='static_bm25()'),
        weight?: float(name='weight', description='The weight.

Valid values: [-100000,100000] (excluding 0).', example='10'),
      }
    ](name='meta', description='The content of the expression.'),
    name?: string(name='name', description='The name of the expression.', example='default'),
  }(name='result', description='The information about the rough sort expression.'),
}

model RemoveFirstRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveFirstRankResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveFirstRankResponse
 */
async function removeFirstRankWithOptions(appGroupIdentity: string, appId: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveFirstRankResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveFirstRank',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/first-ranks/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return RemoveFirstRankResponse
 */
async function removeFirstRank(appGroupIdentity: string, appId: string, name: string): RemoveFirstRankResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeFirstRankWithOptions(appGroupIdentity, appId, name, headers, runtime);
}

model RemoveInterventionDictionaryResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='06BBD41A-5F72-34E4-2DAF-E43B0526051D'),
  result?: {
    analyzer?: string(name='analyzer', description='The custom analyzer.', example='""'),
    created?: string(name='created', description='The time when the intervention dictionary was created.', example='1539158313'),
    name?: string(name='name', description='The name of the intervention dictionary.', example='tongyici'),
    type?: string(name='type', description='The type of the intervention dictionary. Valid values:

*   stopword: an intervention dictionary for stop word filtering
*   synonym: an intervention dictionary for synonym configuration
*   correction: an intervention dictionary for spelling correction
*   category_prediction: an intervention dictionary for category prediction
*   ner: an intervention dictionary for named entity recognition (NER)
*   term_weighting: an intervention dictionary for term weight analysis', example='synonym'),
    updated?: string(name='updated', description='The time when the intervention dictionary was last updated.', example='1539158313'),
  }(name='result', description='The information about the intervention dictionary.'),
}

model RemoveInterventionDictionaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveInterventionDictionaryResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveInterventionDictionaryResponse
 */
async function removeInterventionDictionaryWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveInterventionDictionaryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveInterventionDictionary',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/intervention-dictionaries/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return RemoveInterventionDictionaryResponse
 */
async function removeInterventionDictionary(name: string): RemoveInterventionDictionaryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeInterventionDictionaryWithOptions(name, headers, runtime);
}

model RemoveQueryProcessorResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: string(name='result', description='N/A', example='[]'),
}

model RemoveQueryProcessorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveQueryProcessorResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveQueryProcessorResponse
 */
async function removeQueryProcessorWithOptions(appGroupIdentity: string, appId: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveQueryProcessorResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveQueryProcessor',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/query-processors/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return RemoveQueryProcessorResponse
 */
async function removeQueryProcessor(appGroupIdentity: string, appId: string, name: string): RemoveQueryProcessorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeQueryProcessorWithOptions(appGroupIdentity, appId, name, headers, runtime);
}

model RemoveScheduledTaskResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ int32 ](name='result', description='N/A'),
}

model RemoveScheduledTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveScheduledTaskResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveScheduledTaskResponse
 */
async function removeScheduledTaskWithOptions(appGroupIdentity: string, taskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveScheduledTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveScheduledTask',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scheduled-tasks/${OpenApiUtil.getEncodeParam(taskId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return RemoveScheduledTaskResponse
 */
async function removeScheduledTask(appGroupIdentity: string, taskId: string): RemoveScheduledTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeScheduledTaskWithOptions(appGroupIdentity, taskId, headers, runtime);
}

model RemoveSearchStrategyResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='F5099063-6B86-F398-D843-905F9EFB683A'),
}

model RemoveSearchStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveSearchStrategyResponseBody(name='body'),
}

/**
 * @summary Deletes a query policy.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveSearchStrategyResponse
 */
async function removeSearchStrategyWithOptions(appGroupIdentity: string, appId: string, strategyName: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveSearchStrategyResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveSearchStrategy',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/search-strategies/${OpenApiUtil.getEncodeParam(strategyName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a query policy.
 *
 * @return RemoveSearchStrategyResponse
 */
async function removeSearchStrategy(appGroupIdentity: string, appId: string, strategyName: string): RemoveSearchStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeSearchStrategyWithOptions(appGroupIdentity, appId, strategyName, headers, runtime);
}

model RemoveSecondRankResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: map[string]any(name='result', description='N/A', example='{}'),
}

model RemoveSecondRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveSecondRankResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveSecondRankResponse
 */
async function removeSecondRankWithOptions(appGroupIdentity: string, appId: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveSecondRankResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveSecondRank',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/second-ranks/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return RemoveSecondRankResponse
 */
async function removeSecondRank(appGroupIdentity: string, appId: string, name: string): RemoveSecondRankResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeSecondRankWithOptions(appGroupIdentity, appId, name, headers, runtime);
}

model RemoveUserAnalyzerResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: map[string]any(name='result', description='N/A', example='[]'),
}

model RemoveUserAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveUserAnalyzerResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveUserAnalyzerResponse
 */
async function removeUserAnalyzerWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveUserAnalyzerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveUserAnalyzer',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/user-analyzers/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return RemoveUserAnalyzerResponse
 */
async function removeUserAnalyzer(name: string): RemoveUserAnalyzerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeUserAnalyzerWithOptions(name, headers, runtime);
}

model RenewAppGroupRequest {
  body?: PrepayOrderInfo(name='body', description='The renewal request body.'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request.', example='74db41d8cd3c784209093aa76afbe89e'),
}

model RenewAppGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: boolean(name='result', description='Indicates whether the application was renewed.', example='true'),
}

model RenewAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenewAppGroupResponseBody(name='body'),
}

/**
 * @summary Renews an application. This operation is not available now. You must renew an application in the OpenSearch console.
 *
 * @param request RenewAppGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RenewAppGroupResponse
 */
async function renewAppGroupWithOptions(appGroupIdentity: string, request: RenewAppGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenewAppGroupResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'RenewAppGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/actions/renew`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Renews an application. This operation is not available now. You must renew an application in the OpenSearch console.
 *
 * @param request RenewAppGroupRequest
 * @return RenewAppGroupResponse
 */
async function renewAppGroup(appGroupIdentity: string, request: RenewAppGroupRequest): RenewAppGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renewAppGroupWithOptions(appGroupIdentity, request, headers, runtime);
}

model ReplaceAppGroupCommodityCodeResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='AC5F78BA-66B9-545B-9CF1-8F542E682E1F'),
  result?: {
    chargeType?: string(name='chargeType', description='The billing method. Valid values:

*   POSTPAY: pay-as-you-go.
*   PREPAY: subscription.', example='POSTPAY'),
    chargingWay?: int32(name='chargingWay', description='The billing type. Valid values:

*   1: computing resources.
*   2: queries per second (QPS).', example='1'),
    commodityCode?: string(name='commodityCode', description='The code of the commodity.', example='opensearch'),
    created?: int32(name='created', description='The timestamp when the application was created.', example='1588054131'),
    currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='100302903'),
    description?: string(name='description', description='The description of the application.', example='""'),
    expireOn?: string(name='expireOn', description='The expiration time.', example='-'),
    firstRankAlgoDeploymentId?: int32(name='firstRankAlgoDeploymentId', description='The ID of the rough sort expression.', example='0'),
    hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval state of the quotas. Valid values:

*   0: The approval status is normal.
*   1: The quotas are being approved.', example='0'),
    id?: string(name='id', description='The application ID.', example='-'),
    instanceId?: string(name='instanceId', description='The instance ID.', example='-'),
    lockMode?: string(name='lockMode', description='The lock state. Valid values:

*   Unlock: The instance is unlocked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
    lockedByExpiration?: int32(name='lockedByExpiration', description='Indicates whether the instance is automatically locked after it expires. Valid values:

*   0: The instance is not automatically locked after it expires.
*   1: The instance is automatically locked after it expires.', example='0'),
    name?: string(name='name', description='The name of the order.', example='-'),
    pendingSecondRankAlgoDeploymentId?: int32(name='pendingSecondRankAlgoDeploymentId', description='The ID of the fine sort expression that is being created.', example='0'),
    processingOrderId?: string(name='processingOrderId', description='The ID of the order that is in progress.', example='-'),
    produced?: int32(name='produced', description='Indicates whether the order is produced.', example='0'),
    projectId?: string(name='projectId', description='The name of the A/B test group.', example='-'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The number of computing resources configured.', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity.', example='1'),
      spec?: string(name='spec', description='The specifications configured.', example='-'),
    }(name='quota', description='The configuration information.'),
    secondRankAlgoDeploymentId?: int32(name='secondRankAlgoDeploymentId', description='The ID of the fine sort expression.', example='0'),
    status?: string(name='status', description='The status of the application.', example='normal'),
    switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='1590486386'),
    type?: string(name='type', description='The type of the application.', example='-'),
    updated?: int32(name='updated', description='The timestamp when the application was updated.', example='1581065904'),
    versions?: [ string ](name='versions', description='The versions.'),
  }(name='result', description='The returned result.', example='{}'),
}

model ReplaceAppGroupCommodityCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReplaceAppGroupCommodityCodeResponseBody(name='body'),
}

/**
 * @summary Converts a service-based application to an instance-based application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReplaceAppGroupCommodityCodeResponse
 */
async function replaceAppGroupCommodityCodeWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: Util.RuntimeOptions): ReplaceAppGroupCommodityCodeResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ReplaceAppGroupCommodityCode',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/actions/to-instance-typed`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Converts a service-based application to an instance-based application.
 *
 * @return ReplaceAppGroupCommodityCodeResponse
 */
async function replaceAppGroupCommodityCode(appGroupIdentity: string): ReplaceAppGroupCommodityCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return replaceAppGroupCommodityCodeWithOptions(appGroupIdentity, headers, runtime);
}

model SaveSortScriptFileRequest {
  content?: string(name='content', description='The script content that is encoded in the Base64 format.', example='4769#0: *28194492991 a client request body is buffered to a temporary file /usr/local/webserver/openresty/nginx/client_body_temp/0000624474,'),
  version?: int32(name='version', description='The version number of the script content.', example='2022-12-01'),
}

model SaveSortScriptFileResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
}

model SaveSortScriptFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SaveSortScriptFileResponseBody(name='body'),
}

/**
 * @summary Uploads a sort script.
 *
 * @param request SaveSortScriptFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveSortScriptFileResponse
 */
async function saveSortScriptFileWithOptions(appGroupIdentity: string, scriptName: string, appVersionId: string, fileName: string, request: SaveSortScriptFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SaveSortScriptFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }
  if (!Util.isUnset(request.version)) {
    body['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SaveSortScriptFile',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appVersionId)}/sort-scripts/${OpenApiUtil.getEncodeParam(scriptName)}/files/src/${OpenApiUtil.getEncodeParam(fileName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Uploads a sort script.
 *
 * @param request SaveSortScriptFileRequest
 * @return SaveSortScriptFileResponse
 */
async function saveSortScriptFile(appGroupIdentity: string, scriptName: string, appVersionId: string, fileName: string, request: SaveSortScriptFileRequest): SaveSortScriptFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return saveSortScriptFileWithOptions(appGroupIdentity, scriptName, appVersionId, fileName, request, headers, runtime);
}

model StartSlowQueryAnalyzerResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: map[string]any(name='result', description='N/A', example='{}'),
}

model StartSlowQueryAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartSlowQueryAnalyzerResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartSlowQueryAnalyzerResponse
 */
async function startSlowQueryAnalyzerWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartSlowQueryAnalyzerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartSlowQueryAnalyzer',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/optimizers/slow-query/actions/run`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return StartSlowQueryAnalyzerResponse
 */
async function startSlowQueryAnalyzer(appGroupIdentity: string): StartSlowQueryAnalyzerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startSlowQueryAnalyzerWithOptions(appGroupIdentity, headers, runtime);
}

model TagResourcesRequest {
  resourceId?: [ string ](name='resourceId', description='The resource IDs. You can specify a maximum number of 50 resource IDs.

This parameter is required.'),
  resourceType?: string(name='resourceType', description='The resource type.

This parameter is required.', example='ProductVersion'),
  tag?: [ 
    {
      key?: string(name='key', description='The key of the tag.', example='cloud_manage'),
      value?: string(name='value', description='The value of the tag.', example='31261301'),
    }
  ](name='tag', description='The tags. You can specify a maximum number of 20 tags.

This parameter is required.'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
 * @summary Adds tags to resources.
 *
 * @param request TagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
async function tagResourcesWithOptions(request: TagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.resourceId)) {
    body['resourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    body['tag'] = request.tag;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/resource-tags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds tags to resources.
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(request, headers, runtime);
}

model UnbindESUserAnalyzerRequest {
  body?: any(name='body', description='The request parameters.', example='{
  "name": "kevintest-analyzer"
}'),
}

model UnbindESUserAnalyzerResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: map[string]any(name='result', description='The custom analyzer.', example='[]'),
}

model UnbindESUserAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindESUserAnalyzerResponseBody(name='body'),
}

/**
 * @summary Unbinds a custom analyzer from an Elasticsearch instance.
 *
 * @description You can call this operation to unbind a custom analyzer from an Elasticsearch instance.
 *
 * @param request UnbindESUserAnalyzerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnbindESUserAnalyzerResponse
 */
async function unbindESUserAnalyzerWithOptions(appGroupIdentity: string, esInstanceId: string, request: UnbindESUserAnalyzerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UnbindESUserAnalyzerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UnbindESUserAnalyzer',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/es/${OpenApiUtil.getEncodeParam(esInstanceId)}/actions/unbind-analyzer`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Unbinds a custom analyzer from an Elasticsearch instance.
 *
 * @description You can call this operation to unbind a custom analyzer from an Elasticsearch instance.
 *
 * @param request UnbindESUserAnalyzerRequest
 * @return UnbindESUserAnalyzerResponse
 */
async function unbindESUserAnalyzer(appGroupIdentity: string, esInstanceId: string, request: UnbindESUserAnalyzerRequest): UnbindESUserAnalyzerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unbindESUserAnalyzerWithOptions(appGroupIdentity, esInstanceId, request, headers, runtime);
}

model UnbindEsInstanceResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: map[string]any(name='result', description='The data returned.', example='{}'),
}

model UnbindEsInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindEsInstanceResponseBody(name='body'),
}

/**
 * @summary Unbinds an Elasticsearch instance from an OpenSearch application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnbindEsInstanceResponse
 */
async function unbindEsInstanceWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: Util.RuntimeOptions): UnbindEsInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UnbindEsInstance',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/actions/unbind-es-instance`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Unbinds an Elasticsearch instance from an OpenSearch application.
 *
 * @return UnbindEsInstanceResponse
 */
async function unbindEsInstance(appGroupIdentity: string): UnbindEsInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unbindEsInstanceWithOptions(appGroupIdentity, headers, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='all', description='Specifies whether to remove all tags from the specified one or more resources. This parameter takes effect only if the tagKey parameter is not specified. Valid values: true and false. Default value: false.', example='true'),
  resourceId?: [ string ](name='resourceId', description='The resource IDs. You can specify a maximum number of 50 IDs.

This parameter is required.'),
  resourceType?: string(name='resourceType', description='The resource type.

This parameter is required.', example='ProductVersion'),
  tagKey?: [ string ](name='tagKey', description='The keys of tags. You can specify a maximum number of 20 keys.'),
}

model UntagResourcesShrinkRequest {
  all?: boolean(name='all', description='Specifies whether to remove all tags from the specified one or more resources. This parameter takes effect only if the tagKey parameter is not specified. Valid values: true and false. Default value: false.', example='true'),
  resourceIdShrink?: string(name='resourceId', description='The resource IDs. You can specify a maximum number of 50 IDs.

This parameter is required.'),
  resourceType?: string(name='resourceType', description='The resource type.

This parameter is required.', example='ProductVersion'),
  tagKeyShrink?: string(name='tagKey', description='The keys of tags. You can specify a maximum number of 20 keys.'),
}

model UntagResourcesResponseBody = {
  tequestId?: string(name='tequestId', description='The ID of the request.', example='1-A-0-B'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
 * @summary Remove tags from resources.
 *
 * @param tmpReq UntagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesResponse
 */
async function untagResourcesWithOptions(tmpReq: UntagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new UntagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceId)) {
    request.resourceIdShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceId, 'resourceId', 'json');
  }
  if (!Util.isUnset(tmpReq.tagKey)) {
    request.tagKeyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tagKey, 'tagKey', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    query['all'] = request.all;
  }
  if (!Util.isUnset(request.resourceIdShrink)) {
    query['resourceId'] = request.resourceIdShrink;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKeyShrink)) {
    query['tagKey'] = request.tagKeyShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/resource-tags`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Remove tags from resources.
 *
 * @param request UntagResourcesRequest
 * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourcesWithOptions(request, headers, runtime);
}

model UpdateABTestExperimentRequest {
  body?: ABTestExperiment(name='body', description='The request body. For more information, see [ABTestExperiment](https://help.aliyun.com/document_detail/173617.html).'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   true: performs only a dry run. No endpoint is created. The system checks whether your AccessKey is valid, whether Resource Access Management (RAM) users are authorized, and whether the required parameters are set.
*   false (default): creates an endpoint immediately.', example='true'),
}

model UpdateABTestExperimentResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test was created.', example='1588842080'),
    id?: string(name='id', description='The test ID.', example='12888'),
    name?: string(name='name', description='The alias of the test.', example='test1'),
    online?: boolean(name='online', description='Indicates whether the test is in effect. Valid values:

*   true
*   false', example='true'),
    params?: map[string]any(name='params', description='The test parameters.', example='{}'),
    traffic?: int32(name='traffic', description='The percentage of traffic that is routed to the test. Valid values: [0,100]', example='30'),
    updated?: int32(name='updated', description='The time when the test was last modified.', example='1588842080'),
  }(name='result', description='The details of the test.'),
}

model UpdateABTestExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateABTestExperimentResponseBody(name='body'),
}

/**
 * @summary Modifies the parameters of an A/B test.
 *
 * @param request UpdateABTestExperimentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateABTestExperimentResponse
 */
async function updateABTestExperimentWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string, request: UpdateABTestExperimentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateABTestExperimentResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateABTestExperiment',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scenes/${OpenApiUtil.getEncodeParam(sceneId)}/groups/${OpenApiUtil.getEncodeParam(groupId)}/experiments/${OpenApiUtil.getEncodeParam(experimentId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the parameters of an A/B test.
 *
 * @param request UpdateABTestExperimentRequest
 * @return UpdateABTestExperimentResponse
 */
async function updateABTestExperiment(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string, request: UpdateABTestExperimentRequest): UpdateABTestExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateABTestExperimentWithOptions(appGroupIdentity, sceneId, groupId, experimentId, request, headers, runtime);
}

model UpdateABTestFixedFlowDividersRequest {
  body?: [ string ](name='body', description='The request body.'),
}

model UpdateABTestFixedFlowDividersResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ string ](name='result', description='The returned results.'),
}

model UpdateABTestFixedFlowDividersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateABTestFixedFlowDividersResponseBody(name='body'),
}

/**
 * @summary Modifies whitelists.
 *
 * @param request UpdateABTestFixedFlowDividersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateABTestFixedFlowDividersResponse
 */
async function updateABTestFixedFlowDividersWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string, request: UpdateABTestFixedFlowDividersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateABTestFixedFlowDividersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateABTestFixedFlowDividers',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scenes/${OpenApiUtil.getEncodeParam(sceneId)}/groups/${OpenApiUtil.getEncodeParam(groupId)}/experiments/${OpenApiUtil.getEncodeParam(experimentId)}/fixed-flow-dividers`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies whitelists.
 *
 * @param request UpdateABTestFixedFlowDividersRequest
 * @return UpdateABTestFixedFlowDividersResponse
 */
async function updateABTestFixedFlowDividers(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string, request: UpdateABTestFixedFlowDividersRequest): UpdateABTestFixedFlowDividersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateABTestFixedFlowDividersWithOptions(appGroupIdentity, sceneId, groupId, experimentId, request, headers, runtime);
}

model UpdateABTestGroupRequest {
  body?: ABTestGroup(name='body', description='The request body. For more information, see [ABTestGroup](https://help.aliyun.com/document_detail/178935.html).'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   true: performs only a dry run. No endpoint is created. The system checks whether your AccessKey is valid, whether Resource Access Management (RAM) users are authorized, and whether the required parameters are set.
*   false (default): creates an endpoint immediately.', example='true'),
}

model UpdateABTestGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='\\\\"\\\\"1111\\\\"\\\\"'),
  result?: {
    created?: int32(name='created', description='The time when the test group was created.', example='1588839490'),
    id?: string(name='id', description='The ID of the test group.', example='13466'),
    name?: string(name='name', description='The alias of the test group.', example='Group_2020-5-7_15:23:3'),
    status?: int32(name='status', description='The status of the test group. Valid values:

*   0: not in effect
*   1: in effect', example='1'),
    updated?: int32(name='updated', description='The time when the test group was last updated.', example='1588839490'),
  }(name='result', description='The details of the test group.'),
}

model UpdateABTestGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateABTestGroupResponseBody(name='body'),
}

/**
 * @summary Modifies a test group.
 *
 * @param request UpdateABTestGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateABTestGroupResponse
 */
async function updateABTestGroupWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, request: UpdateABTestGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateABTestGroupResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateABTestGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scenes/${OpenApiUtil.getEncodeParam(sceneId)}/groups/${OpenApiUtil.getEncodeParam(groupId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a test group.
 *
 * @param request UpdateABTestGroupRequest
 * @return UpdateABTestGroupResponse
 */
async function updateABTestGroup(appGroupIdentity: string, sceneId: string, groupId: string, request: UpdateABTestGroupRequest): UpdateABTestGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateABTestGroupWithOptions(appGroupIdentity, sceneId, groupId, request, headers, runtime);
}

model UpdateABTestSceneRequest {
  body?: ABTestScene(name='body', description='The request body.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run. This parameter is only used to check whether the data source is valid. Valid values: true and false.', example='true'),
}

model UpdateABTestSceneResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test scenario was created.', example='1596527691'),
    id?: string(name='id', description='The ID of the test scenario.', example='20614'),
    name?: string(name='name', description='The name of the test scenario.', example='kevintest22'),
    online?: boolean(name='online', description='The status of the test. Valid values:

*   true: The test is started.
*   false: The test is stopped.', example='true'),
    params?: map[string]any(name='params', description='The parameters of the A/B test.', example='{}'),
    traffic?: int32(name='traffic', description='The percentage of traffic that is allocated to the A/B test. Valid values: 0 to 100.', example='111'),
    updated?: int32(name='updated', description='The time when the test scenario was last modified.', example='1596527691'),
  }(name='result', description='The details of the test scenario. For more information, see [ABTestScene](https://help.aliyun.com/document_detail/173618.html).', example='{}'),
}

model UpdateABTestSceneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateABTestSceneResponseBody(name='body'),
}

/**
 * @summary Modifies an A/B test scenario.
 *
 * @param request UpdateABTestSceneRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateABTestSceneResponse
 */
async function updateABTestSceneWithOptions(appGroupIdentity: string, sceneId: string, request: UpdateABTestSceneRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateABTestSceneResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateABTestScene',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/scenes/${OpenApiUtil.getEncodeParam(sceneId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies an A/B test scenario.
 *
 * @param request UpdateABTestSceneRequest
 * @return UpdateABTestSceneResponse
 */
async function updateABTestScene(appGroupIdentity: string, sceneId: string, request: UpdateABTestSceneRequest): UpdateABTestSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateABTestSceneWithOptions(appGroupIdentity, sceneId, request, headers, runtime);
}

model UpdateFetchFieldsRequest {
  body?: [ string ](name='body', description='The request body.'),
  dryRun?: boolean(name='dryRun', description='true', example='true'),
}

model UpdateFetchFieldsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: boolean(name='result', description='Indicates whether the operation was successful.', example='true'),
}

model UpdateFetchFieldsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFetchFieldsResponseBody(name='body'),
}

/**
 * @param request UpdateFetchFieldsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFetchFieldsResponse
 */
async function updateFetchFieldsWithOptions(appGroupIdentity: string, appId: string, request: UpdateFetchFieldsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFetchFieldsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateFetchFields',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/fetch-fields`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateFetchFieldsRequest
 * @return UpdateFetchFieldsResponse
 */
async function updateFetchFields(appGroupIdentity: string, appId: string, request: UpdateFetchFieldsRequest): UpdateFetchFieldsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFetchFieldsWithOptions(appGroupIdentity, appId, request, headers, runtime);
}

model UpdateFunctionDefaultInstanceRequest {
  instanceName?: string(name='instanceName', description='The name of the instance.', example='"pop_test"'),
}

model UpdateFunctionDefaultInstanceResponseBody = {
  code?: string(name='Code', description='The error code.', example='DefaultInstance.SetFail'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A4D487A9-A456-5AA5-A9C6-B7BF2889CF74'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model UpdateFunctionDefaultInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFunctionDefaultInstanceResponseBody(name='body'),
}

/**
 * @summary Sets the default algorithm instance used by the specified application. The new algorithm instance automatically overwrites the most recently set default instance. If no instance is set, the default instance is canceled.
 *
 * @param request UpdateFunctionDefaultInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFunctionDefaultInstanceResponse
 */
async function updateFunctionDefaultInstanceWithOptions(appGroupIdentity: string, functionName: string, request: UpdateFunctionDefaultInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFunctionDefaultInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceName)) {
    body['instanceName'] = request.instanceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFunctionDefaultInstance',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/default-instance`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Sets the default algorithm instance used by the specified application. The new algorithm instance automatically overwrites the most recently set default instance. If no instance is set, the default instance is canceled.
 *
 * @param request UpdateFunctionDefaultInstanceRequest
 * @return UpdateFunctionDefaultInstanceResponse
 */
async function updateFunctionDefaultInstance(appGroupIdentity: string, functionName: string, request: UpdateFunctionDefaultInstanceRequest): UpdateFunctionDefaultInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFunctionDefaultInstanceWithOptions(appGroupIdentity, functionName, request, headers, runtime);
}

model UpdateFunctionInstanceRequest {
  createParameters?: [ 
    {
      name?: string(name='name', description='The name of the parameter.', example='title_field'),
      value?: string(name='value', description='The value of the parameter.', example='title'),
    }
  ](name='createParameters', description='The parameters that are used to create the instance.', example='{             "name": "title_field",             "value": "title"         }'),
  cron?: string(name='cron', description='The cron expression used to schedule periodic training, in the format of (Minutes Hours DayofMonth Month DayofWeek). The default value is empty, which indicates that no periodic training is performed. DayofWeek 0 indicates Sunday.', example='"0 3 ? * 0,1,3,5"'),
  description?: string(name='description', description='The description of the instance.', example='test instance'),
  usageParameters?: [ 
    {
      name?: string(name='name', description='The name of the parameter.', example='allow_dict_id'),
      value?: string(name='value', description='The value of the parameter.', example='123'),
    }
  ](name='usageParameters', description='The parameters that are used.'),
}

model UpdateFunctionInstanceResponseBody = {
  code?: string(name='Code', description='The error code.', example='"Instance.NotExist"'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='10'),
  message?: string(name='Message', description='The error message.', example='"instance not exist."'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='"3A809095-C554-5CF5-8FCE-BE19D4673790"'),
  status?: string(name='Status', description='The status of the request. Valid values:

*       OK: The request was successful.
*       FAIL: The request failed.', example='OK'),
}

model UpdateFunctionInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFunctionInstanceResponseBody(name='body'),
}

/**
 * @summary Updates an algorithm instance.
 *
 * @param request UpdateFunctionInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFunctionInstanceResponse
 */
async function updateFunctionInstanceWithOptions(appGroupIdentity: string, functionName: string, instanceName: string, request: UpdateFunctionInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFunctionInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.createParameters)) {
    body['createParameters'] = request.createParameters;
  }
  if (!Util.isUnset(request.cron)) {
    body['cron'] = request.cron;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.usageParameters)) {
    body['usageParameters'] = request.usageParameters;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFunctionInstance',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/instances/${OpenApiUtil.getEncodeParam(instanceName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates an algorithm instance.
 *
 * @param request UpdateFunctionInstanceRequest
 * @return UpdateFunctionInstanceResponse
 */
async function updateFunctionInstance(appGroupIdentity: string, functionName: string, instanceName: string, request: UpdateFunctionInstanceRequest): UpdateFunctionInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFunctionInstanceWithOptions(appGroupIdentity, functionName, instanceName, request, headers, runtime);
}

model UpdateFunctionResourceRequest {
  data?: {
    content?: string(name='Content', description='The content of the file that corresponds to a resource of the raw_file type.', example='abc'),
    generators?: [ 
      {
        generator?: string(name='Generator', description='The type of the feature generator.', example='combo'),
        input?: {
          features?: [ 
            {
              name?: string(name='Name', description='The name of the feature.', example='system_item_id'),
              type?: string(name='Type', description='The type of the feature.', example='item'),
            }
          ](name='Features', description='The input features.'),
        }(name='Input', description='The input.'),
        output?: string(name='Output', description='The name of the output feature.', example='feature1'),
      }
    ](name='Generators', description='The feature generators that correspond to resources of the feature_generator type.'),
  }(name='Data', description='The resource data. The data structure varies with the resource type.'),
  description?: string(name='Description', description='The description of the resource.', example='updated description'),
}

model UpdateFunctionResourceResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, this parameter is left empty.', example='InvalidRequest'),
  httpCode?: long(name='HttpCode', description='The HTTP status code returned.', example='200'),
  latency?: double(name='Latency', description='The time consumed for the request. Unit: milliseconds.', example='123'),
  message?: string(name='Message', description='The error message returned.', example='Invalid request.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7E375703-5B12-5466-8B48-C4D01AE1291A'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model UpdateFunctionResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFunctionResourceResponseBody(name='body'),
}

/**
 * @summary Updates an algorithm resource.
 *
 * @description You can call this operation to update the information about resources by resource name. You can modify only the values of data and description.
 *
 * @param request UpdateFunctionResourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFunctionResourceResponse
 */
async function updateFunctionResourceWithOptions(appGroupIdentity: string, functionName: string, resourceName: string, request: UpdateFunctionResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFunctionResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.data)) {
    body['Data'] = request.data;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFunctionResource',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/resources/${OpenApiUtil.getEncodeParam(resourceName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates an algorithm resource.
 *
 * @description You can call this operation to update the information about resources by resource name. You can modify only the values of data and description.
 *
 * @param request UpdateFunctionResourceRequest
 * @return UpdateFunctionResourceResponse
 */
async function updateFunctionResource(appGroupIdentity: string, functionName: string, resourceName: string, request: UpdateFunctionResourceRequest): UpdateFunctionResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFunctionResourceWithOptions(appGroupIdentity, functionName, resourceName, request, headers, runtime);
}

model UpdateSearchStrategyRequest {
  body?: SearchStrategy(name='body', description='The request body.'),
}

model UpdateSearchStrategyResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
}

model UpdateSearchStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSearchStrategyResponseBody(name='body'),
}

/**
 * @summary Modifies a query policy.
 *
 * @param request UpdateSearchStrategyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSearchStrategyResponse
 */
async function updateSearchStrategyWithOptions(appGroupIdentity: string, appId: string, strategyName: string, request: UpdateSearchStrategyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSearchStrategyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSearchStrategy',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/search-strategies/${OpenApiUtil.getEncodeParam(strategyName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a query policy.
 *
 * @param request UpdateSearchStrategyRequest
 * @return UpdateSearchStrategyResponse
 */
async function updateSearchStrategy(appGroupIdentity: string, appId: string, strategyName: string, request: UpdateSearchStrategyRequest): UpdateSearchStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSearchStrategyWithOptions(appGroupIdentity, appId, strategyName, request, headers, runtime);
}

model UpdateSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='9F165784-5507-5342-ABF3-545293F9808A'),
}

model UpdateSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSortScriptResponseBody(name='body'),
}

/**
 * @summary Modifies the description of a sort script.
 *
 * @description You can call this operation to modify the description of a sort script.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSortScriptResponse
 */
async function updateSortScriptWithOptions(appGroupIdentity: string, appVersionId: string, scriptName: string, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSortScriptResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UpdateSortScript',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appVersionId)}/sort-scripts/${OpenApiUtil.getEncodeParam(scriptName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the description of a sort script.
 *
 * @description You can call this operation to modify the description of a sort script.
 *
 * @return UpdateSortScriptResponse
 */
async function updateSortScript(appGroupIdentity: string, appVersionId: string, scriptName: string): UpdateSortScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSortScriptWithOptions(appGroupIdentity, appVersionId, scriptName, headers, runtime);
}

model UpdateSummariesRequest {
  body?: [ 
    {
      element?: string(name='element', description='The HTML tag that is used to highlight terms in red.', example='"em"'),
      ellipsis?: string(name='ellipsis', description='The connector that is used to connect segments.', example='"..."'),
      field?: string(name='field', description='The field.', example='"title"'),
      len?: int32(name='len', description='The length of a segment.', example='50'),
      snippet?: int32(name='snippet', description='The number of segments.', example='1'),
    }
  ](name='body', description='The request body.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether the request is a dry run.', example='true'),
}

model UpdateSummariesResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='7A389E09-7964-5A2B-FE9D-F6CFA7162852'),
  result?: boolean(name='result', description='Indicates whether the request was successful.', example='true'),
}

model UpdateSummariesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSummariesResponseBody(name='body'),
}

/**
 * @summary Updates summaries. A dry run is supported.
 *
 * @param request UpdateSummariesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSummariesResponse
 */
async function updateSummariesWithOptions(appGroupIdentity: string, appId: string, request: UpdateSummariesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSummariesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSummaries',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${OpenApiUtil.getEncodeParam(appGroupIdentity)}/apps/${OpenApiUtil.getEncodeParam(appId)}/summaries`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates summaries. A dry run is supported.
 *
 * @param request UpdateSummariesRequest
 * @return UpdateSummariesResponse
 */
async function updateSummaries(appGroupIdentity: string, appId: string, request: UpdateSummariesRequest): UpdateSummariesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSummariesWithOptions(appGroupIdentity, appId, request, headers, runtime);
}

model ValidateDataSourcesRequest {
  body?: DataSource(name='body', description='The request parameter. For more information, see [DataSource](https://help.aliyun.com/document_detail/170005.html).'),
}

model ValidateDataSourcesResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='8FA2B338-AFDC-46B4-A132-B5487820C2BF'),
  result?: [ 
    {
      code?: string(name='code', description='The code returned for the request.', example='SUCCEED'),
      dataSource?: {
        parameters?: map[string]any(name='parameters', description='The parameters of the data source.', example='{}'),
        tableName?: string(name='tableName', description='The name of the table.', example='user_activity_decision'),
        type?: string(name='type', description='The type of the data source.', example='rds'),
      }(name='dataSource', description='The data source.', example='{}'),
      message?: string(name='message', description='The status of the execution.', example='successful'),
    }
  ](name='result', description='The result returned.', example='[]'),
}

model ValidateDataSourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ValidateDataSourcesResponseBody(name='body'),
}

/**
 * @summary Verifies data sources.
 *
 * @param request ValidateDataSourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ValidateDataSourcesResponse
 */
async function validateDataSourcesWithOptions(request: ValidateDataSourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateDataSourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ValidateDataSources',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/assist/data-sources/validations`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Verifies data sources.
 *
 * @param request ValidateDataSourcesRequest
 * @return ValidateDataSourcesResponse
 */
async function validateDataSources(request: ValidateDataSourcesRequest): ValidateDataSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateDataSourcesWithOptions(request, headers, runtime);
}

