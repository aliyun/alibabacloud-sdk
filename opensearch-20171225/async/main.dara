/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'OpenSearch';
  @version = '2017-12-25';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model ABTestExperiment {
  name?: string(name='name'),
  online?: boolean(name='online'),
  params?: map[string]string(name='params'),
  serialNumber?: int32(name='serialNumber'),
  traffic?: int32(name='traffic'),
}

model ABTestGroup {
  name?: string(name='name'),
  status?: int32(name='status'),
}

model ABTestScene {
  name?: string(name='name'),
  status?: int32(name='status', example='0 停止实验 1 开通实验'),
  values?: [ string ](name='values'),
}

model App {
  autoSwitch?: boolean(name='autoSwitch'),
  cluster?: {
    maxQueryClauseLength?: int32(name='maxQueryClauseLength'),
    maxTimeoutMS?: int32(name='maxTimeoutMS'),
  }(name='cluster'),
  dataSources?: [
    DataSource
  ](name='dataSources'),
  description?: string(name='description'),
  domain?: Domain(name='domain'),
  fetchFields?: [ string ](name='fetchFields'),
  firstRanks?: [
    FirstRank
  ](name='firstRanks'),
  networkType?: string(name='networkType'),
  queryProcessors?: [
    QueryProcessor
  ](name='queryProcessors'),
  quota?: Quota(name='quota'),
  realtimeShared?: boolean(name='realtimeShared'),
  schema?: Schema(name='schema'),
  schemas?: [
    Schema
  ](name='schemas'),
  secondRanks?: [
    SecondRank
  ](name='secondRanks'),
  summaries?: [
    Summary
  ](name='summaries'),
  type?: string(name='type'),
}

model AppGroup {
  chargeType?: string(name='chargeType'),
  description?: string(name='description'),
  domain?: string(name='domain'),
  name?: string(name='name'),
  order?: {
    autoRenew?: boolean(name='autoRenew', example='false'),
    duration?: long(name='duration', example='1'),
    pricingCycle?: string(name='pricingCycle', example='Month'),
  }(name='order'),
  quota?: Quota(name='quota'),
  resourceGroupId?: string(name='resourceGroupId'),
  type?: string(name='type'),
}

model DataSource {
  fields?: [ map[string]string ](name='fields'),
  keyField?: string(name='keyField'),
  parameters?: map[string]any(name='parameters'),
  plugins?: map[string]DataSourcePluginsValue(name='plugins'),
  schemaName?: string(name='schemaName'),
  tableName?: string(name='tableName'),
  type?: string(name='type'),
}

model Domain {
  category?: string(name='category'),
  functions?: map[string][ string ](name='functions'),
  name?: string(name='name'),
}

model FirstRank {
  active?: boolean(name='active'),
  description?: string(name='description'),
  meta?: any(name='meta'),
  name?: string(name='name'),
  type?: string(name='type'),
}

model PrepayOrderInfo {
  autoRenew?: boolean(name='autoRenew'),
  duration?: int32(name='duration'),
  pricingCycle?: string(name='pricingCycle'),
}

model QueryProcessor {
  active?: boolean(name='active'),
  category?: string(name='category'),
  domain?: string(name='domain'),
  indexes?: [ string ](name='indexes'),
  name?: string(name='name'),
  processors?: [  map[string]any ](name='processors'),
}

model Quota {
  computeResource?: int32(name='computeResource'),
  docSize?: int32(name='docSize'),
  orderType?: string(name='orderType'),
  spec?: string(name='spec'),
}

model ScheduledTask {
  autoSwitch?: boolean(name='autoSwitch'),
  cron?: string(name='cron'),
  enabled?: boolean(name='enabled'),
  filter?: {
    days?: int32(name='days'),
    expression?: string(name='expression'),
    field?: string(name='field'),
    unit?: string(name='unit'),
  }(name='filter'),
  forkedAppId?: string(name='forkedAppId'),
  permanent?: boolean(name='permanent'),
  runNow?: boolean(name='runNow'),
  type?: string(name='type'),
  version?: string(name='version'),
}

model Schema {
  indexSortConfig?: [ 
    {
      direction?: string(name='direction'),
      field?: string(name='field'),
    }
  ](name='indexSortConfig'),
  indexes?: {
    filterFields?: [ string ](name='filterFields'),
    searchFields?: map[string]SchemaIndexesSearchFieldsValue(name='searchFields'),
  }(name='indexes'),
  name?: string(name='name'),
  routeField?: string(name='routeField'),
  routeFieldValues?: [ string ](name='routeFieldValues'),
  secondRouteField?: string(name='secondRouteField'),
  tables?: map[string]SchemaTablesValue(name='tables'),
  ttlField?: {
    name?: string(name='name'),
    ttl?: long(name='ttl'),
  }(name='ttlField'),
}

model SearchStrategy {
  description?: string(name='description'),
  isDefault?: boolean(name='isDefault'),
  mergeConfig?: {
    docCount?: int32(name='docCount'),
    rankName?: string(name='rankName'),
  }(name='mergeConfig'),
  name?: string(name='name'),
  searchConfigs?: [ 
    {
      firstRankName?: string(name='firstRankName'),
      mergeProportion?: int32(name='mergeProportion'),
      queryType?: string(name='queryType', example='keyword: 关键字查询 vector: 向量查询'),
      secondRankName?: string(name='secondRankName'),
    }
  ](name='searchConfigs'),
}

model SecondRank {
  active?: boolean(name='active'),
  description?: string(name='description'),
  meta?: any(name='meta'),
  name?: string(name='name'),
}

model Summary {
  active?: boolean(name='active'),
  meta?: {
    element?: string(name='element'),
    ellipsis?: string(name='ellipsis'),
    field?: string(name='field'),
    len?: int32(name='len'),
    snippet?: string(name='snippet'),
  }(name='meta'),
  name?: string(name='name'),
}

model BindESUserAnalyzerRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='130187460', position='Path'),
  esInstanceId: string(name='esInstanceId', description='The ID of the instance.', example='es-cn-zvp2g952l000v5uxp', position='Path'),
  body?: any(name='body', description='The request parameters.', example='{
  "name": "kevintest-analyzer"
}', position='Body'),
}

model BindESUserAnalyzerResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='3AD34CAD-9603-5251-AFF5-3916C848A1D3'),
  result?: map[string]any(name='result', description='The custom analyzer.', example='[]'),
}

model BindESUserAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindESUserAnalyzerResponseBody(name='body'),
}

async function bindESUserAnalyzer(request: BindESUserAnalyzerRequest): BindESUserAnalyzerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BindESUserAnalyzer', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/es/{esInstanceId}/actions/bind-analyzer', 'json', false, 'json', request);
}

model BindEsInstanceRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='my_app_group_name', position='Path'),
  body?: map[string]any(name='body', description='The body of the request.', example='{
  "esInstanceId": "es-cn-abcde"
}', position='Body'),
}

model BindEsInstanceResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='F5099063-6B86-F398-D843-905F9EFB683A'),
  result?: map[string]any(name='result', description='The result', example='[]'),
}

model BindEsInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindEsInstanceResponseBody(name='body'),
}

async function bindEsInstance(request: BindEsInstanceRequest): BindEsInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BindEsInstance', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/actions/bind-es-instance', 'json', false, 'json', request);
}

model CompileSortScriptRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='search', example='search', position='Path'),
  scriptName: string(name='scriptName', description='script', example='script', position='Path'),
  appVersionId?: string(name='appVersionId', description='1234567', example='130196473', position='Path'),
}

model CompileSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
}

model CompileSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CompileSortScriptResponseBody(name='body'),
}

async function compileSortScript(request: CompileSortScriptRequest): CompileSortScriptResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CompileSortScript', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appVersionId}/sort-scripts/{scriptName}/actions/compiling', 'json', false, 'json', request);
}

model CreateABTestExperimentRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application name.', example='my_app_group_name', position='Path'),
  sceneId: int32(name='sceneId', description='The scenario ID.', example='20404', minimum=-1, maximum=999999999, position='Path'),
  groupId: int32(name='groupId', description='The group ID.', example='13467', minimum=-1, maximum=999999999, position='Path'),
  body?: ABTestExperiment(name='body', description='The request body.', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run. This parameter is only used to check whether the data source is valid. Valid values: true and false.', example='false', position='Query'),
}

model CreateABTestExperimentResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the experiment was created.', example='0'),
    id?: string(name='id', description='The experiment ID.', example='12889'),
    name?: string(name='name', description='The experiment alias.', example='test3'),
    online?: boolean(name='online', description='Indicates whether the experiment is in effect. Valid values:

*   true
*   false', example='true'),
    params?: map[string]any(name='params', description='The experiment parameters.', example='{"firstFormulaName": "default"}'),
    traffic?: int32(name='traffic', description='The percentage of traffic that is routed to the experiment.', example='30'),
    updated?: int32(name='updated', description='The time when the experiment was last modified.', example='1589017861'),
  }(name='result', description='The experiment details.'),
}

model CreateABTestExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateABTestExperimentResponseBody(name='body'),
}

async function createABTestExperiment(request: CreateABTestExperimentRequest): CreateABTestExperimentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateABTestExperiment', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/scenes/{sceneId}/groups/{groupId}/experiments', 'json', false, 'json', request);
}

model CreateABTestGroupRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='my_app_group_name', position='Path'),
  sceneId?: int32(name='sceneId', description='The scenario ID.', example='20404', minimum=-1, maximum=999999999, position='Path'),
  body?: ABTestGroup(name='body', description='The request body. For more information, see [ABTestGroup](~~178935~~).', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to check the validity of input parameters. Default value: false.

Valid values:

*   **true**: checks only the validity of input parameters.
*   **false**: checks the validity of input parameters and creates an attribution configuration.', example='true', position='Query'),
}

model CreateABTestGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test group was created.', example='1588839490'),
    id?: string(name='id', description='The ID of the test group.', example='13466'),
    name?: string(name='name', description='The alias of the test group.', example='Group_2020-5-7_15:23:3'),
    status?: int32(name='status', description='The status of the test group.

*   0: not in effect
*   1: in effect', example='1'),
    updated?: int32(name='updated', description='The time when the test group was last updated.', example='1588839490'),
  }(name='result', description='The returned results.'),
}

model CreateABTestGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateABTestGroupResponseBody(name='body'),
}

async function createABTestGroup(request: CreateABTestGroupRequest): CreateABTestGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateABTestGroup', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/scenes/{sceneId}/groups', 'json', false, 'json', request);
}

model CreateABTestSceneRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app_group_name', example='my_app_group_name', position='Path'),
  body?: ABTestScene(name='body', description='The request body.', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Default value: false.

Valid values:

*   **true**
*   **false**', example='false', position='Query'),
}

model CreateABTestSceneResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test scenario was created.', example='0'),
    id?: string(name='id', description='The ID of the test group.', example='20405'),
    name?: string(name='name', description='The name of the test group.', example='kevintest_2020-5-7_15:21:48'),
    status?: int32(name='status', description='The status of the test scenario. Valid values:

*   0: not in effect
*   1: in effect', example='1'),
    updated?: int32(name='updated', description='The time when the test scenario was last modified.', example='1589012351'),
    values?: [ string ](name='values', description='The tag of the test scenario.'),
  }(name='result', description='The return result.'),
}

model CreateABTestSceneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateABTestSceneResponseBody(name='body'),
}

async function createABTestScene(request: CreateABTestSceneRequest): CreateABTestSceneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateABTestScene', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/scenes', 'json', false, 'json', request);
}

model CreateAppRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application', example='my_app_group_name', position='Path'),
  autoSwitch?: boolean(name='autoSwitch', position='Body'),
  cluster?: {
    maxQueryClauseLength?: int32(name='maxQueryClauseLength'),
    maxTimeoutMS?: int32(name='maxTimeoutMS'),
  }(name='cluster', position='Body'),
  dataSources?: [ 
    {
      fields?: [  map[string]any ](name='fields'),
      keyField?: string(name='keyField'),
      parameters?: map[string]any(name='parameters'),
      plugins?: map[string]any(name='plugins'),
      schemaName?: string(name='schemaName'),
      tableName?: string(name='tableName'),
      type?: string(name='type'),
    }
  ](name='dataSources', position='Body'),
  description?: string(name='description', position='Body'),
  domain?: {
    category?: string(name='category'),
    functions?: map[string]any(name='functions'),
    name?: string(name='name'),
  }(name='domain', position='Body'),
  fetchFields?: [ string ](name='fetchFields', position='Body'),
  firstRanks?: [ 
    {
      active?: boolean(name='active'),
      description?: string(name='description'),
      meta?: any(name='meta'),
      name?: string(name='name'),
      type?: string(name='type'),
    }
  ](name='firstRanks', position='Body'),
  networkType?: string(name='networkType', position='Body'),
  queryProcessors?: [ 
    {
      active?: boolean(name='active'),
      category?: string(name='category'),
      domain?: string(name='domain'),
      indexes?: [ string ](name='indexes'),
      name?: string(name='name'),
      processors?: [  map[string]any ](name='processors'),
    }
  ](name='queryProcessors', position='Body'),
  schema?: {
    indexSortConfig?: [ 
      {
        direction?: string(name='direction'),
        field?: string(name='field'),
      }
    ](name='indexSortConfig'),
    indexes?: {
      filterFields?: [ string ](name='filterFields'),
      searchFields?: map[string]any(name='searchFields'),
    }(name='indexes'),
    name?: string(name='name'),
    routeField?: string(name='routeField'),
    routeFieldValues?: [ string ](name='routeFieldValues'),
    secondRouteField?: string(name='secondRouteField'),
    tables?: map[string]any(name='tables'),
    ttlField?: {
      name?: string(name='name'),
      ttl?: long(name='ttl'),
    }(name='ttlField'),
  }(name='schema', position='Body'),
  schemas?: [ 
    {
      indexSortConfig?: [ 
        {
          direction?: string(name='direction'),
          field?: string(name='field'),
        }
      ](name='indexSortConfig'),
      indexes?: {
        filterFields?: [ string ](name='filterFields'),
        searchFields?: map[string]any(name='searchFields'),
      }(name='indexes'),
      name?: string(name='name'),
      routeField?: string(name='routeField'),
      routeFieldValues?: [ string ](name='routeFieldValues'),
      secondRouteField?: string(name='secondRouteField'),
      tables?: map[string]any(name='tables'),
      ttlField?: {
        name?: string(name='name'),
        ttl?: long(name='ttl'),
      }(name='ttlField'),
    }
  ](name='schemas', position='Body'),
  secondRanks?: [ 
    {
      active?: boolean(name='active'),
      description?: string(name='description'),
      meta?: any(name='meta'),
      name?: string(name='name'),
    }
  ](name='secondRanks', position='Body'),
  summaries?: [ 
    {
      meta?: [ 
        {
          element?: string(name='element'),
          ellipsis?: string(name='ellipsis'),
          field?: string(name='field'),
          len?: int32(name='len'),
          snippet?: string(name='snippet'),
        }
      ](name='meta'),
      name?: string(name='name'),
    }
  ](name='summaries', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run. This parameter is only used to check whether the data source is valid. Valid values: true and false.', example='true', position='Query'),
}

model CreateAppResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFG'),
  result?: {
    autoSwitch?: boolean(name='autoSwitch'),
    cluster?: {
      maxQueryClauseLength?: int32(name='maxQueryClauseLength'),
      maxTimeoutMS?: int32(name='maxTimeoutMS'),
    }(name='cluster'),
    clusterName?: string(name='clusterName'),
    dataSources?: [ 
      {
        fields?: [  map[string]any ](name='fields'),
        keyField?: string(name='keyField'),
        parameters?: map[string]any(name='parameters'),
        plugins?: map[string]any(name='plugins'),
        schemaName?: string(name='schemaName'),
        tableName?: string(name='tableName'),
        type?: string(name='type'),
      }
    ](name='dataSources'),
    description?: string(name='description'),
    domain?: {
      category?: string(name='category'),
      functions?: {
        algo?: [ string ](name='algo'),
        qp?: [ string ](name='qp'),
        service?: [ string ](name='service'),
      }(name='functions'),
      name?: string(name='name'),
    }(name='domain'),
    fetchFields?: [ string ](name='fetchFields'),
    firstRanks?: [ 
      {
        active?: boolean(name='active'),
        description?: string(name='description'),
        meta?: any(name='meta'),
        name?: string(name='name'),
        type?: string(name='type'),
      }
    ](name='firstRanks'),
    id?: string(name='id'),
    interpretations?: map[string]any(name='interpretations'),
    isCurrent?: boolean(name='isCurrent'),
    progressPercent?: int32(name='progressPercent'),
    prompts?: [  map[string]any ](name='prompts'),
    queryProcessors?: [ 
      {
        active?: boolean(name='active'),
        category?: string(name='category'),
        domain?: string(name='domain'),
        indexes?: [ string ](name='indexes'),
        name?: string(name='name'),
        processors?: [  map[string]any ](name='processors'),
      }
    ](name='queryProcessors'),
    quota?: {
      computeResource?: int32(name='computeResource'),
      docSize?: int32(name='docSize'),
      qps?: int32(name='qps'),
      spec?: string(name='spec'),
    }(name='quota'),
    schema?: {
      indexSortConfig?: [ 
        {
          direction?: string(name='direction'),
          field?: string(name='field'),
        }
      ](name='indexSortConfig'),
      indexes?: {
        filterFields?: [ string ](name='filterFields'),
        searchFields?: map[string]any(name='searchFields'),
      }(name='indexes'),
      name?: string(name='name'),
      routeField?: string(name='routeField'),
      routeFieldValues?: [ string ](name='routeFieldValues'),
      secondRouteField?: string(name='secondRouteField'),
      tables?: map[string]any(name='tables'),
      ttlField?: {
        name?: string(name='name'),
        ttl?: long(name='ttl'),
      }(name='ttlField'),
    }(name='schema'),
    schemas?: [ 
      {
        indexSortConfig?: [ 
          {
            direction?: string(name='direction'),
            field?: string(name='field'),
          }
        ](name='indexSortConfig'),
        indexes?: {
          filterFields?: [ string ](name='filterFields'),
          searchFields?: map[string]any(name='searchFields'),
        }(name='indexes'),
        name?: string(name='name'),
        routeField?: string(name='routeField'),
        routeFieldValues?: [ string ](name='routeFieldValues'),
        secondRouteField?: string(name='secondRouteField'),
        tables?: map[string]any(name='tables'),
        ttlField?: {
          name?: string(name='name'),
          ttl?: long(name='ttl'),
        }(name='ttlField'),
      }
    ](name='schemas'),
    secondRanks?: [ 
      {
        active?: boolean(name='active'),
        description?: string(name='description'),
        meta?: any(name='meta'),
        name?: string(name='name'),
      }
    ](name='secondRanks'),
    status?: string(name='status'),
    summaries?: [ 
      {
        meta?: [ 
          {
            element?: string(name='element'),
            ellipsis?: string(name='ellipsis'),
            field?: string(name='field'),
            len?: int32(name='len'),
            snippet?: string(name='snippet'),
          }
        ](name='meta'),
        name?: string(name='name'),
      }
    ](name='summaries'),
    type?: string(name='type'),
  }(name='result', description='The returned results.', example='{}'),
}

model CreateAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAppResponseBody(name='body'),
}

/**
  * *   When you create a standard application, a new version of the application is created if the specified application name already exists.
  * *   When you create a version of an existing application, you must specify the autoSwitch and realtimeShared parameters.
  * *   When you create a version of an existing application, the value of the quota parameter is the same as that of the quota parameter in the previous version of the application.
  * *   When you create a version of an existing application, the modification of the value of the quota parameter does not take effect.
  *
 */
async function createApp(request: CreateAppRequest): CreateAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateApp', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/apps', 'json', false, 'json', request);
}

model CreateAppGroupRequest {
  chargeType?: string(name='chargeType', position='Body'),
  name?: string(name='name', position='Body'),
  quota?: {
    computeResource?: int32(name='computeResource'),
    docSize?: int32(name='docSize'),
    spec?: string(name='spec'),
  }(name='quota', position='Body'),
  resourceGroupId?: string(name='resourceGroupId', position='Body'),
  type?: string(name='type', position='Body'),
}

model CreateAppGroupResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='766CF6DB-CA02-3E12-7CBA-6AC21FC978FD'),
  result?: {
    chargeType?: string(name='chargeType', description='The billing method of the application. Valid values:

*   POSTPAY: pay-as-you-go
*   PREPAY: subscription', example='POSTPAY'),
    chargingWay?: int32(name='chargingWay', description='The billing model. Valid values:

*   1: computing resources
*   2: queries per second (QPS)', example='1'),
    commodityCode?: string(name='commodityCode', description='The code of the commodity.', example='opensearch'),
    created?: int32(name='created', description='The timestamp when the application was created.', example='1590139542'),
    currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='100302903'),
    description?: string(name='description', description='The description of the application.', example='-'),
    domain?: string(name='domain', description='The type of the industry. Valid values:

*   GENERAL: general.
*   ECOMMERCE: e-commerce.
*   IT_CONTENT: IT content.', example='GENERAL'),
    engineType?: string(name='engineType'),
    expireOn?: string(name='expireOn', description='The expiration time.', example='-'),
    hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval status of the quotas. Valid values:

*   0: The quotas are approved.
*   1: The quotas are being approved.', example='0'),
    id?: string(name='id', description='The ID of the application.', example='100302881'),
    instanceId?: string(name='instanceId', description='The ID of the instance.', example='-'),
    lockMode?: string(name='lockMode', description='The lock mode of the instance. Valid values:

*   Unlock: The instance is not locked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
    name?: string(name='name', description='The name of the application.', example='lsh_test_1'),
    produced?: int32(name='produced', description='Indicates whether the order is complete. Valid values:

*   0: The order is in progress.
*   1: The order is complete.', example='1'),
    projectId?: string(name='projectId', description='The name of the A/B test group.', example='-'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing units (LCUs).', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
      spec?: string(name='spec', description='The specifications of the application. Valid values:

*   opensearch.share.junior: basic
*   opensearch.share.common: shared general-purpose
*   opensearch.share.compute: shared computing
*   opensearch.share.storage: shared storage
*   opensearch.private.common: exclusive general-purpose
*   opensearch.private.compute: exclusive computing
*   opensearch.private.storage: exclusive storage', example='opensearch.share.common'),
    }(name='quota', description='The information about the quotas of the application.'),
    status?: string(name='status', description='The status of the application. Valid values:

*   producing
*   review_pending
*   config_pending
*   normal
*   frozen', example='normal'),
    switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='1590486386'),
    type?: string(name='type', description='The type of the application. Valid values:

*   standard: a standard application.
*   advance: an advanced application which is of an old application type. New applications cannot be of this type.
*   enhanced: an advanced application which is of a new application type.', example='enhanced'),
    updated?: int32(name='updated', description='The timestamp when the application was last updated.', example='1590978265'),
  }(name='result', description='N/A'),
}

model CreateAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAppGroupResponseBody(name='body'),
}

async function createAppGroup(request: CreateAppGroupRequest): CreateAppGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateAppGroup', 'POST', '/v4/openapi/app-groups', 'json', false, 'json', request);
}

model CreateAppGroupCredentialsRequest {
  appGroupIdentity: string(name='appGroupIdentity', example='app_group_123', position='Path'),
  type?: string(name='type', example='api-token', position='Body'),
  dryRun?: boolean(name='dryRun', position='Query'),
}

model CreateAppGroupCredentialsResponseBody = {
  requestId?: string(name='requestId', example='1-2-3-4'),
  result?: {
    appGroupId?: long(name='appGroupId', example='app_group_123'),
    enabled?: boolean(name='enabled'),
    token?: string(name='token', example='generated_token_string'),
    type?: string(name='type', example='api-token'),
  }(name='result'),
}

model CreateAppGroupCredentialsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAppGroupCredentialsResponseBody(name='body'),
}

async function createAppGroupCredentials(request: CreateAppGroupCredentialsRequest): CreateAppGroupCredentialsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateAppGroupCredentials', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/credentials', 'json', false, 'json', request);
}

model CreateFirstRankRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application', example='my_app_group_name', position='Path'),
  appId: int32(name='appId', description='The version number of the application.', example='110157886', position='Path'),
  body?: FirstRank(name='body', description='The request body that contains the parameters of the rough sort expression.', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run.', example='true', position='Query'),
}

model CreateFirstRankResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
    meta?: [ 
      {
        arg?: string(name='arg', description='The parameters that are used by a function in the expression.', example='1'),
        attribute?: string(name='attribute', description='The attribute, feature functions, or field to be searched for.', example='static_bm25()'),
        weight?: float(name='weight', description='The weight. Valid values: \\[-100000,100000]. The value cannot be 0.', example='10'),
      }
    ](name='meta', description='The content of the expression.'),
    name?: string(name='name', description='The name of the expression.', example='default'),
  }(name='result', description='The information about the rough sort expression.'),
}

model CreateFirstRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFirstRankResponseBody(name='body'),
}

async function createFirstRank(request: CreateFirstRankRequest): CreateFirstRankResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateFirstRank', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/first-ranks', 'json', false, 'json', request);
}

model CreateFunctionInstanceRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='my_app_group_name', position='Path'),
  functionName: string(name='functionName', description='The feature name. Valid values:

*   ctr: CTR model.
*   pop: popularity model.
*   category: category model.
*   hot: hotword model.
*   hint: hint model.
*   suggest: drop-down suggestion model.
*   analyzer: tokenization model.
*   termweight: term weight model.
*   synonym: synonym model.', example='ctr', position='Path'),
  createParameters?: [ 
    {
      name?: string(name='name', description='The parameter name.', example='title_field'),
      value?: string(name='value', description='The parameter value.', example='title'),
    }
  ](name='createParameters', description='The parameters used to create the instance.', example='[   { "name": "param1", "value": "val1"   } ]', position='Body'),
  cron?: string(name='cron', description='The CRON expression used to schedule periodic training, in the format of Minutes Hours DayofMonth Month DayofWeek. The default value is empty, which specifies that no periodic training is performed. A value of 0 for DayofWeek specifies Sunday.', example='0 0 ? * 0,1,2,3,4,5,6', position='Body'),
  description?: string(name='description', description='The description.', example='test instance', position='Body'),
  functionType?: string(name='functionType', description='The feature type.

*   Default value: PAAS. Training is required before you can use the feature.', example='PAAS', position='Body'),
  instanceName: string(name='instanceName', description='The instance name. The name must be 1 to 30 characters in length and can contain letters, digits, and underscores (\\_). The name is case-sensitive and must start with a letter.', example='ctr_test', position='Body'),
  modelType: string(name='modelType', description='The model type. The value varies based on the model.

*   Click-through rate (CTR) model: tf_checkpoint
*   Popularity model: pop
*   Category model: offline_inference
*   Hotword model: offline_inference
*   Hint model: offline_inference
*   Hotword model for real-time top searches: near_realtime
*   Personalized hint model: near_realtime
*   Drop-down suggestion model: offline_inference
*   Tokenization model: text
*   Term weight model: tf_checkpoint
*   Synonym model: offline_inference', example='tf_checkpoint', position='Body'),
  usageParameters?: [ 
    {
      name?: string(name='name', description='The parameter name.', example='allow_dict_id'),
      value?: string(name='value', description='The parameter value.', example='123'),
    }
  ](name='usageParameters', description='The parameters used to use the instance.', position='Body'),
}

model CreateFunctionInstanceResponseBody = {
  code?: string(name='Code', description='The error code.', example='Version.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message. If no error occurs, this parameter is left empty.', example='version not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='98724351-D6B2-5D8A-B089-7FFD1821A7E9'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model CreateFunctionInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFunctionInstanceResponseBody(name='body'),
}

/**
  * You can call the [GetFunctionCurrentVersion](~~421377~~) operation to query the latest version of a feature. The response of the operation includes the createParameters parameter that is used to create an algorithm instance, the usageParameters parameter, and the requirements for setting these parameters.
  *
 */
async function createFunctionInstance(request: CreateFunctionInstanceRequest): CreateFunctionInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateFunctionInstance', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/functions/{functionName}/instances', 'json', false, 'json', request);
}

model CreateFunctionResourceRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='my_app_group_name', position='Path'),
  functionName: string(name='functionName', description='The name of the feature.', example='rank', position='Path'),
  data?: {
    content?: string(name='Content', description='The content of the file that corresponds to a resource of the raw_file type.', example='"abc"'),
    generators?: [ 
      {
        generator?: string(name='Generator', description='The type of the feature generator.

Valid values:

*   lookup

    <!-- -->

    <!-- -->

    <!-- -->

*   sequence

    <!-- -->

    <!-- -->

    <!-- -->

*   overlap

    <!-- -->

    <!-- -->

    <!-- -->

*   raw

    <!-- -->

    <!-- -->

    <!-- -->

*   combo

    <!-- -->

    <!-- -->

    <!-- -->

*   id

    <!-- -->

    <!-- -->

    <!-- -->', example='id'),
        input?: {
          features?: [ 
            {
              name?: string(name='Name', description='The name of the feature.', example='system_item_id'),
              type?: string(name='Type', description='The type of the feature.

Valid values:

*   item

    <!-- -->

    <!-- -->

    <!-- -->

*   user

    <!-- -->

    <!-- -->

    <!-- -->', example='item'),
            }
          ](name='Features', description='The input features.'),
        }(name='Input', description='The input.'),
        output?: string(name='Output', description='The name of the output feature.', example='item_id_feature'),
      }
    ](name='Generators', description='The feature generators that correspond to resources of the feature_generator type.'),
  }(name='Data', description='The resource data. The data structure varies with the resource type.', position='Body'),
  description?: string(name='Description', description='The description of the resource.', example='""', position='Body'),
  resourceName?: string(name='ResourceName', description='The name of the resource.', example='fg_jsoon', position='Body'),
  resourceType?: string(name='ResourceType', description='The resource type.

Valid values:

*   feature_generator

    <!-- -->

    <!-- -->

    <!-- -->

*   raw_file

    <!-- -->

    <!-- -->

    <!-- -->', example='feature_generator', position='Body'),
}

model CreateFunctionResourceResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, this parameter is left empty.', example='""'),
  httpCode?: long(name='HttpCode', description='The HTTP status code returned.', example='200'),
  latency?: double(name='Latency', description='The time consumed for the request. Unit: milliseconds.', example='123'),
  message?: string(name='Message', description='The error message returned.', example='""'),
  requestId?: string(name='RequestId', description='The request ID.', example='A4D487A9-A456-5AA5-A9C6-B7BF2889CF74'),
  status?: string(name='Status', description='The status code. Valid values:

*   OK
*   FAIL', example='OK'),
}

model CreateFunctionResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFunctionResourceResponseBody(name='body'),
}

async function createFunctionResource(request: CreateFunctionResourceRequest): CreateFunctionResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateFunctionResource', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/functions/{functionName}/resources', 'json', false, 'json', request);
}

model CreateFunctionTaskRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='app_group_name', position='Path'),
  functionName: string(name='functionName', description='The name of the feature.', example='ctr', position='Path'),
  instanceName: string(name='instanceName', description='The name of the instance.', example='ctr_test', position='Path'),
}

model CreateFunctionTaskResponseBody = {
  code?: string(name='Code', description='The error code.', example='Task.IsRunning'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1638157990724'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model CreateFunctionTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFunctionTaskResponseBody(name='body'),
}

async function createFunctionTask(request: CreateFunctionTaskRequest): CreateFunctionTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateFunctionTask', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/functions/{functionName}/instances/{instanceName}/tasks', 'json', false, 'json', request);
}

model CreateInterventionDictionaryRequest {
  analyzerType?: string(name='analyzerType', description='The type of the analyzer. Valid values:

*   MODEL: model-based custom analyzer.
*   SYSTEM: system analyzer.
*   USER: custom analyzer.', example='SYSTEM', position='Body'),
  name?: string(name='name', description='The name of the intervention dictionary.', example='ner_dict_ec', position='Body'),
  type?: string(name='type', description='The type of the intervention dictionary. Valid values:

*   stopword: an intervention dictionary for stop word filtering.
*   synonym: an intervention dictionary for synonym configuration.
*   correction: an intervention dictionary for spelling correction.
*   category_prediction: an intervention dictionary for category prediction.
*   ner: an intervention dictionary for named entity recognition (NER).
*   term_weighting: an intervention dictionary for term weight analysis.
*   suggest_allowlist: a drop-down suggestion whitelist.
*   suggest_denylist: a drop-down suggestion blacklist.
*   hot_allowlist: a top search whitelist.
*   hot_denylist: a top search blacklist.
*   hint_allowlist: a hint whitelist.
*   hint_denylist: a hint blacklist.', example='ner', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Default value: false.

Valid values:

*   **true**
*   **false**', example='false', position='Query'),
}

model CreateInterventionDictionaryResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='80326EFE-485F-46E7-B291-5A1DD08D2198'),
  result?: {
    analyzer?: string(name='analyzer', description='The custom analyzer.', example='dianshang'),
    created?: string(name='created', description='The time when the test scenario was created.', example='1591086323'),
    name?: string(name='name', description='The name of the test group.', example='testb'),
    type?: string(name='type', description='The type of the intervention dictionary. Valid values:

*   stopword: an intervention dictionary for stop word filtering
*   synonym: an intervention dictionary for synonym configuration
*   correction: an intervention dictionary for spelling correction
*   category_prediction: an intervention dictionary for category prediction
*   ner: an intervention dictionary for named entity recognition (NER)
*   term_weighting: an intervention dictionary for term weight analysis', example='ner'),
    updated?: string(name='updated', description='The time when the intervention dictionary was last updated.', example='1591086323'),
  }(name='result', description='The returned results.'),
}

model CreateInterventionDictionaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateInterventionDictionaryResponseBody(name='body'),
}

async function createInterventionDictionary(request: CreateInterventionDictionaryRequest): CreateInterventionDictionaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateInterventionDictionary', 'POST', '/v4/openapi/intervention-dictionaries', 'json', false, 'json', request);
}

model CreateQueryProcessorRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='my_app_group_name', position='Path'),
  appId: int32(name='appId', description='The version number of the application.', example='110157886', position='Path'),
  body?: any(name='body', description='The request body.', example='{}', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run.', example='true', position='Query'),
}

model CreateQueryProcessorResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the query analysis rule is the default one.', example='true'),
    created?: int32(name='created', description='The time when the query analysis rule was created.', example='1587398402'),
    domain?: string(name='domain', description='The type of the industry to which the query analysis rule was applied. Valid values:

*   GENERAL: general.
*   ECOMMERCE: e-commerce.
*   IT_CONTENT: IT content.', example='GENERAL'),
    indexes?: [ string ](name='indexes', description='The indexes to which the query analysis rule was applied.'),
    name?: string(name='name', description='The name of the query analysis rule.', example='query_filter'),
    processors?: [  map[string]any ](name='processors', description='The features that are used in the query analysis rule.

For more information, see [QueryProcessor](~~170014~~).'),
    updated?: int32(name='updated', description='The time when the query analysis rule was last modified.', example='1587398402'),
  }(name='result', description='The information about the query analysis rule.'),
}

model CreateQueryProcessorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateQueryProcessorResponseBody(name='body'),
}

async function createQueryProcessor(request: CreateQueryProcessorRequest): CreateQueryProcessorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateQueryProcessor', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/query-processors', 'json', false, 'json', request);
}

model CreateScheduledTaskRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app_group_name', example='my_app_group_name', position='Path'),
  body?: ScheduledTask(name='body', description='请求体', position='Body'),
}

model CreateScheduledTaskResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='The details of the scheduled task.', example='{}'),
}

model CreateScheduledTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateScheduledTaskResponseBody(name='body'),
}

async function createScheduledTask(request: CreateScheduledTaskRequest): CreateScheduledTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateScheduledTask', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/scheduled-tasks', 'json', false, 'json', request);
}

model CreateSearchStrategyRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='"my_app"', position='Path'),
  appId: string(name='appId', description='The version number of the application.', example='1234', position='Path'),
  body?: SearchStrategy(name='body', description='The query policy.', position='Body'),
}

model CreateSearchStrategyResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='"abc123"'),
}

model CreateSearchStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSearchStrategyResponseBody(name='body'),
}

async function createSearchStrategy(request: CreateSearchStrategyRequest): CreateSearchStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateSearchStrategy', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/search-strategies', 'json', false, 'json', request);
}

model CreateSecondRankRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='my_app_group_name', position='Path'),
  appId: int32(name='appId', description='The version number of the application.', example='110157886', position='Path'),
  body?: SecondRank(name='body', description='The request body. For more information, see [SecondRank](~~170008~~).', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run.', example='true', position='Query'),
}

model CreateSecondRankResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='The information about the fine sort expression.', example='{}'),
}

model CreateSecondRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSecondRankResponseBody(name='body'),
}

async function createSecondRank(request: CreateSecondRankRequest): CreateSecondRankResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateSecondRank', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/second-ranks', 'json', false, 'json', request);
}

model CreateSortScriptRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application name or ID.', example='search', position='Path'),
  appVersionId: string(name='appVersionId', description='The ID of the report in the application.', example='1234567', position='Path'),
  scope?: string(name='scope', description='The sort phase to which the script applies.', example='second_rank', position='Body'),
  scriptName?: string(name='scriptName', description='The script name.', example='rank_cava_20230606_v7', position='Body'),
  type?: string(name='type', description='The script type. Set the value to cava_script.', example='cava_script', position='Body'),
}

model CreateSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: {
    scope?: string(name='scope', description='The sort phase to which the script applies.', example='second_rank'),
    scriptName?: string(name='scriptName', description='The script name.', example='rank_cava_20230606_v7'),
    type?: string(name='type', description='The script type.', example='cava_script'),
  }(name='result', description='The response parameters.'),
}

model CreateSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSortScriptResponseBody(name='body'),
}

async function createSortScript(request: CreateSortScriptRequest): CreateSortScriptResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateSortScript', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appVersionId}/sort-scripts', 'json', false, 'json', request);
}

model CreateUserAnalyzerRequest {
  business?: string(name='business', description='The basic analyzer.', example='chn_standard', position='Body'),
  businessAppGroupId?: string(name='businessAppGroupId', description='The application ID of the custom analyzer.', example='110123123', position='Body'),
  businessType?: string(name='businessType', description='The basic analyzer type. Valid values: AUTO, MODEL, SYSTEM, and USER.', example='AUTO', position='Body'),
  name?: string(name='name', description='The analyzer name.', example='jmbon_analyzer', position='Body'),
  type?: string(name='type', description='The engine type. Valid values: HA3 and ES.', example='HA3', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Default value: false.

Valid values:

*   **true**
*   **false**', example='false', position='Query'),
}

model CreateUserAnalyzerResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='98724351-D6B2-5D8A-B089-7FFD1821A7E9'),
  result?: map[string]any(name='result', description='The custom analyzer.', example='{}'),
}

model CreateUserAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateUserAnalyzerResponseBody(name='body'),
}

async function createUserAnalyzer(request: CreateUserAnalyzerRequest): CreateUserAnalyzerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateUserAnalyzer', 'POST', '/v4/openapi/user-analyzers', 'json', false, 'json', request);
}

model DeleteABTestExperimentRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app_group_name', example='my_app_group_name', position='Path'),
  sceneId: int32(name='sceneId', description='20404', example='20404', minimum=-1, maximum=999999999, position='Path'),
  groupId: int32(name='groupId', description='13467', example='13467', minimum=-1, maximum=999999999, position='Path'),
  experimentId: int32(name='experimentId', description='12889', example='12889', minimum=-1, maximum=999999999, position='Path'),
}

model DeleteABTestExperimentResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='The result that was returned.', example='{}'),
}

model DeleteABTestExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteABTestExperimentResponseBody(name='body'),
}

async function deleteABTestExperiment(request: DeleteABTestExperimentRequest): DeleteABTestExperimentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteABTestExperiment', 'DELETE', '/v4/openapi/app-groups/{appGroupIdentity}/scenes/{sceneId}/groups/{groupId}/experiments/{experimentId}', 'json', false, 'json', request);
}

model DeleteABTestGroupRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application name.', example='my_app_group_name', position='Path'),
  sceneId: int32(name='sceneId', description='The scenario ID.', example='20404', minimum=-1, maximum=999999999, position='Path'),
  groupId: int32(name='groupId', description='The group ID.', example='13467', minimum=-1, maximum=999999999, position='Path'),
}

model DeleteABTestGroupResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='The return result.', example='{}'),
}

model DeleteABTestGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteABTestGroupResponseBody(name='body'),
}

async function deleteABTestGroup(request: DeleteABTestGroupRequest): DeleteABTestGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteABTestGroup', 'DELETE', '/v4/openapi/app-groups/{appGroupIdentity}/scenes/{sceneId}/groups/{groupId}', 'json', false, 'json', request);
}

model DeleteABTestSceneRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name or ID of the application.', example='my_app_group_name', position='Path'),
  sceneId: int32(name='sceneId', description='The test scenario ID.', example='20404', minimum=-1, maximum=999999999, position='Path'),
}

model DeleteABTestSceneResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='The returned results.', example='{}'),
}

model DeleteABTestSceneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteABTestSceneResponseBody(name='body'),
}

async function deleteABTestScene(request: DeleteABTestSceneRequest): DeleteABTestSceneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteABTestScene', 'DELETE', '/v4/openapi/app-groups/{appGroupIdentity}/scenes/{sceneId}', 'json', false, 'json', request);
}

model DeleteFunctionInstanceRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='“my_app_group_name”', position='Path'),
  functionName: string(name='functionName', description='The name of the feature.', example='"ctr"', position='Path'),
  instanceName: string(name='instanceName', description='The name of the instance.', example='"ctr_test"', position='Path'),
}

model DeleteFunctionInstanceResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, this parameter is left empty.', example='"Instance.NotExist"'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='10'),
  message?: string(name='Message', description='The error message. If no error occurs, this parameter is left empty.', example='"instance not exist."'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='"1081EB05-473C-5BF4-95BE-6D7CAD5E2213"'),
  status?: string(name='Status', description='The status of the request. Valid values:

*   OK: The request is successful.
*   FAIL: The request fails.', example='"OK"'),
}

model DeleteFunctionInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFunctionInstanceResponseBody(name='body'),
}

async function deleteFunctionInstance(request: DeleteFunctionInstanceRequest): DeleteFunctionInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteFunctionInstance', 'DELETE', '/v4/openapi/app-groups/{appGroupIdentity}/functions/{functionName}/instances/{instanceName}', 'json', false, 'json', request);
}

model DeleteFunctionResourceRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application ID.', example='my_app_group_name', position='Path'),
  functionName: string(name='functionName', description='The name of the feature.', example='rank', position='Path'),
  resourceName: string(name='resourceName', description='The name of the resource.', example='fg_json', position='Path'),
}

model DeleteFunctionResourceResponseBody = {
  code?: string(name='Code', description='The error code returned. If no error occurs, this value is empty.', example='""'),
  httpCode?: long(name='HttpCode', description='The HTTP status code returned.', example='200'),
  latency?: double(name='Latency', description='The time consumed for the request. Unit: milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='""'),
  requestId?: string(name='RequestId', description='The request ID.', example='A4D487A9-A456-5AA5-A9C6-B7BF2889CF74'),
  status?: string(name='Status', description='The status code. Valid values:

*   OK
*   FAIL', example='OK'),
}

model DeleteFunctionResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFunctionResourceResponseBody(name='body'),
}

async function deleteFunctionResource(request: DeleteFunctionResourceRequest): DeleteFunctionResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteFunctionResource', 'DELETE', '/v4/openapi/app-groups/{appGroupIdentity}/functions/{functionName}/resources/{resourceName}', 'json', false, 'json', request);
}

model DeleteFunctionTaskRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='my_app_group_name', position='Path'),
  functionName: string(name='functionName', description='The name of the feature.', example='ctr', position='Path'),
  instanceName: string(name='instanceName', description='The name of the instance.', example='ctr_test', position='Path'),
  generation: string(name='generation', description='The number of iterations.', example='1', position='Path'),
}

model DeleteFunctionTaskResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, this parameter is left empty.', example='Task.UnableDelete'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='operation success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='"1081EB05-473C-5BF4-95BE-6D7CAD5E2213"'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model DeleteFunctionTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFunctionTaskResponseBody(name='body'),
}

async function deleteFunctionTask(request: DeleteFunctionTaskRequest): DeleteFunctionTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteFunctionTask', 'DELETE', '/v4/openapi/app-groups/{appGroupIdentity}/functions/{functionName}/instances/{instanceName}/tasks/{generation}', 'json', false, 'json', request);
}

model DeleteSortScriptRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='search', example='search', position='Path'),
  scriptName: string(name='scriptName', description='cava', example='cava', position='Path'),
  appVersionId: string(name='appVersionId', description='1234567', example='1234567', position='Path'),
}

model DeleteSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
}

model DeleteSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSortScriptResponseBody(name='body'),
}

async function deleteSortScript(request: DeleteSortScriptRequest): DeleteSortScriptResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteSortScript', 'DELETE', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appVersionId}/sort-scripts/{scriptName}', 'json', false, 'json', request);
}

model DeleteSortScriptFileRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='search', example='search', position='Path'),
  appVersionId: string(name='appVersionId', description='1234567', example='1234567', position='Path'),
  scriptName: string(name='scriptName', description='cava', example='cava', position='Path'),
  fileName: string(name='fileName', description='cavafile', example='cavafile', position='Path'),
}

model DeleteSortScriptFileResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
}

model DeleteSortScriptFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSortScriptFileResponseBody(name='body'),
}

async function deleteSortScriptFile(request: DeleteSortScriptFileRequest): DeleteSortScriptFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteSortScriptFile', 'DELETE', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appVersionId}/sort-scripts/{scriptName}/files/src/{fileName}', 'json', false, 'json', request);
}

model DescribeABTestExperimentRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application name.', example='my_app_group_name', position='Path'),
  sceneId: int32(name='sceneId', description='The scenario ID.', example='20404', minimum=-1, maximum=999999999, position='Path'),
  groupId: int32(name='groupId', description='The group ID.', example='13467', minimum=-1, maximum=999999999, position='Path'),
  experimentId: int32(name='experimentId', description='The experiment ID', example='12889', minimum=-1, maximum=999999999, position='Path'),
}

model DescribeABTestExperimentResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test was created.', example='1588842080'),
    id?: string(name='id', description='The ID of the test.', example='12888'),
    name?: string(name='name', description='The name of the test.', example='test1'),
    online?: boolean(name='online', description='The status of the test. Valid values:

*   true: in effect
*   false: not in effect', example='true'),
    params?: {
      firstFormulaName?: string(name='first_formula_name', description='The name of the rough sort policy.', example='default'),
    }(name='params', description='The parameters of the test.'),
    traffic?: int32(name='traffic', description='The percentage of traffic that is routed to the test.', example='30'),
    updated?: int32(name='updated', description='The time when the test was last modified.', example='1588842080'),
  }(name='result', description='The details of the test.'),
}

model DescribeABTestExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeABTestExperimentResponseBody(name='body'),
}

async function describeABTestExperiment(request: DescribeABTestExperimentRequest): DescribeABTestExperimentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeABTestExperiment', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/scenes/{sceneId}/groups/{groupId}/experiments/{experimentId}', 'json', false, 'json', request);
}

model DescribeABTestGroupRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app_group_name', example='my_app_group_name', position='Path'),
  sceneId: int32(name='sceneId', description='20404', example='20404', minimum=-1, maximum=999999999, position='Path'),
  groupId: int32(name='groupId', description='13467', example='13467', minimum=-1, maximum=999999999, position='Path'),
}

model DescribeABTestGroupResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test group was created.', example='1588839490'),
    id?: string(name='id', description='The ID of the test group.', example='13466'),
    name?: string(name='name', description='The name of the test group.', example='Group_2020-5-7_15:23:3'),
    status?: int32(name='status', description='The status of the test group. Valid values:

*   0: not in effect
*   1: in effect', example='1'),
    updated?: int32(name='updated', description='The time when the test group was last modified.', example='1588839490'),
  }(name='result', description='The details of the test group.'),
}

model DescribeABTestGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeABTestGroupResponseBody(name='body'),
}

async function describeABTestGroup(request: DescribeABTestGroupRequest): DescribeABTestGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeABTestGroup', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/scenes/{sceneId}/groups/{groupId}', 'json', false, 'json', request);
}

model DescribeABTestSceneRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name or ID of the application.', example='my_app_group_name', position='Path'),
  sceneId: int32(name='sceneId', description='The ID of the test scenario.', example='20404', minimum=-1, maximum=999999999, position='Path'),
}

model DescribeABTestSceneResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test scenario was created.', example='1596527691'),
    id?: string(name='id', description='The ID of the test scenario.', example='20614'),
    name?: string(name='name', description='The name of the test scenario.', example='test'),
    status?: int32(name='status', description='The status of the test scenario. Valid values:

*   0: The test is stopped.
*   1: The test is started.', example='0'),
    updated?: int32(name='updated', description='The time when the test was last modified.', example='1596527691'),
    values?: [ string ](name='values', description='The indicators of the test scenarios.'),
  }(name='result', description='The details of the test scenario.'),
}

model DescribeABTestSceneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeABTestSceneResponseBody(name='body'),
}

async function describeABTestScene(request: DescribeABTestSceneRequest): DescribeABTestSceneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeABTestScene', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/scenes/{sceneId}', 'json', false, 'json', request);
}

model DescribeAppRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='my_app_group_name', position='Path'),
  appId: int32(name='appId', description='The ID of the version.', example='110116134', position='Path'),
}

model DescribeAppResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='33477D76-C380-1D84-A4AD-043F52876CB1'),
  result?: {
    autoSwitch?: boolean(name='autoSwitch', description='Indicates whether the version is automatically published to the online environment.', example='true'),
    cluster?: {
      maxQueryClauseLength?: int32(name='maxQueryClauseLength'),
      maxTimeoutMS?: int32(name='maxTimeoutMS'),
    }(name='cluster'),
    clusterName?: string(name='clusterName', description='The name of the cluster.', example='-'),
    dataSources?: [ 
      {
        fields?: [  map[string]any ](name='fields'),
        keyField?: string(name='keyField'),
        parameters?: map[string]any(name='parameters'),
        plugins?: map[string]any(name='plugins'),
        schemaName?: string(name='schemaName'),
        tableName?: string(name='tableName'),
        type?: string(name='type'),
      }
    ](name='dataSources'),
    description?: string(name='description', description='The description of the version.', example='-'),
    domain?: {
      category?: string(name='category', description='The category. By default, this parameter is left empty.', example='-'),
      functions?: {
        algo?: [ string ](name='algo', description='Algorithm structure', example='[]'),
        qp?: [ string ](name='qp', description='Queryprocessor description', example='[]'),
        service?: [ string ](name='service', description='Function description', example='[]'),
      }(name='functions', description='search functions', example='{}'),
      name?: string(name='name', description='The name', example='test'),
    }(name='domain', description='The type of the industry. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='GENERAL'),
    fetchFields?: [ string ](name='fetchFields', description='The default display fields.', example='[]'),
    firstRanks?: [ 
      {
        active?: boolean(name='active'),
        description?: string(name='description'),
        meta?: any(name='meta'),
        name?: string(name='name'),
        type?: string(name='type'),
      }
    ](name='firstRanks'),
    id?: string(name='id', description='The ID of the version.', example='100303063'),
    interpretations?: map[string]any(name='interpretations'),
    isCurrent?: boolean(name='isCurrent'),
    progressPercent?: int32(name='progressPercent', description='The progress of data import, in percentage. For example, a value of 83 indicates 83%.', example='100'),
    prompts?: [  map[string]any ](name='prompts'),
    queryProcessors?: [ 
      {
        active?: boolean(name='active'),
        category?: string(name='category'),
        domain?: string(name='domain'),
        indexes?: [ string ](name='indexes'),
        name?: string(name='name'),
        processors?: [  map[string]any ](name='processors'),
      }
    ](name='queryProcessors'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing units (LCUs).', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
      qps?: int32(name='qps', description='The number of search requests per second. You are charged based on the number of search requests per second in the earlier billing model.', example='5'),
      spec?: string(name='spec', description='The specifications of the application. Valid values:

*   opensearch.share.junior: basic
*   opensearch.share.common: shared general-purpose
*   opensearch.share.compute: shared computing
*   opensearch.share.storage: shared storage
*   opensearch.private.common: exclusive general-purpose
*   opensearch.private.compute: exclusive computing
*   opensearch.private.storage: exclusive storage', example='opensearch.share.common'),
    }(name='quota', description='The quota information about the version.', example='{}'),
    schema?: {
      indexSortConfig?: [ 
        {
          direction?: string(name='direction'),
          field?: string(name='field'),
        }
      ](name='indexSortConfig'),
      indexes?: {
        filterFields?: [ string ](name='filterFields'),
        searchFields?: map[string]any(name='searchFields'),
      }(name='indexes'),
      name?: string(name='name'),
      routeField?: string(name='routeField'),
      routeFieldValues?: [ string ](name='routeFieldValues'),
      secondRouteField?: string(name='secondRouteField'),
      tables?: map[string]any(name='tables'),
      ttlField?: {
        name?: string(name='name'),
        ttl?: long(name='ttl'),
      }(name='ttlField'),
    }(name='schema', description='The application schema.', example='{}'),
    schemas?: [ 
      {
        indexSortConfig?: [ 
          {
            direction?: string(name='direction'),
            field?: string(name='field'),
          }
        ](name='indexSortConfig'),
        indexes?: {
          filterFields?: [ string ](name='filterFields'),
          searchFields?: map[string]any(name='searchFields'),
        }(name='indexes'),
        name?: string(name='name'),
        routeField?: string(name='routeField'),
        routeFieldValues?: [ string ](name='routeFieldValues'),
        secondRouteField?: string(name='secondRouteField'),
        tables?: map[string]any(name='tables'),
        ttlField?: {
          name?: string(name='name'),
          ttl?: long(name='ttl'),
        }(name='ttlField'),
      }
    ](name='schemas'),
    secondRanks?: [ 
      {
        active?: boolean(name='active'),
        description?: string(name='description'),
        meta?: any(name='meta'),
        name?: string(name='name'),
      }
    ](name='secondRanks'),
    status?: string(name='status', description='The status of the version. Valid values:

*   ok
*   stopped
*   frozen
*   initializing
*   unavailable
*   data_waiting
*   data_preparing', example='ok'),
    summaries?: [ 
      {
        meta?: [ 
          {
            element?: string(name='element'),
            ellipsis?: string(name='ellipsis'),
            field?: string(name='field'),
            len?: int32(name='len'),
            snippet?: string(name='snippet'),
          }
        ](name='meta'),
        name?: string(name='name'),
      }
    ](name='summaries'),
    type?: string(name='type', description='The type of the application. Valid values:

*   standard: a standard application.
*   advance: an advanced application which is of an old application type. New applications cannot be of this type.
*   enhanced: an advanced application which is of a new application type.', example='enhanced'),
  }(name='result', description='The information about the version.', example='{}'),
}

model DescribeAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAppResponseBody(name='body'),
}

async function describeApp(request: DescribeAppRequest): DescribeAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeApp', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}', 'json', false, 'json', request);
}

model DescribeAppGroupRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application name.', example='my_app_group_name', position='Path'),
}

model DescribeAppGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    chargeType?: string(name='chargeType', description='The billing method. Valid values:

*   POSTPAY: pay-as-you-go.
*   PREPAY: subscription.', example='POSTPAY'),
    chargingWay?: int32(name='chargingWay', description='The billable item. Valid values:

*   1: computing resources.
*   2: queries per second (QPS).', example='1'),
    commodityCode?: string(name='commodityCode', description='The commodity code.', example='opensearch'),
    created?: int32(name='created', description='The timestamp when the application was created.', example='1575442875'),
    currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='110116134'),
    description?: string(name='description', description='The description of the application.', example='-'),
    domain?: string(name='domain', description='The industry of the application.', example='ecommerce'),
    engineType?: string(name='engineType'),
    expireOn?: string(name='expireOn', description='The expiration time.', example='-'),
    firstRankAlgoDeploymentId?: int32(name='firstRankAlgoDeploymentId', description='The ID of the created rough sort expression.', example='0'),
    hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval state of the quotas. Valid values:

*   0: The application is in service.
*   1: The quotas are being reviewed.', example='0'),
    id?: string(name='id', description='The application ID.', example='110116134'),
    instanceId?: string(name='instanceId', description='The instance ID.', example='-'),
    lockMode?: string(name='lockMode', description='The lock state. Valid values:

*   Unlock: The instance is unlocked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
    lockedByExpiration?: int32(name='lockedByExpiration', description='Indicates whether the instance is automatically locked after it expires.', example='0'),
    name?: string(name='name', description='The application name.', example='os_function_test_v1'),
    pendingSecondRankAlgoDeploymentId?: int32(name='pendingSecondRankAlgoDeploymentId', description='The ID of the fine sort expression that is being created.', example='0'),
    processingOrderId?: string(name='processingOrderId', description='The ID of the order that is not complete.', example='-'),
    produced?: int32(name='produced', description='Indicates whether the application is created. Valid values:

*   0: The application is being created.
*   1: The application is created.', example='1'),
    projectId?: string(name='projectId', description='The name of the A/B test group.', example='-'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing unit (LCU).', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
      spec?: string(name='spec', description='The specifications. Valid values:

*   opensearch.share.junior: basic.
*   opensearch.share.common: shared general-purpose.
*   opensearch.share.compute: shared computing.
*   opensearch.share.storage: shared storage.
*   opensearch.private.common: exclusive general-purpose.
*   opensearch.private.compute: exclusive computing.
*   opensearch.private.storage: exclusive storage.', example='opensearch.share.common'),
    }(name='quota', description='The information about the quotas of the application.'),
    resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group.', example='rg-acfmoiyerh6nzly'),
    secondRankAlgoDeploymentId?: int32(name='secondRankAlgoDeploymentId', description='The ID of the created fine sort expression.', example='0'),
    status?: string(name='status', description='The state of the application. Valid values:

*   producing: The application is being created.
*   review_pending: The application is being reviewed.
*   config_pending: The application is to be configured.
*   normal: The application is in service.
*   frozen: The application is frozen.', example='normal'),
    switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='0'),
    tags?: [ 
      {
        key?: string(name='key', description='The tag key.', example='foo'),
        value?: string(name='value', description='The tag value', example='bar'),
      }
    ](name='tags', description='The application tags.'),
    type?: string(name='type', description='The type of the application. Valid values:

*   standard: a High-performance Search Edition application.
*
*   enhanced: an Industry Algorithm Edition application.', example='enhanced'),
    updated?: int32(name='updated', description='The timestamp when the application was last updated.', example='1578916076'),
  }(name='result', description='The information about the application.'),
}

model DescribeAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAppGroupResponseBody(name='body'),
}

async function describeAppGroup(request: DescribeAppGroupRequest): DescribeAppGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeAppGroup', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}', 'json', false, 'json', request);
}

model DescribeAppStatisticsRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app_group_name', example='my_app_group_name', position='Path'),
  appId: string(name='appId', description='110157886', example='110157886', position='Path'),
}

model DescribeAppStatisticsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='76FC45F1-4167-D3CD-6737-4F97BA503FA0'),
  result?: map[string]any(name='result', description='The statistics.', example='{}'),
}

model DescribeAppStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAppStatisticsResponseBody(name='body'),
}

async function describeAppStatistics(request: DescribeAppStatisticsRequest): DescribeAppStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeAppStatistics', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/statistics', 'json', false, 'json', request);
}

model DescribeAppsRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app_group_name', example='my_app_group_name', position='Path'),
}

model DescribeAppsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='77CAA411-0010-4DB9-82E2-1C384E590AFF'),
  result?: [ 
    {
      autoSwitch?: boolean(name='autoSwitch'),
      cluster?: {
        maxQueryClauseLength?: int32(name='maxQueryClauseLength'),
        maxTimeoutMS?: int32(name='maxTimeoutMS'),
      }(name='cluster'),
      clusterName?: string(name='clusterName'),
      dataSources?: [ 
        {
          fields?: [  map[string]any ](name='fields'),
          keyField?: string(name='keyField'),
          parameters?: map[string]any(name='parameters'),
          plugins?: map[string]any(name='plugins'),
          schemaName?: string(name='schemaName'),
          tableName?: string(name='tableName'),
          type?: string(name='type'),
        }
      ](name='dataSources'),
      description?: string(name='description'),
      domain?: {
        category?: string(name='category'),
        functions?: {
          algo?: [ string ](name='algo'),
          qp?: [ string ](name='qp'),
          service?: [ string ](name='service'),
        }(name='functions'),
        name?: string(name='name'),
      }(name='domain'),
      fetchFields?: [ string ](name='fetchFields'),
      firstRanks?: [ 
        {
          active?: boolean(name='active'),
          description?: string(name='description'),
          meta?: any(name='meta'),
          name?: string(name='name'),
          type?: string(name='type'),
        }
      ](name='firstRanks'),
      id?: string(name='id'),
      interpretations?: map[string]any(name='interpretations'),
      isCurrent?: boolean(name='isCurrent'),
      progressPercent?: int32(name='progressPercent'),
      prompts?: [  map[string]any ](name='prompts'),
      queryProcessors?: [ 
        {
          active?: boolean(name='active'),
          category?: string(name='category'),
          domain?: string(name='domain'),
          indexes?: [ string ](name='indexes'),
          name?: string(name='name'),
          processors?: [  map[string]any ](name='processors'),
        }
      ](name='queryProcessors'),
      quota?: {
        computeResource?: int32(name='computeResource'),
        docSize?: int32(name='docSize'),
        qps?: int32(name='qps'),
        spec?: string(name='spec'),
      }(name='quota'),
      schema?: {
        indexSortConfig?: [ 
          {
            direction?: string(name='direction'),
            field?: string(name='field'),
          }
        ](name='indexSortConfig'),
        indexes?: {
          filterFields?: [ string ](name='filterFields'),
          searchFields?: map[string]any(name='searchFields'),
        }(name='indexes'),
        name?: string(name='name'),
        routeField?: string(name='routeField'),
        routeFieldValues?: [ string ](name='routeFieldValues'),
        secondRouteField?: string(name='secondRouteField'),
        tables?: map[string]any(name='tables'),
        ttlField?: {
          name?: string(name='name'),
          ttl?: long(name='ttl'),
        }(name='ttlField'),
      }(name='schema'),
      schemas?: [ 
        {
          indexSortConfig?: [ 
            {
              direction?: string(name='direction'),
              field?: string(name='field'),
            }
          ](name='indexSortConfig'),
          indexes?: {
            filterFields?: [ string ](name='filterFields'),
            searchFields?: map[string]any(name='searchFields'),
          }(name='indexes'),
          name?: string(name='name'),
          routeField?: string(name='routeField'),
          routeFieldValues?: [ string ](name='routeFieldValues'),
          secondRouteField?: string(name='secondRouteField'),
          tables?: map[string]any(name='tables'),
          ttlField?: {
            name?: string(name='name'),
            ttl?: long(name='ttl'),
          }(name='ttlField'),
        }
      ](name='schemas'),
      secondRanks?: [ 
        {
          active?: boolean(name='active'),
          description?: string(name='description'),
          meta?: any(name='meta'),
          name?: string(name='name'),
        }
      ](name='secondRanks'),
      status?: string(name='status'),
      summaries?: [ 
        {
          meta?: [ 
            {
              element?: string(name='element'),
              ellipsis?: string(name='ellipsis'),
              field?: string(name='field'),
              len?: int32(name='len'),
              snippet?: string(name='snippet'),
            }
          ](name='meta'),
          name?: string(name='name'),
        }
      ](name='summaries'),
      type?: string(name='type'),
    }
  ](name='result', description='The information about each version.'),
}

model DescribeAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAppsResponseBody(name='body'),
}

async function describeApps(request: DescribeAppsRequest): DescribeAppsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeApps', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/apps', 'json', false, 'json', request);
}

model DescribeDataCollctionRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application name.', example='my_app_group_name', position='Path'),
  dataCollectionIdentity: string(name='dataCollectionIdentity', description='The ID of the data collection task.', example='286', position='Path'),
}

model DescribeDataCollctionResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='72FAD77B-83F9-F393-BA8E-5834E2427BF8'),
  result?: {
    created?: int32(name='created', description='The time when the task was created.', example='1581065837'),
    dataCollectionType?: string(name='dataCollectionType', description='The type of data collected. Valid values:

*   behavior: behavioral data.
*   item_info: project information.
*   industry_specific: industry-specific data.', example='BEHAVIOR'),
    id?: string(name='id', description='The ID of the data collection task.', example='286'),
    industryName?: string(name='industryName', description='The industry name. Valid values:

*   general
*   ecommerce', example='GENERAL'),
    name?: string(name='name', description='The name of the data collection task.', example='os_function_test_v1'),
    status?: int32(name='status', description='The status of the data collection feature. Valid values:

*   0: The feature is disabled.
*   1: The feature is being enabled.
*   2: The feature is enabled.
*   3: The feature failed to be enabled.', example='2'),
    sundialId?: string(name='sundialId', description='The sundial ID.', example='1755'),
    type?: string(name='type', description='The type of the source from which data was collected. Valid values:

*   server
*   web
*   app Note: Only server is supported.', example='server'),
    updated?: int32(name='updated', description='The time when the data collection task was updated.', example='1581065904'),
  }(name='result', description='The details of the data collection task.'),
}

model DescribeDataCollctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDataCollctionResponseBody(name='body'),
}

async function describeDataCollction(request: DescribeDataCollctionRequest): DescribeDataCollctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeDataCollction', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/data-collections/{dataCollectionIdentity}', 'json', false, 'json', request);
}

model DescribeFirstRankRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app_group_name', example='my_app_group_name', position='Path'),
  appId: int32(name='appId', description='110157886', example='110157886', position='Path'),
  name: string(name='name', description='test', example='test', position='Path'),
}

model DescribeFirstRankResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='false'),
    description?: string(name='description', description='The description of the expression.', example='-'),
    meta?: [ 
      {
        arg?: string(name='arg', description='The parameters that are used by a function in the expression.', example='ar_edit_time'),
        attribute?: string(name='attribute', description='The attribute, feature function, or field to be searched for.', example='timeliness_ms()'),
        weight?: float(name='weight', description='The weight.

Valid values: \\[-100000,100000] (excluding 0).', example='1'),
      }
    ](name='meta', description='The content of the expression.'),
    name?: string(name='name', description='The name of the expression.', example='ar_wear_edit_time'),
  }(name='result', description='The information about the rough sort expression.'),
}

model DescribeFirstRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFirstRankResponseBody(name='body'),
}

async function describeFirstRank(request: DescribeFirstRankRequest): DescribeFirstRankResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeFirstRank', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/first-ranks/{name}', 'json', false, 'json', request);
}

model DescribeInterventionDictionaryRequest {
  name: string(name='name', description='my_dict', example='my_dict', position='Path'),
}

model DescribeInterventionDictionaryResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D7CCF454-472A-030E-F254-604520B028AA'),
  result?: {
    analyzer?: string(name='analyzer', description='The custom analyzer.', example='-'),
    created?: string(name='created', description='The time when the intervention dictionary was created.', example='1536233287'),
    name?: string(name='name', description='The name of the intervention dictionary.', example='test'),
    type?: string(name='type', description='The type of the intervention dictionary. Valid values:

*   stopword: an intervention dictionary for stop word filtering
*   synonym: an intervention dictionary for synonym configuration
*   correction: an intervention dictionary for spelling correction
*   category_prediction: an intervention dictionary for category prediction
*   ner: an intervention dictionary for named entity recognition (NER)
*   term_weighting: an intervention dictionary for term weight analysis', example='category_prediction'),
    updated?: string(name='updated', description='The time when the intervention dictionary was last updated.', example='1536233287'),
  }(name='result', description='The information the intervention dictionary.'),
}

model DescribeInterventionDictionaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInterventionDictionaryResponseBody(name='body'),
}

async function describeInterventionDictionary(request: DescribeInterventionDictionaryRequest): DescribeInterventionDictionaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeInterventionDictionary', 'GET', '/v4/openapi/intervention-dictionaries/{name}', 'json', false, 'json', request);
}

model DescribeQueryProcessorRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app_group_name', example='my_app_group_name', position='Path'),
  appId: int32(name='appId', description='110157886', example='110157886', position='Path'),
  name: string(name='name', description='test', example='test', position='Path'),
}

model DescribeQueryProcessorResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the query analysis rule is the default one.', example='true'),
    created?: int32(name='created', description='The time when the query analysis rule was created.', example='1587398402'),
    domain?: string(name='domain', description='The type of the industry. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='GENERAL'),
    indexes?: [ string ](name='indexes', description='The indexes to which the query analysis rule applies.'),
    name?: string(name='name', description='The name of the query analysis rule.', example='test'),
    processors?: [  map[string]any ](name='processors', description='The features that are used in the query analysis rule.'),
    updated?: int32(name='updated', description='The time when the query analysis rule was last updated.', example='1587398402'),
  }(name='result', description='The information about the query analysis rule.'),
}

model DescribeQueryProcessorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeQueryProcessorResponseBody(name='body'),
}

async function describeQueryProcessor(request: DescribeQueryProcessorRequest): DescribeQueryProcessorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeQueryProcessor', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/query-processors/{name}', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='3B7E42BD-1D63-2F6B-C8E0-41BACEA76EEB'),
  result?: [ 
    {
      consoleUrl?: string(name='consoleUrl', description='The console URL.', example='https://opensearch-cn-hangzhou.console.aliyun.com'),
      endpoint?: string(name='endpoint', description='The endpoint.', example='opensearch.cn-hangzhou.aliyuncs.com'),
      localName?: string(name='localName', description='The region name.', example='China (Hangzhou)'),
      regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
    }
  ](name='result', description='The results returned.'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeRegions', 'GET', '/v4/openapi/regions', 'json', false, 'json', request);
}

model DescribeScheduledTaskRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application', example='my_app_group_name', position='Path'),
  taskId: string(name='taskId', description='The ID of the task.', example='2f12c585-5873-11ea-974a-7cd30ad3e268', position='Path'),
}

model DescribeScheduledTaskResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='922DC0D9-31B5-45F9-47B7-37DC678D61A8'),
  result?: map[string]any(name='result', description='The details of the scheduled task.', example='{}'),
}

model DescribeScheduledTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeScheduledTaskResponseBody(name='body'),
}

async function describeScheduledTask(request: DescribeScheduledTaskRequest): DescribeScheduledTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeScheduledTask', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/scheduled-tasks/{taskId}', 'json', false, 'json', request);
}

model DescribeSecondRankRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app_group_name', example='my_app_group_name', position='Path'),
  appId: int32(name='appId', description='110157886', example='110157886', position='Path'),
  name: string(name='name', description='test', example='test', position='Path'),
}

model DescribeSecondRankResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
    created?: int32(name='created', description='The time when the expression was created.', example='1587052801'),
    description?: string(name='description', description='The description of the expression.', example='-'),
    id?: string(name='id', description='The ID of the expression. This parameter appears only in the response.', example='89047'),
    isDefault?: string(name='isDefault', description='Indicates whether the expression is the default one. This parameter appears only in the response. Valid values:

*   true
*   false', example='true'),
    isSys?: string(name='isSys', description='Indicates whether the expression is a system expression. This parameter appears only in the response. Valid values:

*   true
*   false', example='false'),
    meta?: string(name='meta', description='The content of the fine sort expression.

You can define an expression that consists of fields, feature functions, and mathematical functions to implement complex sort logic.', example='random()+now()'),
    name?: string(name='name', description='The name of the expression.', example='tests'),
    updated?: int32(name='updated', description='The time when the expression was last updated.', example='1587052801'),
  }(name='result', description='The information about the fine sort expression.'),
}

model DescribeSecondRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSecondRankResponseBody(name='body'),
}

async function describeSecondRank(request: DescribeSecondRankRequest): DescribeSecondRankResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeSecondRank', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/second-ranks/{name}', 'json', false, 'json', request);
}

model DescribeSlowQueryStatusRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app_group_name', example='my_app_group_name', position='Path'),
}

model DescribeSlowQueryStatusResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='5C1C1C45-C64A-AD30-565F-140871D57E5E'),
  result?: {
    appGroupId?: string(name='appGroupId', description='The ID of the application.', example='100298370'),
    region?: string(name='region', description='The network type of the slow query optimization service. Valid values:

*   outer: the Internet
*   internal: the internal network', example='internal'),
    status?: string(name='status', description='The status of the slow query optimization service. Valid values:

*   enabled
*   disabled
*   n/a', example='disabled'),
  }(name='result', description='The return result.'),
}

model DescribeSlowQueryStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSlowQueryStatusResponseBody(name='body'),
}

async function describeSlowQueryStatus(request: DescribeSlowQueryStatusRequest): DescribeSlowQueryStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeSlowQueryStatus', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/optimizers/slow-query', 'json', false, 'json', request);
}

model DescribeUserAnalyzerRequest {
  name: string(name='name', description='The name of the analyzer.', example='kevin_test', position='Path'),
  with?: string(name='with', description='The Associated information,output properties based on hierarchy.
* **all**: Outputs associated app information', example='all', position='Query'),
}

model DescribeUserAnalyzerResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='FFAEF396-10EF-53C7-1F51-518853880729'),
  result?: map[string]any(name='result', description='The details of the custom analyzer.', example='{}'),
}

model DescribeUserAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUserAnalyzerResponseBody(name='body'),
}

async function describeUserAnalyzer(request: DescribeUserAnalyzerRequest): DescribeUserAnalyzerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeUserAnalyzer', 'GET', '/v4/openapi/user-analyzers/{name}', 'json', false, 'json', request);
}

model DisableSlowQueryRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app_group_name', example='my_app_group_name', position='Path'),
}

model DisableSlowQueryResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='728E89C6-8673-D39B-39A1-5BA2B56D448F'),
  result?: map[string]any(name='result', description='The return result.', example='{}'),
}

model DisableSlowQueryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableSlowQueryResponseBody(name='body'),
}

async function disableSlowQuery(request: DisableSlowQueryRequest): DisableSlowQueryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DisableSlowQuery', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/optimizers/slow-query/actions/disable', 'json', false, 'json', request);
}

model EnableSlowQueryRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app_group_name', example='my_app_group_name', position='Path'),
}

model EnableSlowQueryResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='728E89C6-8673-D39B-39A1-5BA2B56D448F'),
  result?: map[string]any(name='result', description='The return result.', example='{}'),
}

model EnableSlowQueryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableSlowQueryResponseBody(name='body'),
}

async function enableSlowQuery(request: EnableSlowQueryRequest): EnableSlowQueryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'EnableSlowQuery', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/optimizers/slow-query/actions/enable', 'json', false, 'json', request);
}

model GenerateMergedTableRequest {
  body?: Schema(name='body', description='The request body parameters.', position='Body'),
  spec?: string(name='spec', description='The specifications of the OpenSearch instance. This parameter is used to check whether the OpenSearch instance meets the special limits on an exclusive instance.

Default value: opensearch.share.common.

For more information, see the description of the spec field in the Quota topic.', example='"opensearch.share.common"', position='Query'),
}

model GenerateMergedTableResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: {
    fromTable?: map[string]any(name='fromTable', description='The tables on which the JOIN operation is performed.', example='-'),
    mergeTable?: map[string]any(name='mergeTable', description='The wide table that is generated after the JOIN operation is performed on multiple tables.', example='-'),
    primaryKey?: string(name='primaryKey', description='The primary key.', example='-'),
  }(name='result', description='The response parameters.'),
}

model GenerateMergedTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GenerateMergedTableResponseBody(name='body'),
}

async function generateMergedTable(request: GenerateMergedTableRequest): GenerateMergedTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GenerateMergedTable', 'POST', '/v4/openapi/assist/schema/actions/merge', 'json', false, 'json', request);
}

model GetDomainRequest {
  domainName: string(name='domainName', description='The type of the industry.', example='-', position='Path'),
  appGroupIdentity: string(name='appGroupIdentity', description='The name or ID of the application.', example='my_app_group_name', position='Query'),
}

model GetDomainResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='The returned result.', example='-'),
}

model GetDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDomainResponseBody(name='body'),
}

async function getDomain(request: GetDomainRequest): GetDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetDomain', 'GET', '/v4/openapi/domains/{domainName}', 'json', false, 'json', request);
}

model GetFunctionCurrentVersionRequest {
  functionName: string(name='functionName', description='The name of the feature. Valid values:

*   ctr: click-through rate (CTR) model
*   pop: popularity model
*   category: category model
*   hot: hotword model
*   hint: shading model
*   suggest: drop-down suggestion model
*   analyzer: word segmentation model
*   termweight: word weight model', example='ctr', position='Path'),
  category?: string(name='category', description='The category. By default, this parameter is left empty.', example='general', position='Query'),
  domain?: string(name='domain', description='The industry. By default, this parameter is left empty, which indicates General-purpose Edition.', example='ecommerce', position='Query'),
  functionType?: string(name='functionType', description='The type of the feature. Valid values:

*   PAAS. This is the default value.
*   SAAS.', example='PAAS', position='Query'),
  modelType: string(name='modelType', description='The type of the model. The following features correspond to different model types:

*   CTR model: tf_checkpoint
*   Popularity model: pop
*   Category model: offline_inference
*   Hotword model: offline_inference
*   Shading model: offline_inference
*   Drop-down suggestion model: offline_inference
*   Word segmentation model: text
*   Word weight model: tf_checkpoint', example='tf_checkpoint', position='Query'),
}

model GetFunctionCurrentVersionResponseBody = {
  code?: string(name='Code', description='The error code.', example='Version.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='version not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1638157479281'),
  result?: {
    functionName?: string(name='FunctionName', description='The name of the feature.', example='ctr'),
    functionType?: string(name='FunctionType', description='The type of the feature. Valid values:

*   PAAS
*   SAAS', example='PAAS'),
    modelType?: string(name='ModelType', description='The type of the model.', example='tf_checkpoint'),
    versionConfig?: {
      createParameters?: [ 
        {
          name?: string(name='Name', description='The name of the parameter.', example='params1'),
          required?: string(name='Required', description='Indicates whether the parameter is required.', example='true'),
        }
      ](name='CreateParameters', description='The parameters that are used to create the instance.', example='[                 {                     "name": "params1",                     "required": "true",                     "formItemProps": "{\\"required\\": true, \\"pattern?\\": \\"/^[a-zA-Z][a-zA-Z0-9_]{0,29}$/\\"}",                     "componentProps": "{\\"component\\": \\"Input\\", \\"attributes\\": {\\"defaultValue\\": \\"value1\\"}}"                 }             ]'),
      depends?: [ 
        {
          condition?: string(name='Condition', description='The condition.', example='""'),
          dependency?: string(name='Dependency', description='The dependency.', example='""'),
          description?: string(name='Description', description='The description.', example='""'),
        }
      ](name='Depends', description='The dependencies of the instance.'),
      usageParameters?: [ 
        {
          name?: string(name='Name', description='The name of the parameter.', example='""'),
          required?: string(name='Required', description='Indicates whether the parameter is required.', example='""'),
        }
      ](name='UsageParameters', description='The parameters that are used to use the instance online.', example='[]'),
    }(name='VersionConfig', description='The configuration information about the instance.'),
    versionId?: long(name='VersionId', description='The ID of the version.', example='101'),
    versionName?: string(name='VersionName', description='The name of the version.', example='v1'),
  }(name='Result', description='The result of the request.'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model GetFunctionCurrentVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionCurrentVersionResponseBody(name='body'),
}

async function getFunctionCurrentVersion(request: GetFunctionCurrentVersionRequest): GetFunctionCurrentVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunctionCurrentVersion', 'GET', '/v4/openapi/functions/{functionName}/current-version', 'json', false, 'json', request);
}

model GetFunctionDefaultInstanceRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='my_app_group_name', position='Path'),
  functionName: string(name='functionName', description='The name of the feature.', example='ctr', position='Path'),
}

model GetFunctionDefaultInstanceResponseBody = {
  code?: string(name='Code', description='The error code.', example='DefaultInstance.NotExist'),
  functionName?: string(name='FunctionName', description='The name of the feature.', example='cdn_waf'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  instanceName?: string(name='InstanceName', description='The name of the instance.', example='sh-bp1oi31w1jn4ctdyv'),
  latency?: long(name='Latency', description='The default running time.', example='123'),
  message?: string(name='Message', description='The error message.', example='default instance not set.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='062BA91F-A568-5779-8A5B-9E62C9BB3DC1'),
  result?: {
    instanceName?: string(name='InstanceName', description='The default instance name.', example='model1'),
  }(name='Result', description='The result of the request.', example='{\\"Pagination\\": {\\"TotalCount\\": 0, \\"PageNumber\\": 1, \\"PageSize\\": 10}, \\"AntConsortiums\\": []}'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model GetFunctionDefaultInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionDefaultInstanceResponseBody(name='body'),
}

async function getFunctionDefaultInstance(request: GetFunctionDefaultInstanceRequest): GetFunctionDefaultInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunctionDefaultInstance', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/functions/{functionName}/default-instance', 'json', false, 'json', request);
}

model GetFunctionInstanceRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='150057101', position='Path'),
  functionName: string(name='functionName', description='The name of the feature.', example='ctr', position='Path'),
  instanceName: string(name='instanceName', description='The name of the instance.', example='ctr_test', position='Path'),
  output?: string(name='output', description='Specifies the richness of returned information. Valid values:

*   simple: displays only the basic information.
*   normal: displays information such as createParameters and cron. This is the default value.
*   detail: returns the details of the training task.', example='detail', position='Query'),
}

model GetFunctionInstanceResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, this parameter is left empty.', example='Instance.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='instance not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='68ED4E1B-92B8-5821-A886-9C90686139EB'),
  result?: {
    belongs?: {
      category?: string(name='Category', description='The category.', example='general'),
      domain?: string(name='Domain', description='The industry.', example='ecommerce'),
      language?: string(name='Language', description='The abbreviation of the language that applies.', example='zh'),
    }(name='Belongs', description='The information about the instance.'),
    createParameters?: [ 
      {
        name?: string(name='Name', description='The name of the parameter.', example='param1'),
        value?: string(name='Value', description='The value of the parameter.', example='value1'),
      }
    ](name='CreateParameters', description='The parameters that are used to create the instance.'),
    createTime?: long(name='CreateTime', description='The time when the task was created. Unit: milliseconds.', example='1234'),
    cron?: string(name='Cron', description='The cron expression used to schedule training, in the format of (Minutes Hours DayofMonth Month DayofWeek). If the value is empty, it indicates that no periodic training is performed.', example='0 3 ? \\* 0,1,3,5 (at 3 a.m. on Sunday, Monday, Wednesday, and Friday)'),
    description?: string(name='Description', description='The description of the instance.', example='instance descriptions'),
    extendInfo?: string(name='ExtendInfo', description='The extended information, which is a JSON string.', example='{\\"dataReport\\":{},\\"errors\\":{}}'),
    functionName?: string(name='FunctionName', description='The name of the feature.', example='ctr'),
    functionType?: string(name='FunctionType', description='The type of the feature.', example='PAAS'),
    instanceName?: string(name='InstanceName', description='The name of the instance.', example='ctr_test'),
    modelType?: string(name='ModelType', description='The type of the model.', example='tf_checkpoint'),
    source?: string(name='Source', description='How the instance is created. Valid values:

*   user: The instance is created by user.
*   builtin: The instance is created by the system.', example='user'),
    status?: string(name='Status', description='The status of the instance. Valid values:

1.  unavailable: No model is available. Models must be trained before you can use them.
2.  available: Models can be used.', example='available'),
    task?: {
      dagStatus?: string(name='DagStatus', description='The status of the task. Valid values:

*   success: succeeded
*   failed: failed
*   untrained: to be trained
*   pending: being scheduled
*   running: being trained', example='success'),
      lastRunTime?: long(name='LastRunTime', description='The time consumed for the most recent run, in milliseconds.', example='1234'),
    }(name='Task', description='The information about the training task. This parameter is not displayed if no task is available.'),
    usageParameters?: [ 
      {
        name?: string(name='Name', description='The name of the parameter.', example='use_param1'),
        value?: string(name='Value', description='The value of the parameter.', example='value1'),
      }
    ](name='UsageParameters', description='The parameters that are used.'),
    versionId?: long(name='VersionId', description='The ID of the version.', example='101'),
  }(name='Result', description='The details of the instance.', example='{}'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model GetFunctionInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionInstanceResponseBody(name='body'),
}

async function getFunctionInstance(request: GetFunctionInstanceRequest): GetFunctionInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunctionInstance', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/functions/{functionName}/instances/{instanceName}', 'json', false, 'json', request);
}

model GetFunctionResourceRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The ID of the application.', example='my_app_group_name', position='Path'),
  functionName: string(name='functionName', description='The name of the feature.', example='rank', position='Path'),
  resourceName: string(name='resourceName', description='The name of the instance.', example='fg_json', position='Path'),
  output?: string(name='output', description='The output level.

Valid values:

*   simple
*   normal
*   detail', example='detail', position='Query'),
}

model GetFunctionResourceResponseBody = {
  code?: string(name='Code', description='The error code returned. If no error occurs, this value is empty.', example='Resource.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code returned.', example='200'),
  latency?: double(name='Latency', description='The time consumed for the API request. Unit: milliseconds.', example='123'),
  message?: string(name='Message', description='The error message returned.', example='Resource not exist.'),
  requestId?: string(name='RequestId', description='The request ID.', example='E215C843-0795-5293-AC9A-14FE0723E890'),
  result?: {
    createTime?: long(name='CreateTime', description='The time when the resource was created. Unit: milliseconds.', example='1234'),
    data?: {
      content?: string(name='Content', description='The content of the file that corresponds to a resource of the raw_file type.', example='abc'),
      generators?: [ 
        {
          generator?: string(name='Generator', description='The type of the feature generator.', example='id'),
          input?: {
            features?: [ 
              {
                name?: string(name='Name', description='The name of the feature.', example='system_item_id'),
                type?: string(name='Type', description='The type of the feature.', example='item'),
              }
            ](name='Features', description='The input features.'),
          }(name='Input', description='The input.'),
          output?: string(name='Output', description='The name of the output feature.', example='output_feature_name'),
        }
      ](name='Generators', description='The feature generators that correspond to resources of the feature_generator type.'),
    }(name='Data', description='The resource data. The data structure varies with the resource type.'),
    description?: string(name='Description', description='The description of the resource.', example='""'),
    functionName?: string(name='FunctionName', description='The name of the feature.', example='rank'),
    modifyTime?: long(name='ModifyTime', description='The time when the resource was modified. Unit: milliseconds.', example='1234'),
    referencedInstances?: [ string ](name='ReferencedInstances', description='The algorithm instances that are referenced.'),
    resourceName?: string(name='ResourceName', description='The name of the resource.', example='fg_json'),
    resourceType?: string(name='ResourceType', description='The type of the resource.', example='raw_file'),
  }(name='Result', description='The returned results.'),
  status?: string(name='Status', description='The HTTP status code. Valid values:

*   OK
*   FAIL', example='OK'),
}

model GetFunctionResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionResourceResponseBody(name='body'),
}

async function getFunctionResource(request: GetFunctionResourceRequest): GetFunctionResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunctionResource', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/functions/{functionName}/resources/{resourceName}', 'json', false, 'json', request);
}

model GetFunctionTaskRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='my_app_group_name', position='Path'),
  functionName: string(name='functionName', description='The name of the feature.', example='ctr', position='Path'),
  instanceName: string(name='instanceName', description='The name of the instance.', example='test_model_2', position='Path'),
  generation: string(name='generation', description='The number of iterations.', example='1', position='Path'),
}

model GetFunctionTaskResponseBody = {
  code?: string(name='Code', description='The error code.', example='Task.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='operation success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A4D487A9-A456-5AA5-A9C6-B7BF2889CF74'),
  result?: {
    endTime?: long(name='EndTime', description='The timestamp that indicates the end time of the task. Unit: milliseconds.', example='1647213406267'),
    extendInfo?: string(name='ExtendInfo', description='The extended information, which is a JSON string.', example='{\\"recall\\":91,\\"errors\\":[]}'),
    functionName?: string(name='FunctionName', description='The name of the feature.', example='ctr'),
    generation?: string(name='Generation', description='The number of iterations.', example='1'),
    progress?: long(name='Progress', description='The progress. 90 indicates 90%.', example='90'),
    runId?: string(name='RunId', description='The ID of the task.', example='trigger__2021-03-05T12:18:41'),
    startTime?: long(name='StartTime', description='The timestamp that indicates the start time of the task. Unit: milliseconds.', example='1647212220000'),
    status?: string(name='Status', description='The status of the task. Valid values:

*   success
*   failed
*   running', example='success'),
  }(name='Result', description='The result of the request.'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model GetFunctionTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionTaskResponseBody(name='body'),
}

async function getFunctionTask(request: GetFunctionTaskRequest): GetFunctionTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunctionTask', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/functions/{functionName}/instances/{instanceName}/tasks/{generation}', 'json', false, 'json', request);
}

model GetFunctionVersionRequest {
  functionName: string(name='functionName', description='The name of the feature.', example='ctr', position='Path'),
  versionId: int32(name='versionId', description='The ID of the version.', example='100', position='Path'),
}

model GetFunctionVersionResponseBody = {
  code?: string(name='Code', description='The error code.', example='Version.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The maximum duration for which a task can be executed.', example='123'),
  message?: string(name='Message', description='The error message.', example='version not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1638157479281'),
  result?: {
    functionName?: string(name='FunctionName', description='The name of the feature.', example='ctr'),
    functionType?: string(name='FunctionType', description='The type of the feature. Valid values:

*   PAAS
*   SAAS', example='PAAS'),
    modelType?: string(name='ModelType', description='The type of the model.', example='tf_checkpoint'),
    versionConfig?: {
      createParameters?: [ 
        {
          name?: string(name='Name', description='The name of the parameter.', example='params1'),
          required?: string(name='Required', description='Indicates whether the parameter is required.', example='true'),
        }
      ](name='CreateParameters', description='The parameters that are used to create the instance.', example='[                 {                     "name": "params1",                     "required": "true",                     "formItemProps": "{\\"required\\": true, \\"pattern?\\": \\"/^[a-zA-Z][a-zA-Z0-9_]{0,29}$/\\"}",                     "componentProps": "{\\"component\\": \\"Input\\", \\"attributes\\": {\\"defaultValue\\": \\"value1\\"}}"                 }             ]'),
      depends?: [ 
        {
          condition?: string(name='Condition', description='The condition.', example='""'),
          dependency?: string(name='Dependency', description='The dependency.', example='""'),
          description?: string(name='Description', description='The description.', example='""'),
        }
      ](name='Depends', description='The dependencies of the instance.'),
      usageParameters?: [ 
        {
          name?: string(name='Name', description='The name of the instance.', example='""'),
          required?: string(name='Required', description='Indicates whether the parameter is required.', example='""'),
        }
      ](name='UsageParameters', description='The parameters that are used during online use of the instance.', example='[]'),
    }(name='VersionConfig', description='The configuration information.'),
    versionId?: long(name='VersionId', description='The ID of the version.', example='101'),
    versionName?: string(name='VersionName', description='The name of the version.', example='v1'),
  }(name='Result', description='The result body.', example='[]'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model GetFunctionVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionVersionResponseBody(name='body'),
}

async function getFunctionVersion(request: GetFunctionVersionRequest): GetFunctionVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunctionVersion', 'GET', '/v4/openapi/functions/{functionName}/versions/{versionId}', 'json', false, 'json', request);
}

model GetScriptFileNamesRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app', example='my_app', position='Path'),
  appVersionId: string(name='appVersionId', description='123456', example='123456', position='Path'),
  scriptName: string(name='scriptName', description='file_names', example='file_names', position='Path'),
}

model GetScriptFileNamesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
  result?: [ 
    {
      createTime?: string(name='createTime', description='The time when the script file was created.', example='2020-04-02 20:21:14'),
      fileName?: string(name='fileName', description='The name of the script file.', example='my_cava_script.cava'),
      modifyTime?: string(name='modifyTime', description='The time when the script file was last modified.', example='2020-04-02 21:21:14'),
      pathName?: string(name='pathName', description='The path name of the script file.', example='src'),
    }
  ](name='result', description='The files of the script.'),
}

model GetScriptFileNamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetScriptFileNamesResponseBody(name='body'),
}

async function getScriptFileNames(request: GetScriptFileNamesRequest): GetScriptFileNamesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetScriptFileNames', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appVersionId}/sort-scripts/{scriptName}/file-names', 'json', false, 'json', request);
}

model GetSearchStrategyRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The ID of the application.', example='my_app_group_name', position='Path'),
  appId: string(name='appId', description='The version of the application.', example='110157886', position='Path'),
  strategyName: string(name='strategyName', description='The name of the policy.', example='default', position='Path'),
}

model GetSearchStrategyResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='5C1C1C45-C64A-AD30-565F-140871D57E5E'),
}

model GetSearchStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSearchStrategyResponseBody(name='body'),
}

async function getSearchStrategy(request: GetSearchStrategyRequest): GetSearchStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetSearchStrategy', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/search-strategies/{strategyName}', 'json', false, 'json', request);
}

model GetSortScriptRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name or ID of the application.', example='my_app', position='Path'),
  scriptName: string(name='scriptName', description='The name of the script.', example='script1', position='Path'),
  appVersionId: string(name='appVersionId', description='The version ID of the application.', example='160051478', position='Path'),
}

model GetSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: {
    createTime?: string(name='createTime', description='The time when the script was created.', example='2020-04-02 20:21:14'),
    modifyTime?: string(name='modifyTime', description='The time when the script was last modified.', example='2020-04-02 21:21:14'),
    scope?: string(name='scope', description='The sort phase to which the script applies.', example='second_rank'),
    scriptName?: string(name='scriptName', description='The name of the script.', example='rank_cava_20230606_v7'),
    status?: string(name='status', description='The status of the script. For more information, see the description of the status response parameter in the ListSortScripts topic.', example='released'),
    type?: string(name='type', description='The type of the script.', example='cava_script'),
  }(name='result', description='The details of the script.'),
}

model GetSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSortScriptResponseBody(name='body'),
}

async function getSortScript(request: GetSortScriptRequest): GetSortScriptResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetSortScript', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appVersionId}/sort-scripts/{scriptName}', 'json', false, 'json', request);
}

model GetSortScriptFileRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name or ID of the application.', example='my_app', position='Path'),
  scriptName: string(name='scriptName', description='The name of the script.', example='UserScorer.cava', position='Path'),
  appVersionId: string(name='appVersionId', description='The version ID of the application.', example='123456', position='Path'),
  fileName: string(name='fileName', description='The name of the script file.', example='script1', position='Path'),
}

model GetSortScriptFileResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: {
    content?: string(name='content', description='The script content that is encoded in the Base64 format.', example='YWJjZGVmZw=='),
    createTime?: string(name='createTime', description='The time when the script was created.', example='2020-04-02 20:21:14'),
    modifyTime?: string(name='modifyTime', description='The time when the script was last modified.', example='2020-04-02 21:21:14'),
    version?: long(name='version', description='The version of the script content.', example='123456'),
  }(name='result', description='The content of the sort script.'),
}

model GetSortScriptFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSortScriptFileResponseBody(name='body'),
}

async function getSortScriptFile(request: GetSortScriptFileRequest): GetSortScriptFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetSortScriptFile', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appVersionId}/sort-scripts/{scriptName}/files/src/{fileName}', 'json', false, 'json', request);
}

model ListABTestExperimentsRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application name.', example='“my_app_group_name”', position='Path'),
  sceneId: int32(name='sceneId', description='The scenario ID.', example='13467', minimum=-1, maximum=999999999, position='Path'),
  groupId: int32(name='groupId', description='The group ID.', example='20404', minimum=-1, maximum=999999999, position='Path'),
}

model ListABTestExperimentsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ 
    {
      created?: int32(name='created', description='The time when the experiment was created.', example='1588842080'),
      id?: string(name='id', description='The experiment ID.', example='12888'),
      name?: string(name='name', description='The group alias.', example='test1'),
      online?: boolean(name='online', description='Indicates whether the experiment is in effect. Valid values:

*   true
*   false', example='true'),
      params?: map[string]any(name='params', description='The experiment parameters.', example='1'),
      traffic?: int32(name='traffic', description='The percentage of traffic that is routed to the experiment.

Valid values: \\[0,100]', example='30'),
      updated?: int32(name='updated', description='The time when the experiment was last modified.', example='1588842080'),
    }
  ](name='result', description='The experiment details.\\
For more information, see [ABTestExperiment](~~173617~~).'),
}

model ListABTestExperimentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListABTestExperimentsResponseBody(name='body'),
}

async function listABTestExperiments(request: ListABTestExperimentsRequest): ListABTestExperimentsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListABTestExperiments', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/scenes/{sceneId}/groups/{groupId}/experiments', 'json', false, 'json', request);
}

model ListABTestFixedFlowDividersRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='"my_app_group_name"', example='“my_app_group_name”', position='Path'),
  sceneId: int32(name='sceneId', description='12889', example='12889', minimum=-1, maximum=999999999, position='Path'),
  groupId: int32(name='groupId', description='13467', example='13467', minimum=-1, maximum=999999999, position='Path'),
  experimentId: int32(name='experimentId', description='20404', example='20404', minimum=-1, maximum=999999999, position='Path'),
}

model ListABTestFixedFlowDividersResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ string ](name='result', description='The queried whitelists.'),
}

model ListABTestFixedFlowDividersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListABTestFixedFlowDividersResponseBody(name='body'),
}

async function listABTestFixedFlowDividers(request: ListABTestFixedFlowDividersRequest): ListABTestFixedFlowDividersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListABTestFixedFlowDividers', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/scenes/{sceneId}/groups/{groupId}/experiments/{experimentId}/fixed-flow-dividers', 'json', false, 'json', request);
}

model ListABTestGroupsRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application name.', example='“my_app_group_name”', position='Path'),
  sceneId: int32(name='sceneId', description='The scenario ID.', example='20404', minimum=-1, maximum=999999999, position='Path'),
}

model ListABTestGroupsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ 
    {
      created?: int32(name='created', description='The time when the test group was created.', example='1588839490'),
      id?: string(name='id', description='The ID of the test group.', example='13466'),
      name?: string(name='name', description='The name of the test group.', example='Group_2020-5-7_15:23:3'),
      status?: int32(name='status', description='The status of the test group. Valid values:

*   0: not in effect
*   1: in effect', example='1'),
      updated?: int32(name='updated', description='The time when the test group was last modified.', example='1588839490'),
    }
  ](name='result', description='The test groups.

For more information, see [ABTestGroup](~~178935~~).'),
}

model ListABTestGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListABTestGroupsResponseBody(name='body'),
}

async function listABTestGroups(request: ListABTestGroupsRequest): ListABTestGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListABTestGroups', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/scenes/{sceneId}/groups', 'json', false, 'json', request);
}

model ListABTestScenesRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app_group_name', example='my_app_group_name', position='Path'),
}

model ListABTestScenesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ 
    {
      created?: int32(name='created', description='The time when the test scenario was created.', example='1588836130'),
      id?: string(name='id', description='The ID of the test group.', example='20404'),
      name?: string(name='name', description='The name of the test group.', example='kevintest_2020-5-7_15:21:482'),
      status?: int32(name='status', description='The status of the test scenario. Valid values:

*   0: not in effect
*   1: in effect', example='1'),
      updated?: int32(name='updated', description='The time when the test scenario was last modified.', example='1588836129'),
      values?: [ string ](name='values', description='The name of the test scenario.'),
    }
  ](name='result', description='The details of the test scenarios.

For more information, see [ABTestScene](~~173618~~).'),
}

model ListABTestScenesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListABTestScenesResponseBody(name='body'),
}

async function listABTestScenes(request: ListABTestScenesRequest): ListABTestScenesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListABTestScenes', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/scenes', 'json', false, 'json', request);
}

model ListAppGroupsRequest {
  instanceId?: string(name='instanceId', description='The ID of the instance. Exact match is used.', example='ops-cn-xxxx', position='Query'),
  name?: string(name='name', description='The name of the application.', example='my_name', position='Query'),
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10', position='Query'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group.', example='"110123123"', position='Query'),
  sortBy?: int32(name='sortBy', description='The method based on which applications are sorted. Valid values:

*   0: sorts applications in descending order by creation time.
*   1: sorts applications in descending order by modification time.

Default value: 0.', example='0', position='Query'),
  tags?: [ 
    {
      key?: string(name='key', description='The tag key.', example='foo'),
      value?: string(name='value', description='The tag value.', example='bar'),
    }
  ](name='tags', description='The tags.', shrink='json', position='Query'),
  type?: string(name='type', description='The type of the application. Valid values:

*   standard: a High-performance Search Edition application.
*   enhanced: an Industry Algorithm Edition application.', example='standard', position='Query'),
}

model ListAppGroupsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      chargeType?: string(name='chargeType', description='The billing method. Valid values:

*   POSTPAY: pay-as-you-go.
*   PREPAY: subscription.', example='POSTPAY'),
      chargingWay?: int32(name='chargingWay', description='The billable item. Valid values:

*   1: computing resources.
*   2: queries per second (QPS).', example='1'),
      commodityCode?: string(name='commodityCode', description='The commodity code.', example='opensearch'),
      created?: int32(name='created', description='The timestamp when the application was created.', example='1575442875'),
      currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='110116134'),
      description?: string(name='description', description='The description of the application.', example='"xxx"'),
      domain?: string(name='domain', description='The industry of the application.', example='""'),
      engineType?: string(name='engineType'),
      expireOn?: string(name='expireOn', description='The time when the application expired.', example='"xxx"'),
      hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval state of the quotas. Valid values:

*   0: The application is in service.
*   1: The quotas are being reviewed.', example='0'),
      id?: string(name='id', description='The application ID.', example='110116134'),
      instanceId?: string(name='instanceId', description='The instance ID.', example='"xxx"'),
      lockMode?: string(name='lockMode', description='The lock state. Valid values:

*   Unlock: The instance is unlocked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
      lockedByExpiration?: int32(name='lockedByExpiration', description='Indicates whether the instance is automatically locked after it expires.', example='0'),
      name?: string(name='name', description='The application name.', example='os_function_test_v1'),
      produced?: int32(name='produced', description='Indicates whether the application is created. Valid values:

*   0: The application is being created.
*   1: The application is created.', example='1'),
      projectId?: string(name='projectId', description='The name of the A/B test group.', example='"xxx"'),
      quota?: {
        computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing unit (LCU).', example='20'),
        docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
        spec?: string(name='spec', description='The specifications. Valid values:

*   opensearch.share.junior: basic.
*   opensearch.share.common: shared general-purpose.
*   opensearch.share.compute: shared computing.
*   opensearch.share.storage: shared storage.
*   opensearch.private.common: exclusive general-purpose.
*   opensearch.private.compute: exclusive computing.
*   opensearch.private.storage: exclusive storage.', example='opensearch.share.common'),
      }(name='quota', description='The information about the quotas of the application. For more information, see [Quota](~~170001~~).', example='{}'),
      status?: string(name='status', description='The state of the application. Valid values:

*   producing: The application is being created.
*   review_pending: The application is being reviewed.
*   config_pending: The application is to be configured.
*   normal: The application is in service.
*   frozen: The application is frozen.', example='normal'),
      switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='0'),
      tags?: [ 
        {
          key?: string(name='key', description='The tag key.', example='foo'),
          value?: string(name='value', description='The tag value.', example='bar'),
        }
      ](name='tags', description='The application tags.'),
      type?: string(name='type', description='The type of the application. Valid values:

*   standard: a High-performance Search Edition application.
*
*   enhanced: an Industry Algorithm Edition application.', example='enhanced'),
      updated?: int32(name='updated', description='The timestamp when the application was last updated.', example='1578916076'),
    }
  ](name='result', description='The information about the application.

For more information, see [AppGroup](~~170000~~).', example='[]'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='1'),
}

model ListAppGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAppGroupsResponseBody(name='body'),
}

/**
  * *   This operation allows you to query applications by application name, instance ID, and application type.
  * *   This operation allows you to sort the applications based on their creation time.
  * *   This operation supports the parameters for paging.
  *
 */
async function listAppGroups(request: ListAppGroupsRequest): ListAppGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAppGroups', 'GET', '/v4/openapi/app-groups', 'json', false, 'json', request);
}

model ListDataCollectionsRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app_group_name', example='my_app_group_name', position='Path'),
  pageNumber?: int32(name='pageNumber', description='1', example='1', position='Query'),
  pageSize?: int32(name='pageSize', description='10', example='10', position='Query'),
}

model ListDataCollectionsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='959D8782-B130-95EB-86CC-1F6ED447981F'),
  result?: [ 
    {
      created?: int32(name='created', description='The time when the data collection task was created.', example='1581065837'),
      dataCollectionType?: string(name='dataCollectionType', description='The type of the data that is collected by the task. Valid values:

*   behavior: behavioral data
*   item_info: project data
*   industry_specific: industry-specific data', example='BEHAVIOR'),
      id?: string(name='id', description='The ID of the data collection task.', example='286'),
      industryName?: string(name='industryName', description='The industry to which the data collection task applies. Valid values:

*   general
*   ecommerce', example='GENERAL'),
      name?: string(name='name', description='The name of the data collection task.', example='os_function_test_v1'),
      status?: int32(name='status', description='The status of the data collection task. Valid values:

*   0: disabled
*   1: being enabled
*   2: enabled
*   3: failed to be enabled', example='2'),
      sundialId?: string(name='sundialId', description='The ID of the sundial.', example='1755'),
      type?: string(name='type', description='The type of the data source. Valid values:

*   server
*   web
*   app

Note: Only server is supported.', example='server'),
      updated?: int32(name='updated', description='The time when the data collection task was updated.', example='1581065904'),
    }
  ](name='result', description='The details of the data collection tasks.

For more information, see [DataCollection](~~173605~~).'),
  totalCount?: int32(name='totalCount', description='The total number of the returned data collection tasks.', example='1'),
}

model ListDataCollectionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataCollectionsResponseBody(name='body'),
}

async function listDataCollections(request: ListDataCollectionsRequest): ListDataCollectionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDataCollections', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/data-collections', 'json', false, 'json', request);
}

model ListDataSourceTableFieldsRequest {
  dataSourceType: string(name='dataSourceType', description='The type of the data source. Valid values:

*   rds
*   polardb
*   odps
*   mysql
*   drds', example='rds', position='Path'),
  params: string(name='params', description='The parameters of the data source. The value of the params parameter is a JSON string. The value must be URL-encoded.

Different types of data sources use different parameters. For more information, see the following sections of the "DataSource" topic:

*   [rds](~~170005~~)
*   [polardb](~~170005~~)
*   [odps](~~170005~~)
*   [mysql](~~173627~~)
*   [drds](~~173627~~)', example='{}', position='Query'),
  rawType?: boolean(name='rawType', description='Specifies whether to return the original field types of the data source.', example='false', position='Query'),
}

model ListDataSourceTableFieldsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: map[string]any(name='result', description='The returned result.', example='{}'),
}

model ListDataSourceTableFieldsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataSourceTableFieldsResponseBody(name='body'),
}

async function listDataSourceTableFields(request: ListDataSourceTableFieldsRequest): ListDataSourceTableFieldsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDataSourceTableFields', 'GET', '/v4/openapi/assist/data-sources/{dataSourceType}/fields', 'json', false, 'json', request);
}

model ListDataSourceTablesRequest {
  dataSourceType: string(name='dataSourceType', description='rds', example='rds', position='Path'),
  params: string(name='params', description='N/A', example='-', position='Query'),
}

model ListDataSourceTablesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ string ](name='result', description='The data tables.'),
}

model ListDataSourceTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataSourceTablesResponseBody(name='body'),
}

async function listDataSourceTables(request: ListDataSourceTablesRequest): ListDataSourceTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDataSourceTables', 'GET', '/v4/openapi/assist/data-sources/{dataSourceType}/tables', 'json', false, 'json', request);
}

model ListFirstRanksRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app_group_name', example='my_app_group_name', position='Path'),
  appId: int32(name='appId', description='110157886', example='110157886', position='Path'),
}

model ListFirstRanksResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
      created?: int32(name='created', description='The time when the cluster was created.', example='0'),
      description?: string(name='description', description='The description of the expression.', example='""'),
      meta?: [ 
        {
          arg?: string(name='arg', description='The parameters that are used by a function in the expression.

For more information, see [Rough sort functions](~~180765~~).', example='""'),
          attribute?: string(name='attribute', description='The attribute, feature function, or field to be searched for.

For more information about supported feature functions, see [Rough sort functions](~~180765~~).', example='static_bm25()'),
          weight?: int32(name='weight', description='The weight.

Valid values: \\[-100000,100000] (excluding 0).', example='1'),
        }
      ](name='meta', description='The content of the expression.', example='[]'),
      name?: string(name='name', description='The name of the expression.', example='default'),
      updated?: int32(name='updated', description='The time when the cluster was updated.', example='0'),
    }
  ](name='result', description='The information about each rough sort expression.

For more information, see [FirstRank](~~170007~~).', example='[]'),
}

model ListFirstRanksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFirstRanksResponseBody(name='body'),
}

async function listFirstRanks(request: ListFirstRanksRequest): ListFirstRanksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFirstRanks', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/first-ranks', 'json', false, 'json', request);
}

model ListFunctionInstancesRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='app_group_name', position='Path'),
  functionName: string(name='functionName', description='The name of the feature.', example='ctr', position='Path'),
  functionType?: string(name='functionType', description='The type of the feature.', example='"PAAS"', position='Query'),
  modelType?: string(name='modelType', description='The type of the model.', example='tf_checkpoint', position='Query'),
  output?: string(name='output', description='The richness of the returned information. Valid values:

*   normal: displays information such as createParameters and cron. This is the default value.
*   simple: displays only the basic information.
*   detail: returns the details of the training task.', example='normal', position='Query'),
  pageNumber?: int32(name='pageNumber', description='The number of the page to return. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='pageSize', description='The number of entries to return on each page. Default value: 10.', example='10', position='Query'),
  source?: string(name='source', description='How the instance is created. Valid values:

*   builtin: The instance is created by system.
*   user: The instance is created by user. This is the default value.
*   all: all instances', example='user', position='Query'),
}

model ListFunctionInstancesResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, the parameter is left empty.', example='Instance.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message. If no error occurs, the parameter is left empty.', example='instance not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A4D487A9-A456-5AA5-A9C6-B7BF2889CF74'),
  result?: [ 
    {
      belongs?: {
        category?: string(name='Category', description='The category.', example='"general"'),
        domain?: string(name='Domain', description='The industry.', example='"ecommerce"'),
        language?: string(name='Language', description='The abbreviation of the language that applies.', example='"zh"'),
      }(name='Belongs', description='The information about the instance.', example='{}'),
      createParameters?: [ 
        {
          name?: string(name='Name', description='The name of the parameter.', example='"param1"'),
          value?: string(name='Value', description='The value of the parameter.', example='"value1"'),
        }
      ](name='CreateParameters', description='The parameters of the instance.', example='[]'),
      createTime?: long(name='CreateTime', description='The time when the instance was created.', example='1234'),
      cron?: string(name='Cron', description='The cron expression used to schedule training, in the format of (Minutes Hours DayofMonth Month DayofWeek). If the value is empty, it indicates that no periodic training is performed.', example='0 3 ? \\* 0,1,3,5 (at 3 a.m. on Sunday, Monday, Wednesday, and Friday)'),
      description?: string(name='Description', description='The description.', example='" "'),
      extendInfo?: string(name='ExtendInfo', description='The extended information, which is a JSON string. It includes model evaluation information and error information.', example='"{\\"dataReport\\":{},\\"errors\\":{}}"'),
      functionName?: string(name='FunctionName', description='The name of the feature.', example='"ctr"'),
      functionType?: string(name='FunctionType', description='The type of the feature.', example='"PAAS"'),
      instanceName?: string(name='InstanceName', description='The name of the instance.', example='"ctr_test"'),
      modelType?: string(name='ModelType', description='The type of the model.', example='"tf_checkpoint"'),
      source?: string(name='Source', description='How the instance is created. Valid values:

*   user: The instance is created by user.
*   builtin: The instance is created by system.', example='"user"'),
      status?: string(name='Status', description='The state of the instance. Valid values:

1.  unavailable: No model is available. Models must be trained before you can use them.
2.  available: Models can be used.', example='available'),
      usageParameters?: [ 
        {
          name?: string(name='Name', description='The name of the parameter.', example='use_param1'),
          value?: string(name='Value', description='The value of the parameter.', example='value1'),
        }
      ](name='UsageParameters', description='The parameters that are used.'),
      versionId?: long(name='VersionId', description='The ID of the version.', example='123'),
    }
  ](name='Result', description='The information about the instances.', example='[]'),
  status?: string(name='Status', description='The status of the request.', example='"OK"'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model ListFunctionInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionInstancesResponseBody(name='body'),
}

async function listFunctionInstances(request: ListFunctionInstancesRequest): ListFunctionInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFunctionInstances', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/functions/{functionName}/instances', 'json', false, 'json', request);
}

model ListFunctionResourcesRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application ID.', example='my_app_group_name', position='Path'),
  functionName: string(name='functionName', description='The name of the feature.', example='rank', position='Path'),
  output?: string(name='output', description='The output level.

Valid values:

*   simple
*   normal
*   detail', example='detail', position='Query'),
  pageNumber?: int32(name='pageNumber', description='The page number.', example='1', position='Query'),
  pageSize?: int32(name='pageSize', description='The number of entries returned per page.', example='10', position='Query'),
  resourceType?: string(name='resourceType', description='The type of the resource.

Valid values:

*   feature_generator

    <!-- -->

    <!-- -->

    <!-- -->

*   raw_file

    <!-- -->

    <!-- -->

    <!-- -->', example='feature_generator', position='Query'),
}

model ListFunctionResourcesResponseBody = {
  code?: string(name='Code', description='The error code returned. If no error occurs, this value is empty.', example='Resource.InvalidResourceName'),
  httpCode?: long(name='HttpCode', description='The HTTP status code returned.', example='200'),
  latency?: double(name='Latency', description='The amount of time consumed for the request. Unit: milliseconds.', example='123'),
  message?: string(name='Message', description='The error message returned.', example='Invalid resource name.'),
  requestId?: string(name='RequestId', description='The request ID.', example='"3A809095-C554-5CF5-8FCE-BE19D4673790"'),
  result?: [ 
    {
      createTime?: long(name='CreateTime', description='The time when the resource was created. Unit: milliseconds.', example='1234'),
      data?: {
        content?: string(name='Content', description='The content of the file that corresponds to a resource of the raw_file type.', example='"abc"'),
        generators?: [ 
          {
            generator?: string(name='Generator', description='The type of the feature generator.', example='combo'),
            input?: {
              features?: [ 
                {
                  name?: string(name='Name', description='The name of the feature.', example='system_item_id'),
                  type?: string(name='Type', description='The type of the feature.

Valid values:

*   item

    <!-- -->

    <!-- -->

    <!-- -->

*   user

    <!-- -->

    <!-- -->

    <!-- -->', example='item'),
                }
              ](name='Features', description='The input features.'),
            }(name='Input', description='The input.'),
            output?: string(name='Output', description='The name of the output feature.', example='feature1'),
          }
        ](name='Generators', description='The feature generators that correspond to resources of the feature_generator type.'),
      }(name='Data', description='The resource data. The data structure varies with the resource type.'),
      description?: string(name='Description', description='The description of the resource.', example='resource description'),
      functionName?: string(name='FunctionName', description='The name of the feature.', example='rank'),
      modifyTime?: long(name='ModifyTime', description='The time when the resource was modified. Unit: milliseconds.', example='1234'),
      referencedInstances?: [ string ](name='ReferencedInstances', description='The algorithm instances that are referenced.'),
      resourceName?: string(name='ResourceName', description='The name of the resource.', example='fg_json'),
      resourceType?: string(name='ResourceType', description='The type of the resource.', example='feature_generator'),
    }
  ](name='Result', description='The results returned.'),
  status?: string(name='Status', description='The status of the request. Valid values: OK and FAIL.', example='OK'),
  totalCount?: long(name='TotalCount', description='The total number of records that meet the requirements.', example='2'),
}

model ListFunctionResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionResourcesResponseBody(name='body'),
}

async function listFunctionResources(request: ListFunctionResourcesRequest): ListFunctionResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFunctionResources', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/functions/{functionName}/resources', 'json', false, 'json', request);
}

model ListFunctionTasksRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='app_group_name', position='Path'),
  functionName: string(name='functionName', description='The name of the feature.', example='ctr', position='Path'),
  instanceName: string(name='instanceName', description='The name of the instance.', example='test_model_2', position='Path'),
  endTime?: long(name='endTime', description='The end time is less than the specified time. Specify the time in the UNIX timestamp format. Unit: milliseconds.', example='1582646399', position='Query'),
  pageNumber?: int32(name='pageNumber', description='The number of the page to return. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='pageSize', description='The number of entries to return on each page. Default value: 1.', example='10', position='Query'),
  startTime?: long(name='startTime', description='The start time is greater than the specified time. Specify the time in the UNIX timestamp format. Unit: milliseconds.', example='1582214400', position='Query'),
  status?: string(name='status', description='The status of the task. Valid values:

*   success
*   failed
*   running', example='success', position='Query'),
}

model ListFunctionTasksResponseBody = {
  code?: string(name='Code', description='The error code.', example='200'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='fail'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1638157479281'),
  result?: [ 
    {
      endTime?: long(name='EndTime', description='The timestamp that indicates the end time. Unit: milliseconds. 0 indicates that the task has not ended.', example='100010'),
      extendInfo?: string(name='ExtendInfo', description='The value is a JSON string. It includes model evaluation information and training error information.', example='{\\"recall\\":91,\\"errors\\":[]}'),
      functionName?: string(name='FunctionName', description='The name of the feature.', example='ctr'),
      generation?: string(name='Generation', description='The number of iterations.', example='2'),
      progress?: long(name='Progress', description='The progress. 90 indicates 90%.', example='90'),
      runId?: string(name='RunId', description='The ID of the task.', example='trigger__2021-03-05T12:18:41'),
      startTime?: long(name='StartTime', description='The timestamp that indicates the start time. Unit: milliseconds.', example='100010'),
      status?: string(name='Status', description='The status of the task. Valid values:

*   success
*   failed
*   running', example='success'),
    }
  ](name='Result', description='The returned result.', example='[         {             "functionName": "ctr",             "progress": 100,             "status": "success",             "startTime": 100010,             "endTime": 200020,             "extendInfo": "{\\"recall\\":91,\\"errors\\":[]}",             "runId": "trigger__2021-03-05T12:18:41"         }     ]'),
  status?: string(name='Status', description='The status of the request.', example='200'),
  totalCount?: long(name='TotalCount', description='The total number of records that meet the requirements.', example='2'),
}

model ListFunctionTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionTasksResponseBody(name='body'),
}

async function listFunctionTasks(request: ListFunctionTasksRequest): ListFunctionTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFunctionTasks', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/functions/{functionName}/instances/{instanceName}/tasks', 'json', false, 'json', request);
}

model ListInterventionDictionariesRequest {
  pageNumber?: int32(name='pageNumber', description='The number of the page to return. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='pageSize', description='The number of entries to return on each page. Default value: 10.', example='10', position='Query'),
  types?: string(name='types', description='The type of the intervention dictionary. Valid values:

*   stopword: an intervention dictionary for stop word filtering
*   synonym: an intervention dictionary for synonym configuration
*   correction: an intervention dictionary for spelling correction
*   category_prediction: an intervention dictionary for category prediction
*   ner: an intervention dictionary for named entity recognition (NER)
*   term_weighting: an intervention dictionary for term weight analysis', example='["synonym"]', position='Query'),
}

model ListInterventionDictionariesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      analyzer?: string(name='analyzer', description='The custom analyzer.', example='""'),
      created?: int32(name='created', description='The time when the intervention dictionary was created.', example='1539158325'),
      id?: int32(name='id', description='The ID of the intervention dictionary.', example='1'),
      name?: string(name='name', description='The name of the intervention dictionary.', example='tongyici'),
      type?: string(name='type', description='The type of the intervention dictionary. Valid values:

*   stopword: an intervention dictionary for stop word filtering
*   synonym: an intervention dictionary for synonym configuration
*   correction: an intervention dictionary for spelling correction
*   category_prediction: an intervention dictionary for category prediction
*   ner: an intervention dictionary for named entity recognition (NER)
*   term_weighting: an intervention dictionary for term weight analysis', example='synonym'),
      updated?: int32(name='updated', description='The time when the intervention dictionary was last updated.', example='1539158313'),
    }
  ](name='result', description='The information about each intervention dictionary.

For more information, see [InterventionDictionary](~~173608~~).'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='2'),
}

model ListInterventionDictionariesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInterventionDictionariesResponseBody(name='body'),
}

async function listInterventionDictionaries(request: ListInterventionDictionariesRequest): ListInterventionDictionariesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListInterventionDictionaries', 'GET', '/v4/openapi/intervention-dictionaries', 'json', false, 'json', request);
}

model ListInterventionDictionaryEntriesRequest {
  name: string(name='name', description='The name of the intervention dictionary.', example='my_dict', position='Path'),
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='pageSize', description='The number of entries returned per page. Default value: 10.', example='10', position='Query'),
  word?: string(name='word', description='The intervention entry.', example='test', position='Query'),
}

model ListInterventionDictionaryEntriesResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='516A02B7-2167-8D92-12D0-B639A2A0F3C5'),
  result?: [ 
    {
      cmd?: string(name='cmd', description='The command. Valid values:

*   add
*   delete', example='add'),
      created?: long(name='created', description='The timestamp when the intervention entry was created.', example='1536690285'),
      relevance?: map[string]any(name='relevance', description='The content of an intervention entry for category prediction. The field value consists of key-value pairs. The key in a key-value pair indicates the ID of the category. The value in a key-value pair indicates the relevance to the category. A value of 0 indicates irrelevant. A value of 1 indicates slightly relevant. A value of 2 indicates relevant. Example: {"2":1, "100":0}', example='{                 "100": "0",                 "200": "2"             }'),
      status?: string(name='status', description='The status of the intervention entry. Valid value:

*   ACTIVE: The intervention entry takes effect.', example='ACTIVE'),
      tokens?: [ 
        {
          order?: int32(name='order', description='The sequence number.', example='1'),
          tag?: string(name='tag', description='The internal name of the identified entity type. Valid values:

*   brand
*   category
*   material
*   element
*   style
*   color
*   function
*   scenario
*   people
*   season
*   model
*   region
*   name
*   adjective
*   category-modifier
*   size
*   quality
*   suit
*   new-release
*   series
*   marketing
*   entertainment
*   organization
*   movie
*   game
*   number
*   unit
*   common
*   new-word
*   proper-noun
*   symbol
*   prefix
*   suffix
*   gift
*   negative
*   agent', example='category'),
          tagLabel?: string(name='tagLabel', description='The description of the internal name of the identified entity type.', example='category'),
          token?: string(name='token', description='The entity.', example='category'),
        }
      ](name='tokens', description='The content of the intervention entry for term weight analysis.'),
      updated?: long(name='updated', description='The timestamp when the intervention entry was last updated.', example='1537348987'),
      word?: string(name='word', description='The intervention entry.', example='\\u8fc7\\u513f'),
    }
  ](name='result', description='The information about intervention entries.

For more information, see [InterventionDictionaryEntry](~~173606~~).'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='8'),
}

model ListInterventionDictionaryEntriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInterventionDictionaryEntriesResponseBody(name='body'),
}

async function listInterventionDictionaryEntries(request: ListInterventionDictionaryEntriesRequest): ListInterventionDictionaryEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListInterventionDictionaryEntries', 'GET', '/v4/openapi/intervention-dictionaries/{name}/entries', 'json', false, 'json', request);
}

model ListInterventionDictionaryNerResultsRequest {
  name: string(name='name', description='The dictionary name.', example='my_dict', position='Path'),
  query: string(name='query', description='Query keywords.', example='"hello world"', position='Query'),
}

model ListInterventionDictionaryNerResultsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='8F780CA8-D4D4-2FFE-B8AC-42040822C554'),
  result?: [ 
    {
      order?: int32(name='order', description='The sequence number.', example='1'),
      tag?: string(name='tag', description='The internal name of the identified entity type. Valid values:

*   brand
*   category
*   material
*   element
*   style
*   color
*   function
*   scenario
*   people
*   season
*   model
*   region
*   name
*   adjective
*   category-modifier
*   size
*   quality
*   suit
*   new-release
*   series
*   marketing
*   entertainment
*   organization
*   movie
*   game
*   number
*   unit
*   common
*   new-word
*   proper-noun
*   symbol
*   prefix
*   suffix
*   gift
*   negative
*   agent', example='category'),
      tagLabel?: string(name='tagLabel', description='The description of the internal name of the identified entity type.', example='category'),
      token?: string(name='token', description='The entity.', example='eaa73f35-007a-4be7-88c7-37dca4a04ab7'),
    }
  ](name='result', description='The NER result.

For more information, see [InterventionDictionaryEntry](~~173606~~).'),
}

model ListInterventionDictionaryNerResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInterventionDictionaryNerResultsResponseBody(name='body'),
}

async function listInterventionDictionaryNerResults(request: ListInterventionDictionaryNerResultsRequest): ListInterventionDictionaryNerResultsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListInterventionDictionaryNerResults', 'GET', '/v4/openapi/intervention-dictionaries/{name}/ner-results', 'json', false, 'json', request);
}

model ListInterventionDictionaryRelatedEntitiesRequest {
  name: string(name='name', description='my_dict', example='my_dict', position='Path'),
}

model ListInterventionDictionaryRelatedEntitiesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [  map[string]any ](name='result', description='The information about each application and each query analysis rule. If no query analysis rule references the intervention dictionary, the value of the result parameter is an empty list.'),
}

model ListInterventionDictionaryRelatedEntitiesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInterventionDictionaryRelatedEntitiesResponseBody(name='body'),
}

async function listInterventionDictionaryRelatedEntities(request: ListInterventionDictionaryRelatedEntitiesRequest): ListInterventionDictionaryRelatedEntitiesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListInterventionDictionaryRelatedEntities', 'GET', '/v4/openapi/intervention-dictionaries/{name}/related', 'json', false, 'json', request);
}

model ListProceedingsRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The ID of the application instance group.', example='120677456', position='Path'),
  filterFinished?: boolean(name='filterFinished', description='Specifies whether the filtering is complete.', example='true', position='Query'),
}

model ListProceedingsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='F5099063-6B86-F398-D843-905F9EFB683A'),
}

model ListProceedingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProceedingsResponseBody(name='body'),
}

async function listProceedings(request: ListProceedingsRequest): ListProceedingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListProceedings', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/proceedings', 'json', false, 'json', request);
}

model ListQueryProcessorAnalyzerResultsRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application', example='my_app_group_name', position='Path'),
  appId: string(name='appId', description='The version number.', example='"110157886"', position='Path'),
  name: string(name='name', description='The name of the test.', example='"test"', position='Path'),
  text: string(name='text', description='The text to be tested.', example='"abcde"', position='Query'),
}

model ListQueryProcessorAnalyzerResultsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='98724351-D6B2-5D8A-B089-7FFD1821A7E9'),
  result?: map[string]any(name='result', description='The data returned.', example='{}'),
}

model ListQueryProcessorAnalyzerResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueryProcessorAnalyzerResultsResponseBody(name='body'),
}

async function listQueryProcessorAnalyzerResults(request: ListQueryProcessorAnalyzerResultsRequest): ListQueryProcessorAnalyzerResultsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListQueryProcessorAnalyzerResults', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/query-processors/{name}/analyze', 'json', false, 'json', request);
}

model ListQueryProcessorNersRequest {
  domain?: string(name='domain', description='The type of the industry.

*   ECOMMERCE', example='ECOMMERCE', position='Query'),
}

model ListQueryProcessorNersResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      label?: string(name='label', description='The name of the entity type.', example='brand'),
      order?: int32(name='order', description='The priority of an entity type among entity types that have the same priority level. A smaller value indicates a higher priority. Default value: 0.', example='1'),
      priority?: string(name='priority', description='The priority level of the entity type. Valid values:

*   HIGH
*   MIDDLE
*   LOW', example='HIGH'),
      tag?: string(name='tag', description='The internal name of the entity type.', example='brand'),
    }
  ](name='result', description='The priority settings of entity types.

For more information, see [Priority settings of entity types](~~173616~~).'),
}

model ListQueryProcessorNersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueryProcessorNersResponseBody(name='body'),
}

async function listQueryProcessorNers(request: ListQueryProcessorNersRequest): ListQueryProcessorNersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListQueryProcessorNers', 'GET', '/v4/openapi/query-processor/ner/default-priorities', 'json', false, 'json', request);
}

model ListQueryProcessorsRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application name.', example='my_app_group_name', position='Path'),
  appId: int32(name='appId', description='The application version number.', example='110157886', position='Path'),
  isActive?: int32(name='isActive', description='The scope of query analysis rules to be queried. Default value: 0. Valid values:

*   0: queries all query analysis rules.
*   1: queries the default query analysis rules.
*   2: queries the query analysis rules that are not the default rules.', example='0', position='Query'),
}

model ListQueryProcessorsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      active?: boolean(name='active', description='Indicates whether the query analysis rule is a default rule.', example='true'),
      created?: int32(name='created', description='The time when the query analysis rule was created.', example='1587398402'),
      domain?: string(name='domain', description='The type of the industry to which the query analysis rule is applied. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='GENERAL'),
      indexes?: [ string ](name='indexes', description='The indexes to which the query analysis rule is applied.'),
      name?: string(name='name', description='The name of the query analysis rule.', example='ner'),
      processors?: [  map[string]any ](name='processors', description='The features that are used in the query analysis rule.'),
      updated?: int32(name='updated', description='The time when the query analysis rule was last modified.', example='1587398402'),
    }
  ](name='result', description='The information about the query analysis rule.

For more information, see [QueryProcessor](~~170014~~).'),
}

model ListQueryProcessorsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueryProcessorsResponseBody(name='body'),
}

async function listQueryProcessors(request: ListQueryProcessorsRequest): ListQueryProcessorsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListQueryProcessors', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/query-processors', 'json', false, 'json', request);
}

model ListQuotaReviewTasksRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application name.', example='"my_app_name"', position='Path'),
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='pageSize', description='The number of entries to return on each page. Default value: 10.', example='10', position='Query'),
}

model ListQuotaReviewTasksResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='"3351A21F-705B-508C-9450-DA65A681547F"'),
  result?: [ 
    {
      appGroupId?: int32(name='appGroupId', description='The application ID.', example='120123456'),
      appGroupName?: string(name='appGroupName', description='The application name.', example='"td_test_os"'),
      appGroupType?: string(name='appGroupType', description='The application type.', example='"standard"'),
      approved?: boolean(name='approved', description='Indicates whether the ticket is approved.', example='true'),
      available?: boolean(name='available', description='Indicates whether the application is available.', example='true'),
      gmtCreate?: string(name='gmtCreate', description='The time when the ticket was created.', example='"2020-04-08T08:29:45+0000"'),
      gmtModified?: string(name='gmtModified', description='The time when the ticket was last updated.', example='"2020-04-08T08:36:36+0000"'),
      id?: int32(name='id', description='The ticket ID.', example='142'),
      memo?: string(name='memo', description='The remarks.', example='null'),
      newComputeResource?: int32(name='newComputeResource', description='The computing resource quota that is applied for.', example='6000'),
      newSocSize?: int32(name='newSocSize', description='The storage capacity quota that is applied for.', example='1100'),
      newSpec?: string(name='newSpec', description='The application specifications that are applied for.', example='"opensearch.private.common"'),
      oldComputeResource?: int32(name='oldComputeResource', description='The original quota of computing resources.', example='500'),
      oldDocSize?: int32(name='oldDocSize', description='The original quota of storage capacity.', example='900'),
      oldSpec?: string(name='oldSpec', description='The original specifications of the application.', example='"opensearch.private.common"'),
      pending?: boolean(name='pending', description='Indicates whether the ticket is pending.', example='false'),
    }
  ](name='result', description='The information about the tickets. For more information, see [QuotaReviewTask](~~173609~~).', example='[]'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='500'),
}

model ListQuotaReviewTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQuotaReviewTasksResponseBody(name='body'),
}

async function listQuotaReviewTasks(request: ListQuotaReviewTasksRequest): ListQuotaReviewTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListQuotaReviewTasks', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/quota-review-tasks', 'json', false, 'json', request);
}

model ListScheduledTasksRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application name.', example='my_app_group_name', position='Path'),
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10', position='Query'),
  type?: string(name='type', description='The scheduled task type. Valid values:

*   wipe: data cleaning.
*   fork: reindexing.
*   check-status: application status check.
*   index: reindexing.', example='wipe', position='Query'),
}

model ListScheduledTasksResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [  map[string]any ](name='result'),
  totalCount?: long(name='totalCount', description='The total number of entries returned.', example='1'),
}

model ListScheduledTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListScheduledTasksResponseBody(name='body'),
}

async function listScheduledTasks(request: ListScheduledTasksRequest): ListScheduledTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListScheduledTasks', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/scheduled-tasks', 'json', false, 'json', request);
}

model ListSearchStrategiesRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='"my_app"', position='Path'),
  appId: string(name='appId', description='The ID of the version.', example='"110123456"', position='Path'),
}

model ListSearchStrategiesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='9C6351F5-2E2E-5249-888B-88A74E1B8A65'),
}

model ListSearchStrategiesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSearchStrategiesResponseBody(name='body'),
}

async function listSearchStrategies(request: ListSearchStrategiesRequest): ListSearchStrategiesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListSearchStrategies', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/search-strategies', 'json', false, 'json', request);
}

model ListSecondRanksRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app_group_name', example='my_app_group_name', position='Path'),
  appId: int32(name='appId', description='110157886', example='110157886', position='Path'),
}

model ListSecondRanksResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='false'),
      created?: int32(name='created', description='The time when the expression was created.', example='0'),
      description?: string(name='description', description='The description of the expression.', example='""'),
      id?: string(name='id', description='The ID of the expression. This parameter appears only in the response.', example='890473'),
      isDefault?: string(name='isDefault', description='Indicates whether the expression is the default one. This parameter appears only in the response. Valid values:

*   true
*   false', example='false'),
      isSys?: string(name='isSys', description='Indicates whether the expression is a system expression. This parameter appears only in the response. Valid values:

*   true
*   false', example='true'),
      meta?: string(name='meta', description='The content of the fine sort expression.

You can define an expression that consists of fields, feature functions, and mathematical functions to implement complex sort logic.', example='random()+now()'),
      name?: string(name='name', description='The name of the expression.', example='tests'),
      updated?: int32(name='updated', description='The time when the expression was last updated.', example='1587052801'),
    }
  ](name='result', description='The information about each fine sort expression.

For more information, see [SecondRank](~~170008~~).'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='1'),
}

model ListSecondRanksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSecondRanksResponseBody(name='body'),
}

async function listSecondRanks(request: ListSecondRanksRequest): ListSecondRanksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListSecondRanks', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/second-ranks', 'json', false, 'json', request);
}

model ListSlowQueryCategoriesRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application', example='my_app_group_name', position='Path'),
}

model ListSlowQueryCategoriesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='4406F40B-A0A2-9D5D-531F-3B6936567584'),
  result?: {
    analyzeStatus?: string(name='analyzeStatus', description='The status of the analysis. Valid values:

*   PENDING: preparing
*   SUCCESS: succeeded
*   RUNNING: running
*   FAILED: failed
*   N/A: unknown', example='"PENDING"'),
    end?: int32(name='end', description='The timestamp that indicates the end of the time range to query.', example='1589990340'),
    start?: int32(name='start', description='The timestamp that indicates the beginning of the time range to query.', example='1589986800'),
  }(name='result', description='The data returned.'),
}

model ListSlowQueryCategoriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSlowQueryCategoriesResponseBody(name='body'),
}

async function listSlowQueryCategories(request: ListSlowQueryCategoriesRequest): ListSlowQueryCategoriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListSlowQueryCategories', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/optimizers/slow-query/categories', 'json', false, 'json', request);
}

model ListSlowQueryQueriesRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='my_app_group_name', example='my_app_group_name', position='Path'),
  categoryIndex: string(name='categoryIndex', description='0', example='0', position='Path'),
}

model ListSlowQueryQueriesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='EB250CA0-ACFD-C5DE-17CD-01445BFE8AE5'),
  result?: {
    appQuery?: string(name='appQuery', description='The content of the optimization suggestion for the query.', example='no data'),
    end?: int32(name='end', description='The end of the time range that was queried.', example='1589990340'),
    index?: int32(name='index', description='The ID of the optimization suggestion.', example='0'),
    start?: int32(name='start', description='The beginning of the time range that was queried.', example='1589986800'),
  }(name='result', description='The return result.'),
}

model ListSlowQueryQueriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSlowQueryQueriesResponseBody(name='body'),
}

async function listSlowQueryQueries(request: ListSlowQueryQueriesRequest): ListSlowQueryQueriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListSlowQueryQueries', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/optimizers/slow-query/categories/{categoryIndex}/queries', 'json', false, 'json', request);
}

model ListSortExpressionsRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application name.', example='my_app_group_name', position='Path'),
  appId: int32(name='appId', description='The version ID.', example='110116134', minimum=1, maximum=999999999, position='Path'),
}

model ListSortExpressionsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ 
    {
      active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
      created?: int32(name='created', description='The timestamp when the sort expression was created.', example='1655793690'),
      description?: string(name='description', description='The description of the sort expression.', example='""'),
      name?: string(name='name', description='The name of the sort expression.', example='default'),
      updated?: int32(name='updated', description='The timestamp when the sort expression was updated.', example='1655793690'),
    }
  ](name='result', description='The information about the rough sort or fine sort expressions that are returned.

For more information, see [FirstRank](~~170007~~) and [SecondRank](~~170008~~).'),
}

model ListSortExpressionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSortExpressionsResponseBody(name='body'),
}

async function listSortExpressions(request: ListSortExpressionsRequest): ListSortExpressionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListSortExpressions', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/sort-expressions', 'json', false, 'json', request);
}

model ListSortScriptsRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name or ID of the application.', example='my_app', position='Path'),
  appVersionId: string(name='appVersionId', description='The version ID of the application.', example='110142366', position='Path'),
}

model ListSortScriptsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: [ 
    {
      createTime?: string(name='createTime', description='The time when the script was created.', example='2020-04-02 20:21:14'),
      modifyTime?: string(name='modifyTime', description='The time when the script was last modified.', example='2020-04-02 21:21:14'),
      scope?: string(name='scope', description='The sort phase to which the script applies.', example='second_rank'),
      scriptName?: string(name='scriptName', description='The name of the script.', example='test'),
      status?: string(name='status', description='The status of the script. Valid values:

*   configurable: The script is created, but no script files are uploaded.
*   not compiled: The script is not compiled.
*   compile failed: The compilation of the script failed.
*   compile successful: The script is compiled.
*   released: The script is published.', example='released'),
      type?: string(name='type', description='The type of the script.', example='cava_script'),
    }
  ](name='result', description='The scripts.'),
}

model ListSortScriptsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSortScriptsResponseBody(name='body'),
}

async function listSortScripts(request: ListSortScriptsRequest): ListSortScriptsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListSortScripts', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appVersionId}/sort-scripts', 'json', false, 'json', request);
}

model ListStatisticLogsRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application name.', example='app_group_name', position='Path'),
  moduleName: string(name='moduleName', description='The module name. Valid values:

*   hot: rankings of hotwords.
*   error: application error logs.
*   slow-log: slow query logs.

Set the value to hot.', example='hot', position='Path'),
  columns?: string(name='columns', description='The fields to query. Format: columns=wordsTopPv.

For more information, see [Metrics in statistical reports](~~187665~~).', example='wordsTopPv', position='Query'),
  distinct?: boolean(name='distinct', description='Specifies whether to use the distinct clause.', example='true', position='Query'),
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1', minimum=1, maximum=1000, position='Query'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10', minimum=1, maximum=10000, position='Query'),
  query?: string(name='query', description='The content of the query clause.', example='"default:\\"OpenSearch\\""', position='Query'),
  sortBy?: string(name='sortBy', description='The content of the sort clause.', example='"-id"', position='Query'),
  startTime?: int32(name='startTime', description='The beginning of the time range to query. The default value is the timestamp of 00:00:00 on the current day.', example='1582214400', minimum=0, maximum=9999999999, position='Query'),
  stopTime?: int32(name='stopTime', description='The end of the time range to query. The default value is the timestamp of 24:00:00 on the current day.', example='1682222400', minimum=0, maximum=9999999999, position='Query'),
}

model ListStatisticLogsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='F76ACE3D-E510-EE2C-B7B1-39B3136A61EE'),
  result?: [  map[string]any ](name='result', description='The returned result. For more information, see

*   [Parameters of hotwords rankings](~~421248~~).', example='[]'),
  totalCount?: long(name='totalCount', description='The total number of entries returned.', example='1'),
}

model ListStatisticLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListStatisticLogsResponseBody(name='body'),
}

async function listStatisticLogs(request: ListStatisticLogsRequest): ListStatisticLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListStatisticLogs', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/statistic-logs/{moduleName}', 'json', false, 'json', request);
}

model ListStatisticReportRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='app_group_name', example='app_group_name', position='Path'),
  moduleName: string(name='moduleName', description='suggest', example='suggest', position='Path'),
  columns?: string(name='columns', description='pv,uv', example='pv,uv', position='Query'),
  endTime?: int32(name='endTime', description='1582646399', example='1582646399', minimum=0, maximum=9999999999, position='Query'),
  pageNumber?: int32(name='pageNumber', description='1', example='1', minimum=1, maximum=100, position='Query'),
  pageSize?: int32(name='pageSize', description='10', example='10', minimum=1, maximum=10000, position='Query'),
  query?: string(name='query', description='bizType:test,sceneTag:myTag', example='bizType:test,sceneTag:myTag', position='Query'),
  startTime?: int32(name='startTime', description='1582214400', example='1582214400', minimum=0, maximum=9999999999, position='Query'),
}

model ListStatisticReportResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='F65C8BB2-C14F-5983-888B-41C4E082D3BC'),
  result?: [  map[string]any ](name='result', description='The queried reports. Valid values:

For more information about the metrics in data quality reports, see the Upload behavioral data section of [Data collection 2.0](~~131547~~).

For more information about the metrics in application and A/B test reports, see the Core metrics section of [Metrics of statistical reports](~~187654~~).

For more information about the metrics in query analysis reports, see the Query analysis metrics section of [Metrics of statistical reports](~~187654~~).', example='[]'),
  totalCount?: long(name='totalCount', description='The total number of the queried reports.', example='43'),
}

model ListStatisticReportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListStatisticReportResponseBody(name='body'),
}

async function listStatisticReport(request: ListStatisticReportRequest): ListStatisticReportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListStatisticReport', 'GET', '/v4/openapi/app-groups/{appGroupIdentity}/statistic-report/{moduleName}', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='nextToken', description='The token that is used to retrieve the next page.', example='60', position='Query'),
  resourceId?: [ string ](name='resourceId', description='The resource IDs. You can specify a maximum number of 50 resource IDs.', shrink='json', position='Query'),
  resourceType: string(name='resourceType', description='The resource type.', example='BIGDATA', position='Query'),
  tag?: [ 
    {
      key?: string(name='key', description='The key of the tag.', example='bm'),
      value?: string(name='value', description='The value of the tag.', example='Uefi'),
    }
  ](name='tag', description='The tags. You can specify a maximum number of 20 tags.', shrink='json', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='nextToken', description='The token that is used to retrieve the next page.', example='20'),
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ 
    {
      resourceId?: string(name='resourceId', description='The ID of the resource.', example='54041'),
      resourceType?: string(name='resourceType', description='The resource type.', example='hostGroup'),
      tagKey?: string(name='tagKey', description='The key of the tag.', example='GENIE_FUNCTION'),
      tagValue?: string(name='tagValue', description='The value of the tag.', example='ALLOW'),
    }
  ](name='result', description='The resources.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTagResources', 'GET', '/v4/openapi/resource-tags', 'json', false, 'json', request);
}

model ListUserAnalyzerEntriesRequest {
  name: string(name='name', description='The name of the analyzer.', example='kevin_test', position='Path'),
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1', minimum=-1, maximum=999999999, position='Query'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10', minimum=-1, maximum=999999999, position='Query'),
  word?: string(name='word', description='The key to be used to query entries.', example='kevintest', position='Query'),
}

model ListUserAnalyzerEntriesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='516A02B7-2167-8D92-12D0-B639A2A0F3C5'),
  result?: map[string]any(name='result', description='The entries of the custom analyzer. For more information, see [UserAnalyzerEntry](https://www.alibabacloud.com/help/en/open-search/industry-algorithm-edition/useranalyzerentry).', example='[]'),
}

model ListUserAnalyzerEntriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserAnalyzerEntriesResponseBody(name='body'),
}

async function listUserAnalyzerEntries(request: ListUserAnalyzerEntriesRequest): ListUserAnalyzerEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListUserAnalyzerEntries', 'GET', '/v4/openapi/user-analyzers/{name}/entries', 'json', false, 'json', request);
}

model ListUserAnalyzersRequest {
  pageNumber?: int32(name='pageNumber', description='The number of the page to return. Default value: 1.', example='1', minimum=-1, maximum=999999999, position='Query'),
  pageSize?: int32(name='pageSize', description='The number of entries to return on each page. Default value: 10.', example='10', minimum=-1, maximum=999999999, position='Query'),
}

model ListUserAnalyzersResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      available?: boolean(name='available', description='Indicates whether the application is available.', example='false'),
      business?: string(name='business', description='The basic analyzer. Valid values:

*   chn_standard: [a common analyzer in Chinese](~~179424~~)
*   chn_scene_name: an analyzer for person names in Chinese
*   chn_ecommerce: [an analyzer for E-commerce in Chinese](~~179424~~)
*   chn_it_content: [an analyzer for IT content in Chinese](~~179424~~)
*   en_min: a small-granularity analyzer in English
*   th_standard: a common analyzer in Thai
*   th_ecommerce: an analyzer for E-commerce in Thai
*   vn_standard: a common analyzer in Vietnamese
*   chn_community_it: an analyzer for IT community content in Chinese
*   chn_ecommerce_general: a common analyzer for the E-commerce industry in Chinese
*   chn_esports_general: a common analyzer for the gaming industry in Chinese
*   chn_edu_question: an analyzer for question search of the education industry in Chinese', example='chn_standard'),
      created?: int32(name='created', description='The timestamp when the application was created.', example='1588054131'),
      dicts?: [ 
        {
          available?: boolean(name='available', description='Indicates whether the application is available.', example='false'),
          created?: int32(name='created', description='The timestamp when the application was created.', example='1588054131'),
          entriesCount?: int32(name='entriesCount', description='The number of intervention entries.', example='-1'),
          entriesLimit?: int32(name='entriesLimit', description='The maximum number of intervention entries that can be created in the dictionary.', example='4'),
          id?: string(name='id', description='The ID of the dictionary.', example='123'),
          type?: string(name='type', description='The type. Valid value:

*   segment', example='segment'),
          updated?: int32(name='updated', description='The timestamp when the application was last updated.', example='1588054131'),
        }
      ](name='dicts', description='The dictionaries that are used by the custom analyzer.

For more information, see [UserDict](~~178933~~).'),
      id?: string(name='id', description='The ID of the custom analyzer.', example='1234'),
      name?: string(name='name', description='The name of the custom analyzer.', example='kevin_test2'),
      updated?: int32(name='updated', description='The timestamp when the application was last updated.', example='1588054131'),
    }
  ](name='result', description='The custom analyzer.

For more information, see [UserAnalyzer](~~178934~~).'),
  totalCount?: int32(name='totalCount', description='The total number.', example='1'),
}

model ListUserAnalyzersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserAnalyzersResponseBody(name='body'),
}

async function listUserAnalyzers(request: ListUserAnalyzersRequest): ListUserAnalyzersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListUserAnalyzers', 'GET', '/v4/openapi/user-analyzers', 'json', false, 'json', request);
}

model ModifyAppGroupRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='my_app_group_name', position='Path'),
  currentVersion?: string(name='currentVersion', description='The online version of the application.', example='1223232', position='Body'),
  description?: string(name='description', description='The description of the application.', example='"test"', position='Body'),
  domain?: string(name='domain', description='The type of the industry. Valid values:

*   general: general.
*   ecommerce: e-commerce.
*   education: education.
*   esports: electronic sports.
*   community: content community.', example='"ecommerce"', position='Body'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-****', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to verify the application before modification. Valid values: true and false.', example='true', position='Query'),
}

model ModifyAppGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    chargeType?: string(name='chargeType', description='The billing method. Valid values:

*   POSTPAY: pay-as-you-go.
*   PREPAY: subscription.', example='POSTPAY'),
    chargingWay?: int32(name='chargingWay', description='The billable item. Valid values:

*   1: computing resources.
*   2: QPS.', example='1'),
    commodityCode?: string(name='commodityCode', description='The code of the commodity.', example='opensearch'),
    created?: int32(name='created', description='The timestamp when the application was created.', example='1590139524'),
    currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='100302903'),
    description?: string(name='description', description='The description of the application.', example='1'),
    domain?: string(name='domain', description='The type of the industry. Valid values:

*   GENERAL: general.
*   ECOMMERCE: e-commerce.
*   IT_CONTENT: IT content.', example='GENERAL'),
    engineType?: string(name='engineType'),
    expireOn?: string(name='expireOn', description='The time when the application expired.', example='1'),
    hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval status of the quotas. Valid values:

*   0: normal.
*   1: being approved.', example='0'),
    id?: string(name='id', description='The application ID.', example='100302881'),
    instanceId?: string(name='instanceId', description='The instance ID.', example='10030288'),
    lockMode?: string(name='lockMode', description='The lock status. Valid values:

*   Unlock: The instance is unlocked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
    name?: string(name='name', description='The name of the application.', example='lsh_test_1'),
    produced?: int32(name='produced', description='Indicates whether the order is complete. Valid values:

*   0: The order is in progress.
*   1: The order is complete.', example='1'),
    projectId?: string(name='projectId', description='The name of the A/B test group.', example='1'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing unit (LCU).', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
      spec?: string(name='spec', description='The specifications. Valid values:

*   opensearch.share.junior: basic.
*   opensearch.share.common: shared general-purpose.
*   opensearch.share.compute: shared computing.
*   opensearch.share.storage: shared storage.
*   opensearch.private.common: exclusive general-purpose.
*   opensearch.private.compute: exclusive computing.
*   opensearch.private.storage: exclusive storage.', example='opensearch.share.common'),
    }(name='quota', description='The information about the quotas of the application.', example='{}'),
    resourceGroupId?: string(name='resourceGroupId'),
    status?: string(name='status', description='The state of the application. Valid values:

*   producing: being produced.
*   review_pending: being approved.
*   config_pending: to be configured.
*   normal: normal.
*   frozen: frozen.', example='normal'),
    switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='1590486386'),
    type?: string(name='type', description='The type of the application. Valid values:

*   standard: a standard edition application.
*   advance: an advanced edition application of an old version. New versions are not supported for this edition.
*   enhanced: an advanced edition application of a new version.', example='enhanced'),
    updated?: int32(name='updated', description='The timestamp when the application was last modified.', example='1590978265'),
  }(name='result', description='The returned data.', example='{}'),
}

model ModifyAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAppGroupResponseBody(name='body'),
}

async function modifyAppGroup(request: ModifyAppGroupRequest): ModifyAppGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyAppGroup', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}', 'json', false, 'json', request);
}

model ModifyAppGroupQuotaRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='my_app_group_name', position='Path'),
  body?: Quota(name='body', description='The request body.', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to verify the application before modification. Valid values: true and false.', example='false', position='Query'),
}

model ModifyAppGroupQuotaResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    chargeType?: string(name='chargeType', description='The billing method of the application. Valid values:

*   POSTPAY: pay-as-you-go
*   PREPAY: subscription', example='POSTPAY'),
    chargingWay?: int32(name='chargingWay', description='The billing model. Valid values:

*   1: computing resources
*   2: queries per second (QPS)', example='1'),
    commodityCode?: string(name='commodityCode', description='The code of the commodity.', example='opensearch'),
    created?: int32(name='created', description='The timestamp when the application was created.', example='1590139542'),
    currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='100302903'),
    description?: string(name='description', description='The description of the application.', example='1'),
    engineType?: string(name='engineType'),
    expireOn?: string(name='expireOn', description='The expiration time.', example='1'),
    hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval status of the quotas. Valid values:

*   0: The quotas are approved.
*   1: The quotas are being approved.', example='0'),
    id?: string(name='id', description='The ID of the application.', example='100302881'),
    instanceId?: string(name='instanceId', description='The ID of the instance.', example='1'),
    lockMode?: string(name='lockMode', description='The lock mode of the instance. Valid values:

*   Unlock: The instance is not locked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
    name?: string(name='name', description='The name of the application.', example='lsh_test_1'),
    produced?: int32(name='produced', description='Indicates whether the order is complete. Valid values:

*   0: The order is in progress.
*   1: The order is complete.', example='1'),
    projectId?: string(name='projectId', description='The name of the A/B test group.', example='1000'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing units (LCUs).', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
      spec?: string(name='spec', description='The specifications of the application. Valid values:

*   opensearch.share.junior: basic
*   opensearch.share.common: shared general-purpose
*   opensearch.share.compute: shared computing
*   opensearch.share.storage: shared storage
*   opensearch.private.common: exclusive general-purpose
*   opensearch.private.compute: exclusive computing
*   opensearch.private.storage: exclusive storage', example='opensearch.share.common'),
    }(name='quota', description='The information about the quotas of the application.'),
    resourceGroupId?: string(name='resourceGroupId'),
    status?: string(name='status', description='The status of the application. Valid values:

*   producing
*   review_pending
*   config_pending
*   normal
*   frozen', example='normal'),
    switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='1590486386'),
    type?: string(name='type', description='The type of the application. Valid values:

*   standard: a standard application.
*   advance: an advanced application which is of an old application type. New applications cannot be of this type.
*   enhanced: an advanced application which is of a new application type.', example='enhanced'),
    updated?: int32(name='updated', description='The timestamp when the application was last updated.', example='1590978265'),
  }(name='result', description='The information about the application.'),
}

model ModifyAppGroupQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAppGroupQuotaResponseBody(name='body'),
}

async function modifyAppGroupQuota(request: ModifyAppGroupQuotaRequest): ModifyAppGroupQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyAppGroupQuota', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}/quota', 'json', false, 'json', request);
}

model ModifyFirstRankRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='my_app_group_name', position='Path'),
  appId: int32(name='appId', description='The version number of the application.', example='110157886', position='Path'),
  name: string(name='name', description='The name of the rough sort expression', example='test', position='Path'),
  body?: FirstRank(name='body', description='The request body.', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether the request is a dry run.', example='true', position='Query'),
}

model ModifyFirstRankResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
    description?: string(name='description', description='The description of the rough sort expression.', example='1'),
    meta?: [ 
      {
        arg?: string(name='arg', description='The parameters that are used by a function in the expression.', example='“1 ”'),
        attribute?: string(name='attribute', description='The attribute, feature function, or field to be searched for.', example='static_bm25()'),
        weight?: float(name='weight', description='The weight. Valid values: -100000 to 100000. The value cannot be 0.', example='10'),
      }
    ](name='meta', description='The information about the expression.'),
    name?: string(name='name', description='The name of the expression.', example='default'),
  }(name='result', description='The information about the rough sort expression.'),
}

model ModifyFirstRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyFirstRankResponseBody(name='body'),
}

async function modifyFirstRank(request: ModifyFirstRankRequest): ModifyFirstRankResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyFirstRank', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/first-ranks/{name}', 'json', false, 'json', request);
}

model ModifyQueryProcessorRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application name.', example='“my_app_group_name”', position='Path'),
  appId: int32(name='appId', description='The version number of the application.', example='110157886', position='Path'),
  name: string(name='name', description='The name of the query analysis rule', example='“test”', position='Path'),
  body?: any(name='body', description='The request parameters.', example='{
    "domain": "GENERAL",
    "category": "",
    "processors": [
        {
            "name": "synonym",
            "useSystemDictionary": true
        },
        {
            "name": "stop_word",
            "useSystemDictionary": true
        }
    ]
}', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether the request is a dry run.', example='true', position='Query'),
}

model ModifyQueryProcessorResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the query analysis rule is a default rule.', example='true'),
    created?: int32(name='created', description='The time when the rule was created.', example='0'),
    domain?: string(name='domain', description='The type of the industry to which the query analysis rule is applied. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='GENERAL'),
    indexes?: [ string ](name='indexes', description='The indexes to which the query analysis rule is applied.', example='["default"]'),
    name?: string(name='name', description='The name of the query analysis rule.', example='synonym'),
    processors?: [  map[string]any ](name='processors', description='The analysis rule.', example='[]'),
    updated?: int32(name='updated', description='The time when the rule was updated.', example='1'),
  }(name='result', description='The information about the query analysis rule.', example='{}'),
}

model ModifyQueryProcessorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyQueryProcessorResponseBody(name='body'),
}

async function modifyQueryProcessor(request: ModifyQueryProcessorRequest): ModifyQueryProcessorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyQueryProcessor', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/query-processors/{name}', 'json', false, 'json', request);
}

model ModifyScheduledTaskRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application name or ID.', example='121414148', position='Path'),
  taskId: string(name='taskId', description='The task ID.', example='56e9c2e7-5a4d-481a-9f1b-b07da6909450', position='Path'),
  body?: any(name='body', description='The request parameters.', example='The request parameters.', position='Body'),
}

model ModifyScheduledTaskResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: map[string]any(name='result', description='The information about the scheduled task.', example='Array'),
}

model ModifyScheduledTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyScheduledTaskResponseBody(name='body'),
}

async function modifyScheduledTask(request: ModifyScheduledTaskRequest): ModifyScheduledTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyScheduledTask', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}/scheduled-tasks/{taskId}', 'json', false, 'json', request);
}

model ModifySecondRankRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application name.', example='“my_app_group_name”', position='Path'),
  appId: int32(name='appId', description='The version number of the application.', example='110157886', position='Path'),
  name: string(name='name', description='The name of the fine sort expression.', example='true', position='Path'),
  body?: SecondRank(name='body', description='The request parameters.', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether the request is a dry run.', example='true', position='Query'),
}

model ModifySecondRankResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='C5E2F73C-8241-81F8-3A62-65478C5A3111'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
    created?: int32(name='created', description='The time when the expression was created.', example='1'),
    description?: string(name='description', description='The description of the expression.', example='"11"'),
    id?: string(name='id', description='The expression ID. This parameter is displayed only in the response.', example='890473'),
    isDefault?: string(name='isDefault', description='Indicates whether the expression is the default one. This parameter is displayed only in the response. Valid values:

*   true: the expression is the default one.
*   false: the expression is not the default one.', example='true'),
    isSys?: string(name='isSys', description='Indicates whether the expression is a system expression. This parameter is displayed only in the response. Valid values:

*   true: The expression is a system expression.
*   false:The expression is not a system expression', example='false'),
    meta?: string(name='meta', description='The content of the fine sort expression. You can define an expression that consists of fields, feature functions, and mathematical functions to implement complex sort logic.', example='cate_id > 0 and cate_id < 1000'),
    name?: string(name='name', description='The expression name.', example='lsh_second_1'),
    updated?: int32(name='updated', description='The time when the expression was updated.', example='1'),
  }(name='result', description='The information about the fine sort expression.', example='{}'),
}

model ModifySecondRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySecondRankResponseBody(name='body'),
}

async function modifySecondRank(request: ModifySecondRankRequest): ModifySecondRankResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifySecondRank', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/second-ranks/{name}', 'json', false, 'json', request);
}

model PushInterventionDictionaryEntriesRequest {
  name: string(name='name', description='The name of the intervention dictionary.', example='my_dict', position='Path'),
  body?: [  map[string]any ](name='body', description='The request body.', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to check the validity of input parameters. Default value: false.

Valid values:

*   **true**: checks only the validity of input parameters.
*   **false**: checks the validity of input parameters and creates an attribution configuration.', example='false', position='Query'),
}

model PushInterventionDictionaryEntriesResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ string ](name='result', description='The returned results.'),
}

model PushInterventionDictionaryEntriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushInterventionDictionaryEntriesResponseBody(name='body'),
}

async function pushInterventionDictionaryEntries(request: PushInterventionDictionaryEntriesRequest): PushInterventionDictionaryEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PushInterventionDictionaryEntries', 'POST', '/v4/openapi/intervention-dictionaries/{name}/entries/actions/bulk', 'json', false, 'json', request);
}

model PushUserAnalyzerEntriesRequest {
  name: string(name='name', description='The name of the analyzer.', example='“kevin_test”', position='Path'),
  entries?: [ 
    {
      cmd?: string(name='cmd', description='The operation to be performed on the entries.

Valid values:

*   add
*   delete', example='"add"'),
      key?: string(name='key', description='The key to be used to query entries.', example='"testvalue"'),
      splitEnabled?: boolean(name='splitEnabled', description='Specifies whether to further analyze the terms that are generated after the search query is analyzed.

Default value: true.', example='true'),
      value?: string(name='value', description='The analysis result.', example='"test value"'),
    }
  ](name='entries', description='The entries of the custom analyzer.', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run. This parameter is only used to check whether the data source is valid. Valid values: true and false.', example='true', position='Query'),
}

model PushUserAnalyzerEntriesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: map[string]any(name='result', description='The result returned.', example='{}'),
}

model PushUserAnalyzerEntriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushUserAnalyzerEntriesResponseBody(name='body'),
}

async function pushUserAnalyzerEntries(request: PushUserAnalyzerEntriesRequest): PushUserAnalyzerEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PushUserAnalyzerEntries', 'POST', '/v4/openapi/user-analyzers/{name}/entries/actions/bulk', 'json', false, 'json', request);
}

model ReleaseSortScriptRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='\\"\\"1234\\"\\"', example='\\"\\"1234\\"\\"', position='Path'),
  scriptName: string(name='scriptName', description='\\"\\"test\\"\\"', example='\\"\\"test\\"\\"', position='Path'),
  appVersionId: string(name='appVersionId', description='\\"\\"12345\\"\\"', example='\\"\\"12345\\"\\"', position='Path'),
}

model ReleaseSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
}

model ReleaseSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleaseSortScriptResponseBody(name='body'),
}

async function releaseSortScript(request: ReleaseSortScriptRequest): ReleaseSortScriptResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ReleaseSortScript', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appVersionId}/sort-scripts/{scriptName}/actions/release', 'json', false, 'json', request);
}

model RemoveAppRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name or ID of the application.', example='“my_app_group_name”', position='Path'),
  appId: int32(name='appId', description='The ID of the version.', example='110116134', position='Path'),
}

model RemoveAppResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='33477D76-C380-2D84-A4AD-043F52876CB1'),
  result?: [ int32 ](name='result', description='The return result.'),
}

model RemoveAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveAppResponseBody(name='body'),
}

async function removeApp(request: RemoveAppRequest): RemoveAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RemoveApp', 'DELETE', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}', 'json', false, 'json', request);
}

model RemoveAppGroupRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='"my_app_group_name"', example='121001650', position='Path'),
}

model RemoveAppGroupResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='3AA29D02-54F3-8569-F71A-90E1B7BE4E7E'),
  result?: [ int32 ](name='result', description='N/A'),
}

model RemoveAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveAppGroupResponseBody(name='body'),
}

async function removeAppGroup(request: RemoveAppGroupRequest): RemoveAppGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RemoveAppGroup', 'DELETE', '/v4/openapi/app-groups/{appGroupIdentity}', 'json', false, 'json', request);
}

model RemoveDataCollectionRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application', example='“my_app_group_name”', position='Path'),
  dataCollectionIdentity: string(name='dataCollectionIdentity', description='The data collection ID.', example='286', position='Path'),
}

model RemoveDataCollectionResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: string(name='result', description='—', example='{}'),
}

model RemoveDataCollectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveDataCollectionResponseBody(name='body'),
}

async function removeDataCollection(request: RemoveDataCollectionRequest): RemoveDataCollectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RemoveDataCollection', 'DELETE', '/v4/openapi/app-groups/{appGroupIdentity}/data-collections/{dataCollectionIdentity}', 'json', false, 'json', request);
}

model RemoveFirstRankRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='"my_app_group_name"', example='“my_app_group_name”', position='Path'),
  appId: int32(name='appId', description='110157886', example='110157886', position='Path'),
  name: string(name='name', description='"test"', example='“test”', position='Path'),
}

model RemoveFirstRankResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='E676FAB6-A0AC-64D9-F9D7-D0D33C930CFF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
    description?: string(name='description', description='The description of the expression.', example='""'),
    meta?: [ 
      {
        arg?: string(name='arg', description='The parameters that are used by a function in the expression.

For more information, see Rough sort functions.', example='""'),
        attribute?: string(name='attribute', description='The attribute, feature function, or field to be searched for.

For more information about supported feature functions, see Rough sort functions.', example='static_bm25()'),
        weight?: float(name='weight', description='The weight.

Valid values: \\[-100000,100000] (excluding 0).', example='10'),
      }
    ](name='meta', description='The content of the expression.'),
    name?: string(name='name', description='The name of the expression.', example='default'),
  }(name='result', description='The information about the rough sort expression.'),
}

model RemoveFirstRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveFirstRankResponseBody(name='body'),
}

async function removeFirstRank(request: RemoveFirstRankRequest): RemoveFirstRankResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RemoveFirstRank', 'DELETE', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/first-ranks/{name}', 'json', false, 'json', request);
}

model RemoveInterventionDictionaryRequest {
  name?: string(name='name', description='"my_dict"', example='“my_dict”', position='Path'),
}

model RemoveInterventionDictionaryResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='06BBD41A-5F72-34E4-2DAF-E43B0526051D'),
  result?: {
    analyzer?: string(name='analyzer', description='The custom analyzer.', example='""'),
    created?: string(name='created', description='The time when the intervention dictionary was created.', example='1539158313'),
    name?: string(name='name', description='The name of the intervention dictionary.', example='tongyici'),
    type?: string(name='type', description='The type of the intervention dictionary. Valid values:

*   stopword: an intervention dictionary for stop word filtering
*   synonym: an intervention dictionary for synonym configuration
*   correction: an intervention dictionary for spelling correction
*   category_prediction: an intervention dictionary for category prediction
*   ner: an intervention dictionary for named entity recognition (NER)
*   term_weighting: an intervention dictionary for term weight analysis', example='synonym'),
    updated?: string(name='updated', description='The time when the intervention dictionary was last updated.', example='1539158313'),
  }(name='result', description='The information about the intervention dictionary.'),
}

model RemoveInterventionDictionaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveInterventionDictionaryResponseBody(name='body'),
}

async function removeInterventionDictionary(request: RemoveInterventionDictionaryRequest): RemoveInterventionDictionaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RemoveInterventionDictionary', 'DELETE', '/v4/openapi/intervention-dictionaries/{name}', 'json', false, 'json', request);
}

model RemoveQueryProcessorRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='"my_app_group_name"', example='“my_app_group_name”', position='Path'),
  appId: int32(name='appId', description='110157886', example='110157886', position='Path'),
  name: string(name='name', description='"test"', example='“test”', position='Path'),
}

model RemoveQueryProcessorResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: string(name='result', description='N/A', example='[]'),
}

model RemoveQueryProcessorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveQueryProcessorResponseBody(name='body'),
}

async function removeQueryProcessor(request: RemoveQueryProcessorRequest): RemoveQueryProcessorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RemoveQueryProcessor', 'DELETE', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/query-processors/{name}', 'json', false, 'json', request);
}

model RemoveScheduledTaskRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='"my_app_group_name"', example='“my_app_group_name”', position='Path'),
  taskId: string(name='taskId', description='"2f12c585-5873-11ea-974a-7cd30ad3e268"', example='“2f12c585-5873-11ea-974a-7cd30ad3e268”', position='Path'),
}

model RemoveScheduledTaskResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ int32 ](name='result', description='N/A'),
}

model RemoveScheduledTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveScheduledTaskResponseBody(name='body'),
}

async function removeScheduledTask(request: RemoveScheduledTaskRequest): RemoveScheduledTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RemoveScheduledTask', 'DELETE', '/v4/openapi/app-groups/{appGroupIdentity}/scheduled-tasks/{taskId}', 'json', false, 'json', request);
}

model RemoveSearchStrategyRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='my_app_group_name', position='Path'),
  appId: string(name='appId', description='The version number.', example='110157886', position='Path'),
  strategyName: string(name='strategyName', description='The name of the policy.', example='default', position='Path'),
}

model RemoveSearchStrategyResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='F5099063-6B86-F398-D843-905F9EFB683A'),
}

model RemoveSearchStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveSearchStrategyResponseBody(name='body'),
}

async function removeSearchStrategy(request: RemoveSearchStrategyRequest): RemoveSearchStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RemoveSearchStrategy', 'DELETE', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/search-strategies/{strategyName}', 'json', false, 'json', request);
}

model RemoveSecondRankRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='"my_app_group_name"', example='“my_app_group_name”', position='Path'),
  appId: int32(name='appId', description='110157886', example='110157886', position='Path'),
  name: string(name='name', description='"tests"', example='“tests”', position='Path'),
}

model RemoveSecondRankResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: map[string]any(name='result', description='N/A', example='{}'),
}

model RemoveSecondRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveSecondRankResponseBody(name='body'),
}

async function removeSecondRank(request: RemoveSecondRankRequest): RemoveSecondRankResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RemoveSecondRank', 'DELETE', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/second-ranks/{name}', 'json', false, 'json', request);
}

model RemoveUserAnalyzerRequest {
  name: string(name='name', description='The name of the analyzer.', example='“kevin_test”', position='Path'),
}

model RemoveUserAnalyzerResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: map[string]any(name='result', description='N/A', example='[]'),
}

model RemoveUserAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveUserAnalyzerResponseBody(name='body'),
}

async function removeUserAnalyzer(request: RemoveUserAnalyzerRequest): RemoveUserAnalyzerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RemoveUserAnalyzer', 'DELETE', '/v4/openapi/user-analyzers/{name}', 'json', false, 'json', request);
}

model RenewAppGroupRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='my_app', position='Path'),
  body?: PrepayOrderInfo(name='body', description='The renewal request body.', position='Body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request.', example='74db41d8cd3c784209093aa76afbe89e', position='Query'),
}

model RenewAppGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: boolean(name='result', description='Indicates whether the application was renewed.', example='true'),
}

model RenewAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenewAppGroupResponseBody(name='body'),
}

async function renewAppGroup(request: RenewAppGroupRequest): RenewAppGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RenewAppGroup', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/actions/renew', 'json', false, 'json', request);
}

model ReplaceAppGroupCommodityCodeRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application', example='my_app', position='Path'),
}

model ReplaceAppGroupCommodityCodeResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='AC5F78BA-66B9-545B-9CF1-8F542E682E1F'),
  result?: {
    chargeType?: string(name='chargeType', description='The billing method. Valid values:

*   POSTPAY: pay-as-you-go.
*   PREPAY: subscription.', example='POSTPAY'),
    chargingWay?: int32(name='chargingWay', description='The billing type. Valid values:

*   1: computing resources.
*   2: queries per second (QPS).', example='1'),
    commodityCode?: string(name='commodityCode', description='The code of the commodity.', example='opensearch'),
    created?: int32(name='created', description='The timestamp when the application was created.', example='1588054131'),
    currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='100302903'),
    description?: string(name='description', description='The description of the application.', example='""'),
    expireOn?: string(name='expireOn', description='The expiration time.', example='-'),
    firstRankAlgoDeploymentId?: int32(name='firstRankAlgoDeploymentId', description='The ID of the rough sort expression.', example='0'),
    hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval state of the quotas. Valid values:

*   0: The approval status is normal.
*   1: The quotas are being approved.', example='0'),
    id?: string(name='id', description='The application ID.', example='-'),
    instanceId?: string(name='instanceId', description='The instance ID.', example='-'),
    lockMode?: string(name='lockMode', description='The lock state. Valid values:

*   Unlock: The instance is unlocked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
    lockedByExpiration?: int32(name='lockedByExpiration', description='Indicates whether the instance is automatically locked after it expires. Valid values:

*   0: The instance is not automatically locked after it expires.
*   1: The instance is automatically locked after it expires.', example='0'),
    name?: string(name='name', description='The name of the order.', example='-'),
    pendingSecondRankAlgoDeploymentId?: int32(name='pendingSecondRankAlgoDeploymentId', description='The ID of the fine sort expression that is being created.', example='0'),
    processingOrderId?: string(name='processingOrderId', description='The ID of the order that is in progress.', example='-'),
    produced?: int32(name='produced', description='Indicates whether the order is produced.', example='0'),
    projectId?: string(name='projectId', description='The name of the A/B test group.', example='-'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The number of computing resources configured.', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity.', example='1'),
      spec?: string(name='spec', description='The specifications configured.', example='-'),
    }(name='quota', description='The configuration information.'),
    secondRankAlgoDeploymentId?: int32(name='secondRankAlgoDeploymentId', description='The ID of the fine sort expression.', example='0'),
    status?: string(name='status', description='The status of the application.', example='normal'),
    switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='1590486386'),
    type?: string(name='type', description='The type of the application.', example='-'),
    updated?: int32(name='updated', description='The timestamp when the application was updated.', example='1581065904'),
    versions?: [ string ](name='versions', description='The versions.'),
  }(name='result', description='The returned result.', example='{}'),
}

model ReplaceAppGroupCommodityCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReplaceAppGroupCommodityCodeResponseBody(name='body'),
}

async function replaceAppGroupCommodityCode(request: ReplaceAppGroupCommodityCodeRequest): ReplaceAppGroupCommodityCodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ReplaceAppGroupCommodityCode', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/actions/to-instance-typed', 'json', false, 'json', request);
}

model SaveSortScriptFileRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name or ID of the application.', example='\\"\\"1111\\"\\"', position='Path'),
  scriptName: string(name='scriptName', description='The name of the script whose content you want to update.', example='\\"\\"11111\\"\\"', position='Path'),
  appVersionId: string(name='appVersionId', description='The version number of the application.', example='\\"\\"111111\\"\\"', position='Path'),
  fileName: string(name='fileName', description='The file name.', example='\\"\\"11111\\"\\"', position='Path'),
  content?: string(name='content', description='The script content that is encoded in the Base64 format.', example='4769#0: *28194492991 a client request body is buffered to a temporary file /usr/local/webserver/openresty/nginx/client_body_temp/0000624474,', position='Body'),
  version?: int32(name='version', description='The version number of the script content.', example='2022-12-01', position='Body'),
}

model SaveSortScriptFileResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
}

model SaveSortScriptFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SaveSortScriptFileResponseBody(name='body'),
}

async function saveSortScriptFile(request: SaveSortScriptFileRequest): SaveSortScriptFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'SaveSortScriptFile', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appVersionId}/sort-scripts/{scriptName}/files/src/{fileName}', 'json', false, 'json', request);
}

model StartSlowQueryAnalyzerRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='"my_app_group_name"', example='“my_app_group_name”', position='Path'),
}

model StartSlowQueryAnalyzerResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: map[string]any(name='result', description='N/A', example='{}'),
}

model StartSlowQueryAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartSlowQueryAnalyzerResponseBody(name='body'),
}

async function startSlowQueryAnalyzer(request: StartSlowQueryAnalyzerRequest): StartSlowQueryAnalyzerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StartSlowQueryAnalyzer', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/optimizers/slow-query/actions/run', 'json', false, 'json', request);
}

model TagResourcesRequest {
  resourceId: [ string ](name='resourceId', description='The resource IDs. You can specify a maximum number of 50 resource IDs.', position='Body'),
  resourceType: string(name='resourceType', description='The resource type.', example='ProductVersion', position='Body'),
  tag: [ 
    {
      key?: string(name='key', description='The key of the tag.', example='cloud_manage'),
      value?: string(name='value', description='The value of the tag.', example='31261301'),
    }
  ](name='tag', description='The tags. You can specify a maximum number of 20 tags.', position='Body'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'TagResources', 'POST', '/v4/openapi/resource-tags', 'json', false, 'json', request);
}

model UnbindESUserAnalyzerRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='my_app_group_name', position='Path'),
  esInstanceId: string(name='esInstanceId', description='The ID of the instance.', example='es-cn-zvp2ff3iq000myzv7', position='Path'),
  body?: any(name='body', description='The request parameters.', example='{
  "name": "kevintest-analyzer"
}', position='Body'),
}

model UnbindESUserAnalyzerResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: map[string]any(name='result', description='The custom analyzer.', example='[]'),
}

model UnbindESUserAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindESUserAnalyzerResponseBody(name='body'),
}

/**
  * You can call this operation to unbind a custom analyzer from an Elasticsearch instance.
  *
 */
async function unbindESUserAnalyzer(request: UnbindESUserAnalyzerRequest): UnbindESUserAnalyzerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UnbindESUserAnalyzer', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/es/{esInstanceId}/actions/unbind-analyzer', 'json', false, 'json', request);
}

model UnbindEsInstanceRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='"my_app_group_name"', position='Path'),
}

model UnbindEsInstanceResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: map[string]any(name='result', description='The data returned.', example='{}'),
}

model UnbindEsInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindEsInstanceResponseBody(name='body'),
}

async function unbindEsInstance(request: UnbindEsInstanceRequest): UnbindEsInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UnbindEsInstance', 'POST', '/v4/openapi/app-groups/{appGroupIdentity}/actions/unbind-es-instance', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='all', description='Specifies whether to remove all tags from the specified one or more resources. This parameter takes effect only if the tagKey parameter is not specified. Valid values: true and false. Default value: false.', example='true', position='Query'),
  resourceId: [ string ](name='resourceId', description='The resource IDs. You can specify a maximum number of 50 IDs.', shrink='json', position='Query'),
  resourceType: string(name='resourceType', description='The resource type.', example='ProductVersion', position='Query'),
  tagKey?: [ string ](name='tagKey', description='The keys of tags. You can specify a maximum number of 20 keys.', shrink='json', position='Query'),
}

model UntagResourcesResponseBody = {
  tequestId?: string(name='tequestId', description='The ID of the request.', example='1-A-0-B'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UntagResources', 'DELETE', '/v4/openapi/resource-tags', 'json', false, 'json', request);
}

model UpdateABTestExperimentRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='“my_app_group_name”', position='Path'),
  sceneId: int32(name='sceneId', description='The scenario ID.', example='20404', minimum=-1, maximum=999999999, position='Path'),
  groupId: int32(name='groupId', description='The ID of the test group', example='13467', minimum=-1, maximum=999999999, position='Path'),
  experimentId: int32(name='experimentId', description='The test ID.', example='12889', minimum=-1, maximum=999999999, position='Path'),
  body?: ABTestExperiment(name='body', description='The request body. For more information, see [ABTestExperiment](~~173617~~).', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   true: performs only a dry run. No endpoint is created. The system checks whether your AccessKey is valid, whether Resource Access Management (RAM) users are authorized, and whether the required parameters are set.
*   false (default): creates an endpoint immediately.', example='true', position='Query'),
}

model UpdateABTestExperimentResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test was created.', example='1588842080'),
    id?: string(name='id', description='The test ID.', example='12888'),
    name?: string(name='name', description='The alias of the test.', example='test1'),
    online?: boolean(name='online', description='Indicates whether the test is in effect. Valid values:

*   true
*   false', example='true'),
    params?: map[string]any(name='params', description='The test parameters.', example='{}'),
    traffic?: int32(name='traffic', description='The percentage of traffic that is routed to the test. Valid values: \\[0,100]', example='30'),
    updated?: int32(name='updated', description='The time when the test was last modified.', example='1588842080'),
  }(name='result', description='The details of the test.'),
}

model UpdateABTestExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateABTestExperimentResponseBody(name='body'),
}

async function updateABTestExperiment(request: UpdateABTestExperimentRequest): UpdateABTestExperimentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateABTestExperiment', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}/scenes/{sceneId}/groups/{groupId}/experiments/{experimentId}', 'json', false, 'json', request);
}

model UpdateABTestFixedFlowDividersRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='“my_app_group_name”', position='Path'),
  sceneId: int32(name='sceneId', description='The scenario ID.', example='20404', minimum=-1, maximum=999999999, position='Path'),
  groupId: int32(name='groupId', description='The ID of the test group.', example='13467', minimum=-1, maximum=999999999, position='Path'),
  experimentId: int32(name='experimentId', description='The test ID.', example='12889', minimum=-1, maximum=999999999, position='Path'),
  body?: [ string ](name='body', description='The request body.', position='Body'),
}

model UpdateABTestFixedFlowDividersResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ string ](name='result', description='The returned results.'),
}

model UpdateABTestFixedFlowDividersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateABTestFixedFlowDividersResponseBody(name='body'),
}

async function updateABTestFixedFlowDividers(request: UpdateABTestFixedFlowDividersRequest): UpdateABTestFixedFlowDividersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateABTestFixedFlowDividers', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}/scenes/{sceneId}/groups/{groupId}/experiments/{experimentId}/fixed-flow-dividers', 'json', false, 'json', request);
}

model UpdateABTestGroupRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='“my_app_group_name”', position='Path'),
  sceneId: int32(name='sceneId', description='The scenario ID.', example='20404', minimum=-1, maximum=999999999, position='Path'),
  groupId: int32(name='groupId', description='The ID of the test group.', example='13467', minimum=-1, maximum=999999999, position='Path'),
  body?: ABTestGroup(name='body', description='The request body. For more information, see [ABTestGroup](~~178935~~).', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   true: performs only a dry run. No endpoint is created. The system checks whether your AccessKey is valid, whether Resource Access Management (RAM) users are authorized, and whether the required parameters are set.
*   false (default): creates an endpoint immediately.', example='true', position='Query'),
}

model UpdateABTestGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='\\"\\"1111\\"\\"'),
  result?: {
    created?: int32(name='created', description='The time when the test group was created.', example='1588839490'),
    id?: string(name='id', description='The ID of the test group.', example='13466'),
    name?: string(name='name', description='The alias of the test group.', example='Group_2020-5-7_15:23:3'),
    status?: int32(name='status', description='The status of the test group. Valid values:

*   0: not in effect
*   1: in effect', example='1'),
    updated?: int32(name='updated', description='The time when the test group was last updated.', example='1588839490'),
  }(name='result', description='The details of the test group.'),
}

model UpdateABTestGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateABTestGroupResponseBody(name='body'),
}

async function updateABTestGroup(request: UpdateABTestGroupRequest): UpdateABTestGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateABTestGroup', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}/scenes/{sceneId}/groups/{groupId}', 'json', false, 'json', request);
}

model UpdateABTestSceneRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='“my_app_group_name”', position='Path'),
  sceneId: int32(name='sceneId', description='The ID of the test scenario.', example='20404', minimum=-1, maximum=999999999, position='Path'),
  body?: ABTestScene(name='body', description='The request body.', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run. This parameter is only used to check whether the data source is valid. Valid values: true and false.', example='true', position='Query'),
}

model UpdateABTestSceneResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test scenario was created.', example='1596527691'),
    id?: string(name='id', description='The ID of the test scenario.', example='20614'),
    name?: string(name='name', description='The name of the test scenario.', example='kevintest22'),
    online?: boolean(name='online', description='The status of the test. Valid values:

*   true: The test is started.
*   false: The test is stopped.', example='true'),
    params?: map[string]any(name='params', description='The parameters of the A/B test.', example='{}'),
    traffic?: int32(name='traffic', description='The percentage of traffic that is allocated to the A/B test. Valid values: 0 to 100.', example='111'),
    updated?: int32(name='updated', description='The time when the test scenario was last modified.', example='1596527691'),
  }(name='result', description='The details of the test scenario. For more information, see [ABTestScene](~~173618~~).', example='{}'),
}

model UpdateABTestSceneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateABTestSceneResponseBody(name='body'),
}

async function updateABTestScene(request: UpdateABTestSceneRequest): UpdateABTestSceneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateABTestScene', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}/scenes/{sceneId}', 'json', false, 'json', request);
}

model UpdateFetchFieldsRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='"my_app_group_name"', example='“my_app_group_name”', position='Path'),
  appId: int32(name='appId', description='110157886', example='110157886', position='Path'),
  body?: [ string ](name='body', description='The request body.', position='Body'),
  dryRun?: boolean(name='dryRun', description='true', example='true', position='Query'),
}

model UpdateFetchFieldsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: boolean(name='result', description='Indicates whether the operation was successful.', example='true'),
}

model UpdateFetchFieldsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFetchFieldsResponseBody(name='body'),
}

async function updateFetchFields(request: UpdateFetchFieldsRequest): UpdateFetchFieldsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateFetchFields', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/fetch-fields', 'json', false, 'json', request);
}

model UpdateFunctionDefaultInstanceRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='"app_group_name"', position='Path'),
  functionName: string(name='functionName', description='The name of the feature.', example='pop', position='Path'),
  instanceName?: string(name='instanceName', description='The name of the instance.', example='"pop_test"', position='Body'),
}

model UpdateFunctionDefaultInstanceResponseBody = {
  code?: string(name='Code', description='The error code.', example='DefaultInstance.SetFail'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A4D487A9-A456-5AA5-A9C6-B7BF2889CF74'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model UpdateFunctionDefaultInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFunctionDefaultInstanceResponseBody(name='body'),
}

async function updateFunctionDefaultInstance(request: UpdateFunctionDefaultInstanceRequest): UpdateFunctionDefaultInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateFunctionDefaultInstance', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}/functions/{functionName}/default-instance', 'json', false, 'json', request);
}

model UpdateFunctionInstanceRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='"app_group_name"', position='Path'),
  functionName: string(name='functionName', description='The name of the feature.', example='"ctr"', position='Path'),
  instanceName: string(name='instanceName', description='The name of the instance.', example='"ctr_test"', position='Path'),
  createParameters?: [ 
    {
      name?: string(name='name', description='The name of the parameter.', example='title_field'),
      value?: string(name='value', description='The value of the parameter.', example='title'),
    }
  ](name='createParameters', description='The parameters that are used to create the instance.', example='{             "name": "title_field",             "value": "title"         }', position='Body'),
  cron?: string(name='cron', description='The cron expression used to schedule periodic training, in the format of (Minutes Hours DayofMonth Month DayofWeek). The default value is empty, which indicates that no periodic training is performed. DayofWeek 0 indicates Sunday.', example='"0 3 ? * 0,1,3,5"', position='Body'),
  description?: string(name='description', description='The description of the instance.', example='test instance', position='Body'),
  usageParameters?: [ 
    {
      name?: string(name='name', description='The name of the parameter.', example='allow_dict_id'),
      value?: string(name='value', description='The value of the parameter.', example='123'),
    }
  ](name='usageParameters', description='The parameters that are used.', position='Body'),
}

model UpdateFunctionInstanceResponseBody = {
  code?: string(name='Code', description='The error code.', example='"Instance.NotExist"'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='10'),
  message?: string(name='Message', description='The error message.', example='"instance not exist."'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='"3A809095-C554-5CF5-8FCE-BE19D4673790"'),
  status?: string(name='Status', description='The status of the request. Valid values:

*       OK: The request was successful.
*       FAIL: The request failed.', example='OK'),
}

model UpdateFunctionInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFunctionInstanceResponseBody(name='body'),
}

async function updateFunctionInstance(request: UpdateFunctionInstanceRequest): UpdateFunctionInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateFunctionInstance', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}/functions/{functionName}/instances/{instanceName}', 'json', false, 'json', request);
}

model UpdateFunctionResourceRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The application ID.', example='my_app_group_name', position='Path'),
  functionName: string(name='functionName', description='The name of the feature.', example='rank', position='Path'),
  resourceName: string(name='resourceName', description='The name of the resource.', example='fg_json', position='Path'),
  data?: {
    content?: string(name='Content', description='The content of the file that corresponds to a resource of the raw_file type.', example='abc'),
    generators?: [ 
      {
        generator?: string(name='Generator', description='The type of the feature generator.', example='combo'),
        input?: {
          features?: [ 
            {
              name?: string(name='Name', description='The name of the feature.', example='system_item_id'),
              type?: string(name='Type', description='The type of the feature.', example='item'),
            }
          ](name='Features', description='The input features.'),
        }(name='Input', description='The input.'),
        output?: string(name='Output', description='The name of the output feature.', example='feature1'),
      }
    ](name='Generators', description='The feature generators that correspond to resources of the feature_generator type.'),
  }(name='Data', description='The resource data. The data structure varies with the resource type.', position='Body'),
  description?: string(name='Description', description='The description of the resource.', example='updated description', position='Body'),
}

model UpdateFunctionResourceResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, this parameter is left empty.', example='InvalidRequest'),
  httpCode?: long(name='HttpCode', description='The HTTP status code returned.', example='200'),
  latency?: double(name='Latency', description='The time consumed for the request. Unit: milliseconds.', example='123'),
  message?: string(name='Message', description='The error message returned.', example='Invalid request.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7E375703-5B12-5466-8B48-C4D01AE1291A'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model UpdateFunctionResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFunctionResourceResponseBody(name='body'),
}

/**
  * You can call this operation to update the information about resources by resource name. You can modify only the values of data and description.
  *
 */
async function updateFunctionResource(request: UpdateFunctionResourceRequest): UpdateFunctionResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateFunctionResource', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}/functions/{functionName}/resources/{resourceName}', 'json', false, 'json', request);
}

model UpdateSearchStrategyRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='group_name', position='Path'),
  appId: string(name='appId', description='The version number.', example='"110157886"', position='Path'),
  strategyName: string(name='strategyName', description='The name of the policy.', example='default', position='Path'),
  body?: SearchStrategy(name='body', description='The request body.', position='Body'),
}

model UpdateSearchStrategyResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
}

model UpdateSearchStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSearchStrategyResponseBody(name='body'),
}

async function updateSearchStrategy(request: UpdateSearchStrategyRequest): UpdateSearchStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateSearchStrategy', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/search-strategies/{strategyName}', 'json', false, 'json', request);
}

model UpdateSortScriptRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application or the ID of the application.', example='my_app', position='Path'),
  appVersionId: string(name='appVersionId', description='The version number of the application.', example='123456', position='Path'),
  scriptName: string(name='scriptName', description='The name of the script.', example='test_cava', position='Path'),
}

model UpdateSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='9F165784-5507-5342-ABF3-545293F9808A'),
}

model UpdateSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSortScriptResponseBody(name='body'),
}

/**
  * You can call this operation to modify the description of a sort script.
  *
 */
async function updateSortScript(request: UpdateSortScriptRequest): UpdateSortScriptResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateSortScript', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appVersionId}/sort-scripts/{scriptName}', 'json', false, 'json', request);
}

model UpdateSummariesRequest {
  appGroupIdentity: string(name='appGroupIdentity', description='The name of the application.', example='“my_app_group_name”', position='Path'),
  appId: int32(name='appId', description='The version number of the application.', example='10157886', position='Path'),
  body?: [ 
    {
      element?: string(name='element', description='The HTML tag that is used to highlight terms in red.', example='"em"'),
      ellipsis?: string(name='ellipsis', description='The connector that is used to connect segments.', example='"..."'),
      field?: string(name='field', description='The field.', example='"title"'),
      len?: int32(name='len', description='The length of a segment.', example='50'),
      snippet?: int32(name='snippet', description='The number of segments.', example='1'),
    }
  ](name='body', description='The request body.', position='Body'),
  dryRun?: boolean(name='dryRun', description='Specifies whether the request is a dry run.', example='true', position='Query'),
}

model UpdateSummariesResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='7A389E09-7964-5A2B-FE9D-F6CFA7162852'),
  result?: boolean(name='result', description='Indicates whether the request was successful.', example='true'),
}

model UpdateSummariesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSummariesResponseBody(name='body'),
}

async function updateSummaries(request: UpdateSummariesRequest): UpdateSummariesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateSummaries', 'PUT', '/v4/openapi/app-groups/{appGroupIdentity}/apps/{appId}/summaries', 'json', false, 'json', request);
}

model ValidateDataSourcesRequest {
  body?: DataSource(name='body', description='The request parameter. For more information, see [DataSource](~~170005~~).', position='Body'),
}

model ValidateDataSourcesResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='8FA2B338-AFDC-46B4-A132-B5487820C2BF'),
  result?: [ 
    {
      code?: string(name='code', description='The code returned for the request.', example='SUCCEED'),
      dataSource?: {
        parameters?: map[string]any(name='parameters', description='The parameters of the data source.', example='{}'),
        tableName?: string(name='tableName', description='The name of the table.', example='user_activity_decision'),
        type?: string(name='type', description='The type of the data source.', example='rds'),
      }(name='dataSource', description='The data source.', example='{}'),
      message?: string(name='message', description='The status of the execution.', example='successful'),
    }
  ](name='result', description='The result returned.', example='[]'),
}

model ValidateDataSourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ValidateDataSourcesResponseBody(name='body'),
}

async function validateDataSources(request: ValidateDataSourcesRequest): ValidateDataSourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ValidateDataSources', 'POST', '/v4/openapi/assist/data-sources/validations', 'json', false, 'json', request);
}

model DataSourcePluginsValue = {
  name?: string(name='name'),
  fromFields?: string(name='fromFields'),
  parameters?: map[string]string(name='parameters'),
}

model SchemaIndexesSearchFieldsValue = {
  analyzer?: string(name='analyzer'),
  analyzerType?: string(name='analyzerType'),
  analyzerGeneration?: string(name='analyzerGeneration'),
  fields?: [ string ](name='fields'),
  label?: string(name='label'),
}

model SchemaTablesValue = {
  name?: string(name='name'),
  primaryTable?: boolean(name='primaryTable'),
  fields?: map[string]SchemaTablesValueFieldsValue(name='fields'),
}

model SchemaTablesValueFieldsValue = {
  name?: string(name='name'),
  primaryKey?: boolean(name='primaryKey'),
  type?: string(name='type'),
  joinWith?: [ string ](name='joinWith'),
  label?: string(name='label'),
}

