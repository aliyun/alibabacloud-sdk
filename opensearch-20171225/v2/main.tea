/**
 *
 */
import OpenApi;
import OpenApi.OpenApiUtil;

extends OpenApi;


init(config: OpenApiUtil.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('opensearch', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!$isNull(endpoint)) {
    return endpoint;
  }
  
  if (!$isNull(endpointMap) && !$isNull(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ABTestExperiment {
  name?: string(name='name'),
  online?: boolean(name='online'),
  params?: map[string]string(name='params'),
  serialNumber?: int32(name='serialNumber'),
  traffic?: int32(name='traffic'),
}

model ABTestGroup {
  name?: string(name='name'),
  status?: int32(name='status'),
}

model ABTestScene {
  name?: string(name='name'),
  status?: int32(name='status', example='0 停止实验 1 开通实验'),
  values?: [ string ](name='values'),
}

model App {
  autoSwitch?: boolean(name='autoSwitch'),
  cluster?: {
    maxQueryClauseLength?: int32(name='maxQueryClauseLength'),
    maxTimeoutMS?: int32(name='maxTimeoutMS'),
  }(name='cluster'),
  dataSources?: [
    DataSource
  ](name='dataSources'),
  description?: string(name='description'),
  domain?: Domain(name='domain'),
  fetchFields?: [ string ](name='fetchFields'),
  firstRanks?: [
    FirstRank
  ](name='firstRanks'),
  networkType?: string(name='networkType'),
  queryProcessors?: [
    QueryProcessor
  ](name='queryProcessors'),
  quota?: Quota(name='quota'),
  realtimeShared?: boolean(name='realtimeShared'),
  schema?: Schema(name='schema'),
  schemas?: [
    Schema
  ](name='schemas'),
  secondRanks?: [
    SecondRank
  ](name='secondRanks'),
  summaries?: [
    Summary
  ](name='summaries'),
  type?: string(name='type'),
}

model AppGroup {
  chargeType?: string(name='chargeType'),
  description?: string(name='description'),
  domain?: string(name='domain'),
  name?: string(name='name'),
  order?: {
    autoRenew?: boolean(name='autoRenew', example='false'),
    duration?: long(name='duration', example='1'),
    pricingCycle?: string(name='pricingCycle', example='Month'),
  }(name='order'),
  quota?: Quota(name='quota'),
  resourceGroupId?: string(name='resourceGroupId'),
  type?: string(name='type'),
}

model DataSource {
  fields?: [ map[string]string ](name='fields'),
  keyField?: string(name='keyField'),
  parameters?: map[string]any(name='parameters'),
  plugins?: map[string]DataSourcePluginsValue(name='plugins'),
  schemaName?: string(name='schemaName'),
  tableName?: string(name='tableName'),
  type?: string(name='type'),
}

model Domain {
  category?: string(name='category'),
  functions?: map[string][ string ](name='functions'),
  name?: string(name='name'),
}

model FirstRank {
  active?: boolean(name='active'),
  description?: string(name='description'),
  meta?: any(name='meta'),
  name?: string(name='name'),
  type?: string(name='type'),
}

model PrepayOrderInfo {
  autoRenew?: boolean(name='autoRenew'),
  duration?: int32(name='duration'),
  pricingCycle?: string(name='pricingCycle'),
}

model QueryProcessor {
  active?: boolean(name='active'),
  category?: string(name='category'),
  domain?: string(name='domain'),
  indexes?: [ string ](name='indexes'),
  name?: string(name='name'),
  processors?: [  map[string]any ](name='processors'),
}

model Quota {
  computeResource?: int32(name='computeResource'),
  docSize?: int32(name='docSize'),
  orderType?: string(name='orderType'),
  spec?: string(name='spec'),
}

model ScheduledTask {
  autoSwitch?: boolean(name='autoSwitch'),
  cron?: string(name='cron'),
  enabled?: boolean(name='enabled'),
  filter?: {
    days?: int32(name='days'),
    expression?: string(name='expression'),
    field?: string(name='field'),
    unit?: string(name='unit'),
  }(name='filter'),
  forkedAppId?: string(name='forkedAppId'),
  permanent?: boolean(name='permanent'),
  runNow?: boolean(name='runNow'),
  type?: string(name='type'),
  version?: string(name='version'),
}

model Schema {
  indexSortConfig?: [ 
    {
      direction?: string(name='direction'),
      field?: string(name='field'),
    }
  ](name='indexSortConfig'),
  indexes?: {
    filterFields?: [ string ](name='filterFields'),
    searchFields?: map[string]SchemaIndexesSearchFieldsValue(name='searchFields'),
  }(name='indexes'),
  name?: string(name='name'),
  routeField?: string(name='routeField'),
  routeFieldValues?: [ string ](name='routeFieldValues'),
  secondRouteField?: string(name='secondRouteField'),
  tables?: map[string]SchemaTablesValue(name='tables'),
  ttlField?: {
    name?: string(name='name'),
    ttl?: long(name='ttl'),
  }(name='ttlField'),
}

model SearchStrategy {
  description?: string(name='description'),
  isDefault?: boolean(name='isDefault'),
  mergeConfig?: {
    docCount?: int32(name='docCount'),
    rankName?: string(name='rankName'),
  }(name='mergeConfig'),
  name?: string(name='name'),
  searchConfigs?: [ 
    {
      firstRankName?: string(name='firstRankName'),
      mergeProportion?: int32(name='mergeProportion'),
      queryType?: string(name='queryType', example='keyword: 关键字查询 vector: 向量查询'),
      secondRankName?: string(name='secondRankName'),
    }
  ](name='searchConfigs'),
}

model SecondRank {
  active?: boolean(name='active'),
  description?: string(name='description'),
  meta?: any(name='meta'),
  name?: string(name='name'),
}

model Summary {
  active?: boolean(name='active'),
  meta?: {
    element?: string(name='element'),
    ellipsis?: string(name='ellipsis'),
    field?: string(name='field'),
    len?: int32(name='len'),
    snippet?: string(name='snippet'),
  }(name='meta'),
  name?: string(name='name'),
}

model DataSourcePluginsValue = {
  name?: string(name='name'),
  fromFields?: string(name='fromFields'),
  parameters?: map[string]string(name='parameters'),
}

model SchemaIndexesSearchFieldsValue = {
  analyzer?: string(name='analyzer'),
  analyzerType?: string(name='analyzerType'),
  analyzerGeneration?: string(name='analyzerGeneration'),
  fields?: [ string ](name='fields'),
  label?: string(name='label'),
}

model SchemaTablesValue = {
  name?: string(name='name'),
  primaryTable?: boolean(name='primaryTable'),
  fields?: map[string]SchemaTablesValueFieldsValue(name='fields'),
}

model SchemaTablesValueFieldsValue = {
  name?: string(name='name'),
  primaryKey?: boolean(name='primaryKey'),
  type?: string(name='type'),
  joinWith?: [ string ](name='joinWith'),
  label?: string(name='label'),
}

model BindESUserAnalyzerRequest {
  body?: any(name='body', description='The request parameters.', example='{
  "name": "kevintest-analyzer"
}'),
}

model BindESUserAnalyzerResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='3AD34CAD-9603-5251-AFF5-3916C848A1D3'),
  result?: map[string]any(name='result', description='The custom analyzer.', example='[]'),
}

model BindESUserAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindESUserAnalyzerResponseBody(name='body'),
}

/**
 * @summary Binds a custom analyzer to an Elasticsearch instance.
 *
 * @param request BindESUserAnalyzerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindESUserAnalyzerResponse
 */
@context("bindESUserAnalyzerWithContext")
async function bindESUserAnalyzerWithOptions(appGroupIdentity: string, esInstanceId: string, request: BindESUserAnalyzerRequest, headers: map[string]string, runtime: $RuntimeOptions): BindESUserAnalyzerResponse {
  request.validate();
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApiUtil.Params{
    action = 'BindESUserAnalyzer',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/es/${$URL.percentEncode(esInstanceId)}/actions/bind-analyzer`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Binds a custom analyzer to an Elasticsearch instance.
 *
 * @param request BindESUserAnalyzerRequest
 * @return BindESUserAnalyzerResponse
 */
async function bindESUserAnalyzer(appGroupIdentity: string, esInstanceId: string, request: BindESUserAnalyzerRequest): BindESUserAnalyzerResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return bindESUserAnalyzerWithOptions(appGroupIdentity, esInstanceId, request, headers, runtime);
}

model BindEsInstanceRequest {
  body?: map[string]any(name='body', description='The body of the request.', example='{
  "esInstanceId": "es-cn-abcde"
}'),
}

model BindEsInstanceResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='F5099063-6B86-F398-D843-905F9EFB683A'),
  result?: map[string]any(name='result', description='The result', example='[]'),
}

model BindEsInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindEsInstanceResponseBody(name='body'),
}

/**
 * @summary Binds an Elasticsearch instance.
 *
 * @param request BindEsInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindEsInstanceResponse
 */
@context("bindEsInstanceWithContext")
async function bindEsInstanceWithOptions(appGroupIdentity: string, request: BindEsInstanceRequest, headers: map[string]string, runtime: $RuntimeOptions): BindEsInstanceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'BindEsInstance',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/actions/bind-es-instance`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Binds an Elasticsearch instance.
 *
 * @param request BindEsInstanceRequest
 * @return BindEsInstanceResponse
 */
async function bindEsInstance(appGroupIdentity: string, request: BindEsInstanceRequest): BindEsInstanceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return bindEsInstanceWithOptions(appGroupIdentity, request, headers, runtime);
}

model CompileSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
}

model CompileSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CompileSortScriptResponseBody(name='body'),
}

/**
 * @summary Compiles a sort script.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CompileSortScriptResponse
 */
@context("compileSortScriptWithContext")
async function compileSortScriptWithOptions(appGroupIdentity: string, scriptName: string, appVersionId: string, headers: map[string]string, runtime: $RuntimeOptions): CompileSortScriptResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'CompileSortScript',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appVersionId)}/sort-scripts/${$URL.percentEncode(scriptName)}/actions/compiling`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Compiles a sort script.
 *
 * @return CompileSortScriptResponse
 */
async function compileSortScript(appGroupIdentity: string, scriptName: string, appVersionId: string): CompileSortScriptResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return compileSortScriptWithOptions(appGroupIdentity, scriptName, appVersionId, headers, runtime);
}

model CreateABTestExperimentRequest {
  body?: ABTestExperiment(name='body', description='The request body.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run. This parameter is only used to check whether the data source is valid. Valid values: true and false.', example='false'),
}

model CreateABTestExperimentResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the experiment was created.', example='0'),
    id?: string(name='id', description='The experiment ID.', example='12889'),
    name?: string(name='name', description='The experiment alias.', example='test3'),
    online?: boolean(name='online', description='Indicates whether the experiment is in effect. Valid values:

*   true
*   false', example='true'),
    params?: map[string]any(name='params', description='The experiment parameters.', example='{"firstFormulaName": "default"}'),
    traffic?: int32(name='traffic', description='The percentage of traffic that is routed to the experiment.', example='30'),
    updated?: int32(name='updated', description='The time when the experiment was last modified.', example='1589017861'),
  }(name='result', description='The experiment details.'),
}

model CreateABTestExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateABTestExperimentResponseBody(name='body'),
}

/**
 * @summary Creates an experiment.
 *
 * @param request CreateABTestExperimentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateABTestExperimentResponse
 */
@context("createABTestExperimentWithContext")
async function createABTestExperimentWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, request: CreateABTestExperimentRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateABTestExperimentResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateABTestExperiment',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scenes/${$URL.percentEncode(sceneId)}/groups/${$URL.percentEncode(groupId)}/experiments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an experiment.
 *
 * @param request CreateABTestExperimentRequest
 * @return CreateABTestExperimentResponse
 */
async function createABTestExperiment(appGroupIdentity: string, sceneId: string, groupId: string, request: CreateABTestExperimentRequest): CreateABTestExperimentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createABTestExperimentWithOptions(appGroupIdentity, sceneId, groupId, request, headers, runtime);
}

model CreateABTestGroupRequest {
  body?: ABTestGroup(name='body', description='The request body. For more information, see [ABTestGroup](https://help.aliyun.com/document_detail/178935.html).'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to check the validity of input parameters. Default value: false.

Valid values:

*   **true**: checks only the validity of input parameters.
*   **false**: checks the validity of input parameters and creates an attribution configuration.', example='true'),
}

model CreateABTestGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test group was created.', example='1588839490'),
    id?: string(name='id', description='The ID of the test group.', example='13466'),
    name?: string(name='name', description='The alias of the test group.', example='Group_2020-5-7_15:23:3'),
    status?: int32(name='status', description='The status of the test group.

*   0: not in effect
*   1: in effect', example='1'),
    updated?: int32(name='updated', description='The time when the test group was last updated.', example='1588839490'),
  }(name='result', description='The returned results.'),
}

model CreateABTestGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateABTestGroupResponseBody(name='body'),
}

/**
 * @summary Creates a test group.
 *
 * @param request CreateABTestGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateABTestGroupResponse
 */
@context("createABTestGroupWithContext")
async function createABTestGroupWithOptions(appGroupIdentity: string, sceneId: string, request: CreateABTestGroupRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateABTestGroupResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateABTestGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scenes/${$URL.percentEncode(sceneId)}/groups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a test group.
 *
 * @param request CreateABTestGroupRequest
 * @return CreateABTestGroupResponse
 */
async function createABTestGroup(appGroupIdentity: string, sceneId: string, request: CreateABTestGroupRequest): CreateABTestGroupResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createABTestGroupWithOptions(appGroupIdentity, sceneId, request, headers, runtime);
}

model CreateABTestSceneRequest {
  body?: ABTestScene(name='body', description='The ABTest scenario. For more information, see [ABTestScene](https://help.aliyun.com/document_detail/173618.html)'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to check the validity of input parameters. Default value: false.

Valid values:

*   **true**: checks only the validity of input parameters.
*   **false**: checks the validity of input parameters and creates an attribution configuration.', example='false'),
}

model CreateABTestSceneResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test scenario was created.', example='0'),
    id?: string(name='id', description='The ID of the test group.', example='20405'),
    name?: string(name='name', description='The name of the A/B test group.', example='kevintest_2020-5-7_15:21:48'),
    status?: int32(name='status', description='The status. Valid values:

*   0: not in effect
*   1: in effect', example='1'),
    updated?: int32(name='updated', description='The time when the test scenario was last updated.', example='1589012351'),
    values?: [ string ](name='values', description='The ID of the test scenario'),
  }(name='result', description='The returned data.'),
}

model CreateABTestSceneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateABTestSceneResponseBody(name='body'),
}

/**
 * @summary Creates an scenario.
 *
 * @param request CreateABTestSceneRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateABTestSceneResponse
 */
@context("createABTestSceneWithContext")
async function createABTestSceneWithOptions(appGroupIdentity: string, request: CreateABTestSceneRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateABTestSceneResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateABTestScene',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scenes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an scenario.
 *
 * @param request CreateABTestSceneRequest
 * @return CreateABTestSceneResponse
 */
async function createABTestScene(appGroupIdentity: string, request: CreateABTestSceneRequest): CreateABTestSceneResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createABTestSceneWithOptions(appGroupIdentity, request, headers, runtime);
}

model CreateAppRequest {
  autoSwitch?: boolean(name='autoSwitch', description='Specifies whether to automatically switch the created version to an online version. Valid values:

*   true
*   false', example='false'),
  cluster?: {
    chunkModels?: [  map[string]any ](name='chunkModels'),
    graphRag?: map[string]any(name='graphRag'),
    imageContentRecognizerModels?: [  map[string]any ](name='imageContentRecognizerModels'),
    maxQueryClauseLength?: int32(name='maxQueryClauseLength', description='The maximum length of the query clause.', example='1024'),
    maxTimeoutMS?: int32(name='maxTimeoutMS', description='The timeout period. Unit: milliseconds.', example='750'),
    textEmbeddingModel?: string(name='textEmbeddingModel', example='ops-text-embedding-002'),
    textSparseEmbeddingModel?: string(name='textSparseEmbeddingModel', example='ops-text-sparse-embedding-001'),
    vectorIndexConfigs?: [  map[string]any ](name='vectorIndexConfigs'),
  }(name='cluster', description='The capability opening configurations.'),
  configItems?: [  map[string]any ](name='configItems'),
  dataSources?: [ 
    {
      fields?: [  map[string]any ](name='fields', description='The information about field mappings.'),
      keyField?: string(name='keyField', description='The primary key.', example='id'),
      parameters?: map[string]any(name='parameters', description='The information about the data source.', example='{
  "instanceId": "rds-instance-id",
  "dbName": "my_db",
  "dbTableName": "my_table",
  "dbUser": "my",
  "dbPassword": "my_passwd",
  "filter":"",
  "autoSync": true
}'),
      plugins?: map[string]any(name='plugins', description='The plug-ins that are used for data processing.

name:

*   JsonKeyValueExtractor
*   MultiValueSpliter
*   KeyValueExtractor
*   StringCatenateExtractor
*   HTMLTagRemover

parameters:

*   JsonKeyValueExtractor
*   MultiValueSpliter
*   KeyValueExtractor
*   StringCatenateExtractor
*   HTMLTagRemover', example='{
  "name": "JsonKeyValueExtractor",
  "parameters": {
  "key": "my_field"
}
}'),
      schemaName?: string(name='schemaName', description='The name of the wide table.', example='table_name'),
      tableName?: string(name='tableName', description='The name of the table in the application.', example='main'),
      type?: string(name='type', description='The type of the data source. Valid values:

*   rds
*   odps
*   opensearch
*   polardb', example='rds'),
    }
  ](name='dataSources', description='The configurations of data sources.'),
  description?: string(name='description', description='The version description.', example='"Version description"'),
  domain?: {
    category?: string(name='category', description='The industry category.', example='general'),
    functions?: map[string]any(name='functions', description='The selected feature category. Valid values:

*   qp: query analysis
*   algo: sort policy
*   service: service', example='{"qp":["spellcheck"],"algo":["pop"],"service":["suggest"]}'),
    name?: string(name='name', description='The industry type.', example='ecommerce'),
  }(name='domain', description='The industry model module.'),
  fetchFields?: [ string ](name='fetchFields', description='The default display fields.'),
  firstRanks?: [ 
    {
      active?: boolean(name='active', description='Specifies whether the expression is the default one.', example='False'),
      description?: string(name='description', description='The description.', example='Description'),
      meta?: any(name='meta', description='The information about the expression. The information can be of the array or string type.', example='String :"random()*100+now()";
Array: [
    {
      "attribute": "static_bm25()",
      "arg": "",
      "weight": 10
    }
  ]'),
      name?: string(name='name', description='The name of the rough sort expression.', example='test'),
      type?: string(name='type', description='The expression type. Valid values:

*   STRUCT: The content of the expression is a structure.
*   STRING (default): You can configure a custom formula.', example='STRING'),
    }
  ](name='firstRanks', description='The configurations of rough sort.'),
  interpretations?: [  map[string]any ](name='interpretations'),
  networkType?: string(name='networkType', description='The zone identifier. Valid values:

*   vpc
*   oxs', example='vpc'),
  prompts?: [  map[string]any ](name='prompts'),
  queryProcessors?: [ 
    {
      active?: boolean(name='active', description='Specifies whether the rule is the default one.', example='True'),
      category?: string(name='category', description='The industry category.', example='""'),
      domain?: string(name='domain', description='The industry type. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='ECOMMERCE'),
      indexes?: [ string ](name='indexes', description='The index range.'),
      name?: string(name='name', description='The rule name.', example='name'),
      processors?: [  map[string]any ](name='processors', description='The features.'),
    }
  ](name='queryProcessors', description='The query intent understanding configurations.'),
  realtimeShared?: boolean(name='realtimeShared'),
  schema?: {
    indexSortConfig?: [ 
      {
        direction?: string(name='direction', description='The sort method.', example='ASC;
DESC;'),
        field?: string(name='field', description='The sort field.', example='field1'),
      }
    ](name='indexSortConfig', description='The sort configurations.'),
    indexes?: {
      filterFields?: [ string ](name='filterFields', description='The attribute fields.'),
      searchFields?: map[string]any(name='searchFields', description='The index fields.', example='{
  "fields": ["title"],
  "analyzer": "chn_standard"
}'),
    }(name='indexes', description='The index schema.'),
    name?: string(name='name', description='The name of the wide table.', example='table_name'),
    routeField?: string(name='routeField', description='The name of the level-1 routing field.', example='field1'),
    routeFieldValues?: [ string ](name='routeFieldValues', description='The hot values of the level-1 routing field. After you configure this parameter, level-2 routing is enabled.'),
    secondRouteField?: string(name='secondRouteField', description='The name of the level-2 routing field. This parameter takes effect only when the `routeFieldValues` parameter is configured. By default, the wide-table primary key field is used as the level-2 routing field.', example='field2'),
    tables?: map[string]any(name='tables', description='The table schema.', example='{
	"primaryTable": true,
	"name": "main",
	"fields": {
		"id": {
			"name": "id",
			"type": "LITERAL",
			"primaryKey": true
		},
		"title": {
			"name": "title",
			"type": "TEXT",
			"primaryKey": false
		},
		"buy": {
			"name": "buy",
			"type": "INT",
			"primaryKey": false
		},
		"cate_id": {
			"name": "cate_id",
			"type": "INT",
			"primaryKey": false
		},
		"cate_name": {
			"name": "cate_name",
			"type": "LITERAL",
			"primaryKey": false
		}
	}
}'),
    ttlField?: {
      name?: string(name='name', description='The name of the document time field.', example='text1'),
      ttl?: long(name='ttl', description='The TTL. Unit: milliseconds.', example='1000'),
    }(name='ttlField', description='The document clearing configurations.'),
  }(name='schema', description='The single-table schema.'),
  schemas?: [ 
    {
      indexSortConfig?: [ 
        {
          direction?: string(name='direction', description='The sort method.

*   ASC
*   DESC', example='DESC'),
          field?: string(name='field', description='The sort field.', example='field1'),
        }
      ](name='indexSortConfig', description='The sort configurations.'),
      indexes?: {
        filterFields?: [ string ](name='filterFields', description='The attribute fields.'),
        searchFields?: map[string]any(name='searchFields', description='The index fields.', example='{
  "fields": ["title"],
  "analyzer": "chn_standard"
}'),
      }(name='indexes', description='The index schema.'),
      name?: string(name='name', description='The name of the wide table.', example='table_name'),
      routeField?: string(name='routeField', description='The name of the level-1 routing field.', example='field1'),
      routeFieldValues?: [ string ](name='routeFieldValues', description='The hot values of the level-1 routing field. After you configure this parameter, level-2 routing is enabled.'),
      secondRouteField?: string(name='secondRouteField', description='The name of the level-2 routing field. This parameter takes effect only when the routeFieldValues parameter is configured. By default, the wide-table primary key field is used as the level-2 routing field.', example='field2'),
      tables?: map[string]any(name='tables', description='The table schema.', example='{
	"primaryTable": true,
	"name": "main",
	"fields": {
		"id": {
			"name": "id",
			"type": "LITERAL",
			"primaryKey": true
		},
		"title": {
			"name": "title",
			"type": "TEXT",
			"primaryKey": false
		},
		"buy": {
			"name": "buy",
			"type": "INT",
			"primaryKey": false
		},
		"cate_id": {
			"name": "cate_id",
			"type": "INT",
			"primaryKey": false
		},
		"cate_name": {
			"name": "cate_name",
			"type": "LITERAL",
			"primaryKey": false
		}
	}
}'),
      ttlField?: {
        name?: string(name='name', description='The name of the document time field.', example='text1'),
        ttl?: long(name='ttl', description='The TTL. Unit: milliseconds.', example='1000'),
      }(name='ttlField', description='The document clearing configurations.'),
    }
  ](name='schemas', description='The multi-table schema.'),
  secondRanks?: [ 
    {
      active?: boolean(name='active', description='Specifies whether the expression is the default one.', example='False'),
      description?: string(name='description', description='The description.', example='Description'),
      meta?: any(name='meta', description='The fine sort expression. You can define an expression that contains fields, feature functions, and mathematical functions to implement complex sort logic.', example='"cate_id > 0 and cate_id < 1000"'),
      name?: string(name='name', description='The name of the fine sort expression.', example='default'),
    }
  ](name='secondRanks', description='The configurations of fine sort.'),
  summaries?: [ 
    {
      meta?: [ 
        {
          element?: string(name='element', description='The element that is used for highlighting.', example='em'),
          ellipsis?: string(name='ellipsis', description='The connector that is used to connect segments.', example='...'),
          field?: string(name='field', description='The field.', example='field1'),
          len?: int32(name='len', description='The length of the segment. Valid values: 1 to 300.', example='50'),
          snippet?: string(name='snippet', description='The number of segments. Valid values: 1 to 5.', example='1'),
        }
      ](name='meta', description='The collection of summary configurations.'),
      name?: string(name='name', description='The group name.', example='default'),
    }
  ](name='summaries', description='The summary configurations of search results.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run. This parameter is only used to check whether the data source is valid. Valid values: true and false.', example='true'),
}

model CreateAppResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFG'),
  result?: {
    cluster?: {
      chunkModels?: [  map[string]any ](name='chunkModels'),
      graphRag?: map[string]any(name='graphRag'),
      imageContentRecognizerModels?: [  map[string]any ](name='imageContentRecognizerModels'),
      maxQueryClauseLength?: int32(name='maxQueryClauseLength', description='The maximum length of the query clause.', example='1024'),
      maxTimeoutMS?: int32(name='maxTimeoutMS', description='The timeout period. Unit: milliseconds.', example='750'),
      textEmbeddingModel?: string(name='textEmbeddingModel'),
      textSparseEmbeddingModel?: string(name='textSparseEmbeddingModel'),
      vectorIndexConfigs?: [  map[string]any ](name='vectorIndexConfigs'),
    }(name='cluster', description='The capability opening configurations.'),
    clusterName?: string(name='clusterName', description='The name of the cluster.', example='vpc_sh_domain_1', deprecated=true),
    configItems?: [  map[string]any ](name='configItems'),
    created?: long(name='created'),
    dataSources?: [ 
      {
        fields?: [  map[string]any ](name='fields', description='The information about field mappings.'),
        keyField?: string(name='keyField', description='The primary key.', example='id'),
        parameters?: map[string]any(name='parameters', description='The information about the data source.', example='{
  "instanceId": "rds-instance-id",
  "dbName": "my_db",
  "dbTableName": "my_table",
  "dbUser": "my",
  "dbPassword": "my_passwd",
  "filter":"",
  "autoSync": true
}'),
        plugins?: map[string]any(name='plugins', description='The plug-ins that are used for data processing.

name:

*   JsonKeyValueExtractor
*   MultiValueSpliter
*   KeyValueExtractor
*   StringCatenateExtractor
*   HTMLTagRemover

parameters:

*   JsonKeyValueExtractor
*   MultiValueSpliter
*   KeyValueExtractor
*   StringCatenateExtractor
*   HTMLTagRemover', example='{
  "name": "JsonKeyValueExtractor",
  "parameters": {
  "key": "my_field"
}
}'),
        schemaName?: string(name='schemaName', description='The name of the wide table.', example='table_name'),
        tableName?: string(name='tableName', description='The name of the table in the application.', example='main'),
        type?: string(name='type', description='The type of the data source. Valid values:

*   rds
*   odps
*   opensearch
*   polardb', example='rds'),
      }
    ](name='dataSources', description='The configurations of the data sources.'),
    description?: string(name='description', description='The description of the application.', example='My application'),
    domain?: {
      category?: string(name='category', description='The industry category.', example='-'),
      functions?: {
        algo?: [ string ](name='algo', description='The features of the sort policy category.'),
        qp?: [ string ](name='qp', description='The features of the query analysis category.'),
        service?: [ string ](name='service', description='The features of the service category.'),
      }(name='functions', description='The selected features.'),
      name?: string(name='name', description='The industry type. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='GENERAL'),
    }(name='domain', description='The industry model module.'),
    fetchFields?: [ string ](name='fetchFields', description='The default display fields.'),
    firstRanks?: [ 
      {
        active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='False'),
        description?: string(name='description', description='The description.', example='Description'),
        meta?: any(name='meta', description='The information about the expression. The information can be of the array or string type.', example='String :"random()*100+now()";
Array: [
    {
      "attribute": "static_bm25()",
      "arg": "",
      "weight": 10
    }
  ]'),
        name?: string(name='name', description='The name of the rough sort expression.', example='test'),
        type?: string(name='type', description='The expression type. Valid values:

STRUCT: The content of the expression is a structure. STRING (default): You can configure a custom formula.', example='STRING'),
      }
    ](name='firstRanks', description='The configurations of rough sort.'),
    id?: string(name='id', description='The application ID.', example='12888'),
    interpretations?: [  map[string]any ](name='interpretations', description='The descriptions of the LLM table fields.', example='{ "name": "longyu_llm_1", "schemas": [], "interpretations": [ { "table": "table1", "fields": [ { "name": "field1", "interpretation": "Title" }, { "name": "field2", "interpretation": "Number" } ] } ] }'),
    isCurrent?: boolean(name='isCurrent', description='Indicates whether the version is an online version.', example='12333'),
    progressPercent?: int32(name='progressPercent', description='The percentage for the data import progress.', example='100'),
    prompts?: [  map[string]any ](name='prompts', description='The prompt configurations'),
    queryProcessors?: [ 
      {
        active?: boolean(name='active', description='Indicates whether the rule is the default one.', example='False'),
        category?: string(name='category', description='The industry category.', example='""'),
        domain?: string(name='domain', description='The industry type. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='GENERAL'),
        indexes?: [ string ](name='indexes', description='The index range.'),
        name?: string(name='name', description='The rule name.', example='test'),
        processors?: [  map[string]any ](name='processors', description='The features.'),
      }
    ](name='queryProcessors', description='The query intent understanding configurations.'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The computing resources.', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity.', example='1'),
      qps?: int32(name='qps', description='The search request.', example='5'),
      spec?: string(name='spec', description='The specifications. Valid values:

*   opensearch.share.junior: basic
*   opensearch.share.common: shared general-purpose
*   opensearch.share.compute: shared computing
*   opensearch.share.storage: shared storage
*   opensearch.private.common: exclusive general-purpose
*   opensearch.private.compute: exclusive computing
*   opensearch.private.storage: exclusive storage', example='opensearch.share.common'),
      usedComputeResource?: int32(name='usedComputeResource', example='100'),
      usedDocSize?: double(name='usedDocSize', example='1024'),
      usedQps?: int32(name='usedQps', example='100'),
    }(name='quota', description='The quota.'),
    schema?: {
      indexSortConfig?: [ 
        {
          direction?: string(name='direction', description='The sort method. Valid values:

*   ASC
*   DESC', example='DESC'),
          field?: string(name='field', description='The sort field.', example='field1'),
        }
      ](name='indexSortConfig', description='The sort configurations.'),
      indexes?: {
        filterFields?: [ string ](name='filterFields', description='The attribute fields.'),
        searchFields?: map[string]any(name='searchFields', description='The index fields.', example='{
  "fields": ["title"],
  "analyzer": "chn_standard"
}'),
      }(name='indexes', description='The index schema.'),
      name?: string(name='name', description='The name of the wide table.', example='test'),
      routeField?: string(name='routeField', description='The name of the level-1 routing field.', example='field1'),
      routeFieldValues?: [ string ](name='routeFieldValues', description='The name of the level-2 routing field. This parameter takes effect only when the routeFieldValues parameter is configured. By default, the wide-table primary key field is used as the level-2 routing field.'),
      secondRouteField?: string(name='secondRouteField', description='The name of the level-2 routing field. This parameter takes effect only when the routeFieldValues parameter is configured. By default, the wide-table primary key field is used as the level-2 routing field.', example='field2'),
      tables?: map[string]any(name='tables', description='The table schema.', example='{
	"primaryTable": true,
	"name": "main",
	"fields": {
		"id": {
			"name": "id",
			"type": "LITERAL",
			"primaryKey": true
		},
		"title": {
			"name": "title",
			"type": "TEXT",
			"primaryKey": false
		},
		"buy": {
			"name": "buy",
			"type": "INT",
			"primaryKey": false
		},
		"cate_id": {
			"name": "cate_id",
			"type": "INT",
			"primaryKey": false
		},
		"cate_name": {
			"name": "cate_name",
			"type": "LITERAL",
			"primaryKey": false
		}
	}
}'),
      ttlField?: {
        name?: string(name='name', description='The name of the document time field.', example='text1'),
        ttl?: long(name='ttl', description='The TTL. Unit: milliseconds.', example='1000'),
      }(name='ttlField', description='The document clearing configurations.'),
    }(name='schema', description='The single-table schema.'),
    schemas?: [ 
      {
        indexSortConfig?: [ 
          {
            direction?: string(name='direction', description='The sort method. Valid values:

*   ASC
*   DESC', example='DESC'),
            field?: string(name='field', description='The sort field.', example='fIeld1'),
          }
        ](name='indexSortConfig', description='The sort configurations.'),
        indexes?: {
          filterFields?: [ string ](name='filterFields', description='The attribute fields.'),
          searchFields?: map[string]any(name='searchFields', description='The index fields.', example='{
  "fields": ["title"],
  "analyzer": "chn_standard"
}'),
        }(name='indexes', description='The index schema.'),
        name?: string(name='name', description='The name of the wide table.', example='main'),
        routeField?: string(name='routeField', description='The name of the level-1 routing field.', example='field1'),
        routeFieldValues?: [ string ](name='routeFieldValues', description='The hot values of the level-1 routing field. After you configure this parameter, level-2 routing is enabled.'),
        secondRouteField?: string(name='secondRouteField', description='The name of the level-2 routing field. This parameter takes effect only when the routeFieldValues parameter is configured. By default, the wide-table primary key field is used as the level-2 routing field.', example='field2'),
        tables?: map[string]any(name='tables', description='The table schema.', example='{
	"primaryTable": true,
	"name": "main",
	"fields": {
		"id": {
			"name": "id",
			"type": "LITERAL",
			"primaryKey": true
		},
		"title": {
			"name": "title",
			"type": "TEXT",
			"primaryKey": false
		},
		"buy": {
			"name": "buy",
			"type": "INT",
			"primaryKey": false
		},
		"cate_id": {
			"name": "cate_id",
			"type": "INT",
			"primaryKey": false
		},
		"cate_name": {
			"name": "cate_name",
			"type": "LITERAL",
			"primaryKey": false
		}
	}
}'),
        ttlField?: {
          name?: string(name='name', description='The name of the document time field.', example='fIeld1'),
          ttl?: long(name='ttl', description='The TTL. Unit: milliseconds.', example='1000'),
        }(name='ttlField', description='The document clearing configurations.'),
      }
    ](name='schemas', description='The multi-table schema.'),
    secondRanks?: [ 
      {
        active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='False'),
        description?: string(name='description', description='The description.', example='default'),
        meta?: any(name='meta', description='The fine sort expression. You can define an expression that contains fields, feature functions, and mathematical functions to implement complex sort logic.', example='"cate_id > 0 and cate_id < 1000"'),
        name?: string(name='name', description='The name of the fine sort expression.', example='default'),
      }
    ](name='secondRanks', description='The configurations of fine sort.'),
    status?: string(name='status', description='The status of the application. Valid values:

*   OK
*   STOPPED
*   FROZEN
*   INITIALIZING
*   UNAVAILABLE
*   DATA_WAITING
*   DATA_PREPARING', example='OK'),
    summaries?: [ 
      {
        meta?: [ 
          {
            element?: string(name='element', description='The element that is used for highlighting.', example='em'),
            ellipsis?: string(name='ellipsis', description='The connector that is used to connect segments.', example='...'),
            field?: string(name='field', description='The field.', example='field1'),
            len?: int32(name='len', description='The length of the segment. Valid values: 1 to 300.', example='50'),
            snippet?: string(name='snippet', description='The number of segments. Valid values: 1 to 5.', example='5'),
          }
        ](name='meta', description='The collection of summary configurations.'),
        name?: string(name='name', description='The group name.', example='fefault'),
      }
    ](name='summaries', description='The summary configurations of search results.'),
    switchTime?: long(name='switchTime'),
    type?: string(name='type', description='The type of the application. Valid values:

*   standard
*   enhanced', example='standard'),
    updated?: long(name='updated'),
  }(name='result', description='The response parameters.', example='{}'),
}

model CreateAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAppResponseBody(name='body'),
}

/**
 * @summary Creates a version for an OpenSearch application.
 *
 * @description *   When you create a standard application, a new version of the application is created if the specified application name already exists.
 * *   When you create a version of an existing application, you must specify the autoSwitch and realtimeShared parameters.
 * *   When you create a version of an existing application, the value of the quota parameter is the same as that of the quota parameter in the previous version of the application.
 * *   When you create a version of an existing application, the modification of the value of the quota parameter does not take effect.
 *
 * @param request CreateAppRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAppResponse
 */
@context("createAppWithContext")
async function createAppWithOptions(appGroupIdentity: string, request: CreateAppRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateAppResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!$isNull(request.autoSwitch)) {
    body['autoSwitch'] = request.autoSwitch;
  }
  if (!$isNull(request.cluster)) {
    body['cluster'] = request.cluster;
  }
  if (!$isNull(request.configItems)) {
    body['configItems'] = request.configItems;
  }
  if (!$isNull(request.dataSources)) {
    body['dataSources'] = request.dataSources;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.domain)) {
    body['domain'] = request.domain;
  }
  if (!$isNull(request.fetchFields)) {
    body['fetchFields'] = request.fetchFields;
  }
  if (!$isNull(request.firstRanks)) {
    body['firstRanks'] = request.firstRanks;
  }
  if (!$isNull(request.interpretations)) {
    body['interpretations'] = request.interpretations;
  }
  if (!$isNull(request.networkType)) {
    body['networkType'] = request.networkType;
  }
  if (!$isNull(request.prompts)) {
    body['prompts'] = request.prompts;
  }
  if (!$isNull(request.queryProcessors)) {
    body['queryProcessors'] = request.queryProcessors;
  }
  if (!$isNull(request.realtimeShared)) {
    body['realtimeShared'] = request.realtimeShared;
  }
  if (!$isNull(request.schema)) {
    body['schema'] = request.schema;
  }
  if (!$isNull(request.schemas)) {
    body['schemas'] = request.schemas;
  }
  if (!$isNull(request.secondRanks)) {
    body['secondRanks'] = request.secondRanks;
  }
  if (!$isNull(request.summaries)) {
    body['summaries'] = request.summaries;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateApp',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a version for an OpenSearch application.
 *
 * @description *   When you create a standard application, a new version of the application is created if the specified application name already exists.
 * *   When you create a version of an existing application, you must specify the autoSwitch and realtimeShared parameters.
 * *   When you create a version of an existing application, the value of the quota parameter is the same as that of the quota parameter in the previous version of the application.
 * *   When you create a version of an existing application, the modification of the value of the quota parameter does not take effect.
 *
 * @param request CreateAppRequest
 * @return CreateAppResponse
 */
async function createApp(appGroupIdentity: string, request: CreateAppRequest): CreateAppResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createAppWithOptions(appGroupIdentity, request, headers, runtime);
}

model CreateAppGroupRequest {
  chargeType?: string(name='chargeType', description='The billing method. Valid values:

*   POSTPAY: pay-as-you-go
*   PREPAY: subscription', example='POSTPAY'),
  name?: string(name='name', description='The name of the application.', example='jmbon_analyzer'),
  quota?: {
    computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing unit (LCU).', example='20'),
    docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
    spec?: string(name='spec', description='The specifications. Valid values:

*   opensearch.share.junior: basic
*   opensearch.share.common: shared general-purpose
*   opensearch.share.compute: shared computing
*   opensearch.share.storage: shared storage
*   opensearch.private.common: exclusive general-purpose
*   opensearch.private.compute: exclusive computing
*   opensearch.private.storage: exclusive storage', example='opensearch.share.common'),
  }(name='quota', description='The quota.'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-acfm2ij6pwxsvua'),
  tags?: [ 
    {
      key?: string(name='key', description='The tag key.', example='a'),
      value?: string(name='value', description='The tag value.', example='1'),
    }
  ](name='tags', description='The tags.'),
  type?: string(name='type', description='The type of the application. Valid values:

*   standard
*   enhanced', example='enhanced'),
}

model CreateAppGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='766CF6DB-CA02-3E12-7CBA-6AC21FC978FD'),
  result?: {
    chargeType?: string(name='chargeType', description='The billing method. Valid values:

*   POSTPAY: pay-as-you-go.
*   PREPAY: subscription.', example='POSTPAY'),
    chargingWay?: int32(name='chargingWay', description='The type of billing. Valid values:

*   1: computing resources.
*   2: queries per second (QPS).', example='1'),
    commodityCode?: string(name='commodityCode', description='The commodity code.', example='opensearch'),
    created?: int32(name='created', description='The timestamp when the application was created.', example='1590139542'),
    currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='100302903'),
    description?: string(name='description', description='The description of the application.', example='-'),
    domain?: string(name='domain', description='The type of the industry. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='GENERAL'),
    engineType?: string(name='engineType', description='The engine type.', example='ha3'),
    expireOn?: string(name='expireOn', description='The expiration time.', example='-'),
    hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval state of the quotas. Valid values:

*   0: The application is in service.
*   1: The quotas are being reviewed.', example='0'),
    id?: string(name='id', description='The application ID.', example='100302881'),
    instanceId?: string(name='instanceId', description='The ID of the instance.', example='-'),
    lockMode?: string(name='lockMode', description='The lock state. Valid values:

*   Unlock: The instance is unlocked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
    name?: string(name='name', description='The name of the application.', example='lsh_test_1'),
    produced?: int32(name='produced', description='Indicates whether the application is created. Valid values:

*   0: The application is being created.
*   1: The application is created.', example='1'),
    projectId?: string(name='projectId', description='The name of the A/B test group.', example='-'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing units (LCUs).', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
      spec?: string(name='spec', description='The specifications. Valid values:

*   opensearch.share.junior: basic.
*   opensearch.share.common: shared general-purpose.
*   opensearch.share.compute: shared computing.
*   opensearch.share.storage: shared storage.
*   opensearch.private.common: exclusive general-purpose.
*   opensearch.private.compute: exclusive computing.
*   opensearch.private.storage: exclusive storage.', example='opensearch.share.common'),
    }(name='quota', description='The information about the quotas of the application.'),
    status?: string(name='status', description='The status of the application. Valid values:

*   producing: The application is being created.
*   review_pending: The application is being reviewed.
*   config_pending: The application is to be configured.
*   normal: The application is in service.
*   frozen: The application is frozen.', example='normal'),
    switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='1590486386'),
    type?: string(name='type', description='The type of the application. Valid values:

*   standard: a standard edition application.
*   advance: an advanced edition which is of an old version. New version is not supported for this edition.
*   enhanced: an advanced edition application of a new version.', example='enhanced'),
    updated?: int32(name='updated', description='The timestamp when the application was last modified.', example='1590978265'),
  }(name='result', description='None'),
}

model CreateAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAppGroupResponseBody(name='body'),
}

/**
 * @summary Creates an OpenSearch application.
 *
 * @param request CreateAppGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAppGroupResponse
 */
@context("createAppGroupWithContext")
async function createAppGroupWithOptions(request: CreateAppGroupRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateAppGroupResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.chargeType)) {
    body['chargeType'] = request.chargeType;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }
  if (!$isNull(request.quota)) {
    body['quota'] = request.quota;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!$isNull(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateAppGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an OpenSearch application.
 *
 * @param request CreateAppGroupRequest
 * @return CreateAppGroupResponse
 */
async function createAppGroup(request: CreateAppGroupRequest): CreateAppGroupResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createAppGroupWithOptions(request, headers, runtime);
}

model CreateAppGroupCredentialsRequest {
  type?: string(name='type', example='api-token'),
  dryRun?: boolean(name='dryRun'),
}

model CreateAppGroupCredentialsResponseBody = {
  requestId?: string(name='requestId', example='1-2-3-4'),
  result?: {
    appGroupId?: long(name='appGroupId', example='app_group_123'),
    enabled?: boolean(name='enabled'),
    token?: string(name='token', example='generated_token_string'),
    type?: string(name='type', example='api-token'),
  }(name='result'),
}

model CreateAppGroupCredentialsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAppGroupCredentialsResponseBody(name='body'),
}

/**
 * @param request CreateAppGroupCredentialsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAppGroupCredentialsResponse
 */
@context("createAppGroupCredentialsWithContext")
async function createAppGroupCredentialsWithOptions(appGroupIdentity: string, request: CreateAppGroupCredentialsRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateAppGroupCredentialsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!$isNull(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateAppGroupCredentials',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/credentials`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateAppGroupCredentialsRequest
 * @return CreateAppGroupCredentialsResponse
 */
async function createAppGroupCredentials(appGroupIdentity: string, request: CreateAppGroupCredentialsRequest): CreateAppGroupCredentialsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createAppGroupCredentialsWithOptions(appGroupIdentity, request, headers, runtime);
}

model CreateFirstRankRequest {
  body?: FirstRank(name='body', description='The request body that contains the parameters of the rough sort expression.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run.', example='true'),
}

model CreateFirstRankResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
    meta?: [ 
      {
        arg?: string(name='arg', description='The parameters that are used by a function in the expression.', example='1'),
        attribute?: string(name='attribute', description='The attribute, feature functions, or field to be searched for.', example='static_bm25()'),
        weight?: float(name='weight', description='The weight. Valid values: [-100000,100000]. The value cannot be 0.', example='10'),
      }
    ](name='meta', description='The content of the expression.'),
    name?: string(name='name', description='The name of the expression.', example='default'),
  }(name='result', description='The information about the rough sort expression.'),
}

model CreateFirstRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFirstRankResponseBody(name='body'),
}

/**
 * @summary Creates a rough sort expression for a version of an OpenSearch application. If you set dryRun to true, this operation checks the specified rough sort expression. By default, the value of dryRun is false if you do not set this parameter.
 *
 * @param request CreateFirstRankRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFirstRankResponse
 */
@context("createFirstRankWithContext")
async function createFirstRankWithOptions(appGroupIdentity: string, appId: string, request: CreateFirstRankRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateFirstRankResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateFirstRank',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/first-ranks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a rough sort expression for a version of an OpenSearch application. If you set dryRun to true, this operation checks the specified rough sort expression. By default, the value of dryRun is false if you do not set this parameter.
 *
 * @param request CreateFirstRankRequest
 * @return CreateFirstRankResponse
 */
async function createFirstRank(appGroupIdentity: string, appId: string, request: CreateFirstRankRequest): CreateFirstRankResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createFirstRankWithOptions(appGroupIdentity, appId, request, headers, runtime);
}

model CreateFunctionInstanceRequest {
  createParameters?: [ 
    {
      name?: string(name='name', description='The parameter name.', example='title_field'),
      value?: string(name='value', description='The parameter value.', example='title'),
    }
  ](name='createParameters', description='The parameters used to create the instance.', example='[   { "name": "param1", "value": "val1"   } ]'),
  cron?: string(name='cron', description='The CRON expression used to schedule periodic training, in the format of Minutes Hours DayofMonth Month DayofWeek. The default value is empty, which specifies that no periodic training is performed. A value of 0 for DayofWeek specifies Sunday.', example='0 0 ? * 0,1,2,3,4,5,6'),
  description?: string(name='description', description='The description.', example='test instance'),
  functionType?: string(name='functionType', description='The feature type.

*   Default value: PAAS. Training is required before you can use the feature.', example='PAAS'),
  instanceName?: string(name='instanceName', description='The instance name. The name must be 1 to 30 characters in length and can contain letters, digits, and underscores (_). The name is case-sensitive and must start with a letter.

This parameter is required.', example='ctr_test'),
  modelType?: string(name='modelType', description='The model type. The value varies based on the model.

*   Click-through rate (CTR) model: tf_checkpoint
*   Popularity model: pop
*   Category model: offline_inference
*   Hotword model: offline_inference
*   Hint model: offline_inference
*   Hotword model for real-time top searches: near_realtime
*   Personalized hint model: near_realtime
*   Drop-down suggestion model: offline_inference
*   Tokenization model: text
*   Term weight model: tf_checkpoint
*   Synonym model: offline_inference

This parameter is required.', example='tf_checkpoint'),
  usageParameters?: [ 
    {
      name?: string(name='name', description='The parameter name.', example='allow_dict_id'),
      value?: string(name='value', description='The parameter value.', example='123'),
    }
  ](name='usageParameters', description='The parameters used to use the instance.'),
}

model CreateFunctionInstanceResponseBody = {
  code?: string(name='Code', description='The error code.', example='Version.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message. If no error occurs, this parameter is left empty.', example='version not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='98724351-D6B2-5D8A-B089-7FFD1821A7E9'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model CreateFunctionInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFunctionInstanceResponseBody(name='body'),
}

/**
 * @summary Creates an algorithm instance of a feature.
 *
 * @description You can call the [GetFunctionCurrentVersion](https://help.aliyun.com/document_detail/421377.html) operation to query the latest version of a feature. The response of the operation includes the createParameters parameter that is used to create an algorithm instance, the usageParameters parameter, and the requirements for setting these parameters.
 *
 * @param request CreateFunctionInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFunctionInstanceResponse
 */
@context("createFunctionInstanceWithContext")
async function createFunctionInstanceWithOptions(appGroupIdentity: string, functionName: string, request: CreateFunctionInstanceRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateFunctionInstanceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.createParameters)) {
    body['createParameters'] = request.createParameters;
  }
  if (!$isNull(request.cron)) {
    body['cron'] = request.cron;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.functionType)) {
    body['functionType'] = request.functionType;
  }
  if (!$isNull(request.instanceName)) {
    body['instanceName'] = request.instanceName;
  }
  if (!$isNull(request.modelType)) {
    body['modelType'] = request.modelType;
  }
  if (!$isNull(request.usageParameters)) {
    body['usageParameters'] = request.usageParameters;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateFunctionInstance',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/functions/${$URL.percentEncode(functionName)}/instances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an algorithm instance of a feature.
 *
 * @description You can call the [GetFunctionCurrentVersion](https://help.aliyun.com/document_detail/421377.html) operation to query the latest version of a feature. The response of the operation includes the createParameters parameter that is used to create an algorithm instance, the usageParameters parameter, and the requirements for setting these parameters.
 *
 * @param request CreateFunctionInstanceRequest
 * @return CreateFunctionInstanceResponse
 */
async function createFunctionInstance(appGroupIdentity: string, functionName: string, request: CreateFunctionInstanceRequest): CreateFunctionInstanceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createFunctionInstanceWithOptions(appGroupIdentity, functionName, request, headers, runtime);
}

model CreateFunctionResourceRequest {
  data?: {
    content?: string(name='Content', description='The content of the file that corresponds to a resource of the raw_file type.', example='"abc"'),
    generators?: [ 
      {
        generator?: string(name='Generator', description='The type of the feature generator.

Valid values:

*   lookup

    <!-- -->

    <!-- -->

    <!-- -->

*   sequence

    <!-- -->

    <!-- -->

    <!-- -->

*   overlap

    <!-- -->

    <!-- -->

    <!-- -->

*   raw

    <!-- -->

    <!-- -->

    <!-- -->

*   combo

    <!-- -->

    <!-- -->

    <!-- -->

*   id

    <!-- -->

    <!-- -->

    <!-- -->', example='id'),
        input?: {
          features?: [ 
            {
              name?: string(name='Name', description='The name of the feature.', example='system_item_id'),
              type?: string(name='Type', description='The type of the feature.

Valid values:

*   item

    <!-- -->

    <!-- -->

    <!-- -->

*   user

    <!-- -->

    <!-- -->

    <!-- -->', example='item'),
            }
          ](name='Features', description='The input features.'),
        }(name='Input', description='The input.'),
        output?: string(name='Output', description='The name of the output feature.', example='item_id_feature'),
      }
    ](name='Generators', description='The feature generators that correspond to resources of the feature_generator type.'),
  }(name='Data', description='The resource data. The data structure varies with the resource type.'),
  description?: string(name='Description', description='The description of the resource.', example='""'),
  resourceName?: string(name='ResourceName', description='The name of the resource.', example='fg_jsoon'),
  resourceType?: string(name='ResourceType', description='The resource type.

Valid values:

*   feature_generator

    <!-- -->

    <!-- -->

    <!-- -->

*   raw_file

    <!-- -->

    <!-- -->

    <!-- -->', example='feature_generator'),
}

model CreateFunctionResourceResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, this parameter is left empty.', example='""'),
  httpCode?: long(name='HttpCode', description='The HTTP status code returned.', example='200'),
  latency?: double(name='Latency', description='The time consumed for the request. Unit: milliseconds.', example='123'),
  message?: string(name='Message', description='The error message returned.', example='""'),
  requestId?: string(name='RequestId', description='The request ID.', example='A4D487A9-A456-5AA5-A9C6-B7BF2889CF74'),
  status?: string(name='Status', description='The status code. Valid values:

*   OK
*   FAIL', example='OK'),
}

model CreateFunctionResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFunctionResourceResponseBody(name='body'),
}

/**
 * @summary Creates an algorithm resource for a specific feature.
 *
 * @param request CreateFunctionResourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFunctionResourceResponse
 */
@context("createFunctionResourceWithContext")
async function createFunctionResourceWithOptions(appGroupIdentity: string, functionName: string, request: CreateFunctionResourceRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateFunctionResourceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.data)) {
    body['Data'] = request.data;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.resourceName)) {
    body['ResourceName'] = request.resourceName;
  }
  if (!$isNull(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateFunctionResource',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/functions/${$URL.percentEncode(functionName)}/resources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an algorithm resource for a specific feature.
 *
 * @param request CreateFunctionResourceRequest
 * @return CreateFunctionResourceResponse
 */
async function createFunctionResource(appGroupIdentity: string, functionName: string, request: CreateFunctionResourceRequest): CreateFunctionResourceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createFunctionResourceWithOptions(appGroupIdentity, functionName, request, headers, runtime);
}

model CreateFunctionTaskResponseBody = {
  code?: string(name='Code', description='The error code.', example='Task.IsRunning'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1638157990724'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model CreateFunctionTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFunctionTaskResponseBody(name='body'),
}

/**
 * @summary Starts a training task for an algorithm instance.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFunctionTaskResponse
 */
@context("createFunctionTaskWithContext")
async function createFunctionTaskWithOptions(appGroupIdentity: string, functionName: string, instanceName: string, headers: map[string]string, runtime: $RuntimeOptions): CreateFunctionTaskResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateFunctionTask',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/functions/${$URL.percentEncode(functionName)}/instances/${$URL.percentEncode(instanceName)}/tasks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Starts a training task for an algorithm instance.
 *
 * @return CreateFunctionTaskResponse
 */
async function createFunctionTask(appGroupIdentity: string, functionName: string, instanceName: string): CreateFunctionTaskResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createFunctionTaskWithOptions(appGroupIdentity, functionName, instanceName, headers, runtime);
}

model CreateInterventionDictionaryRequest {
  analyzerType?: string(name='analyzerType', description='The type of the analyzer. Valid values:

*   MODEL: model-based custom analyzer.
*   SYSTEM: system analyzer.
*   USER: custom analyzer.', example='SYSTEM'),
  name?: string(name='name', description='The name of the intervention dictionary.', example='ner_dict_ec'),
  type?: string(name='type', description='The type of the intervention dictionary. Valid values:

*   stopword: an intervention dictionary for stop word filtering.
*   synonym: an intervention dictionary for synonym configuration.
*   correction: an intervention dictionary for spelling correction.
*   category_prediction: an intervention dictionary for category prediction.
*   ner: an intervention dictionary for named entity recognition (NER).
*   term_weighting: an intervention dictionary for term weight analysis.
*   suggest_allowlist: a drop-down suggestion whitelist.
*   suggest_denylist: a drop-down suggestion blacklist.
*   hot_allowlist: a top search whitelist.
*   hot_denylist: a top search blacklist.
*   hint_allowlist: a hint whitelist.
*   hint_denylist: a hint blacklist.', example='ner'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Default value: false.

Valid values:

*   **true**
*   **false**', example='false'),
}

model CreateInterventionDictionaryResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='80326EFE-485F-46E7-B291-5A1DD08D2198'),
  result?: {
    analyzer?: string(name='analyzer', description='The custom analyzer.', example='dianshang'),
    created?: string(name='created', description='The time when the test scenario was created.', example='1591086323'),
    name?: string(name='name', description='The name of the test group.', example='testb'),
    type?: string(name='type', description='The type of the intervention dictionary. Valid values:

*   stopword: an intervention dictionary for stop word filtering
*   synonym: an intervention dictionary for synonym configuration
*   correction: an intervention dictionary for spelling correction
*   category_prediction: an intervention dictionary for category prediction
*   ner: an intervention dictionary for named entity recognition (NER)
*   term_weighting: an intervention dictionary for term weight analysis', example='ner'),
    updated?: string(name='updated', description='The time when the intervention dictionary was last updated.', example='1591086323'),
  }(name='result', description='The returned results.'),
}

model CreateInterventionDictionaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateInterventionDictionaryResponseBody(name='body'),
}

/**
 * @summary Create an intervention dictionary.
 *
 * @param request CreateInterventionDictionaryRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateInterventionDictionaryResponse
 */
@context("createInterventionDictionaryWithContext")
async function createInterventionDictionaryWithOptions(request: CreateInterventionDictionaryRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateInterventionDictionaryResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!$isNull(request.analyzerType)) {
    body['analyzerType'] = request.analyzerType;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }
  if (!$isNull(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateInterventionDictionary',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/intervention-dictionaries`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create an intervention dictionary.
 *
 * @param request CreateInterventionDictionaryRequest
 * @return CreateInterventionDictionaryResponse
 */
async function createInterventionDictionary(request: CreateInterventionDictionaryRequest): CreateInterventionDictionaryResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createInterventionDictionaryWithOptions(request, headers, runtime);
}

model CreateQueryProcessorRequest {
  body?: any(name='body', description='The request body.', example='{}'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run.', example='true'),
}

model CreateQueryProcessorResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the query analysis rule is the default one.', example='true'),
    created?: int32(name='created', description='The time when the query analysis rule was created.', example='1587398402'),
    domain?: string(name='domain', description='The type of the industry to which the query analysis rule was applied. Valid values:

*   GENERAL: general.
*   ECOMMERCE: e-commerce.
*   IT_CONTENT: IT content.', example='GENERAL'),
    indexes?: [ string ](name='indexes', description='The indexes to which the query analysis rule was applied.'),
    name?: string(name='name', description='The name of the query analysis rule.', example='query_filter'),
    processors?: [  map[string]any ](name='processors', description='The features that are used in the query analysis rule.

For more information, see [QueryProcessor](https://help.aliyun.com/document_detail/170014.html).'),
    updated?: int32(name='updated', description='The time when the query analysis rule was last modified.', example='1587398402'),
  }(name='result', description='The information about the query analysis rule.'),
}

model CreateQueryProcessorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateQueryProcessorResponseBody(name='body'),
}

/**
 * @summary Creates a query analysis rule. If you set dryRun to true, this operation checks the specified query analysis rule. By default, the value of dryRun is false if you do not set this parameter.
 *
 * @param request CreateQueryProcessorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateQueryProcessorResponse
 */
@context("createQueryProcessorWithContext")
async function createQueryProcessorWithOptions(appGroupIdentity: string, appId: string, request: CreateQueryProcessorRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateQueryProcessorResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateQueryProcessor',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/query-processors`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a query analysis rule. If you set dryRun to true, this operation checks the specified query analysis rule. By default, the value of dryRun is false if you do not set this parameter.
 *
 * @param request CreateQueryProcessorRequest
 * @return CreateQueryProcessorResponse
 */
async function createQueryProcessor(appGroupIdentity: string, appId: string, request: CreateQueryProcessorRequest): CreateQueryProcessorResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createQueryProcessorWithOptions(appGroupIdentity, appId, request, headers, runtime);
}

model CreateScheduledTaskRequest {
  body?: ScheduledTask(name='body', description='The request body.'),
}

model CreateScheduledTaskResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='For more information about a scheduled task, see [ScheduledTask](https://help.aliyun.com/document_detail/173610.html).', example='{}'),
}

model CreateScheduledTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateScheduledTaskResponseBody(name='body'),
}

/**
 * @summary Creates a scheduled task for an OpenSearch application.
 *
 * @param request CreateScheduledTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateScheduledTaskResponse
 */
@context("createScheduledTaskWithContext")
async function createScheduledTaskWithOptions(appGroupIdentity: string, request: CreateScheduledTaskRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateScheduledTaskResponse {
  request.validate();
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateScheduledTask',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scheduled-tasks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a scheduled task for an OpenSearch application.
 *
 * @param request CreateScheduledTaskRequest
 * @return CreateScheduledTaskResponse
 */
async function createScheduledTask(appGroupIdentity: string, request: CreateScheduledTaskRequest): CreateScheduledTaskResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createScheduledTaskWithOptions(appGroupIdentity, request, headers, runtime);
}

model CreateSearchStrategyRequest {
  body?: SearchStrategy(name='body', description='The query policy.'),
}

model CreateSearchStrategyResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='"abc123"'),
}

model CreateSearchStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSearchStrategyResponseBody(name='body'),
}

/**
 * @summary Creates a query policy.
 *
 * @param request CreateSearchStrategyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSearchStrategyResponse
 */
@context("createSearchStrategyWithContext")
async function createSearchStrategyWithOptions(appGroupIdentity: string, appId: string, request: CreateSearchStrategyRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateSearchStrategyResponse {
  request.validate();
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateSearchStrategy',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/search-strategies`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a query policy.
 *
 * @param request CreateSearchStrategyRequest
 * @return CreateSearchStrategyResponse
 */
async function createSearchStrategy(appGroupIdentity: string, appId: string, request: CreateSearchStrategyRequest): CreateSearchStrategyResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createSearchStrategyWithOptions(appGroupIdentity, appId, request, headers, runtime);
}

model CreateSecondRankRequest {
  body?: SecondRank(name='body', description='The request body. For more information, see [SecondRank](https://help.aliyun.com/document_detail/170008.html).'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run.', example='true'),
}

model CreateSecondRankResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='The information about the fine sort expression.', example='{}'),
}

model CreateSecondRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSecondRankResponseBody(name='body'),
}

/**
 * @summary Creates a fine sort expression for a version of an OpenSearch application. If you set dryRun to true, this operation checks the specified fine sort expression. The default value of dryRun is false if you do not set this parameter.
 *
 * @param request CreateSecondRankRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSecondRankResponse
 */
@context("createSecondRankWithContext")
async function createSecondRankWithOptions(appGroupIdentity: string, appId: string, request: CreateSecondRankRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateSecondRankResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateSecondRank',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/second-ranks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a fine sort expression for a version of an OpenSearch application. If you set dryRun to true, this operation checks the specified fine sort expression. The default value of dryRun is false if you do not set this parameter.
 *
 * @param request CreateSecondRankRequest
 * @return CreateSecondRankResponse
 */
async function createSecondRank(appGroupIdentity: string, appId: string, request: CreateSecondRankRequest): CreateSecondRankResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createSecondRankWithOptions(appGroupIdentity, appId, request, headers, runtime);
}

model CreateSortScriptRequest {
  description?: string(name='description'),
  scope?: string(name='scope', description='The sort phase to which the script applies.', example='second_rank'),
  scriptName?: string(name='scriptName', description='The script name.', example='rank_cava_20230606_v7'),
  type?: string(name='type', description='The script type. Set the value to cava_script.', example='cava_script'),
}

model CreateSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: {
    scope?: string(name='scope', description='The sort phase to which the script applies.', example='second_rank'),
    scriptName?: string(name='scriptName', description='The script name.', example='rank_cava_20230606_v7'),
    type?: string(name='type', description='The script type.', example='cava_script'),
  }(name='result', description='The response parameters.'),
}

model CreateSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSortScriptResponseBody(name='body'),
}

/**
 * @summary Creates a sort script.
 *
 * @param request CreateSortScriptRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSortScriptResponse
 */
@context("createSortScriptWithContext")
async function createSortScriptWithOptions(appGroupIdentity: string, appVersionId: string, request: CreateSortScriptRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateSortScriptResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.scope)) {
    body['scope'] = request.scope;
  }
  if (!$isNull(request.scriptName)) {
    body['scriptName'] = request.scriptName;
  }
  if (!$isNull(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateSortScript',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appVersionId)}/sort-scripts`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a sort script.
 *
 * @param request CreateSortScriptRequest
 * @return CreateSortScriptResponse
 */
async function createSortScript(appGroupIdentity: string, appVersionId: string, request: CreateSortScriptRequest): CreateSortScriptResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createSortScriptWithOptions(appGroupIdentity, appVersionId, request, headers, runtime);
}

model CreateUserAnalyzerRequest {
  business?: string(name='business', description='The basic analyzer.', example='chn_standard'),
  businessAppGroupId?: string(name='businessAppGroupId', description='The application ID of the custom analyzer.', example='110123123'),
  businessType?: string(name='businessType', description='The basic analyzer type. Valid values: AUTO, MODEL, SYSTEM, and USER.', example='AUTO'),
  name?: string(name='name', description='The analyzer name.', example='jmbon_analyzer'),
  type?: string(name='type', description='The engine type. Valid values: HA3 and ES.', example='HA3'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Default value: false.
Valid values:
*   **true**
*   **false**', example='false'),
}

model CreateUserAnalyzerResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='98724351-D6B2-5D8A-B089-7FFD1821A7E9'),
  result?: map[string]any(name='result', description='The custom analyzer.', example='{}'),
}

model CreateUserAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateUserAnalyzerResponseBody(name='body'),
}

/**
 * @summary Create a custom analyzer.
 *
 * @param request CreateUserAnalyzerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUserAnalyzerResponse
 */
@context("createUserAnalyzerWithContext")
async function createUserAnalyzerWithOptions(request: CreateUserAnalyzerRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateUserAnalyzerResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!$isNull(request.business)) {
    body['business'] = request.business;
  }
  if (!$isNull(request.businessAppGroupId)) {
    body['businessAppGroupId'] = request.businessAppGroupId;
  }
  if (!$isNull(request.businessType)) {
    body['businessType'] = request.businessType;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }
  if (!$isNull(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateUserAnalyzer',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/user-analyzers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create a custom analyzer.
 *
 * @param request CreateUserAnalyzerRequest
 * @return CreateUserAnalyzerResponse
 */
async function createUserAnalyzer(request: CreateUserAnalyzerRequest): CreateUserAnalyzerResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createUserAnalyzerWithOptions(request, headers, runtime);
}

model DeleteABTestExperimentResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='The returned data.', example='{}'),
}

model DeleteABTestExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteABTestExperimentResponseBody(name='body'),
}

/**
 * @summary Deletes a test.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteABTestExperimentResponse
 */
@context("deleteABTestExperimentWithContext")
async function deleteABTestExperimentWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteABTestExperimentResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteABTestExperiment',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scenes/${$URL.percentEncode(sceneId)}/groups/${$URL.percentEncode(groupId)}/experiments/${$URL.percentEncode(experimentId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a test.
 *
 * @return DeleteABTestExperimentResponse
 */
async function deleteABTestExperiment(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string): DeleteABTestExperimentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteABTestExperimentWithOptions(appGroupIdentity, sceneId, groupId, experimentId, headers, runtime);
}

model DeleteABTestGroupResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='The return result.', example='{}'),
}

model DeleteABTestGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteABTestGroupResponseBody(name='body'),
}

/**
 * @summary 删除实验组
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteABTestGroupResponse
 */
@context("deleteABTestGroupWithContext")
async function deleteABTestGroupWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteABTestGroupResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteABTestGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scenes/${$URL.percentEncode(sceneId)}/groups/${$URL.percentEncode(groupId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除实验组
 *
 * @return DeleteABTestGroupResponse
 */
async function deleteABTestGroup(appGroupIdentity: string, sceneId: string, groupId: string): DeleteABTestGroupResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteABTestGroupWithOptions(appGroupIdentity, sceneId, groupId, headers, runtime);
}

model DeleteABTestSceneResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='The returned results.', example='{}'),
}

model DeleteABTestSceneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteABTestSceneResponseBody(name='body'),
}

/**
 * @summary Deletes an A/B test scenario.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteABTestSceneResponse
 */
@context("deleteABTestSceneWithContext")
async function deleteABTestSceneWithOptions(appGroupIdentity: string, sceneId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteABTestSceneResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteABTestScene',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scenes/${$URL.percentEncode(sceneId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an A/B test scenario.
 *
 * @return DeleteABTestSceneResponse
 */
async function deleteABTestScene(appGroupIdentity: string, sceneId: string): DeleteABTestSceneResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteABTestSceneWithOptions(appGroupIdentity, sceneId, headers, runtime);
}

model DeleteFunctionInstanceResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, this parameter is left empty.', example='"Instance.NotExist"'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='10'),
  message?: string(name='Message', description='The error message. If no error occurs, this parameter is left empty.', example='"instance not exist."'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='"1081EB05-473C-5BF4-95BE-6D7CAD5E2213"'),
  status?: string(name='Status', description='The status of the request. Valid values:

*   OK: The request is successful.
*   FAIL: The request fails.', example='"OK"'),
}

model DeleteFunctionInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFunctionInstanceResponseBody(name='body'),
}

/**
 * @summary Deletes an algorithm instance. Before you delete an instance, make sure that it is not in use to prevent service interruptions.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFunctionInstanceResponse
 */
@context("deleteFunctionInstanceWithContext")
async function deleteFunctionInstanceWithOptions(appGroupIdentity: string, functionName: string, instanceName: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteFunctionInstanceResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteFunctionInstance',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/functions/${$URL.percentEncode(functionName)}/instances/${$URL.percentEncode(instanceName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an algorithm instance. Before you delete an instance, make sure that it is not in use to prevent service interruptions.
 *
 * @return DeleteFunctionInstanceResponse
 */
async function deleteFunctionInstance(appGroupIdentity: string, functionName: string, instanceName: string): DeleteFunctionInstanceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionInstanceWithOptions(appGroupIdentity, functionName, instanceName, headers, runtime);
}

model DeleteFunctionResourceResponseBody = {
  code?: string(name='Code', description='The error code returned. If no error occurs, this value is empty.', example='""'),
  httpCode?: long(name='HttpCode', description='The HTTP status code returned.', example='200'),
  latency?: double(name='Latency', description='The time consumed for the request. Unit: milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='""'),
  requestId?: string(name='RequestId', description='The request ID.', example='A4D487A9-A456-5AA5-A9C6-B7BF2889CF74'),
  status?: string(name='Status', description='The status code. Valid values:

*   OK
*   FAIL', example='OK'),
}

model DeleteFunctionResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFunctionResourceResponseBody(name='body'),
}

/**
 * @summary Deletes an algorithm resource.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFunctionResourceResponse
 */
@context("deleteFunctionResourceWithContext")
async function deleteFunctionResourceWithOptions(appGroupIdentity: string, functionName: string, resourceName: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteFunctionResourceResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteFunctionResource',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/functions/${$URL.percentEncode(functionName)}/resources/${$URL.percentEncode(resourceName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an algorithm resource.
 *
 * @return DeleteFunctionResourceResponse
 */
async function deleteFunctionResource(appGroupIdentity: string, functionName: string, resourceName: string): DeleteFunctionResourceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionResourceWithOptions(appGroupIdentity, functionName, resourceName, headers, runtime);
}

model DeleteFunctionTaskResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, this parameter is left empty.', example='Task.UnableDelete'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='operation success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='"1081EB05-473C-5BF4-95BE-6D7CAD5E2213"'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model DeleteFunctionTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFunctionTaskResponseBody(name='body'),
}

/**
 * @summary Deletes a training task. The training task in progress cannot be deleted.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFunctionTaskResponse
 */
@context("deleteFunctionTaskWithContext")
async function deleteFunctionTaskWithOptions(appGroupIdentity: string, functionName: string, instanceName: string, generation: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteFunctionTaskResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteFunctionTask',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/functions/${$URL.percentEncode(functionName)}/instances/${$URL.percentEncode(instanceName)}/tasks/${$URL.percentEncode(generation)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a training task. The training task in progress cannot be deleted.
 *
 * @return DeleteFunctionTaskResponse
 */
async function deleteFunctionTask(appGroupIdentity: string, functionName: string, instanceName: string, generation: string): DeleteFunctionTaskResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionTaskWithOptions(appGroupIdentity, functionName, instanceName, generation, headers, runtime);
}

model DeleteSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
}

model DeleteSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSortScriptResponseBody(name='body'),
}

/**
 * @summary 删除排序脚本
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSortScriptResponse
 */
@context("deleteSortScriptWithContext")
async function deleteSortScriptWithOptions(appGroupIdentity: string, scriptName: string, appVersionId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteSortScriptResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteSortScript',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appVersionId)}/sort-scripts/${$URL.percentEncode(scriptName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除排序脚本
 *
 * @return DeleteSortScriptResponse
 */
async function deleteSortScript(appGroupIdentity: string, scriptName: string, appVersionId: string): DeleteSortScriptResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSortScriptWithOptions(appGroupIdentity, scriptName, appVersionId, headers, runtime);
}

model DeleteSortScriptFileResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
}

model DeleteSortScriptFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSortScriptFileResponseBody(name='body'),
}

/**
 * @summary Deletes a script file.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSortScriptFileResponse
 */
@context("deleteSortScriptFileWithContext")
async function deleteSortScriptFileWithOptions(appGroupIdentity: string, appVersionId: string, scriptName: string, fileName: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteSortScriptFileResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteSortScriptFile',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appVersionId)}/sort-scripts/${$URL.percentEncode(scriptName)}/files/src/${$URL.percentEncode(fileName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a script file.
 *
 * @return DeleteSortScriptFileResponse
 */
async function deleteSortScriptFile(appGroupIdentity: string, appVersionId: string, scriptName: string, fileName: string): DeleteSortScriptFileResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSortScriptFileWithOptions(appGroupIdentity, appVersionId, scriptName, fileName, headers, runtime);
}

model DescribeABTestExperimentResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test was created.', example='1588842080'),
    id?: string(name='id', description='The ID of the test.', example='12888'),
    name?: string(name='name', description='The name of the test.', example='test1'),
    online?: boolean(name='online', description='The status of the test. Valid values:

*   true: in effect
*   false: not in effect', example='true'),
    params?: {
      firstFormulaName?: string(name='first_formula_name', description='The name of the rough sort policy.', example='default'),
    }(name='params', description='The parameters of the test.'),
    traffic?: int32(name='traffic', description='The percentage of traffic that is routed to the test.', example='30'),
    updated?: int32(name='updated', description='The time when the test was last modified.', example='1588842080'),
  }(name='result', description='The details of the test.'),
}

model DescribeABTestExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeABTestExperimentResponseBody(name='body'),
}

/**
 * @summary 获取实验详情
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeABTestExperimentResponse
 */
@context("describeABTestExperimentWithContext")
async function describeABTestExperimentWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string, headers: map[string]string, runtime: $RuntimeOptions): DescribeABTestExperimentResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeABTestExperiment',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scenes/${$URL.percentEncode(sceneId)}/groups/${$URL.percentEncode(groupId)}/experiments/${$URL.percentEncode(experimentId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取实验详情
 *
 * @return DescribeABTestExperimentResponse
 */
async function describeABTestExperiment(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string): DescribeABTestExperimentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return describeABTestExperimentWithOptions(appGroupIdentity, sceneId, groupId, experimentId, headers, runtime);
}

model DescribeABTestGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test group was created.', example='1588839490'),
    id?: string(name='id', description='The ID of the test group.', example='13466'),
    name?: string(name='name', description='The alias of the test group.', example='Group_2020-5-7_15:23:3'),
    status?: int32(name='status', description='The status of the test group. Valid values:

*   0: not in effect
*   1: in effect', example='1'),
    updated?: int32(name='updated', description='The time when the test group was last updated.', example='1588839490'),
  }(name='result', description='The details of the test group.'),
}

model DescribeABTestGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeABTestGroupResponseBody(name='body'),
}

/**
 * @summary Queries the details of a test group.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeABTestGroupResponse
 */
@context("describeABTestGroupWithContext")
async function describeABTestGroupWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, headers: map[string]string, runtime: $RuntimeOptions): DescribeABTestGroupResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeABTestGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scenes/${$URL.percentEncode(sceneId)}/groups/${$URL.percentEncode(groupId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a test group.
 *
 * @return DescribeABTestGroupResponse
 */
async function describeABTestGroup(appGroupIdentity: string, sceneId: string, groupId: string): DescribeABTestGroupResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return describeABTestGroupWithOptions(appGroupIdentity, sceneId, groupId, headers, runtime);
}

model DescribeABTestSceneResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test scenario was created.', example='1596527691'),
    id?: string(name='id', description='The ID of the test scenario.', example='20614'),
    name?: string(name='name', description='The name of the test scenario.', example='test'),
    status?: int32(name='status', description='The status of the test scenario. Valid values:

*   0: The test is stopped.
*   1: The test is started.', example='0'),
    updated?: int32(name='updated', description='The time when the test was last modified.', example='1596527691'),
    values?: [ string ](name='values', description='The indicators of the test scenarios.'),
  }(name='result', description='The details of the test scenario.'),
}

model DescribeABTestSceneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeABTestSceneResponseBody(name='body'),
}

/**
 * @summary Queries the information about an A/B test scenario.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeABTestSceneResponse
 */
@context("describeABTestSceneWithContext")
async function describeABTestSceneWithOptions(appGroupIdentity: string, sceneId: string, headers: map[string]string, runtime: $RuntimeOptions): DescribeABTestSceneResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeABTestScene',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scenes/${$URL.percentEncode(sceneId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about an A/B test scenario.
 *
 * @return DescribeABTestSceneResponse
 */
async function describeABTestScene(appGroupIdentity: string, sceneId: string): DescribeABTestSceneResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return describeABTestSceneWithOptions(appGroupIdentity, sceneId, headers, runtime);
}

model DescribeAppResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='33477D76-C380-1D84-A4AD-043F52876CB1'),
  result?: {
    autoSwitch?: boolean(name='autoSwitch', description='Indicates whether the version is automatically switched to an online version.', example='true'),
    cluster?: {
      maxQueryClauseLength?: int32(name='maxQueryClauseLength', description='The maximum length of the query clause.', example='1024'),
      maxTimeoutMS?: int32(name='maxTimeoutMS', description='The timeout period. Unit: milliseconds.', example='750'),
    }(name='cluster', description='The capability opening configurations.'),
    clusterName?: string(name='clusterName', description='The cluster name.', example='-'),
    dataSources?: [ 
      {
        fields?: [  map[string]any ](name='fields', description='The information about field mappings.'),
        keyField?: string(name='keyField', description='The primary key.', example='id'),
        parameters?: map[string]any(name='parameters', description='The information about the data source.', example='{
  "instanceId": "rds-instance-id",
  "dbName": "my_db",
  "dbTableName": "my_table",
  "dbUser": "my",
  "dbPassword": "my_passwd",
  "filter":"",
  "autoSync": true
}'),
        plugins?: map[string]any(name='plugins', description='The plug-ins that are used for data processing.

name:

*   JsonKeyValueExtractor
*   MultiValueSpliter
*   KeyValueExtractor
*   StringCatenateExtractor
*   HTMLTagRemover

parameters:

*   JsonKeyValueExtractor
*   MultiValueSpliter
*   KeyValueExtractor
*   StringCatenateExtractor
*   HTMLTagRemover', example='{
  "name": "JsonKeyValueExtractor",
  "parameters": {
  "key": "my_field"
}
}'),
        schemaName?: string(name='schemaName', description='The name of the wide table.', example='name'),
        tableName?: string(name='tableName', description='The name of the table in the application.', example='main'),
        type?: string(name='type', description='The type of the data source. Valid values:

*   rds
*   odps
*   opensearch
*   polardb', example='rds'),
      }
    ](name='dataSources', description='The configurations of the data sources.'),
    description?: string(name='description', description='The description of the version.', example='-'),
    domain?: {
      category?: string(name='category', description='The type of the edition. Valid values: standard, advance, and enhanced. A value of standard indicates a standard edition. A value of advance indicates an advanced edition which is of an old version. New version is not supported for this edition. A value of enhanced indicates an advanced edition which is of a new version.', example='-'),
      functions?: {
        algo?: [ string ](name='algo', description='The structure of the algorithm.', example='[]'),
        qp?: [ string ](name='qp', description='The information about the layout.', example='[]'),
        service?: [ string ](name='service', description='The description of each feature.', example='[]'),
      }(name='functions', description='The search results.', example='{}'),
      name?: string(name='name', description='The name (in English).', example='test'),
    }(name='domain', description='The industry type. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='GENERAL'),
    fetchFields?: [ string ](name='fetchFields', description='The default display fields.', example='[]'),
    firstRanks?: [ 
      {
        active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='False'),
        description?: string(name='description', description='The description.', example='abc'),
        meta?: any(name='meta', description='The information about the expression. The information can be of the array or string type.', example='String :"random()*100+now()";
Array: [
    {
      "attribute": "static_bm25()",
      "arg": "",
      "weight": 10
    }
  ]'),
        name?: string(name='name', description='The name of the rough sort expression.', example='test'),
        type?: string(name='type', description='The expression type. Valid values:

STRUCT: The content of the expression is a structure. STRING (default): custom formula.', example='STRING'),
      }
    ](name='firstRanks', description='The configurations of rough sort.'),
    id?: string(name='id', description='The version ID.', example='100303063'),
    interpretations?: map[string]any(name='interpretations', description='The industry model module.', example='[ { "table": "table1", "fields": [ { "name": "field1", "interpretation": "Title" }, { "name": "field2", "interpretation": "Number" } ] } ]'),
    isCurrent?: boolean(name='isCurrent', description='Indices whether the version is an online version.', example='True'),
    progressPercent?: int32(name='progressPercent', description='The progress of data import, in percentage. For example, a value of 83 indicates 83%.', example='100'),
    prompts?: [  map[string]any ](name='prompts', description='The prompt configurations.'),
    queryProcessors?: [ 
      {
        active?: boolean(name='active', description='Indicates whether the rule is the default one.', example='False'),
        category?: string(name='category', description='The industry category.', example='""'),
        domain?: string(name='domain', description='The industry type. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='GENERAL'),
        indexes?: [ string ](name='indexes', description='Then index range.'),
        name?: string(name='name', description='The rule name.', example='test'),
        processors?: [  map[string]any ](name='processors', description='The features.'),
      }
    ](name='queryProcessors', description='The query intent understanding configurations.'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing unit (LCU).', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
      qps?: int32(name='qps', description='The number of search requests per second. You are charged based on the number of search requests per second in the earlier billing model.', example='5'),
      spec?: string(name='spec', description='The specifications. Valid values:

*   opensearch.share.junior: basic
*   opensearch.share.common: shared general-purpose
*   opensearch.share.compute: shared computing
*   opensearch.share.storage: shared storage
*   opensearch.private.common: exclusive general-purpose
*   opensearch.private.compute: exclusive computing
*   opensearch.private.storage: exclusive storage', example='opensearch.share.common'),
    }(name='quota', description='The quota information.', example='{}'),
    schema?: {
      indexSortConfig?: [ 
        {
          direction?: string(name='direction', description='The sort method. Valid values:

*   ASC
*   DESC', example='DESC'),
          field?: string(name='field', description='The sort field.', example='field1'),
        }
      ](name='indexSortConfig', description='The sort configurations.'),
      indexes?: {
        filterFields?: [ string ](name='filterFields', description='The attribute fields.'),
        searchFields?: map[string]any(name='searchFields', description='The index fields.', example='{
  "fields": ["title"],
  "analyzer": "chn_standard"
}'),
      }(name='indexes', description='The index schema.'),
      name?: string(name='name', description='The name of the wide table.', example='test'),
      routeField?: string(name='routeField', description='The name of the level-1 routing field.', example='field1'),
      routeFieldValues?: [ string ](name='routeFieldValues', description='The hot values of the level-1 routing field.'),
      secondRouteField?: string(name='secondRouteField', description='The name of the level-2 routing field. This parameter takes effect only when the routeFieldValues parameter is configured. By default, the wide-table primary key field is used as the level-2 routing field.', example='field2'),
      tables?: map[string]any(name='tables', description='The table schema.', example='{
	"primaryTable": true,
	"name": "main",
	"fields": {
		"id": {
			"name": "id",
			"type": "LITERAL",
			"primaryKey": true
		},
		"title": {
			"name": "title",
			"type": "TEXT",
			"primaryKey": false
		},
		"buy": {
			"name": "buy",
			"type": "INT",
			"primaryKey": false
		},
		"cate_id": {
			"name": "cate_id",
			"type": "INT",
			"primaryKey": false
		},
		"cate_name": {
			"name": "cate_name",
			"type": "LITERAL",
			"primaryKey": false
		}
	}
}'),
      ttlField?: {
        name?: string(name='name', description='The document time field.', example='text1'),
        ttl?: long(name='ttl', description='The TTL. Unit: milliseconds.', example='1000'),
      }(name='ttlField', description='The document clearing configurations.'),
    }(name='schema', description='The schema of the application.', example='{}'),
    schemas?: [ 
      {
        indexSortConfig?: [ 
          {
            direction?: string(name='direction', description='The sort method. Valid values:

*   ASC
*   DESC', example='DESC'),
            field?: string(name='field', description='The sort field.', example='fIeld1'),
          }
        ](name='indexSortConfig', description='The sort configurations.'),
        indexes?: {
          filterFields?: [ string ](name='filterFields', description='The attribute fields.'),
          searchFields?: map[string]any(name='searchFields', description='The index fields.', example='{
  "fields": ["title"],
  "analyzer": "chn_standard"
}'),
        }(name='indexes', description='The index schema.'),
        name?: string(name='name', description='The name of the wide table.', example='main'),
        routeField?: string(name='routeField', description='The name of the level-1 routing field.', example='field1'),
        routeFieldValues?: [ string ](name='routeFieldValues', description='The hot values of the level-1 routing field.'),
        secondRouteField?: string(name='secondRouteField', description='The name of the level-2 routing field. This parameter takes effect only when the routeFieldValues parameter is configured. By default, the wide-table primary key field is used as the level-2 routing field.', example='field2'),
        tables?: map[string]any(name='tables', description='The table schema.', example='{
	"primaryTable": true,
	"name": "main",
	"fields": {
		"id": {
			"name": "id",
			"type": "LITERAL",
			"primaryKey": true
		},
		"title": {
			"name": "title",
			"type": "TEXT",
			"primaryKey": false
		},
		"buy": {
			"name": "buy",
			"type": "INT",
			"primaryKey": false
		},
		"cate_id": {
			"name": "cate_id",
			"type": "INT",
			"primaryKey": false
		},
		"cate_name": {
			"name": "cate_name",
			"type": "LITERAL",
			"primaryKey": false
		}
	}
}'),
        ttlField?: {
          name?: string(name='name', description='The document time field.', example='fIeld1'),
          ttl?: long(name='ttl', description='The TTL. Unit: milliseconds.', example='1000'),
        }(name='ttlField', description='The document clearing configurations.'),
      }
    ](name='schemas', description='The multi-table schema.'),
    secondRanks?: [ 
      {
        active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='False'),
        description?: string(name='description', description='The description.', example='Description'),
        meta?: any(name='meta', description='The fine sort expression. You can define an expression that contains fields, feature functions, and mathematical functions to implement complex sort logic.', example='"cate_id > 0 and cate_id < 1000"'),
        name?: string(name='name', description='The name of the fine sort expression.', example='default'),
      }
    ](name='secondRanks', description='The configurations of fine sort.'),
    status?: string(name='status', description='The status of the version. Valid values:

*   ok: The version is normal.
*   stopped: The version is suspended.
*   frozen: The version is frozen.
*   initializing: The version is being initialized.
*   unavailable: The version is invalid.
*   data_waiting: Data is to be initialized.
*   data_preparing: Data is being initialized.', example='ok'),
    summaries?: [ 
      {
        meta?: [ 
          {
            element?: string(name='element', description='The element that is used for highlighting.', example='em'),
            ellipsis?: string(name='ellipsis', description='The connector that is used to connect segments.', example='...'),
            field?: string(name='field', description='The field.', example='field1'),
            len?: int32(name='len', description='The length of the segment. Valid values: 1 to 300.', example='50'),
            snippet?: string(name='snippet', description='The number of segments. Valid values: 1 to 5.', example='5'),
          }
        ](name='meta', description='The summary configurations.'),
        name?: string(name='name', description='The group name.', example='default'),
      }
    ](name='summaries', description='The summary configurations of search results.'),
    type?: string(name='type', description='The edition type. Valid values:

*   standard: a standard edition application.
*   advance: an advanced edition application of an old version. New versions are not supported for this edition.
*   enhanced: an advanced edition application of a new version.', example='enhanced'),
  }(name='result', description='The version information.', example='{}'),
}

model DescribeAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAppResponseBody(name='body'),
}

/**
 * @summary Queries the information about a version of an OpenSearch application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAppResponse
 */
@context("describeAppWithContext")
async function describeAppWithOptions(appGroupIdentity: string, appId: string, headers: map[string]string, runtime: $RuntimeOptions): DescribeAppResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeApp',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about a version of an OpenSearch application.
 *
 * @return DescribeAppResponse
 */
async function describeApp(appGroupIdentity: string, appId: string): DescribeAppResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return describeAppWithOptions(appGroupIdentity, appId, headers, runtime);
}

model DescribeAppGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    chargeType?: string(name='chargeType', description='The billing method. Valid values:

*   POSTPAY: pay-as-you-go.
*   PREPAY: subscription.', example='POSTPAY'),
    chargingWay?: int32(name='chargingWay', description='The billable item. Valid values:

*   1: computing resources.
*   2: queries per second (QPS).', example='1'),
    commodityCode?: string(name='commodityCode', description='The commodity code.', example='opensearch'),
    created?: int32(name='created', description='The timestamp when the application was created.', example='1575442875'),
    currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='110116134'),
    description?: string(name='description', description='The description of the application.', example='-'),
    domain?: string(name='domain', description='The industry of the application.', example='ecommerce'),
    engineType?: string(name='engineType', description='The engine type.', example='ha3'),
    expireOn?: string(name='expireOn', description='The expiration time.', example='-'),
    firstRankAlgoDeploymentId?: int32(name='firstRankAlgoDeploymentId', description='The ID of the created rough sort expression.', example='0'),
    hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval state of the quotas. Valid values:

*   0: The application is in service.
*   1: The quotas are being reviewed.', example='0'),
    id?: string(name='id', description='The application ID.', example='110116134'),
    instanceId?: string(name='instanceId', description='The instance ID.', example='-'),
    lockMode?: string(name='lockMode', description='The lock state. Valid values:

*   Unlock: The instance is unlocked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
    lockedByExpiration?: int32(name='lockedByExpiration', description='Indicates whether the instance is automatically locked after it expires.', example='0'),
    name?: string(name='name', description='The application name.', example='os_function_test_v1'),
    pendingSecondRankAlgoDeploymentId?: int32(name='pendingSecondRankAlgoDeploymentId', description='The ID of the fine sort expression that is being created.', example='0'),
    processingOrderId?: string(name='processingOrderId', description='The ID of the order that is not complete.', example='-'),
    produced?: int32(name='produced', description='Indicates whether the application is created. Valid values:

*   0: The application is being created.
*   1: The application is created.', example='1'),
    projectId?: string(name='projectId', description='The name of the A/B test group.', example='-'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing unit (LCU).', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
      spec?: string(name='spec', description='The specifications. Valid values:

*   opensearch.share.junior: basic.
*   opensearch.share.common: shared general-purpose.
*   opensearch.share.compute: shared computing.
*   opensearch.share.storage: shared storage.
*   opensearch.private.common: exclusive general-purpose.
*   opensearch.private.compute: exclusive computing.
*   opensearch.private.storage: exclusive storage.', example='opensearch.share.common'),
    }(name='quota', description='The information about the quotas of the application.'),
    resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group to which the network instance belongs.', example='rg-acfmoiyerh6nzly'),
    secondRankAlgoDeploymentId?: int32(name='secondRankAlgoDeploymentId', description='The ID of the created fine sort expression.', example='0'),
    status?: string(name='status', description='The state of the application. Valid values:

*   producing: The application is being created.
*   review_pending: The application is being reviewed.
*   config_pending: The application is to be configured.
*   normal: The application is in service.
*   frozen: The application is frozen.', example='normal'),
    switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='0'),
    tags?: [ 
      {
        key?: string(name='key', description='The tag key.', example='foo'),
        value?: string(name='value', description='The tag value', example='bar'),
      }
    ](name='tags', description='The application tags.'),
    type?: string(name='type', description='The type of the application. Valid values:

*   standard: a High-performance Search Edition application.
*   enhanced: an Industry Algorithm Edition application.', example='enhanced'),
    updated?: int32(name='updated', description='The timestamp when the application was last updated.', example='1578916076'),
  }(name='result', description='The information about the application.'),
}

model DescribeAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAppGroupResponseBody(name='body'),
}

/**
 * @summary Queries the details of an OpenSearch application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAppGroupResponse
 */
@context("describeAppGroupWithContext")
async function describeAppGroupWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: $RuntimeOptions): DescribeAppGroupResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeAppGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of an OpenSearch application.
 *
 * @return DescribeAppGroupResponse
 */
async function describeAppGroup(appGroupIdentity: string): DescribeAppGroupResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return describeAppGroupWithOptions(appGroupIdentity, headers, runtime);
}

model DescribeAppStatisticsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='76FC45F1-4167-D3CD-6737-4F97BA503FA0'),
  result?: map[string]any(name='result', description='The statistics.', example='{}'),
}

model DescribeAppStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAppStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics about a version of an OpenSearch application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAppStatisticsResponse
 */
@context("describeAppStatisticsWithContext")
async function describeAppStatisticsWithOptions(appGroupIdentity: string, appId: string, headers: map[string]string, runtime: $RuntimeOptions): DescribeAppStatisticsResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeAppStatistics',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/statistics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the statistics about a version of an OpenSearch application.
 *
 * @return DescribeAppStatisticsResponse
 */
async function describeAppStatistics(appGroupIdentity: string, appId: string): DescribeAppStatisticsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return describeAppStatisticsWithOptions(appGroupIdentity, appId, headers, runtime);
}

model DescribeAppsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='77CAA411-0010-4DB9-82E2-1C384E590AFF'),
  result?: [ 
    {
      autoSwitch?: boolean(name='autoSwitch', description='Indicates whether the version is automatically switched to an online version.', example='true'),
      cluster?: {
        maxQueryClauseLength?: int32(name='maxQueryClauseLength', description='The maximum length of the query clause.', example='1024'),
        maxTimeoutMS?: int32(name='maxTimeoutMS', description='The timeout period. Unit: milliseconds.', example='750'),
      }(name='cluster', description='The capability opening configurations.'),
      clusterName?: string(name='clusterName', description='The cluster name.', example='vpc_sh_domain_1'),
      dataSources?: [ 
        {
          fields?: [  map[string]any ](name='fields', description='The information about field mappings.'),
          keyField?: string(name='keyField', description='The primary key.', example='id'),
          parameters?: map[string]any(name='parameters', description='The information about the data source.'),
          plugins?: map[string]any(name='plugins', description='The plug-ins that are used for data processing.

name:

*   JsonKeyValueExtractor
*   MultiValueSpliter
*   KeyValueExtractor
*   StringCatenateExtractor
*   HTMLTagRemover

parameters:

*   JsonKeyValueExtractor
*   MultiValueSpliter
*   KeyValueExtractor
*   StringCatenateExtractor
*   HTMLTagRemover'),
          schemaName?: string(name='schemaName', description='The name of the wide table.', example='name'),
          tableName?: string(name='tableName', description='The name of the table in the application.', example='main'),
          type?: string(name='type', description='The type of the data source. Valid values:

*   rds
*   odps
*   opensearch
*   polardb', example='rds'),
        }
      ](name='dataSources', description='The configurations of data sources.'),
      description?: string(name='description', description='The description.', example='""'),
      domain?: {
        category?: string(name='category', description='The type of the edition. Valid values: standard, advance, and enhanced. A value of standard indicates a standard edition. A value of advance indicates an advanced edition which is of an old version. New version is not supported for this edition. A value of enhanced indicates an advanced edition which is of a new version.', example='-'),
        functions?: {
          algo?: [ string ](name='algo', description='Structure 1.'),
          qp?: [ string ](name='qp', description='Information 1.'),
          service?: [ string ](name='service', description='Feature 1.'),
        }(name='functions', description='The search results.'),
        name?: string(name='name', description='The name (in English).', example='test'),
      }(name='domain', description='The type of the industry. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT'),
      fetchFields?: [ string ](name='fetchFields', description='The default display fields.'),
      firstRanks?: [ 
        {
          active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='False'),
          description?: string(name='description', description='The description.', example='Description'),
          meta?: any(name='meta', description='The information about the expression. The information is displayed in the array or string format.', example='String :"random()*100+now()";
Array: [
    {
      "attribute": "static_bm25()",
      "arg": "",
      "weight": 10
    }
  ]'),
          name?: string(name='name', description='The name of the rough sort expression.', example='test'),
          type?: string(name='type', description='The expression type. Valid values:

STRUCT: The content of the expression is a structure. STRING (default): a custom formula.', example='STRING'),
        }
      ](name='firstRanks', description='The configurations of rough sort.'),
      id?: string(name='id', description='The group ID.', example='100302881'),
      interpretations?: map[string]any(name='interpretations', description='The field model.'),
      isCurrent?: boolean(name='isCurrent', description='Indicates whether the version is an online version.', example='12333'),
      progressPercent?: int32(name='progressPercent', description='The progress of data import, in percentage. For example, a value of 83 indicates 83%.', example='100'),
      prompts?: [  map[string]any ](name='prompts', description='The prompt configurations.'),
      queryProcessors?: [ 
        {
          active?: boolean(name='active', description='Indicates whether the rule is the default one.', example='False'),
          category?: string(name='category', description='The industry category.', example='""'),
          domain?: string(name='domain', description='The type of the industry. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='GENERAL'),
          indexes?: [ string ](name='indexes', description='The indexes.'),
          name?: string(name='name', description='The rule name.', example='test'),
          processors?: [  map[string]any ](name='processors', description='The features.'),
        }
      ](name='queryProcessors', description='The query intent understanding configurations.'),
      quota?: {
        computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing unit (LCU).', example='20'),
        docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
        qps?: int32(name='qps', description='The number of search requests per second. You are charged based on the number of search requests per second in the earlier billing model.', example='5'),
        spec?: string(name='spec', description='The specifications. Valid values:

*   opensearch.share.junior: basic
*   opensearch.share.common: shared general-purpose
*   opensearch.share.compute: shared computing
*   opensearch.share.storage: shared storage
*   opensearch.private.common: exclusive general-purpose
*   opensearch.private.compute: exclusive computing
*   opensearch.private.storage: exclusive storage', example='opensearch.share.common'),
      }(name='quota', description='The quota information.'),
      schema?: {
        indexSortConfig?: [ 
          {
            direction?: string(name='direction', description='The sort method. Valid values:

*   ASC
*   DESC', example='DESC'),
            field?: string(name='field', description='The sort field.', example='field1'),
          }
        ](name='indexSortConfig', description='The sort configurations.'),
        indexes?: {
          filterFields?: [ string ](name='filterFields', description='The attribute fields.'),
          searchFields?: map[string]any(name='searchFields', description='The index fields.'),
        }(name='indexes', description='The index schema.'),
        name?: string(name='name', description='The name of the wide table.', example='test'),
        routeField?: string(name='routeField', description='The level-1 routing field.', example='field1'),
        routeFieldValues?: [ string ](name='routeFieldValues', description='The hot values of the level-1 routing field.'),
        secondRouteField?: string(name='secondRouteField', description='The level-2 routing field. This parameter is returned if the routeFieldValues parameter is returned. By default, the wide-table primary key field is used as the level-2 routing field.', example='field2'),
        tables?: map[string]any(name='tables', description='The table schema.'),
        ttlField?: {
          name?: string(name='name', description='The document clearing field.', example='text1'),
          ttl?: long(name='ttl', description='The TTL. Unit: milliseconds.', example='1000'),
        }(name='ttlField', description='The document clearing configurations.'),
      }(name='schema', description='The application schema.'),
      schemas?: [ 
        {
          indexSortConfig?: [ 
            {
              direction?: string(name='direction', description='The sort method. Valid values:

*   ASC
*   DESC', example='DESC'),
              field?: string(name='field', description='The sort field.', example='fIeld1'),
            }
          ](name='indexSortConfig', description='The sort configurations.'),
          indexes?: {
            filterFields?: [ string ](name='filterFields', description='The attribute fields.'),
            searchFields?: map[string]any(name='searchFields', description='The index fields.'),
          }(name='indexes', description='The index schema.'),
          name?: string(name='name', description='The name of the wide table.', example='main'),
          routeField?: string(name='routeField', description='The level-1 routing field.', example='field1'),
          routeFieldValues?: [ string ](name='routeFieldValues', description='The hot values of the level-1 routing field.'),
          secondRouteField?: string(name='secondRouteField', description='The level-2 routing field. This parameter is returned if the routeFieldValues parameter is returned. By default, the wide-table primary key field is used as the level-2 routing field.', example='field2'),
          tables?: map[string]any(name='tables', description='The table schema.'),
          ttlField?: {
            name?: string(name='name', description='The document time field.', example='fIeld1'),
            ttl?: long(name='ttl', description='The TTL. Unit: milliseconds.', example='1000'),
          }(name='ttlField', description='The document clearing configurations.'),
        }
      ](name='schemas', description='The single-table schema.'),
      secondRanks?: [ 
        {
          active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='False'),
          description?: string(name='description', description='The description.', example='Description'),
          meta?: any(name='meta', description='The fine sort expression. You can define an expression that consists of fields, feature functions, and mathematical functions to implement complex sort logic.', example='"cate_id > 0 and cate_id < 1000"'),
          name?: string(name='name', description='The name of the fine sort expression.', example='default'),
        }
      ](name='secondRanks', description='The configurations of fine sort.'),
      status?: string(name='status', description='The status of the version. Valid values:

*   ok: The version is normal.
*   stopped: The version is suspended.
*   frozen: The version is frozen.
*   initializing: The version is being initialized.
*   unavailable: The version is invalid.
*   data_waiting: Data is to be initialized.
*   data_preparing: Data is being initialized.', example='normal'),
      summaries?: [ 
        {
          meta?: [ 
            {
              element?: string(name='element', description='The element that is used for highlighting.', example='em'),
              ellipsis?: string(name='ellipsis', description='The connector that is used to connect segments.', example='...'),
              field?: string(name='field', description='The field.', example='field1'),
              len?: int32(name='len', description='The length of the segment. Valid values: 1 to 300.', example='50'),
              snippet?: string(name='snippet', description='The number of segments. Valid values: 1 to 5.', example='5'),
            }
          ](name='meta', description='The summary configurations.'),
          name?: string(name='name', description='The group name.', example='fefault'),
        }
      ](name='summaries', description='The search result summary configurations.'),
      type?: string(name='type', description='The type of the application. Valid values:

*   standard: a standard edition application.
*   advance: an advanced edition application of an old version. New versions are not supported for this edition.
*   enhanced: an advanced edition application of a new version.', example='enhanced'),
    }
  ](name='result', description='The response parameters.'),
}

model DescribeAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAppsResponseBody(name='body'),
}

/**
 * @summary Queries the version list of an OpenSearch application.
 *
 * @description *   When you create a standard application, a new version of the application is created if the specified application name already exists.
 * *   When you create a version of an existing application, you must specify the autoSwitch and realtimeShared parameters.
 * *   When you create a version of an existing application, the value of the quota parameter is the same as that of the quota parameter in the previous version of the application.
 * *   When you create a version of an existing application, the modification of the value of the quota parameter does not take effect.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAppsResponse
 */
@context("describeAppsWithContext")
async function describeAppsWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: $RuntimeOptions): DescribeAppsResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeApps',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the version list of an OpenSearch application.
 *
 * @description *   When you create a standard application, a new version of the application is created if the specified application name already exists.
 * *   When you create a version of an existing application, you must specify the autoSwitch and realtimeShared parameters.
 * *   When you create a version of an existing application, the value of the quota parameter is the same as that of the quota parameter in the previous version of the application.
 * *   When you create a version of an existing application, the modification of the value of the quota parameter does not take effect.
 *
 * @return DescribeAppsResponse
 */
async function describeApps(appGroupIdentity: string): DescribeAppsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return describeAppsWithOptions(appGroupIdentity, headers, runtime);
}

model DescribeDataCollctionResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='72FAD77B-83F9-F393-BA8E-5834E2427BF8'),
  result?: {
    created?: int32(name='created', description='The time when the task was created.', example='1581065837'),
    dataCollectionType?: string(name='dataCollectionType', description='The type of data collected. Valid values:

*   behavior: behavioral data.
*   item_info: project information.
*   industry_specific: industry-specific data.', example='BEHAVIOR'),
    id?: string(name='id', description='The ID of the data collection task.', example='286'),
    industryName?: string(name='industryName', description='The industry name. Valid values:

*   general
*   ecommerce', example='GENERAL'),
    name?: string(name='name', description='The name of the data collection task.', example='os_function_test_v1'),
    status?: int32(name='status', description='The status of the data collection feature. Valid values:

*   0: The feature is disabled.
*   1: The feature is being enabled.
*   2: The feature is enabled.
*   3: The feature failed to be enabled.', example='2'),
    sundialId?: string(name='sundialId', description='The sundial ID.', example='1755'),
    type?: string(name='type', description='The type of the source from which data was collected. Valid values:

*   server
*   web
*   app Note: Only server is supported.', example='server'),
    updated?: int32(name='updated', description='The time when the data collection task was updated.', example='1581065904'),
  }(name='result', description='The details of the data collection task.'),
}

model DescribeDataCollctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDataCollctionResponseBody(name='body'),
}

/**
 * @summary Queries the details of a data collection task of an application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDataCollctionResponse
 */
@context("describeDataCollctionWithContext")
async function describeDataCollctionWithOptions(appGroupIdentity: string, dataCollectionIdentity: string, headers: map[string]string, runtime: $RuntimeOptions): DescribeDataCollctionResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDataCollction',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/data-collections/${$URL.percentEncode(dataCollectionIdentity)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a data collection task of an application.
 *
 * @return DescribeDataCollctionResponse
 */
async function describeDataCollction(appGroupIdentity: string, dataCollectionIdentity: string): DescribeDataCollctionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDataCollctionWithOptions(appGroupIdentity, dataCollectionIdentity, headers, runtime);
}

model DescribeFirstRankResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='false'),
    description?: string(name='description', description='Description', example='-'),
    meta?: [ 
      {
        arg?: string(name='arg', description='The parameters that are used by a function in the expression.', example='ar_edit_time'),
        attribute?: string(name='attribute', description='The attribute, feature function, or field to be searched for.', example='timeliness_ms()'),
        weight?: float(name='weight', description='The weight. Valid values: -100000 to 100000. The value cannot be 0.', example='1'),
      }
    ](name='meta', description='The information about the expression.'),
    name?: string(name='name', description='Parameter', example='ar_wear_edit_time'),
  }(name='result', description='The information about the rough sort expression.'),
}

model DescribeFirstRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFirstRankResponseBody(name='body'),
}

/**
 * @summary Queries a rough sort expression that is configured for an OpenSearch application version.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFirstRankResponse
 */
@context("describeFirstRankWithContext")
async function describeFirstRankWithOptions(appGroupIdentity: string, appId: string, name: string, headers: map[string]string, runtime: $RuntimeOptions): DescribeFirstRankResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeFirstRank',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/first-ranks/${$URL.percentEncode(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a rough sort expression that is configured for an OpenSearch application version.
 *
 * @return DescribeFirstRankResponse
 */
async function describeFirstRank(appGroupIdentity: string, appId: string, name: string): DescribeFirstRankResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return describeFirstRankWithOptions(appGroupIdentity, appId, name, headers, runtime);
}

model DescribeInterventionDictionaryResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D7CCF454-472A-030E-F254-604520B028AA'),
  result?: {
    analyzer?: string(name='analyzer', description='The custom analyzer.', example='-'),
    created?: string(name='created', description='The time when the the intervention dictionary was created.', example='1536233287'),
    name?: string(name='name', description='The name of the the intervention dictionary.', example='test'),
    type?: string(name='type', description='Type

*   stopword: an intervention dictionary for stop word filtering.
*   synonym: an intervention dictionary for synonym configuration.
*   correction: an intervention dictionary for spelling correction.
*   category_prediction: an intervention dictionary for category prediction.
*   ner: an intervention dictionary for named entity recognition.
*   term_weighting: an intervention dictionary for term weight analysis.', example='category_prediction'),
    updated?: string(name='updated', description='The time when the the intervention dictionary was modified.', example='1536233287'),
  }(name='result', description='The details about the intervention dictionary.'),
}

model DescribeInterventionDictionaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInterventionDictionaryResponseBody(name='body'),
}

/**
 * @summary Queries the details of an intervention dictionary.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInterventionDictionaryResponse
 */
@context("describeInterventionDictionaryWithContext")
async function describeInterventionDictionaryWithOptions(name: string, headers: map[string]string, runtime: $RuntimeOptions): DescribeInterventionDictionaryResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeInterventionDictionary',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/intervention-dictionaries/${$URL.percentEncode(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of an intervention dictionary.
 *
 * @return DescribeInterventionDictionaryResponse
 */
async function describeInterventionDictionary(name: string): DescribeInterventionDictionaryResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return describeInterventionDictionaryWithOptions(name, headers, runtime);
}

model DescribeQueryProcessorResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the query analysis rule is the default one.', example='true'),
    created?: int32(name='created', description='The time when the query analysis rule was created.', example='1587398402'),
    domain?: string(name='domain', description='The type of the industry. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='GENERAL'),
    indexes?: [ string ](name='indexes', description='The indexes to which the query analysis rule applies.'),
    name?: string(name='name', description='The name of the query analysis rule.', example='test'),
    processors?: [  map[string]any ](name='processors', description='The features that are used in the query analysis rule.'),
    updated?: int32(name='updated', description='The time when the query analysis rule was last updated.', example='1587398402'),
  }(name='result', description='The information about the query analysis rule.'),
}

model DescribeQueryProcessorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeQueryProcessorResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeQueryProcessorResponse
 */
@context("describeQueryProcessorWithContext")
async function describeQueryProcessorWithOptions(appGroupIdentity: string, appId: string, name: string, headers: map[string]string, runtime: $RuntimeOptions): DescribeQueryProcessorResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeQueryProcessor',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/query-processors/${$URL.percentEncode(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeQueryProcessorResponse
 */
async function describeQueryProcessor(appGroupIdentity: string, appId: string, name: string): DescribeQueryProcessorResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return describeQueryProcessorWithOptions(appGroupIdentity, appId, name, headers, runtime);
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='3B7E42BD-1D63-2F6B-C8E0-41BACEA76EEB'),
  result?: [ 
    {
      consoleUrl?: string(name='consoleUrl', description='The console URL.', example='https://opensearch-cn-hangzhou.console.aliyun.com'),
      endpoint?: string(name='endpoint', description='The endpoint.', example='opensearch.cn-hangzhou.aliyuncs.com'),
      localName?: string(name='localName', description='The region name.', example='China (Hangzhou)'),
      regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
    }
  ](name='result', description='The results returned.'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @summary Queries the endpoints of all regions that support OpenSearch.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
@context("describeRegionsWithContext")
async function describeRegionsWithOptions(headers: map[string]string, runtime: $RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeRegions',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/regions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the endpoints of all regions that support OpenSearch.
 *
 * @return DescribeRegionsResponse
 */
async function describeRegions(): DescribeRegionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(headers, runtime);
}

model DescribeScheduledTaskResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='922DC0D9-31B5-45F9-47B7-37DC678D61A8'),
  result?: map[string]any(name='result', description='The details of the scheduled task.', example='{}'),
}

model DescribeScheduledTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeScheduledTaskResponseBody(name='body'),
}

/**
 * @summary 查看应用定时任务详情
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeScheduledTaskResponse
 */
@context("describeScheduledTaskWithContext")
async function describeScheduledTaskWithOptions(appGroupIdentity: string, taskId: string, headers: map[string]string, runtime: $RuntimeOptions): DescribeScheduledTaskResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeScheduledTask',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scheduled-tasks/${$URL.percentEncode(taskId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查看应用定时任务详情
 *
 * @return DescribeScheduledTaskResponse
 */
async function describeScheduledTask(appGroupIdentity: string, taskId: string): DescribeScheduledTaskResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return describeScheduledTaskWithOptions(appGroupIdentity, taskId, headers, runtime);
}

model DescribeSecondRankResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Specifies whether to set the fine sort expression as the default sort expression.', example='true'),
    created?: int32(name='created', description='The time when the expression was created.', example='1587052801'),
    description?: string(name='description', description='Description', example='-'),
    id?: string(name='id', description='The ID of the expression. This parameter appears only in the response.', example='89047'),
    isDefault?: string(name='isDefault', description='Indicates whether the expression is the default one. This parameter appears only in the response. Valid values:

*   true
*   false', example='true'),
    isSys?: string(name='isSys', description='Indicates whether the expression is a system expression. This parameter appears only in the response. Valid values:

*   true
*   false', example='false'),
    meta?: string(name='meta', description='The content of the fine sort expression. You can define an expression that consists of fields, feature functions, and mathematical functions to implement complex sort logic.', example='random()+now()'),
    name?: string(name='name', description='The name.', example='tests'),
    updated?: int32(name='updated', description='The time when the expression was updated.', example='1587052801'),
  }(name='result', description='The information about the fine sort expression.'),
}

model DescribeSecondRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSecondRankResponseBody(name='body'),
}

/**
 * @summary Queries a fine sort expression that is configured for a version of an OpenSearch application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSecondRankResponse
 */
@context("describeSecondRankWithContext")
async function describeSecondRankWithOptions(appGroupIdentity: string, appId: string, name: string, headers: map[string]string, runtime: $RuntimeOptions): DescribeSecondRankResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeSecondRank',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/second-ranks/${$URL.percentEncode(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a fine sort expression that is configured for a version of an OpenSearch application.
 *
 * @return DescribeSecondRankResponse
 */
async function describeSecondRank(appGroupIdentity: string, appId: string, name: string): DescribeSecondRankResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return describeSecondRankWithOptions(appGroupIdentity, appId, name, headers, runtime);
}

model DescribeSlowQueryStatusResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='5C1C1C45-C64A-AD30-565F-140871D57E5E'),
  result?: {
    appGroupId?: string(name='appGroupId', description='The ID of the application.', example='100298370'),
    region?: string(name='region', description='The network type of the slow query optimization service. Valid values:

*   outer: the Internet
*   internal: the internal network', example='internal'),
    status?: string(name='status', description='The status of the slow query optimization service. Valid values:

*   enabled
*   disabled
*   n/a', example='disabled'),
  }(name='result', description='The return result.'),
}

model DescribeSlowQueryStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSlowQueryStatusResponseBody(name='body'),
}

/**
 * @summary 获取优化大师慢查询开通状态
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSlowQueryStatusResponse
 */
@context("describeSlowQueryStatusWithContext")
async function describeSlowQueryStatusWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: $RuntimeOptions): DescribeSlowQueryStatusResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeSlowQueryStatus',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/optimizers/slow-query`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取优化大师慢查询开通状态
 *
 * @return DescribeSlowQueryStatusResponse
 */
async function describeSlowQueryStatus(appGroupIdentity: string): DescribeSlowQueryStatusResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return describeSlowQueryStatusWithOptions(appGroupIdentity, headers, runtime);
}

model DescribeUserAnalyzerRequest {
  with?: string(name='with', description='The Associated information,output properties based on hierarchy.
* **all**: Outputs associated app information', example='all'),
}

model DescribeUserAnalyzerResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='FFAEF396-10EF-53C7-1F51-518853880729'),
  result?: map[string]any(name='result', description='The details of the custom analyzer.', example='{}'),
}

model DescribeUserAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUserAnalyzerResponseBody(name='body'),
}

/**
 * @summary 获取自定义分析器详情
 *
 * @param request DescribeUserAnalyzerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserAnalyzerResponse
 */
@context("describeUserAnalyzerWithContext")
async function describeUserAnalyzerWithOptions(name: string, request: DescribeUserAnalyzerRequest, headers: map[string]string, runtime: $RuntimeOptions): DescribeUserAnalyzerResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.with)) {
    query['with'] = request.with;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeUserAnalyzer',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/user-analyzers/${$URL.percentEncode(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取自定义分析器详情
 *
 * @param request DescribeUserAnalyzerRequest
 * @return DescribeUserAnalyzerResponse
 */
async function describeUserAnalyzer(name: string, request: DescribeUserAnalyzerRequest): DescribeUserAnalyzerResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return describeUserAnalyzerWithOptions(name, request, headers, runtime);
}

model DisableSlowQueryResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='728E89C6-8673-D39B-39A1-5BA2B56D448F'),
  result?: map[string]any(name='result', description='The return result.', example='{}'),
}

model DisableSlowQueryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableSlowQueryResponseBody(name='body'),
}

/**
 * @summary 禁用优化大师慢查询服务
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableSlowQueryResponse
 */
@context("disableSlowQueryWithContext")
async function disableSlowQueryWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: $RuntimeOptions): DisableSlowQueryResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DisableSlowQuery',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/optimizers/slow-query/actions/disable`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 禁用优化大师慢查询服务
 *
 * @return DisableSlowQueryResponse
 */
async function disableSlowQuery(appGroupIdentity: string): DisableSlowQueryResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return disableSlowQueryWithOptions(appGroupIdentity, headers, runtime);
}

model EnableSlowQueryResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='728E89C6-8673-D39B-39A1-5BA2B56D448F'),
  result?: map[string]any(name='result', description='The returned data.', example='{}'),
}

model EnableSlowQueryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableSlowQueryResponseBody(name='body'),
}

/**
 * @summary Enables slow query optimization of Optimization Master.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableSlowQueryResponse
 */
@context("enableSlowQueryWithContext")
async function enableSlowQueryWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: $RuntimeOptions): EnableSlowQueryResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'EnableSlowQuery',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/optimizers/slow-query/actions/enable`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables slow query optimization of Optimization Master.
 *
 * @return EnableSlowQueryResponse
 */
async function enableSlowQuery(appGroupIdentity: string): EnableSlowQueryResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return enableSlowQueryWithOptions(appGroupIdentity, headers, runtime);
}

model GenerateMergedTableRequest {
  body?: Schema(name='body', description='The request body parameters.'),
  spec?: string(name='spec', description='The specifications of the OpenSearch instance. This parameter is used to check whether the OpenSearch instance meets the special limits on an exclusive instance.

Default value: opensearch.share.common.

For more information, see the description of the spec field in the Quota topic.', example='"opensearch.share.common"'),
}

model GenerateMergedTableResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: {
    fromTable?: map[string]any(name='fromTable', description='The tables on which the JOIN operation is performed.', example='-'),
    mergeTable?: map[string]any(name='mergeTable', description='The wide table that is generated after the JOIN operation is performed on multiple tables.', example='-'),
    primaryKey?: string(name='primaryKey', description='The primary key.', example='-'),
  }(name='result', description='The response parameters.'),
}

model GenerateMergedTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GenerateMergedTableResponseBody(name='body'),
}

/**
 * @summary Queries the information about a wide table that is generated after a JOIN operation is performed on multiple tables.
 *
 * @param request GenerateMergedTableRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateMergedTableResponse
 */
@context("generateMergedTableWithContext")
async function generateMergedTableWithOptions(request: GenerateMergedTableRequest, headers: map[string]string, runtime: $RuntimeOptions): GenerateMergedTableResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.spec)) {
    query['spec'] = request.spec;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GenerateMergedTable',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/assist/schema/actions/merge`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about a wide table that is generated after a JOIN operation is performed on multiple tables.
 *
 * @param request GenerateMergedTableRequest
 * @return GenerateMergedTableResponse
 */
async function generateMergedTable(request: GenerateMergedTableRequest): GenerateMergedTableResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return generateMergedTableWithOptions(request, headers, runtime);
}

model GetDomainRequest {
  appGroupIdentity?: string(name='appGroupIdentity', description='The name or ID of the application.

This parameter is required.', example='my_app_group_name'),
}

model GetDomainResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: map[string]any(name='result', description='The returned result.', example='-'),
}

model GetDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDomainResponseBody(name='body'),
}

/**
 * @summary Queries the type of an industry.
 *
 * @param request GetDomainRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDomainResponse
 */
@context("getDomainWithContext")
async function getDomainWithOptions(domainName: string, request: GetDomainRequest, headers: map[string]string, runtime: $RuntimeOptions): GetDomainResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.appGroupIdentity)) {
    query['appGroupIdentity'] = request.appGroupIdentity;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDomain',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/domains/${$URL.percentEncode(domainName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the type of an industry.
 *
 * @param request GetDomainRequest
 * @return GetDomainResponse
 */
async function getDomain(domainName: string, request: GetDomainRequest): GetDomainResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getDomainWithOptions(domainName, request, headers, runtime);
}

model GetFunctionCurrentVersionRequest {
  category?: string(name='category', description='The category. By default, this parameter is left empty.', example='general'),
  domain?: string(name='domain', description='The industry. By default, this parameter is left empty, which indicates General-purpose Edition.', example='ecommerce'),
  functionType?: string(name='functionType', description='The type of the feature. Valid values:

*   PAAS. This is the default value.
*   SAAS.', example='PAAS'),
  modelType?: string(name='modelType', description='The type of the model. The following features correspond to different model types:

*   CTR model: tf_checkpoint
*   Popularity model: pop
*   Category model: offline_inference
*   Hotword model: offline_inference
*   Shading model: offline_inference
*   Drop-down suggestion model: offline_inference
*   Word segmentation model: text
*   Word weight model: tf_checkpoint

This parameter is required.', example='tf_checkpoint'),
}

model GetFunctionCurrentVersionResponseBody = {
  code?: string(name='Code', description='The error code.', example='Version.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='version not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1638157479281'),
  result?: {
    functionName?: string(name='FunctionName', description='The name of the feature.', example='ctr'),
    functionType?: string(name='FunctionType', description='The type of the feature. Valid values:

*   PAAS
*   SAAS', example='PAAS'),
    modelType?: string(name='ModelType', description='The type of the model.', example='tf_checkpoint'),
    versionConfig?: {
      createParameters?: [ 
        {
          name?: string(name='Name', description='The name of the parameter.', example='params1'),
          required?: string(name='Required', description='Indicates whether the parameter is required.', example='true'),
        }
      ](name='CreateParameters', description='The parameters that are used to create the instance.', example='[                 {                     "name": "params1",                     "required": "true",                     "formItemProps": "{\\\\"required\\\\": true, \\\\"pattern?\\\\": \\\\"/^[a-zA-Z][a-zA-Z0-9_]{0,29}$/\\\\"}",                     "componentProps": "{\\\\"component\\\\": \\\\"Input\\\\", \\\\"attributes\\\\": {\\\\"defaultValue\\\\": \\\\"value1\\\\"}}"                 }             ]'),
      depends?: [ 
        {
          condition?: string(name='Condition', description='The condition.', example='""'),
          dependency?: string(name='Dependency', description='The dependency.', example='""'),
          description?: string(name='Description', description='The description.', example='""'),
        }
      ](name='Depends', description='The dependencies of the instance.'),
      usageParameters?: [ 
        {
          name?: string(name='Name', description='The name of the parameter.', example='""'),
          required?: string(name='Required', description='Indicates whether the parameter is required.', example='""'),
        }
      ](name='UsageParameters', description='The parameters that are used to use the instance online.', example='[]'),
    }(name='VersionConfig', description='The configuration information about the instance.'),
    versionId?: long(name='VersionId', description='The ID of the version.', example='101'),
    versionName?: string(name='VersionName', description='The name of the version.', example='v1'),
  }(name='Result', description='The result of the request.'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model GetFunctionCurrentVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionCurrentVersionResponseBody(name='body'),
}

/**
 * @summary Queries the version information about the current feature when you create an instance.
 *
 * @param request GetFunctionCurrentVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionCurrentVersionResponse
 */
@context("getFunctionCurrentVersionWithContext")
async function getFunctionCurrentVersionWithOptions(functionName: string, request: GetFunctionCurrentVersionRequest, headers: map[string]string, runtime: $RuntimeOptions): GetFunctionCurrentVersionResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.category)) {
    query['category'] = request.category;
  }
  if (!$isNull(request.domain)) {
    query['domain'] = request.domain;
  }
  if (!$isNull(request.functionType)) {
    query['functionType'] = request.functionType;
  }
  if (!$isNull(request.modelType)) {
    query['modelType'] = request.modelType;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetFunctionCurrentVersion',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/functions/${$URL.percentEncode(functionName)}/current-version`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the version information about the current feature when you create an instance.
 *
 * @param request GetFunctionCurrentVersionRequest
 * @return GetFunctionCurrentVersionResponse
 */
async function getFunctionCurrentVersion(functionName: string, request: GetFunctionCurrentVersionRequest): GetFunctionCurrentVersionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionCurrentVersionWithOptions(functionName, request, headers, runtime);
}

model GetFunctionDefaultInstanceResponseBody = {
  code?: string(name='Code', description='The error code.', example='DefaultInstance.NotExist'),
  functionName?: string(name='FunctionName', description='The name of the feature.', example='cdn_waf'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  instanceName?: string(name='InstanceName', description='The name of the instance.', example='sh-bp1oi31w1jn4ctdyv'),
  latency?: long(name='Latency', description='The default running time.', example='123'),
  message?: string(name='Message', description='The error message.', example='default instance not set.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='062BA91F-A568-5779-8A5B-9E62C9BB3DC1'),
  result?: {
    instanceName?: string(name='InstanceName', description='The default instance name.', example='model1'),
  }(name='Result', description='The result of the request.', example='{\\\\"Pagination\\\\": {\\\\"TotalCount\\\\": 0, \\\\"PageNumber\\\\": 1, \\\\"PageSize\\\\": 10}, \\\\"AntConsortiums\\\\": []}'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model GetFunctionDefaultInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionDefaultInstanceResponseBody(name='body'),
}

/**
 * @summary Queries the algorithm instance that an application uses by default.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionDefaultInstanceResponse
 */
@context("getFunctionDefaultInstanceWithContext")
async function getFunctionDefaultInstanceWithOptions(appGroupIdentity: string, functionName: string, headers: map[string]string, runtime: $RuntimeOptions): GetFunctionDefaultInstanceResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetFunctionDefaultInstance',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/functions/${$URL.percentEncode(functionName)}/default-instance`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the algorithm instance that an application uses by default.
 *
 * @return GetFunctionDefaultInstanceResponse
 */
async function getFunctionDefaultInstance(appGroupIdentity: string, functionName: string): GetFunctionDefaultInstanceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionDefaultInstanceWithOptions(appGroupIdentity, functionName, headers, runtime);
}

model GetFunctionInstanceRequest {
  output?: string(name='output', description='Specifies the richness of returned information. Valid values:

*   simple: displays only the basic information.
*   normal: displays information such as createParameters and cron. This is the default value.
*   detail: returns the details of the training task.', example='detail'),
}

model GetFunctionInstanceResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, this parameter is left empty.', example='Instance.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='instance not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='68ED4E1B-92B8-5821-A886-9C90686139EB'),
  result?: {
    belongs?: {
      category?: string(name='Category', description='The category.', example='general'),
      domain?: string(name='Domain', description='The industry.', example='ecommerce'),
      language?: string(name='Language', description='The abbreviation of the language that applies.', example='zh'),
    }(name='Belongs', description='The information about the instance.'),
    createParameters?: [ 
      {
        name?: string(name='Name', description='The name of the parameter.', example='param1'),
        value?: string(name='Value', description='The value of the parameter.', example='value1'),
      }
    ](name='CreateParameters', description='The parameters that are used to create the instance.'),
    createTime?: long(name='CreateTime', description='The time when the task was created. Unit: milliseconds.', example='1234'),
    cron?: string(name='Cron', description='The cron expression used to schedule training, in the format of (Minutes Hours DayofMonth Month DayofWeek). If the value is empty, it indicates that no periodic training is performed.', example='0 3 ? \\\\* 0,1,3,5 (at 3 a.m. on Sunday, Monday, Wednesday, and Friday)'),
    description?: string(name='Description', description='The description of the instance.', example='instance descriptions'),
    extendInfo?: string(name='ExtendInfo', description='The extended information, which is a JSON string.', example='{\\\\"dataReport\\\\":{},\\\\"errors\\\\":{}}'),
    functionName?: string(name='FunctionName', description='The name of the feature.', example='ctr'),
    functionType?: string(name='FunctionType', description='The type of the feature.', example='PAAS'),
    instanceName?: string(name='InstanceName', description='The name of the instance.', example='ctr_test'),
    modelType?: string(name='ModelType', description='The type of the model.', example='tf_checkpoint'),
    source?: string(name='Source', description='How the instance is created. Valid values:

*   user: The instance is created by user.
*   builtin: The instance is created by the system.', example='user'),
    status?: string(name='Status', description='The status of the instance. Valid values:

1.  unavailable: No model is available. Models must be trained before you can use them.
2.  available: Models can be used.', example='available'),
    task?: {
      dagStatus?: string(name='DagStatus', description='The status of the task. Valid values:

*   success: succeeded
*   failed: failed
*   untrained: to be trained
*   pending: being scheduled
*   running: being trained', example='success'),
      lastRunTime?: long(name='LastRunTime', description='The time consumed for the most recent run, in milliseconds.', example='1234'),
    }(name='Task', description='The information about the training task. This parameter is not displayed if no task is available.'),
    usageParameters?: [ 
      {
        name?: string(name='Name', description='The name of the parameter.', example='use_param1'),
        value?: string(name='Value', description='The value of the parameter.', example='value1'),
      }
    ](name='UsageParameters', description='The parameters that are used.'),
    versionId?: long(name='VersionId', description='The ID of the version.', example='101'),
  }(name='Result', description='The details of the instance.', example='{}'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model GetFunctionInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionInstanceResponseBody(name='body'),
}

/**
 * @summary Queries the details of an algorithm instance by instance name.
 *
 * @param request GetFunctionInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionInstanceResponse
 */
@context("getFunctionInstanceWithContext")
async function getFunctionInstanceWithOptions(appGroupIdentity: string, functionName: string, instanceName: string, request: GetFunctionInstanceRequest, headers: map[string]string, runtime: $RuntimeOptions): GetFunctionInstanceResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.output)) {
    query['output'] = request.output;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetFunctionInstance',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/functions/${$URL.percentEncode(functionName)}/instances/${$URL.percentEncode(instanceName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of an algorithm instance by instance name.
 *
 * @param request GetFunctionInstanceRequest
 * @return GetFunctionInstanceResponse
 */
async function getFunctionInstance(appGroupIdentity: string, functionName: string, instanceName: string, request: GetFunctionInstanceRequest): GetFunctionInstanceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionInstanceWithOptions(appGroupIdentity, functionName, instanceName, request, headers, runtime);
}

model GetFunctionResourceRequest {
  output?: string(name='output', description='The output level.

Valid values:

*   simple
*   normal
*   detail', example='detail'),
}

model GetFunctionResourceResponseBody = {
  code?: string(name='Code', description='The error code returned. If no error occurs, this value is empty.', example='Resource.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code returned.', example='200'),
  latency?: double(name='Latency', description='The time consumed for the API request. Unit: milliseconds.', example='123'),
  message?: string(name='Message', description='The error message returned.', example='Resource not exist.'),
  requestId?: string(name='RequestId', description='The request ID.', example='E215C843-0795-5293-AC9A-14FE0723E890'),
  result?: {
    createTime?: long(name='CreateTime', description='The time when the resource was created. Unit: milliseconds.', example='1234'),
    data?: {
      content?: string(name='Content', description='The content of the file that corresponds to a resource of the raw_file type.', example='abc'),
      generators?: [ 
        {
          generator?: string(name='Generator', description='The type of the feature generator.', example='id'),
          input?: {
            features?: [ 
              {
                name?: string(name='Name', description='The name of the feature.', example='system_item_id'),
                type?: string(name='Type', description='The type of the feature.', example='item'),
              }
            ](name='Features', description='The input features.'),
          }(name='Input', description='The input.'),
          output?: string(name='Output', description='The name of the output feature.', example='output_feature_name'),
        }
      ](name='Generators', description='The feature generators that correspond to resources of the feature_generator type.'),
    }(name='Data', description='The resource data. The data structure varies with the resource type.'),
    description?: string(name='Description', description='The description of the resource.', example='""'),
    functionName?: string(name='FunctionName', description='The name of the feature.', example='rank'),
    modifyTime?: long(name='ModifyTime', description='The time when the resource was modified. Unit: milliseconds.', example='1234'),
    referencedInstances?: [ string ](name='ReferencedInstances', description='The algorithm instances that are referenced.'),
    resourceName?: string(name='ResourceName', description='The name of the resource.', example='fg_json'),
    resourceType?: string(name='ResourceType', description='The type of the resource.', example='raw_file'),
  }(name='Result', description='The returned results.'),
  status?: string(name='Status', description='The HTTP status code. Valid values:

*   OK
*   FAIL', example='OK'),
}

model GetFunctionResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionResourceResponseBody(name='body'),
}

/**
 * @summary Queries an algorithm resource.
 *
 * @param request GetFunctionResourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionResourceResponse
 */
@context("getFunctionResourceWithContext")
async function getFunctionResourceWithOptions(appGroupIdentity: string, functionName: string, resourceName: string, request: GetFunctionResourceRequest, headers: map[string]string, runtime: $RuntimeOptions): GetFunctionResourceResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.output)) {
    query['output'] = request.output;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetFunctionResource',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/functions/${$URL.percentEncode(functionName)}/resources/${$URL.percentEncode(resourceName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries an algorithm resource.
 *
 * @param request GetFunctionResourceRequest
 * @return GetFunctionResourceResponse
 */
async function getFunctionResource(appGroupIdentity: string, functionName: string, resourceName: string, request: GetFunctionResourceRequest): GetFunctionResourceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionResourceWithOptions(appGroupIdentity, functionName, resourceName, request, headers, runtime);
}

model GetFunctionTaskResponseBody = {
  code?: string(name='Code', description='The error code.', example='Task.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='operation success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A4D487A9-A456-5AA5-A9C6-B7BF2889CF74'),
  result?: {
    endTime?: long(name='EndTime', description='The timestamp that indicates the end time of the task. Unit: milliseconds.', example='1647213406267'),
    extendInfo?: string(name='ExtendInfo', description='The extended information, which is a JSON string.', example='{\\\\"recall\\\\":91,\\\\"errors\\\\":[]}'),
    functionName?: string(name='FunctionName', description='The name of the feature.', example='ctr'),
    generation?: string(name='Generation', description='The number of iterations.', example='1'),
    progress?: long(name='Progress', description='The progress. 90 indicates 90%.', example='90'),
    runId?: string(name='RunId', description='The ID of the task.', example='trigger__2021-03-05T12:18:41'),
    startTime?: long(name='StartTime', description='The timestamp that indicates the start time of the task. Unit: milliseconds.', example='1647212220000'),
    status?: string(name='Status', description='The status of the task. Valid values:

*   success
*   failed
*   running', example='success'),
  }(name='Result', description='The result of the request.'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model GetFunctionTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionTaskResponseBody(name='body'),
}

/**
 * @summary Queries the details of a training task.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionTaskResponse
 */
@context("getFunctionTaskWithContext")
async function getFunctionTaskWithOptions(appGroupIdentity: string, functionName: string, instanceName: string, generation: string, headers: map[string]string, runtime: $RuntimeOptions): GetFunctionTaskResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetFunctionTask',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/functions/${$URL.percentEncode(functionName)}/instances/${$URL.percentEncode(instanceName)}/tasks/${$URL.percentEncode(generation)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a training task.
 *
 * @return GetFunctionTaskResponse
 */
async function getFunctionTask(appGroupIdentity: string, functionName: string, instanceName: string, generation: string): GetFunctionTaskResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionTaskWithOptions(appGroupIdentity, functionName, instanceName, generation, headers, runtime);
}

model GetFunctionVersionResponseBody = {
  code?: string(name='Code', description='The error code.', example='Version.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The maximum duration for which a task can be executed.', example='123'),
  message?: string(name='Message', description='The error message.', example='version not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1638157479281'),
  result?: {
    functionName?: string(name='FunctionName', description='The name of the feature.', example='ctr'),
    functionType?: string(name='FunctionType', description='The type of the feature. Valid values:

*   PAAS
*   SAAS', example='PAAS'),
    modelType?: string(name='ModelType', description='The type of the model.', example='tf_checkpoint'),
    versionConfig?: {
      createParameters?: [ 
        {
          name?: string(name='Name', description='The name of the parameter.', example='params1'),
          required?: string(name='Required', description='Indicates whether the parameter is required.', example='true'),
        }
      ](name='CreateParameters', description='The parameters that are used to create the instance.', example='[                 {                     "name": "params1",                     "required": "true",                     "formItemProps": "{\\\\"required\\\\": true, \\\\"pattern?\\\\": \\\\"/^[a-zA-Z][a-zA-Z0-9_]{0,29}$/\\\\"}",                     "componentProps": "{\\\\"component\\\\": \\\\"Input\\\\", \\\\"attributes\\\\": {\\\\"defaultValue\\\\": \\\\"value1\\\\"}}"                 }             ]'),
      depends?: [ 
        {
          condition?: string(name='Condition', description='The condition.', example='""'),
          dependency?: string(name='Dependency', description='The dependency.', example='""'),
          description?: string(name='Description', description='The description.', example='""'),
        }
      ](name='Depends', description='The dependencies of the instance.'),
      usageParameters?: [ 
        {
          name?: string(name='Name', description='The name of the instance.', example='""'),
          required?: string(name='Required', description='Indicates whether the parameter is required.', example='""'),
        }
      ](name='UsageParameters', description='The parameters that are used during online use of the instance.', example='[]'),
    }(name='VersionConfig', description='The configuration information.'),
    versionId?: long(name='VersionId', description='The ID of the version.', example='101'),
    versionName?: string(name='VersionName', description='The name of the version.', example='v1'),
  }(name='Result', description='The result body.', example='[]'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model GetFunctionVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionVersionResponseBody(name='body'),
}

/**
 * @summary Queries version information by version ID.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionVersionResponse
 */
@context("getFunctionVersionWithContext")
async function getFunctionVersionWithOptions(functionName: string, versionId: string, headers: map[string]string, runtime: $RuntimeOptions): GetFunctionVersionResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetFunctionVersion',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/functions/${$URL.percentEncode(functionName)}/versions/${$URL.percentEncode(versionId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries version information by version ID.
 *
 * @return GetFunctionVersionResponse
 */
async function getFunctionVersion(functionName: string, versionId: string): GetFunctionVersionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionVersionWithOptions(functionName, versionId, headers, runtime);
}

model GetScriptFileNamesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
  result?: [ 
    {
      createTime?: string(name='createTime', description='The time when the script file was created.', example='2020-04-02 20:21:14'),
      fileName?: string(name='fileName', description='The name of the script file.', example='my_cava_script.cava'),
      modifyTime?: string(name='modifyTime', description='The time when the script file was last modified.', example='2020-04-02 21:21:14'),
      pathName?: string(name='pathName', description='The path name of the script file.', example='src'),
    }
  ](name='result', description='The files of the script.'),
}

model GetScriptFileNamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetScriptFileNamesResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetScriptFileNamesResponse
 */
@context("getScriptFileNamesWithContext")
async function getScriptFileNamesWithOptions(appGroupIdentity: string, appVersionId: string, scriptName: string, headers: map[string]string, runtime: $RuntimeOptions): GetScriptFileNamesResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetScriptFileNames',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appVersionId)}/sort-scripts/${$URL.percentEncode(scriptName)}/file-names`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return GetScriptFileNamesResponse
 */
async function getScriptFileNames(appGroupIdentity: string, appVersionId: string, scriptName: string): GetScriptFileNamesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getScriptFileNamesWithOptions(appGroupIdentity, appVersionId, scriptName, headers, runtime);
}

model GetSearchStrategyResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='5C1C1C45-C64A-AD30-565F-140871D57E5E'),
}

model GetSearchStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSearchStrategyResponseBody(name='body'),
}

/**
 * @summary Queries the details of a query policy.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSearchStrategyResponse
 */
@context("getSearchStrategyWithContext")
async function getSearchStrategyWithOptions(appGroupIdentity: string, appId: string, strategyName: string, headers: map[string]string, runtime: $RuntimeOptions): GetSearchStrategyResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetSearchStrategy',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/search-strategies/${$URL.percentEncode(strategyName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a query policy.
 *
 * @return GetSearchStrategyResponse
 */
async function getSearchStrategy(appGroupIdentity: string, appId: string, strategyName: string): GetSearchStrategyResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getSearchStrategyWithOptions(appGroupIdentity, appId, strategyName, headers, runtime);
}

model GetSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: {
    createTime?: string(name='createTime', description='The time when the script was created.', example='2020-04-02 20:21:14'),
    description?: string(name='description'),
    modifyTime?: string(name='modifyTime', description='The time when the script was last modified.', example='2020-04-02 21:21:14'),
    scope?: string(name='scope', description='The sort phase to which the script applies.', example='second_rank'),
    scriptName?: string(name='scriptName', description='The name of the script.', example='rank_cava_20230606_v7'),
    status?: string(name='status', description='The status of the script. For more information, see the description of the status response parameter in the ListSortScripts topic.', example='released'),
    type?: string(name='type', description='The type of the script.', example='cava_script'),
  }(name='result', description='The details of the script.'),
}

model GetSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSortScriptResponseBody(name='body'),
}

/**
 * @summary Queries the details of a sort script.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSortScriptResponse
 */
@context("getSortScriptWithContext")
async function getSortScriptWithOptions(appGroupIdentity: string, scriptName: string, appVersionId: string, headers: map[string]string, runtime: $RuntimeOptions): GetSortScriptResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetSortScript',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appVersionId)}/sort-scripts/${$URL.percentEncode(scriptName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a sort script.
 *
 * @return GetSortScriptResponse
 */
async function getSortScript(appGroupIdentity: string, scriptName: string, appVersionId: string): GetSortScriptResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getSortScriptWithOptions(appGroupIdentity, scriptName, appVersionId, headers, runtime);
}

model GetSortScriptFileResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: {
    content?: string(name='content', description='The script content that is encoded in the Base64 format.', example='YWJjZGVmZw=='),
    createTime?: string(name='createTime', description='The time when the script was created.', example='2020-04-02 20:21:14'),
    modifyTime?: string(name='modifyTime', description='The time when the script was last modified.', example='2020-04-02 21:21:14'),
    version?: long(name='version', description='The version of the script content.', example='123456'),
  }(name='result', description='The content of the sort script.'),
}

model GetSortScriptFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSortScriptFileResponseBody(name='body'),
}

/**
 * @summary Queries the content of a sort script.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSortScriptFileResponse
 */
@context("getSortScriptFileWithContext")
async function getSortScriptFileWithOptions(appGroupIdentity: string, scriptName: string, appVersionId: string, fileName: string, headers: map[string]string, runtime: $RuntimeOptions): GetSortScriptFileResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetSortScriptFile',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appVersionId)}/sort-scripts/${$URL.percentEncode(scriptName)}/files/src/${$URL.percentEncode(fileName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the content of a sort script.
 *
 * @return GetSortScriptFileResponse
 */
async function getSortScriptFile(appGroupIdentity: string, scriptName: string, appVersionId: string, fileName: string): GetSortScriptFileResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getSortScriptFileWithOptions(appGroupIdentity, scriptName, appVersionId, fileName, headers, runtime);
}

model ListABTestExperimentsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ 
    {
      created?: int32(name='created', description='The time when the experiment was created.', example='1588842080'),
      id?: string(name='id', description='The experiment ID.', example='12888'),
      name?: string(name='name', description='The group alias.', example='test1'),
      online?: boolean(name='online', description='Indicates whether the experiment is in effect. Valid values:

*   true
*   false', example='true'),
      params?: map[string]any(name='params', description='The experiment parameters.', example='1'),
      traffic?: int32(name='traffic', description='The percentage of traffic that is routed to the experiment.

Valid values: [0,100]', example='30'),
      updated?: int32(name='updated', description='The time when the experiment was last modified.', example='1588842080'),
    }
  ](name='result', description='The experiment details.\\\\
For more information, see [ABTestExperiment](https://help.aliyun.com/document_detail/173617.html).'),
}

model ListABTestExperimentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListABTestExperimentsResponseBody(name='body'),
}

/**
 * @summary Queries a list of experiments.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListABTestExperimentsResponse
 */
@context("listABTestExperimentsWithContext")
async function listABTestExperimentsWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, headers: map[string]string, runtime: $RuntimeOptions): ListABTestExperimentsResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ListABTestExperiments',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scenes/${$URL.percentEncode(sceneId)}/groups/${$URL.percentEncode(groupId)}/experiments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of experiments.
 *
 * @return ListABTestExperimentsResponse
 */
async function listABTestExperiments(appGroupIdentity: string, sceneId: string, groupId: string): ListABTestExperimentsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listABTestExperimentsWithOptions(appGroupIdentity, sceneId, groupId, headers, runtime);
}

model ListABTestFixedFlowDividersResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ string ](name='result'),
}

model ListABTestFixedFlowDividersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListABTestFixedFlowDividersResponseBody(name='body'),
}

/**
 * @summary Queries whitelists.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListABTestFixedFlowDividersResponse
 */
@context("listABTestFixedFlowDividersWithContext")
async function listABTestFixedFlowDividersWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string, headers: map[string]string, runtime: $RuntimeOptions): ListABTestFixedFlowDividersResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ListABTestFixedFlowDividers',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scenes/${$URL.percentEncode(sceneId)}/groups/${$URL.percentEncode(groupId)}/experiments/${$URL.percentEncode(experimentId)}/fixed-flow-dividers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries whitelists.
 *
 * @return ListABTestFixedFlowDividersResponse
 */
async function listABTestFixedFlowDividers(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string): ListABTestFixedFlowDividersResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listABTestFixedFlowDividersWithOptions(appGroupIdentity, sceneId, groupId, experimentId, headers, runtime);
}

model ListABTestGroupsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ 
    {
      created?: int32(name='created', description='The time when the test group was created.', example='1588839490'),
      id?: string(name='id', description='The ID of the test group.', example='13466'),
      name?: string(name='name', description='The name of the test group.', example='Group_2020-5-7_15:23:3'),
      status?: int32(name='status', description='The status of the test group. Valid values:

*   0: not in effect
*   1: in effect', example='1'),
      updated?: int32(name='updated', description='The time when the test group was last modified.', example='1588839490'),
    }
  ](name='result', description='The test groups.

For more information, see [ABTestGroup](https://help.aliyun.com/document_detail/178935.html).'),
}

model ListABTestGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListABTestGroupsResponseBody(name='body'),
}

/**
 * @summary 获取实验组清单
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListABTestGroupsResponse
 */
@context("listABTestGroupsWithContext")
async function listABTestGroupsWithOptions(appGroupIdentity: string, sceneId: string, headers: map[string]string, runtime: $RuntimeOptions): ListABTestGroupsResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ListABTestGroups',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scenes/${$URL.percentEncode(sceneId)}/groups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取实验组清单
 *
 * @return ListABTestGroupsResponse
 */
async function listABTestGroups(appGroupIdentity: string, sceneId: string): ListABTestGroupsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listABTestGroupsWithOptions(appGroupIdentity, sceneId, headers, runtime);
}

model ListABTestScenesResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ 
    {
      created?: int32(name='created', description='The time when the test group was created.', example='1588836130'),
      id?: string(name='id', description='The ID of the test group.', example='20404'),
      name?: string(name='name', description='The alias of the test group.', example='kevintest_2020-5-7_15:21:482'),
      status?: int32(name='status', description='The status of the test group. Valid values:

*   0: not in effect
*   1: in effect', example='1'),
      updated?: int32(name='updated', description='The time when the test group was last updated.', example='1588836129'),
      values?: [ string ](name='values', description='The name of the test scenario.'),
    }
  ](name='result', description='The details of the test scenario.

For more information, see [ABTestScene](https://help.aliyun.com/document_detail/173618.html).'),
}

model ListABTestScenesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListABTestScenesResponseBody(name='body'),
}

/**
 * @summary Queries test scenarios.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListABTestScenesResponse
 */
@context("listABTestScenesWithContext")
async function listABTestScenesWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: $RuntimeOptions): ListABTestScenesResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ListABTestScenes',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scenes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries test scenarios.
 *
 * @return ListABTestScenesResponse
 */
async function listABTestScenes(appGroupIdentity: string): ListABTestScenesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listABTestScenesWithOptions(appGroupIdentity, headers, runtime);
}

model ListAppGroupsRequest {
  instanceId?: string(name='instanceId', description='The ID of the instance. Exact match is used.', example='ops-cn-xxxx'),
  name?: string(name='name', description='The name of the application.', example='my_name'),
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group.', example='"110123123"'),
  sortBy?: int32(name='sortBy', description='The method based on which applications are sorted. Valid values:

*   0: sorts applications in descending order by creation time.
*   1: sorts applications in descending order by modification time.

Default value: 0.', example='0'),
  tags?: [ 
    {
      key?: string(name='key', description='The tag key.', example='foo'),
      value?: string(name='value', description='The tag value.', example='bar'),
    }
  ](name='tags', description='The tags.'),
  type?: string(name='type', description='The type of the application. Valid values:

*   standard: a High-performance Search Edition application.
*   enhanced: an Industry Algorithm Edition application.', example='standard'),
}

model ListAppGroupsShrinkRequest {
  instanceId?: string(name='instanceId', description='The ID of the instance. Exact match is used.', example='ops-cn-xxxx'),
  name?: string(name='name', description='The name of the application.', example='my_name'),
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group.', example='"110123123"'),
  sortBy?: int32(name='sortBy', description='The method based on which applications are sorted. Valid values:

*   0: sorts applications in descending order by creation time.
*   1: sorts applications in descending order by modification time.

Default value: 0.', example='0'),
  tagsShrink?: string(name='tags', description='The tags.'),
  type?: string(name='type', description='The type of the application. Valid values:

*   standard: a High-performance Search Edition application.
*   enhanced: an Industry Algorithm Edition application.', example='standard'),
}

model ListAppGroupsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      chargeType?: string(name='chargeType', description='The billing method. Valid values:

*   POSTPAY: pay-as-you-go.
*   PREPAY: subscription.', example='POSTPAY'),
      chargingWay?: int32(name='chargingWay', description='The billable item. Valid values:

*   1: computing resources.
*   2: queries per second (QPS).', example='1'),
      commodityCode?: string(name='commodityCode', description='The commodity code.', example='opensearch'),
      created?: int32(name='created', description='The timestamp when the application was created.', example='1575442875'),
      currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='110116134'),
      description?: string(name='description', description='The description of the application.', example='"xxx"'),
      domain?: string(name='domain', description='The industry of the application.', example='""'),
      engineType?: string(name='engineType', description='The engine type.', example='ha3'),
      expireOn?: string(name='expireOn', description='The time when the application expired.', example='"xxx"'),
      hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval state of the quotas. Valid values:

*   0: The application is in service.
*   1: The quotas are being reviewed.', example='0'),
      id?: string(name='id', description='The application ID.', example='110116134'),
      instanceId?: string(name='instanceId', description='The instance ID.', example='"xxx"'),
      lockMode?: string(name='lockMode', description='The lock state. Valid values:

*   Unlock: The instance is unlocked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
      lockedByExpiration?: int32(name='lockedByExpiration', description='Indicates whether the instance is automatically locked after it expires.', example='0'),
      name?: string(name='name', description='The application name.', example='os_function_test_v1'),
      produced?: int32(name='produced', description='Indicates whether the application is created. Valid values:

*   0: The application is being created.
*   1: The application is created.', example='1'),
      projectId?: string(name='projectId', description='The name of the A/B test group.', example='"xxx"'),
      quota?: {
        computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing unit (LCU).', example='20'),
        docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
        spec?: string(name='spec', description='The specifications. Valid values:

*   opensearch.share.junior: basic.
*   opensearch.share.common: shared general-purpose.
*   opensearch.share.compute: shared computing.
*   opensearch.share.storage: shared storage.
*   opensearch.private.common: exclusive general-purpose.
*   opensearch.private.compute: exclusive computing.
*   opensearch.private.storage: exclusive storage.', example='opensearch.share.common'),
      }(name='quota', description='The information about the quotas of the application. For more information, see [Quota](https://help.aliyun.com/document_detail/170001.html).', example='{}'),
      status?: string(name='status', description='The state of the application. Valid values:

*   producing: The application is being created.
*   review_pending: The application is being reviewed.
*   config_pending: The application is to be configured.
*   normal: The application is in service.
*   frozen: The application is frozen.', example='normal'),
      switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='0'),
      tags?: [ 
        {
          key?: string(name='key', description='The tag key.', example='foo'),
          value?: string(name='value', description='The tag value.', example='bar'),
        }
      ](name='tags', description='The application tags.'),
      type?: string(name='type', description='The type of the application. Valid values:

*   standard: a High-performance Search Edition application.
*   enhanced: an Industry Algorithm Edition application.', example='enhanced'),
      updated?: int32(name='updated', description='The timestamp when the application was last updated.', example='1578916076'),
    }
  ](name='result', description='The information about the application.

For more information, see [AppGroup](https://help.aliyun.com/document_detail/170000.html).', example='[]'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='1'),
}

model ListAppGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAppGroupsResponseBody(name='body'),
}

/**
 * @summary Queries a list of OpenSearch applications.
 *
 * @description *   This operation allows you to query applications by application name, instance ID, and application type.
 * *   This operation allows you to sort the applications based on their creation time.
 * *   This operation supports the parameters for paging.
 *
 * @param tmpReq ListAppGroupsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAppGroupsResponse
 */
@context("listAppGroupsWithContext")
async function listAppGroupsWithOptions(tmpReq: ListAppGroupsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListAppGroupsResponse {
  tmpReq.validate();
  var request = new ListAppGroupsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'tags', 'json');
  }
  var query : map[string]any = {};
  if (!$isNull(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!$isNull(request.name)) {
    query['name'] = request.name;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.sortBy)) {
    query['sortBy'] = request.sortBy;
  }
  if (!$isNull(request.tagsShrink)) {
    query['tags'] = request.tagsShrink;
  }
  if (!$isNull(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListAppGroups',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of OpenSearch applications.
 *
 * @description *   This operation allows you to query applications by application name, instance ID, and application type.
 * *   This operation allows you to sort the applications based on their creation time.
 * *   This operation supports the parameters for paging.
 *
 * @param request ListAppGroupsRequest
 * @return ListAppGroupsResponse
 */
async function listAppGroups(request: ListAppGroupsRequest): ListAppGroupsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listAppGroupsWithOptions(request, headers, runtime);
}

model ListDataCollectionsRequest {
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
}

model ListDataCollectionsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='959D8782-B130-95EB-86CC-1F6ED447981F'),
  result?: [ 
    {
      created?: int32(name='created', description='The time when the task was created.', example='1581065837'),
      dataCollectionType?: string(name='dataCollectionType', description='The type of data collected. Valid values:

*   behavior: behavioral data.
*   item_info: project information.
*   industry_specific: industry-specific data.', example='BEHAVIOR'),
      id?: string(name='id', description='The data collection ID.', example='286'),
      industryName?: string(name='industryName', description='The industry name. Valid values:

*   general
*   ecommerce', example='GENERAL'),
      name?: string(name='name', description='The name of the data collection task.', example='os_function_test_v1'),
      status?: int32(name='status', description='The status of the data collection feature. Valid values:

*   0: The feature is disabled.
*   1: The feature is being enabled.
*   2: The feature is enabled.
*   3: The feature failed to be enabled.', example='2'),
      sundialId?: string(name='sundialId', description='The sundial ID.', example='1755'),
      type?: string(name='type', description='The type of the source from which data was collected. Valid values:

*   server
*   web
*   app

Only server is supported.', example='server'),
      updated?: int32(name='updated', description='The time when the data collection task was updated.', example='1581065904'),
    }
  ](name='result', description='The details of the data collection task.

For more information, see [DataCollection](https://help.aliyun.com/document_detail/173605.html).'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='1'),
}

model ListDataCollectionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataCollectionsResponseBody(name='body'),
}

/**
 * @summary Queries the data collection tasks of an OpenSearch application.
 *
 * @param request ListDataCollectionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataCollectionsResponse
 */
@context("listDataCollectionsWithContext")
async function listDataCollectionsWithOptions(appGroupIdentity: string, request: ListDataCollectionsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListDataCollectionsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListDataCollections',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/data-collections`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the data collection tasks of an OpenSearch application.
 *
 * @param request ListDataCollectionsRequest
 * @return ListDataCollectionsResponse
 */
async function listDataCollections(appGroupIdentity: string, request: ListDataCollectionsRequest): ListDataCollectionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataCollectionsWithOptions(appGroupIdentity, request, headers, runtime);
}

model ListDataSourceTableFieldsRequest {
  params?: string(name='params', description='The parameters of the data source. The value of the params parameter is a JSON string. The value must be URL-encoded.

Different types of data sources use different parameters. For more information, see the following sections of the "DataSource" topic:

*   [rds](https://help.aliyun.com/document_detail/170005.html)
*   [polardb](https://help.aliyun.com/document_detail/170005.html)
*   [odps](https://help.aliyun.com/document_detail/170005.html)
*   [mysql](https://help.aliyun.com/document_detail/173627.html)
*   [drds](https://help.aliyun.com/document_detail/173627.html)

This parameter is required.', example='{}'),
  rawType?: boolean(name='rawType', description='Specifies whether to return the original field types of the data source.', example='false'),
}

model ListDataSourceTableFieldsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: map[string]any(name='result', description='The returned result.', example='{}'),
}

model ListDataSourceTableFieldsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataSourceTableFieldsResponseBody(name='body'),
}

/**
 * @summary Queries all fields in a table of a data source. This operation is for internal use only.
 *
 * @param request ListDataSourceTableFieldsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataSourceTableFieldsResponse
 */
@context("listDataSourceTableFieldsWithContext")
async function listDataSourceTableFieldsWithOptions(dataSourceType: string, request: ListDataSourceTableFieldsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListDataSourceTableFieldsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.params)) {
    query['params'] = request.params;
  }
  if (!$isNull(request.rawType)) {
    query['rawType'] = request.rawType;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListDataSourceTableFields',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/assist/data-sources/${$URL.percentEncode(dataSourceType)}/fields`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all fields in a table of a data source. This operation is for internal use only.
 *
 * @param request ListDataSourceTableFieldsRequest
 * @return ListDataSourceTableFieldsResponse
 */
async function listDataSourceTableFields(dataSourceType: string, request: ListDataSourceTableFieldsRequest): ListDataSourceTableFieldsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataSourceTableFieldsWithOptions(dataSourceType, request, headers, runtime);
}

model ListDataSourceTablesRequest {
  params?: string(name='params', description='The parameters of the data source. The value is a JSON string which must be encoded in the urlencode format.

Different types of data sources use different parameters. For more information, see the following sections of the "DataSource" topic:

*   [rds](https://help.aliyun.com/document_detail/170005.html)
*   [polardb](https://help.aliyun.com/document_detail/170005.html)
*   [odps](https://help.aliyun.com/document_detail/170005.html)
*   [mysql](https://help.aliyun.com/document_detail/173627.html)
*   [drds](https://help.aliyun.com/document_detail/173627.html)

This parameter is required.', example='-'),
}

model ListDataSourceTablesResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ string ](name='result'),
}

model ListDataSourceTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataSourceTablesResponseBody(name='body'),
}

/**
 * @summary Obtains all data from a specified data source.
 *
 * @param request ListDataSourceTablesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataSourceTablesResponse
 */
@context("listDataSourceTablesWithContext")
async function listDataSourceTablesWithOptions(dataSourceType: string, request: ListDataSourceTablesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListDataSourceTablesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.params)) {
    query['params'] = request.params;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListDataSourceTables',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/assist/data-sources/${$URL.percentEncode(dataSourceType)}/tables`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains all data from a specified data source.
 *
 * @param request ListDataSourceTablesRequest
 * @return ListDataSourceTablesResponse
 */
async function listDataSourceTables(dataSourceType: string, request: ListDataSourceTablesRequest): ListDataSourceTablesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataSourceTablesWithOptions(dataSourceType, request, headers, runtime);
}

model ListFirstRanksResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      active?: boolean(name='active', description='Specifies whether to set the fine sort expression as the default sort expression.', example='true'),
      created?: int32(name='created', description='The time when the expression was created.', example='0'),
      description?: string(name='description', description='Description', example='""'),
      meta?: [ 
        {
          arg?: string(name='arg', description='The parameters that are used by a function in the expression.

For more information, see [Rough sort functions](https://help.aliyun.com/document_detail/180765.html).', example='""'),
          attribute?: string(name='attribute', description='The attribute, feature function, or field to be searched for.

For more information about supported feature functions, see [Rough sort functions](https://help.aliyun.com/document_detail/180765.html).', example='static_bm25()'),
          weight?: int32(name='weight', description='The weight. Valid values: -100000 to 100000. The value cannot be 0.', example='1'),
        }
      ](name='meta', description='The information about the expression.', example='[]'),
      name?: string(name='name', description='The name.', example='default'),
      updated?: int32(name='updated', description='The time when the expression was updated.', example='0'),
    }
  ](name='result', description='The information about the rough sort expression.

For more information, see [FirstRank](https://help.aliyun.com/document_detail/170007.html).', example='[]'),
}

model ListFirstRanksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFirstRanksResponseBody(name='body'),
}

/**
 * @summary Queries the rough sort expressions that are configured for a version of an OpenSearch application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFirstRanksResponse
 */
@context("listFirstRanksWithContext")
async function listFirstRanksWithOptions(appGroupIdentity: string, appId: string, headers: map[string]string, runtime: $RuntimeOptions): ListFirstRanksResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ListFirstRanks',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/first-ranks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the rough sort expressions that are configured for a version of an OpenSearch application.
 *
 * @return ListFirstRanksResponse
 */
async function listFirstRanks(appGroupIdentity: string, appId: string): ListFirstRanksResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listFirstRanksWithOptions(appGroupIdentity, appId, headers, runtime);
}

model ListFunctionInstancesRequest {
  functionType?: string(name='functionType', description='The type of the feature.', example='"PAAS"'),
  modelType?: string(name='modelType', description='The type of the model.', example='tf_checkpoint'),
  output?: string(name='output', description='The richness of the returned information. Valid values:

*   normal: displays information such as createParameters and cron. This is the default value.
*   simple: displays only the basic information.
*   detail: returns the details of the training task.', example='normal'),
  pageNumber?: int32(name='pageNumber', description='The number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries to return on each page. Default value: 10.', example='10'),
  source?: string(name='source', description='How the instance is created. Valid values:

*   builtin: The instance is created by system.
*   user: The instance is created by user. This is the default value.
*   all: all instances', example='user'),
}

model ListFunctionInstancesResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, the parameter is left empty.', example='Instance.NotExist'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message. If no error occurs, the parameter is left empty.', example='instance not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A4D487A9-A456-5AA5-A9C6-B7BF2889CF74'),
  result?: [ 
    {
      belongs?: {
        category?: string(name='Category', description='The category.', example='"general"'),
        domain?: string(name='Domain', description='The industry.', example='"ecommerce"'),
        language?: string(name='Language', description='The abbreviation of the language that applies.', example='"zh"'),
      }(name='Belongs', description='The information about the instance.', example='{}'),
      createParameters?: [ 
        {
          name?: string(name='Name', description='The name of the parameter.', example='"param1"'),
          value?: string(name='Value', description='The value of the parameter.', example='"value1"'),
        }
      ](name='CreateParameters', description='The parameters of the instance.', example='[]'),
      createTime?: long(name='CreateTime', description='The time when the instance was created.', example='1234'),
      cron?: string(name='Cron', description='The cron expression used to schedule training, in the format of (Minutes Hours DayofMonth Month DayofWeek). If the value is empty, it indicates that no periodic training is performed.', example='0 3 ? \\\\* 0,1,3,5 (at 3 a.m. on Sunday, Monday, Wednesday, and Friday)'),
      description?: string(name='Description', description='The description.', example='" "'),
      extendInfo?: string(name='ExtendInfo', description='The extended information, which is a JSON string. It includes model evaluation information and error information.', example='"{\\\\"dataReport\\\\":{},\\\\"errors\\\\":{}}"'),
      functionName?: string(name='FunctionName', description='The name of the feature.', example='"ctr"'),
      functionType?: string(name='FunctionType', description='The type of the feature.', example='"PAAS"'),
      instanceName?: string(name='InstanceName', description='The name of the instance.', example='"ctr_test"'),
      modelType?: string(name='ModelType', description='The type of the model.', example='"tf_checkpoint"'),
      source?: string(name='Source', description='How the instance is created. Valid values:

*   user: The instance is created by user.
*   builtin: The instance is created by system.', example='"user"'),
      status?: string(name='Status', description='The state of the instance. Valid values:

1.  unavailable: No model is available. Models must be trained before you can use them.
2.  available: Models can be used.', example='available'),
      usageParameters?: [ 
        {
          name?: string(name='Name', description='The name of the parameter.', example='use_param1'),
          value?: string(name='Value', description='The value of the parameter.', example='value1'),
        }
      ](name='UsageParameters', description='The parameters that are used.'),
      versionId?: long(name='VersionId', description='The ID of the version.', example='123'),
    }
  ](name='Result', description='The information about the instances.', example='[]'),
  status?: string(name='Status', description='The status of the request.', example='"OK"'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model ListFunctionInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionInstancesResponseBody(name='body'),
}

/**
 * @summary Queries all algorithm instances of a user, which meet specified conditions.
 *
 * @param request ListFunctionInstancesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFunctionInstancesResponse
 */
@context("listFunctionInstancesWithContext")
async function listFunctionInstancesWithOptions(appGroupIdentity: string, functionName: string, request: ListFunctionInstancesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListFunctionInstancesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.functionType)) {
    query['functionType'] = request.functionType;
  }
  if (!$isNull(request.modelType)) {
    query['modelType'] = request.modelType;
  }
  if (!$isNull(request.output)) {
    query['output'] = request.output;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.source)) {
    query['source'] = request.source;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListFunctionInstances',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/functions/${$URL.percentEncode(functionName)}/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all algorithm instances of a user, which meet specified conditions.
 *
 * @param request ListFunctionInstancesRequest
 * @return ListFunctionInstancesResponse
 */
async function listFunctionInstances(appGroupIdentity: string, functionName: string, request: ListFunctionInstancesRequest): ListFunctionInstancesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionInstancesWithOptions(appGroupIdentity, functionName, request, headers, runtime);
}

model ListFunctionResourcesRequest {
  output?: string(name='output', description='The output level.

Valid values:

*   simple
*   normal
*   detail', example='detail'),
  pageNumber?: int32(name='pageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries returned per page.', example='10'),
  resourceType?: string(name='resourceType', description='The type of the resource.

Valid values:

*   feature_generator

    <!-- -->

    <!-- -->

    <!-- -->

*   raw_file

    <!-- -->

    <!-- -->

    <!-- -->', example='feature_generator'),
}

model ListFunctionResourcesResponseBody = {
  code?: string(name='Code', description='The error code returned. If no error occurs, this value is empty.', example='Resource.InvalidResourceName'),
  httpCode?: long(name='HttpCode', description='The HTTP status code returned.', example='200'),
  latency?: double(name='Latency', description='The amount of time consumed for the request. Unit: milliseconds.', example='123'),
  message?: string(name='Message', description='The error message returned.', example='Invalid resource name.'),
  requestId?: string(name='RequestId', description='The request ID.', example='"3A809095-C554-5CF5-8FCE-BE19D4673790"'),
  result?: [ 
    {
      createTime?: long(name='CreateTime', description='The time when the resource was created. Unit: milliseconds.', example='1234'),
      data?: {
        content?: string(name='Content', description='The content of the file that corresponds to a resource of the raw_file type.', example='"abc"'),
        generators?: [ 
          {
            generator?: string(name='Generator', description='The type of the feature generator.', example='combo'),
            input?: {
              features?: [ 
                {
                  name?: string(name='Name', description='The name of the feature.', example='system_item_id'),
                  type?: string(name='Type', description='The type of the feature.

Valid values:

*   item

    <!-- -->

    <!-- -->

    <!-- -->

*   user

    <!-- -->

    <!-- -->

    <!-- -->', example='item'),
                }
              ](name='Features', description='The input features.'),
            }(name='Input', description='The input.'),
            output?: string(name='Output', description='The name of the output feature.', example='feature1'),
          }
        ](name='Generators', description='The feature generators that correspond to resources of the feature_generator type.'),
      }(name='Data', description='The resource data. The data structure varies with the resource type.'),
      description?: string(name='Description', description='The description of the resource.', example='resource description'),
      functionName?: string(name='FunctionName', description='The name of the feature.', example='rank'),
      modifyTime?: long(name='ModifyTime', description='The time when the resource was modified. Unit: milliseconds.', example='1234'),
      referencedInstances?: [ string ](name='ReferencedInstances', description='The algorithm instances that are referenced.'),
      resourceName?: string(name='ResourceName', description='The name of the resource.', example='fg_json'),
      resourceType?: string(name='ResourceType', description='The type of the resource.', example='feature_generator'),
    }
  ](name='Result', description='The results returned.'),
  status?: string(name='Status', description='The status of the request. Valid values: OK and FAIL.', example='OK'),
  totalCount?: long(name='TotalCount', description='The total number of records that meet the requirements.', example='2'),
}

model ListFunctionResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionResourcesResponseBody(name='body'),
}

/**
 * @summary Queries algorithm resources.
 *
 * @param request ListFunctionResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFunctionResourcesResponse
 */
@context("listFunctionResourcesWithContext")
async function listFunctionResourcesWithOptions(appGroupIdentity: string, functionName: string, request: ListFunctionResourcesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListFunctionResourcesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.output)) {
    query['output'] = request.output;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListFunctionResources',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/functions/${$URL.percentEncode(functionName)}/resources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries algorithm resources.
 *
 * @param request ListFunctionResourcesRequest
 * @return ListFunctionResourcesResponse
 */
async function listFunctionResources(appGroupIdentity: string, functionName: string, request: ListFunctionResourcesRequest): ListFunctionResourcesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionResourcesWithOptions(appGroupIdentity, functionName, request, headers, runtime);
}

model ListFunctionTasksRequest {
  endTime?: long(name='endTime', description='The end time is less than the specified time. Specify the time in the UNIX timestamp format. Unit: milliseconds.', example='1582646399'),
  pageNumber?: int32(name='pageNumber', description='The number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries to return on each page. Default value: 1.', example='10'),
  startTime?: long(name='startTime', description='The start time is greater than the specified time. Specify the time in the UNIX timestamp format. Unit: milliseconds.', example='1582214400'),
  status?: string(name='status', description='The status of the task. Valid values:

*   success
*   failed
*   running', example='success'),
}

model ListFunctionTasksResponseBody = {
  code?: string(name='Code', description='The error code.', example='200'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='fail'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1638157479281'),
  result?: [ 
    {
      endTime?: long(name='EndTime', description='The timestamp that indicates the end time. Unit: milliseconds. 0 indicates that the task has not ended.', example='100010'),
      extendInfo?: string(name='ExtendInfo', description='The value is a JSON string. It includes model evaluation information and training error information.', example='{\\\\"recall\\\\":91,\\\\"errors\\\\":[]}'),
      functionName?: string(name='FunctionName', description='The name of the feature.', example='ctr'),
      generation?: string(name='Generation', description='The number of iterations.', example='2'),
      progress?: long(name='Progress', description='The progress. 90 indicates 90%.', example='90'),
      runId?: string(name='RunId', description='The ID of the task.', example='trigger__2021-03-05T12:18:41'),
      startTime?: long(name='StartTime', description='The timestamp that indicates the start time. Unit: milliseconds.', example='100010'),
      status?: string(name='Status', description='The status of the task. Valid values:

*   success
*   failed
*   running', example='success'),
    }
  ](name='Result', description='The returned result.', example='[         {             "functionName": "ctr",             "progress": 100,             "status": "success",             "startTime": 100010,             "endTime": 200020,             "extendInfo": "{\\\\"recall\\\\":91,\\\\"errors\\\\":[]}",             "runId": "trigger__2021-03-05T12:18:41"         }     ]'),
  status?: string(name='Status', description='The status of the request.', example='200'),
  totalCount?: long(name='TotalCount', description='The total number of records that meet the requirements.', example='2'),
}

model ListFunctionTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionTasksResponseBody(name='body'),
}

/**
 * @summary Queries the training tasks. The returned results are sorted by start time in descending order.
 *
 * @param request ListFunctionTasksRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFunctionTasksResponse
 */
@context("listFunctionTasksWithContext")
async function listFunctionTasksWithOptions(appGroupIdentity: string, functionName: string, instanceName: string, request: ListFunctionTasksRequest, headers: map[string]string, runtime: $RuntimeOptions): ListFunctionTasksResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.startTime)) {
    query['startTime'] = request.startTime;
  }
  if (!$isNull(request.status)) {
    query['status'] = request.status;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListFunctionTasks',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/functions/${$URL.percentEncode(functionName)}/instances/${$URL.percentEncode(instanceName)}/tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the training tasks. The returned results are sorted by start time in descending order.
 *
 * @param request ListFunctionTasksRequest
 * @return ListFunctionTasksResponse
 */
async function listFunctionTasks(appGroupIdentity: string, functionName: string, instanceName: string, request: ListFunctionTasksRequest): ListFunctionTasksResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionTasksWithOptions(appGroupIdentity, functionName, instanceName, request, headers, runtime);
}

model ListInterventionDictionariesRequest {
  pageNumber?: int32(name='pageNumber', description='The number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries to return on each page. Default value: 10.', example='10'),
  types?: string(name='types', description='The type of the intervention dictionary. Valid values:

*   stopword: an intervention dictionary for stop word filtering
*   synonym: an intervention dictionary for synonym configuration
*   correction: an intervention dictionary for spelling correction
*   category_prediction: an intervention dictionary for category prediction
*   ner: an intervention dictionary for named entity recognition (NER)
*   term_weighting: an intervention dictionary for term weight analysis', example='["synonym"]'),
}

model ListInterventionDictionariesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      analyzer?: string(name='analyzer', description='The custom analyzer.', example='""'),
      created?: int32(name='created', description='The time when the intervention dictionary was created.', example='1539158325'),
      id?: int32(name='id', description='The ID of the intervention dictionary.', example='1'),
      name?: string(name='name', description='The name of the intervention dictionary.', example='tongyici'),
      type?: string(name='type', description='The type of the intervention dictionary. Valid values:

*   stopword: an intervention dictionary for stop word filtering
*   synonym: an intervention dictionary for synonym configuration
*   correction: an intervention dictionary for spelling correction
*   category_prediction: an intervention dictionary for category prediction
*   ner: an intervention dictionary for named entity recognition (NER)
*   term_weighting: an intervention dictionary for term weight analysis', example='synonym'),
      updated?: int32(name='updated', description='The time when the intervention dictionary was last updated.', example='1539158313'),
    }
  ](name='result', description='The information about each intervention dictionary.

For more information, see [InterventionDictionary](https://help.aliyun.com/document_detail/173608.html).'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='2'),
}

model ListInterventionDictionariesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInterventionDictionariesResponseBody(name='body'),
}

/**
 * @summary 获取用户的干预词典列表
 *
 * @param request ListInterventionDictionariesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInterventionDictionariesResponse
 */
@context("listInterventionDictionariesWithContext")
async function listInterventionDictionariesWithOptions(request: ListInterventionDictionariesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListInterventionDictionariesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.types)) {
    query['types'] = request.types;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListInterventionDictionaries',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/intervention-dictionaries`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取用户的干预词典列表
 *
 * @param request ListInterventionDictionariesRequest
 * @return ListInterventionDictionariesResponse
 */
async function listInterventionDictionaries(request: ListInterventionDictionariesRequest): ListInterventionDictionariesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listInterventionDictionariesWithOptions(request, headers, runtime);
}

model ListInterventionDictionaryEntriesRequest {
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries returned per page. Default value: 10.', example='10'),
  word?: string(name='word', description='The intervention entry.', example='test'),
}

model ListInterventionDictionaryEntriesResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='516A02B7-2167-8D92-12D0-B639A2A0F3C5'),
  result?: [ 
    {
      cmd?: string(name='cmd', description='The command. Valid values:

*   add
*   delete', example='add'),
      created?: long(name='created', description='The timestamp when the intervention entry was created.', example='1536690285'),
      relevance?: map[string]any(name='relevance', description='The content of an intervention entry for category prediction. The field value consists of key-value pairs. The key in a key-value pair indicates the ID of the category. The value in a key-value pair indicates the relevance to the category. A value of 0 indicates irrelevant. A value of 1 indicates slightly relevant. A value of 2 indicates relevant. Example: {"2":1, "100":0}', example='{                 "100": "0",                 "200": "2"             }'),
      status?: string(name='status', description='The status of the intervention entry. Valid value:

*   ACTIVE: The intervention entry takes effect.', example='ACTIVE'),
      tokens?: [ 
        {
          order?: int32(name='order', description='The sequence number.', example='1'),
          tag?: string(name='tag', description='The internal name of the identified entity type. Valid values:

*   brand
*   category
*   material
*   element
*   style
*   color
*   function
*   scenario
*   people
*   season
*   model
*   region
*   name
*   adjective
*   category-modifier
*   size
*   quality
*   suit
*   new-release
*   series
*   marketing
*   entertainment
*   organization
*   movie
*   game
*   number
*   unit
*   common
*   new-word
*   proper-noun
*   symbol
*   prefix
*   suffix
*   gift
*   negative
*   agent', example='category'),
          tagLabel?: string(name='tagLabel', description='The description of the internal name of the identified entity type.', example='category'),
          token?: string(name='token', description='The entity.', example='category'),
        }
      ](name='tokens', description='The content of the intervention entry for term weight analysis.'),
      updated?: long(name='updated', description='The timestamp when the intervention entry was last updated.', example='1537348987'),
      word?: string(name='word', description='The intervention entry.', example='\\\\u8fc7\\\\u513f'),
    }
  ](name='result', description='The information about intervention entries.

For more information, see [InterventionDictionaryEntry](https://help.aliyun.com/document_detail/173606.html).'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='8'),
}

model ListInterventionDictionaryEntriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInterventionDictionaryEntriesResponseBody(name='body'),
}

/**
 * @summary Queries the intervention entries in an intervention dictionary.
 *
 * @param request ListInterventionDictionaryEntriesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInterventionDictionaryEntriesResponse
 */
@context("listInterventionDictionaryEntriesWithContext")
async function listInterventionDictionaryEntriesWithOptions(name: string, request: ListInterventionDictionaryEntriesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListInterventionDictionaryEntriesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.word)) {
    query['word'] = request.word;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListInterventionDictionaryEntries',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/intervention-dictionaries/${$URL.percentEncode(name)}/entries`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the intervention entries in an intervention dictionary.
 *
 * @param request ListInterventionDictionaryEntriesRequest
 * @return ListInterventionDictionaryEntriesResponse
 */
async function listInterventionDictionaryEntries(name: string, request: ListInterventionDictionaryEntriesRequest): ListInterventionDictionaryEntriesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listInterventionDictionaryEntriesWithOptions(name, request, headers, runtime);
}

model ListInterventionDictionaryNerResultsRequest {
  query?: string(name='query', description='Query keywords.

This parameter is required.', example='"hello world"'),
}

model ListInterventionDictionaryNerResultsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='8F780CA8-D4D4-2FFE-B8AC-42040822C554'),
  result?: [ 
    {
      order?: int32(name='order', description='The sequence number.', example='1'),
      tag?: string(name='tag', description='The internal name of the identified entity type. Valid values:

*   brand
*   category
*   material
*   element
*   style
*   color
*   function
*   scenario
*   people
*   season
*   model
*   region
*   name
*   adjective
*   category-modifier
*   size
*   quality
*   suit
*   new-release
*   series
*   marketing
*   entertainment
*   organization
*   movie
*   game
*   number
*   unit
*   common
*   new-word
*   proper-noun
*   symbol
*   prefix
*   suffix
*   gift
*   negative
*   agent', example='category'),
      tagLabel?: string(name='tagLabel', description='The description of the internal name of the identified entity type.', example='category'),
      token?: string(name='token', description='The entity.', example='eaa73f35-007a-4be7-88c7-37dca4a04ab7'),
    }
  ](name='result', description='The NER result.

For more information, see [InterventionDictionaryEntry](https://help.aliyun.com/document_detail/173606.html).'),
}

model ListInterventionDictionaryNerResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInterventionDictionaryNerResultsResponseBody(name='body'),
}

/**
 * @summary 获取实体识别结果
 *
 * @param request ListInterventionDictionaryNerResultsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInterventionDictionaryNerResultsResponse
 */
@context("listInterventionDictionaryNerResultsWithContext")
async function listInterventionDictionaryNerResultsWithOptions(name: string, request: ListInterventionDictionaryNerResultsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListInterventionDictionaryNerResultsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.query)) {
    query['query'] = request.query;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListInterventionDictionaryNerResults',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/intervention-dictionaries/${$URL.percentEncode(name)}/ner-results`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取实体识别结果
 *
 * @param request ListInterventionDictionaryNerResultsRequest
 * @return ListInterventionDictionaryNerResultsResponse
 */
async function listInterventionDictionaryNerResults(name: string, request: ListInterventionDictionaryNerResultsRequest): ListInterventionDictionaryNerResultsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listInterventionDictionaryNerResultsWithOptions(name, request, headers, runtime);
}

model ListInterventionDictionaryRelatedEntitiesResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [  map[string]any ](name='result', description='The returned results.'),
}

model ListInterventionDictionaryRelatedEntitiesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInterventionDictionaryRelatedEntitiesResponseBody(name='body'),
}

/**
 * @summary Queries the resources that are associated with an intervention dictionary. If the intervention dictionary is referenced by query analysis rules, this operation returns all applications that use the intervention dictionary and the information about the query analysis rules.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInterventionDictionaryRelatedEntitiesResponse
 */
@context("listInterventionDictionaryRelatedEntitiesWithContext")
async function listInterventionDictionaryRelatedEntitiesWithOptions(name: string, headers: map[string]string, runtime: $RuntimeOptions): ListInterventionDictionaryRelatedEntitiesResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ListInterventionDictionaryRelatedEntities',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/intervention-dictionaries/${$URL.percentEncode(name)}/related`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the resources that are associated with an intervention dictionary. If the intervention dictionary is referenced by query analysis rules, this operation returns all applications that use the intervention dictionary and the information about the query analysis rules.
 *
 * @return ListInterventionDictionaryRelatedEntitiesResponse
 */
async function listInterventionDictionaryRelatedEntities(name: string): ListInterventionDictionaryRelatedEntitiesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listInterventionDictionaryRelatedEntitiesWithOptions(name, headers, runtime);
}

model ListProceedingsRequest {
  filterFinished?: boolean(name='filterFinished', description='Specifies whether the filtering is complete.', example='true'),
}

model ListProceedingsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='F5099063-6B86-F398-D843-905F9EFB683A'),
}

model ListProceedingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProceedingsResponseBody(name='body'),
}

/**
 * @summary 查看当前的处理流
 *
 * @param request ListProceedingsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListProceedingsResponse
 */
@context("listProceedingsWithContext")
async function listProceedingsWithOptions(appGroupIdentity: string, request: ListProceedingsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListProceedingsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.filterFinished)) {
    query['filterFinished'] = request.filterFinished;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListProceedings',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/proceedings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查看当前的处理流
 *
 * @param request ListProceedingsRequest
 * @return ListProceedingsResponse
 */
async function listProceedings(appGroupIdentity: string, request: ListProceedingsRequest): ListProceedingsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listProceedingsWithOptions(appGroupIdentity, request, headers, runtime);
}

model ListQueryProcessorAnalyzerResultsRequest {
  text?: string(name='text', description='The text to be tested.

This parameter is required.', example='"abcde"'),
}

model ListQueryProcessorAnalyzerResultsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='98724351-D6B2-5D8A-B089-7FFD1821A7E9'),
  result?: map[string]any(name='result', description='The data returned.', example='{}'),
}

model ListQueryProcessorAnalyzerResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueryProcessorAnalyzerResultsResponseBody(name='body'),
}

/**
 * @summary Queries the results of a query analysis test. This API operation is available only to existing applications of OpenSearch Open Source Compatible Edition.
 *
 * @param request ListQueryProcessorAnalyzerResultsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQueryProcessorAnalyzerResultsResponse
 */
@context("listQueryProcessorAnalyzerResultsWithContext")
async function listQueryProcessorAnalyzerResultsWithOptions(appGroupIdentity: string, appId: string, name: string, request: ListQueryProcessorAnalyzerResultsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListQueryProcessorAnalyzerResultsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.text)) {
    query['text'] = request.text;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListQueryProcessorAnalyzerResults',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/query-processors/${$URL.percentEncode(name)}/analyze`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the results of a query analysis test. This API operation is available only to existing applications of OpenSearch Open Source Compatible Edition.
 *
 * @param request ListQueryProcessorAnalyzerResultsRequest
 * @return ListQueryProcessorAnalyzerResultsResponse
 */
async function listQueryProcessorAnalyzerResults(appGroupIdentity: string, appId: string, name: string, request: ListQueryProcessorAnalyzerResultsRequest): ListQueryProcessorAnalyzerResultsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listQueryProcessorAnalyzerResultsWithOptions(appGroupIdentity, appId, name, request, headers, runtime);
}

model ListQueryProcessorNersRequest {
  domain?: string(name='domain', description='The type of the industry.

*   ECOMMERCE', example='ECOMMERCE'),
}

model ListQueryProcessorNersResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      label?: string(name='label', description='The name of the entity type.', example='brand'),
      order?: int32(name='order', description='The priority of an entity type among entity types that have the same priority level. A smaller value indicates a higher priority. Default value: 0.', example='1'),
      priority?: string(name='priority', description='The priority level of the entity type. Valid values:

*   HIGH
*   MIDDLE
*   LOW', example='HIGH'),
      tag?: string(name='tag', description='The internal name of the entity type.', example='brand'),
    }
  ](name='result', description='The priority settings of entity types.

For more information, see [Priority settings of entity types](https://help.aliyun.com/document_detail/173616.html).'),
}

model ListQueryProcessorNersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueryProcessorNersResponseBody(name='body'),
}

/**
 * @summary Queries the recommended priority settings of entity types for named entity recognition (NER).
 *
 * @param request ListQueryProcessorNersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQueryProcessorNersResponse
 */
@context("listQueryProcessorNersWithContext")
async function listQueryProcessorNersWithOptions(request: ListQueryProcessorNersRequest, headers: map[string]string, runtime: $RuntimeOptions): ListQueryProcessorNersResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.domain)) {
    query['domain'] = request.domain;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListQueryProcessorNers',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/query-processor/ner/default-priorities`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the recommended priority settings of entity types for named entity recognition (NER).
 *
 * @param request ListQueryProcessorNersRequest
 * @return ListQueryProcessorNersResponse
 */
async function listQueryProcessorNers(request: ListQueryProcessorNersRequest): ListQueryProcessorNersResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listQueryProcessorNersWithOptions(request, headers, runtime);
}

model ListQueryProcessorsRequest {
  isActive?: int32(name='isActive', description='The scope of query analysis rules to be queried. Default value: 0. Valid values:

*   0: queries all query analysis rules.
*   1: queries the default query analysis rules.
*   2: queries the query analysis rules that are not the default rules.', example='0'),
}

model ListQueryProcessorsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      active?: boolean(name='active', description='Indicates whether the query analysis rule is a default rule.', example='true'),
      created?: int32(name='created', description='The time when the query analysis rule was created.', example='1587398402'),
      domain?: string(name='domain', description='The type of the industry to which the query analysis rule is applied. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='GENERAL'),
      indexes?: [ string ](name='indexes', description='The indexes to which the query analysis rule is applied.'),
      name?: string(name='name', description='The name of the query analysis rule.', example='ner'),
      processors?: [  map[string]any ](name='processors', description='The features that are used in the query analysis rule.'),
      updated?: int32(name='updated', description='The time when the query analysis rule was last modified.', example='1587398402'),
    }
  ](name='result', description='The information about the query analysis rule.

For more information, see [QueryProcessor](https://help.aliyun.com/document_detail/170014.html).'),
}

model ListQueryProcessorsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueryProcessorsResponseBody(name='body'),
}

/**
 * @summary Queries a list of query analysis rules that are configured for a version of an OpenSearch application.
 *
 * @param request ListQueryProcessorsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQueryProcessorsResponse
 */
@context("listQueryProcessorsWithContext")
async function listQueryProcessorsWithOptions(appGroupIdentity: string, appId: string, request: ListQueryProcessorsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListQueryProcessorsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.isActive)) {
    query['isActive'] = request.isActive;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListQueryProcessors',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/query-processors`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of query analysis rules that are configured for a version of an OpenSearch application.
 *
 * @param request ListQueryProcessorsRequest
 * @return ListQueryProcessorsResponse
 */
async function listQueryProcessors(appGroupIdentity: string, appId: string, request: ListQueryProcessorsRequest): ListQueryProcessorsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listQueryProcessorsWithOptions(appGroupIdentity, appId, request, headers, runtime);
}

model ListQuotaReviewTasksRequest {
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries to return on each page. Default value: 10.', example='10'),
}

model ListQuotaReviewTasksResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='"3351A21F-705B-508C-9450-DA65A681547F"'),
  result?: [ 
    {
      appGroupId?: int32(name='appGroupId', description='The application ID.', example='120123456'),
      appGroupName?: string(name='appGroupName', description='The application name.', example='"td_test_os"'),
      appGroupType?: string(name='appGroupType', description='The application type.', example='"standard"'),
      approved?: boolean(name='approved', description='Indicates whether the ticket is approved.', example='true'),
      available?: boolean(name='available', description='Indicates whether the application is available.', example='true'),
      gmtCreate?: string(name='gmtCreate', description='The time when the ticket was created.', example='"2020-04-08T08:29:45+0000"'),
      gmtModified?: string(name='gmtModified', description='The time when the ticket was last updated.', example='"2020-04-08T08:36:36+0000"'),
      id?: int32(name='id', description='The ticket ID.', example='142'),
      memo?: string(name='memo', description='The remarks.', example='null'),
      newComputeResource?: int32(name='newComputeResource', description='The computing resource quota that is applied for.', example='6000'),
      newSocSize?: int32(name='newSocSize', description='The storage capacity quota that is applied for.', example='1100'),
      newSpec?: string(name='newSpec', description='The application specifications that are applied for.', example='"opensearch.private.common"'),
      oldComputeResource?: int32(name='oldComputeResource', description='The original quota of computing resources.', example='500'),
      oldDocSize?: int32(name='oldDocSize', description='The original quota of storage capacity.', example='900'),
      oldSpec?: string(name='oldSpec', description='The original specifications of the application.', example='"opensearch.private.common"'),
      pending?: boolean(name='pending', description='Indicates whether the ticket is pending.', example='false'),
    }
  ](name='result', description='The information about the tickets. For more information, see [QuotaReviewTask](https://help.aliyun.com/document_detail/173609.html).', example='[]'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='500'),
}

model ListQuotaReviewTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQuotaReviewTasksResponseBody(name='body'),
}

/**
 * @summary Queries tickets that are submitted to apply for quotas for an OpenSearch application.
 *
 * @param request ListQuotaReviewTasksRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQuotaReviewTasksResponse
 */
@context("listQuotaReviewTasksWithContext")
async function listQuotaReviewTasksWithOptions(appGroupIdentity: string, request: ListQuotaReviewTasksRequest, headers: map[string]string, runtime: $RuntimeOptions): ListQuotaReviewTasksResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListQuotaReviewTasks',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/quota-review-tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries tickets that are submitted to apply for quotas for an OpenSearch application.
 *
 * @param request ListQuotaReviewTasksRequest
 * @return ListQuotaReviewTasksResponse
 */
async function listQuotaReviewTasks(appGroupIdentity: string, request: ListQuotaReviewTasksRequest): ListQuotaReviewTasksResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listQuotaReviewTasksWithOptions(appGroupIdentity, request, headers, runtime);
}

model ListScheduledTasksRequest {
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
  type?: string(name='type', description='The scheduled task type. Valid values:

*   wipe: data cleaning.
*   fork: reindexing.
*   check-status: application status check.
*   index: reindexing.', example='wipe'),
}

model ListScheduledTasksResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [  map[string]any ](name='result'),
  totalCount?: long(name='totalCount', description='The total number of entries returned.', example='1'),
}

model ListScheduledTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListScheduledTasksResponseBody(name='body'),
}

/**
 * @summary Queries a list of scheduled tasks of an OpenSearch application.
 *
 * @param request ListScheduledTasksRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListScheduledTasksResponse
 */
@context("listScheduledTasksWithContext")
async function listScheduledTasksWithOptions(appGroupIdentity: string, request: ListScheduledTasksRequest, headers: map[string]string, runtime: $RuntimeOptions): ListScheduledTasksResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListScheduledTasks',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scheduled-tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of scheduled tasks of an OpenSearch application.
 *
 * @param request ListScheduledTasksRequest
 * @return ListScheduledTasksResponse
 */
async function listScheduledTasks(appGroupIdentity: string, request: ListScheduledTasksRequest): ListScheduledTasksResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listScheduledTasksWithOptions(appGroupIdentity, request, headers, runtime);
}

model ListSearchStrategiesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='9C6351F5-2E2E-5249-888B-88A74E1B8A65'),
}

model ListSearchStrategiesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSearchStrategiesResponseBody(name='body'),
}

/**
 * @summary Queries the details of query policies.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSearchStrategiesResponse
 */
@context("listSearchStrategiesWithContext")
async function listSearchStrategiesWithOptions(appGroupIdentity: string, appId: string, headers: map[string]string, runtime: $RuntimeOptions): ListSearchStrategiesResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ListSearchStrategies',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/search-strategies`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of query policies.
 *
 * @return ListSearchStrategiesResponse
 */
async function listSearchStrategies(appGroupIdentity: string, appId: string): ListSearchStrategiesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listSearchStrategiesWithOptions(appGroupIdentity, appId, headers, runtime);
}

model ListSecondRanksResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='false'),
      created?: int32(name='created', description='The time when the expression was created.', example='0'),
      description?: string(name='description', description='Description', example='""'),
      id?: string(name='id', description='The expression ID. This parameter is displayed only in the response.', example='890473'),
      isDefault?: string(name='isDefault', description='Indicates whether the expression is the default one. This parameter is displayed only in the response. Valid values:

*   true: the expression is the default one.
*   false: the expression is not the default one.', example='false'),
      isSys?: string(name='isSys', description='Indicates whether the expression is a system expression. This parameter is displayed only in the response. Valid values:

*   true: The expression is a system expression.
*   false:The expression is not a system expression', example='true'),
      meta?: string(name='meta', description='The content of the fine sort expression. You can define an expression that consists of fields, feature functions, and mathematical functions to implement complex sort logic.', example='random()+now()'),
      name?: string(name='name', description='Parameter', example='tests'),
      updated?: int32(name='updated', description='The time when the expression was updated.', example='1587052801'),
    }
  ](name='result', description='The information about the fine sort expression.

For more information, see [SecondRank](https://help.aliyun.com/document_detail/170008.html).'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='1'),
}

model ListSecondRanksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSecondRanksResponseBody(name='body'),
}

/**
 * @summary Queries the fine sort expressions that are configured for a version of an OpenSearch application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSecondRanksResponse
 */
@context("listSecondRanksWithContext")
async function listSecondRanksWithOptions(appGroupIdentity: string, appId: string, headers: map[string]string, runtime: $RuntimeOptions): ListSecondRanksResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ListSecondRanks',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/second-ranks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the fine sort expressions that are configured for a version of an OpenSearch application.
 *
 * @return ListSecondRanksResponse
 */
async function listSecondRanks(appGroupIdentity: string, appId: string): ListSecondRanksResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listSecondRanksWithOptions(appGroupIdentity, appId, headers, runtime);
}

model ListSlowQueryCategoriesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='4406F40B-A0A2-9D5D-531F-3B6936567584'),
  result?: {
    analyzeStatus?: string(name='analyzeStatus', description='The status of the analysis. Valid values:

*   PENDING: preparing
*   SUCCESS: succeeded
*   RUNNING: running
*   FAILED: failed
*   N/A: unknown', example='"PENDING"'),
    end?: int32(name='end', description='The timestamp that indicates the end of the time range to query.', example='1589990340'),
    start?: int32(name='start', description='The timestamp that indicates the beginning of the time range to query.', example='1589986800'),
  }(name='result', description='The data returned.'),
}

model ListSlowQueryCategoriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSlowQueryCategoriesResponseBody(name='body'),
}

/**
 * @summary Queries the suggestions that are provided by Optimization Master for slow queries.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSlowQueryCategoriesResponse
 */
@context("listSlowQueryCategoriesWithContext")
async function listSlowQueryCategoriesWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: $RuntimeOptions): ListSlowQueryCategoriesResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ListSlowQueryCategories',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/optimizers/slow-query/categories`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the suggestions that are provided by Optimization Master for slow queries.
 *
 * @return ListSlowQueryCategoriesResponse
 */
async function listSlowQueryCategories(appGroupIdentity: string): ListSlowQueryCategoriesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listSlowQueryCategoriesWithOptions(appGroupIdentity, headers, runtime);
}

model ListSlowQueryQueriesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='EB250CA0-ACFD-C5DE-17CD-01445BFE8AE5'),
  result?: {
    appQuery?: string(name='appQuery', description='The content of the optimization suggestion for the query.', example='no data'),
    end?: int32(name='end', description='The end of the time range that was queried.', example='1589990340'),
    index?: int32(name='index', description='The ID of the optimization suggestion.', example='0'),
    start?: int32(name='start', description='The beginning of the time range that was queried.', example='1589986800'),
  }(name='result', description='The return result.'),
}

model ListSlowQueryQueriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSlowQueryQueriesResponseBody(name='body'),
}

/**
 * @summary 列出优化大师慢查询Query清单
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSlowQueryQueriesResponse
 */
@context("listSlowQueryQueriesWithContext")
async function listSlowQueryQueriesWithOptions(appGroupIdentity: string, categoryIndex: string, headers: map[string]string, runtime: $RuntimeOptions): ListSlowQueryQueriesResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ListSlowQueryQueries',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/optimizers/slow-query/categories/${$URL.percentEncode(categoryIndex)}/queries`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 列出优化大师慢查询Query清单
 *
 * @return ListSlowQueryQueriesResponse
 */
async function listSlowQueryQueries(appGroupIdentity: string, categoryIndex: string): ListSlowQueryQueriesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listSlowQueryQueriesWithOptions(appGroupIdentity, categoryIndex, headers, runtime);
}

model ListSortExpressionsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ 
    {
      active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
      created?: int32(name='created', description='The timestamp when the sort expression was created.', example='1655793690'),
      description?: string(name='description', description='The description of the sort expression.', example='""'),
      name?: string(name='name', description='The name of the sort expression.', example='default'),
      updated?: int32(name='updated', description='The timestamp when the sort expression was updated.', example='1655793690'),
    }
  ](name='result', description='The information about the rough sort or fine sort expressions that are returned.

For more information, see [FirstRank](https://help.aliyun.com/document_detail/170007.html) and [SecondRank](https://help.aliyun.com/document_detail/170008.html).'),
}

model ListSortExpressionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSortExpressionsResponseBody(name='body'),
}

/**
 * @summary Queries a list of sort expressions that are configured for a version of an OpenSearch application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSortExpressionsResponse
 */
@context("listSortExpressionsWithContext")
async function listSortExpressionsWithOptions(appGroupIdentity: string, appId: string, headers: map[string]string, runtime: $RuntimeOptions): ListSortExpressionsResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ListSortExpressions',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/sort-expressions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of sort expressions that are configured for a version of an OpenSearch application.
 *
 * @return ListSortExpressionsResponse
 */
async function listSortExpressions(appGroupIdentity: string, appId: string): ListSortExpressionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listSortExpressionsWithOptions(appGroupIdentity, appId, headers, runtime);
}

model ListSortScriptsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
  result?: [ 
    {
      createTime?: string(name='createTime', description='The time when the script was created.', example='2020-04-02 20:21:14'),
      modifyTime?: string(name='modifyTime', description='The time when the script was last modified.', example='2020-04-02 21:21:14'),
      scope?: string(name='scope', description='The sort phase to which the script applies.', example='second_rank'),
      scriptName?: string(name='scriptName', description='The name of the script.', example='test'),
      status?: string(name='status', description='The status of the script. Valid values:

*   configurable: The script is created, but no script files are uploaded.
*   not compiled: The script is not compiled.
*   compile failed: The compilation of the script failed.
*   compile successful: The script is compiled.
*   released: The script is published.', example='released'),
      type?: string(name='type', description='The type of the script.', example='cava_script'),
    }
  ](name='result', description='The scripts.'),
}

model ListSortScriptsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSortScriptsResponseBody(name='body'),
}

/**
 * @summary Queries all sort scripts of an application version.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSortScriptsResponse
 */
@context("listSortScriptsWithContext")
async function listSortScriptsWithOptions(appGroupIdentity: string, appVersionId: string, headers: map[string]string, runtime: $RuntimeOptions): ListSortScriptsResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ListSortScripts',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appVersionId)}/sort-scripts`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all sort scripts of an application version.
 *
 * @return ListSortScriptsResponse
 */
async function listSortScripts(appGroupIdentity: string, appVersionId: string): ListSortScriptsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listSortScriptsWithOptions(appGroupIdentity, appVersionId, headers, runtime);
}

model ListStatisticLogsRequest {
  columns?: string(name='columns', description='The fields to query. Format: columns=wordsTopPv.

For more information, see [Metrics in statistical reports](https://help.aliyun.com/document_detail/187665.html).', example='wordsTopPv'),
  distinct?: boolean(name='distinct', description='Specifies whether to use the distinct clause.', example='true'),
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
  query?: string(name='query', description='The content of the query clause.', example='"default:\\\\"OpenSearch\\\\""'),
  sortBy?: string(name='sortBy', description='The content of the sort clause.', example='"-id"'),
  startTime?: int32(name='startTime', description='The beginning of the time range to query. The default value is the timestamp of 00:00:00 on the current day.', example='1582214400'),
  stopTime?: int32(name='stopTime', description='The end of the time range to query. The default value is the timestamp of 24:00:00 on the current day.', example='1682222400'),
}

model ListStatisticLogsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='F76ACE3D-E510-EE2C-B7B1-39B3136A61EE'),
  result?: [  map[string]any ](name='result', description='The returned result. For more information, see

*   [Parameters of hotwords rankings](https://help.aliyun.com/document_detail/421248.html).', example='[]'),
  totalCount?: long(name='totalCount', description='The total number of entries returned.', example='1'),
}

model ListStatisticLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListStatisticLogsResponseBody(name='body'),
}

/**
 * @summary Queries log statistics, such as application error logs, hotword rankings, and slow query logs.
 *
 * @param request ListStatisticLogsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListStatisticLogsResponse
 */
@context("listStatisticLogsWithContext")
async function listStatisticLogsWithOptions(appGroupIdentity: string, moduleName: string, request: ListStatisticLogsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListStatisticLogsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.columns)) {
    query['columns'] = request.columns;
  }
  if (!$isNull(request.distinct)) {
    query['distinct'] = request.distinct;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.query)) {
    query['query'] = request.query;
  }
  if (!$isNull(request.sortBy)) {
    query['sortBy'] = request.sortBy;
  }
  if (!$isNull(request.startTime)) {
    query['startTime'] = request.startTime;
  }
  if (!$isNull(request.stopTime)) {
    query['stopTime'] = request.stopTime;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListStatisticLogs',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/statistic-logs/${$URL.percentEncode(moduleName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries log statistics, such as application error logs, hotword rankings, and slow query logs.
 *
 * @param request ListStatisticLogsRequest
 * @return ListStatisticLogsResponse
 */
async function listStatisticLogs(appGroupIdentity: string, moduleName: string, request: ListStatisticLogsRequest): ListStatisticLogsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listStatisticLogsWithOptions(appGroupIdentity, moduleName, request, headers, runtime);
}

model ListStatisticReportRequest {
  columns?: string(name='columns', description='The fields to query. Set this parameter in the format of columns="pv,uv,ipv". For more information, see [Metrics of statistical reports](https://help.aliyun.com/document_detail/187665.html).', example='pv,uv'),
  endTime?: int32(name='endTime', description='The end timestamp of the query. By default, the end time is the current time. Unit: seconds.', example='1582646399'),
  pageNumber?: int32(name='pageNumber', description='The page number.

Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
  query?: string(name='query', description='The query conditions. Set this parameter in the format of k1:v1,k2:v2. Valid values:

*   experimentSerialNumber: the globally unique sequence number of the test
*   sceneTag: the tag of the test scenario
*   bizType: the type of the business
*   modelId: the ID of the algorithm model', example='bizType:test,sceneTag:myTag'),
  startTime?: int32(name='startTime', description='The start timestamp of the query. Unit: seconds.', example='1582214400'),
}

model ListStatisticReportResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='F65C8BB2-C14F-5983-888B-41C4E082D3BC'),
  result?: [  map[string]any ](name='result', description='The statistical reports. Valid values:

*   For more information about the metrics in data quality reports, see the Upload behavioral data section of [Data collection 2.0](https://help.aliyun.com/document_detail/131547.html).
*   For more information about the metrics in application and A/B test reports, see the Core metrics section of [Metrics of statistical reports](https://help.aliyun.com/document_detail/187665.html).
*   For more information about the metrics in query analysis reports, see the Query analysis metrics section of [Metrics of statistical reports](https://help.aliyun.com/document_detail/187665.html).', example='[]'),
  totalCount?: long(name='totalCount', description='The total number of entries returned.', example='43'),
}

model ListStatisticReportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListStatisticReportResponseBody(name='body'),
}

/**
 * @summary Queries statistical reports, such as application reports, drop-down suggestion reports, hotword shading reports, A/B test reports, and data quality reports.
 *
 * @param request ListStatisticReportRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListStatisticReportResponse
 */
@context("listStatisticReportWithContext")
async function listStatisticReportWithOptions(appGroupIdentity: string, moduleName: string, request: ListStatisticReportRequest, headers: map[string]string, runtime: $RuntimeOptions): ListStatisticReportResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.columns)) {
    query['columns'] = request.columns;
  }
  if (!$isNull(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.query)) {
    query['query'] = request.query;
  }
  if (!$isNull(request.startTime)) {
    query['startTime'] = request.startTime;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListStatisticReport',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/statistic-report/${$URL.percentEncode(moduleName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries statistical reports, such as application reports, drop-down suggestion reports, hotword shading reports, A/B test reports, and data quality reports.
 *
 * @param request ListStatisticReportRequest
 * @return ListStatisticReportResponse
 */
async function listStatisticReport(appGroupIdentity: string, moduleName: string, request: ListStatisticReportRequest): ListStatisticReportResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listStatisticReportWithOptions(appGroupIdentity, moduleName, request, headers, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='nextToken', description='The token that is used to retrieve the next page.', example='60'),
  resourceId?: [ string ](name='resourceId', description='The resource IDs. You can specify a maximum number of 50 resource IDs.'),
  resourceType?: string(name='resourceType', description='The resource type.

This parameter is required.', example='BIGDATA'),
  tag?: [ 
    {
      key?: string(name='key', description='The key of the tag.', example='bm'),
      value?: string(name='value', description='The value of the tag.', example='Uefi'),
    }
  ](name='tag', description='The tags. You can specify a maximum number of 20 tags.'),
}

model ListTagResourcesShrinkRequest {
  nextToken?: string(name='nextToken', description='The token that is used to retrieve the next page.', example='60'),
  resourceIdShrink?: string(name='resourceId', description='The resource IDs. You can specify a maximum number of 50 resource IDs.'),
  resourceType?: string(name='resourceType', description='The resource type.

This parameter is required.', example='BIGDATA'),
  tagShrink?: string(name='tag', description='The tags. You can specify a maximum number of 20 tags.'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='nextToken', description='The token that is used to retrieve the next page.', example='20'),
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ 
    {
      resourceId?: string(name='resourceId', description='The ID of the resource.', example='54041'),
      resourceType?: string(name='resourceType', description='The resource type.', example='hostGroup'),
      tagKey?: string(name='tagKey', description='The key of the tag.', example='GENIE_FUNCTION'),
      tagValue?: string(name='tagValue', description='The value of the tag.', example='ALLOW'),
    }
  ](name='result', description='The resources.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
 * @summary Queries tagged resources.
 *
 * @param tmpReq ListTagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
@context("listTagResourcesWithContext")
async function listTagResourcesWithOptions(tmpReq: ListTagResourcesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListTagResourcesResponse {
  tmpReq.validate();
  var request = new ListTagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.resourceId)) {
    request.resourceIdShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceId, 'resourceId', 'json');
  }
  if (!$isNull(tmpReq.tag)) {
    request.tagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tag, 'tag', 'json');
  }
  var query : map[string]any = {};
  if (!$isNull(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!$isNull(request.resourceIdShrink)) {
    query['resourceId'] = request.resourceIdShrink;
  }
  if (!$isNull(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }
  if (!$isNull(request.tagShrink)) {
    query['tag'] = request.tagShrink;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListTagResources',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/resource-tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries tagged resources.
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

model ListUserAnalyzerEntriesRequest {
  pageNumber?: int32(name='pageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
  word?: string(name='word', description='The key to be used to query entries.', example='kevintest'),
}

model ListUserAnalyzerEntriesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='516A02B7-2167-8D92-12D0-B639A2A0F3C5'),
  result?: map[string]any(name='result', description='The entries of the custom analyzer. For more information, see [UserAnalyzerEntry](https://www.alibabacloud.com/help/en/open-search/industry-algorithm-edition/useranalyzerentry).', example='[]'),
}

model ListUserAnalyzerEntriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserAnalyzerEntriesResponseBody(name='body'),
}

/**
 * @summary Queries the entries of a custom analyzer.
 *
 * @param request ListUserAnalyzerEntriesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUserAnalyzerEntriesResponse
 */
@context("listUserAnalyzerEntriesWithContext")
async function listUserAnalyzerEntriesWithOptions(name: string, request: ListUserAnalyzerEntriesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListUserAnalyzerEntriesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.word)) {
    query['word'] = request.word;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListUserAnalyzerEntries',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/user-analyzers/${$URL.percentEncode(name)}/entries`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the entries of a custom analyzer.
 *
 * @param request ListUserAnalyzerEntriesRequest
 * @return ListUserAnalyzerEntriesResponse
 */
async function listUserAnalyzerEntries(name: string, request: ListUserAnalyzerEntriesRequest): ListUserAnalyzerEntriesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listUserAnalyzerEntriesWithOptions(name, request, headers, runtime);
}

model ListUserAnalyzersRequest {
  pageNumber?: int32(name='pageNumber', description='The number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries to return on each page. Default value: 10.', example='10'),
}

model ListUserAnalyzersResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ 
    {
      available?: boolean(name='available', description='Indicates whether the application is available.', example='false'),
      business?: string(name='business', description='The basic analyzer. Valid values:

*   chn_standard: [a common analyzer in Chinese](https://help.aliyun.com/document_detail/179424.html)
*   chn_scene_name: an analyzer for person names in Chinese
*   chn_ecommerce: [an analyzer for E-commerce in Chinese](https://help.aliyun.com/document_detail/179424.html)
*   chn_it_content: [an analyzer for IT content in Chinese](https://help.aliyun.com/document_detail/179424.html)
*   en_min: a small-granularity analyzer in English
*   th_standard: a common analyzer in Thai
*   th_ecommerce: an analyzer for E-commerce in Thai
*   vn_standard: a common analyzer in Vietnamese
*   chn_community_it: an analyzer for IT community content in Chinese
*   chn_ecommerce_general: a common analyzer for the E-commerce industry in Chinese
*   chn_esports_general: a common analyzer for the gaming industry in Chinese
*   chn_edu_question: an analyzer for question search of the education industry in Chinese', example='chn_standard'),
      created?: int32(name='created', description='The timestamp when the application was created.', example='1588054131'),
      dicts?: [ 
        {
          available?: boolean(name='available', description='Indicates whether the application is available.', example='false'),
          created?: int32(name='created', description='The timestamp when the application was created.', example='1588054131'),
          entriesCount?: int32(name='entriesCount', description='The number of intervention entries.', example='-1'),
          entriesLimit?: int32(name='entriesLimit', description='The maximum number of intervention entries that can be created in the dictionary.', example='4'),
          id?: string(name='id', description='The ID of the dictionary.', example='123'),
          type?: string(name='type', description='The type. Valid value:

*   segment', example='segment'),
          updated?: int32(name='updated', description='The timestamp when the application was last updated.', example='1588054131'),
        }
      ](name='dicts', description='The dictionaries that are used by the custom analyzer.

For more information, see [UserDict](https://help.aliyun.com/document_detail/178933.html).'),
      id?: string(name='id', description='The ID of the custom analyzer.', example='1234'),
      name?: string(name='name', description='The name of the custom analyzer.', example='kevin_test2'),
      updated?: int32(name='updated', description='The timestamp when the application was last updated.', example='1588054131'),
    }
  ](name='result', description='The custom analyzer.

For more information, see [UserAnalyzer](https://help.aliyun.com/document_detail/178934.html).'),
  totalCount?: int32(name='totalCount', description='The total number.', example='1'),
}

model ListUserAnalyzersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserAnalyzersResponseBody(name='body'),
}

/**
 * @summary Queries the custom analyzers that belong to the current account.
 *
 * @param request ListUserAnalyzersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUserAnalyzersResponse
 */
@context("listUserAnalyzersWithContext")
async function listUserAnalyzersWithOptions(request: ListUserAnalyzersRequest, headers: map[string]string, runtime: $RuntimeOptions): ListUserAnalyzersResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListUserAnalyzers',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/user-analyzers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the custom analyzers that belong to the current account.
 *
 * @param request ListUserAnalyzersRequest
 * @return ListUserAnalyzersResponse
 */
async function listUserAnalyzers(request: ListUserAnalyzersRequest): ListUserAnalyzersResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listUserAnalyzersWithOptions(request, headers, runtime);
}

model ModifyAppGroupRequest {
  currentVersion?: string(name='currentVersion', description='The online version of the application.', example='1223232'),
  description?: string(name='description', description='The description of the application.', example='"test"'),
  domain?: string(name='domain', description='The type of the industry. Valid values:

*   general: general.
*   ecommerce: e-commerce.
*   education: education.
*   esports: electronic sports.
*   community: content community.', example='"ecommerce"'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-****'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to verify the application before modification. Valid values: true and false.', example='true'),
}

model ModifyAppGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    chargeType?: string(name='chargeType', description='The billing method. Valid values:

*   POSTPAY: pay-as-you-go.
*   PREPAY: subscription.', example='POSTPAY'),
    chargingWay?: int32(name='chargingWay', description='The billable item. Valid values:

*   1: computing resources.
*   2: QPS.', example='1'),
    commodityCode?: string(name='commodityCode', description='The code of the commodity.', example='opensearch'),
    created?: int32(name='created', description='The timestamp when the application was created.', example='1590139524'),
    currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='100302903'),
    description?: string(name='description', description='The description of the application.', example='1'),
    domain?: string(name='domain', description='The type of the industry. Valid values:

*   GENERAL: general.
*   ECOMMERCE: e-commerce.
*   IT_CONTENT: IT content.', example='GENERAL'),
    engineType?: string(name='engineType', description='The engine type.', example='ha3'),
    expireOn?: string(name='expireOn', description='The time when the application expired.', example='1'),
    hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval status of the quotas. Valid values:

*   0: normal.
*   1: being approved.', example='0'),
    id?: string(name='id', description='The application ID.', example='100302881'),
    instanceId?: string(name='instanceId', description='The instance ID.', example='10030288'),
    lockMode?: string(name='lockMode', description='The lock status. Valid values:

*   Unlock: The instance is unlocked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
    name?: string(name='name', description='The name of the application.', example='lsh_test_1'),
    produced?: int32(name='produced', description='Indicates whether the order is complete. Valid values:

*   0: The order is in progress.
*   1: The order is complete.', example='1'),
    projectId?: string(name='projectId', description='The name of the A/B test group.', example='1'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing unit (LCU).', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
      spec?: string(name='spec', description='The specifications. Valid values:

*   opensearch.share.junior: basic.
*   opensearch.share.common: shared general-purpose.
*   opensearch.share.compute: shared computing.
*   opensearch.share.storage: shared storage.
*   opensearch.private.common: exclusive general-purpose.
*   opensearch.private.compute: exclusive computing.
*   opensearch.private.storage: exclusive storage.', example='opensearch.share.common'),
    }(name='quota', description='The information about the quotas of the application.', example='{}'),
    resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-acfmoiyerh6nzly'),
    status?: string(name='status', description='The state of the application. Valid values:

*   producing: being produced.
*   review_pending: being approved.
*   config_pending: to be configured.
*   normal: normal.
*   frozen: frozen.', example='normal'),
    switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='1590486386'),
    type?: string(name='type', description='The type of the application. Valid values:

*   standard: a standard edition application.
*   advance: an advanced edition application of an old version. New versions are not supported for this edition.
*   enhanced: an advanced edition application of a new version.', example='enhanced'),
    updated?: int32(name='updated', description='The timestamp when the application was last modified.', example='1590978265'),
  }(name='result', description='Response parameters', example='{}'),
}

model ModifyAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAppGroupResponseBody(name='body'),
}

/**
 * @summary Modifies the properties of an OpenSearch application or sets the online version of an OpenSearch application.
 *
 * @param request ModifyAppGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAppGroupResponse
 */
@context("modifyAppGroupWithContext")
async function modifyAppGroupWithOptions(appGroupIdentity: string, request: ModifyAppGroupRequest, headers: map[string]string, runtime: $RuntimeOptions): ModifyAppGroupResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!$isNull(request.currentVersion)) {
    body['currentVersion'] = request.currentVersion;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.domain)) {
    body['domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyAppGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the properties of an OpenSearch application or sets the online version of an OpenSearch application.
 *
 * @param request ModifyAppGroupRequest
 * @return ModifyAppGroupResponse
 */
async function modifyAppGroup(appGroupIdentity: string, request: ModifyAppGroupRequest): ModifyAppGroupResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyAppGroupWithOptions(appGroupIdentity, request, headers, runtime);
}

model ModifyAppGroupQuotaRequest {
  body?: Quota(name='body', description='The request body.'),
  clientToken?: string(name='clientToken'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to check the validity of input parameters. Default value: false.

Valid values:

*   **true**: checks only the validity of input parameters.
*   **false**: checks the validity of input parameters and creates an attribution configuration.', example='false'),
}

model ModifyAppGroupQuotaResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    chargeType?: string(name='chargeType', description='The billing method. Valid values:

*   POSTPAY: pay-as-you-go.
*   PREPAY: subscription.', example='POSTPAY'),
    chargingWay?: int32(name='chargingWay', description='The billable item. Valid values:

*   1: computing resources.
*   2: queries per second (QPS).', example='1'),
    commodityCode?: string(name='commodityCode', description='The commodity code.', example='opensearch'),
    created?: int32(name='created', description='The timestamp when the application was created.', example='1590139542'),
    currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='100302903'),
    description?: string(name='description', description='The description of the application.', example='1'),
    engineType?: string(name='engineType', description='The engine type.

Valid values:

*   ha3: ha3.', example='ha3'),
    expireOn?: string(name='expireOn', description='The time when the application expired.', example='1'),
    hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval state of the quotas. Valid values:

*   0: The application is in service.
*   1: The quotas are being reviewed.', example='0'),
    id?: string(name='id', description='The application ID.', example='100302881'),
    instanceId?: string(name='instanceId', description='The instance ID.', example='1'),
    lockMode?: string(name='lockMode', description='The lock state. Valid values:

*   Unlock: The instance is unlocked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
    name?: string(name='name', description='The name of the application', example='lsh_test_1'),
    produced?: int32(name='produced', description='Indicates whether the application is created. Valid values:

*   0: The application is being created.
*   1: The application is created.', example='1'),
    projectId?: string(name='projectId', description='The name of the A/B test group.', example='1000'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The computing resources. Unit: logical computing unit (LCU).', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='1'),
      spec?: string(name='spec', description='The specifications. Valid values:

*   opensearch.share.junior: basic.
*   opensearch.share.common: shared general-purpose.
*   opensearch.share.compute: shared computing.
*   opensearch.share.storage: shared storage.
*   opensearch.private.common: exclusive general-purpose.
*   opensearch.private.compute: exclusive computing.
*   opensearch.private.storage: exclusive storage.', example='opensearch.share.common'),
    }(name='quota', description='The information about the quotas of the application.'),
    resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-acfmoiyerh6nzly'),
    status?: string(name='status', description='The state of the application. Valid values:

*   producing: The application is being created.
*   review_pending: The application is being reviewed.
*   config_pending: The application is to be configured.
*   normal: The application is in service.
*   frozen: The application is frozen.', example='normal'),
    switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='1590486386'),
    type?: string(name='type', description='The type of the application. Valid values:

*   standard: a standard edition application.
*   advance: an advanced edition application of an old version. New versions are not supported for this edition.
*   enhanced: an advanced edition application of a new version.', example='enhanced'),
    updated?: int32(name='updated', description='The timestamp when the application was last modified.', example='1590978265'),
  }(name='result', description='The information about the application.'),
}

model ModifyAppGroupQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAppGroupQuotaResponseBody(name='body'),
}

/**
 * @summary Modifies the quotas of an OpenSearch application.
 *
 * @param request ModifyAppGroupQuotaRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAppGroupQuotaResponse
 */
@context("modifyAppGroupQuotaWithContext")
async function modifyAppGroupQuotaWithOptions(appGroupIdentity: string, request: ModifyAppGroupQuotaRequest, headers: map[string]string, runtime: $RuntimeOptions): ModifyAppGroupQuotaResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyAppGroupQuota',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/quota`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the quotas of an OpenSearch application.
 *
 * @param request ModifyAppGroupQuotaRequest
 * @return ModifyAppGroupQuotaResponse
 */
async function modifyAppGroupQuota(appGroupIdentity: string, request: ModifyAppGroupQuotaRequest): ModifyAppGroupQuotaResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyAppGroupQuotaWithOptions(appGroupIdentity, request, headers, runtime);
}

model ModifyFirstRankRequest {
  body?: FirstRank(name='body', description='The request body.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether the request is a dry run.', example='true'),
}

model ModifyFirstRankResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
    description?: string(name='description', description='The description of the rough sort expression.', example='1'),
    meta?: [ 
      {
        arg?: string(name='arg', description='The parameters that are used by a function in the expression.', example='“1 ”'),
        attribute?: string(name='attribute', description='The attribute, feature function, or field to be searched for.', example='static_bm25()'),
        weight?: float(name='weight', description='The weight. Valid values: -100000 to 100000. The value cannot be 0.', example='10'),
      }
    ](name='meta', description='The information about the expression.'),
    name?: string(name='name', description='The name of the expression.', example='default'),
  }(name='result', description='The information about the rough sort expression.'),
}

model ModifyFirstRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyFirstRankResponseBody(name='body'),
}

/**
 * @summary Modifies a rough sort expression for an OpenSearch application. If you set dryRun to true, this operation checks the rough sort expression after the expression is modified. If you do not specify this parameter, false is used by default.
 *
 * @param request ModifyFirstRankRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyFirstRankResponse
 */
@context("modifyFirstRankWithContext")
async function modifyFirstRankWithOptions(appGroupIdentity: string, appId: string, name: string, request: ModifyFirstRankRequest, headers: map[string]string, runtime: $RuntimeOptions): ModifyFirstRankResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyFirstRank',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/first-ranks/${$URL.percentEncode(name)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a rough sort expression for an OpenSearch application. If you set dryRun to true, this operation checks the rough sort expression after the expression is modified. If you do not specify this parameter, false is used by default.
 *
 * @param request ModifyFirstRankRequest
 * @return ModifyFirstRankResponse
 */
async function modifyFirstRank(appGroupIdentity: string, appId: string, name: string, request: ModifyFirstRankRequest): ModifyFirstRankResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyFirstRankWithOptions(appGroupIdentity, appId, name, request, headers, runtime);
}

model ModifyQueryProcessorRequest {
  body?: any(name='body', description='The request parameters.', example='{
    "domain": "GENERAL",
    "category": "",
    "processors": [
        {
            "name": "synonym",
            "useSystemDictionary": true
        },
        {
            "name": "stop_word",
            "useSystemDictionary": true
        }
    ]
}'),
  dryRun?: boolean(name='dryRun', description='Specifies whether the request is a dry run.', example='true'),
}

model ModifyQueryProcessorResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the query analysis rule is a default rule.', example='true'),
    created?: int32(name='created', description='The time when the rule was created.', example='0'),
    domain?: string(name='domain', description='The type of the industry to which the query analysis rule is applied. Valid values:

*   GENERAL
*   ECOMMERCE
*   IT_CONTENT', example='GENERAL'),
    indexes?: [ string ](name='indexes', description='The indexes to which the query analysis rule is applied.', example='["default"]'),
    name?: string(name='name', description='The name of the query analysis rule.', example='synonym'),
    processors?: [  map[string]any ](name='processors', description='The analysis rule.', example='[]'),
    updated?: int32(name='updated', description='The time when the rule was updated.', example='1'),
  }(name='result', description='The information about the query analysis rule.', example='{}'),
}

model ModifyQueryProcessorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyQueryProcessorResponseBody(name='body'),
}

/**
 * @summary Modifies a query analysis rule for a specific application version. If you set dryRun to true, this operation checks the specified query analysis rule. By default, the value of dryRun is false if you do not specify this parameter.
 *
 * @param request ModifyQueryProcessorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyQueryProcessorResponse
 */
@context("modifyQueryProcessorWithContext")
async function modifyQueryProcessorWithOptions(appGroupIdentity: string, appId: string, name: string, request: ModifyQueryProcessorRequest, headers: map[string]string, runtime: $RuntimeOptions): ModifyQueryProcessorResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyQueryProcessor',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/query-processors/${$URL.percentEncode(name)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a query analysis rule for a specific application version. If you set dryRun to true, this operation checks the specified query analysis rule. By default, the value of dryRun is false if you do not specify this parameter.
 *
 * @param request ModifyQueryProcessorRequest
 * @return ModifyQueryProcessorResponse
 */
async function modifyQueryProcessor(appGroupIdentity: string, appId: string, name: string, request: ModifyQueryProcessorRequest): ModifyQueryProcessorResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyQueryProcessorWithOptions(appGroupIdentity, appId, name, request, headers, runtime);
}

model ModifyScheduledTaskRequest {
  body?: any(name='body', description='The request parameters.', example='The request parameters.'),
}

model ModifyScheduledTaskResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: map[string]any(name='result', description='The information about the scheduled task.', example='Array'),
}

model ModifyScheduledTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyScheduledTaskResponseBody(name='body'),
}

/**
 * @summary Modifies a scheduled task.
 *
 * @param request ModifyScheduledTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyScheduledTaskResponse
 */
@context("modifyScheduledTaskWithContext")
async function modifyScheduledTaskWithOptions(appGroupIdentity: string, taskId: string, request: ModifyScheduledTaskRequest, headers: map[string]string, runtime: $RuntimeOptions): ModifyScheduledTaskResponse {
  request.validate();
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyScheduledTask',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scheduled-tasks/${$URL.percentEncode(taskId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a scheduled task.
 *
 * @param request ModifyScheduledTaskRequest
 * @return ModifyScheduledTaskResponse
 */
async function modifyScheduledTask(appGroupIdentity: string, taskId: string, request: ModifyScheduledTaskRequest): ModifyScheduledTaskResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyScheduledTaskWithOptions(appGroupIdentity, taskId, request, headers, runtime);
}

model ModifySecondRankRequest {
  body?: SecondRank(name='body', description='The request parameters.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether the request is a dry run.', example='true'),
}

model ModifySecondRankResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='C5E2F73C-8241-81F8-3A62-65478C5A3111'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the expression is the default one.', example='true'),
    created?: int32(name='created', description='The time when the expression was created.', example='1'),
    description?: string(name='description', description='The description of the expression.', example='"11"'),
    id?: string(name='id', description='The expression ID. This parameter is displayed only in the response.', example='890473'),
    isDefault?: string(name='isDefault', description='Indicates whether the expression is the default one. This parameter is displayed only in the response. Valid values:

*   true: the expression is the default one.
*   false: the expression is not the default one.', example='true'),
    isSys?: string(name='isSys', description='Indicates whether the expression is a system expression. This parameter is displayed only in the response. Valid values:

*   true: The expression is a system expression.
*   false:The expression is not a system expression', example='false'),
    meta?: string(name='meta', description='The content of the fine sort expression. You can define an expression that consists of fields, feature functions, and mathematical functions to implement complex sort logic.', example='cate_id > 0 and cate_id < 1000'),
    name?: string(name='name', description='The expression name.', example='lsh_second_1'),
    updated?: int32(name='updated', description='The time when the expression was updated.', example='1'),
  }(name='result', description='The information about the fine sort expression.', example='{}'),
}

model ModifySecondRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySecondRankResponseBody(name='body'),
}

/**
 * @summary Modifies a fine sort expression that is configured for a specific OpenSearch application version. If you set dryRun to true, the specified fine sort expression is checked after the expression is modified. By default, the value of dryRun is false if you do not specify this parameter.
 *
 * @param request ModifySecondRankRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySecondRankResponse
 */
@context("modifySecondRankWithContext")
async function modifySecondRankWithOptions(appGroupIdentity: string, appId: string, name: string, request: ModifySecondRankRequest, headers: map[string]string, runtime: $RuntimeOptions): ModifySecondRankResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifySecondRank',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/second-ranks/${$URL.percentEncode(name)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a fine sort expression that is configured for a specific OpenSearch application version. If you set dryRun to true, the specified fine sort expression is checked after the expression is modified. By default, the value of dryRun is false if you do not specify this parameter.
 *
 * @param request ModifySecondRankRequest
 * @return ModifySecondRankResponse
 */
async function modifySecondRank(appGroupIdentity: string, appId: string, name: string, request: ModifySecondRankRequest): ModifySecondRankResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return modifySecondRankWithOptions(appGroupIdentity, appId, name, request, headers, runtime);
}

model PushInterventionDictionaryEntriesRequest {
  body?: [  map[string]any ](name='body', description='The request body.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to check the validity of input parameters. Default value: false.

Valid values:

*   **true**: checks only the validity of input parameters.
*   **false**: checks the validity of input parameters and creates an attribution configuration.', example='false'),
}

model PushInterventionDictionaryEntriesResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ string ](name='result', description='The returned results.'),
}

model PushInterventionDictionaryEntriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushInterventionDictionaryEntriesResponseBody(name='body'),
}

/**
 * @summary Accepts the changes in intervention entries.
 *
 * @param request PushInterventionDictionaryEntriesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushInterventionDictionaryEntriesResponse
 */
@context("pushInterventionDictionaryEntriesWithContext")
async function pushInterventionDictionaryEntriesWithOptions(name: string, request: PushInterventionDictionaryEntriesRequest, headers: map[string]string, runtime: $RuntimeOptions): PushInterventionDictionaryEntriesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.toArray(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'PushInterventionDictionaryEntries',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/intervention-dictionaries/${$URL.percentEncode(name)}/entries/actions/bulk`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Accepts the changes in intervention entries.
 *
 * @param request PushInterventionDictionaryEntriesRequest
 * @return PushInterventionDictionaryEntriesResponse
 */
async function pushInterventionDictionaryEntries(name: string, request: PushInterventionDictionaryEntriesRequest): PushInterventionDictionaryEntriesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return pushInterventionDictionaryEntriesWithOptions(name, request, headers, runtime);
}

model PushUserAnalyzerEntriesRequest {
  entries?: [ 
    {
      cmd?: string(name='cmd', description='The operation to be performed on the entries.

Valid values:

*   add
*   delete', example='"add"'),
      key?: string(name='key', description='The key to be used to query entries.', example='"testvalue"'),
      splitEnabled?: boolean(name='splitEnabled', description='Specifies whether to further analyze the terms that are generated after the search query is analyzed.

Default value: true.', example='true'),
      value?: string(name='value', description='The analysis result.', example='"test value"'),
    }
  ](name='entries', description='The entries of the custom analyzer.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run. This parameter is only used to check whether the data source is valid. Valid values: true and false.', example='true'),
}

model PushUserAnalyzerEntriesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: map[string]any(name='result', description='The result returned.', example='{}'),
}

model PushUserAnalyzerEntriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushUserAnalyzerEntriesResponseBody(name='body'),
}

/**
 * @summary Accepts the changes in the entries of a custom analyzer.
 *
 * @param request PushUserAnalyzerEntriesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushUserAnalyzerEntriesResponse
 */
@context("pushUserAnalyzerEntriesWithContext")
async function pushUserAnalyzerEntriesWithOptions(name: string, request: PushUserAnalyzerEntriesRequest, headers: map[string]string, runtime: $RuntimeOptions): PushUserAnalyzerEntriesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!$isNull(request.entries)) {
    body['entries'] = request.entries;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'PushUserAnalyzerEntries',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/user-analyzers/${$URL.percentEncode(name)}/entries/actions/bulk`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Accepts the changes in the entries of a custom analyzer.
 *
 * @param request PushUserAnalyzerEntriesRequest
 * @return PushUserAnalyzerEntriesResponse
 */
async function pushUserAnalyzerEntries(name: string, request: PushUserAnalyzerEntriesRequest): PushUserAnalyzerEntriesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return pushUserAnalyzerEntriesWithOptions(name, request, headers, runtime);
}

model ReleaseSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
  result?: {
    version?: long(name='version'),
  }(name='result'),
}

model ReleaseSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleaseSortScriptResponseBody(name='body'),
}

/**
 * @summary 发布排序脚本
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseSortScriptResponse
 */
@context("releaseSortScriptWithContext")
async function releaseSortScriptWithOptions(appGroupIdentity: string, scriptName: string, appVersionId: string, headers: map[string]string, runtime: $RuntimeOptions): ReleaseSortScriptResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ReleaseSortScript',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appVersionId)}/sort-scripts/${$URL.percentEncode(scriptName)}/actions/release`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 发布排序脚本
 *
 * @return ReleaseSortScriptResponse
 */
async function releaseSortScript(appGroupIdentity: string, scriptName: string, appVersionId: string): ReleaseSortScriptResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return releaseSortScriptWithOptions(appGroupIdentity, scriptName, appVersionId, headers, runtime);
}

model RemoveAppResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='33477D76-C380-2D84-A4AD-043F52876CB1'),
  result?: [ int32 ](name='result', description='The return result.'),
}

model RemoveAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveAppResponseBody(name='body'),
}

/**
 * @summary Deletes a version of an OpenSearch application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveAppResponse
 */
@context("removeAppWithContext")
async function removeAppWithOptions(appGroupIdentity: string, appId: string, headers: map[string]string, runtime: $RuntimeOptions): RemoveAppResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'RemoveApp',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a version of an OpenSearch application.
 *
 * @return RemoveAppResponse
 */
async function removeApp(appGroupIdentity: string, appId: string): RemoveAppResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return removeAppWithOptions(appGroupIdentity, appId, headers, runtime);
}

model RemoveAppGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='3AA29D02-54F3-8569-F71A-90E1B7BE4E7E'),
  result?: [ int32 ](name='result', description='The returned results.'),
}

model RemoveAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveAppGroupResponseBody(name='body'),
}

/**
 * @summary Deletes an OpenSearch application.
 *
 * @description You can delete only pay-as-you-go applications. You cannot delete subscription applications.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveAppGroupResponse
 */
@context("removeAppGroupWithContext")
async function removeAppGroupWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: $RuntimeOptions): RemoveAppGroupResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'RemoveAppGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an OpenSearch application.
 *
 * @description You can delete only pay-as-you-go applications. You cannot delete subscription applications.
 *
 * @return RemoveAppGroupResponse
 */
async function removeAppGroup(appGroupIdentity: string): RemoveAppGroupResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return removeAppGroupWithOptions(appGroupIdentity, headers, runtime);
}

model RemoveDataCollectionResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: string(name='result', description='-', example='{}'),
}

model RemoveDataCollectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveDataCollectionResponseBody(name='body'),
}

/**
 * @summary Disables data collection.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveDataCollectionResponse
 */
@context("removeDataCollectionWithContext")
async function removeDataCollectionWithOptions(appGroupIdentity: string, dataCollectionIdentity: string, headers: map[string]string, runtime: $RuntimeOptions): RemoveDataCollectionResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'RemoveDataCollection',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/data-collections/${$URL.percentEncode(dataCollectionIdentity)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disables data collection.
 *
 * @return RemoveDataCollectionResponse
 */
async function removeDataCollection(appGroupIdentity: string, dataCollectionIdentity: string): RemoveDataCollectionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return removeDataCollectionWithOptions(appGroupIdentity, dataCollectionIdentity, headers, runtime);
}

model RemoveFirstRankResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='E676FAB6-A0AC-64D9-F9D7-D0D33C930CFF'),
  result?: {
    active?: boolean(name='active', description='Specifies whether to set the fine sort expression as the default sort expression.', example='true'),
    description?: string(name='description', description='Description', example='""'),
    meta?: [ 
      {
        arg?: string(name='arg', description='The parameters that are used by a function in the expression. For more information, see Rough sort functions.[](~~170007~~)', example='""'),
        attribute?: string(name='attribute', description='The attribute, which refers to the scoring feature or search field, For more information about supported feature functions, see Rough sort functions.[](~~170007~~)', example='static_bm25()'),
        weight?: float(name='weight', description='The weight. Valid values: -100000 to 100000. The value cannot be 0.', example='10'),
      }
    ](name='meta', description='The information about the expression.'),
    name?: string(name='name', description='Parameter', example='default'),
  }(name='result', description='The information about the rough sort expression.'),
}

model RemoveFirstRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveFirstRankResponseBody(name='body'),
}

/**
 * @summary Deletes a rough sort expression for a version of an OpenSearch application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveFirstRankResponse
 */
@context("removeFirstRankWithContext")
async function removeFirstRankWithOptions(appGroupIdentity: string, appId: string, name: string, headers: map[string]string, runtime: $RuntimeOptions): RemoveFirstRankResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'RemoveFirstRank',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/first-ranks/${$URL.percentEncode(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a rough sort expression for a version of an OpenSearch application.
 *
 * @return RemoveFirstRankResponse
 */
async function removeFirstRank(appGroupIdentity: string, appId: string, name: string): RemoveFirstRankResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return removeFirstRankWithOptions(appGroupIdentity, appId, name, headers, runtime);
}

model RemoveInterventionDictionaryResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='06BBD41A-5F72-34E4-2DAF-E43B0526051D'),
  result?: {
    analyzer?: string(name='analyzer', description='The custom analyzer.', example='""'),
    created?: string(name='created', description='The time when the intervention dictionary was created.', example='1539158313'),
    name?: string(name='name', description='Parameter', example='tongyici'),
    type?: string(name='type', description='Type

*   stopword: an intervention dictionary for stop word filtering.
*   synonym: an intervention dictionary for synonym configuration.
*   correction: an intervention dictionary for spelling correction.
*   category_prediction: an intervention dictionary for category prediction.
*   ner: an intervention dictionary for named entity recognition.
*   term_weighting: an intervention dictionary for term weight analysis.', example='synonym'),
    updated?: string(name='updated', description='The time when the the intervention dictionary was modified.', example='1539158313'),
  }(name='result', description='The information about the intervention dictionary.'),
}

model RemoveInterventionDictionaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveInterventionDictionaryResponseBody(name='body'),
}

/**
 * @summary Deletes an intervention dictionary.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveInterventionDictionaryResponse
 */
@context("removeInterventionDictionaryWithContext")
async function removeInterventionDictionaryWithOptions(name: string, headers: map[string]string, runtime: $RuntimeOptions): RemoveInterventionDictionaryResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'RemoveInterventionDictionary',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/intervention-dictionaries/${$URL.percentEncode(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an intervention dictionary.
 *
 * @return RemoveInterventionDictionaryResponse
 */
async function removeInterventionDictionary(name: string): RemoveInterventionDictionaryResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return removeInterventionDictionaryWithOptions(name, headers, runtime);
}

model RemoveQueryProcessorResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: string(name='result', description='\\\\--', example='[]'),
}

model RemoveQueryProcessorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveQueryProcessorResponseBody(name='body'),
}

/**
 * @summary Deletes a query analysis rule for an OpenSearch application version.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveQueryProcessorResponse
 */
@context("removeQueryProcessorWithContext")
async function removeQueryProcessorWithOptions(appGroupIdentity: string, appId: string, name: string, headers: map[string]string, runtime: $RuntimeOptions): RemoveQueryProcessorResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'RemoveQueryProcessor',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/query-processors/${$URL.percentEncode(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a query analysis rule for an OpenSearch application version.
 *
 * @return RemoveQueryProcessorResponse
 */
async function removeQueryProcessor(appGroupIdentity: string, appId: string, name: string): RemoveQueryProcessorResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return removeQueryProcessorWithOptions(appGroupIdentity, appId, name, headers, runtime);
}

model RemoveScheduledTaskResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: [ int32 ](name='result', description='The returned results.'),
}

model RemoveScheduledTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveScheduledTaskResponseBody(name='body'),
}

/**
 * @summary Deletes a scheduled task of an OpenSearch application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveScheduledTaskResponse
 */
@context("removeScheduledTaskWithContext")
async function removeScheduledTaskWithOptions(appGroupIdentity: string, taskId: string, headers: map[string]string, runtime: $RuntimeOptions): RemoveScheduledTaskResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'RemoveScheduledTask',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scheduled-tasks/${$URL.percentEncode(taskId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a scheduled task of an OpenSearch application.
 *
 * @return RemoveScheduledTaskResponse
 */
async function removeScheduledTask(appGroupIdentity: string, taskId: string): RemoveScheduledTaskResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return removeScheduledTaskWithOptions(appGroupIdentity, taskId, headers, runtime);
}

model RemoveSearchStrategyResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='F5099063-6B86-F398-D843-905F9EFB683A'),
}

model RemoveSearchStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveSearchStrategyResponseBody(name='body'),
}

/**
 * @summary Deletes a query policy.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveSearchStrategyResponse
 */
@context("removeSearchStrategyWithContext")
async function removeSearchStrategyWithOptions(appGroupIdentity: string, appId: string, strategyName: string, headers: map[string]string, runtime: $RuntimeOptions): RemoveSearchStrategyResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'RemoveSearchStrategy',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/search-strategies/${$URL.percentEncode(strategyName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a query policy.
 *
 * @return RemoveSearchStrategyResponse
 */
async function removeSearchStrategy(appGroupIdentity: string, appId: string, strategyName: string): RemoveSearchStrategyResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return removeSearchStrategyWithOptions(appGroupIdentity, appId, strategyName, headers, runtime);
}

model RemoveSecondRankResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: map[string]any(name='result', description='The returned results.', example='{}'),
}

model RemoveSecondRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveSecondRankResponseBody(name='body'),
}

/**
 * @summary Deletes a fine sort expression from a version of an OpenSearch application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveSecondRankResponse
 */
@context("removeSecondRankWithContext")
async function removeSecondRankWithOptions(appGroupIdentity: string, appId: string, name: string, headers: map[string]string, runtime: $RuntimeOptions): RemoveSecondRankResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'RemoveSecondRank',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/second-ranks/${$URL.percentEncode(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a fine sort expression from a version of an OpenSearch application.
 *
 * @return RemoveSecondRankResponse
 */
async function removeSecondRank(appGroupIdentity: string, appId: string, name: string): RemoveSecondRankResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return removeSecondRankWithOptions(appGroupIdentity, appId, name, headers, runtime);
}

model RemoveUserAnalyzerResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: map[string]any(name='result', description='The result set. This parameter is not returned if the request is successful.', example='[]'),
}

model RemoveUserAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveUserAnalyzerResponseBody(name='body'),
}

/**
 * @summary Deletes a custom analyzer.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveUserAnalyzerResponse
 */
@context("removeUserAnalyzerWithContext")
async function removeUserAnalyzerWithOptions(name: string, headers: map[string]string, runtime: $RuntimeOptions): RemoveUserAnalyzerResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'RemoveUserAnalyzer',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/user-analyzers/${$URL.percentEncode(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a custom analyzer.
 *
 * @return RemoveUserAnalyzerResponse
 */
async function removeUserAnalyzer(name: string): RemoveUserAnalyzerResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return removeUserAnalyzerWithOptions(name, headers, runtime);
}

model RenewAppGroupRequest {
  body?: PrepayOrderInfo(name='body', description='The renewal request body.'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request.', example='74db41d8cd3c784209093aa76afbe89e'),
}

model RenewAppGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: boolean(name='result', description='Indicates whether the application was renewed.', example='true'),
}

model RenewAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenewAppGroupResponseBody(name='body'),
}

/**
 * @summary Renews an application. This operation is not available now. You must renew an application in the OpenSearch console.
 *
 * @param request RenewAppGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RenewAppGroupResponse
 */
@context("renewAppGroupWithContext")
async function renewAppGroupWithOptions(appGroupIdentity: string, request: RenewAppGroupRequest, headers: map[string]string, runtime: $RuntimeOptions): RenewAppGroupResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'RenewAppGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/actions/renew`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Renews an application. This operation is not available now. You must renew an application in the OpenSearch console.
 *
 * @param request RenewAppGroupRequest
 * @return RenewAppGroupResponse
 */
async function renewAppGroup(appGroupIdentity: string, request: RenewAppGroupRequest): RenewAppGroupResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return renewAppGroupWithOptions(appGroupIdentity, request, headers, runtime);
}

model ReplaceAppGroupCommodityCodeResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='AC5F78BA-66B9-545B-9CF1-8F542E682E1F'),
  result?: {
    chargeType?: string(name='chargeType', description='The billing method. Valid values:

*   POSTPAY: pay-as-you-go.
*   PREPAY: subscription.', example='POSTPAY'),
    chargingWay?: int32(name='chargingWay', description='The billing type. Valid values:

*   1: computing resources.
*   2: queries per second (QPS).', example='1'),
    commodityCode?: string(name='commodityCode', description='The code of the commodity.', example='opensearch'),
    created?: int32(name='created', description='The timestamp when the application was created.', example='1588054131'),
    currentVersion?: string(name='currentVersion', description='The ID of the current online version.', example='100302903'),
    description?: string(name='description', description='The description of the application.', example='""'),
    expireOn?: string(name='expireOn', description='The expiration time.', example='-'),
    firstRankAlgoDeploymentId?: int32(name='firstRankAlgoDeploymentId', description='The ID of the rough sort expression.', example='0'),
    hasPendingQuotaReviewTask?: int32(name='hasPendingQuotaReviewTask', description='The approval state of the quotas. Valid values:

*   0: The approval status is normal.
*   1: The quotas are being approved.', example='0'),
    id?: string(name='id', description='The application ID.', example='-'),
    instanceId?: string(name='instanceId', description='The instance ID.', example='-'),
    lockMode?: string(name='lockMode', description='The lock state. Valid values:

*   Unlock: The instance is unlocked.
*   LockByExpiration: The instance is automatically locked after it expires.
*   ManualLock: The instance is manually locked.', example='Unlock'),
    lockedByExpiration?: int32(name='lockedByExpiration', description='Indicates whether the instance is automatically locked after it expires. Valid values:

*   0: The instance is not automatically locked after it expires.
*   1: The instance is automatically locked after it expires.', example='0'),
    name?: string(name='name', description='The name of the order.', example='-'),
    pendingSecondRankAlgoDeploymentId?: int32(name='pendingSecondRankAlgoDeploymentId', description='The ID of the fine sort expression that is being created.', example='0'),
    processingOrderId?: string(name='processingOrderId', description='The ID of the order that is in progress.', example='-'),
    produced?: int32(name='produced', description='Indicates whether the order is produced.', example='0'),
    projectId?: string(name='projectId', description='The name of the A/B test group.', example='-'),
    quota?: {
      computeResource?: int32(name='computeResource', description='The number of computing resources configured.', example='20'),
      docSize?: int32(name='docSize', description='The storage capacity.', example='1'),
      spec?: string(name='spec', description='The specifications configured.', example='-'),
    }(name='quota', description='The configuration information.'),
    secondRankAlgoDeploymentId?: int32(name='secondRankAlgoDeploymentId', description='The ID of the fine sort expression.', example='0'),
    status?: string(name='status', description='The status of the application.', example='normal'),
    switchedTime?: int32(name='switchedTime', description='The timestamp when the current online version was published.', example='1590486386'),
    type?: string(name='type', description='The type of the application.', example='-'),
    updated?: int32(name='updated', description='The timestamp when the application was updated.', example='1581065904'),
    versions?: [ string ](name='versions', description='The versions.'),
  }(name='result', description='The returned result.', example='{}'),
}

model ReplaceAppGroupCommodityCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReplaceAppGroupCommodityCodeResponseBody(name='body'),
}

/**
 * @summary Converts a service-based application to an instance-based application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReplaceAppGroupCommodityCodeResponse
 */
@context("replaceAppGroupCommodityCodeWithContext")
async function replaceAppGroupCommodityCodeWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: $RuntimeOptions): ReplaceAppGroupCommodityCodeResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ReplaceAppGroupCommodityCode',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/actions/to-instance-typed`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Converts a service-based application to an instance-based application.
 *
 * @return ReplaceAppGroupCommodityCodeResponse
 */
async function replaceAppGroupCommodityCode(appGroupIdentity: string): ReplaceAppGroupCommodityCodeResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return replaceAppGroupCommodityCodeWithOptions(appGroupIdentity, headers, runtime);
}

model SaveSortScriptFileRequest {
  content?: string(name='content', description='The script content that is encoded in the Base64 format.', example='4769#0: *28194492991 a client request body is buffered to a temporary file /usr/local/webserver/openresty/nginx/client_body_temp/0000624474,'),
  version?: int32(name='version', description='The version number of the script content.', example='2022-12-01'),
}

model SaveSortScriptFileResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ABCDEFGH'),
}

model SaveSortScriptFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SaveSortScriptFileResponseBody(name='body'),
}

/**
 * @summary Uploads a sort script.
 *
 * @param request SaveSortScriptFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveSortScriptFileResponse
 */
@context("saveSortScriptFileWithContext")
async function saveSortScriptFileWithOptions(appGroupIdentity: string, scriptName: string, appVersionId: string, fileName: string, request: SaveSortScriptFileRequest, headers: map[string]string, runtime: $RuntimeOptions): SaveSortScriptFileResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.content)) {
    body['content'] = request.content;
  }
  if (!$isNull(request.version)) {
    body['version'] = request.version;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'SaveSortScriptFile',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appVersionId)}/sort-scripts/${$URL.percentEncode(scriptName)}/files/src/${$URL.percentEncode(fileName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Uploads a sort script.
 *
 * @param request SaveSortScriptFileRequest
 * @return SaveSortScriptFileResponse
 */
async function saveSortScriptFile(appGroupIdentity: string, scriptName: string, appVersionId: string, fileName: string, request: SaveSortScriptFileRequest): SaveSortScriptFileResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return saveSortScriptFileWithOptions(appGroupIdentity, scriptName, appVersionId, fileName, request, headers, runtime);
}

model StartSlowQueryAnalyzerResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: map[string]any(name='result', description='N/A', example='{}'),
}

model StartSlowQueryAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartSlowQueryAnalyzerResponseBody(name='body'),
}

/**
 * @summary 立即进行慢查询分析
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartSlowQueryAnalyzerResponse
 */
@context("startSlowQueryAnalyzerWithContext")
async function startSlowQueryAnalyzerWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: $RuntimeOptions): StartSlowQueryAnalyzerResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'StartSlowQueryAnalyzer',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/optimizers/slow-query/actions/run`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 立即进行慢查询分析
 *
 * @return StartSlowQueryAnalyzerResponse
 */
async function startSlowQueryAnalyzer(appGroupIdentity: string): StartSlowQueryAnalyzerResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return startSlowQueryAnalyzerWithOptions(appGroupIdentity, headers, runtime);
}

model TagResourcesRequest {
  resourceId?: [ string ](name='resourceId', description='The resource IDs. You can specify a maximum number of 50 resource IDs.

This parameter is required.'),
  resourceType?: string(name='resourceType', description='The resource type.

This parameter is required.', example='ProductVersion'),
  tag?: [ 
    {
      key?: string(name='key', description='The key of the tag.', example='cloud_manage'),
      value?: string(name='value', description='The value of the tag.', example='31261301'),
    }
  ](name='tag', description='The tags. You can specify a maximum number of 20 tags.

This parameter is required.'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
 * @summary Adds tags to resources.
 *
 * @param request TagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
@context("tagResourcesWithContext")
async function tagResourcesWithOptions(request: TagResourcesRequest, headers: map[string]string, runtime: $RuntimeOptions): TagResourcesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.resourceId)) {
    body['resourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    body['resourceType'] = request.resourceType;
  }
  if (!$isNull(request.tag)) {
    body['tag'] = request.tag;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'TagResources',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/resource-tags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds tags to resources.
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(request, headers, runtime);
}

model UnbindESUserAnalyzerRequest {
  body?: any(name='body', description='The request parameters.', example='{
  "name": "kevintest-analyzer"
}'),
}

model UnbindESUserAnalyzerResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: map[string]any(name='result', description='The custom analyzer.', example='[]'),
}

model UnbindESUserAnalyzerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindESUserAnalyzerResponseBody(name='body'),
}

/**
 * @summary Unbinds a custom analyzer from an Elasticsearch instance.
 *
 * @description You can call this operation to unbind a custom analyzer from an Elasticsearch instance.
 *
 * @param request UnbindESUserAnalyzerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnbindESUserAnalyzerResponse
 */
@context("unbindESUserAnalyzerWithContext")
async function unbindESUserAnalyzerWithOptions(appGroupIdentity: string, esInstanceId: string, request: UnbindESUserAnalyzerRequest, headers: map[string]string, runtime: $RuntimeOptions): UnbindESUserAnalyzerResponse {
  request.validate();
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApiUtil.Params{
    action = 'UnbindESUserAnalyzer',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/es/${$URL.percentEncode(esInstanceId)}/actions/unbind-analyzer`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Unbinds a custom analyzer from an Elasticsearch instance.
 *
 * @description You can call this operation to unbind a custom analyzer from an Elasticsearch instance.
 *
 * @param request UnbindESUserAnalyzerRequest
 * @return UnbindESUserAnalyzerResponse
 */
async function unbindESUserAnalyzer(appGroupIdentity: string, esInstanceId: string, request: UnbindESUserAnalyzerRequest): UnbindESUserAnalyzerResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return unbindESUserAnalyzerWithOptions(appGroupIdentity, esInstanceId, request, headers, runtime);
}

model UnbindEsInstanceResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='0A6EB64B-B4C8-CF02-810F-E660812972FF'),
  result?: map[string]any(name='result', description='The data returned.', example='{}'),
}

model UnbindEsInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindEsInstanceResponseBody(name='body'),
}

/**
 * @summary Unbinds an Elasticsearch instance from an OpenSearch application.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnbindEsInstanceResponse
 */
@context("unbindEsInstanceWithContext")
async function unbindEsInstanceWithOptions(appGroupIdentity: string, headers: map[string]string, runtime: $RuntimeOptions): UnbindEsInstanceResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'UnbindEsInstance',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/actions/unbind-es-instance`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Unbinds an Elasticsearch instance from an OpenSearch application.
 *
 * @return UnbindEsInstanceResponse
 */
async function unbindEsInstance(appGroupIdentity: string): UnbindEsInstanceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return unbindEsInstanceWithOptions(appGroupIdentity, headers, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='all', description='Specifies whether to remove all tags from the specified one or more resources. This parameter takes effect only if the tagKey parameter is not specified. Valid values: true and false. Default value: false.', example='true'),
  resourceId?: [ string ](name='resourceId', description='The resource IDs. You can specify a maximum number of 50 IDs.

This parameter is required.'),
  resourceType?: string(name='resourceType', description='The resource type.

This parameter is required.', example='ProductVersion'),
  tagKey?: [ string ](name='tagKey', description='The keys of tags. You can specify a maximum number of 20 keys.'),
}

model UntagResourcesShrinkRequest {
  all?: boolean(name='all', description='Specifies whether to remove all tags from the specified one or more resources. This parameter takes effect only if the tagKey parameter is not specified. Valid values: true and false. Default value: false.', example='true'),
  resourceIdShrink?: string(name='resourceId', description='The resource IDs. You can specify a maximum number of 50 IDs.

This parameter is required.'),
  resourceType?: string(name='resourceType', description='The resource type.

This parameter is required.', example='ProductVersion'),
  tagKeyShrink?: string(name='tagKey', description='The keys of tags. You can specify a maximum number of 20 keys.'),
}

model UntagResourcesResponseBody = {
  tequestId?: string(name='tequestId', description='The ID of the request.', example='1-A-0-B'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
 * @summary Remove tags from resources.
 *
 * @param tmpReq UntagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesResponse
 */
@context("untagResourcesWithContext")
async function untagResourcesWithOptions(tmpReq: UntagResourcesRequest, headers: map[string]string, runtime: $RuntimeOptions): UntagResourcesResponse {
  tmpReq.validate();
  var request = new UntagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.resourceId)) {
    request.resourceIdShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceId, 'resourceId', 'json');
  }
  if (!$isNull(tmpReq.tagKey)) {
    request.tagKeyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tagKey, 'tagKey', 'json');
  }
  var query : map[string]any = {};
  if (!$isNull(request.all)) {
    query['all'] = request.all;
  }
  if (!$isNull(request.resourceIdShrink)) {
    query['resourceId'] = request.resourceIdShrink;
  }
  if (!$isNull(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }
  if (!$isNull(request.tagKeyShrink)) {
    query['tagKey'] = request.tagKeyShrink;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UntagResources',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/resource-tags`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Remove tags from resources.
 *
 * @param request UntagResourcesRequest
 * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourcesWithOptions(request, headers, runtime);
}

model UpdateABTestExperimentRequest {
  body?: ABTestExperiment(name='body', description='The request body. For more information, see [ABTestExperiment](https://help.aliyun.com/document_detail/173617.html).'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   true: performs only a dry run. No endpoint is created. The system checks whether your AccessKey is valid, whether Resource Access Management (RAM) users are authorized, and whether the required parameters are set.
*   false (default): creates an endpoint immediately.', example='true'),
}

model UpdateABTestExperimentResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test was created.', example='1588842080'),
    id?: string(name='id', description='The test ID.', example='12888'),
    name?: string(name='name', description='The alias of the test.', example='test1'),
    online?: boolean(name='online', description='Indicates whether the test is in effect. Valid values:

*   true
*   false', example='true'),
    params?: map[string]any(name='params', description='The test parameters.', example='{}'),
    traffic?: int32(name='traffic', description='The percentage of traffic that is routed to the test. Valid values: [0,100]', example='30'),
    updated?: int32(name='updated', description='The time when the test was last modified.', example='1588842080'),
  }(name='result', description='The details of the test.'),
}

model UpdateABTestExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateABTestExperimentResponseBody(name='body'),
}

/**
 * @summary Modifies the parameters of an A/B test.
 *
 * @param request UpdateABTestExperimentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateABTestExperimentResponse
 */
@context("updateABTestExperimentWithContext")
async function updateABTestExperimentWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string, request: UpdateABTestExperimentRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateABTestExperimentResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateABTestExperiment',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scenes/${$URL.percentEncode(sceneId)}/groups/${$URL.percentEncode(groupId)}/experiments/${$URL.percentEncode(experimentId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the parameters of an A/B test.
 *
 * @param request UpdateABTestExperimentRequest
 * @return UpdateABTestExperimentResponse
 */
async function updateABTestExperiment(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string, request: UpdateABTestExperimentRequest): UpdateABTestExperimentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateABTestExperimentWithOptions(appGroupIdentity, sceneId, groupId, experimentId, request, headers, runtime);
}

model UpdateABTestFixedFlowDividersRequest {
  body?: [ string ](name='body', description='The request body.'),
}

model UpdateABTestFixedFlowDividersResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: [ string ](name='result', description='The returned results.'),
}

model UpdateABTestFixedFlowDividersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateABTestFixedFlowDividersResponseBody(name='body'),
}

/**
 * @summary Modifies whitelists.
 *
 * @param request UpdateABTestFixedFlowDividersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateABTestFixedFlowDividersResponse
 */
@context("updateABTestFixedFlowDividersWithContext")
async function updateABTestFixedFlowDividersWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string, request: UpdateABTestFixedFlowDividersRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateABTestFixedFlowDividersResponse {
  request.validate();
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateABTestFixedFlowDividers',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scenes/${$URL.percentEncode(sceneId)}/groups/${$URL.percentEncode(groupId)}/experiments/${$URL.percentEncode(experimentId)}/fixed-flow-dividers`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies whitelists.
 *
 * @param request UpdateABTestFixedFlowDividersRequest
 * @return UpdateABTestFixedFlowDividersResponse
 */
async function updateABTestFixedFlowDividers(appGroupIdentity: string, sceneId: string, groupId: string, experimentId: string, request: UpdateABTestFixedFlowDividersRequest): UpdateABTestFixedFlowDividersResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateABTestFixedFlowDividersWithOptions(appGroupIdentity, sceneId, groupId, experimentId, request, headers, runtime);
}

model UpdateABTestGroupRequest {
  body?: ABTestGroup(name='body', description='The request body. For more information, see [ABTestGroup](https://help.aliyun.com/document_detail/178935.html).'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   true: performs only a dry run. No endpoint is created. The system checks whether your AccessKey is valid, whether Resource Access Management (RAM) users are authorized, and whether the required parameters are set.
*   false (default): creates an endpoint immediately.', example='true'),
}

model UpdateABTestGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='\\\\"\\\\"1111\\\\"\\\\"'),
  result?: {
    created?: int32(name='created', description='The time when the test group was created.', example='1588839490'),
    id?: string(name='id', description='The ID of the test group.', example='13466'),
    name?: string(name='name', description='The alias of the test group.', example='Group_2020-5-7_15:23:3'),
    status?: int32(name='status', description='The status of the test group. Valid values:

*   0: not in effect
*   1: in effect', example='1'),
    updated?: int32(name='updated', description='The time when the test group was last updated.', example='1588839490'),
  }(name='result', description='The details of the test group.'),
}

model UpdateABTestGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateABTestGroupResponseBody(name='body'),
}

/**
 * @summary Modifies a test group.
 *
 * @param request UpdateABTestGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateABTestGroupResponse
 */
@context("updateABTestGroupWithContext")
async function updateABTestGroupWithOptions(appGroupIdentity: string, sceneId: string, groupId: string, request: UpdateABTestGroupRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateABTestGroupResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateABTestGroup',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scenes/${$URL.percentEncode(sceneId)}/groups/${$URL.percentEncode(groupId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a test group.
 *
 * @param request UpdateABTestGroupRequest
 * @return UpdateABTestGroupResponse
 */
async function updateABTestGroup(appGroupIdentity: string, sceneId: string, groupId: string, request: UpdateABTestGroupRequest): UpdateABTestGroupResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateABTestGroupWithOptions(appGroupIdentity, sceneId, groupId, request, headers, runtime);
}

model UpdateABTestSceneRequest {
  body?: ABTestScene(name='body', description='The request body.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run. This parameter is only used to check whether the data source is valid. Valid values: true and false.', example='true'),
}

model UpdateABTestSceneResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: {
    created?: int32(name='created', description='The time when the test scenario was created.', example='1596527691'),
    id?: string(name='id', description='The ID of the test scenario.', example='20614'),
    name?: string(name='name', description='The name of the test scenario.', example='kevintest22'),
    online?: boolean(name='online', description='The status of the test. Valid values:

*   true: The test is started.
*   false: The test is stopped.', example='true'),
    params?: map[string]any(name='params', description='The parameters of the A/B test.', example='{}'),
    traffic?: int32(name='traffic', description='The percentage of traffic that is allocated to the A/B test. Valid values: 0 to 100.', example='111'),
    updated?: int32(name='updated', description='The time when the test scenario was last modified.', example='1596527691'),
  }(name='result', description='The details of the test scenario. For more information, see [ABTestScene](https://help.aliyun.com/document_detail/173618.html).', example='{}'),
}

model UpdateABTestSceneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateABTestSceneResponseBody(name='body'),
}

/**
 * @summary Modifies an A/B test scenario.
 *
 * @param request UpdateABTestSceneRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateABTestSceneResponse
 */
@context("updateABTestSceneWithContext")
async function updateABTestSceneWithOptions(appGroupIdentity: string, sceneId: string, request: UpdateABTestSceneRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateABTestSceneResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateABTestScene',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/scenes/${$URL.percentEncode(sceneId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies an A/B test scenario.
 *
 * @param request UpdateABTestSceneRequest
 * @return UpdateABTestSceneResponse
 */
async function updateABTestScene(appGroupIdentity: string, sceneId: string, request: UpdateABTestSceneRequest): UpdateABTestSceneResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateABTestSceneWithOptions(appGroupIdentity, sceneId, request, headers, runtime);
}

model UpdateFetchFieldsRequest {
  body?: [ string ](name='body', description='The request body.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether the request is a dry run.', example='true'),
}

model UpdateFetchFieldsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D77D0DAF-790D-F5F5-A9C0-133738165014'),
  result?: boolean(name='result', description='Indicates whether the operation was successful.', example='true'),
}

model UpdateFetchFieldsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFetchFieldsResponseBody(name='body'),
}

/**
 * @summary Updates fetch fields. A dry run is supported.
 *
 * @param request UpdateFetchFieldsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFetchFieldsResponse
 */
@context("updateFetchFieldsWithContext")
async function updateFetchFieldsWithOptions(appGroupIdentity: string, appId: string, request: UpdateFetchFieldsRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateFetchFieldsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateFetchFields',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/fetch-fields`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates fetch fields. A dry run is supported.
 *
 * @param request UpdateFetchFieldsRequest
 * @return UpdateFetchFieldsResponse
 */
async function updateFetchFields(appGroupIdentity: string, appId: string, request: UpdateFetchFieldsRequest): UpdateFetchFieldsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFetchFieldsWithOptions(appGroupIdentity, appId, request, headers, runtime);
}

model UpdateFunctionDefaultInstanceRequest {
  instanceName?: string(name='instanceName', description='The name of the instance.', example='"pop_test"'),
}

model UpdateFunctionDefaultInstanceResponseBody = {
  code?: string(name='Code', description='The error code.', example='DefaultInstance.SetFail'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='123'),
  message?: string(name='Message', description='The error message.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A4D487A9-A456-5AA5-A9C6-B7BF2889CF74'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model UpdateFunctionDefaultInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFunctionDefaultInstanceResponseBody(name='body'),
}

/**
 * @summary Sets the default algorithm instance used by the specified application. The new algorithm instance automatically overwrites the most recently set default instance. If no instance is set, the default instance is canceled.
 *
 * @param request UpdateFunctionDefaultInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFunctionDefaultInstanceResponse
 */
@context("updateFunctionDefaultInstanceWithContext")
async function updateFunctionDefaultInstanceWithOptions(appGroupIdentity: string, functionName: string, request: UpdateFunctionDefaultInstanceRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateFunctionDefaultInstanceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.instanceName)) {
    body['instanceName'] = request.instanceName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateFunctionDefaultInstance',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/functions/${$URL.percentEncode(functionName)}/default-instance`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Sets the default algorithm instance used by the specified application. The new algorithm instance automatically overwrites the most recently set default instance. If no instance is set, the default instance is canceled.
 *
 * @param request UpdateFunctionDefaultInstanceRequest
 * @return UpdateFunctionDefaultInstanceResponse
 */
async function updateFunctionDefaultInstance(appGroupIdentity: string, functionName: string, request: UpdateFunctionDefaultInstanceRequest): UpdateFunctionDefaultInstanceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFunctionDefaultInstanceWithOptions(appGroupIdentity, functionName, request, headers, runtime);
}

model UpdateFunctionInstanceRequest {
  createParameters?: [ 
    {
      name?: string(name='name', description='The name of the parameter.', example='title_field'),
      value?: string(name='value', description='The value of the parameter.', example='title'),
    }
  ](name='createParameters', description='The parameters that are used to create the instance.', example='{             "name": "title_field",             "value": "title"         }'),
  cron?: string(name='cron', description='The cron expression used to schedule periodic training, in the format of (Minutes Hours DayofMonth Month DayofWeek). The default value is empty, which indicates that no periodic training is performed. DayofWeek 0 indicates Sunday.', example='"0 3 ? * 0,1,3,5"'),
  description?: string(name='description', description='The description of the instance.', example='test instance'),
  usageParameters?: [ 
    {
      name?: string(name='name', description='The name of the parameter.', example='allow_dict_id'),
      value?: string(name='value', description='The value of the parameter.', example='123'),
    }
  ](name='usageParameters', description='The parameters that are used.'),
}

model UpdateFunctionInstanceResponseBody = {
  code?: string(name='Code', description='The error code.', example='"Instance.NotExist"'),
  httpCode?: long(name='HttpCode', description='The HTTP status code.', example='200'),
  latency?: long(name='Latency', description='The time consumed for the request, in milliseconds.', example='10'),
  message?: string(name='Message', description='The error message.', example='"instance not exist."'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='"3A809095-C554-5CF5-8FCE-BE19D4673790"'),
  status?: string(name='Status', description='The status of the request. Valid values:

*       OK: The request was successful.
*       FAIL: The request failed.', example='OK'),
}

model UpdateFunctionInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFunctionInstanceResponseBody(name='body'),
}

/**
 * @summary Updates an algorithm instance.
 *
 * @param request UpdateFunctionInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFunctionInstanceResponse
 */
@context("updateFunctionInstanceWithContext")
async function updateFunctionInstanceWithOptions(appGroupIdentity: string, functionName: string, instanceName: string, request: UpdateFunctionInstanceRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateFunctionInstanceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.createParameters)) {
    body['createParameters'] = request.createParameters;
  }
  if (!$isNull(request.cron)) {
    body['cron'] = request.cron;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.usageParameters)) {
    body['usageParameters'] = request.usageParameters;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateFunctionInstance',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/functions/${$URL.percentEncode(functionName)}/instances/${$URL.percentEncode(instanceName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates an algorithm instance.
 *
 * @param request UpdateFunctionInstanceRequest
 * @return UpdateFunctionInstanceResponse
 */
async function updateFunctionInstance(appGroupIdentity: string, functionName: string, instanceName: string, request: UpdateFunctionInstanceRequest): UpdateFunctionInstanceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFunctionInstanceWithOptions(appGroupIdentity, functionName, instanceName, request, headers, runtime);
}

model UpdateFunctionResourceRequest {
  data?: {
    content?: string(name='Content', description='The content of the file that corresponds to a resource of the raw_file type.', example='abc'),
    generators?: [ 
      {
        generator?: string(name='Generator', description='The type of the feature generator.', example='combo'),
        input?: {
          features?: [ 
            {
              name?: string(name='Name', description='The name of the feature.', example='system_item_id'),
              type?: string(name='Type', description='The type of the feature.', example='item'),
            }
          ](name='Features', description='The input features.'),
        }(name='Input', description='The input.'),
        output?: string(name='Output', description='The name of the output feature.', example='feature1'),
      }
    ](name='Generators', description='The feature generators that correspond to resources of the feature_generator type.'),
  }(name='Data', description='The resource data. The data structure varies with the resource type.'),
  description?: string(name='Description', description='The description of the resource.', example='updated description'),
}

model UpdateFunctionResourceResponseBody = {
  code?: string(name='Code', description='The error code. If no error occurs, this parameter is left empty.', example='InvalidRequest'),
  httpCode?: long(name='HttpCode', description='The HTTP status code returned.', example='200'),
  latency?: double(name='Latency', description='The time consumed for the request. Unit: milliseconds.', example='123'),
  message?: string(name='Message', description='The error message returned.', example='Invalid request.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7E375703-5B12-5466-8B48-C4D01AE1291A'),
  status?: string(name='Status', description='The status of the request.', example='OK'),
}

model UpdateFunctionResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFunctionResourceResponseBody(name='body'),
}

/**
 * @summary Updates an algorithm resource.
 *
 * @description You can call this operation to update the information about resources by resource name. You can modify only the values of data and description.
 *
 * @param request UpdateFunctionResourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFunctionResourceResponse
 */
@context("updateFunctionResourceWithContext")
async function updateFunctionResourceWithOptions(appGroupIdentity: string, functionName: string, resourceName: string, request: UpdateFunctionResourceRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateFunctionResourceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.data)) {
    body['Data'] = request.data;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateFunctionResource',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/functions/${$URL.percentEncode(functionName)}/resources/${$URL.percentEncode(resourceName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates an algorithm resource.
 *
 * @description You can call this operation to update the information about resources by resource name. You can modify only the values of data and description.
 *
 * @param request UpdateFunctionResourceRequest
 * @return UpdateFunctionResourceResponse
 */
async function updateFunctionResource(appGroupIdentity: string, functionName: string, resourceName: string, request: UpdateFunctionResourceRequest): UpdateFunctionResourceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFunctionResourceWithOptions(appGroupIdentity, functionName, resourceName, request, headers, runtime);
}

model UpdateSearchStrategyRequest {
  body?: SearchStrategy(name='body', description='The request body.'),
}

model UpdateSearchStrategyResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ABCDEFGH'),
}

model UpdateSearchStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSearchStrategyResponseBody(name='body'),
}

/**
 * @summary Modifies a query policy.
 *
 * @param request UpdateSearchStrategyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSearchStrategyResponse
 */
@context("updateSearchStrategyWithContext")
async function updateSearchStrategyWithOptions(appGroupIdentity: string, appId: string, strategyName: string, request: UpdateSearchStrategyRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateSearchStrategyResponse {
  request.validate();
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateSearchStrategy',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/search-strategies/${$URL.percentEncode(strategyName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a query policy.
 *
 * @param request UpdateSearchStrategyRequest
 * @return UpdateSearchStrategyResponse
 */
async function updateSearchStrategy(appGroupIdentity: string, appId: string, strategyName: string, request: UpdateSearchStrategyRequest): UpdateSearchStrategyResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSearchStrategyWithOptions(appGroupIdentity, appId, strategyName, request, headers, runtime);
}

model UpdateSortScriptRequest {
  description?: string(name='description'),
}

model UpdateSortScriptResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='9F165784-5507-5342-ABF3-545293F9808A'),
}

model UpdateSortScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSortScriptResponseBody(name='body'),
}

/**
 * @summary Modifies the description of a sort script.
 *
 * @description You can call this operation to modify the description of a sort script.
 *
 * @param request UpdateSortScriptRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSortScriptResponse
 */
@context("updateSortScriptWithContext")
async function updateSortScriptWithOptions(appGroupIdentity: string, appVersionId: string, scriptName: string, request: UpdateSortScriptRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateSortScriptResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateSortScript',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appVersionId)}/sort-scripts/${$URL.percentEncode(scriptName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the description of a sort script.
 *
 * @description You can call this operation to modify the description of a sort script.
 *
 * @param request UpdateSortScriptRequest
 * @return UpdateSortScriptResponse
 */
async function updateSortScript(appGroupIdentity: string, appVersionId: string, scriptName: string, request: UpdateSortScriptRequest): UpdateSortScriptResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSortScriptWithOptions(appGroupIdentity, appVersionId, scriptName, request, headers, runtime);
}

model UpdateSummariesRequest {
  body?: [ 
    {
      element?: string(name='element', description='The HTML tag that is used to highlight terms in red.', example='"em"'),
      ellipsis?: string(name='ellipsis', description='The connector that is used to connect segments.', example='"..."'),
      field?: string(name='field', description='The field.', example='"title"'),
      len?: int32(name='len', description='The length of a segment.', example='50'),
      snippet?: int32(name='snippet', description='The number of segments.', example='1'),
    }
  ](name='body', description='The request body.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether the request is a dry run.', example='true'),
}

model UpdateSummariesResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='7A389E09-7964-5A2B-FE9D-F6CFA7162852'),
  result?: boolean(name='result', description='Indicates whether the request was successful.', example='true'),
}

model UpdateSummariesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSummariesResponseBody(name='body'),
}

/**
 * @summary Updates summaries. A dry run is supported.
 *
 * @param request UpdateSummariesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSummariesResponse
 */
@context("updateSummariesWithContext")
async function updateSummariesWithOptions(appGroupIdentity: string, appId: string, request: UpdateSummariesRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateSummariesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.toArray(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateSummaries',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/app-groups/${$URL.percentEncode(appGroupIdentity)}/apps/${$URL.percentEncode(appId)}/summaries`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates summaries. A dry run is supported.
 *
 * @param request UpdateSummariesRequest
 * @return UpdateSummariesResponse
 */
async function updateSummaries(appGroupIdentity: string, appId: string, request: UpdateSummariesRequest): UpdateSummariesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSummariesWithOptions(appGroupIdentity, appId, request, headers, runtime);
}

model ValidateDataSourcesRequest {
  body?: DataSource(name='body', description='The request parameter. For more information, see [DataSource](https://help.aliyun.com/document_detail/170005.html).'),
}

model ValidateDataSourcesResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='8FA2B338-AFDC-46B4-A132-B5487820C2BF'),
  result?: [ 
    {
      code?: string(name='code', description='The code returned for the request.', example='SUCCEED'),
      dataSource?: {
        parameters?: map[string]any(name='parameters', description='The parameters of the data source.', example='{}'),
        tableName?: string(name='tableName', description='The name of the table.', example='user_activity_decision'),
        type?: string(name='type', description='The type of the data source.', example='rds'),
      }(name='dataSource', description='The data source.', example='{}'),
      message?: string(name='message', description='The status of the execution.', example='successful'),
    }
  ](name='result', description='The result returned.', example='[]'),
}

model ValidateDataSourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ValidateDataSourcesResponseBody(name='body'),
}

/**
 * @summary Verifies data sources.
 *
 * @param request ValidateDataSourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ValidateDataSourcesResponse
 */
@context("validateDataSourcesWithContext")
async function validateDataSourcesWithOptions(request: ValidateDataSourcesRequest, headers: map[string]string, runtime: $RuntimeOptions): ValidateDataSourcesResponse {
  request.validate();
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ValidateDataSources',
    version = '2017-12-25',
    protocol = 'HTTPS',
    pathname = `/v4/openapi/assist/data-sources/validations`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Verifies data sources.
 *
 * @param request ValidateDataSourcesRequest
 * @return ValidateDataSourcesResponse
 */
async function validateDataSources(request: ValidateDataSourcesRequest): ValidateDataSourcesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return validateDataSourcesWithOptions(request, headers, runtime);
}

