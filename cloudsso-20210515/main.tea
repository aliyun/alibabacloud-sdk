/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('cloudsso', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddExternalSAMLIdPCertificateRequest {
  directoryId?: string(name='DirectoryId'),
  x509Certificate?: string(name='X509Certificate'),
}

model AddExternalSAMLIdPCertificateResponseBody = {
  certificateId?: string(name='CertificateId'),
  requestId?: string(name='RequestId'),
}

model AddExternalSAMLIdPCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddExternalSAMLIdPCertificateResponseBody(name='body'),
}

async function addExternalSAMLIdPCertificateWithOptions(request: AddExternalSAMLIdPCertificateRequest, runtime: Util.RuntimeOptions): AddExternalSAMLIdPCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.x509Certificate)) {
    query['X509Certificate'] = request.x509Certificate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddExternalSAMLIdPCertificate',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addExternalSAMLIdPCertificate(request: AddExternalSAMLIdPCertificateRequest): AddExternalSAMLIdPCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addExternalSAMLIdPCertificateWithOptions(request, runtime);
}

model AddPermissionPolicyToAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId'),
  directoryId?: string(name='DirectoryId'),
  inlinePolicyDocument?: string(name='InlinePolicyDocument'),
  permissionPolicyName?: string(name='PermissionPolicyName'),
  permissionPolicyType?: string(name='PermissionPolicyType'),
}

model AddPermissionPolicyToAccessConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddPermissionPolicyToAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddPermissionPolicyToAccessConfigurationResponseBody(name='body'),
}

async function addPermissionPolicyToAccessConfigurationWithOptions(request: AddPermissionPolicyToAccessConfigurationRequest, runtime: Util.RuntimeOptions): AddPermissionPolicyToAccessConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessConfigurationId)) {
    query['AccessConfigurationId'] = request.accessConfigurationId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.inlinePolicyDocument)) {
    query['InlinePolicyDocument'] = request.inlinePolicyDocument;
  }
  if (!Util.isUnset(request.permissionPolicyName)) {
    query['PermissionPolicyName'] = request.permissionPolicyName;
  }
  if (!Util.isUnset(request.permissionPolicyType)) {
    query['PermissionPolicyType'] = request.permissionPolicyType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddPermissionPolicyToAccessConfiguration',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addPermissionPolicyToAccessConfiguration(request: AddPermissionPolicyToAccessConfigurationRequest): AddPermissionPolicyToAccessConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPermissionPolicyToAccessConfigurationWithOptions(request, runtime);
}

model AddUserToGroupRequest {
  directoryId?: string(name='DirectoryId'),
  groupId?: string(name='GroupId'),
  userId?: string(name='UserId'),
}

model AddUserToGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddUserToGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddUserToGroupResponseBody(name='body'),
}

async function addUserToGroupWithOptions(request: AddUserToGroupRequest, runtime: Util.RuntimeOptions): AddUserToGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddUserToGroup',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addUserToGroup(request: AddUserToGroupRequest): AddUserToGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUserToGroupWithOptions(request, runtime);
}

model ClearExternalSAMLIdentityProviderRequest {
  directoryId?: string(name='DirectoryId'),
}

model ClearExternalSAMLIdentityProviderResponseBody = {
  requestId?: string(name='RequestId'),
}

model ClearExternalSAMLIdentityProviderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ClearExternalSAMLIdentityProviderResponseBody(name='body'),
}

async function clearExternalSAMLIdentityProviderWithOptions(request: ClearExternalSAMLIdentityProviderRequest, runtime: Util.RuntimeOptions): ClearExternalSAMLIdentityProviderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ClearExternalSAMLIdentityProvider',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function clearExternalSAMLIdentityProvider(request: ClearExternalSAMLIdentityProviderRequest): ClearExternalSAMLIdentityProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return clearExternalSAMLIdentityProviderWithOptions(request, runtime);
}

model CreateAccessAssignmentRequest {
  accessConfigurationId?: string(name='AccessConfigurationId'),
  directoryId?: string(name='DirectoryId'),
  principalId?: string(name='PrincipalId'),
  principalType?: string(name='PrincipalType'),
  targetId?: string(name='TargetId'),
  targetType?: string(name='TargetType'),
}

model CreateAccessAssignmentResponseBody = {
  requestId?: string(name='RequestId'),
  task?: {
    accessConfigurationId?: string(name='AccessConfigurationId'),
    accessConfigurationName?: string(name='AccessConfigurationName'),
    principalId?: string(name='PrincipalId'),
    principalName?: string(name='PrincipalName'),
    principalType?: string(name='PrincipalType'),
    status?: string(name='Status'),
    targetId?: string(name='TargetId'),
    targetName?: string(name='TargetName'),
    targetPath?: string(name='TargetPath'),
    targetPathName?: string(name='TargetPathName'),
    targetType?: string(name='TargetType'),
    taskId?: string(name='TaskId'),
    taskType?: string(name='TaskType'),
  }(name='Task'),
}

model CreateAccessAssignmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAccessAssignmentResponseBody(name='body'),
}

async function createAccessAssignmentWithOptions(request: CreateAccessAssignmentRequest, runtime: Util.RuntimeOptions): CreateAccessAssignmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessConfigurationId)) {
    query['AccessConfigurationId'] = request.accessConfigurationId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.principalId)) {
    query['PrincipalId'] = request.principalId;
  }
  if (!Util.isUnset(request.principalType)) {
    query['PrincipalType'] = request.principalType;
  }
  if (!Util.isUnset(request.targetId)) {
    query['TargetId'] = request.targetId;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccessAssignment',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAccessAssignment(request: CreateAccessAssignmentRequest): CreateAccessAssignmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccessAssignmentWithOptions(request, runtime);
}

model CreateAccessConfigurationRequest {
  accessConfigurationName?: string(name='AccessConfigurationName'),
  description?: string(name='Description'),
  directoryId?: string(name='DirectoryId'),
  relayState?: string(name='RelayState'),
  sessionDuration?: int32(name='SessionDuration'),
}

model CreateAccessConfigurationResponseBody = {
  accessConfiguration?: {
    accessConfigurationId?: string(name='AccessConfigurationId'),
    accessConfigurationName?: string(name='AccessConfigurationName'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    relayState?: string(name='RelayState'),
    sessionDuration?: int32(name='SessionDuration'),
    statusNotifications?: [ string ](name='StatusNotifications'),
    updateTime?: string(name='UpdateTime'),
  }(name='AccessConfiguration'),
  requestId?: string(name='RequestId'),
}

model CreateAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAccessConfigurationResponseBody(name='body'),
}

async function createAccessConfigurationWithOptions(request: CreateAccessConfigurationRequest, runtime: Util.RuntimeOptions): CreateAccessConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessConfigurationName)) {
    query['AccessConfigurationName'] = request.accessConfigurationName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.relayState)) {
    query['RelayState'] = request.relayState;
  }
  if (!Util.isUnset(request.sessionDuration)) {
    query['SessionDuration'] = request.sessionDuration;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccessConfiguration',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAccessConfiguration(request: CreateAccessConfigurationRequest): CreateAccessConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccessConfigurationWithOptions(request, runtime);
}

model CreateDirectoryRequest {
  directoryName?: string(name='DirectoryName'),
}

model CreateDirectoryResponseBody = {
  directory?: {
    createTime?: string(name='CreateTime'),
    directoryId?: string(name='DirectoryId'),
    directoryName?: string(name='DirectoryName'),
    region?: string(name='Region'),
    updateTime?: string(name='UpdateTime'),
  }(name='Directory'),
  requestId?: string(name='RequestId'),
}

model CreateDirectoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDirectoryResponseBody(name='body'),
}

async function createDirectoryWithOptions(request: CreateDirectoryRequest, runtime: Util.RuntimeOptions): CreateDirectoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryName)) {
    query['DirectoryName'] = request.directoryName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDirectory',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDirectory(request: CreateDirectoryRequest): CreateDirectoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDirectoryWithOptions(request, runtime);
}

model CreateGroupRequest {
  description?: string(name='Description'),
  directoryId?: string(name='DirectoryId'),
  groupName?: string(name='GroupName'),
}

model CreateGroupResponseBody = {
  group?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    provisionType?: string(name='ProvisionType'),
    updateTime?: string(name='UpdateTime'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model CreateGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGroupResponseBody(name='body'),
}

async function createGroupWithOptions(request: CreateGroupRequest, runtime: Util.RuntimeOptions): CreateGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGroup',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGroup(request: CreateGroupRequest): CreateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupWithOptions(request, runtime);
}

model CreateSCIMServerCredentialRequest {
  directoryId?: string(name='DirectoryId'),
}

model CreateSCIMServerCredentialResponseBody = {
  requestId?: string(name='RequestId'),
  SCIMServerCredential?: {
    createTime?: string(name='CreateTime'),
    credentialId?: string(name='CredentialId'),
    credentialSecret?: string(name='CredentialSecret'),
    credentialType?: string(name='CredentialType'),
    directoryId?: string(name='DirectoryId'),
    expireTime?: string(name='ExpireTime'),
    status?: string(name='Status'),
  }(name='SCIMServerCredential'),
}

model CreateSCIMServerCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSCIMServerCredentialResponseBody(name='body'),
}

async function createSCIMServerCredentialWithOptions(request: CreateSCIMServerCredentialRequest, runtime: Util.RuntimeOptions): CreateSCIMServerCredentialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSCIMServerCredential',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSCIMServerCredential(request: CreateSCIMServerCredentialRequest): CreateSCIMServerCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSCIMServerCredentialWithOptions(request, runtime);
}

model CreateUserRequest {
  description?: string(name='Description'),
  directoryId?: string(name='DirectoryId'),
  displayName?: string(name='DisplayName'),
  email?: string(name='Email'),
  firstName?: string(name='FirstName'),
  lastName?: string(name='LastName'),
  status?: string(name='Status'),
  userName?: string(name='UserName'),
}

model CreateUserResponseBody = {
  requestId?: string(name='RequestId'),
  user?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    displayName?: string(name='DisplayName'),
    email?: string(name='Email'),
    firstName?: string(name='FirstName'),
    lastName?: string(name='LastName'),
    provisionType?: string(name='ProvisionType'),
    status?: string(name='Status'),
    updateTime?: string(name='UpdateTime'),
    userId?: string(name='UserId'),
    userName?: string(name='UserName'),
  }(name='User'),
}

model CreateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUserResponseBody(name='body'),
}

async function createUserWithOptions(request: CreateUserRequest, runtime: Util.RuntimeOptions): CreateUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.firstName)) {
    query['FirstName'] = request.firstName;
  }
  if (!Util.isUnset(request.lastName)) {
    query['LastName'] = request.lastName;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUser',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserWithOptions(request, runtime);
}

model DeleteAccessAssignmentRequest {
  accessConfigurationId?: string(name='AccessConfigurationId'),
  deprovisionStrategy?: string(name='DeprovisionStrategy'),
  directoryId?: string(name='DirectoryId'),
  principalId?: string(name='PrincipalId'),
  principalType?: string(name='PrincipalType'),
  targetId?: string(name='TargetId'),
  targetType?: string(name='TargetType'),
}

model DeleteAccessAssignmentResponseBody = {
  requestId?: string(name='RequestId'),
  task?: {
    accessConfigurationId?: string(name='AccessConfigurationId'),
    accessConfigurationName?: string(name='AccessConfigurationName'),
    principalId?: string(name='PrincipalId'),
    principalName?: string(name='PrincipalName'),
    principalType?: string(name='PrincipalType'),
    status?: string(name='Status'),
    targetId?: string(name='TargetId'),
    targetName?: string(name='TargetName'),
    targetPath?: string(name='TargetPath'),
    targetPathName?: string(name='TargetPathName'),
    targetType?: string(name='TargetType'),
    taskId?: string(name='TaskId'),
    taskType?: string(name='TaskType'),
  }(name='Task'),
}

model DeleteAccessAssignmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAccessAssignmentResponseBody(name='body'),
}

async function deleteAccessAssignmentWithOptions(request: DeleteAccessAssignmentRequest, runtime: Util.RuntimeOptions): DeleteAccessAssignmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessConfigurationId)) {
    query['AccessConfigurationId'] = request.accessConfigurationId;
  }
  if (!Util.isUnset(request.deprovisionStrategy)) {
    query['DeprovisionStrategy'] = request.deprovisionStrategy;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.principalId)) {
    query['PrincipalId'] = request.principalId;
  }
  if (!Util.isUnset(request.principalType)) {
    query['PrincipalType'] = request.principalType;
  }
  if (!Util.isUnset(request.targetId)) {
    query['TargetId'] = request.targetId;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAccessAssignment',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAccessAssignment(request: DeleteAccessAssignmentRequest): DeleteAccessAssignmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccessAssignmentWithOptions(request, runtime);
}

model DeleteAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId'),
  directoryId?: string(name='DirectoryId'),
  forceRemovePermissionPolicies?: boolean(name='ForceRemovePermissionPolicies'),
}

model DeleteAccessConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAccessConfigurationResponseBody(name='body'),
}

async function deleteAccessConfigurationWithOptions(request: DeleteAccessConfigurationRequest, runtime: Util.RuntimeOptions): DeleteAccessConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessConfigurationId)) {
    query['AccessConfigurationId'] = request.accessConfigurationId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.forceRemovePermissionPolicies)) {
    query['ForceRemovePermissionPolicies'] = request.forceRemovePermissionPolicies;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAccessConfiguration',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAccessConfiguration(request: DeleteAccessConfigurationRequest): DeleteAccessConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccessConfigurationWithOptions(request, runtime);
}

model DeleteDirectoryRequest {
  directoryId?: string(name='DirectoryId'),
}

model DeleteDirectoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDirectoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDirectoryResponseBody(name='body'),
}

async function deleteDirectoryWithOptions(request: DeleteDirectoryRequest, runtime: Util.RuntimeOptions): DeleteDirectoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDirectory',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDirectory(request: DeleteDirectoryRequest): DeleteDirectoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDirectoryWithOptions(request, runtime);
}

model DeleteGroupRequest {
  directoryId?: string(name='DirectoryId'),
  groupId?: string(name='GroupId'),
}

model DeleteGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGroupResponseBody(name='body'),
}

async function deleteGroupWithOptions(request: DeleteGroupRequest, runtime: Util.RuntimeOptions): DeleteGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGroup',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGroup(request: DeleteGroupRequest): DeleteGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGroupWithOptions(request, runtime);
}

model DeleteMFADeviceForUserRequest {
  directoryId?: string(name='DirectoryId'),
  MFADeviceId?: string(name='MFADeviceId'),
  userId?: string(name='UserId'),
}

model DeleteMFADeviceForUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMFADeviceForUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMFADeviceForUserResponseBody(name='body'),
}

async function deleteMFADeviceForUserWithOptions(request: DeleteMFADeviceForUserRequest, runtime: Util.RuntimeOptions): DeleteMFADeviceForUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.MFADeviceId)) {
    query['MFADeviceId'] = request.MFADeviceId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMFADeviceForUser',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMFADeviceForUser(request: DeleteMFADeviceForUserRequest): DeleteMFADeviceForUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMFADeviceForUserWithOptions(request, runtime);
}

model DeleteSCIMServerCredentialRequest {
  credentialId?: string(name='CredentialId'),
  directoryId?: string(name='DirectoryId'),
}

model DeleteSCIMServerCredentialResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSCIMServerCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSCIMServerCredentialResponseBody(name='body'),
}

async function deleteSCIMServerCredentialWithOptions(request: DeleteSCIMServerCredentialRequest, runtime: Util.RuntimeOptions): DeleteSCIMServerCredentialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.credentialId)) {
    query['CredentialId'] = request.credentialId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSCIMServerCredential',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSCIMServerCredential(request: DeleteSCIMServerCredentialRequest): DeleteSCIMServerCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSCIMServerCredentialWithOptions(request, runtime);
}

model DeleteUserRequest {
  directoryId?: string(name='DirectoryId'),
  userId?: string(name='UserId'),
}

model DeleteUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUserWithOptions(request: DeleteUserRequest, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUser',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserWithOptions(request, runtime);
}

model DeprovisionAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId'),
  directoryId?: string(name='DirectoryId'),
  targetId?: string(name='TargetId'),
  targetType?: string(name='TargetType'),
}

model DeprovisionAccessConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      accessConfigurationId?: string(name='AccessConfigurationId'),
      accessConfigurationName?: string(name='AccessConfigurationName'),
      status?: string(name='Status'),
      targetId?: string(name='TargetId'),
      targetName?: string(name='TargetName'),
      targetPath?: string(name='TargetPath'),
      targetPathName?: string(name='TargetPathName'),
      targetType?: string(name='TargetType'),
      taskId?: string(name='TaskId'),
      taskType?: string(name='TaskType'),
    }
  ](name='Tasks'),
}

model DeprovisionAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeprovisionAccessConfigurationResponseBody(name='body'),
}

async function deprovisionAccessConfigurationWithOptions(request: DeprovisionAccessConfigurationRequest, runtime: Util.RuntimeOptions): DeprovisionAccessConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessConfigurationId)) {
    query['AccessConfigurationId'] = request.accessConfigurationId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.targetId)) {
    query['TargetId'] = request.targetId;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeprovisionAccessConfiguration',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deprovisionAccessConfiguration(request: DeprovisionAccessConfigurationRequest): DeprovisionAccessConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deprovisionAccessConfigurationWithOptions(request, runtime);
}

model DisableServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableServiceResponseBody(name='body'),
}

async function disableServiceWithOptions(runtime: Util.RuntimeOptions): DisableServiceResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DisableService',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableService(): DisableServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableServiceWithOptions(runtime);
}

model EnableServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableServiceResponseBody(name='body'),
}

async function enableServiceWithOptions(runtime: Util.RuntimeOptions): EnableServiceResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'EnableService',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableService(): EnableServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableServiceWithOptions(runtime);
}

model GetAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId'),
  directoryId?: string(name='DirectoryId'),
}

model GetAccessConfigurationResponseBody = {
  accessConfiguration?: {
    accessConfigurationId?: string(name='AccessConfigurationId'),
    accessConfigurationName?: string(name='AccessConfigurationName'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    relayState?: string(name='RelayState'),
    sessionDuration?: int32(name='SessionDuration'),
    statusNotifications?: [ string ](name='StatusNotifications'),
    updateTime?: string(name='UpdateTime'),
  }(name='AccessConfiguration'),
  requestId?: string(name='RequestId'),
}

model GetAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAccessConfigurationResponseBody(name='body'),
}

async function getAccessConfigurationWithOptions(request: GetAccessConfigurationRequest, runtime: Util.RuntimeOptions): GetAccessConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessConfigurationId)) {
    query['AccessConfigurationId'] = request.accessConfigurationId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAccessConfiguration',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAccessConfiguration(request: GetAccessConfigurationRequest): GetAccessConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccessConfigurationWithOptions(request, runtime);
}

model GetDirectoryRequest {
  directoryId?: string(name='DirectoryId'),
}

model GetDirectoryResponseBody = {
  directory?: {
    createTime?: string(name='CreateTime'),
    directoryId?: string(name='DirectoryId'),
    directoryName?: string(name='DirectoryName'),
    region?: string(name='Region'),
    updateTime?: string(name='UpdateTime'),
  }(name='Directory'),
  requestId?: string(name='RequestId'),
}

model GetDirectoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDirectoryResponseBody(name='body'),
}

async function getDirectoryWithOptions(request: GetDirectoryRequest, runtime: Util.RuntimeOptions): GetDirectoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDirectory',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDirectory(request: GetDirectoryRequest): GetDirectoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDirectoryWithOptions(request, runtime);
}

model GetDirectorySAMLServiceProviderInfoRequest {
  directoryId?: string(name='DirectoryId'),
}

model GetDirectorySAMLServiceProviderInfoResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLServiceProvider?: {
    acsUrl?: string(name='AcsUrl'),
    directoryId?: string(name='DirectoryId'),
    encodedMetadataDocument?: string(name='EncodedMetadataDocument'),
    entityId?: string(name='EntityId'),
  }(name='SAMLServiceProvider'),
}

model GetDirectorySAMLServiceProviderInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDirectorySAMLServiceProviderInfoResponseBody(name='body'),
}

async function getDirectorySAMLServiceProviderInfoWithOptions(request: GetDirectorySAMLServiceProviderInfoRequest, runtime: Util.RuntimeOptions): GetDirectorySAMLServiceProviderInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDirectorySAMLServiceProviderInfo',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDirectorySAMLServiceProviderInfo(request: GetDirectorySAMLServiceProviderInfoRequest): GetDirectorySAMLServiceProviderInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDirectorySAMLServiceProviderInfoWithOptions(request, runtime);
}

model GetDirectoryStatisticsRequest {
  directoryId?: string(name='DirectoryId'),
}

model GetDirectoryStatisticsResponseBody = {
  directoryStatistics?: {
    accessAssignmentCount?: int32(name='AccessAssignmentCount'),
    accessConfigurationCount?: int32(name='AccessConfigurationCount'),
    accessConfigurationQuota?: int32(name='AccessConfigurationQuota'),
    directoryId?: string(name='DirectoryId'),
    directoryName?: string(name='DirectoryName'),
    groupCount?: int32(name='GroupCount'),
    groupQuota?: int32(name='GroupQuota'),
    inProgressTaskCount?: int32(name='InProgressTaskCount'),
    region?: string(name='Region'),
    SCIMServerCredentialCount?: int32(name='SCIMServerCredentialCount'),
    SCIMSyncEnabled?: boolean(name='SCIMSyncEnabled'),
    SSOEnabled?: boolean(name='SSOEnabled'),
    userCount?: int32(name='UserCount'),
    userQuota?: int32(name='UserQuota'),
  }(name='DirectoryStatistics'),
  requestId?: string(name='RequestId'),
}

model GetDirectoryStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDirectoryStatisticsResponseBody(name='body'),
}

async function getDirectoryStatisticsWithOptions(request: GetDirectoryStatisticsRequest, runtime: Util.RuntimeOptions): GetDirectoryStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDirectoryStatistics',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDirectoryStatistics(request: GetDirectoryStatisticsRequest): GetDirectoryStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDirectoryStatisticsWithOptions(request, runtime);
}

model GetExternalSAMLIdentityProviderRequest {
  directoryId?: string(name='DirectoryId'),
}

model GetExternalSAMLIdentityProviderResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLIdentityProviderConfiguration?: {
    certificateIds?: [ string ](name='CertificateIds'),
    createTime?: string(name='CreateTime'),
    directoryId?: string(name='DirectoryId'),
    encodedMetadataDocument?: string(name='EncodedMetadataDocument'),
    entityId?: string(name='EntityId'),
    loginUrl?: string(name='LoginUrl'),
    SSOStatus?: string(name='SSOStatus'),
    updateTime?: string(name='UpdateTime'),
    wantRequestSigned?: boolean(name='WantRequestSigned'),
  }(name='SAMLIdentityProviderConfiguration'),
}

model GetExternalSAMLIdentityProviderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExternalSAMLIdentityProviderResponseBody(name='body'),
}

async function getExternalSAMLIdentityProviderWithOptions(request: GetExternalSAMLIdentityProviderRequest, runtime: Util.RuntimeOptions): GetExternalSAMLIdentityProviderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExternalSAMLIdentityProvider',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getExternalSAMLIdentityProvider(request: GetExternalSAMLIdentityProviderRequest): GetExternalSAMLIdentityProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return getExternalSAMLIdentityProviderWithOptions(request, runtime);
}

model GetGroupRequest {
  directoryId?: string(name='DirectoryId'),
  groupId?: string(name='GroupId'),
}

model GetGroupResponseBody = {
  group?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    provisionType?: string(name='ProvisionType'),
    updateTime?: string(name='UpdateTime'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model GetGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGroupResponseBody(name='body'),
}

async function getGroupWithOptions(request: GetGroupRequest, runtime: Util.RuntimeOptions): GetGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGroup',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGroup(request: GetGroupRequest): GetGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGroupWithOptions(request, runtime);
}

model GetMFAAuthenticationSettingsRequest {
  directoryId?: string(name='DirectoryId'),
}

model GetMFAAuthenticationSettingsResponseBody = {
  MFAAuthenticationAdvanceSettings?: string(name='MFAAuthenticationAdvanceSettings'),
  requestId?: string(name='RequestId'),
}

model GetMFAAuthenticationSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMFAAuthenticationSettingsResponseBody(name='body'),
}

async function getMFAAuthenticationSettingsWithOptions(request: GetMFAAuthenticationSettingsRequest, runtime: Util.RuntimeOptions): GetMFAAuthenticationSettingsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMFAAuthenticationSettings',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMFAAuthenticationSettings(request: GetMFAAuthenticationSettingsRequest): GetMFAAuthenticationSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMFAAuthenticationSettingsWithOptions(request, runtime);
}

model GetMFAAuthenticationStatusRequest {
  directoryId?: string(name='DirectoryId'),
}

model GetMFAAuthenticationStatusResponseBody = {
  MFAAuthenticationStatus?: string(name='MFAAuthenticationStatus'),
  requestId?: string(name='RequestId'),
}

model GetMFAAuthenticationStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMFAAuthenticationStatusResponseBody(name='body'),
}

async function getMFAAuthenticationStatusWithOptions(request: GetMFAAuthenticationStatusRequest, runtime: Util.RuntimeOptions): GetMFAAuthenticationStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMFAAuthenticationStatus',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMFAAuthenticationStatus(request: GetMFAAuthenticationStatusRequest): GetMFAAuthenticationStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMFAAuthenticationStatusWithOptions(request, runtime);
}

model GetSCIMSynchronizationStatusRequest {
  directoryId?: string(name='DirectoryId'),
}

model GetSCIMSynchronizationStatusResponseBody = {
  requestId?: string(name='RequestId'),
  SCIMSynchronizationStatus?: string(name='SCIMSynchronizationStatus'),
}

model GetSCIMSynchronizationStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSCIMSynchronizationStatusResponseBody(name='body'),
}

async function getSCIMSynchronizationStatusWithOptions(request: GetSCIMSynchronizationStatusRequest, runtime: Util.RuntimeOptions): GetSCIMSynchronizationStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSCIMSynchronizationStatus',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSCIMSynchronizationStatus(request: GetSCIMSynchronizationStatusRequest): GetSCIMSynchronizationStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSCIMSynchronizationStatusWithOptions(request, runtime);
}

model GetServiceStatusResponseBody = {
  requestId?: string(name='RequestId'),
  serviceStatus?: {
    accountId?: string(name='AccountId'),
    prerequisiteCheckResult?: string(name='PrerequisiteCheckResult'),
    regionsInUse?: [ string ](name='RegionsInUse'),
    status?: string(name='Status'),
  }(name='ServiceStatus'),
}

model GetServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceStatusResponseBody(name='body'),
}

async function getServiceStatusWithOptions(runtime: Util.RuntimeOptions): GetServiceStatusResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetServiceStatus',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getServiceStatus(): GetServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServiceStatusWithOptions(runtime);
}

model GetTaskRequest {
  directoryId?: string(name='DirectoryId'),
  taskId?: string(name='TaskId'),
}

model GetTaskResponseBody = {
  requestId?: string(name='RequestId'),
  task?: {
    accessConfigurationId?: string(name='AccessConfigurationId'),
    accessConfigurationName?: string(name='AccessConfigurationName'),
    endTime?: string(name='EndTime'),
    failureReason?: string(name='FailureReason'),
    principalId?: string(name='PrincipalId'),
    principalName?: string(name='PrincipalName'),
    principalType?: string(name='PrincipalType'),
    startTime?: string(name='StartTime'),
    status?: string(name='Status'),
    targetId?: string(name='TargetId'),
    targetName?: string(name='TargetName'),
    targetPath?: string(name='TargetPath'),
    targetPathName?: string(name='TargetPathName'),
    targetType?: string(name='TargetType'),
    taskId?: string(name='TaskId'),
    taskType?: string(name='TaskType'),
  }(name='Task'),
}

model GetTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskResponseBody(name='body'),
}

async function getTaskWithOptions(request: GetTaskRequest, runtime: Util.RuntimeOptions): GetTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTask',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTask(request: GetTaskRequest): GetTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskWithOptions(request, runtime);
}

model GetTaskStatusRequest {
  directoryId?: string(name='DirectoryId'),
  taskId?: string(name='TaskId'),
}

model GetTaskStatusResponseBody = {
  requestId?: string(name='RequestId'),
  taskStatus?: {
    endTime?: string(name='EndTime'),
    failureReason?: string(name='FailureReason'),
    startTime?: string(name='StartTime'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
    taskType?: string(name='TaskType'),
  }(name='TaskStatus'),
}

model GetTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskStatusResponseBody(name='body'),
}

async function getTaskStatusWithOptions(request: GetTaskStatusRequest, runtime: Util.RuntimeOptions): GetTaskStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskStatus',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTaskStatus(request: GetTaskStatusRequest): GetTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskStatusWithOptions(request, runtime);
}

model GetUserRequest {
  directoryId?: string(name='DirectoryId'),
  userId?: string(name='UserId'),
}

model GetUserResponseBody = {
  requestId?: string(name='RequestId'),
  user?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    displayName?: string(name='DisplayName'),
    email?: string(name='Email'),
    firstName?: string(name='FirstName'),
    lastName?: string(name='LastName'),
    provisionType?: string(name='ProvisionType'),
    status?: string(name='Status'),
    updateTime?: string(name='UpdateTime'),
    userId?: string(name='UserId'),
    userName?: string(name='UserName'),
  }(name='User'),
}

model GetUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserResponseBody(name='body'),
}

async function getUserWithOptions(request: GetUserRequest, runtime: Util.RuntimeOptions): GetUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUser',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUser(request: GetUserRequest): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserWithOptions(request, runtime);
}

model GetUserMFAAuthenticationSettingsRequest {
  directoryId?: string(name='DirectoryId'),
  userId?: string(name='UserId'),
}

model GetUserMFAAuthenticationSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  userMFAAuthenticationSettings?: string(name='UserMFAAuthenticationSettings'),
}

model GetUserMFAAuthenticationSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserMFAAuthenticationSettingsResponseBody(name='body'),
}

async function getUserMFAAuthenticationSettingsWithOptions(request: GetUserMFAAuthenticationSettingsRequest, runtime: Util.RuntimeOptions): GetUserMFAAuthenticationSettingsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserMFAAuthenticationSettings',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserMFAAuthenticationSettings(request: GetUserMFAAuthenticationSettingsRequest): GetUserMFAAuthenticationSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserMFAAuthenticationSettingsWithOptions(request, runtime);
}

model ListAccessAssignmentsRequest {
  accessConfigurationId?: string(name='AccessConfigurationId'),
  directoryId?: string(name='DirectoryId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  principalId?: string(name='PrincipalId'),
  principalType?: string(name='PrincipalType'),
  targetId?: string(name='TargetId'),
  targetType?: string(name='TargetType'),
}

model ListAccessAssignmentsResponseBody = {
  accessAssignments?: [ 
    {
      accessConfigurationId?: string(name='AccessConfigurationId'),
      accessConfigurationName?: string(name='AccessConfigurationName'),
      createTime?: string(name='CreateTime'),
      principalId?: string(name='PrincipalId'),
      principalName?: string(name='PrincipalName'),
      principalType?: string(name='PrincipalType'),
      targetId?: string(name='TargetId'),
      targetName?: string(name='TargetName'),
      targetPath?: string(name='TargetPath'),
      targetPathName?: string(name='TargetPathName'),
      targetType?: string(name='TargetType'),
    }
  ](name='AccessAssignments'),
  isTruncated?: boolean(name='IsTruncated'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListAccessAssignmentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAccessAssignmentsResponseBody(name='body'),
}

async function listAccessAssignmentsWithOptions(request: ListAccessAssignmentsRequest, runtime: Util.RuntimeOptions): ListAccessAssignmentsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessConfigurationId)) {
    query['AccessConfigurationId'] = request.accessConfigurationId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.principalId)) {
    query['PrincipalId'] = request.principalId;
  }
  if (!Util.isUnset(request.principalType)) {
    query['PrincipalType'] = request.principalType;
  }
  if (!Util.isUnset(request.targetId)) {
    query['TargetId'] = request.targetId;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAccessAssignments',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAccessAssignments(request: ListAccessAssignmentsRequest): ListAccessAssignmentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccessAssignmentsWithOptions(request, runtime);
}

model ListAccessConfigurationProvisioningsRequest {
  accessConfigurationId?: string(name='AccessConfigurationId'),
  directoryId?: string(name='DirectoryId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  provisioningStatus?: string(name='ProvisioningStatus'),
  targetId?: string(name='TargetId'),
  targetType?: string(name='TargetType'),
}

model ListAccessConfigurationProvisioningsResponseBody = {
  accessConfigurationProvisionings?: [ 
    {
      accessConfigurationId?: string(name='AccessConfigurationId'),
      accessConfigurationName?: string(name='AccessConfigurationName'),
      createTime?: string(name='CreateTime'),
      RAMPolicyNames?: [ string ](name='RAMPolicyNames'),
      RAMRoleName?: string(name='RAMRoleName'),
      SAMLProviderName?: string(name='SAMLProviderName'),
      status?: string(name='Status'),
      targetId?: string(name='TargetId'),
      targetName?: string(name='TargetName'),
      targetPath?: string(name='TargetPath'),
      targetPathName?: string(name='TargetPathName'),
      targetType?: string(name='TargetType'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='AccessConfigurationProvisionings'),
  isTruncated?: boolean(name='IsTruncated'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListAccessConfigurationProvisioningsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAccessConfigurationProvisioningsResponseBody(name='body'),
}

async function listAccessConfigurationProvisioningsWithOptions(request: ListAccessConfigurationProvisioningsRequest, runtime: Util.RuntimeOptions): ListAccessConfigurationProvisioningsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessConfigurationId)) {
    query['AccessConfigurationId'] = request.accessConfigurationId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.provisioningStatus)) {
    query['ProvisioningStatus'] = request.provisioningStatus;
  }
  if (!Util.isUnset(request.targetId)) {
    query['TargetId'] = request.targetId;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAccessConfigurationProvisionings',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAccessConfigurationProvisionings(request: ListAccessConfigurationProvisioningsRequest): ListAccessConfigurationProvisioningsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccessConfigurationProvisioningsWithOptions(request, runtime);
}

model ListAccessConfigurationsRequest {
  directoryId?: string(name='DirectoryId'),
  filter?: string(name='Filter'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  statusNotifications?: string(name='StatusNotifications'),
}

model ListAccessConfigurationsResponseBody = {
  accessConfigurations?: [ 
    {
      accessConfigurationId?: string(name='AccessConfigurationId'),
      accessConfigurationName?: string(name='AccessConfigurationName'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      relayState?: string(name='RelayState'),
      sessionDuration?: int32(name='SessionDuration'),
      statusNotifications?: [ string ](name='StatusNotifications'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='AccessConfigurations'),
  isTruncated?: boolean(name='IsTruncated'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListAccessConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAccessConfigurationsResponseBody(name='body'),
}

async function listAccessConfigurationsWithOptions(request: ListAccessConfigurationsRequest, runtime: Util.RuntimeOptions): ListAccessConfigurationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.statusNotifications)) {
    query['StatusNotifications'] = request.statusNotifications;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAccessConfigurations',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAccessConfigurations(request: ListAccessConfigurationsRequest): ListAccessConfigurationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccessConfigurationsWithOptions(request, runtime);
}

model ListDirectoriesResponseBody = {
  directories?: [ 
    {
      createTime?: string(name='CreateTime'),
      directoryId?: string(name='DirectoryId'),
      directoryName?: string(name='DirectoryName'),
      region?: string(name='Region'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Directories'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListDirectoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDirectoriesResponseBody(name='body'),
}

async function listDirectoriesWithOptions(runtime: Util.RuntimeOptions): ListDirectoriesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListDirectories',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDirectories(): ListDirectoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDirectoriesWithOptions(runtime);
}

model ListExternalSAMLIdPCertificatesRequest {
  directoryId?: string(name='DirectoryId'),
}

model ListExternalSAMLIdPCertificatesResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLIdPCertificates?: [ 
    {
      certificateId?: string(name='CertificateId'),
      issuer?: string(name='Issuer'),
      notAfter?: string(name='NotAfter'),
      notBefore?: string(name='NotBefore'),
      publicKey?: string(name='PublicKey'),
      serialNumber?: string(name='SerialNumber'),
      signatureAlgorithm?: string(name='SignatureAlgorithm'),
      subject?: string(name='Subject'),
      version?: int32(name='Version'),
      x509Certificate?: string(name='X509Certificate'),
    }
  ](name='SAMLIdPCertificates'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListExternalSAMLIdPCertificatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListExternalSAMLIdPCertificatesResponseBody(name='body'),
}

async function listExternalSAMLIdPCertificatesWithOptions(request: ListExternalSAMLIdPCertificatesRequest, runtime: Util.RuntimeOptions): ListExternalSAMLIdPCertificatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListExternalSAMLIdPCertificates',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listExternalSAMLIdPCertificates(request: ListExternalSAMLIdPCertificatesRequest): ListExternalSAMLIdPCertificatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExternalSAMLIdPCertificatesWithOptions(request, runtime);
}

model ListGroupMembersRequest {
  directoryId?: string(name='DirectoryId'),
  groupId?: string(name='GroupId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListGroupMembersResponseBody = {
  groupMembers?: [ 
    {
      description?: string(name='Description'),
      displayName?: string(name='DisplayName'),
      email?: string(name='Email'),
      groupId?: string(name='GroupId'),
      joinTime?: string(name='JoinTime'),
      provisionType?: string(name='ProvisionType'),
      status?: string(name='Status'),
      userId?: string(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='GroupMembers'),
  isTruncated?: boolean(name='IsTruncated'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListGroupMembersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGroupMembersResponseBody(name='body'),
}

async function listGroupMembersWithOptions(request: ListGroupMembersRequest, runtime: Util.RuntimeOptions): ListGroupMembersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGroupMembers',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGroupMembers(request: ListGroupMembersRequest): ListGroupMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupMembersWithOptions(request, runtime);
}

model ListGroupsRequest {
  directoryId?: string(name='DirectoryId'),
  filter?: string(name='Filter'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  provisionType?: string(name='ProvisionType'),
}

model ListGroupsResponseBody = {
  groups?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      provisionType?: string(name='ProvisionType'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Groups'),
  isTruncated?: boolean(name='IsTruncated'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGroupsResponseBody(name='body'),
}

async function listGroupsWithOptions(request: ListGroupsRequest, runtime: Util.RuntimeOptions): ListGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.provisionType)) {
    query['ProvisionType'] = request.provisionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGroups',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupsWithOptions(request, runtime);
}

model ListJoinedGroupsForUserRequest {
  directoryId?: string(name='DirectoryId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  userId?: string(name='UserId'),
}

model ListJoinedGroupsForUserResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  joinedGroups?: [ 
    {
      description?: string(name='Description'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      joinTime?: string(name='JoinTime'),
      provisionType?: string(name='ProvisionType'),
      userId?: string(name='UserId'),
    }
  ](name='JoinedGroups'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListJoinedGroupsForUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJoinedGroupsForUserResponseBody(name='body'),
}

async function listJoinedGroupsForUserWithOptions(request: ListJoinedGroupsForUserRequest, runtime: Util.RuntimeOptions): ListJoinedGroupsForUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJoinedGroupsForUser',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJoinedGroupsForUser(request: ListJoinedGroupsForUserRequest): ListJoinedGroupsForUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJoinedGroupsForUserWithOptions(request, runtime);
}

model ListMFADevicesForUserRequest {
  directoryId?: string(name='DirectoryId'),
  userId?: string(name='UserId'),
}

model ListMFADevicesForUserResponseBody = {
  MFADevices?: [ 
    {
      deviceId?: string(name='DeviceId'),
      deviceName?: string(name='DeviceName'),
      deviceType?: string(name='DeviceType'),
      effectiveTime?: string(name='EffectiveTime'),
      userId?: string(name='UserId'),
    }
  ](name='MFADevices'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListMFADevicesForUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMFADevicesForUserResponseBody(name='body'),
}

async function listMFADevicesForUserWithOptions(request: ListMFADevicesForUserRequest, runtime: Util.RuntimeOptions): ListMFADevicesForUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMFADevicesForUser',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMFADevicesForUser(request: ListMFADevicesForUserRequest): ListMFADevicesForUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMFADevicesForUserWithOptions(request, runtime);
}

model ListPermissionPoliciesInAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId'),
  directoryId?: string(name='DirectoryId'),
  permissionPolicyType?: string(name='PermissionPolicyType'),
}

model ListPermissionPoliciesInAccessConfigurationResponseBody = {
  permissionPolicies?: [ 
    {
      addTime?: string(name='AddTime'),
      permissionPolicyDocument?: string(name='PermissionPolicyDocument'),
      permissionPolicyName?: string(name='PermissionPolicyName'),
      permissionPolicyType?: string(name='PermissionPolicyType'),
    }
  ](name='PermissionPolicies'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListPermissionPoliciesInAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPermissionPoliciesInAccessConfigurationResponseBody(name='body'),
}

async function listPermissionPoliciesInAccessConfigurationWithOptions(request: ListPermissionPoliciesInAccessConfigurationRequest, runtime: Util.RuntimeOptions): ListPermissionPoliciesInAccessConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessConfigurationId)) {
    query['AccessConfigurationId'] = request.accessConfigurationId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.permissionPolicyType)) {
    query['PermissionPolicyType'] = request.permissionPolicyType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPermissionPoliciesInAccessConfiguration',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPermissionPoliciesInAccessConfiguration(request: ListPermissionPoliciesInAccessConfigurationRequest): ListPermissionPoliciesInAccessConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPermissionPoliciesInAccessConfigurationWithOptions(request, runtime);
}

model ListSCIMServerCredentialsRequest {
  directoryId?: string(name='DirectoryId'),
}

model ListSCIMServerCredentialsResponseBody = {
  requestId?: string(name='RequestId'),
  SCIMServerCredentials?: [ 
    {
      createTime?: string(name='CreateTime'),
      credentialId?: string(name='CredentialId'),
      credentialType?: string(name='CredentialType'),
      directoryId?: string(name='DirectoryId'),
      expireTime?: string(name='ExpireTime'),
      status?: string(name='Status'),
    }
  ](name='SCIMServerCredentials'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListSCIMServerCredentialsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSCIMServerCredentialsResponseBody(name='body'),
}

async function listSCIMServerCredentialsWithOptions(request: ListSCIMServerCredentialsRequest, runtime: Util.RuntimeOptions): ListSCIMServerCredentialsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSCIMServerCredentials',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSCIMServerCredentials(request: ListSCIMServerCredentialsRequest): ListSCIMServerCredentialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSCIMServerCredentialsWithOptions(request, runtime);
}

model ListTasksRequest {
  accessConfigurationId?: string(name='AccessConfigurationId'),
  directoryId?: string(name='DirectoryId'),
  filter?: string(name='Filter'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  principalId?: string(name='PrincipalId'),
  principalType?: string(name='PrincipalType'),
  status?: string(name='Status'),
  targetId?: string(name='TargetId'),
  targetType?: string(name='TargetType'),
  taskType?: string(name='TaskType'),
}

model ListTasksResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      accessConfigurationId?: string(name='AccessConfigurationId'),
      accessConfigurationName?: string(name='AccessConfigurationName'),
      endTime?: string(name='EndTime'),
      failureReason?: string(name='FailureReason'),
      principalId?: string(name='PrincipalId'),
      principalName?: string(name='PrincipalName'),
      principalType?: string(name='PrincipalType'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      targetId?: string(name='TargetId'),
      targetName?: string(name='TargetName'),
      targetPath?: string(name='TargetPath'),
      targetPathName?: string(name='TargetPathName'),
      targetType?: string(name='TargetType'),
      taskId?: string(name='TaskId'),
      taskType?: string(name='TaskType'),
    }
  ](name='Tasks'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTasksResponseBody(name='body'),
}

async function listTasksWithOptions(request: ListTasksRequest, runtime: Util.RuntimeOptions): ListTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessConfigurationId)) {
    query['AccessConfigurationId'] = request.accessConfigurationId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.principalId)) {
    query['PrincipalId'] = request.principalId;
  }
  if (!Util.isUnset(request.principalType)) {
    query['PrincipalType'] = request.principalType;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.targetId)) {
    query['TargetId'] = request.targetId;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTasks',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTasks(request: ListTasksRequest): ListTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTasksWithOptions(request, runtime);
}

model ListUsersRequest {
  directoryId?: string(name='DirectoryId'),
  filter?: string(name='Filter'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  provisionType?: string(name='ProvisionType'),
  status?: string(name='Status'),
}

model ListUsersResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
  users?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      displayName?: string(name='DisplayName'),
      email?: string(name='Email'),
      firstName?: string(name='FirstName'),
      lastName?: string(name='LastName'),
      provisionType?: string(name='ProvisionType'),
      status?: string(name='Status'),
      updateTime?: string(name='UpdateTime'),
      userId?: string(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='Users'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsersWithOptions(request: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.provisionType)) {
    query['ProvisionType'] = request.provisionType;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUsers',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model ProvisionAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId'),
  directoryId?: string(name='DirectoryId'),
  targetId?: string(name='TargetId'),
  targetType?: string(name='TargetType'),
}

model ProvisionAccessConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      accessConfigurationId?: string(name='AccessConfigurationId'),
      accessConfigurationName?: string(name='AccessConfigurationName'),
      status?: string(name='Status'),
      targetId?: string(name='TargetId'),
      targetName?: string(name='TargetName'),
      targetPath?: string(name='TargetPath'),
      targetPathName?: string(name='TargetPathName'),
      targetType?: string(name='TargetType'),
      taskId?: string(name='TaskId'),
      taskType?: string(name='TaskType'),
    }
  ](name='Tasks'),
}

model ProvisionAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ProvisionAccessConfigurationResponseBody(name='body'),
}

async function provisionAccessConfigurationWithOptions(request: ProvisionAccessConfigurationRequest, runtime: Util.RuntimeOptions): ProvisionAccessConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessConfigurationId)) {
    query['AccessConfigurationId'] = request.accessConfigurationId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.targetId)) {
    query['TargetId'] = request.targetId;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ProvisionAccessConfiguration',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function provisionAccessConfiguration(request: ProvisionAccessConfigurationRequest): ProvisionAccessConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return provisionAccessConfigurationWithOptions(request, runtime);
}

model RemoveExternalSAMLIdPCertificateRequest {
  certificateId?: string(name='CertificateId'),
  directoryId?: string(name='DirectoryId'),
}

model RemoveExternalSAMLIdPCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveExternalSAMLIdPCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveExternalSAMLIdPCertificateResponseBody(name='body'),
}

async function removeExternalSAMLIdPCertificateWithOptions(request: RemoveExternalSAMLIdPCertificateRequest, runtime: Util.RuntimeOptions): RemoveExternalSAMLIdPCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveExternalSAMLIdPCertificate',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeExternalSAMLIdPCertificate(request: RemoveExternalSAMLIdPCertificateRequest): RemoveExternalSAMLIdPCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeExternalSAMLIdPCertificateWithOptions(request, runtime);
}

model RemovePermissionPolicyFromAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId'),
  directoryId?: string(name='DirectoryId'),
  permissionPolicyName?: string(name='PermissionPolicyName'),
  permissionPolicyType?: string(name='PermissionPolicyType'),
}

model RemovePermissionPolicyFromAccessConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemovePermissionPolicyFromAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemovePermissionPolicyFromAccessConfigurationResponseBody(name='body'),
}

async function removePermissionPolicyFromAccessConfigurationWithOptions(request: RemovePermissionPolicyFromAccessConfigurationRequest, runtime: Util.RuntimeOptions): RemovePermissionPolicyFromAccessConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessConfigurationId)) {
    query['AccessConfigurationId'] = request.accessConfigurationId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.permissionPolicyName)) {
    query['PermissionPolicyName'] = request.permissionPolicyName;
  }
  if (!Util.isUnset(request.permissionPolicyType)) {
    query['PermissionPolicyType'] = request.permissionPolicyType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemovePermissionPolicyFromAccessConfiguration',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removePermissionPolicyFromAccessConfiguration(request: RemovePermissionPolicyFromAccessConfigurationRequest): RemovePermissionPolicyFromAccessConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return removePermissionPolicyFromAccessConfigurationWithOptions(request, runtime);
}

model RemoveUserFromGroupRequest {
  directoryId?: string(name='DirectoryId'),
  groupId?: string(name='GroupId'),
  userId?: string(name='UserId'),
}

model RemoveUserFromGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveUserFromGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveUserFromGroupResponseBody(name='body'),
}

async function removeUserFromGroupWithOptions(request: RemoveUserFromGroupRequest, runtime: Util.RuntimeOptions): RemoveUserFromGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveUserFromGroup',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeUserFromGroup(request: RemoveUserFromGroupRequest): RemoveUserFromGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeUserFromGroupWithOptions(request, runtime);
}

model ResetUserPasswordRequest {
  directoryId?: string(name='DirectoryId'),
  generateRandomPassword?: boolean(name='GenerateRandomPassword'),
  password?: string(name='Password'),
  requirePasswordResetForNextLogin?: boolean(name='RequirePasswordResetForNextLogin'),
  userId?: string(name='UserId'),
}

model ResetUserPasswordResponseBody = {
  newPassword?: string(name='NewPassword'),
  requestId?: string(name='RequestId'),
}

model ResetUserPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetUserPasswordResponseBody(name='body'),
}

async function resetUserPasswordWithOptions(request: ResetUserPasswordRequest, runtime: Util.RuntimeOptions): ResetUserPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.generateRandomPassword)) {
    query['GenerateRandomPassword'] = request.generateRandomPassword;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.requirePasswordResetForNextLogin)) {
    query['RequirePasswordResetForNextLogin'] = request.requirePasswordResetForNextLogin;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetUserPassword',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetUserPassword(request: ResetUserPasswordRequest): ResetUserPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetUserPasswordWithOptions(request, runtime);
}

model SetExternalSAMLIdentityProviderRequest {
  directoryId?: string(name='DirectoryId'),
  encodedMetadataDocument?: string(name='EncodedMetadataDocument'),
  entityId?: string(name='EntityId'),
  loginUrl?: string(name='LoginUrl'),
  SSOStatus?: string(name='SSOStatus'),
  wantRequestSigned?: boolean(name='WantRequestSigned'),
  x509Certificate?: string(name='X509Certificate'),
}

model SetExternalSAMLIdentityProviderResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLIdentityProviderConfiguration?: {
    certificateIds?: [ string ](name='CertificateIds'),
    createTime?: string(name='CreateTime'),
    directoryId?: string(name='DirectoryId'),
    encodedMetadataDocument?: string(name='EncodedMetadataDocument'),
    entityId?: string(name='EntityId'),
    loginUrl?: string(name='LoginUrl'),
    SSOStatus?: string(name='SSOStatus'),
    updateTime?: string(name='UpdateTime'),
    wantRequestSigned?: boolean(name='WantRequestSigned'),
  }(name='SAMLIdentityProviderConfiguration'),
}

model SetExternalSAMLIdentityProviderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetExternalSAMLIdentityProviderResponseBody(name='body'),
}

async function setExternalSAMLIdentityProviderWithOptions(request: SetExternalSAMLIdentityProviderRequest, runtime: Util.RuntimeOptions): SetExternalSAMLIdentityProviderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.encodedMetadataDocument)) {
    query['EncodedMetadataDocument'] = request.encodedMetadataDocument;
  }
  if (!Util.isUnset(request.entityId)) {
    query['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.loginUrl)) {
    query['LoginUrl'] = request.loginUrl;
  }
  if (!Util.isUnset(request.SSOStatus)) {
    query['SSOStatus'] = request.SSOStatus;
  }
  if (!Util.isUnset(request.wantRequestSigned)) {
    query['WantRequestSigned'] = request.wantRequestSigned;
  }
  if (!Util.isUnset(request.x509Certificate)) {
    query['X509Certificate'] = request.x509Certificate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetExternalSAMLIdentityProvider',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setExternalSAMLIdentityProvider(request: SetExternalSAMLIdentityProviderRequest): SetExternalSAMLIdentityProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return setExternalSAMLIdentityProviderWithOptions(request, runtime);
}

model SetMFAAuthenticationStatusRequest {
  directoryId?: string(name='DirectoryId'),
  MFAAuthenticationStatus?: string(name='MFAAuthenticationStatus'),
}

model SetMFAAuthenticationStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetMFAAuthenticationStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetMFAAuthenticationStatusResponseBody(name='body'),
}

async function setMFAAuthenticationStatusWithOptions(request: SetMFAAuthenticationStatusRequest, runtime: Util.RuntimeOptions): SetMFAAuthenticationStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.MFAAuthenticationStatus)) {
    query['MFAAuthenticationStatus'] = request.MFAAuthenticationStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetMFAAuthenticationStatus',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setMFAAuthenticationStatus(request: SetMFAAuthenticationStatusRequest): SetMFAAuthenticationStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setMFAAuthenticationStatusWithOptions(request, runtime);
}

model SetSCIMSynchronizationStatusRequest {
  directoryId?: string(name='DirectoryId'),
  SCIMSynchronizationStatus?: string(name='SCIMSynchronizationStatus'),
}

model SetSCIMSynchronizationStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetSCIMSynchronizationStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetSCIMSynchronizationStatusResponseBody(name='body'),
}

async function setSCIMSynchronizationStatusWithOptions(request: SetSCIMSynchronizationStatusRequest, runtime: Util.RuntimeOptions): SetSCIMSynchronizationStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.SCIMSynchronizationStatus)) {
    query['SCIMSynchronizationStatus'] = request.SCIMSynchronizationStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetSCIMSynchronizationStatus',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setSCIMSynchronizationStatus(request: SetSCIMSynchronizationStatusRequest): SetSCIMSynchronizationStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setSCIMSynchronizationStatusWithOptions(request, runtime);
}

model UpdateAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId'),
  directoryId?: string(name='DirectoryId'),
  newDescription?: string(name='NewDescription'),
  newRelayState?: string(name='NewRelayState'),
  newSessionDuration?: int32(name='NewSessionDuration'),
}

model UpdateAccessConfigurationResponseBody = {
  accessConfiguration?: {
    accessConfigurationId?: string(name='AccessConfigurationId'),
    accessConfigurationName?: string(name='AccessConfigurationName'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    relayState?: string(name='RelayState'),
    sessionDuration?: int32(name='SessionDuration'),
    statusNotifications?: [ string ](name='StatusNotifications'),
    updateTime?: string(name='UpdateTime'),
  }(name='AccessConfiguration'),
  requestId?: string(name='RequestId'),
}

model UpdateAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAccessConfigurationResponseBody(name='body'),
}

async function updateAccessConfigurationWithOptions(request: UpdateAccessConfigurationRequest, runtime: Util.RuntimeOptions): UpdateAccessConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessConfigurationId)) {
    query['AccessConfigurationId'] = request.accessConfigurationId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.newDescription)) {
    query['NewDescription'] = request.newDescription;
  }
  if (!Util.isUnset(request.newRelayState)) {
    query['NewRelayState'] = request.newRelayState;
  }
  if (!Util.isUnset(request.newSessionDuration)) {
    query['NewSessionDuration'] = request.newSessionDuration;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAccessConfiguration',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAccessConfiguration(request: UpdateAccessConfigurationRequest): UpdateAccessConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAccessConfigurationWithOptions(request, runtime);
}

model UpdateDirectoryRequest {
  directoryId?: string(name='DirectoryId'),
  newDirectoryName?: string(name='NewDirectoryName'),
}

model UpdateDirectoryResponseBody = {
  directory?: {
    createTime?: string(name='CreateTime'),
    directoryId?: string(name='DirectoryId'),
    directoryName?: string(name='DirectoryName'),
    region?: string(name='Region'),
    updateTime?: string(name='UpdateTime'),
  }(name='Directory'),
  requestId?: string(name='RequestId'),
}

model UpdateDirectoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDirectoryResponseBody(name='body'),
}

async function updateDirectoryWithOptions(request: UpdateDirectoryRequest, runtime: Util.RuntimeOptions): UpdateDirectoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.newDirectoryName)) {
    query['NewDirectoryName'] = request.newDirectoryName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDirectory',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDirectory(request: UpdateDirectoryRequest): UpdateDirectoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDirectoryWithOptions(request, runtime);
}

model UpdateGroupRequest {
  directoryId?: string(name='DirectoryId'),
  groupId?: string(name='GroupId'),
  newDescription?: string(name='NewDescription'),
  newGroupName?: string(name='NewGroupName'),
}

model UpdateGroupResponseBody = {
  group?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    provisionType?: string(name='ProvisionType'),
    updateTime?: string(name='UpdateTime'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model UpdateGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGroupResponseBody(name='body'),
}

async function updateGroupWithOptions(request: UpdateGroupRequest, runtime: Util.RuntimeOptions): UpdateGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.newDescription)) {
    query['NewDescription'] = request.newDescription;
  }
  if (!Util.isUnset(request.newGroupName)) {
    query['NewGroupName'] = request.newGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGroup',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGroup(request: UpdateGroupRequest): UpdateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGroupWithOptions(request, runtime);
}

model UpdateInlinePolicyForAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId'),
  directoryId?: string(name='DirectoryId'),
  inlinePolicyName?: string(name='InlinePolicyName'),
  newInlinePolicyDocument?: string(name='NewInlinePolicyDocument'),
}

model UpdateInlinePolicyForAccessConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateInlinePolicyForAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInlinePolicyForAccessConfigurationResponseBody(name='body'),
}

async function updateInlinePolicyForAccessConfigurationWithOptions(request: UpdateInlinePolicyForAccessConfigurationRequest, runtime: Util.RuntimeOptions): UpdateInlinePolicyForAccessConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessConfigurationId)) {
    query['AccessConfigurationId'] = request.accessConfigurationId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.inlinePolicyName)) {
    query['InlinePolicyName'] = request.inlinePolicyName;
  }
  if (!Util.isUnset(request.newInlinePolicyDocument)) {
    query['NewInlinePolicyDocument'] = request.newInlinePolicyDocument;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInlinePolicyForAccessConfiguration',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateInlinePolicyForAccessConfiguration(request: UpdateInlinePolicyForAccessConfigurationRequest): UpdateInlinePolicyForAccessConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateInlinePolicyForAccessConfigurationWithOptions(request, runtime);
}

model UpdateMFAAuthenticationSettingsRequest {
  directoryId?: string(name='DirectoryId'),
  MFAAuthenticationSettings?: string(name='MFAAuthenticationSettings'),
  operationForRiskLogin?: string(name='OperationForRiskLogin'),
}

model UpdateMFAAuthenticationSettingsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMFAAuthenticationSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMFAAuthenticationSettingsResponseBody(name='body'),
}

async function updateMFAAuthenticationSettingsWithOptions(request: UpdateMFAAuthenticationSettingsRequest, runtime: Util.RuntimeOptions): UpdateMFAAuthenticationSettingsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.MFAAuthenticationSettings)) {
    query['MFAAuthenticationSettings'] = request.MFAAuthenticationSettings;
  }
  if (!Util.isUnset(request.operationForRiskLogin)) {
    query['OperationForRiskLogin'] = request.operationForRiskLogin;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMFAAuthenticationSettings',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMFAAuthenticationSettings(request: UpdateMFAAuthenticationSettingsRequest): UpdateMFAAuthenticationSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMFAAuthenticationSettingsWithOptions(request, runtime);
}

model UpdateSCIMServerCredentialStatusRequest {
  credentialId?: string(name='CredentialId'),
  directoryId?: string(name='DirectoryId'),
  newStatus?: string(name='NewStatus'),
}

model UpdateSCIMServerCredentialStatusResponseBody = {
  requestId?: string(name='RequestId'),
  SCIMServerCredential?: {
    createTime?: string(name='CreateTime'),
    credentialId?: string(name='CredentialId'),
    credentialType?: string(name='CredentialType'),
    directoryId?: string(name='DirectoryId'),
    expireTime?: string(name='ExpireTime'),
    status?: string(name='Status'),
  }(name='SCIMServerCredential'),
}

model UpdateSCIMServerCredentialStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSCIMServerCredentialStatusResponseBody(name='body'),
}

async function updateSCIMServerCredentialStatusWithOptions(request: UpdateSCIMServerCredentialStatusRequest, runtime: Util.RuntimeOptions): UpdateSCIMServerCredentialStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.credentialId)) {
    query['CredentialId'] = request.credentialId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.newStatus)) {
    query['NewStatus'] = request.newStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSCIMServerCredentialStatus',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSCIMServerCredentialStatus(request: UpdateSCIMServerCredentialStatusRequest): UpdateSCIMServerCredentialStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSCIMServerCredentialStatusWithOptions(request, runtime);
}

model UpdateUserRequest {
  directoryId?: string(name='DirectoryId'),
  newDescription?: string(name='NewDescription'),
  newDisplayName?: string(name='NewDisplayName'),
  newEmail?: string(name='NewEmail'),
  newFirstName?: string(name='NewFirstName'),
  newLastName?: string(name='NewLastName'),
  userId?: string(name='UserId'),
}

model UpdateUserResponseBody = {
  requestId?: string(name='RequestId'),
  user?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    displayName?: string(name='DisplayName'),
    email?: string(name='Email'),
    firstName?: string(name='FirstName'),
    lastName?: string(name='LastName'),
    provisionType?: string(name='ProvisionType'),
    status?: string(name='Status'),
    updateTime?: string(name='UpdateTime'),
    userId?: string(name='UserId'),
    userName?: string(name='UserName'),
  }(name='User'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateUserResponseBody(name='body'),
}

async function updateUserWithOptions(request: UpdateUserRequest, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.newDescription)) {
    query['NewDescription'] = request.newDescription;
  }
  if (!Util.isUnset(request.newDisplayName)) {
    query['NewDisplayName'] = request.newDisplayName;
  }
  if (!Util.isUnset(request.newEmail)) {
    query['NewEmail'] = request.newEmail;
  }
  if (!Util.isUnset(request.newFirstName)) {
    query['NewFirstName'] = request.newFirstName;
  }
  if (!Util.isUnset(request.newLastName)) {
    query['NewLastName'] = request.newLastName;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUser',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserWithOptions(request, runtime);
}

model UpdateUserMFAAuthenticationSettingsRequest {
  directoryId?: string(name='DirectoryId'),
  userId?: string(name='UserId'),
  userMFAAuthenticationSettings?: string(name='UserMFAAuthenticationSettings'),
}

model UpdateUserMFAAuthenticationSettingsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateUserMFAAuthenticationSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateUserMFAAuthenticationSettingsResponseBody(name='body'),
}

async function updateUserMFAAuthenticationSettingsWithOptions(request: UpdateUserMFAAuthenticationSettingsRequest, runtime: Util.RuntimeOptions): UpdateUserMFAAuthenticationSettingsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userMFAAuthenticationSettings)) {
    query['UserMFAAuthenticationSettings'] = request.userMFAAuthenticationSettings;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUserMFAAuthenticationSettings',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUserMFAAuthenticationSettings(request: UpdateUserMFAAuthenticationSettingsRequest): UpdateUserMFAAuthenticationSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserMFAAuthenticationSettingsWithOptions(request, runtime);
}

model UpdateUserStatusRequest {
  directoryId?: string(name='DirectoryId'),
  newStatus?: string(name='NewStatus'),
  userId?: string(name='UserId'),
}

model UpdateUserStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateUserStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateUserStatusResponseBody(name='body'),
}

async function updateUserStatusWithOptions(request: UpdateUserStatusRequest, runtime: Util.RuntimeOptions): UpdateUserStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.newStatus)) {
    query['NewStatus'] = request.newStatus;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUserStatus',
    version = '2021-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUserStatus(request: UpdateUserStatusRequest): UpdateUserStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserStatusWithOptions(request, runtime);
}

