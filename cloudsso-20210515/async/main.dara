/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'cloudsso';
  @version = '2021-05-15';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AddExternalSAMLIdPCertificateRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  x509Certificate?: string(name='X509Certificate', position='Query'),
}

model AddExternalSAMLIdPCertificateResponseBody = {
  certificateId?: string(name='CertificateId'),
  requestId?: string(name='RequestId'),
}

model AddExternalSAMLIdPCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: AddExternalSAMLIdPCertificateResponseBody(name='body'),
}

async function addExternalSAMLIdPCertificate(request: AddExternalSAMLIdPCertificateRequest): AddExternalSAMLIdPCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddExternalSAMLIdPCertificate', 'POST', '/', 'json', false, 'json', request);
}

model AddPermissionPolicyToAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  inlinePolicyDocument?: string(name='InlinePolicyDocument', position='Query'),
  permissionPolicyName?: string(name='PermissionPolicyName', position='Query'),
  permissionPolicyType?: string(name='PermissionPolicyType', position='Query'),
}

model AddPermissionPolicyToAccessConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddPermissionPolicyToAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: AddPermissionPolicyToAccessConfigurationResponseBody(name='body'),
}

async function addPermissionPolicyToAccessConfiguration(request: AddPermissionPolicyToAccessConfigurationRequest): AddPermissionPolicyToAccessConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddPermissionPolicyToAccessConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model AddUserToGroupRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model AddUserToGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddUserToGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserToGroupResponseBody(name='body'),
}

async function addUserToGroup(request: AddUserToGroupRequest): AddUserToGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddUserToGroup', 'POST', '/', 'json', false, 'json', request);
}

model ClearExternalSAMLIdentityProviderRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
}

model ClearExternalSAMLIdentityProviderResponseBody = {
  requestId?: string(name='RequestId'),
}

model ClearExternalSAMLIdentityProviderResponse = {
  headers: map[string]string(name='headers'),
  body: ClearExternalSAMLIdentityProviderResponseBody(name='body'),
}

async function clearExternalSAMLIdentityProvider(request: ClearExternalSAMLIdentityProviderRequest): ClearExternalSAMLIdentityProviderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ClearExternalSAMLIdentityProvider', 'POST', '/', 'json', false, 'json', request);
}

model CreateAccessAssignmentRequest {
  accessConfigurationId?: string(name='AccessConfigurationId', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  principalId?: string(name='PrincipalId', position='Query'),
  principalType?: string(name='PrincipalType', position='Query'),
  targetId?: string(name='TargetId', position='Query'),
  targetType?: string(name='TargetType', position='Query'),
}

model CreateAccessAssignmentResponseBody = {
  requestId?: string(name='RequestId'),
  task?: {
    accessConfigurationId?: string(name='AccessConfigurationId'),
    accessConfigurationName?: string(name='AccessConfigurationName'),
    principalId?: string(name='PrincipalId'),
    principalName?: string(name='PrincipalName'),
    principalType?: string(name='PrincipalType'),
    status?: string(name='Status'),
    targetId?: string(name='TargetId'),
    targetName?: string(name='TargetName'),
    targetPath?: string(name='TargetPath'),
    targetPathName?: string(name='TargetPathName'),
    targetType?: string(name='TargetType'),
    taskId?: string(name='TaskId'),
    taskType?: string(name='TaskType'),
  }(name='Task'),
}

model CreateAccessAssignmentResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAccessAssignmentResponseBody(name='body'),
}

async function createAccessAssignment(request: CreateAccessAssignmentRequest): CreateAccessAssignmentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAccessAssignment', 'POST', '/', 'json', false, 'json', request);
}

model CreateAccessConfigurationRequest {
  accessConfigurationName?: string(name='AccessConfigurationName', position='Query'),
  description?: string(name='Description', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  relayState?: string(name='RelayState', position='Query'),
  sessionDuration?: int32(name='SessionDuration', position='Query'),
}

model CreateAccessConfigurationResponseBody = {
  accessConfiguration?: {
    accessConfigurationId?: string(name='AccessConfigurationId'),
    accessConfigurationName?: string(name='AccessConfigurationName'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    relayState?: string(name='RelayState'),
    sessionDuration?: int32(name='SessionDuration'),
    statusNotifications?: [ string ](name='StatusNotifications'),
    updateTime?: string(name='UpdateTime'),
  }(name='AccessConfiguration'),
  requestId?: string(name='RequestId'),
}

model CreateAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAccessConfigurationResponseBody(name='body'),
}

async function createAccessConfiguration(request: CreateAccessConfigurationRequest): CreateAccessConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAccessConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model CreateDirectoryRequest {
  directoryName?: string(name='DirectoryName', position='Query'),
}

model CreateDirectoryResponseBody = {
  directory?: {
    createTime?: string(name='CreateTime'),
    directoryId?: string(name='DirectoryId'),
    directoryName?: string(name='DirectoryName'),
    region?: string(name='Region'),
    updateTime?: string(name='UpdateTime'),
  }(name='Directory'),
  requestId?: string(name='RequestId'),
}

model CreateDirectoryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDirectoryResponseBody(name='body'),
}

async function createDirectory(request: CreateDirectoryRequest): CreateDirectoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDirectory', 'POST', '/', 'json', false, 'json', request);
}

model CreateGroupRequest {
  description?: string(name='Description', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  groupName?: string(name='GroupName', position='Query'),
}

model CreateGroupResponseBody = {
  group?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    provisionType?: string(name='ProvisionType'),
    updateTime?: string(name='UpdateTime'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model CreateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGroupResponseBody(name='body'),
}

async function createGroup(request: CreateGroupRequest): CreateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateSCIMServerCredentialRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
}

model CreateSCIMServerCredentialResponseBody = {
  requestId?: string(name='RequestId'),
  SCIMServerCredential?: {
    createTime?: string(name='CreateTime'),
    credentialId?: string(name='CredentialId'),
    credentialSecret?: string(name='CredentialSecret'),
    credentialType?: string(name='CredentialType'),
    directoryId?: string(name='DirectoryId'),
    expireTime?: string(name='ExpireTime'),
    status?: string(name='Status'),
  }(name='SCIMServerCredential'),
}

model CreateSCIMServerCredentialResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSCIMServerCredentialResponseBody(name='body'),
}

async function createSCIMServerCredential(request: CreateSCIMServerCredentialRequest): CreateSCIMServerCredentialResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSCIMServerCredential', 'POST', '/', 'json', false, 'json', request);
}

model CreateUserRequest {
  description?: string(name='Description', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  displayName?: string(name='DisplayName', position='Query'),
  email?: string(name='Email', position='Query'),
  firstName?: string(name='FirstName', position='Query'),
  lastName?: string(name='LastName', position='Query'),
  status?: string(name='Status', position='Query'),
  userName?: string(name='UserName', position='Query'),
}

model CreateUserResponseBody = {
  requestId?: string(name='RequestId'),
  user?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    displayName?: string(name='DisplayName'),
    email?: string(name='Email'),
    firstName?: string(name='FirstName'),
    lastName?: string(name='LastName'),
    provisionType?: string(name='ProvisionType'),
    status?: string(name='Status'),
    updateTime?: string(name='UpdateTime'),
    userId?: string(name='UserId'),
    userName?: string(name='UserName'),
  }(name='User'),
}

model CreateUserResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUserResponseBody(name='body'),
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUser', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAccessAssignmentRequest {
  accessConfigurationId?: string(name='AccessConfigurationId', position='Query'),
  deprovisionStrategy?: string(name='DeprovisionStrategy', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  principalId?: string(name='PrincipalId', position='Query'),
  principalType?: string(name='PrincipalType', position='Query'),
  targetId?: string(name='TargetId', position='Query'),
  targetType?: string(name='TargetType', position='Query'),
}

model DeleteAccessAssignmentResponseBody = {
  requestId?: string(name='RequestId'),
  task?: {
    accessConfigurationId?: string(name='AccessConfigurationId'),
    accessConfigurationName?: string(name='AccessConfigurationName'),
    principalId?: string(name='PrincipalId'),
    principalName?: string(name='PrincipalName'),
    principalType?: string(name='PrincipalType'),
    status?: string(name='Status'),
    targetId?: string(name='TargetId'),
    targetName?: string(name='TargetName'),
    targetPath?: string(name='TargetPath'),
    targetPathName?: string(name='TargetPathName'),
    targetType?: string(name='TargetType'),
    taskId?: string(name='TaskId'),
    taskType?: string(name='TaskType'),
  }(name='Task'),
}

model DeleteAccessAssignmentResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAccessAssignmentResponseBody(name='body'),
}

async function deleteAccessAssignment(request: DeleteAccessAssignmentRequest): DeleteAccessAssignmentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAccessAssignment', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  forceRemovePermissionPolicies?: boolean(name='ForceRemovePermissionPolicies', position='Query'),
}

model DeleteAccessConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAccessConfigurationResponseBody(name='body'),
}

async function deleteAccessConfiguration(request: DeleteAccessConfigurationRequest): DeleteAccessConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAccessConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDirectoryRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
}

model DeleteDirectoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDirectoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDirectoryResponseBody(name='body'),
}

async function deleteDirectory(request: DeleteDirectoryRequest): DeleteDirectoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDirectory', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGroupRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
}

model DeleteGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGroupResponseBody(name='body'),
}

async function deleteGroup(request: DeleteGroupRequest): DeleteGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMFADeviceForUserRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  MFADeviceId?: string(name='MFADeviceId', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model DeleteMFADeviceForUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMFADeviceForUserResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMFADeviceForUserResponseBody(name='body'),
}

async function deleteMFADeviceForUser(request: DeleteMFADeviceForUserRequest): DeleteMFADeviceForUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMFADeviceForUser', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSCIMServerCredentialRequest {
  credentialId?: string(name='CredentialId', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
}

model DeleteSCIMServerCredentialResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSCIMServerCredentialResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSCIMServerCredentialResponseBody(name='body'),
}

async function deleteSCIMServerCredential(request: DeleteSCIMServerCredentialRequest): DeleteSCIMServerCredentialResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSCIMServerCredential', 'POST', '/', 'json', false, 'json', request);
}

model DeleteUserRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model DeleteUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteUser', 'POST', '/', 'json', false, 'json', request);
}

model DeprovisionAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  targetId?: string(name='TargetId', position='Query'),
  targetType?: string(name='TargetType', position='Query'),
}

model DeprovisionAccessConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      accessConfigurationId?: string(name='AccessConfigurationId'),
      accessConfigurationName?: string(name='AccessConfigurationName'),
      status?: string(name='Status'),
      targetId?: string(name='TargetId'),
      targetName?: string(name='TargetName'),
      targetPath?: string(name='TargetPath'),
      targetPathName?: string(name='TargetPathName'),
      targetType?: string(name='TargetType'),
      taskId?: string(name='TaskId'),
      taskType?: string(name='TaskType'),
    }
  ](name='Tasks'),
}

model DeprovisionAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: DeprovisionAccessConfigurationResponseBody(name='body'),
}

async function deprovisionAccessConfiguration(request: DeprovisionAccessConfigurationRequest): DeprovisionAccessConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeprovisionAccessConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model DisableServiceRequest {
}

model DisableServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DisableServiceResponseBody(name='body'),
}

async function disableService(request: DisableServiceRequest): DisableServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableService', 'POST', '/', 'json', false, 'json', request);
}

model EnableServiceRequest {
}

model EnableServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableServiceResponse = {
  headers: map[string]string(name='headers'),
  body: EnableServiceResponseBody(name='body'),
}

async function enableService(request: EnableServiceRequest): EnableServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableService', 'POST', '/', 'json', false, 'json', request);
}

model GetAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
}

model GetAccessConfigurationResponseBody = {
  accessConfiguration?: {
    accessConfigurationId?: string(name='AccessConfigurationId'),
    accessConfigurationName?: string(name='AccessConfigurationName'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    relayState?: string(name='RelayState'),
    sessionDuration?: int32(name='SessionDuration'),
    statusNotifications?: [ string ](name='StatusNotifications'),
    updateTime?: string(name='UpdateTime'),
  }(name='AccessConfiguration'),
  requestId?: string(name='RequestId'),
}

model GetAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: GetAccessConfigurationResponseBody(name='body'),
}

async function getAccessConfiguration(request: GetAccessConfigurationRequest): GetAccessConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAccessConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model GetDirectoryRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
}

model GetDirectoryResponseBody = {
  directory?: {
    createTime?: string(name='CreateTime'),
    directoryId?: string(name='DirectoryId'),
    directoryName?: string(name='DirectoryName'),
    region?: string(name='Region'),
    updateTime?: string(name='UpdateTime'),
  }(name='Directory'),
  requestId?: string(name='RequestId'),
}

model GetDirectoryResponse = {
  headers: map[string]string(name='headers'),
  body: GetDirectoryResponseBody(name='body'),
}

async function getDirectory(request: GetDirectoryRequest): GetDirectoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDirectory', 'POST', '/', 'json', false, 'json', request);
}

model GetDirectorySAMLServiceProviderInfoRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
}

model GetDirectorySAMLServiceProviderInfoResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLServiceProvider?: {
    acsUrl?: string(name='AcsUrl'),
    directoryId?: string(name='DirectoryId'),
    encodedMetadataDocument?: string(name='EncodedMetadataDocument'),
    entityId?: string(name='EntityId'),
  }(name='SAMLServiceProvider'),
}

model GetDirectorySAMLServiceProviderInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetDirectorySAMLServiceProviderInfoResponseBody(name='body'),
}

async function getDirectorySAMLServiceProviderInfo(request: GetDirectorySAMLServiceProviderInfoRequest): GetDirectorySAMLServiceProviderInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDirectorySAMLServiceProviderInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetDirectoryStatisticsRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
}

model GetDirectoryStatisticsResponseBody = {
  directoryStatistics?: {
    accessAssignmentCount?: int32(name='AccessAssignmentCount'),
    accessConfigurationCount?: int32(name='AccessConfigurationCount'),
    accessConfigurationQuota?: int32(name='AccessConfigurationQuota'),
    directoryId?: string(name='DirectoryId'),
    directoryName?: string(name='DirectoryName'),
    groupCount?: int32(name='GroupCount'),
    groupQuota?: int32(name='GroupQuota'),
    inProgressTaskCount?: int32(name='InProgressTaskCount'),
    region?: string(name='Region'),
    SCIMServerCredentialCount?: int32(name='SCIMServerCredentialCount'),
    SCIMSyncEnabled?: boolean(name='SCIMSyncEnabled'),
    SSOEnabled?: boolean(name='SSOEnabled'),
    userCount?: int32(name='UserCount'),
    userQuota?: int32(name='UserQuota'),
  }(name='DirectoryStatistics'),
  requestId?: string(name='RequestId'),
}

model GetDirectoryStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: GetDirectoryStatisticsResponseBody(name='body'),
}

async function getDirectoryStatistics(request: GetDirectoryStatisticsRequest): GetDirectoryStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDirectoryStatistics', 'POST', '/', 'json', false, 'json', request);
}

model GetExternalSAMLIdentityProviderRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
}

model GetExternalSAMLIdentityProviderResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLIdentityProviderConfiguration?: {
    certificateIds?: [ string ](name='CertificateIds'),
    createTime?: string(name='CreateTime'),
    directoryId?: string(name='DirectoryId'),
    encodedMetadataDocument?: string(name='EncodedMetadataDocument'),
    entityId?: string(name='EntityId'),
    loginUrl?: string(name='LoginUrl'),
    SSOStatus?: string(name='SSOStatus'),
    updateTime?: string(name='UpdateTime'),
    wantRequestSigned?: boolean(name='WantRequestSigned'),
  }(name='SAMLIdentityProviderConfiguration'),
}

model GetExternalSAMLIdentityProviderResponse = {
  headers: map[string]string(name='headers'),
  body: GetExternalSAMLIdentityProviderResponseBody(name='body'),
}

async function getExternalSAMLIdentityProvider(request: GetExternalSAMLIdentityProviderRequest): GetExternalSAMLIdentityProviderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetExternalSAMLIdentityProvider', 'POST', '/', 'json', false, 'json', request);
}

model GetGroupRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
}

model GetGroupResponseBody = {
  group?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    provisionType?: string(name='ProvisionType'),
    updateTime?: string(name='UpdateTime'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model GetGroupResponse = {
  headers: map[string]string(name='headers'),
  body: GetGroupResponseBody(name='body'),
}

async function getGroup(request: GetGroupRequest): GetGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetGroup', 'POST', '/', 'json', false, 'json', request);
}

model GetMFAAuthenticationSettingsRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
}

model GetMFAAuthenticationSettingsResponseBody = {
  MFAAuthenticationAdvanceSettings?: string(name='MFAAuthenticationAdvanceSettings'),
  requestId?: string(name='RequestId'),
}

model GetMFAAuthenticationSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: GetMFAAuthenticationSettingsResponseBody(name='body'),
}

async function getMFAAuthenticationSettings(request: GetMFAAuthenticationSettingsRequest): GetMFAAuthenticationSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMFAAuthenticationSettings', 'POST', '/', 'json', false, 'json', request);
}

model GetMFAAuthenticationStatusRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
}

model GetMFAAuthenticationStatusResponseBody = {
  MFAAuthenticationStatus?: string(name='MFAAuthenticationStatus'),
  requestId?: string(name='RequestId'),
}

model GetMFAAuthenticationStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetMFAAuthenticationStatusResponseBody(name='body'),
}

async function getMFAAuthenticationStatus(request: GetMFAAuthenticationStatusRequest): GetMFAAuthenticationStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMFAAuthenticationStatus', 'POST', '/', 'json', false, 'json', request);
}

model GetSCIMSynchronizationStatusRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
}

model GetSCIMSynchronizationStatusResponseBody = {
  requestId?: string(name='RequestId'),
  SCIMSynchronizationStatus?: string(name='SCIMSynchronizationStatus'),
}

model GetSCIMSynchronizationStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetSCIMSynchronizationStatusResponseBody(name='body'),
}

async function getSCIMSynchronizationStatus(request: GetSCIMSynchronizationStatusRequest): GetSCIMSynchronizationStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSCIMSynchronizationStatus', 'POST', '/', 'json', false, 'json', request);
}

model GetServiceStatusRequest {
}

model GetServiceStatusResponseBody = {
  requestId?: string(name='RequestId'),
  serviceStatus?: {
    accountId?: string(name='AccountId'),
    prerequisiteCheckResult?: string(name='PrerequisiteCheckResult'),
    regionsInUse?: [ string ](name='RegionsInUse'),
    status?: string(name='Status'),
  }(name='ServiceStatus'),
}

model GetServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceStatusResponseBody(name='body'),
}

async function getServiceStatus(request: GetServiceStatusRequest): GetServiceStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetServiceStatus', 'POST', '/', 'json', false, 'json', request);
}

model GetTaskRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  taskId?: string(name='TaskId', position='Query'),
}

model GetTaskResponseBody = {
  requestId?: string(name='RequestId'),
  task?: {
    accessConfigurationId?: string(name='AccessConfigurationId'),
    accessConfigurationName?: string(name='AccessConfigurationName'),
    endTime?: string(name='EndTime'),
    failureReason?: string(name='FailureReason'),
    principalId?: string(name='PrincipalId'),
    principalName?: string(name='PrincipalName'),
    principalType?: string(name='PrincipalType'),
    startTime?: string(name='StartTime'),
    status?: string(name='Status'),
    targetId?: string(name='TargetId'),
    targetName?: string(name='TargetName'),
    targetPath?: string(name='TargetPath'),
    targetPathName?: string(name='TargetPathName'),
    targetType?: string(name='TargetType'),
    taskId?: string(name='TaskId'),
    taskType?: string(name='TaskType'),
  }(name='Task'),
}

model GetTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetTaskResponseBody(name='body'),
}

async function getTask(request: GetTaskRequest): GetTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTask', 'POST', '/', 'json', false, 'json', request);
}

model GetTaskStatusRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  taskId?: string(name='TaskId', position='Query'),
}

model GetTaskStatusResponseBody = {
  requestId?: string(name='RequestId'),
  taskStatus?: {
    endTime?: string(name='EndTime'),
    failureReason?: string(name='FailureReason'),
    startTime?: string(name='StartTime'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
    taskType?: string(name='TaskType'),
  }(name='TaskStatus'),
}

model GetTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetTaskStatusResponseBody(name='body'),
}

async function getTaskStatus(request: GetTaskStatusRequest): GetTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTaskStatus', 'POST', '/', 'json', false, 'json', request);
}

model GetUserRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model GetUserResponseBody = {
  requestId?: string(name='RequestId'),
  user?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    displayName?: string(name='DisplayName'),
    email?: string(name='Email'),
    firstName?: string(name='FirstName'),
    lastName?: string(name='LastName'),
    provisionType?: string(name='ProvisionType'),
    status?: string(name='Status'),
    updateTime?: string(name='UpdateTime'),
    userId?: string(name='UserId'),
    userName?: string(name='UserName'),
  }(name='User'),
}

model GetUserResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserResponseBody(name='body'),
}

async function getUser(request: GetUserRequest): GetUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUser', 'POST', '/', 'json', false, 'json', request);
}

model GetUserMFAAuthenticationSettingsRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model GetUserMFAAuthenticationSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  userMFAAuthenticationSettings?: string(name='UserMFAAuthenticationSettings'),
}

model GetUserMFAAuthenticationSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserMFAAuthenticationSettingsResponseBody(name='body'),
}

async function getUserMFAAuthenticationSettings(request: GetUserMFAAuthenticationSettingsRequest): GetUserMFAAuthenticationSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserMFAAuthenticationSettings', 'POST', '/', 'json', false, 'json', request);
}

model ListAccessAssignmentsRequest {
  accessConfigurationId?: string(name='AccessConfigurationId', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  principalId?: string(name='PrincipalId', position='Query'),
  principalType?: string(name='PrincipalType', position='Query'),
  targetId?: string(name='TargetId', position='Query'),
  targetType?: string(name='TargetType', position='Query'),
}

model ListAccessAssignmentsResponseBody = {
  accessAssignments?: [ 
    {
      accessConfigurationId?: string(name='AccessConfigurationId'),
      accessConfigurationName?: string(name='AccessConfigurationName'),
      createTime?: string(name='CreateTime'),
      principalId?: string(name='PrincipalId'),
      principalName?: string(name='PrincipalName'),
      principalType?: string(name='PrincipalType'),
      targetId?: string(name='TargetId'),
      targetName?: string(name='TargetName'),
      targetPath?: string(name='TargetPath'),
      targetPathName?: string(name='TargetPathName'),
      targetType?: string(name='TargetType'),
    }
  ](name='AccessAssignments'),
  isTruncated?: boolean(name='IsTruncated'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListAccessAssignmentsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAccessAssignmentsResponseBody(name='body'),
}

async function listAccessAssignments(request: ListAccessAssignmentsRequest): ListAccessAssignmentsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAccessAssignments', 'POST', '/', 'json', false, 'json', request);
}

model ListAccessConfigurationProvisioningsRequest {
  accessConfigurationId?: string(name='AccessConfigurationId', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  provisioningStatus?: string(name='ProvisioningStatus', position='Query'),
  targetId?: string(name='TargetId', position='Query'),
  targetType?: string(name='TargetType', position='Query'),
}

model ListAccessConfigurationProvisioningsResponseBody = {
  accessConfigurationProvisionings?: [ 
    {
      accessConfigurationId?: string(name='AccessConfigurationId'),
      accessConfigurationName?: string(name='AccessConfigurationName'),
      createTime?: string(name='CreateTime'),
      RAMPolicyNames?: [ string ](name='RAMPolicyNames'),
      RAMRoleName?: string(name='RAMRoleName'),
      SAMLProviderName?: string(name='SAMLProviderName'),
      status?: string(name='Status'),
      targetId?: string(name='TargetId'),
      targetName?: string(name='TargetName'),
      targetPath?: string(name='TargetPath'),
      targetPathName?: string(name='TargetPathName'),
      targetType?: string(name='TargetType'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='AccessConfigurationProvisionings'),
  isTruncated?: boolean(name='IsTruncated'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListAccessConfigurationProvisioningsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAccessConfigurationProvisioningsResponseBody(name='body'),
}

async function listAccessConfigurationProvisionings(request: ListAccessConfigurationProvisioningsRequest): ListAccessConfigurationProvisioningsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAccessConfigurationProvisionings', 'POST', '/', 'json', false, 'json', request);
}

model ListAccessConfigurationsRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  filter?: string(name='Filter', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  statusNotifications?: string(name='StatusNotifications', position='Query'),
}

model ListAccessConfigurationsResponseBody = {
  accessConfigurations?: [ 
    {
      accessConfigurationId?: string(name='AccessConfigurationId'),
      accessConfigurationName?: string(name='AccessConfigurationName'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      relayState?: string(name='RelayState'),
      sessionDuration?: int32(name='SessionDuration'),
      statusNotifications?: [ string ](name='StatusNotifications'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='AccessConfigurations'),
  isTruncated?: boolean(name='IsTruncated'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListAccessConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAccessConfigurationsResponseBody(name='body'),
}

async function listAccessConfigurations(request: ListAccessConfigurationsRequest): ListAccessConfigurationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAccessConfigurations', 'POST', '/', 'json', false, 'json', request);
}

model ListDirectoriesRequest {
}

model ListDirectoriesResponseBody = {
  directories?: [ 
    {
      createTime?: string(name='CreateTime'),
      directoryId?: string(name='DirectoryId'),
      directoryName?: string(name='DirectoryName'),
      region?: string(name='Region'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Directories'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListDirectoriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDirectoriesResponseBody(name='body'),
}

async function listDirectories(request: ListDirectoriesRequest): ListDirectoriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDirectories', 'POST', '/', 'json', false, 'json', request);
}

model ListExternalSAMLIdPCertificatesRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
}

model ListExternalSAMLIdPCertificatesResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLIdPCertificates?: [ 
    {
      certificateId?: string(name='CertificateId'),
      issuer?: string(name='Issuer'),
      notAfter?: string(name='NotAfter'),
      notBefore?: string(name='NotBefore'),
      publicKey?: string(name='PublicKey'),
      serialNumber?: string(name='SerialNumber'),
      signatureAlgorithm?: string(name='SignatureAlgorithm'),
      subject?: string(name='Subject'),
      version?: int32(name='Version'),
      x509Certificate?: string(name='X509Certificate'),
    }
  ](name='SAMLIdPCertificates'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListExternalSAMLIdPCertificatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListExternalSAMLIdPCertificatesResponseBody(name='body'),
}

async function listExternalSAMLIdPCertificates(request: ListExternalSAMLIdPCertificatesRequest): ListExternalSAMLIdPCertificatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListExternalSAMLIdPCertificates', 'POST', '/', 'json', false, 'json', request);
}

model ListGroupMembersRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
}

model ListGroupMembersResponseBody = {
  groupMembers?: [ 
    {
      description?: string(name='Description'),
      displayName?: string(name='DisplayName'),
      email?: string(name='Email'),
      groupId?: string(name='GroupId'),
      joinTime?: string(name='JoinTime'),
      provisionType?: string(name='ProvisionType'),
      status?: string(name='Status'),
      userId?: string(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='GroupMembers'),
  isTruncated?: boolean(name='IsTruncated'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListGroupMembersResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupMembersResponseBody(name='body'),
}

async function listGroupMembers(request: ListGroupMembersRequest): ListGroupMembersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListGroupMembers', 'POST', '/', 'json', false, 'json', request);
}

model ListGroupsRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  filter?: string(name='Filter', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  provisionType?: string(name='ProvisionType', position='Query'),
}

model ListGroupsResponseBody = {
  groups?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      provisionType?: string(name='ProvisionType'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Groups'),
  isTruncated?: boolean(name='IsTruncated'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupsResponseBody(name='body'),
}

async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListGroups', 'POST', '/', 'json', false, 'json', request);
}

model ListJoinedGroupsForUserRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model ListJoinedGroupsForUserResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  joinedGroups?: [ 
    {
      description?: string(name='Description'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      joinTime?: string(name='JoinTime'),
      provisionType?: string(name='ProvisionType'),
      userId?: string(name='UserId'),
    }
  ](name='JoinedGroups'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListJoinedGroupsForUserResponse = {
  headers: map[string]string(name='headers'),
  body: ListJoinedGroupsForUserResponseBody(name='body'),
}

async function listJoinedGroupsForUser(request: ListJoinedGroupsForUserRequest): ListJoinedGroupsForUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListJoinedGroupsForUser', 'POST', '/', 'json', false, 'json', request);
}

model ListMFADevicesForUserRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model ListMFADevicesForUserResponseBody = {
  MFADevices?: [ 
    {
      deviceId?: string(name='DeviceId'),
      deviceName?: string(name='DeviceName'),
      deviceType?: string(name='DeviceType'),
      effectiveTime?: string(name='EffectiveTime'),
      userId?: string(name='UserId'),
    }
  ](name='MFADevices'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListMFADevicesForUserResponse = {
  headers: map[string]string(name='headers'),
  body: ListMFADevicesForUserResponseBody(name='body'),
}

async function listMFADevicesForUser(request: ListMFADevicesForUserRequest): ListMFADevicesForUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMFADevicesForUser', 'POST', '/', 'json', false, 'json', request);
}

model ListPermissionPoliciesInAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  permissionPolicyType?: string(name='PermissionPolicyType', position='Query'),
}

model ListPermissionPoliciesInAccessConfigurationResponseBody = {
  permissionPolicies?: [ 
    {
      addTime?: string(name='AddTime'),
      permissionPolicyDocument?: string(name='PermissionPolicyDocument'),
      permissionPolicyName?: string(name='PermissionPolicyName'),
      permissionPolicyType?: string(name='PermissionPolicyType'),
    }
  ](name='PermissionPolicies'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListPermissionPoliciesInAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: ListPermissionPoliciesInAccessConfigurationResponseBody(name='body'),
}

async function listPermissionPoliciesInAccessConfiguration(request: ListPermissionPoliciesInAccessConfigurationRequest): ListPermissionPoliciesInAccessConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPermissionPoliciesInAccessConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model ListSCIMServerCredentialsRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
}

model ListSCIMServerCredentialsResponseBody = {
  requestId?: string(name='RequestId'),
  SCIMServerCredentials?: [ 
    {
      createTime?: string(name='CreateTime'),
      credentialId?: string(name='CredentialId'),
      credentialType?: string(name='CredentialType'),
      directoryId?: string(name='DirectoryId'),
      expireTime?: string(name='ExpireTime'),
      status?: string(name='Status'),
    }
  ](name='SCIMServerCredentials'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListSCIMServerCredentialsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSCIMServerCredentialsResponseBody(name='body'),
}

async function listSCIMServerCredentials(request: ListSCIMServerCredentialsRequest): ListSCIMServerCredentialsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSCIMServerCredentials', 'POST', '/', 'json', false, 'json', request);
}

model ListTasksRequest {
  accessConfigurationId?: string(name='AccessConfigurationId', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  filter?: string(name='Filter', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  principalId?: string(name='PrincipalId', position='Query'),
  principalType?: string(name='PrincipalType', position='Query'),
  status?: string(name='Status', position='Query'),
  targetId?: string(name='TargetId', position='Query'),
  targetType?: string(name='TargetType', position='Query'),
  taskType?: string(name='TaskType', position='Query'),
}

model ListTasksResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      accessConfigurationId?: string(name='AccessConfigurationId'),
      accessConfigurationName?: string(name='AccessConfigurationName'),
      endTime?: string(name='EndTime'),
      failureReason?: string(name='FailureReason'),
      principalId?: string(name='PrincipalId'),
      principalName?: string(name='PrincipalName'),
      principalType?: string(name='PrincipalType'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      targetId?: string(name='TargetId'),
      targetName?: string(name='TargetName'),
      targetPath?: string(name='TargetPath'),
      targetPathName?: string(name='TargetPathName'),
      targetType?: string(name='TargetType'),
      taskId?: string(name='TaskId'),
      taskType?: string(name='TaskType'),
    }
  ](name='Tasks'),
  totalCounts?: int32(name='TotalCounts'),
}

model ListTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListTasksResponseBody(name='body'),
}

async function listTasks(request: ListTasksRequest): ListTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTasks', 'POST', '/', 'json', false, 'json', request);
}

model ListUsersRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  filter?: string(name='Filter', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  provisionType?: string(name='ProvisionType', position='Query'),
  status?: string(name='Status', position='Query'),
}

model ListUsersResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCounts?: int32(name='TotalCounts'),
  users?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      displayName?: string(name='DisplayName'),
      email?: string(name='Email'),
      firstName?: string(name='FirstName'),
      lastName?: string(name='LastName'),
      provisionType?: string(name='ProvisionType'),
      status?: string(name='Status'),
      updateTime?: string(name='UpdateTime'),
      userId?: string(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='Users'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUsers', 'POST', '/', 'json', false, 'json', request);
}

model ProvisionAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  targetId?: string(name='TargetId', position='Query'),
  targetType?: string(name='TargetType', position='Query'),
}

model ProvisionAccessConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      accessConfigurationId?: string(name='AccessConfigurationId'),
      accessConfigurationName?: string(name='AccessConfigurationName'),
      status?: string(name='Status'),
      targetId?: string(name='TargetId'),
      targetName?: string(name='TargetName'),
      targetPath?: string(name='TargetPath'),
      targetPathName?: string(name='TargetPathName'),
      targetType?: string(name='TargetType'),
      taskId?: string(name='TaskId'),
      taskType?: string(name='TaskType'),
    }
  ](name='Tasks'),
}

model ProvisionAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: ProvisionAccessConfigurationResponseBody(name='body'),
}

async function provisionAccessConfiguration(request: ProvisionAccessConfigurationRequest): ProvisionAccessConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ProvisionAccessConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model RemoveExternalSAMLIdPCertificateRequest {
  certificateId?: string(name='CertificateId', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
}

model RemoveExternalSAMLIdPCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveExternalSAMLIdPCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveExternalSAMLIdPCertificateResponseBody(name='body'),
}

async function removeExternalSAMLIdPCertificate(request: RemoveExternalSAMLIdPCertificateRequest): RemoveExternalSAMLIdPCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveExternalSAMLIdPCertificate', 'POST', '/', 'json', false, 'json', request);
}

model RemovePermissionPolicyFromAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  permissionPolicyName?: string(name='PermissionPolicyName', position='Query'),
  permissionPolicyType?: string(name='PermissionPolicyType', position='Query'),
}

model RemovePermissionPolicyFromAccessConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemovePermissionPolicyFromAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: RemovePermissionPolicyFromAccessConfigurationResponseBody(name='body'),
}

async function removePermissionPolicyFromAccessConfiguration(request: RemovePermissionPolicyFromAccessConfigurationRequest): RemovePermissionPolicyFromAccessConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemovePermissionPolicyFromAccessConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model RemoveUserFromGroupRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model RemoveUserFromGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveUserFromGroupResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveUserFromGroupResponseBody(name='body'),
}

async function removeUserFromGroup(request: RemoveUserFromGroupRequest): RemoveUserFromGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveUserFromGroup', 'POST', '/', 'json', false, 'json', request);
}

model ResetUserPasswordRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  generateRandomPassword?: boolean(name='GenerateRandomPassword', position='Query'),
  password?: string(name='Password', position='Query'),
  requirePasswordResetForNextLogin?: boolean(name='RequirePasswordResetForNextLogin', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model ResetUserPasswordResponseBody = {
  newPassword?: string(name='NewPassword'),
  requestId?: string(name='RequestId'),
}

model ResetUserPasswordResponse = {
  headers: map[string]string(name='headers'),
  body: ResetUserPasswordResponseBody(name='body'),
}

async function resetUserPassword(request: ResetUserPasswordRequest): ResetUserPasswordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetUserPassword', 'POST', '/', 'json', false, 'json', request);
}

model SetExternalSAMLIdentityProviderRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  encodedMetadataDocument?: string(name='EncodedMetadataDocument', position='Query'),
  entityId?: string(name='EntityId', position='Query'),
  loginUrl?: string(name='LoginUrl', position='Query'),
  SSOStatus?: string(name='SSOStatus', position='Query'),
  wantRequestSigned?: boolean(name='WantRequestSigned', position='Query'),
  x509Certificate?: string(name='X509Certificate', position='Query'),
}

model SetExternalSAMLIdentityProviderResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLIdentityProviderConfiguration?: {
    certificateIds?: [ string ](name='CertificateIds'),
    createTime?: string(name='CreateTime'),
    directoryId?: string(name='DirectoryId'),
    encodedMetadataDocument?: string(name='EncodedMetadataDocument'),
    entityId?: string(name='EntityId'),
    loginUrl?: string(name='LoginUrl'),
    SSOStatus?: string(name='SSOStatus'),
    updateTime?: string(name='UpdateTime'),
    wantRequestSigned?: boolean(name='WantRequestSigned'),
  }(name='SAMLIdentityProviderConfiguration'),
}

model SetExternalSAMLIdentityProviderResponse = {
  headers: map[string]string(name='headers'),
  body: SetExternalSAMLIdentityProviderResponseBody(name='body'),
}

async function setExternalSAMLIdentityProvider(request: SetExternalSAMLIdentityProviderRequest): SetExternalSAMLIdentityProviderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetExternalSAMLIdentityProvider', 'POST', '/', 'json', false, 'json', request);
}

model SetMFAAuthenticationStatusRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  MFAAuthenticationStatus?: string(name='MFAAuthenticationStatus', position='Query'),
}

model SetMFAAuthenticationStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetMFAAuthenticationStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetMFAAuthenticationStatusResponseBody(name='body'),
}

async function setMFAAuthenticationStatus(request: SetMFAAuthenticationStatusRequest): SetMFAAuthenticationStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetMFAAuthenticationStatus', 'POST', '/', 'json', false, 'json', request);
}

model SetSCIMSynchronizationStatusRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  SCIMSynchronizationStatus?: string(name='SCIMSynchronizationStatus', position='Query'),
}

model SetSCIMSynchronizationStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetSCIMSynchronizationStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetSCIMSynchronizationStatusResponseBody(name='body'),
}

async function setSCIMSynchronizationStatus(request: SetSCIMSynchronizationStatusRequest): SetSCIMSynchronizationStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetSCIMSynchronizationStatus', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  newDescription?: string(name='NewDescription', position='Query'),
  newRelayState?: string(name='NewRelayState', position='Query'),
  newSessionDuration?: int32(name='NewSessionDuration', position='Query'),
}

model UpdateAccessConfigurationResponseBody = {
  accessConfiguration?: {
    accessConfigurationId?: string(name='AccessConfigurationId'),
    accessConfigurationName?: string(name='AccessConfigurationName'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    relayState?: string(name='RelayState'),
    sessionDuration?: int32(name='SessionDuration'),
    statusNotifications?: [ string ](name='StatusNotifications'),
    updateTime?: string(name='UpdateTime'),
  }(name='AccessConfiguration'),
  requestId?: string(name='RequestId'),
}

model UpdateAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAccessConfigurationResponseBody(name='body'),
}

async function updateAccessConfiguration(request: UpdateAccessConfigurationRequest): UpdateAccessConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAccessConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDirectoryRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  newDirectoryName?: string(name='NewDirectoryName', position='Query'),
}

model UpdateDirectoryResponseBody = {
  directory?: {
    createTime?: string(name='CreateTime'),
    directoryId?: string(name='DirectoryId'),
    directoryName?: string(name='DirectoryName'),
    region?: string(name='Region'),
    updateTime?: string(name='UpdateTime'),
  }(name='Directory'),
  requestId?: string(name='RequestId'),
}

model UpdateDirectoryResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDirectoryResponseBody(name='body'),
}

async function updateDirectory(request: UpdateDirectoryRequest): UpdateDirectoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDirectory', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGroupRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  newDescription?: string(name='NewDescription', position='Query'),
  newGroupName?: string(name='NewGroupName', position='Query'),
}

model UpdateGroupResponseBody = {
  group?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    provisionType?: string(name='ProvisionType'),
    updateTime?: string(name='UpdateTime'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model UpdateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGroupResponseBody(name='body'),
}

async function updateGroup(request: UpdateGroupRequest): UpdateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateInlinePolicyForAccessConfigurationRequest {
  accessConfigurationId?: string(name='AccessConfigurationId', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  inlinePolicyName?: string(name='InlinePolicyName', position='Query'),
  newInlinePolicyDocument?: string(name='NewInlinePolicyDocument', position='Query'),
}

model UpdateInlinePolicyForAccessConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateInlinePolicyForAccessConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateInlinePolicyForAccessConfigurationResponseBody(name='body'),
}

async function updateInlinePolicyForAccessConfiguration(request: UpdateInlinePolicyForAccessConfigurationRequest): UpdateInlinePolicyForAccessConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateInlinePolicyForAccessConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model UpdateMFAAuthenticationSettingsRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  MFAAuthenticationSettings?: string(name='MFAAuthenticationSettings', position='Query'),
}

model UpdateMFAAuthenticationSettingsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMFAAuthenticationSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMFAAuthenticationSettingsResponseBody(name='body'),
}

async function updateMFAAuthenticationSettings(request: UpdateMFAAuthenticationSettingsRequest): UpdateMFAAuthenticationSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMFAAuthenticationSettings', 'POST', '/', 'json', false, 'json', request);
}

model UpdateSCIMServerCredentialStatusRequest {
  credentialId?: string(name='CredentialId', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  newStatus?: string(name='NewStatus', position='Query'),
}

model UpdateSCIMServerCredentialStatusResponseBody = {
  requestId?: string(name='RequestId'),
  SCIMServerCredential?: {
    createTime?: string(name='CreateTime'),
    credentialId?: string(name='CredentialId'),
    credentialType?: string(name='CredentialType'),
    directoryId?: string(name='DirectoryId'),
    expireTime?: string(name='ExpireTime'),
    status?: string(name='Status'),
  }(name='SCIMServerCredential'),
}

model UpdateSCIMServerCredentialStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSCIMServerCredentialStatusResponseBody(name='body'),
}

async function updateSCIMServerCredentialStatus(request: UpdateSCIMServerCredentialStatusRequest): UpdateSCIMServerCredentialStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSCIMServerCredentialStatus', 'POST', '/', 'json', false, 'json', request);
}

model UpdateUserRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  newDescription?: string(name='NewDescription', position='Query'),
  newDisplayName?: string(name='NewDisplayName', position='Query'),
  newEmail?: string(name='NewEmail', position='Query'),
  newFirstName?: string(name='NewFirstName', position='Query'),
  newLastName?: string(name='NewLastName', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model UpdateUserResponseBody = {
  requestId?: string(name='RequestId'),
  user?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    displayName?: string(name='DisplayName'),
    email?: string(name='Email'),
    firstName?: string(name='FirstName'),
    lastName?: string(name='LastName'),
    provisionType?: string(name='ProvisionType'),
    status?: string(name='Status'),
    updateTime?: string(name='UpdateTime'),
    userId?: string(name='UserId'),
    userName?: string(name='UserName'),
  }(name='User'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserResponseBody(name='body'),
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateUser', 'POST', '/', 'json', false, 'json', request);
}

model UpdateUserMFAAuthenticationSettingsRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  userId?: string(name='UserId', position='Query'),
  userMFAAuthenticationSettings?: string(name='UserMFAAuthenticationSettings', position='Query'),
}

model UpdateUserMFAAuthenticationSettingsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateUserMFAAuthenticationSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserMFAAuthenticationSettingsResponseBody(name='body'),
}

async function updateUserMFAAuthenticationSettings(request: UpdateUserMFAAuthenticationSettingsRequest): UpdateUserMFAAuthenticationSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateUserMFAAuthenticationSettings', 'POST', '/', 'json', false, 'json', request);
}

model UpdateUserStatusRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  newStatus?: string(name='NewStatus', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model UpdateUserStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateUserStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserStatusResponseBody(name='body'),
}

async function updateUserStatus(request: UpdateUserStatusRequest): UpdateUserStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateUserStatus', 'POST', '/', 'json', false, 'json', request);
}

