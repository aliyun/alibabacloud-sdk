/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'pai.cn-beijing.aliyuncs.com',
    cn-hangzhou = 'pai.cn-hangzhou.aliyuncs.com',
    cn-shanghai = 'pai.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'pai.cn-shenzhen.aliyuncs.com',
    cn-hongkong = 'pai.cn-hongkong.aliyuncs.com',
    ap-southeast-1 = 'pai.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'pai.ap-southeast-2.aliyuncs.com',
    ap-southeast-3 = 'pai.ap-southeast-3.aliyuncs.com',
    ap-southeast-5 = 'pai.ap-southeast-5.aliyuncs.com',
    us-west-1 = 'pai.us-west-1.aliyuncs.com',
    us-east-1 = 'pai.us-east-1.aliyuncs.com',
    eu-central-1 = 'pai.eu-central-1.aliyuncs.com',
    me-east-1 = 'pai.me-east-1.aliyuncs.com',
    ap-south-1 = 'pai.ap-south-1.aliyuncs.com',
    cn-qingdao = 'pai.cn-qingdao.aliyuncs.com',
    cn-zhangjiakou = 'pai.cn-zhangjiakou.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('paistudio', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ACS {
  ACSQuotaId?: string(name='ACSQuotaId'),
  associatedProducts?: [ string ](name='AssociatedProducts'),
}

model AlgorithmSpec {
  codeDir?: Location(name='CodeDir'),
  command?: [ string ](name='Command'),
  computeResource?: {
    policy?: {
      value?: string(name='Value'),
      version?: string(name='Version'),
    }(name='Policy'),
  }(name='ComputeResource'),
  customization?: {
    codeDir?: boolean(name='CodeDir'),
  }(name='Customization'),
  hyperParameters?: [
    HyperParameterDefinition
  ](name='HyperParameters'),
  image?: string(name='Image'),
  inputChannels?: [
    Channel
  ](name='InputChannels'),
  jobType?: string(name='JobType'),
  metricDefinitions?: [
    MetricDefinition
  ](name='MetricDefinitions'),
  outputChannels?: [
    Channel
  ](name='OutputChannels'),
  progressDefinitions?: {
    overallProgress?: {
      description?: string(name='Description'),
      regex?: string(name='Regex'),
    }(name='OverallProgress'),
    remainingTime?: {
      description?: string(name='Description'),
      regex?: string(name='Regex'),
    }(name='RemainingTime'),
  }(name='ProgressDefinitions'),
  resourceRequirements?: [
    ConditionExpression
  ](name='ResourceRequirements'),
  supportedInstanceTypes?: [ string ](name='SupportedInstanceTypes', deprecated='true'),
  supportsDistributedTraining?: boolean(name='SupportsDistributedTraining'),
}

model AllocateStrategySpec {
  nodeSpecs?: [
    NodeSpec
  ](name='NodeSpecs'),
}

model Channel {
  description?: string(name='Description'),
  name?: string(name='Name'),
  properties?: map[string]any(name='Properties'),
  required?: boolean(name='Required'),
  supportedChannelTypes?: [ string ](name='SupportedChannelTypes'),
}

model ChannelProperty {
  name?: string(name='Name', example='SKlearn'),
  value?: string(name='Value', example='Framework'),
}

model ComponentSpec {
  codeDir?: Location(name='CodeDir'),
  command?: string(name='Command'),
  hyperParameters?: [
    HyperParameterDefinition
  ](name='HyperParameters'),
  image?: string(name='Image'),
  inputChannels?: [
    Channel
  ](name='InputChannels'),
  jobType?: string(name='JobType'),
  metricDefinitions?: [
    MetricDefinition
  ](name='MetricDefinitions'),
  outputChannels?: [
    Channel
  ](name='OutputChannels'),
  resourceRequirements?: [
    ConditionExpression
  ](name='ResourceRequirements'),
}

model ConditionExpression {
  key?: string(name='Key', example='SupportedMachineTypes'),
  operator?: string(name='Operator', example='in'),
  values?: [ string ](name='Values'),
}

model Features {
  quota?: {
    isEnabled?: boolean(name='IsEnabled', example='true'),
  }(name='Quota'),
}

model GPUInfo {
  count?: long(name='count'),
  type?: string(name='type'),
}

model HyperParameterDefinition {
  defaultValue?: string(name='DefaultValue'),
  description?: string(name='Description'),
  displayName?: string(name='DisplayName'),
  name?: string(name='Name'),
  range?: HyperParameterRange(name='Range'),
  required?: boolean(name='Required'),
  type?: string(name='Type'),
}

model HyperParameterRange {
  enum?: [ string ](name='Enum'),
  exclusiveMaximum?: boolean(name='ExclusiveMaximum'),
  exclusiveMinimum?: boolean(name='ExclusiveMinimum'),
  maxLength?: long(name='MaxLength'),
  maximum?: string(name='Maximum'),
  minLength?: long(name='MinLength'),
  minimum?: string(name='Minimum'),
  pattern?: string(name='Pattern'),
}

model JobViewMetric {
  CPUUsageRate?: string(name='CPUUsageRate'),
  diskReadRate?: string(name='DiskReadRate'),
  diskWriteRate?: string(name='DiskWriteRate'),
  GPUUsageRate?: string(name='GPUUsageRate'),
  jobId?: string(name='JobId'),
  jobType?: string(name='JobType'),
  memoryUsageRate?: string(name='MemoryUsageRate'),
  networkInputRate?: string(name='NetworkInputRate'),
  networkOutputRate?: string(name='NetworkOutputRate'),
  nodeNames?: [ string ](name='NodeNames'),
  requestCPU?: int32(name='RequestCPU'),
  requestGPU?: int32(name='RequestGPU'),
  requestMemory?: long(name='RequestMemory'),
  resourceGroupID?: string(name='ResourceGroupID', example='rg17tmvwiokhzaxg'),
  totalCPU?: int32(name='TotalCPU'),
  totalGPU?: int32(name='TotalGPU'),
  totalMemory?: long(name='TotalMemory'),
  userId?: string(name='UserId'),
}

model Label {
  key?: string(name='Key'),
  value?: string(name='Value'),
}

model Location {
  locationType?: string(name='LocationType'),
  locationValue?: map[string]any(name='LocationValue'),
}

model MachineGroup {
  creatorID?: string(name='CreatorID'),
  defaultDriver?: string(name='DefaultDriver', example='470.199.02'),
  ecsCount?: long(name='EcsCount'),
  ecsSpec?: string(name='EcsSpec'),
  gmtCreatedTime?: string(name='GmtCreatedTime'),
  gmtExpiredTime?: string(name='GmtExpiredTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  gmtStartedTime?: string(name='GmtStartedTime'),
  machineGroupID?: string(name='MachineGroupID', example='mg1'),
  paymentDuration?: string(name='PaymentDuration'),
  paymentDurationUnit?: string(name='PaymentDurationUnit'),
  paymentType?: string(name='PaymentType'),
  reasonCode?: string(name='ReasonCode'),
  reasonMessage?: string(name='ReasonMessage'),
  resourceGroupID?: string(name='ResourceGroupID'),
  status?: string(name='Status'),
  supportedDrivers?: [ string ](name='SupportedDrivers'),
}

model Metric {
  time?: long(name='Time', example='rg17tmvwiokhzaxg'),
  value?: string(name='Value', example='23000'),
}

model MetricDefinition {
  description?: string(name='Description', example='train dataset oob score'),
  name?: string(name='Name', example='train:oob_score'),
  regex?: string(name='Regex', example='.*train:oob_score=([-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?).*'),
}

model Node {
  acceleratorType?: string(name='AcceleratorType'),
  boundQuotas?: [
    QuotaIdName
  ](name='BoundQuotas'),
  CPU?: string(name='CPU'),
  creatorId?: string(name='CreatorId'),
  GPU?: string(name='GPU'),
  GPUType?: string(name='GPUType'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtExpiredTime?: string(name='GmtExpiredTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  isBound?: boolean(name='IsBound'),
  machineGroupId?: string(name='MachineGroupId'),
  memory?: string(name='Memory'),
  nodeName?: string(name='NodeName'),
  nodeStatus?: string(name='NodeStatus'),
  nodeType?: string(name='NodeType'),
  orderStatus?: string(name='OrderStatus'),
  reasonCode?: string(name='ReasonCode'),
  reasonMessage?: string(name='ReasonMessage'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceGroupName?: string(name='ResourceGroupName'),
}

model NodeMetric {
  GPUType?: string(name='GPUType'),
  metrics?: [
    Metric
  ](name='Metrics', example='23000'),
  nodeID?: string(name='NodeID', example='-i121212node'),
}

model NodeSpec {
  count?: long(name='Count', example='10'),
  type?: string(name='Type', example='ecs.g6.4xlarge'),
}

model NodeType {
  acceleratorType?: string(name='AcceleratorType', example='CPU'),
  CPU?: string(name='CPU', example='16'),
  GPU?: string(name='GPU', example='0'),
  GPUType?: string(name='GPUType'),
  memory?: string(name='Memory', example='64Gi'),
  nodeType?: string(name='NodeType', example='ecs.g6.4xlarge'),
}

model NodeTypeStatistic {
  canBeBoundCount?: int32(name='CanBeBoundCount', example='4'),
  nodeType?: string(name='NodeType', example='ecs.g6.4xlarge'),
  totalCount?: int32(name='TotalCount', example='10'),
}

model NodeViewMetric {
  CPUUsageRate?: string(name='CPUUsageRate'),
  createdTime?: string(name='CreatedTime'),
  diskReadRate?: string(name='DiskReadRate'),
  diskWriteRate?: string(name='DiskWriteRate'),
  GPUType?: string(name='GPUType'),
  machineGroupID?: string(name='MachineGroupID'),
  memoryUsageRate?: string(name='MemoryUsageRate'),
  networkInputRate?: string(name='NetworkInputRate'),
  networkOutputRate?: string(name='NetworkOutputRate'),
  nodeID?: string(name='NodeID', example='-i121212node'),
  nodeStatus?: string(name='NodeStatus'),
  nodeType?: string(name='NodeType'),
  requestCPU?: long(name='RequestCPU'),
  requestGPU?: long(name='RequestGPU'),
  requestMemory?: long(name='RequestMemory'),
  taskIdMap?: map[string]any(name='TaskIdMap'),
  totalCPU?: long(name='TotalCPU'),
  totalGPU?: long(name='TotalGPU'),
  totalMemory?: long(name='TotalMemory'),
  totalTasks?: long(name='TotalTasks'),
  userIDs?: [ string ](name='UserIDs'),
  userNumber?: string(name='UserNumber'),
}

model Permission {
  isEnabled?: boolean(name='IsEnabled'),
  resourceType?: string(name='ResourceType'),
}

model QueueInfo {
  gmtEnqueuedTime?: string(name='GmtEnqueuedTime', example='“2023-06-22T00:00:00Z”'),
  gmtPositionModifiedTime?: string(name='GmtPositionModifiedTime', example='"2023-06-22T00:00:00Z"'),
  position?: long(name='Position', example='10'),
  priority?: long(name='Priority', example='2'),
  queueStrategy?: string(name='QueueStrategy', example='PaiStrategyIntelligent'),
  quotaId?: string(name='QuotaId', example='“quotamtl37ge7gkvdz”'),
  workloadId?: string(name='WorkloadId', example='dlcxxxx'),
  workloadType?: string(name='WorkloadType', example='dlc'),
  workspaceId?: string(name='WorkspaceId', example='“432524”'),
}

model Quota {
  allocateStrategy?: string(name='AllocateStrategy'),
  creatorId?: string(name='CreatorId'),
  description?: string(name='Description'),
  gmtCreatedTime?: string(name='GmtCreatedTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  labels?: [
    Label
  ](name='Labels'),
  latestOperationId?: string(name='LatestOperationId'),
  min?: ResourceSpec(name='Min'),
  parentQuotaId?: string(name='ParentQuotaId'),
  queueStrategy?: string(name='QueueStrategy'),
  quotaConfig?: QuotaConfig(name='QuotaConfig'),
  quotaDetails?: QuotaDetails(name='QuotaDetails'),
  quotaId?: string(name='QuotaId', example='quota12345'),
  quotaName?: string(name='QuotaName', example='dlc-quota'),
  reasonCode?: string(name='ReasonCode'),
  reasonMessage?: string(name='ReasonMessage'),
  resourceGroupIds?: [ string ](name='ResourceGroupIds'),
  resourceType?: string(name='ResourceType'),
  status?: string(name='Status'),
  subQuotas?: [
    QuotaIdName
  ](name='SubQuotas'),
  workspaces?: [
    WorkspaceIdName
  ](name='Workspaces'),
}

model QuotaConfig {
  ACS?: ACS(name='ACS'),
  clusterId?: string(name='ClusterId', example='ceeb37xxxx'),
  defaultGPUDriver?: string(name='DefaultGPUDriver', example='470.199.02'),
  supportGPUDrivers?: [ string ](name='SupportGPUDrivers'),
  supportRDMA?: boolean(name='SupportRDMA', example='false'),
  userVpc?: UserVpc(name='UserVpc'),
}

model QuotaDetails {
  actualMinQuota?: ResourceAmount(name='ActualMinQuota'),
  desiredMinQuota?: ResourceAmount(name='DesiredMinQuota'),
  requestedQuota?: ResourceAmount(name='RequestedQuota'),
  usedQuota?: ResourceAmount(name='UsedQuota'),
}

model QuotaIdName {
  quotaId?: string(name='QuotaId', example='quota12345'),
  quotaName?: string(name='QuotaName', example='dlc-quota'),
}

model QuotaJobViewMetric {
  CPUUsageRate?: string(name='CPUUsageRate'),
  diskReadRate?: string(name='DiskReadRate'),
  diskWriteRate?: string(name='DiskWriteRate'),
  GPUUsageRate?: string(name='GPUUsageRate'),
  jobId?: string(name='JobId'),
  jobType?: string(name='JobType'),
  memoryUsageRate?: string(name='MemoryUsageRate'),
  networkInputRate?: string(name='NetworkInputRate'),
  networkOutputRate?: string(name='NetworkOutputRate'),
  nodeNames?: [ string ](name='NodeNames'),
  requestCPU?: int32(name='RequestCPU'),
  requestGPU?: int32(name='RequestGPU'),
  requestMemory?: long(name='RequestMemory'),
  totalCPU?: int32(name='TotalCPU'),
  totalGPU?: int32(name='TotalGPU'),
  totalMemory?: long(name='TotalMemory'),
  userId?: string(name='UserId'),
}

model QuotaMetric {
  GPUType?: string(name='GPUType'),
  metrics?: [
    Metric
  ](name='Metrics', example='23000'),
}

model QuotaNodeViewMetric {
  CPUUsageRate?: string(name='CPUUsageRate'),
  createdTime?: string(name='CreatedTime'),
  diskReadRate?: string(name='DiskReadRate'),
  diskWriteRate?: string(name='DiskWriteRate'),
  GPUType?: string(name='GPUType'),
  memoryUsageRate?: string(name='MemoryUsageRate'),
  networkInputRate?: string(name='NetworkInputRate'),
  networkOutputRate?: string(name='NetworkOutputRate'),
  nodeID?: string(name='NodeID', example='-i121212node'),
  nodeStatus?: string(name='NodeStatus'),
  nodeType?: string(name='NodeType'),
  quotaId?: string(name='QuotaId'),
  requestCPU?: long(name='RequestCPU'),
  requestGPU?: long(name='RequestGPU'),
  requestMemory?: long(name='RequestMemory'),
  taskIdMap?: map[string]any(name='TaskIdMap'),
  totalCPU?: long(name='TotalCPU'),
  totalGPU?: long(name='TotalGPU'),
  totalMemory?: long(name='TotalMemory'),
  totalTasks?: long(name='TotalTasks'),
  userIDs?: [ string ](name='UserIDs'),
  userNumber?: string(name='UserNumber'),
}

model QuotaUserViewMetric {
  CPUNodeNumber?: int32(name='CPUNodeNumber'),
  CPUUsageRate?: string(name='CPUUsageRate'),
  cpuJobNames?: [ string ](name='CpuJobNames'),
  cpuNodeNames?: [ string ](name='CpuNodeNames'),
  diskReadRate?: string(name='DiskReadRate'),
  diskWriteRate?: string(name='DiskWriteRate'),
  GPUNodeNumber?: int32(name='GPUNodeNumber'),
  GPUUsageRate?: string(name='GPUUsageRate'),
  gpuJobNames?: [ string ](name='GpuJobNames'),
  gpuNodeNames?: [ string ](name='GpuNodeNames'),
  jobType?: string(name='JobType'),
  memoryUsageRate?: string(name='MemoryUsageRate'),
  networkInputRate?: string(name='NetworkInputRate'),
  networkOutputRate?: string(name='NetworkOutputRate'),
  nodeNames?: [ string ](name='NodeNames'),
  requestCPU?: int32(name='RequestCPU'),
  requestGPU?: int32(name='RequestGPU'),
  requestMemory?: long(name='RequestMemory'),
  totalCPU?: int32(name='TotalCPU'),
  totalGPU?: int32(name='TotalGPU'),
  totalMemory?: long(name='TotalMemory'),
  userId?: string(name='UserId'),
}

model ResourceAmount {
  CPU?: string(name='CPU', example='100'),
  GPU?: string(name='GPU', example='16'),
  GPUType?: string(name='GPUType', example='GPU'),
  memory?: string(name='Memory', example='100Gi'),
}

model ResourceGroup {
  creatorID?: string(name='CreatorID'),
  gmtCreatedTime?: string(name='GmtCreatedTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  name?: string(name='Name', example='RG1'),
  nodeCount?: int32(name='NodeCount'),
  resourceGroupID?: string(name='ResourceGroupID', example='rg17tmvwiokhzaxg'),
  userVpc?: UserVpc(name='UserVpc'),
  workspaceID?: string(name='WorkspaceID', example='23000'),
}

model ResourceGroupMetric {
  gpuType?: string(name='GpuType'),
  metrics?: [
    Metric
  ](name='Metrics', example='23000'),
  resourceGroupID?: string(name='ResourceGroupID', example='rg17tmvwiokhzaxg'),
}

model ResourceOperation {
  creatorId?: string(name='CreatorId'),
  gmtCreatedTime?: string(name='GmtCreatedTime'),
  gmtEndTime?: string(name='GmtEndTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  gmtStartTime?: string(name='GmtStartTime'),
  objectId?: string(name='ObjectId'),
  objectType?: string(name='ObjectType'),
  operationDescription?: string(name='OperationDescription'),
  operationId?: string(name='OperationId'),
  operationSpecJson?: string(name='OperationSpecJson'),
  operationType?: string(name='OperationType'),
  reasonCode?: string(name='ReasonCode'),
  reasonMessage?: string(name='ReasonMessage'),
  status?: string(name='Status'),
}

model ResourceSpec {
  nodeSpecs?: [
    NodeSpec
  ](name='NodeSpecs'),
}

model UserViewMetric {
  CPUNodeNumber?: int32(name='CPUNodeNumber'),
  CPUUsageRate?: string(name='CPUUsageRate'),
  cpuJobNames?: [ string ](name='CpuJobNames'),
  cpuNodeNames?: [ string ](name='CpuNodeNames'),
  diskReadRate?: string(name='DiskReadRate'),
  diskWriteRate?: string(name='DiskWriteRate'),
  GPUNodeNumber?: int32(name='GPUNodeNumber'),
  GPUUsageRate?: string(name='GPUUsageRate'),
  gpuJobNames?: [ string ](name='GpuJobNames'),
  gpuNodeNames?: [ string ](name='GpuNodeNames'),
  jobType?: string(name='JobType'),
  memoryUsageRate?: string(name='MemoryUsageRate'),
  networkInputRate?: string(name='NetworkInputRate'),
  networkOutputRate?: string(name='NetworkOutputRate'),
  nodeNames?: [ string ](name='NodeNames'),
  requestCPU?: int32(name='RequestCPU'),
  requestGPU?: int32(name='RequestGPU'),
  requestMemory?: long(name='RequestMemory'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg17tmvwiokhzaxg'),
  totalCPU?: int32(name='TotalCPU'),
  totalGPU?: int32(name='TotalGPU'),
  totalMemory?: long(name='TotalMemory'),
  userId?: string(name='UserId'),
}

model UserVpc {
  defaultRoute?: string(name='DefaultRoute'),
  extendedCIDRs?: [ string ](name='ExtendedCIDRs'),
  roleArn?: string(name='RoleArn'),
  securityGroupId?: string(name='SecurityGroupId'),
  switchId?: string(name='SwitchId'),
  vpcId?: string(name='VpcId'),
}

model WorkspaceIdName {
  workspaceId?: string(name='WorkspaceId', example='ws123456'),
}

model CreateAlgorithmRequest {
  algorithmDescription?: string(name='AlgorithmDescription'),
  algorithmName?: string(name='AlgorithmName'),
  displayName?: string(name='DisplayName'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateAlgorithmResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  requestId?: string(name='RequestId'),
}

model CreateAlgorithmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAlgorithmResponseBody(name='body'),
}

async function createAlgorithmWithOptions(request: CreateAlgorithmRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAlgorithmResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmDescription)) {
    body['AlgorithmDescription'] = request.algorithmDescription;
  }
  if (!Util.isUnset(request.algorithmName)) {
    body['AlgorithmName'] = request.algorithmName;
  }
  if (!Util.isUnset(request.displayName)) {
    body['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlgorithm',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithms`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAlgorithm(request: CreateAlgorithmRequest): CreateAlgorithmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAlgorithmWithOptions(request, headers, runtime);
}

model CreateAlgorithmVersionRequest {
  algorithmSpec?: AlgorithmSpec(name='AlgorithmSpec'),
}

model CreateAlgorithmVersionShrinkRequest {
  algorithmSpecShrink?: string(name='AlgorithmSpec'),
}

model CreateAlgorithmVersionResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  algorithmVersion?: string(name='AlgorithmVersion'),
}

model CreateAlgorithmVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAlgorithmVersionResponseBody(name='body'),
}

async function createAlgorithmVersionWithOptions(AlgorithmId: string, AlgorithmVersion: string, tmpReq: CreateAlgorithmVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAlgorithmVersionResponse {
  Util.validateModel(tmpReq);
  var request = new CreateAlgorithmVersionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.algorithmSpec)) {
    request.algorithmSpecShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.algorithmSpec, 'AlgorithmSpec', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmSpecShrink)) {
    body['AlgorithmSpec'] = request.algorithmSpecShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlgorithmVersion',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithms/${OpenApiUtil.getEncodeParam(AlgorithmId)}/versions/${OpenApiUtil.getEncodeParam(AlgorithmVersion)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAlgorithmVersion(AlgorithmId: string, AlgorithmVersion: string, request: CreateAlgorithmVersionRequest): CreateAlgorithmVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAlgorithmVersionWithOptions(AlgorithmId, AlgorithmVersion, request, headers, runtime);
}

model CreateQuotaRequest {
  allocateStrategy?: string(name='AllocateStrategy', example='ByNodeSpecs'),
  description?: string(name='Description', example='this is a test quota'),
  labels?: [
    Label
  ](name='Labels'),
  min?: ResourceSpec(name='Min'),
  parentQuotaId?: string(name='ParentQuotaId', example='quota1ci8g793pgm'),
  queueStrategy?: string(name='QueueStrategy', example='PaiStrategyIntelligent'),
  quotaConfig?: QuotaConfig(name='QuotaConfig'),
  quotaName?: string(name='QuotaName', example='test-quota'),
  resourceGroupIds?: [ string ](name='ResourceGroupIds'),
  resourceType?: string(name='ResourceType', example='ECS'),
}

model CreateQuotaResponseBody = {
  quotaId?: string(name='QuotaId', description='Quota Id', example='quotad2kd8ljpsno'),
  requestId?: string(name='RequestId', example='CBF05F13-B24C-5129-9048-4FA684DCD579'),
}

model CreateQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateQuotaResponseBody(name='body'),
}

async function createQuotaWithOptions(request: CreateQuotaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateQuotaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.allocateStrategy)) {
    body['AllocateStrategy'] = request.allocateStrategy;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.min)) {
    body['Min'] = request.min;
  }
  if (!Util.isUnset(request.parentQuotaId)) {
    body['ParentQuotaId'] = request.parentQuotaId;
  }
  if (!Util.isUnset(request.queueStrategy)) {
    body['QueueStrategy'] = request.queueStrategy;
  }
  if (!Util.isUnset(request.quotaConfig)) {
    body['QuotaConfig'] = request.quotaConfig;
  }
  if (!Util.isUnset(request.quotaName)) {
    body['QuotaName'] = request.quotaName;
  }
  if (!Util.isUnset(request.resourceGroupIds)) {
    body['ResourceGroupIds'] = request.resourceGroupIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateQuota',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/quotas`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createQuota(request: CreateQuotaRequest): CreateQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createQuotaWithOptions(request, headers, runtime);
}

model CreateResourceGroupRequest {
  computingResourceProvider?: string(name='ComputingResourceProvider'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  userVpc?: UserVpc(name='UserVpc'),
}

model CreateResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
  resourceGroupID?: string(name='ResourceGroupID'),
}

model CreateResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResourceGroupResponseBody(name='body'),
}

async function createResourceGroupWithOptions(request: CreateResourceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateResourceGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.computingResourceProvider)) {
    body['ComputingResourceProvider'] = request.computingResourceProvider;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.userVpc)) {
    body['UserVpc'] = request.userVpc;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourceGroup',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createResourceGroup(request: CreateResourceGroupRequest): CreateResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createResourceGroupWithOptions(request, headers, runtime);
}

model CreateTrainingJobRequest {
  algorithmName?: string(name='AlgorithmName'),
  algorithmProvider?: string(name='AlgorithmProvider'),
  algorithmSpec?: AlgorithmSpec(name='AlgorithmSpec'),
  algorithmVersion?: string(name='AlgorithmVersion'),
  codeDir?: Location(name='CodeDir'),
  computeResource?: {
    ecsCount?: long(name='EcsCount'),
    ecsSpec?: string(name='EcsSpec'),
    instanceCount?: long(name='InstanceCount'),
    instanceSpec?: {
      CPU?: string(name='CPU'),
      GPU?: string(name='GPU'),
      GPUType?: string(name='GPUType'),
      memory?: string(name='Memory'),
      sharedMemory?: string(name='SharedMemory'),
    }(name='InstanceSpec'),
    resourceId?: string(name='ResourceId'),
  }(name='ComputeResource'),
  hyperParameters?: [ 
    {
      name?: string(name='Name'),
      value?: string(name='Value'),
    }
  ](name='HyperParameters'),
  inputChannels?: [ 
    {
      datasetId?: string(name='DatasetId'),
      inputUri?: string(name='InputUri'),
      name?: string(name='Name'),
    }
  ](name='InputChannels'),
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
  outputChannels?: [ 
    {
      datasetId?: string(name='DatasetId'),
      name?: string(name='Name'),
      outputUri?: string(name='OutputUri'),
    }
  ](name='OutputChannels'),
  roleArn?: string(name='RoleArn'),
  scheduler?: {
    maxRunningTimeInSeconds?: long(name='MaxRunningTimeInSeconds'),
  }(name='Scheduler'),
  settings?: {
    AIMasterType?: string(name='AIMasterType'),
    enableErrorMonitoringInAIMaster?: boolean(name='EnableErrorMonitoringInAIMaster'),
    errorMonitoringArgs?: string(name='ErrorMonitoringArgs'),
    priority?: int32(name='Priority'),
  }(name='Settings'),
  trainingJobDescription?: string(name='TrainingJobDescription'),
  trainingJobName?: string(name='TrainingJobName'),
  userVpc?: {
    defaultRoute?: string(name='DefaultRoute'),
    extendedCIDRs?: [ string ](name='ExtendedCIDRs'),
    securityGroupId?: string(name='SecurityGroupId'),
    switchId?: string(name='SwitchId'),
    vpcId?: string(name='VpcId'),
  }(name='UserVpc'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateTrainingJobResponseBody = {
  requestId?: string(name='RequestId'),
  trainingJobId?: string(name='TrainingJobId'),
}

model CreateTrainingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTrainingJobResponseBody(name='body'),
}

async function createTrainingJobWithOptions(request: CreateTrainingJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTrainingJobResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmName)) {
    body['AlgorithmName'] = request.algorithmName;
  }
  if (!Util.isUnset(request.algorithmProvider)) {
    body['AlgorithmProvider'] = request.algorithmProvider;
  }
  if (!Util.isUnset(request.algorithmSpec)) {
    body['AlgorithmSpec'] = request.algorithmSpec;
  }
  if (!Util.isUnset(request.algorithmVersion)) {
    body['AlgorithmVersion'] = request.algorithmVersion;
  }
  if (!Util.isUnset(request.codeDir)) {
    body['CodeDir'] = request.codeDir;
  }
  if (!Util.isUnset(request.computeResource)) {
    body['ComputeResource'] = request.computeResource;
  }
  if (!Util.isUnset(request.hyperParameters)) {
    body['HyperParameters'] = request.hyperParameters;
  }
  if (!Util.isUnset(request.inputChannels)) {
    body['InputChannels'] = request.inputChannels;
  }
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.outputChannels)) {
    body['OutputChannels'] = request.outputChannels;
  }
  if (!Util.isUnset(request.roleArn)) {
    body['RoleArn'] = request.roleArn;
  }
  if (!Util.isUnset(request.scheduler)) {
    body['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.settings)) {
    body['Settings'] = request.settings;
  }
  if (!Util.isUnset(request.trainingJobDescription)) {
    body['TrainingJobDescription'] = request.trainingJobDescription;
  }
  if (!Util.isUnset(request.trainingJobName)) {
    body['TrainingJobName'] = request.trainingJobName;
  }
  if (!Util.isUnset(request.userVpc)) {
    body['UserVpc'] = request.userVpc;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTrainingJob',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/trainingjobs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTrainingJob(request: CreateTrainingJobRequest): CreateTrainingJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTrainingJobWithOptions(request, headers, runtime);
}

model DeleteMachineGroupResponseBody = {
  machineGroupID?: string(name='MachineGroupID'),
  requestId?: string(name='RequestId'),
}

model DeleteMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMachineGroupResponseBody(name='body'),
}

async function deleteMachineGroupWithOptions(MachineGroupID: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMachineGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteMachineGroup',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/machinegroups/${OpenApiUtil.getEncodeParam(MachineGroupID)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMachineGroup(MachineGroupID: string): DeleteMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMachineGroupWithOptions(MachineGroupID, headers, runtime);
}

model DeleteQuotaResponseBody = {
  quotaId?: string(name='QuotaId', description='Quota Id', example='quotamtl37ge7gkvdz'),
  requestId?: string(name='RequestId', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model DeleteQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteQuotaResponseBody(name='body'),
}

async function deleteQuotaWithOptions(QuotaId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteQuotaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteQuota',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/quotas/${OpenApiUtil.getEncodeParam(QuotaId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteQuota(QuotaId: string): DeleteQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteQuotaWithOptions(QuotaId, headers, runtime);
}

model DeleteResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
  resourceGroupID?: string(name='ResourceGroupID'),
}

model DeleteResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceGroupResponseBody(name='body'),
}

async function deleteResourceGroupWithOptions(ResourceGroupID: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceGroup',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/${OpenApiUtil.getEncodeParam(ResourceGroupID)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteResourceGroup(ResourceGroupID: string): DeleteResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceGroupWithOptions(ResourceGroupID, headers, runtime);
}

model DeleteResourceGroupMachineGroupResponseBody = {
  machineGroupID?: string(name='MachineGroupID'),
  requestId?: string(name='RequestId'),
}

model DeleteResourceGroupMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceGroupMachineGroupResponseBody(name='body'),
}

async function deleteResourceGroupMachineGroupWithOptions(MachineGroupID: string, ResourceGroupID: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceGroupMachineGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceGroupMachineGroup',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/${OpenApiUtil.getEncodeParam(ResourceGroupID)}/machinegroups/${OpenApiUtil.getEncodeParam(MachineGroupID)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteResourceGroupMachineGroup(MachineGroupID: string, ResourceGroupID: string): DeleteResourceGroupMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceGroupMachineGroupWithOptions(MachineGroupID, ResourceGroupID, headers, runtime);
}

model GetAlgorithmResponseBody = {
  algorithmDescription?: string(name='AlgorithmDescription'),
  algorithmId?: string(name='AlgorithmId'),
  algorithmName?: string(name='AlgorithmName'),
  algorithmProvider?: string(name='AlgorithmProvider'),
  displayName?: string(name='DisplayName'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  requestId?: string(name='RequestId'),
  tenantId?: string(name='TenantId'),
  userId?: string(name='UserId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetAlgorithmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlgorithmResponseBody(name='body'),
}

async function getAlgorithmWithOptions(AlgorithmId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgorithmResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAlgorithm',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithms/${OpenApiUtil.getEncodeParam(AlgorithmId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAlgorithm(AlgorithmId: string): GetAlgorithmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgorithmWithOptions(AlgorithmId, headers, runtime);
}

model GetAlgorithmVersionResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  algorithmName?: string(name='AlgorithmName'),
  algorithmProvider?: string(name='AlgorithmProvider'),
  algorithmSpec?: AlgorithmSpec(name='AlgorithmSpec'),
  algorithmVersion?: string(name='AlgorithmVersion'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  tenantId?: string(name='TenantId'),
  userId?: string(name='UserId'),
}

model GetAlgorithmVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlgorithmVersionResponseBody(name='body'),
}

async function getAlgorithmVersionWithOptions(AlgorithmId: string, AlgorithmVersion: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgorithmVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAlgorithmVersion',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithms/${OpenApiUtil.getEncodeParam(AlgorithmId)}/versions/${OpenApiUtil.getEncodeParam(AlgorithmVersion)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAlgorithmVersion(AlgorithmId: string, AlgorithmVersion: string): GetAlgorithmVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgorithmVersionWithOptions(AlgorithmId, AlgorithmVersion, headers, runtime);
}

model GetMachineGroupResponseBody = {
  count?: long(name='Count'),
  defaultDriver?: string(name='DefaultDriver'),
  duration?: string(name='Duration'),
  ecsType?: string(name='EcsType'),
  gmtCreated?: string(name='GmtCreated'),
  gmtExpired?: string(name='GmtExpired'),
  gmtModified?: string(name='GmtModified'),
  gmtStarted?: string(name='GmtStarted'),
  machineGroupID?: string(name='MachineGroupID'),
  orderID?: string(name='OrderID'),
  PAIResourceID?: string(name='PAIResourceID'),
  payType?: string(name='PayType'),
  pricingCycle?: string(name='PricingCycle'),
  regionID?: string(name='RegionID'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  supportedDrivers?: [ string ](name='SupportedDrivers'),
}

model GetMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMachineGroupResponseBody(name='body'),
}

async function getMachineGroupWithOptions(MachineGroupID: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetMachineGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetMachineGroup',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/machinegroups/${OpenApiUtil.getEncodeParam(MachineGroupID)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMachineGroup(MachineGroupID: string): GetMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMachineGroupWithOptions(MachineGroupID, headers, runtime);
}

model GetNodeMetricsRequest {
  endTime?: string(name='EndTime'),
  GPUType?: string(name='GPUType'),
  startTime?: string(name='StartTime'),
  timeStep?: string(name='TimeStep'),
  verbose?: boolean(name='Verbose'),
}

model GetNodeMetricsResponseBody = {
  metricType?: string(name='MetricType'),
  nodesMetrics?: [
    NodeMetric
  ](name='NodesMetrics'),
  resourceGroupID?: string(name='ResourceGroupID'),
}

model GetNodeMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNodeMetricsResponseBody(name='body'),
}

async function getNodeMetricsWithOptions(ResourceGroupID: string, MetricType: string, request: GetNodeMetricsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetNodeMetricsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.GPUType)) {
    query['GPUType'] = request.GPUType;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.timeStep)) {
    query['TimeStep'] = request.timeStep;
  }
  if (!Util.isUnset(request.verbose)) {
    query['Verbose'] = request.verbose;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeMetrics',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/${OpenApiUtil.getEncodeParam(ResourceGroupID)}/nodemetrics/${OpenApiUtil.getEncodeParam(MetricType)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNodeMetrics(ResourceGroupID: string, MetricType: string, request: GetNodeMetricsRequest): GetNodeMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getNodeMetricsWithOptions(ResourceGroupID, MetricType, request, headers, runtime);
}

model GetQuotaResponseBody = {
  allocateStrategy?: string(name='AllocateStrategy', example='ByNodeSpec'),
  creatorId?: string(name='CreatorId', example='18846926616'),
  description?: string(name='Description', example='this is a test quota'),
  gmtCreatedTime?: string(name='GmtCreatedTime', example='2023-06-22T00:00:00Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', example='2023-06-22T00:00:00Z'),
  labels?: [
    Label
  ](name='Labels'),
  latestOperationId?: string(name='LatestOperationId', example='operation1234'),
  min?: ResourceSpec(name='Min'),
  parentQuotaId?: string(name='ParentQuotaId', example='quota1ci8g793pgm'),
  queueStrategy?: string(name='QueueStrategy', example='PaiStrategyIntelligent'),
  quotaConfig?: QuotaConfig(name='QuotaConfig'),
  quotaDetails?: QuotaDetails(name='QuotaDetails'),
  quotaId?: string(name='QuotaId', description='Quota Id', example='quotajradxh43rgb'),
  quotaName?: string(name='QuotaName', example='test-quota'),
  reasonCode?: string(name='ReasonCode', example='“”'),
  reasonMessage?: string(name='ReasonMessage', example='“”'),
  requestId?: string(name='RequestId', example='18D5A1C6-14B8-545E-8408-0A7DDB4C6B5E'),
  resourceGroupIds?: [ string ](name='ResourceGroupIds'),
  resourceType?: string(name='ResourceType', example='ECS'),
  status?: string(name='Status', example='Ready'),
  subQuotas?: [
    QuotaIdName
  ](name='SubQuotas'),
  workspaces?: [
    WorkspaceIdName
  ](name='Workspaces'),
}

model GetQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetQuotaResponseBody(name='body'),
}

async function getQuotaWithOptions(QuotaId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetQuotaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetQuota',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/quotas/${OpenApiUtil.getEncodeParam(QuotaId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getQuota(QuotaId: string): GetQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getQuotaWithOptions(QuotaId, headers, runtime);
}

model GetResourceGroupRequest {
  isAIWorkspaceDataEnabled?: boolean(name='IsAIWorkspaceDataEnabled'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model GetResourceGroupShrinkRequest {
  isAIWorkspaceDataEnabled?: boolean(name='IsAIWorkspaceDataEnabled'),
  tagShrink?: string(name='Tag'),
}

model GetResourceGroupResponseBody = {
  clusterID?: string(name='ClusterID'),
  computingResourceProvider?: string(name='ComputingResourceProvider'),
  creatorID?: string(name='CreatorID'),
  description?: string(name='Description'),
  gmtCreatedTime?: string(name='GmtCreatedTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  resourceType?: string(name='ResourceType'),
  status?: string(name='Status'),
  supportRDMA?: boolean(name='SupportRDMA'),
  tags?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Tags'),
  userVpc?: UserVpc(name='UserVpc'),
  workspaceID?: string(name='WorkspaceID'),
}

model GetResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceGroupResponseBody(name='body'),
}

async function getResourceGroupWithOptions(ResourceGroupID: string, tmpReq: GetResourceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetResourceGroupResponse {
  Util.validateModel(tmpReq);
  var request = new GetResourceGroupShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tag)) {
    request.tagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tag, 'Tag', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.isAIWorkspaceDataEnabled)) {
    query['IsAIWorkspaceDataEnabled'] = request.isAIWorkspaceDataEnabled;
  }
  if (!Util.isUnset(request.tagShrink)) {
    query['Tag'] = request.tagShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceGroup',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/${OpenApiUtil.getEncodeParam(ResourceGroupID)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResourceGroup(ResourceGroupID: string, request: GetResourceGroupRequest): GetResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getResourceGroupWithOptions(ResourceGroupID, request, headers, runtime);
}

model GetResourceGroupMachineGroupRequest {
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model GetResourceGroupMachineGroupShrinkRequest {
  tagShrink?: string(name='Tag'),
}

model GetResourceGroupMachineGroupResponseBody = {
  cpu?: string(name='Cpu'),
  defaultDriver?: string(name='DefaultDriver'),
  ecsCount?: long(name='EcsCount'),
  ecsSpec?: string(name='EcsSpec'),
  gmtCreatedTime?: string(name='GmtCreatedTime'),
  gmtExpiredTime?: string(name='GmtExpiredTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  gmtStartedTime?: string(name='GmtStartedTime'),
  gpu?: string(name='Gpu'),
  gpuType?: string(name='GpuType'),
  machineGroupID?: string(name='MachineGroupID'),
  memory?: string(name='Memory'),
  name?: string(name='Name'),
  paymentDuration?: string(name='PaymentDuration'),
  paymentDurationUnit?: string(name='PaymentDurationUnit'),
  paymentType?: string(name='PaymentType'),
  requestId?: string(name='RequestId'),
  resourceGroupID?: string(name='ResourceGroupID'),
  status?: string(name='Status'),
  supportedDrivers?: [ string ](name='SupportedDrivers'),
  tags?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Tags'),
}

model GetResourceGroupMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceGroupMachineGroupResponseBody(name='body'),
}

async function getResourceGroupMachineGroupWithOptions(MachineGroupID: string, ResourceGroupID: string, tmpReq: GetResourceGroupMachineGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetResourceGroupMachineGroupResponse {
  Util.validateModel(tmpReq);
  var request = new GetResourceGroupMachineGroupShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tag)) {
    request.tagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tag, 'Tag', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.tagShrink)) {
    query['Tag'] = request.tagShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceGroupMachineGroup',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/${OpenApiUtil.getEncodeParam(ResourceGroupID)}/machinegroups/${OpenApiUtil.getEncodeParam(MachineGroupID)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResourceGroupMachineGroup(MachineGroupID: string, ResourceGroupID: string, request: GetResourceGroupMachineGroupRequest): GetResourceGroupMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getResourceGroupMachineGroupWithOptions(MachineGroupID, ResourceGroupID, request, headers, runtime);
}

model GetResourceGroupRequestRequest {
  podStatus?: string(name='PodStatus'),
  resourceGroupID?: string(name='ResourceGroupID'),
}

model GetResourceGroupRequestResponseBody = {
  requestCPU?: int32(name='requestCPU'),
  requestGPU?: int32(name='requestGPU'),
  requestGPUInfos?: [
    GPUInfo
  ](name='requestGPUInfos'),
  requestMemory?: int32(name='requestMemory'),
}

model GetResourceGroupRequestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceGroupRequestResponseBody(name='body'),
}

async function getResourceGroupRequestWithOptions(request: GetResourceGroupRequestRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetResourceGroupRequestResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.podStatus)) {
    query['PodStatus'] = request.podStatus;
  }
  if (!Util.isUnset(request.resourceGroupID)) {
    query['ResourceGroupID'] = request.resourceGroupID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceGroupRequest',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/data/request`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResourceGroupRequest(request: GetResourceGroupRequestRequest): GetResourceGroupRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getResourceGroupRequestWithOptions(request, headers, runtime);
}

model GetResourceGroupTotalRequest {
  resourceGroupID?: string(name='ResourceGroupID'),
}

model GetResourceGroupTotalResponseBody = {
  totalCPU?: int32(name='totalCPU'),
  totalGPU?: int32(name='totalGPU'),
  totalGPUInfos?: [
    GPUInfo
  ](name='totalGPUInfos'),
  totalMemory?: int32(name='totalMemory'),
}

model GetResourceGroupTotalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceGroupTotalResponseBody(name='body'),
}

async function getResourceGroupTotalWithOptions(request: GetResourceGroupTotalRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetResourceGroupTotalResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.resourceGroupID)) {
    query['ResourceGroupID'] = request.resourceGroupID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceGroupTotal',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/data/total`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResourceGroupTotal(request: GetResourceGroupTotalRequest): GetResourceGroupTotalResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getResourceGroupTotalWithOptions(request, headers, runtime);
}

model GetTrainingJobResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  algorithmName?: string(name='AlgorithmName'),
  algorithmProvider?: string(name='AlgorithmProvider'),
  algorithmSpec?: AlgorithmSpec(name='AlgorithmSpec'),
  algorithmVersion?: string(name='AlgorithmVersion'),
  computeResource?: {
    ecsCount?: long(name='EcsCount'),
    ecsSpec?: string(name='EcsSpec'),
    instanceCount?: long(name='InstanceCount'),
    instanceSpec?: {
      CPU?: string(name='CPU'),
      GPU?: string(name='GPU'),
      GPUType?: string(name='GPUType'),
      memory?: string(name='Memory'),
      sharedMemory?: string(name='SharedMemory'),
    }(name='InstanceSpec'),
    resourceId?: string(name='ResourceId'),
  }(name='ComputeResource'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  hyperParameters?: [ 
    {
      name?: string(name='Name'),
      value?: string(name='Value'),
    }
  ](name='HyperParameters'),
  inputChannels?: [ 
    {
      datasetId?: string(name='DatasetId'),
      inputUri?: string(name='InputUri'),
      name?: string(name='Name'),
    }
  ](name='InputChannels'),
  instances?: [ 
    {
      name?: string(name='Name'),
      role?: string(name='Role'),
      status?: string(name='Status'),
    }
  ](name='Instances'),
  isTempAlgo?: boolean(name='IsTempAlgo'),
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
  latestMetrics?: [ 
    {
      name?: string(name='Name'),
      timestamp?: string(name='Timestamp'),
      value?: double(name='Value'),
    }
  ](name='LatestMetrics'),
  latestProgress?: {
    overallProgress?: {
      timestamp?: string(name='Timestamp'),
      value?: float(name='Value'),
    }(name='OverallProgress'),
    remainingTime?: {
      timestamp?: string(name='Timestamp'),
      value?: long(name='Value'),
    }(name='RemainingTime'),
  }(name='LatestProgress'),
  outputChannels?: [ 
    {
      datasetId?: string(name='DatasetId'),
      name?: string(name='Name'),
      outputUri?: string(name='OutputUri'),
    }
  ](name='OutputChannels'),
  outputModel?: {
    outputChannelName?: string(name='OutputChannelName'),
    uri?: string(name='Uri'),
  }(name='OutputModel'),
  reasonCode?: string(name='ReasonCode'),
  reasonMessage?: string(name='ReasonMessage'),
  requestId?: string(name='RequestId'),
  roleArn?: string(name='RoleArn'),
  scheduler?: {
    maxRunningTimeInSeconds?: long(name='MaxRunningTimeInSeconds'),
  }(name='Scheduler'),
  settings?: {
    AIMasterType?: string(name='AIMasterType'),
    enableErrorMonitoringInAIMaster?: boolean(name='EnableErrorMonitoringInAIMaster'),
    errorMonitoringArgs?: string(name='ErrorMonitoringArgs'),
    priority?: int32(name='Priority'),
  }(name='Settings'),
  status?: string(name='Status'),
  statusTransitions?: [ 
    {
      endTime?: string(name='EndTime'),
      reasonCode?: string(name='ReasonCode'),
      reasonMessage?: string(name='ReasonMessage'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
    }
  ](name='StatusTransitions'),
  trainingJobDescription?: string(name='TrainingJobDescription'),
  trainingJobId?: string(name='TrainingJobId'),
  trainingJobName?: string(name='TrainingJobName'),
  trainingJobUrl?: string(name='TrainingJobUrl'),
  userId?: string(name='UserId'),
  userVpc?: {
    extendedCIDRs?: [ string ](name='ExtendedCIDRs'),
    securityGroupId?: string(name='SecurityGroupId'),
    switchId?: string(name='SwitchId'),
    vpcId?: string(name='VpcId'),
  }(name='UserVpc'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetTrainingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTrainingJobResponseBody(name='body'),
}

async function getTrainingJobWithOptions(TrainingJobId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTrainingJobResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTrainingJob',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/trainingjobs/${OpenApiUtil.getEncodeParam(TrainingJobId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTrainingJob(TrainingJobId: string): GetTrainingJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTrainingJobWithOptions(TrainingJobId, headers, runtime);
}

model GetUserViewMetricsRequest {
  order?: string(name='Order'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  sortBy?: string(name='SortBy'),
  timeStep?: string(name='TimeStep'),
  userId?: string(name='UserId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetUserViewMetricsResponseBody = {
  resourceGroupId?: string(name='ResourceGroupId'),
  summary?: UserViewMetric(name='Summary'),
  total?: int32(name='Total'),
  userMetrics?: [
    UserViewMetric
  ](name='UserMetrics'),
}

model GetUserViewMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserViewMetricsResponseBody(name='body'),
}

async function getUserViewMetricsWithOptions(ResourceGroupID: string, request: GetUserViewMetricsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetUserViewMetricsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.timeStep)) {
    query['TimeStep'] = request.timeStep;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserViewMetrics',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/${OpenApiUtil.getEncodeParam(ResourceGroupID)}/usermetrics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserViewMetrics(ResourceGroupID: string, request: GetUserViewMetricsRequest): GetUserViewMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUserViewMetricsWithOptions(ResourceGroupID, request, headers, runtime);
}

model ListAlgorithmVersionsRequest {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
}

model ListAlgorithmVersionsResponseBody = {
  algorithmVersions?: [ 
    {
      algorithmId?: string(name='AlgorithmId'),
      algorithmName?: string(name='AlgorithmName'),
      algorithmProvider?: string(name='AlgorithmProvider'),
      algorithmVersion?: string(name='AlgorithmVersion'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      tenantId?: string(name='TenantId'),
      userId?: string(name='UserId'),
    }
  ](name='AlgorithmVersions'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListAlgorithmVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlgorithmVersionsResponseBody(name='body'),
}

async function listAlgorithmVersionsWithOptions(AlgorithmId: string, request: ListAlgorithmVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAlgorithmVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlgorithmVersions',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithms/${OpenApiUtil.getEncodeParam(AlgorithmId)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlgorithmVersions(AlgorithmId: string, request: ListAlgorithmVersionsRequest): ListAlgorithmVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAlgorithmVersionsWithOptions(AlgorithmId, request, headers, runtime);
}

model ListAlgorithmsRequest {
  algorithmId?: string(name='AlgorithmId'),
  algorithmName?: string(name='AlgorithmName'),
  algorithmProvider?: string(name='AlgorithmProvider'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListAlgorithmsResponseBody = {
  algorithms?: [ 
    {
      algorithmDescription?: string(name='AlgorithmDescription'),
      algorithmId?: string(name='AlgorithmId'),
      algorithmName?: string(name='AlgorithmName'),
      algorithmProvider?: string(name='AlgorithmProvider'),
      displayName?: string(name='DisplayName'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      userId?: string(name='UserId'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='Algorithms'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListAlgorithmsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlgorithmsResponseBody(name='body'),
}

async function listAlgorithmsWithOptions(request: ListAlgorithmsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAlgorithmsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.algorithmId)) {
    query['AlgorithmId'] = request.algorithmId;
  }
  if (!Util.isUnset(request.algorithmName)) {
    query['AlgorithmName'] = request.algorithmName;
  }
  if (!Util.isUnset(request.algorithmProvider)) {
    query['AlgorithmProvider'] = request.algorithmProvider;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlgorithms',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithms`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlgorithms(request: ListAlgorithmsRequest): ListAlgorithmsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAlgorithmsWithOptions(request, headers, runtime);
}

model ListQuotasRequest {
  labels?: string(name='Labels', example='official=true,gpu=false'),
  layoutMode?: string(name='LayoutMode'),
  order?: string(name='Order', example='desc'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='20'),
  parentQuotaId?: string(name='ParentQuotaId', example='quotajradxh43rgb'),
  quotaIds?: string(name='QuotaIds', example='quota1ci8g793pgm,quotajradxh43rgb'),
  quotaName?: string(name='QuotaName', example='quotajradxh43rgb'),
  resourceType?: string(name='ResourceType', example='ECS'),
  sortBy?: string(name='SortBy', example='status'),
  statuses?: string(name='Statuses', example='Creating'),
  workspaceIds?: string(name='WorkspaceIds', example='21345,38727'),
}

model ListQuotasResponseBody = {
  quotas?: [
    Quota
  ](name='Quotas'),
  requestId?: string(name='RequestId', example='F082BD0D-21E1-5F9B-81A0-AB07485B03CD'),
}

model ListQuotasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListQuotasResponseBody(name='body'),
}

async function listQuotasWithOptions(request: ListQuotasRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListQuotasResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.layoutMode)) {
    query['LayoutMode'] = request.layoutMode;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parentQuotaId)) {
    query['ParentQuotaId'] = request.parentQuotaId;
  }
  if (!Util.isUnset(request.quotaIds)) {
    query['QuotaIds'] = request.quotaIds;
  }
  if (!Util.isUnset(request.quotaName)) {
    query['QuotaName'] = request.quotaName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.statuses)) {
    query['Statuses'] = request.statuses;
  }
  if (!Util.isUnset(request.workspaceIds)) {
    query['WorkspaceIds'] = request.workspaceIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListQuotas',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/quotas/`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listQuotas(request: ListQuotasRequest): ListQuotasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listQuotasWithOptions(request, headers, runtime);
}

model ListResourceGroupMachineGroupsRequest {
  creatorID?: string(name='CreatorID'),
  ecsSpec?: string(name='EcsSpec'),
  name?: string(name='Name'),
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  paymentDuration?: string(name='PaymentDuration'),
  paymentDurationUnit?: string(name='PaymentDurationUnit'),
  paymentType?: string(name='PaymentType'),
  sortBy?: string(name='SortBy'),
  status?: string(name='Status'),
}

model ListResourceGroupMachineGroupsResponseBody = {
  machineGroups?: [
    MachineGroup
  ](name='MachineGroups'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListResourceGroupMachineGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceGroupMachineGroupsResponseBody(name='body'),
}

async function listResourceGroupMachineGroupsWithOptions(ResourceGroupID: string, request: ListResourceGroupMachineGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceGroupMachineGroupsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.creatorID)) {
    query['CreatorID'] = request.creatorID;
  }
  if (!Util.isUnset(request.ecsSpec)) {
    query['EcsSpec'] = request.ecsSpec;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.paymentDuration)) {
    query['PaymentDuration'] = request.paymentDuration;
  }
  if (!Util.isUnset(request.paymentDurationUnit)) {
    query['PaymentDurationUnit'] = request.paymentDurationUnit;
  }
  if (!Util.isUnset(request.paymentType)) {
    query['PaymentType'] = request.paymentType;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceGroupMachineGroups',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/${OpenApiUtil.getEncodeParam(ResourceGroupID)}/machinegroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceGroupMachineGroups(ResourceGroupID: string, request: ListResourceGroupMachineGroupsRequest): ListResourceGroupMachineGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceGroupMachineGroupsWithOptions(ResourceGroupID, request, headers, runtime);
}

model ListResourceGroupsRequest {
  computingResourceProvider?: string(name='ComputingResourceProvider'),
  name?: string(name='Name', example='RG1'),
  order?: string(name='Order', example='desc'),
  pageNumber?: long(name='PageNumber', example='2'),
  pageSize?: long(name='PageSize', example='10'),
  resourceType?: string(name='ResourceType'),
  showAll?: boolean(name='ShowAll'),
  sortBy?: string(name='SortBy', example='DisplayName'),
  status?: string(name='Status', example='Creating'),
}

model ListResourceGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  resourceGroups?: [
    ResourceGroup
  ](name='ResourceGroups', example='RG1'),
  totalCount?: long(name='TotalCount', example='2'),
}

model ListResourceGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceGroupsResponseBody(name='body'),
}

async function listResourceGroupsWithOptions(request: ListResourceGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceGroupsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.computingResourceProvider)) {
    query['ComputingResourceProvider'] = request.computingResourceProvider;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.showAll)) {
    query['ShowAll'] = request.showAll;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceGroups',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceGroups(request: ListResourceGroupsRequest): ListResourceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceGroupsWithOptions(request, headers, runtime);
}

model ListTrainingJobLogsRequest {
  endTime?: string(name='EndTime', example='2020-11-08T16:00:00Z'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: long(name='PageNumber', example='1'),
  pageSize?: long(name='PageSize', example='100'),
  startTime?: string(name='StartTime', example='2020-11-08T16:00:00Z'),
  workerId?: string(name='WorkerId'),
}

model ListTrainingJobLogsResponseBody = {
  logs?: [ string ](name='Logs'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListTrainingJobLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTrainingJobLogsResponseBody(name='body'),
}

async function listTrainingJobLogsWithOptions(TrainingJobId: string, request: ListTrainingJobLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTrainingJobLogsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.workerId)) {
    query['WorkerId'] = request.workerId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTrainingJobLogs',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/trainingjobs/${OpenApiUtil.getEncodeParam(TrainingJobId)}/logs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTrainingJobLogs(TrainingJobId: string, request: ListTrainingJobLogsRequest): ListTrainingJobLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTrainingJobLogsWithOptions(TrainingJobId, request, headers, runtime);
}

model ListTrainingJobMetricsRequest {
  endTime?: string(name='EndTime', example='2020-11-08T16:00:00Z'),
  name?: string(name='Name'),
  order?: string(name='Order'),
  pageNumber?: long(name='PageNumber', example='1'),
  pageSize?: long(name='PageSize', example='100'),
  startTime?: string(name='StartTime', example='2020-11-08T16:00:00Z'),
}

model ListTrainingJobMetricsResponseBody = {
  metrics?: [ 
    {
      name?: string(name='Name'),
      timestamp?: string(name='Timestamp'),
      value?: double(name='Value'),
    }
  ](name='Metrics'),
  requestId?: string(name='RequestId'),
}

model ListTrainingJobMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTrainingJobMetricsResponseBody(name='body'),
}

async function listTrainingJobMetricsWithOptions(TrainingJobId: string, request: ListTrainingJobMetricsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTrainingJobMetricsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTrainingJobMetrics',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/trainingjobs/${OpenApiUtil.getEncodeParam(TrainingJobId)}/metrics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTrainingJobMetrics(TrainingJobId: string, request: ListTrainingJobMetricsRequest): ListTrainingJobMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTrainingJobMetricsWithOptions(TrainingJobId, request, headers, runtime);
}

model ListTrainingJobsRequest {
  algorithmName?: string(name='AlgorithmName'),
  algorithmProvider?: string(name='AlgorithmProvider'),
  endTime?: string(name='EndTime'),
  isTempAlgo?: boolean(name='IsTempAlgo'),
  labels?: map[string]any(name='Labels'),
  order?: string(name='Order'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  sortBy?: string(name='SortBy'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
  trainingJobId?: string(name='TrainingJobId'),
  trainingJobName?: string(name='TrainingJobName'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListTrainingJobsShrinkRequest {
  algorithmName?: string(name='AlgorithmName'),
  algorithmProvider?: string(name='AlgorithmProvider'),
  endTime?: string(name='EndTime'),
  isTempAlgo?: boolean(name='IsTempAlgo'),
  labelsShrink?: string(name='Labels'),
  order?: string(name='Order'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  sortBy?: string(name='SortBy'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
  trainingJobId?: string(name='TrainingJobId'),
  trainingJobName?: string(name='TrainingJobName'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListTrainingJobsResponseBody = {
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  trainingJobs?: [ 
    {
      algorithmName?: string(name='AlgorithmName'),
      algorithmProvider?: string(name='AlgorithmProvider'),
      algorithmVersion?: string(name='AlgorithmVersion'),
      computeResource?: {
        ecsCount?: long(name='EcsCount'),
        ecsSpec?: string(name='EcsSpec'),
        instanceCount?: long(name='InstanceCount'),
        instanceSpec?: {
          CPU?: string(name='CPU'),
          GPU?: string(name='GPU'),
          GPUType?: string(name='GPUType'),
          memory?: string(name='Memory'),
          sharedMemory?: string(name='SharedMemory'),
        }(name='InstanceSpec'),
        resourceId?: string(name='ResourceId'),
      }(name='ComputeResource'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      hyperParameters?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='HyperParameters'),
      inputChannels?: [ 
        {
          datasetId?: string(name='DatasetId'),
          inputUri?: string(name='InputUri'),
          name?: string(name='Name'),
        }
      ](name='InputChannels'),
      isTempAlgo?: boolean(name='IsTempAlgo'),
      labels?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Labels'),
      outputChannels?: [ 
        {
          datasetId?: string(name='DatasetId'),
          name?: string(name='Name'),
          outputUri?: string(name='OutputUri'),
        }
      ](name='OutputChannels'),
      reasonCode?: string(name='ReasonCode'),
      reasonMessage?: string(name='ReasonMessage'),
      roleArn?: string(name='RoleArn'),
      scheduler?: {
        maxRunningTimeInSeconds?: long(name='MaxRunningTimeInSeconds'),
      }(name='Scheduler'),
      status?: string(name='Status'),
      statusTransitions?: [ 
        {
          endTime?: string(name='EndTime'),
          reasonCode?: string(name='ReasonCode'),
          reasonMessage?: string(name='ReasonMessage'),
          startTime?: string(name='StartTime'),
          status?: string(name='Status'),
        }
      ](name='StatusTransitions'),
      trainingJobDescription?: string(name='TrainingJobDescription'),
      trainingJobId?: string(name='TrainingJobId'),
      trainingJobName?: string(name='TrainingJobName'),
      userId?: string(name='UserId'),
      userVpc?: {
        defaultRoute?: string(name='DefaultRoute'),
        extendedCIDRs?: [ string ](name='ExtendedCIDRs'),
        securityGroupId?: string(name='SecurityGroupId'),
        switchId?: string(name='SwitchId'),
        vpcId?: string(name='VpcId'),
      }(name='UserVpc'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='TrainingJobs'),
}

model ListTrainingJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTrainingJobsResponseBody(name='body'),
}

async function listTrainingJobsWithOptions(tmpReq: ListTrainingJobsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTrainingJobsResponse {
  Util.validateModel(tmpReq);
  var request = new ListTrainingJobsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.labels)) {
    request.labelsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labels, 'Labels', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.algorithmName)) {
    query['AlgorithmName'] = request.algorithmName;
  }
  if (!Util.isUnset(request.algorithmProvider)) {
    query['AlgorithmProvider'] = request.algorithmProvider;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.isTempAlgo)) {
    query['IsTempAlgo'] = request.isTempAlgo;
  }
  if (!Util.isUnset(request.labelsShrink)) {
    query['Labels'] = request.labelsShrink;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.trainingJobId)) {
    query['TrainingJobId'] = request.trainingJobId;
  }
  if (!Util.isUnset(request.trainingJobName)) {
    query['TrainingJobName'] = request.trainingJobName;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTrainingJobs',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/trainingjobs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTrainingJobs(request: ListTrainingJobsRequest): ListTrainingJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTrainingJobsWithOptions(request, headers, runtime);
}

model ScaleQuotaRequest {
  min?: ResourceSpec(name='Min'),
  resourceGroupIds?: [ string ](name='ResourceGroupIds'),
}

model ScaleQuotaResponseBody = {
  quotaId?: string(name='QuotaId', description='Quota Id', example='quotamtl37ge7gkvdz'),
  requestId?: string(name='RequestId', example='F2D0392B-D749-5C48-A98A-3FAE5C9444A6'),
}

model ScaleQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ScaleQuotaResponseBody(name='body'),
}

async function scaleQuotaWithOptions(QuotaId: string, request: ScaleQuotaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleQuotaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.min)) {
    body['Min'] = request.min;
  }
  if (!Util.isUnset(request.resourceGroupIds)) {
    body['ResourceGroupIds'] = request.resourceGroupIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ScaleQuota',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/quotas/${OpenApiUtil.getEncodeParam(QuotaId)}/action/scale`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function scaleQuota(QuotaId: string, request: ScaleQuotaRequest): ScaleQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleQuotaWithOptions(QuotaId, request, headers, runtime);
}

model StopTrainingJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopTrainingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopTrainingJobResponseBody(name='body'),
}

async function stopTrainingJobWithOptions(TrainingJobId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopTrainingJobResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopTrainingJob',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/trainingjobs/${OpenApiUtil.getEncodeParam(TrainingJobId)}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopTrainingJob(TrainingJobId: string): StopTrainingJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopTrainingJobWithOptions(TrainingJobId, headers, runtime);
}

model UpdateAlgorithmRequest {
  algorithmDescription?: string(name='AlgorithmDescription'),
  displayName?: string(name='DisplayName'),
}

model UpdateAlgorithmResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  requestId?: string(name='RequestId'),
}

model UpdateAlgorithmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAlgorithmResponseBody(name='body'),
}

async function updateAlgorithmWithOptions(AlgorithmId: string, request: UpdateAlgorithmRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAlgorithmResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmDescription)) {
    body['AlgorithmDescription'] = request.algorithmDescription;
  }
  if (!Util.isUnset(request.displayName)) {
    body['DisplayName'] = request.displayName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlgorithm',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithms/${OpenApiUtil.getEncodeParam(AlgorithmId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAlgorithm(AlgorithmId: string, request: UpdateAlgorithmRequest): UpdateAlgorithmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAlgorithmWithOptions(AlgorithmId, request, headers, runtime);
}

model UpdateAlgorithmVersionRequest {
  algorithmSpec?: AlgorithmSpec(name='AlgorithmSpec'),
}

model UpdateAlgorithmVersionShrinkRequest {
  algorithmSpecShrink?: string(name='AlgorithmSpec'),
}

model UpdateAlgorithmVersionResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  algorithmVersion?: string(name='AlgorithmVersion'),
}

model UpdateAlgorithmVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAlgorithmVersionResponseBody(name='body'),
}

async function updateAlgorithmVersionWithOptions(AlgorithmId: string, AlgorithmVersion: string, tmpReq: UpdateAlgorithmVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAlgorithmVersionResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateAlgorithmVersionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.algorithmSpec)) {
    request.algorithmSpecShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.algorithmSpec, 'AlgorithmSpec', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmSpecShrink)) {
    body['AlgorithmSpec'] = request.algorithmSpecShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlgorithmVersion',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithms/${OpenApiUtil.getEncodeParam(AlgorithmId)}/versions/${OpenApiUtil.getEncodeParam(AlgorithmVersion)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAlgorithmVersion(AlgorithmId: string, AlgorithmVersion: string, request: UpdateAlgorithmVersionRequest): UpdateAlgorithmVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAlgorithmVersionWithOptions(AlgorithmId, AlgorithmVersion, request, headers, runtime);
}

model UpdateQuotaRequest {
  description?: string(name='Description', example='this is a test quota'),
  labels?: [
    Label
  ](name='Labels'),
  queueStrategy?: string(name='QueueStrategy'),
}

model UpdateQuotaResponseBody = {
  quotaId?: string(name='QuotaId', description='Quota Id', example='quota-20210126170216-mtl37ge7gkvdz'),
  requestId?: string(name='RequestId', example='96496E6E-00B4-5F55-80F6-1844FA9E92DC'),
}

model UpdateQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateQuotaResponseBody(name='body'),
}

async function updateQuotaWithOptions(QuotaId: string, request: UpdateQuotaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateQuotaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.queueStrategy)) {
    body['QueueStrategy'] = request.queueStrategy;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateQuota',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/quotas/${OpenApiUtil.getEncodeParam(QuotaId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateQuota(QuotaId: string, request: UpdateQuotaRequest): UpdateQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateQuotaWithOptions(QuotaId, request, headers, runtime);
}

model UpdateResourceGroupRequest {
  description?: string(name='Description'),
  name?: string(name='Name'),
  unbind?: boolean(name='Unbind'),
  userVpc?: UserVpc(name='UserVpc'),
}

model UpdateResourceGroupResponseBody = {
  resourceGroupID?: string(name='ResourceGroupID'),
  requestId?: string(name='requestId'),
}

model UpdateResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateResourceGroupResponseBody(name='body'),
}

async function updateResourceGroupWithOptions(ResourceGroupID: string, request: UpdateResourceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateResourceGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.unbind)) {
    body['Unbind'] = request.unbind;
  }
  if (!Util.isUnset(request.userVpc)) {
    body['UserVpc'] = request.userVpc;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResourceGroup',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/${OpenApiUtil.getEncodeParam(ResourceGroupID)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateResourceGroup(ResourceGroupID: string, request: UpdateResourceGroupRequest): UpdateResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateResourceGroupWithOptions(ResourceGroupID, request, headers, runtime);
}

model UpdateTrainingJobLabelsRequest {
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
}

model UpdateTrainingJobLabelsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTrainingJobLabelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTrainingJobLabelsResponseBody(name='body'),
}

async function updateTrainingJobLabelsWithOptions(TrainingJobId: string, request: UpdateTrainingJobLabelsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTrainingJobLabelsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTrainingJobLabels',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/trainingjobs/${OpenApiUtil.getEncodeParam(TrainingJobId)}/labels`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTrainingJobLabels(TrainingJobId: string, request: UpdateTrainingJobLabelsRequest): UpdateTrainingJobLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTrainingJobLabelsWithOptions(TrainingJobId, request, headers, runtime);
}

