/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'pai.cn-beijing.aliyuncs.com',
    cn-hangzhou = 'pai.cn-hangzhou.aliyuncs.com',
    cn-shanghai = 'pai.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'pai.cn-shenzhen.aliyuncs.com',
    cn-hongkong = 'pai.cn-hongkong.aliyuncs.com',
    ap-southeast-1 = 'pai.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'pai.ap-southeast-2.aliyuncs.com',
    ap-southeast-3 = 'pai.ap-southeast-3.aliyuncs.com',
    ap-southeast-5 = 'pai.ap-southeast-5.aliyuncs.com',
    us-west-1 = 'pai.us-west-1.aliyuncs.com',
    us-east-1 = 'pai.us-east-1.aliyuncs.com',
    eu-central-1 = 'pai.eu-central-1.aliyuncs.com',
    me-east-1 = 'pai.me-east-1.aliyuncs.com',
    ap-south-1 = 'pai.ap-south-1.aliyuncs.com',
    cn-qingdao = 'pai.cn-qingdao.aliyuncs.com',
    cn-zhangjiakou = 'pai.cn-zhangjiakou.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('paistudio', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AlgorithmSpec {
  command?: [ string ](name='Command'),
  computeResource?: {
    policy?: {
      value?: string(name='Value'),
      version?: string(name='Version'),
    }(name='Policy'),
  }(name='ComputeResource'),
  hyperParameters?: [
    HyperParameterDefinition
  ](name='HyperParameters'),
  image?: string(name='Image'),
  inputChannels?: [
    Channel
  ](name='InputChannels'),
  jobType?: string(name='JobType'),
  metricDefinitions?: [
    MetricDefinition
  ](name='MetricDefinitions'),
  outputChannels?: [
    Channel
  ](name='OutputChannels'),
  supportedInstanceTypes?: [ string ](name='SupportedInstanceTypes'),
  supportsDistributedTraining?: boolean(name='SupportsDistributedTraining'),
}

model Channel {
  description?: string(name='Description'),
  name?: string(name='Name'),
  properties?: [
    ChannelProperty
  ](name='Properties'),
  required?: boolean(name='Required'),
  supportedChannelTypes?: [ string ](name='SupportedChannelTypes'),
}

model ChannelProperty {
  name?: string(name='Name'),
  value?: string(name='Value'),
}

model GPUInfo {
  count?: long(name='count'),
  type?: string(name='type'),
}

model HyperParameterDefinition {
  defaultValue?: string(name='DefaultValue'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  required?: boolean(name='Required'),
  type?: string(name='Type'),
}

model MachineGroup {
  creatorID?: string(name='CreatorID'),
  ecsCount?: long(name='EcsCount'),
  ecsSpec?: string(name='EcsSpec'),
  gmtCreatedTime?: string(name='GmtCreatedTime'),
  gmtExpiredTime?: string(name='GmtExpiredTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  gmtStartedTime?: string(name='GmtStartedTime'),
  machineGroupID?: string(name='MachineGroupID'),
  paymentDuration?: string(name='PaymentDuration'),
  paymentDurationUnit?: string(name='PaymentDurationUnit'),
  paymentType?: string(name='PaymentType'),
  reasonCode?: string(name='ReasonCode'),
  reasonMessage?: string(name='ReasonMessage'),
  resourceGroupID?: string(name='ResourceGroupID'),
  status?: string(name='Status'),
}

model Metric {
  time?: long(name='Time'),
  value?: string(name='Value'),
}

model MetricDefinition {
  description?: string(name='Description'),
  name?: string(name='Name'),
  regex?: string(name='Regex'),
}

model NodeMetric {
  GPUType?: string(name='GPUType'),
  metrics?: [
    Metric
  ](name='Metrics'),
  nodeID?: string(name='NodeID'),
}

model ResourceGroup {
  creatorID?: string(name='CreatorID'),
  gmtCreatedTime?: string(name='GmtCreatedTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  name?: string(name='Name'),
  resourceGroupID?: string(name='ResourceGroupID'),
  userVpc?: UserVpc(name='UserVpc'),
  workspaceID?: string(name='WorkspaceID'),
}

model ResourceGroupMetric {
  gpuType?: string(name='GpuType'),
  metrics?: [
    Metric
  ](name='Metrics'),
  resourceGroupID?: string(name='ResourceGroupID'),
}

model UserViewMetric {
  CPUNodeNumber?: int32(name='CPUNodeNumber'),
  CPUUsageRate?: string(name='CPUUsageRate'),
  cpuJobNames?: [ string ](name='CpuJobNames'),
  cpuNodeNames?: [ string ](name='CpuNodeNames'),
  diskReadRate?: string(name='DiskReadRate'),
  diskWriteRate?: string(name='DiskWriteRate'),
  GPUNodeNumber?: int32(name='GPUNodeNumber'),
  GPUUsageRate?: string(name='GPUUsageRate'),
  gpuJobNames?: [ string ](name='GpuJobNames'),
  gpuNodeNames?: [ string ](name='GpuNodeNames'),
  jobType?: string(name='JobType'),
  memoryUsageRate?: string(name='MemoryUsageRate'),
  networkInputRate?: string(name='NetworkInputRate'),
  networkOutputRate?: string(name='NetworkOutputRate'),
  nodeNames?: [ string ](name='NodeNames'),
  requestCPU?: int32(name='RequestCPU'),
  requestGPU?: int32(name='RequestGPU'),
  requestMemory?: long(name='RequestMemory'),
  resourceGroupId?: string(name='ResourceGroupId'),
  totalCPU?: int32(name='TotalCPU'),
  totalGPU?: int32(name='TotalGPU'),
  totalMemory?: long(name='TotalMemory'),
  userId?: string(name='UserId'),
}

model UserVpc {
  extendedCIDRs?: [ string ](name='ExtendedCIDRs'),
  roleArn?: string(name='RoleArn'),
  securityGroupId?: string(name='SecurityGroupId'),
  switchId?: string(name='SwitchId'),
  vpcId?: string(name='VpcId'),
}

model CreateAlgorithmRequest {
  algorithmDescription?: string(name='AlgorithmDescription'),
  algorithmName?: string(name='AlgorithmName'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateAlgorithmResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  requestId?: string(name='RequestId'),
}

model CreateAlgorithmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAlgorithmResponseBody(name='body'),
}

async function createAlgorithm(request: CreateAlgorithmRequest): CreateAlgorithmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAlgorithmWithOptions(request, headers, runtime);
}

async function createAlgorithmWithOptions(request: CreateAlgorithmRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAlgorithmResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmDescription)) {
    body['AlgorithmDescription'] = request.algorithmDescription;
  }
  if (!Util.isUnset(request.algorithmName)) {
    body['AlgorithmName'] = request.algorithmName;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlgorithm',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithms`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateAlgorithmVersionRequest {
  algorithmSpec?: AlgorithmSpec(name='AlgorithmSpec'),
}

model CreateAlgorithmVersionShrinkRequest {
  algorithmSpecShrink?: string(name='AlgorithmSpec'),
}

model CreateAlgorithmVersionResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  algorithmVersion?: string(name='AlgorithmVersion'),
}

model CreateAlgorithmVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAlgorithmVersionResponseBody(name='body'),
}

async function createAlgorithmVersion(AlgorithmId: string, AlgorithmVersion: string, request: CreateAlgorithmVersionRequest): CreateAlgorithmVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAlgorithmVersionWithOptions(AlgorithmId, AlgorithmVersion, request, headers, runtime);
}

async function createAlgorithmVersionWithOptions(AlgorithmId: string, AlgorithmVersion: string, tmpReq: CreateAlgorithmVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAlgorithmVersionResponse {
  Util.validateModel(tmpReq);
  var request = new CreateAlgorithmVersionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.algorithmSpec)) {
    request.algorithmSpecShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.algorithmSpec, 'AlgorithmSpec', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmSpecShrink)) {
    body['AlgorithmSpec'] = request.algorithmSpecShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlgorithmVersion',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithms/${OpenApiUtil.getEncodeParam(AlgorithmId)}/versions/${OpenApiUtil.getEncodeParam(AlgorithmVersion)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateResourceGroupRequest {
  description?: string(name='Description'),
  name?: string(name='Name'),
  userVpc?: UserVpc(name='UserVpc'),
}

model CreateResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
  resourceGroupID?: string(name='ResourceGroupID'),
}

model CreateResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResourceGroupResponseBody(name='body'),
}

async function createResourceGroup(request: CreateResourceGroupRequest): CreateResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createResourceGroupWithOptions(request, headers, runtime);
}

async function createResourceGroupWithOptions(request: CreateResourceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateResourceGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.userVpc)) {
    body['UserVpc'] = request.userVpc;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourceGroup',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateTrainingJobRequest {
  algorithmName?: string(name='AlgorithmName'),
  algorithmProvider?: string(name='AlgorithmProvider'),
  algorithmVersion?: string(name='AlgorithmVersion'),
  computeResource?: {
    ecsCount?: long(name='EcsCount'),
    ecsSpec?: string(name='EcsSpec'),
  }(name='ComputeResource'),
  hyperParameters?: [ 
    {
      name?: string(name='Name'),
      value?: string(name='Value'),
    }
  ](name='HyperParameters'),
  inputChannels?: [ 
    {
      datasetId?: string(name='DatasetId'),
      inputUri?: string(name='InputUri'),
      name?: string(name='Name'),
    }
  ](name='InputChannels'),
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
  outputChannels?: [ 
    {
      datasetId?: string(name='DatasetId'),
      name?: string(name='Name'),
      outputUri?: string(name='OutputUri'),
    }
  ](name='OutputChannels'),
  scheduler?: {
    maxRunningTimeInSeconds?: long(name='MaxRunningTimeInSeconds'),
  }(name='Scheduler'),
  trainingJobDescription?: string(name='TrainingJobDescription'),
  trainingJobName?: string(name='TrainingJobName'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateTrainingJobResponseBody = {
  requestId?: string(name='RequestId'),
  trainingJobId?: string(name='TrainingJobId'),
}

model CreateTrainingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTrainingJobResponseBody(name='body'),
}

async function createTrainingJob(request: CreateTrainingJobRequest): CreateTrainingJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTrainingJobWithOptions(request, headers, runtime);
}

async function createTrainingJobWithOptions(request: CreateTrainingJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTrainingJobResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmName)) {
    body['AlgorithmName'] = request.algorithmName;
  }
  if (!Util.isUnset(request.algorithmProvider)) {
    body['AlgorithmProvider'] = request.algorithmProvider;
  }
  if (!Util.isUnset(request.algorithmVersion)) {
    body['AlgorithmVersion'] = request.algorithmVersion;
  }
  if (!Util.isUnset(request.computeResource)) {
    body['ComputeResource'] = request.computeResource;
  }
  if (!Util.isUnset(request.hyperParameters)) {
    body['HyperParameters'] = request.hyperParameters;
  }
  if (!Util.isUnset(request.inputChannels)) {
    body['InputChannels'] = request.inputChannels;
  }
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.outputChannels)) {
    body['OutputChannels'] = request.outputChannels;
  }
  if (!Util.isUnset(request.scheduler)) {
    body['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.trainingJobDescription)) {
    body['TrainingJobDescription'] = request.trainingJobDescription;
  }
  if (!Util.isUnset(request.trainingJobName)) {
    body['TrainingJobName'] = request.trainingJobName;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTrainingJob',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/trainingjobs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteMachineGroupResponseBody = {
  machineGroupID?: string(name='MachineGroupID'),
  requestId?: string(name='RequestId'),
}

model DeleteMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMachineGroupResponseBody(name='body'),
}

async function deleteMachineGroup(MachineGroupID: string): DeleteMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMachineGroupWithOptions(MachineGroupID, headers, runtime);
}

async function deleteMachineGroupWithOptions(MachineGroupID: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMachineGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteMachineGroup',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/machinegroups/${OpenApiUtil.getEncodeParam(MachineGroupID)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
  resourceGroupID?: string(name='ResourceGroupID'),
}

model DeleteResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceGroupResponseBody(name='body'),
}

async function deleteResourceGroup(ResourceGroupID: string): DeleteResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceGroupWithOptions(ResourceGroupID, headers, runtime);
}

async function deleteResourceGroupWithOptions(ResourceGroupID: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceGroup',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/${OpenApiUtil.getEncodeParam(ResourceGroupID)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteResourceGroupMachineGroupResponseBody = {
  machineGroupID?: string(name='MachineGroupID'),
  requestId?: string(name='RequestId'),
}

model DeleteResourceGroupMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceGroupMachineGroupResponseBody(name='body'),
}

async function deleteResourceGroupMachineGroup(MachineGroupID: string, ResourceGroupID: string): DeleteResourceGroupMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceGroupMachineGroupWithOptions(MachineGroupID, ResourceGroupID, headers, runtime);
}

async function deleteResourceGroupMachineGroupWithOptions(MachineGroupID: string, ResourceGroupID: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceGroupMachineGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceGroupMachineGroup',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/${OpenApiUtil.getEncodeParam(ResourceGroupID)}/machinegroups/${OpenApiUtil.getEncodeParam(MachineGroupID)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetAlgorithmResponseBody = {
  algorithmDescription?: string(name='AlgorithmDescription'),
  algorithmId?: string(name='AlgorithmId'),
  algorithmName?: string(name='AlgorithmName'),
  algorithmProvider?: string(name='AlgorithmProvider'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  requestId?: string(name='RequestId'),
  tenantId?: string(name='TenantId'),
  userId?: string(name='UserId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetAlgorithmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlgorithmResponseBody(name='body'),
}

async function getAlgorithm(AlgorithmId: string): GetAlgorithmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgorithmWithOptions(AlgorithmId, headers, runtime);
}

async function getAlgorithmWithOptions(AlgorithmId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgorithmResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAlgorithm',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithms/${OpenApiUtil.getEncodeParam(AlgorithmId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetAlgorithmVersionResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  algorithmName?: string(name='AlgorithmName'),
  algorithmProvider?: string(name='AlgorithmProvider'),
  algorithmSpec?: AlgorithmSpec(name='AlgorithmSpec'),
  algorithmVersion?: string(name='AlgorithmVersion'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  tenantId?: string(name='TenantId'),
  userId?: string(name='UserId'),
}

model GetAlgorithmVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlgorithmVersionResponseBody(name='body'),
}

async function getAlgorithmVersion(AlgorithmId: string, AlgorithmVersion: string): GetAlgorithmVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgorithmVersionWithOptions(AlgorithmId, AlgorithmVersion, headers, runtime);
}

async function getAlgorithmVersionWithOptions(AlgorithmId: string, AlgorithmVersion: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgorithmVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAlgorithmVersion',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithms/${OpenApiUtil.getEncodeParam(AlgorithmId)}/versions/${OpenApiUtil.getEncodeParam(AlgorithmVersion)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetMachineGroupResponseBody = {
  count?: long(name='Count'),
  duration?: string(name='Duration'),
  ecsType?: string(name='EcsType'),
  gmtCreated?: string(name='GmtCreated'),
  gmtExpired?: string(name='GmtExpired'),
  gmtModified?: string(name='GmtModified'),
  gmtStarted?: string(name='GmtStarted'),
  machineGroupID?: string(name='MachineGroupID'),
  orderID?: string(name='OrderID'),
  PAIResourceID?: string(name='PAIResourceID'),
  payType?: string(name='PayType'),
  pricingCycle?: string(name='PricingCycle'),
  regionID?: string(name='RegionID'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model GetMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMachineGroupResponseBody(name='body'),
}

async function getMachineGroup(MachineGroupID: string): GetMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMachineGroupWithOptions(MachineGroupID, headers, runtime);
}

async function getMachineGroupWithOptions(MachineGroupID: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetMachineGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetMachineGroup',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/machinegroups/${OpenApiUtil.getEncodeParam(MachineGroupID)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetNodeMetricsRequest {
  endTime?: string(name='EndTime'),
  GPUType?: string(name='GPUType'),
  startTime?: string(name='StartTime'),
  timeStep?: string(name='TimeStep'),
  verbose?: boolean(name='Verbose'),
}

model GetNodeMetricsResponseBody = {
  metricType?: string(name='MetricType'),
  nodesMetrics?: [
    NodeMetric
  ](name='NodesMetrics'),
  resourceGroupID?: string(name='ResourceGroupID'),
}

model GetNodeMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNodeMetricsResponseBody(name='body'),
}

async function getNodeMetrics(ResourceGroupID: string, MetricType: string, request: GetNodeMetricsRequest): GetNodeMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getNodeMetricsWithOptions(ResourceGroupID, MetricType, request, headers, runtime);
}

async function getNodeMetricsWithOptions(ResourceGroupID: string, MetricType: string, request: GetNodeMetricsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetNodeMetricsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.GPUType)) {
    query['GPUType'] = request.GPUType;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.timeStep)) {
    query['TimeStep'] = request.timeStep;
  }
  if (!Util.isUnset(request.verbose)) {
    query['Verbose'] = request.verbose;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeMetrics',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/${OpenApiUtil.getEncodeParam(ResourceGroupID)}/nodemetrics/${OpenApiUtil.getEncodeParam(MetricType)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetResourceGroupResponseBody = {
  creatorID?: string(name='CreatorID'),
  gmtCreatedTime?: string(name='GmtCreatedTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  userVpc?: UserVpc(name='UserVpc'),
  workspaceID?: string(name='WorkspaceID'),
}

model GetResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceGroupResponseBody(name='body'),
}

async function getResourceGroup(ResourceGroupID: string): GetResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getResourceGroupWithOptions(ResourceGroupID, headers, runtime);
}

async function getResourceGroupWithOptions(ResourceGroupID: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetResourceGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetResourceGroup',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/${OpenApiUtil.getEncodeParam(ResourceGroupID)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetResourceGroupMachineGroupResponseBody = {
  cpu?: string(name='Cpu'),
  ecsCount?: long(name='EcsCount'),
  ecsSpec?: string(name='EcsSpec'),
  gmtCreatedTime?: string(name='GmtCreatedTime'),
  gmtExpiredTime?: string(name='GmtExpiredTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  gmtStartedTime?: string(name='GmtStartedTime'),
  gpu?: string(name='Gpu'),
  gpuType?: string(name='GpuType'),
  machineGroupID?: string(name='MachineGroupID'),
  memory?: string(name='Memory'),
  paymentDuration?: string(name='PaymentDuration'),
  paymentDurationUnit?: string(name='PaymentDurationUnit'),
  paymentType?: string(name='PaymentType'),
  requestId?: string(name='RequestId'),
  resourceGroupID?: string(name='ResourceGroupID'),
  status?: string(name='Status'),
}

model GetResourceGroupMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceGroupMachineGroupResponseBody(name='body'),
}

async function getResourceGroupMachineGroup(MachineGroupID: string, ResourceGroupID: string): GetResourceGroupMachineGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getResourceGroupMachineGroupWithOptions(MachineGroupID, ResourceGroupID, headers, runtime);
}

async function getResourceGroupMachineGroupWithOptions(MachineGroupID: string, ResourceGroupID: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetResourceGroupMachineGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetResourceGroupMachineGroup',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/${OpenApiUtil.getEncodeParam(ResourceGroupID)}/machinegroups/${OpenApiUtil.getEncodeParam(MachineGroupID)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetResourceGroupRequestRequest {
  podStatus?: string(name='PodStatus'),
  resourceGroupID?: string(name='ResourceGroupID'),
}

model GetResourceGroupRequestResponseBody = {
  requestCPU?: int32(name='requestCPU'),
  requestGPU?: int32(name='requestGPU'),
  requestGPUInfos?: [
    GPUInfo
  ](name='requestGPUInfos'),
  requestMemory?: int32(name='requestMemory'),
}

model GetResourceGroupRequestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceGroupRequestResponseBody(name='body'),
}

async function getResourceGroupRequest(request: GetResourceGroupRequestRequest): GetResourceGroupRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getResourceGroupRequestWithOptions(request, headers, runtime);
}

async function getResourceGroupRequestWithOptions(request: GetResourceGroupRequestRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetResourceGroupRequestResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.podStatus)) {
    query['PodStatus'] = request.podStatus;
  }
  if (!Util.isUnset(request.resourceGroupID)) {
    query['ResourceGroupID'] = request.resourceGroupID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceGroupRequest',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/data/request`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetResourceGroupTotalRequest {
  resourceGroupID?: string(name='ResourceGroupID'),
}

model GetResourceGroupTotalResponseBody = {
  totalCPU?: int32(name='totalCPU'),
  totalGPU?: int32(name='totalGPU'),
  totalGPUInfos?: [
    GPUInfo
  ](name='totalGPUInfos'),
  totalMemory?: int32(name='totalMemory'),
}

model GetResourceGroupTotalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceGroupTotalResponseBody(name='body'),
}

async function getResourceGroupTotal(request: GetResourceGroupTotalRequest): GetResourceGroupTotalResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getResourceGroupTotalWithOptions(request, headers, runtime);
}

async function getResourceGroupTotalWithOptions(request: GetResourceGroupTotalRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetResourceGroupTotalResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.resourceGroupID)) {
    query['ResourceGroupID'] = request.resourceGroupID;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceGroupTotal',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/data/total`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTrainingJobResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  algorithmName?: string(name='AlgorithmName'),
  algorithmProvider?: string(name='AlgorithmProvider'),
  algorithmVersion?: string(name='AlgorithmVersion'),
  computeResource?: {
    ecsCount?: long(name='EcsCount'),
    ecsSpec?: string(name='EcsSpec'),
  }(name='ComputeResource'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  hyperParameters?: [ 
    {
      name?: string(name='Name'),
      value?: string(name='Value'),
    }
  ](name='HyperParameters'),
  inputChannels?: [ 
    {
      datasetId?: string(name='DatasetId'),
      inputUri?: string(name='InputUri'),
      name?: string(name='Name'),
    }
  ](name='InputChannels'),
  instances?: [ 
    {
      name?: string(name='Name'),
      role?: string(name='Role'),
      status?: string(name='Status'),
    }
  ](name='Instances'),
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
  latestMetrics?: [ 
    {
      name?: string(name='Name'),
      timestamp?: string(name='Timestamp'),
      value?: double(name='Value'),
    }
  ](name='LatestMetrics'),
  outputChannels?: [ 
    {
      datasetId?: string(name='DatasetId'),
      name?: string(name='Name'),
      outputUri?: string(name='OutputUri'),
    }
  ](name='OutputChannels'),
  reasonCode?: string(name='ReasonCode'),
  reasonMessage?: string(name='ReasonMessage'),
  requestId?: string(name='RequestId'),
  scheduler?: {
    maxRunningTimeInSeconds?: long(name='MaxRunningTimeInSeconds'),
  }(name='Scheduler'),
  status?: string(name='Status'),
  statusTransitions?: [ 
    {
      endTime?: string(name='EndTime'),
      reasonCode?: string(name='ReasonCode'),
      reasonMessage?: string(name='ReasonMessage'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
    }
  ](name='StatusTransitions'),
  trainingJobDescription?: string(name='TrainingJobDescription'),
  trainingJobId?: string(name='TrainingJobId'),
  trainingJobName?: string(name='TrainingJobName'),
  trainingJobUrl?: string(name='TrainingJobUrl'),
  userId?: string(name='UserId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetTrainingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTrainingJobResponseBody(name='body'),
}

async function getTrainingJob(TrainingJobId: string): GetTrainingJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTrainingJobWithOptions(TrainingJobId, headers, runtime);
}

async function getTrainingJobWithOptions(TrainingJobId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTrainingJobResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTrainingJob',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/trainingjobs/${OpenApiUtil.getEncodeParam(TrainingJobId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetUserViewMetricsRequest {
  order?: string(name='Order'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  sortBy?: string(name='SortBy'),
  timeStep?: string(name='TimeStep'),
  userId?: string(name='UserId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetUserViewMetricsResponseBody = {
  resourceGroupId?: string(name='ResourceGroupId'),
  summary?: UserViewMetric(name='Summary'),
  total?: int32(name='Total'),
  userMetrics?: [
    UserViewMetric
  ](name='UserMetrics'),
}

model GetUserViewMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserViewMetricsResponseBody(name='body'),
}

async function getUserViewMetrics(ResourceGroupID: string, request: GetUserViewMetricsRequest): GetUserViewMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUserViewMetricsWithOptions(ResourceGroupID, request, headers, runtime);
}

async function getUserViewMetricsWithOptions(ResourceGroupID: string, request: GetUserViewMetricsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetUserViewMetricsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.timeStep)) {
    query['TimeStep'] = request.timeStep;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserViewMetrics',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/${OpenApiUtil.getEncodeParam(ResourceGroupID)}/usermetrics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAlgorithmVersionsRequest {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
}

model ListAlgorithmVersionsResponseBody = {
  algorithmVersions?: [ 
    {
      algorithmId?: string(name='AlgorithmId'),
      algorithmName?: string(name='AlgorithmName'),
      algorithmProvider?: string(name='AlgorithmProvider'),
      algorithmVersion?: string(name='AlgorithmVersion'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      tenantId?: string(name='TenantId'),
      userId?: string(name='UserId'),
    }
  ](name='AlgorithmVersions'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListAlgorithmVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlgorithmVersionsResponseBody(name='body'),
}

async function listAlgorithmVersions(AlgorithmId: string, request: ListAlgorithmVersionsRequest): ListAlgorithmVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAlgorithmVersionsWithOptions(AlgorithmId, request, headers, runtime);
}

async function listAlgorithmVersionsWithOptions(AlgorithmId: string, request: ListAlgorithmVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAlgorithmVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlgorithmVersions',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithms/${OpenApiUtil.getEncodeParam(AlgorithmId)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAlgorithmsRequest {
  algorithmId?: string(name='AlgorithmId'),
  algorithmName?: string(name='AlgorithmName'),
  algorithmProvider?: string(name='AlgorithmProvider'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListAlgorithmsResponseBody = {
  algorithms?: [ 
    {
      algorithmDescription?: string(name='AlgorithmDescription'),
      algorithmId?: string(name='AlgorithmId'),
      algorithmName?: string(name='AlgorithmName'),
      algorithmProvider?: string(name='AlgorithmProvider'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      userId?: string(name='UserId'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='Algorithms'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListAlgorithmsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlgorithmsResponseBody(name='body'),
}

async function listAlgorithms(request: ListAlgorithmsRequest): ListAlgorithmsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAlgorithmsWithOptions(request, headers, runtime);
}

async function listAlgorithmsWithOptions(request: ListAlgorithmsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAlgorithmsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.algorithmId)) {
    query['AlgorithmId'] = request.algorithmId;
  }
  if (!Util.isUnset(request.algorithmName)) {
    query['AlgorithmName'] = request.algorithmName;
  }
  if (!Util.isUnset(request.algorithmProvider)) {
    query['AlgorithmProvider'] = request.algorithmProvider;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlgorithms',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithms`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListResourceGroupMachineGroupsRequest {
  creatorID?: string(name='CreatorID'),
  ecsSpec?: string(name='EcsSpec'),
  name?: string(name='Name'),
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  paymentDuration?: string(name='PaymentDuration'),
  paymentDurationUnit?: string(name='PaymentDurationUnit'),
  paymentType?: string(name='PaymentType'),
  sortBy?: string(name='SortBy'),
  status?: string(name='Status'),
}

model ListResourceGroupMachineGroupsResponseBody = {
  machineGroups?: [
    MachineGroup
  ](name='MachineGroups'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListResourceGroupMachineGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceGroupMachineGroupsResponseBody(name='body'),
}

async function listResourceGroupMachineGroups(ResourceGroupID: string, request: ListResourceGroupMachineGroupsRequest): ListResourceGroupMachineGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceGroupMachineGroupsWithOptions(ResourceGroupID, request, headers, runtime);
}

async function listResourceGroupMachineGroupsWithOptions(ResourceGroupID: string, request: ListResourceGroupMachineGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceGroupMachineGroupsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.creatorID)) {
    query['CreatorID'] = request.creatorID;
  }
  if (!Util.isUnset(request.ecsSpec)) {
    query['EcsSpec'] = request.ecsSpec;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.paymentDuration)) {
    query['PaymentDuration'] = request.paymentDuration;
  }
  if (!Util.isUnset(request.paymentDurationUnit)) {
    query['PaymentDurationUnit'] = request.paymentDurationUnit;
  }
  if (!Util.isUnset(request.paymentType)) {
    query['PaymentType'] = request.paymentType;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceGroupMachineGroups',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/${OpenApiUtil.getEncodeParam(ResourceGroupID)}/machinegroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListResourceGroupsRequest {
  name?: string(name='Name'),
  order?: string(name='Order'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  showAll?: boolean(name='ShowAll'),
  sortBy?: string(name='SortBy'),
  status?: string(name='Status'),
}

model ListResourceGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  resourceGroups?: [
    ResourceGroup
  ](name='ResourceGroups'),
  totalCount?: long(name='TotalCount'),
}

model ListResourceGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceGroupsResponseBody(name='body'),
}

async function listResourceGroups(request: ListResourceGroupsRequest): ListResourceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceGroupsWithOptions(request, headers, runtime);
}

async function listResourceGroupsWithOptions(request: ListResourceGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceGroupsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.showAll)) {
    query['ShowAll'] = request.showAll;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceGroups',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTrainingJobLogsRequest {
  endTime?: string(name='EndTime'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  startTime?: string(name='StartTime'),
  workerId?: string(name='WorkerId'),
}

model ListTrainingJobLogsResponseBody = {
  logs?: [ string ](name='Logs'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListTrainingJobLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTrainingJobLogsResponseBody(name='body'),
}

async function listTrainingJobLogs(TrainingJobId: string, request: ListTrainingJobLogsRequest): ListTrainingJobLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTrainingJobLogsWithOptions(TrainingJobId, request, headers, runtime);
}

async function listTrainingJobLogsWithOptions(TrainingJobId: string, request: ListTrainingJobLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTrainingJobLogsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.workerId)) {
    query['WorkerId'] = request.workerId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTrainingJobLogs',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/trainingjobs/${OpenApiUtil.getEncodeParam(TrainingJobId)}/logs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTrainingJobMetricsRequest {
  endTime?: string(name='EndTime'),
  name?: string(name='Name'),
  order?: string(name='Order'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  startTime?: string(name='StartTime'),
}

model ListTrainingJobMetricsResponseBody = {
  metrics?: [ 
    {
      name?: string(name='Name'),
      timestamp?: string(name='Timestamp'),
      value?: double(name='Value'),
    }
  ](name='Metrics'),
  requestId?: string(name='RequestId'),
}

model ListTrainingJobMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTrainingJobMetricsResponseBody(name='body'),
}

async function listTrainingJobMetrics(TrainingJobId: string, request: ListTrainingJobMetricsRequest): ListTrainingJobMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTrainingJobMetricsWithOptions(TrainingJobId, request, headers, runtime);
}

async function listTrainingJobMetricsWithOptions(TrainingJobId: string, request: ListTrainingJobMetricsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTrainingJobMetricsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTrainingJobMetrics',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/trainingjobs/${OpenApiUtil.getEncodeParam(TrainingJobId)}/metrics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTrainingJobsRequest {
  order?: string(name='Order'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  sortBy?: string(name='SortBy'),
  status?: string(name='Status'),
  trainingJobName?: string(name='TrainingJobName'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListTrainingJobsResponseBody = {
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  trainingJobs?: [ 
    {
      algorithmName?: string(name='AlgorithmName'),
      algorithmProvider?: string(name='AlgorithmProvider'),
      algorithmVersion?: string(name='AlgorithmVersion'),
      computeResource?: {
        ecsCount?: long(name='EcsCount'),
        ecsSpec?: string(name='EcsSpec'),
      }(name='ComputeResource'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      hyperParameters?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='HyperParameters'),
      inputChannels?: [ 
        {
          datasetId?: string(name='DatasetId'),
          inputUri?: string(name='InputUri'),
          name?: string(name='Name'),
        }
      ](name='InputChannels'),
      labels?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Labels'),
      outputChannels?: [ 
        {
          datasetId?: string(name='DatasetId'),
          name?: string(name='Name'),
          outputUri?: string(name='OutputUri'),
        }
      ](name='OutputChannels'),
      reasonCode?: string(name='ReasonCode'),
      reasonMessage?: string(name='ReasonMessage'),
      scheduler?: {
        maxRunningTimeInSeconds?: long(name='MaxRunningTimeInSeconds'),
      }(name='Scheduler'),
      status?: string(name='Status'),
      statusTransitions?: [ 
        {
          endTime?: string(name='EndTime'),
          reasonCode?: string(name='ReasonCode'),
          reasonMessage?: string(name='ReasonMessage'),
          startTime?: string(name='StartTime'),
          status?: string(name='Status'),
        }
      ](name='StatusTransitions'),
      trainingJobDescription?: string(name='TrainingJobDescription'),
      trainingJobId?: string(name='TrainingJobId'),
      trainingJobName?: string(name='TrainingJobName'),
      userId?: string(name='UserId'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='TrainingJobs'),
}

model ListTrainingJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTrainingJobsResponseBody(name='body'),
}

async function listTrainingJobs(request: ListTrainingJobsRequest): ListTrainingJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTrainingJobsWithOptions(request, headers, runtime);
}

async function listTrainingJobsWithOptions(request: ListTrainingJobsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTrainingJobsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.trainingJobName)) {
    query['TrainingJobName'] = request.trainingJobName;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTrainingJobs',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/trainingjobs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopTrainingJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopTrainingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopTrainingJobResponseBody(name='body'),
}

async function stopTrainingJob(TrainingJobId: string): StopTrainingJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopTrainingJobWithOptions(TrainingJobId, headers, runtime);
}

async function stopTrainingJobWithOptions(TrainingJobId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopTrainingJobResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopTrainingJob',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/trainingjobs/${OpenApiUtil.getEncodeParam(TrainingJobId)}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateAlgorithmRequest {
  algorithmDescription?: string(name='AlgorithmDescription'),
}

model UpdateAlgorithmResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  requestId?: string(name='RequestId'),
}

model UpdateAlgorithmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAlgorithmResponseBody(name='body'),
}

async function updateAlgorithm(AlgorithmId: string, request: UpdateAlgorithmRequest): UpdateAlgorithmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAlgorithmWithOptions(AlgorithmId, request, headers, runtime);
}

async function updateAlgorithmWithOptions(AlgorithmId: string, request: UpdateAlgorithmRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAlgorithmResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmDescription)) {
    body['AlgorithmDescription'] = request.algorithmDescription;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlgorithm',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithms/${OpenApiUtil.getEncodeParam(AlgorithmId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateAlgorithmVersionRequest {
  algorithmSpec?: AlgorithmSpec(name='AlgorithmSpec'),
}

model UpdateAlgorithmVersionShrinkRequest {
  algorithmSpecShrink?: string(name='AlgorithmSpec'),
}

model UpdateAlgorithmVersionResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  algorithmVersion?: string(name='AlgorithmVersion'),
}

model UpdateAlgorithmVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAlgorithmVersionResponseBody(name='body'),
}

async function updateAlgorithmVersion(AlgorithmId: string, AlgorithmVersion: string, request: UpdateAlgorithmVersionRequest): UpdateAlgorithmVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAlgorithmVersionWithOptions(AlgorithmId, AlgorithmVersion, request, headers, runtime);
}

async function updateAlgorithmVersionWithOptions(AlgorithmId: string, AlgorithmVersion: string, tmpReq: UpdateAlgorithmVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAlgorithmVersionResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateAlgorithmVersionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.algorithmSpec)) {
    request.algorithmSpecShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.algorithmSpec, 'AlgorithmSpec', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmSpecShrink)) {
    body['AlgorithmSpec'] = request.algorithmSpecShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlgorithmVersion',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithms/${OpenApiUtil.getEncodeParam(AlgorithmId)}/versions/${OpenApiUtil.getEncodeParam(AlgorithmVersion)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateResourceGroupRequest {
  unbind?: boolean(name='Unbind'),
  userVpc?: UserVpc(name='UserVpc'),
}

model UpdateResourceGroupResponseBody = {
  resourceGroupID?: string(name='ResourceGroupID'),
  requestId?: string(name='requestId'),
}

model UpdateResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateResourceGroupResponseBody(name='body'),
}

async function updateResourceGroup(ResourceGroupID: string, request: UpdateResourceGroupRequest): UpdateResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateResourceGroupWithOptions(ResourceGroupID, request, headers, runtime);
}

async function updateResourceGroupWithOptions(ResourceGroupID: string, request: UpdateResourceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateResourceGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.unbind)) {
    body['Unbind'] = request.unbind;
  }
  if (!Util.isUnset(request.userVpc)) {
    body['UserVpc'] = request.userVpc;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResourceGroup',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources/${OpenApiUtil.getEncodeParam(ResourceGroupID)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateTrainingJobLabelsRequest {
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
}

model UpdateTrainingJobLabelsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTrainingJobLabelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTrainingJobLabelsResponseBody(name='body'),
}

async function updateTrainingJobLabels(TrainingJobId: string, request: UpdateTrainingJobLabelsRequest): UpdateTrainingJobLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTrainingJobLabelsWithOptions(TrainingJobId, request, headers, runtime);
}

async function updateTrainingJobLabelsWithOptions(TrainingJobId: string, request: UpdateTrainingJobLabelsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTrainingJobLabelsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTrainingJobLabels',
    version = '2022-01-12',
    protocol = 'HTTPS',
    pathname = `/api/v1/trainingjobs/${OpenApiUtil.getEncodeParam(TrainingJobId)}/labels`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

