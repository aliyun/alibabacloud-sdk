/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'PaiStudio';
  @version = '2022-01-12';
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'pai.cn-beijing.aliyuncs.com',
    cn-hangzhou = 'pai.cn-hangzhou.aliyuncs.com',
    cn-shanghai = 'pai.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'pai.cn-shenzhen.aliyuncs.com',
    cn-hongkong = 'pai.cn-hongkong.aliyuncs.com',
    ap-southeast-1 = 'pai.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'pai.ap-southeast-2.aliyuncs.com',
    ap-southeast-3 = 'pai.ap-southeast-3.aliyuncs.com',
    ap-southeast-5 = 'pai.ap-southeast-5.aliyuncs.com',
    us-west-1 = 'pai.us-west-1.aliyuncs.com',
    us-east-1 = 'pai.us-east-1.aliyuncs.com',
    eu-central-1 = 'pai.eu-central-1.aliyuncs.com',
    me-east-1 = 'pai.me-east-1.aliyuncs.com',
    ap-south-1 = 'pai.ap-south-1.aliyuncs.com',
    cn-qingdao = 'pai.cn-qingdao.aliyuncs.com',
    cn-zhangjiakou = 'pai.cn-zhangjiakou.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model ACS {
  ACSQuotaId?: string(name='ACSQuotaId'),
  associatedProducts?: [ string ](name='AssociatedProducts'),
}

model AlgorithmSpec {
  codeDir?: Location(name='CodeDir'),
  command: [ string ](name='Command'),
  computeResource?: {
    policy: {
      value: string(name='Value'),
      version: string(name='Version'),
    }(name='Policy'),
  }(name='ComputeResource'),
  customization?: {
    codeDir?: boolean(name='CodeDir'),
  }(name='Customization'),
  hyperParameters?: [
    HyperParameterDefinition
  ](name='HyperParameters'),
  image: string(name='Image'),
  inputChannels?: [
    Channel
  ](name='InputChannels'),
  jobType: string(name='JobType'),
  metricDefinitions?: [
    MetricDefinition
  ](name='MetricDefinitions'),
  outputChannels?: [
    Channel
  ](name='OutputChannels'),
  progressDefinitions?: {
    overallProgress?: {
      description?: string(name='Description'),
      regex?: string(name='Regex'),
    }(name='OverallProgress'),
    remainingTime?: {
      description?: string(name='Description'),
      regex?: string(name='Regex'),
    }(name='RemainingTime'),
  }(name='ProgressDefinitions'),
  resourceRequirements?: [
    ConditionExpression
  ](name='ResourceRequirements'),
  supportedInstanceTypes?: [ string ](name='SupportedInstanceTypes', deprecated='true'),
  supportsDistributedTraining?: boolean(name='SupportsDistributedTraining'),
}

model AllocateStrategySpec {
  nodeSpecs?: [
    NodeSpec
  ](name='NodeSpecs'),
}

model Channel {
  description?: string(name='Description'),
  name: string(name='Name'),
  properties?: map[string]any(name='Properties'),
  required?: boolean(name='Required'),
  supportedChannelTypes?: [ string ](name='SupportedChannelTypes'),
}

model ChannelProperty {
  name: string(name='Name', example='SKlearn'),
  value: string(name='Value', example='Framework'),
}

model ComponentSpec {
  codeDir?: Location(name='CodeDir'),
  command: string(name='Command'),
  hyperParameters?: [
    HyperParameterDefinition
  ](name='HyperParameters'),
  image: string(name='Image'),
  inputChannels?: [
    Channel
  ](name='InputChannels'),
  jobType: string(name='JobType'),
  metricDefinitions?: [
    MetricDefinition
  ](name='MetricDefinitions'),
  outputChannels?: [
    Channel
  ](name='OutputChannels'),
  resourceRequirements?: [
    ConditionExpression
  ](name='ResourceRequirements'),
}

model ConditionExpression {
  key: string(name='Key', example='SupportedMachineTypes'),
  operator: string(name='Operator', example='in'),
  values: [ string ](name='Values'),
}

model Features {
  quota?: {
    isEnabled?: boolean(name='IsEnabled', example='true'),
  }(name='Quota'),
}

model GPUInfo {
  count?: long(name='count'),
  type?: string(name='type'),
}

model HyperParameterDefinition {
  defaultValue?: string(name='DefaultValue'),
  description?: string(name='Description'),
  displayName?: string(name='DisplayName'),
  name: string(name='Name'),
  range?: HyperParameterRange(name='Range'),
  required?: boolean(name='Required'),
  type: string(name='Type'),
}

model HyperParameterRange {
  enum?: [ string ](name='Enum'),
  exclusiveMaximum?: boolean(name='ExclusiveMaximum'),
  exclusiveMinimum?: boolean(name='ExclusiveMinimum'),
  maxLength?: long(name='MaxLength'),
  maximum?: string(name='Maximum'),
  minLength?: long(name='MinLength'),
  minimum?: string(name='Minimum'),
  pattern?: string(name='Pattern'),
}

model JobViewMetric {
  CPUUsageRate?: string(name='CPUUsageRate'),
  diskReadRate?: string(name='DiskReadRate'),
  diskWriteRate?: string(name='DiskWriteRate'),
  GPUUsageRate?: string(name='GPUUsageRate'),
  jobId?: string(name='JobId'),
  jobType?: string(name='JobType'),
  memoryUsageRate?: string(name='MemoryUsageRate'),
  networkInputRate?: string(name='NetworkInputRate'),
  networkOutputRate?: string(name='NetworkOutputRate'),
  nodeNames?: [ string ](name='NodeNames'),
  requestCPU?: int32(name='RequestCPU'),
  requestGPU?: int32(name='RequestGPU'),
  requestMemory?: long(name='RequestMemory'),
  resourceGroupID?: string(name='ResourceGroupID', example='rg17tmvwiokhzaxg'),
  totalCPU?: int32(name='TotalCPU'),
  totalGPU?: int32(name='TotalGPU'),
  totalMemory?: long(name='TotalMemory'),
  userId?: string(name='UserId'),
}

model Label {
  key?: string(name='Key'),
  value?: string(name='Value'),
}

model Location {
  locationType?: string(name='LocationType'),
  locationValue?: map[string]any(name='LocationValue'),
}

model MachineGroup {
  creatorID?: string(name='CreatorID'),
  defaultDriver?: string(name='DefaultDriver', example='470.199.02'),
  ecsCount?: long(name='EcsCount'),
  ecsSpec?: string(name='EcsSpec'),
  gmtCreatedTime?: string(name='GmtCreatedTime'),
  gmtExpiredTime?: string(name='GmtExpiredTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  gmtStartedTime?: string(name='GmtStartedTime'),
  machineGroupID?: string(name='MachineGroupID', example='mg1'),
  paymentDuration?: string(name='PaymentDuration'),
  paymentDurationUnit?: string(name='PaymentDurationUnit'),
  paymentType?: string(name='PaymentType'),
  reasonCode?: string(name='ReasonCode'),
  reasonMessage?: string(name='ReasonMessage'),
  resourceGroupID?: string(name='ResourceGroupID'),
  status?: string(name='Status'),
  supportedDrivers?: [ string ](name='SupportedDrivers'),
}

model Metric {
  time?: long(name='Time', example='rg17tmvwiokhzaxg'),
  value?: string(name='Value', example='23000'),
}

model MetricDefinition {
  description?: string(name='Description', example='train dataset oob score'),
  name: string(name='Name', example='train:oob_score'),
  regex: string(name='Regex', example='.*train:oob_score=([-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?).*'),
}

model Node {
  acceleratorType?: string(name='AcceleratorType'),
  boundQuotas?: [
    QuotaIdName
  ](name='BoundQuotas'),
  CPU?: string(name='CPU'),
  creatorId?: string(name='CreatorId'),
  GPU?: string(name='GPU'),
  GPUType?: string(name='GPUType'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtExpiredTime?: string(name='GmtExpiredTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  isBound?: boolean(name='IsBound'),
  machineGroupId?: string(name='MachineGroupId'),
  memory?: string(name='Memory'),
  nodeName?: string(name='NodeName'),
  nodeStatus?: string(name='NodeStatus'),
  nodeType?: string(name='NodeType'),
  orderStatus?: string(name='OrderStatus'),
  reasonCode?: string(name='ReasonCode'),
  reasonMessage?: string(name='ReasonMessage'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceGroupName?: string(name='ResourceGroupName'),
}

model NodeMetric {
  GPUType?: string(name='GPUType'),
  metrics?: [
    Metric
  ](name='Metrics', example='23000'),
  nodeID?: string(name='NodeID', example='-i121212node'),
}

model NodeSpec {
  count?: long(name='Count', example='10'),
  type?: string(name='Type', example='ecs.g6.4xlarge'),
}

model NodeType {
  acceleratorType?: string(name='AcceleratorType', example='CPU'),
  CPU?: string(name='CPU', example='16'),
  GPU?: string(name='GPU', example='0'),
  GPUType?: string(name='GPUType'),
  memory?: string(name='Memory', example='64Gi'),
  nodeType?: string(name='NodeType', example='ecs.g6.4xlarge'),
}

model NodeTypeStatistic {
  canBeBoundCount?: int32(name='CanBeBoundCount', example='4'),
  nodeType?: string(name='NodeType', example='ecs.g6.4xlarge'),
  totalCount?: int32(name='TotalCount', example='10'),
}

model NodeViewMetric {
  CPUUsageRate?: string(name='CPUUsageRate'),
  createdTime?: string(name='CreatedTime'),
  diskReadRate?: string(name='DiskReadRate'),
  diskWriteRate?: string(name='DiskWriteRate'),
  GPUType?: string(name='GPUType'),
  machineGroupID?: string(name='MachineGroupID'),
  memoryUsageRate?: string(name='MemoryUsageRate'),
  networkInputRate?: string(name='NetworkInputRate'),
  networkOutputRate?: string(name='NetworkOutputRate'),
  nodeID?: string(name='NodeID', example='-i121212node'),
  nodeStatus?: string(name='NodeStatus'),
  nodeType?: string(name='NodeType'),
  requestCPU?: long(name='RequestCPU'),
  requestGPU?: long(name='RequestGPU'),
  requestMemory?: long(name='RequestMemory'),
  taskIdMap?: map[string]any(name='TaskIdMap'),
  totalCPU?: long(name='TotalCPU'),
  totalGPU?: long(name='TotalGPU'),
  totalMemory?: long(name='TotalMemory'),
  totalTasks?: long(name='TotalTasks'),
  userIDs?: [ string ](name='UserIDs'),
  userNumber?: string(name='UserNumber'),
}

model Permission {
  isEnabled?: boolean(name='IsEnabled'),
  resourceType?: string(name='ResourceType'),
}

model QueueInfo {
  gmtEnqueuedTime?: string(name='GmtEnqueuedTime', example='“2023-06-22T00:00:00Z”'),
  gmtPositionModifiedTime?: string(name='GmtPositionModifiedTime', example='"2023-06-22T00:00:00Z"'),
  position?: long(name='Position', example='10'),
  priority?: long(name='Priority', example='2'),
  queueStrategy?: string(name='QueueStrategy', example='PaiStrategyIntelligent'),
  quotaId?: string(name='QuotaId', example='“quotamtl37ge7gkvdz”'),
  workloadId?: string(name='WorkloadId', example='dlcxxxx'),
  workloadType?: string(name='WorkloadType', example='dlc'),
  workspaceId?: string(name='WorkspaceId', example='“432524”'),
}

model Quota {
  allocateStrategy?: string(name='AllocateStrategy'),
  creatorId?: string(name='CreatorId'),
  description?: string(name='Description'),
  gmtCreatedTime?: string(name='GmtCreatedTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  labels?: [
    Label
  ](name='Labels'),
  latestOperationId?: string(name='LatestOperationId'),
  min?: ResourceSpec(name='Min'),
  parentQuotaId?: string(name='ParentQuotaId'),
  queueStrategy?: string(name='QueueStrategy'),
  quotaConfig?: QuotaConfig(name='QuotaConfig'),
  quotaDetails?: QuotaDetails(name='QuotaDetails'),
  quotaId?: string(name='QuotaId', example='quota12345'),
  quotaName?: string(name='QuotaName', example='dlc-quota'),
  reasonCode?: string(name='ReasonCode'),
  reasonMessage?: string(name='ReasonMessage'),
  resourceGroupIds?: [ string ](name='ResourceGroupIds'),
  resourceType?: string(name='ResourceType'),
  status?: string(name='Status'),
  subQuotas?: [
    QuotaIdName
  ](name='SubQuotas'),
  workspaces?: [
    WorkspaceIdName
  ](name='Workspaces'),
}

model QuotaConfig {
  ACS?: ACS(name='ACS'),
  clusterId?: string(name='ClusterId', example='ceeb37xxxx'),
  defaultGPUDriver?: string(name='DefaultGPUDriver', example='470.199.02'),
  supportGPUDrivers?: [ string ](name='SupportGPUDrivers'),
  supportRDMA?: boolean(name='SupportRDMA', example='false'),
  userVpc?: UserVpc(name='UserVpc'),
}

model QuotaDetails {
  actualMinQuota?: ResourceAmount(name='ActualMinQuota'),
  desiredMinQuota?: ResourceAmount(name='DesiredMinQuota'),
  requestedQuota?: ResourceAmount(name='RequestedQuota'),
  usedQuota?: ResourceAmount(name='UsedQuota'),
}

model QuotaIdName {
  quotaId?: string(name='QuotaId', example='quota12345'),
  quotaName?: string(name='QuotaName', example='dlc-quota'),
}

model QuotaJobViewMetric {
  CPUUsageRate?: string(name='CPUUsageRate'),
  diskReadRate?: string(name='DiskReadRate'),
  diskWriteRate?: string(name='DiskWriteRate'),
  GPUUsageRate?: string(name='GPUUsageRate'),
  jobId?: string(name='JobId'),
  jobType?: string(name='JobType'),
  memoryUsageRate?: string(name='MemoryUsageRate'),
  networkInputRate?: string(name='NetworkInputRate'),
  networkOutputRate?: string(name='NetworkOutputRate'),
  nodeNames?: [ string ](name='NodeNames'),
  requestCPU?: int32(name='RequestCPU'),
  requestGPU?: int32(name='RequestGPU'),
  requestMemory?: long(name='RequestMemory'),
  totalCPU?: int32(name='TotalCPU'),
  totalGPU?: int32(name='TotalGPU'),
  totalMemory?: long(name='TotalMemory'),
  userId?: string(name='UserId'),
}

model QuotaMetric {
  GPUType?: string(name='GPUType'),
  metrics?: [
    Metric
  ](name='Metrics', example='23000'),
}

model QuotaNodeViewMetric {
  CPUUsageRate?: string(name='CPUUsageRate'),
  createdTime?: string(name='CreatedTime'),
  diskReadRate?: string(name='DiskReadRate'),
  diskWriteRate?: string(name='DiskWriteRate'),
  GPUType?: string(name='GPUType'),
  memoryUsageRate?: string(name='MemoryUsageRate'),
  networkInputRate?: string(name='NetworkInputRate'),
  networkOutputRate?: string(name='NetworkOutputRate'),
  nodeID?: string(name='NodeID', example='-i121212node'),
  nodeStatus?: string(name='NodeStatus'),
  nodeType?: string(name='NodeType'),
  quotaId?: string(name='QuotaId'),
  requestCPU?: long(name='RequestCPU'),
  requestGPU?: long(name='RequestGPU'),
  requestMemory?: long(name='RequestMemory'),
  taskIdMap?: map[string]any(name='TaskIdMap'),
  totalCPU?: long(name='TotalCPU'),
  totalGPU?: long(name='TotalGPU'),
  totalMemory?: long(name='TotalMemory'),
  totalTasks?: long(name='TotalTasks'),
  userIDs?: [ string ](name='UserIDs'),
  userNumber?: string(name='UserNumber'),
}

model QuotaUserViewMetric {
  CPUNodeNumber?: int32(name='CPUNodeNumber'),
  CPUUsageRate?: string(name='CPUUsageRate'),
  cpuJobNames?: [ string ](name='CpuJobNames'),
  cpuNodeNames?: [ string ](name='CpuNodeNames'),
  diskReadRate?: string(name='DiskReadRate'),
  diskWriteRate?: string(name='DiskWriteRate'),
  GPUNodeNumber?: int32(name='GPUNodeNumber'),
  GPUUsageRate?: string(name='GPUUsageRate'),
  gpuJobNames?: [ string ](name='GpuJobNames'),
  gpuNodeNames?: [ string ](name='GpuNodeNames'),
  jobType?: string(name='JobType'),
  memoryUsageRate?: string(name='MemoryUsageRate'),
  networkInputRate?: string(name='NetworkInputRate'),
  networkOutputRate?: string(name='NetworkOutputRate'),
  nodeNames?: [ string ](name='NodeNames'),
  requestCPU?: int32(name='RequestCPU'),
  requestGPU?: int32(name='RequestGPU'),
  requestMemory?: long(name='RequestMemory'),
  totalCPU?: int32(name='TotalCPU'),
  totalGPU?: int32(name='TotalGPU'),
  totalMemory?: long(name='TotalMemory'),
  userId?: string(name='UserId'),
}

model ResourceAmount {
  CPU?: string(name='CPU', example='100'),
  GPU?: string(name='GPU', example='16'),
  GPUType?: string(name='GPUType', example='GPU'),
  memory?: string(name='Memory', example='100Gi'),
}

model ResourceGroup {
  creatorID?: string(name='CreatorID'),
  gmtCreatedTime?: string(name='GmtCreatedTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  name?: string(name='Name', example='RG1'),
  nodeCount?: int32(name='NodeCount'),
  resourceGroupID?: string(name='ResourceGroupID', example='rg17tmvwiokhzaxg'),
  userVpc?: UserVpc(name='UserVpc'),
  workspaceID?: string(name='WorkspaceID', example='23000'),
}

model ResourceGroupMetric {
  gpuType?: string(name='GpuType'),
  metrics?: [
    Metric
  ](name='Metrics', example='23000'),
  resourceGroupID?: string(name='ResourceGroupID', example='rg17tmvwiokhzaxg'),
}

model ResourceOperation {
  creatorId?: string(name='CreatorId'),
  gmtCreatedTime?: string(name='GmtCreatedTime'),
  gmtEndTime?: string(name='GmtEndTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  gmtStartTime?: string(name='GmtStartTime'),
  objectId?: string(name='ObjectId'),
  objectType?: string(name='ObjectType'),
  operationDescription?: string(name='OperationDescription'),
  operationId?: string(name='OperationId'),
  operationSpecJson?: string(name='OperationSpecJson'),
  operationType?: string(name='OperationType'),
  reasonCode?: string(name='ReasonCode'),
  reasonMessage?: string(name='ReasonMessage'),
  status?: string(name='Status'),
}

model ResourceSpec {
  nodeSpecs?: [
    NodeSpec
  ](name='NodeSpecs'),
}

model UserViewMetric {
  CPUNodeNumber?: int32(name='CPUNodeNumber'),
  CPUUsageRate?: string(name='CPUUsageRate'),
  cpuJobNames?: [ string ](name='CpuJobNames'),
  cpuNodeNames?: [ string ](name='CpuNodeNames'),
  diskReadRate?: string(name='DiskReadRate'),
  diskWriteRate?: string(name='DiskWriteRate'),
  GPUNodeNumber?: int32(name='GPUNodeNumber'),
  GPUUsageRate?: string(name='GPUUsageRate'),
  gpuJobNames?: [ string ](name='GpuJobNames'),
  gpuNodeNames?: [ string ](name='GpuNodeNames'),
  jobType?: string(name='JobType'),
  memoryUsageRate?: string(name='MemoryUsageRate'),
  networkInputRate?: string(name='NetworkInputRate'),
  networkOutputRate?: string(name='NetworkOutputRate'),
  nodeNames?: [ string ](name='NodeNames'),
  requestCPU?: int32(name='RequestCPU'),
  requestGPU?: int32(name='RequestGPU'),
  requestMemory?: long(name='RequestMemory'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg17tmvwiokhzaxg'),
  totalCPU?: int32(name='TotalCPU'),
  totalGPU?: int32(name='TotalGPU'),
  totalMemory?: long(name='TotalMemory'),
  userId?: string(name='UserId'),
}

model UserVpc {
  defaultRoute?: string(name='DefaultRoute'),
  extendedCIDRs?: [ string ](name='ExtendedCIDRs'),
  roleArn?: string(name='RoleArn'),
  securityGroupId?: string(name='SecurityGroupId'),
  switchId?: string(name='SwitchId'),
  vpcId?: string(name='VpcId'),
}

model WorkspaceIdName {
  workspaceId?: string(name='WorkspaceId', example='ws123456'),
}

model CreateAlgorithmRequest {
  algorithmDescription?: string(name='AlgorithmDescription', position='Body'),
  algorithmName?: string(name='AlgorithmName', position='Body'),
  displayName?: string(name='DisplayName', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model CreateAlgorithmResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  requestId?: string(name='RequestId'),
}

model CreateAlgorithmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAlgorithmResponseBody(name='body'),
}

async function createAlgorithm(request: CreateAlgorithmRequest): CreateAlgorithmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateAlgorithm', 'POST', '/api/v1/algorithms', 'json', true, 'form', request);
}

model CreateAlgorithmVersionRequest {
  algorithmId?: string(name='AlgorithmId', position='Path'),
  algorithmVersion?: string(name='AlgorithmVersion', position='Path'),
  algorithmSpec?: AlgorithmSpec(name='AlgorithmSpec', shrink='json', position='Body'),
}

model CreateAlgorithmVersionResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  algorithmVersion?: string(name='AlgorithmVersion'),
}

model CreateAlgorithmVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAlgorithmVersionResponseBody(name='body'),
}

async function createAlgorithmVersion(request: CreateAlgorithmVersionRequest): CreateAlgorithmVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateAlgorithmVersion', 'POST', '/api/v1/algorithms/{AlgorithmId}/versions/{AlgorithmVersion}', 'json', true, 'form', request);
}

model CreateQuotaRequest {
  allocateStrategy?: string(name='AllocateStrategy', example='ByNodeSpecs', position='Body'),
  description?: string(name='Description', example='this is a test quota', position='Body'),
  labels?: [
    Label
  ](name='Labels', position='Body'),
  min?: ResourceSpec(name='Min', position='Body'),
  parentQuotaId?: string(name='ParentQuotaId', example='quota1ci8g793pgm', position='Body'),
  queueStrategy?: string(name='QueueStrategy', example='PaiStrategyIntelligent', position='Body'),
  quotaConfig?: QuotaConfig(name='QuotaConfig', position='Body'),
  quotaName?: string(name='QuotaName', example='test-quota', position='Body'),
  resourceGroupIds?: [ string ](name='ResourceGroupIds', position='Body'),
  resourceType?: string(name='ResourceType', example='ECS', position='Body'),
}

model CreateQuotaResponseBody = {
  quotaId?: string(name='QuotaId', description='Quota Id', example='quotad2kd8ljpsno'),
  requestId?: string(name='RequestId', example='CBF05F13-B24C-5129-9048-4FA684DCD579'),
}

model CreateQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateQuotaResponseBody(name='body'),
}

async function createQuota(request: CreateQuotaRequest): CreateQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateQuota', 'POST', '/api/v1/quotas', 'json', false, 'json', request);
}

model CreateResourceGroupRequest {
  computingResourceProvider?: string(name='ComputingResourceProvider', position='Body'),
  description?: string(name='Description', position='Body'),
  name?: string(name='Name', position='Body'),
  resourceType?: string(name='ResourceType', position='Body'),
  userVpc?: UserVpc(name='UserVpc', position='Body'),
}

model CreateResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
  resourceGroupID?: string(name='ResourceGroupID'),
}

model CreateResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResourceGroupResponseBody(name='body'),
}

async function createResourceGroup(request: CreateResourceGroupRequest): CreateResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateResourceGroup', 'POST', '/api/v1/resources', 'json', false, 'json', request);
}

model CreateTrainingJobRequest {
  algorithmName?: string(name='AlgorithmName', position='Body'),
  algorithmProvider?: string(name='AlgorithmProvider', position='Body'),
  algorithmSpec?: AlgorithmSpec(name='AlgorithmSpec', position='Body'),
  algorithmVersion?: string(name='AlgorithmVersion', position='Body'),
  codeDir?: Location(name='CodeDir', position='Body'),
  computeResource?: {
    ecsCount?: long(name='EcsCount'),
    ecsSpec?: string(name='EcsSpec'),
    instanceCount?: long(name='InstanceCount'),
    instanceSpec?: {
      CPU?: string(name='CPU'),
      GPU?: string(name='GPU'),
      GPUType?: string(name='GPUType'),
      memory?: string(name='Memory'),
      sharedMemory?: string(name='SharedMemory'),
    }(name='InstanceSpec'),
    resourceId?: string(name='ResourceId'),
  }(name='ComputeResource', position='Body'),
  hyperParameters?: [ 
    {
      name?: string(name='Name'),
      value?: string(name='Value'),
    }
  ](name='HyperParameters', position='Body'),
  inputChannels?: [ 
    {
      datasetId?: string(name='DatasetId'),
      inputUri?: string(name='InputUri'),
      name?: string(name='Name'),
    }
  ](name='InputChannels', position='Body'),
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels', position='Body'),
  outputChannels?: [ 
    {
      datasetId?: string(name='DatasetId'),
      name?: string(name='Name'),
      outputUri?: string(name='OutputUri'),
    }
  ](name='OutputChannels', position='Body'),
  roleArn?: string(name='RoleArn', position='Body'),
  scheduler?: {
    maxRunningTimeInSeconds?: long(name='MaxRunningTimeInSeconds'),
  }(name='Scheduler', position='Body'),
  trainingJobDescription?: string(name='TrainingJobDescription', position='Body'),
  trainingJobName: string(name='TrainingJobName', position='Body'),
  userVpc?: {
    defaultRoute?: string(name='DefaultRoute'),
    extendedCIDRs?: [ string ](name='ExtendedCIDRs'),
    securityGroupId?: string(name='SecurityGroupId'),
    switchId?: string(name='SwitchId'),
    vpcId?: string(name='VpcId'),
  }(name='UserVpc', position='Body'),
  workspaceId: string(name='WorkspaceId', position='Body'),
}

model CreateTrainingJobResponseBody = {
  requestId?: string(name='RequestId'),
  trainingJobId?: string(name='TrainingJobId'),
}

model CreateTrainingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTrainingJobResponseBody(name='body'),
}

async function createTrainingJob(request: CreateTrainingJobRequest): CreateTrainingJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateTrainingJob', 'POST', '/api/v1/trainingjobs', 'json', false, 'json', request);
}

model DeleteMachineGroupRequest {
  machineGroupID?: string(name='MachineGroupID', position='Path'),
}

model DeleteMachineGroupResponseBody = {
  machineGroupID?: string(name='MachineGroupID'),
  requestId?: string(name='RequestId'),
}

model DeleteMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMachineGroupResponseBody(name='body'),
}

async function deleteMachineGroup(request: DeleteMachineGroupRequest): DeleteMachineGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteMachineGroup', 'DELETE', '/api/v1/resources/machinegroups/{MachineGroupID}', 'json', false, 'json', request);
}

model DeleteQuotaRequest {
  quotaId?: string(name='QuotaId', example='quota1ci8g793pgm', position='Path'),
}

model DeleteQuotaResponseBody = {
  quotaId?: string(name='QuotaId', description='Quota Id', example='quotamtl37ge7gkvdz'),
  requestId?: string(name='RequestId', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model DeleteQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteQuotaResponseBody(name='body'),
}

async function deleteQuota(request: DeleteQuotaRequest): DeleteQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteQuota', 'DELETE', '/api/v1/quotas/{QuotaId}', 'json', false, 'json', request);
}

model DeleteResourceGroupRequest {
  resourceGroupID?: string(name='ResourceGroupID', position='Path'),
}

model DeleteResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
  resourceGroupID?: string(name='ResourceGroupID'),
}

model DeleteResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceGroupResponseBody(name='body'),
}

async function deleteResourceGroup(request: DeleteResourceGroupRequest): DeleteResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteResourceGroup', 'DELETE', '/api/v1/resources/{ResourceGroupID}', 'json', false, 'json', request);
}

model DeleteResourceGroupMachineGroupRequest {
  machineGroupID?: string(name='MachineGroupID', position='Path'),
  resourceGroupID?: string(name='ResourceGroupID', position='Path'),
}

model DeleteResourceGroupMachineGroupResponseBody = {
  machineGroupID?: string(name='MachineGroupID'),
  requestId?: string(name='RequestId'),
}

model DeleteResourceGroupMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceGroupMachineGroupResponseBody(name='body'),
}

async function deleteResourceGroupMachineGroup(request: DeleteResourceGroupMachineGroupRequest): DeleteResourceGroupMachineGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteResourceGroupMachineGroup', 'DELETE', '/api/v1/resources/{ResourceGroupID}/machinegroups/{MachineGroupID}', 'json', false, 'json', request);
}

model GetAlgorithmRequest {
  algorithmId?: string(name='AlgorithmId', position='Path'),
}

model GetAlgorithmResponseBody = {
  algorithmDescription?: string(name='AlgorithmDescription'),
  algorithmId?: string(name='AlgorithmId'),
  algorithmName?: string(name='AlgorithmName'),
  algorithmProvider?: string(name='AlgorithmProvider'),
  displayName?: string(name='DisplayName'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  requestId?: string(name='RequestId'),
  tenantId?: string(name='TenantId'),
  userId?: string(name='UserId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetAlgorithmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlgorithmResponseBody(name='body'),
}

async function getAlgorithm(request: GetAlgorithmRequest): GetAlgorithmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetAlgorithm', 'GET', '/api/v1/algorithms/{AlgorithmId}', 'json', false, 'json', request);
}

model GetAlgorithmVersionRequest {
  algorithmId?: string(name='AlgorithmId', position='Path'),
  algorithmVersion?: string(name='AlgorithmVersion', position='Path'),
}

model GetAlgorithmVersionResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  algorithmName?: string(name='AlgorithmName'),
  algorithmProvider?: string(name='AlgorithmProvider'),
  algorithmSpec?: AlgorithmSpec(name='AlgorithmSpec'),
  algorithmVersion?: string(name='AlgorithmVersion'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  tenantId?: string(name='TenantId'),
  userId?: string(name='UserId'),
}

model GetAlgorithmVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlgorithmVersionResponseBody(name='body'),
}

async function getAlgorithmVersion(request: GetAlgorithmVersionRequest): GetAlgorithmVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetAlgorithmVersion', 'GET', '/api/v1/algorithms/{AlgorithmId}/versions/{AlgorithmVersion}', 'json', false, 'json', request);
}

model GetMachineGroupRequest {
  machineGroupID: string(name='MachineGroupID', position='Path'),
}

model GetMachineGroupResponseBody = {
  count?: long(name='Count'),
  defaultDriver?: string(name='DefaultDriver'),
  duration?: string(name='Duration'),
  ecsType?: string(name='EcsType'),
  gmtCreated?: string(name='GmtCreated'),
  gmtExpired?: string(name='GmtExpired'),
  gmtModified?: string(name='GmtModified'),
  gmtStarted?: string(name='GmtStarted'),
  machineGroupID?: string(name='MachineGroupID'),
  orderID?: string(name='OrderID'),
  PAIResourceID?: string(name='PAIResourceID'),
  payType?: string(name='PayType'),
  pricingCycle?: string(name='PricingCycle'),
  regionID?: string(name='RegionID'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  supportedDrivers?: [ string ](name='SupportedDrivers'),
}

model GetMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMachineGroupResponseBody(name='body'),
}

async function getMachineGroup(request: GetMachineGroupRequest): GetMachineGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetMachineGroup', 'GET', '/api/v1/resources/machinegroups/{MachineGroupID}', 'json', false, 'json', request);
}

model GetNodeMetricsRequest {
  resourceGroupID: string(name='ResourceGroupID', position='Path'),
  metricType: string(name='MetricType', position='Path'),
  endTime?: string(name='EndTime', position='Query'),
  GPUType?: string(name='GPUType', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  timeStep?: string(name='TimeStep', position='Query'),
  verbose?: boolean(name='Verbose', position='Query'),
}

model GetNodeMetricsResponseBody = {
  metricType?: string(name='MetricType'),
  nodesMetrics?: [
    NodeMetric
  ](name='NodesMetrics'),
  resourceGroupID?: string(name='ResourceGroupID'),
}

model GetNodeMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNodeMetricsResponseBody(name='body'),
}

async function getNodeMetrics(request: GetNodeMetricsRequest): GetNodeMetricsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetNodeMetrics', 'GET', '/api/v1/resources/{ResourceGroupID}/nodemetrics/{MetricType}', 'json', false, 'json', request);
}

model GetQuotaRequest {
  quotaId?: string(name='QuotaId', example='quota1ci8g793pgm', position='Path'),
}

model GetQuotaResponseBody = {
  allocateStrategy?: string(name='AllocateStrategy', example='ByNodeSpec'),
  creatorId?: string(name='CreatorId', example='18846926616'),
  description?: string(name='Description', example='this is a test quota'),
  gmtCreatedTime?: string(name='GmtCreatedTime', example='2023-06-22T00:00:00Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', example='2023-06-22T00:00:00Z'),
  labels?: [
    Label
  ](name='Labels'),
  latestOperationId?: string(name='LatestOperationId', example='operation1234'),
  min?: ResourceSpec(name='Min'),
  parentQuotaId?: string(name='ParentQuotaId', example='quota1ci8g793pgm'),
  queueStrategy?: string(name='QueueStrategy', example='PaiStrategyIntelligent'),
  quotaConfig?: QuotaConfig(name='QuotaConfig'),
  quotaDetails?: QuotaDetails(name='QuotaDetails'),
  quotaId?: string(name='QuotaId', description='Quota Id', example='quotajradxh43rgb'),
  quotaName?: string(name='QuotaName', example='test-quota'),
  reasonCode?: string(name='ReasonCode', example='“”'),
  reasonMessage?: string(name='ReasonMessage', example='“”'),
  requestId?: string(name='RequestId', example='18D5A1C6-14B8-545E-8408-0A7DDB4C6B5E'),
  resourceGroupIds?: [ string ](name='ResourceGroupIds'),
  resourceType?: string(name='ResourceType', example='ECS'),
  status?: string(name='Status', example='Ready'),
  subQuotas?: [
    QuotaIdName
  ](name='SubQuotas'),
  workspaces?: [
    WorkspaceIdName
  ](name='Workspaces'),
}

model GetQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetQuotaResponseBody(name='body'),
}

async function getQuota(request: GetQuotaRequest): GetQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetQuota', 'GET', '/api/v1/quotas/{QuotaId}', 'json', false, 'json', request);
}

model GetResourceGroupRequest {
  resourceGroupID: string(name='ResourceGroupID', example='rgmhpp8ib5lprq9k', position='Path'),
  isAIWorkspaceDataEnabled?: boolean(name='IsAIWorkspaceDataEnabled', position='Query'),
}

model GetResourceGroupResponseBody = {
  clusterID?: string(name='ClusterID'),
  computingResourceProvider?: string(name='ComputingResourceProvider'),
  creatorID?: string(name='CreatorID'),
  gmtCreatedTime?: string(name='GmtCreatedTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  resourceType?: string(name='ResourceType'),
  status?: string(name='Status'),
  supportRDMA?: boolean(name='SupportRDMA'),
  userVpc?: UserVpc(name='UserVpc'),
  workspaceID?: string(name='WorkspaceID'),
}

model GetResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceGroupResponseBody(name='body'),
}

async function getResourceGroup(request: GetResourceGroupRequest): GetResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetResourceGroup', 'GET', '/api/v1/resources/{ResourceGroupID}', 'json', false, 'json', request);
}

model GetResourceGroupMachineGroupRequest {
  machineGroupID: string(name='MachineGroupID', position='Path'),
  resourceGroupID: string(name='ResourceGroupID', position='Path'),
}

model GetResourceGroupMachineGroupResponseBody = {
  cpu?: string(name='Cpu'),
  defaultDriver?: string(name='DefaultDriver'),
  ecsCount?: long(name='EcsCount'),
  ecsSpec?: string(name='EcsSpec'),
  gmtCreatedTime?: string(name='GmtCreatedTime'),
  gmtExpiredTime?: string(name='GmtExpiredTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  gmtStartedTime?: string(name='GmtStartedTime'),
  gpu?: string(name='Gpu'),
  gpuType?: string(name='GpuType'),
  machineGroupID?: string(name='MachineGroupID'),
  memory?: string(name='Memory'),
  paymentDuration?: string(name='PaymentDuration'),
  paymentDurationUnit?: string(name='PaymentDurationUnit'),
  paymentType?: string(name='PaymentType'),
  requestId?: string(name='RequestId'),
  resourceGroupID?: string(name='ResourceGroupID'),
  status?: string(name='Status'),
  supportedDrivers?: [ string ](name='SupportedDrivers'),
}

model GetResourceGroupMachineGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceGroupMachineGroupResponseBody(name='body'),
}

async function getResourceGroupMachineGroup(request: GetResourceGroupMachineGroupRequest): GetResourceGroupMachineGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetResourceGroupMachineGroup', 'GET', '/api/v1/resources/{ResourceGroupID}/machinegroups/{MachineGroupID}', 'json', false, 'json', request);
}

model GetResourceGroupRequestRequest {
  podStatus?: string(name='PodStatus', position='Query'),
  resourceGroupID: string(name='ResourceGroupID', position='Query'),
}

model GetResourceGroupRequestResponseBody = {
  requestCPU?: int32(name='requestCPU'),
  requestGPU?: int32(name='requestGPU'),
  requestGPUInfos?: [
    GPUInfo
  ](name='requestGPUInfos'),
  requestMemory?: int32(name='requestMemory'),
}

model GetResourceGroupRequestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceGroupRequestResponseBody(name='body'),
}

async function getResourceGroupRequest(request: GetResourceGroupRequestRequest): GetResourceGroupRequestResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetResourceGroupRequest', 'GET', '/api/v1/resources/data/request', 'json', false, 'json', request);
}

model GetResourceGroupTotalRequest {
  resourceGroupID?: string(name='ResourceGroupID', position='Query'),
}

model GetResourceGroupTotalResponseBody = {
  totalCPU?: int32(name='totalCPU'),
  totalGPU?: int32(name='totalGPU'),
  totalGPUInfos?: [
    GPUInfo
  ](name='totalGPUInfos'),
  totalMemory?: int32(name='totalMemory'),
}

model GetResourceGroupTotalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceGroupTotalResponseBody(name='body'),
}

async function getResourceGroupTotal(request: GetResourceGroupTotalRequest): GetResourceGroupTotalResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetResourceGroupTotal', 'GET', '/api/v1/resources/data/total', 'json', false, 'json', request);
}

model GetTrainingJobRequest {
  trainingJobId: string(name='TrainingJobId', position='Path'),
}

model GetTrainingJobResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  algorithmName?: string(name='AlgorithmName'),
  algorithmProvider?: string(name='AlgorithmProvider'),
  algorithmSpec?: AlgorithmSpec(name='AlgorithmSpec'),
  algorithmVersion?: string(name='AlgorithmVersion'),
  computeResource?: {
    ecsCount?: long(name='EcsCount'),
    ecsSpec?: string(name='EcsSpec'),
    instanceCount?: long(name='InstanceCount'),
    instanceSpec?: {
      CPU?: string(name='CPU'),
      GPU?: string(name='GPU'),
      GPUType?: string(name='GPUType'),
      memory?: string(name='Memory'),
      sharedMemory?: string(name='SharedMemory'),
    }(name='InstanceSpec'),
    resourceId?: string(name='ResourceId'),
  }(name='ComputeResource'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  hyperParameters?: [ 
    {
      name?: string(name='Name'),
      value?: string(name='Value'),
    }
  ](name='HyperParameters'),
  inputChannels?: [ 
    {
      datasetId?: string(name='DatasetId'),
      inputUri?: string(name='InputUri'),
      name?: string(name='Name'),
    }
  ](name='InputChannels'),
  instances?: [ 
    {
      name?: string(name='Name'),
      role?: string(name='Role'),
      status?: string(name='Status'),
    }
  ](name='Instances'),
  isTempAlgo?: boolean(name='IsTempAlgo'),
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
  latestMetrics?: [ 
    {
      name?: string(name='Name'),
      timestamp?: string(name='Timestamp'),
      value?: double(name='Value'),
    }
  ](name='LatestMetrics'),
  latestProgress?: {
    overallProgress?: {
      timestamp?: string(name='Timestamp'),
      value?: float(name='Value'),
    }(name='OverallProgress'),
    remainingTime?: {
      timestamp?: string(name='Timestamp'),
      value?: long(name='Value'),
    }(name='RemainingTime'),
  }(name='LatestProgress'),
  outputChannels?: [ 
    {
      datasetId?: string(name='DatasetId'),
      name?: string(name='Name'),
      outputUri?: string(name='OutputUri'),
    }
  ](name='OutputChannels'),
  outputModel?: {
    outputChannelName?: string(name='OutputChannelName'),
    uri?: string(name='Uri'),
  }(name='OutputModel'),
  reasonCode?: string(name='ReasonCode'),
  reasonMessage?: string(name='ReasonMessage'),
  requestId?: string(name='RequestId'),
  roleArn?: string(name='RoleArn'),
  scheduler?: {
    maxRunningTimeInSeconds?: long(name='MaxRunningTimeInSeconds'),
  }(name='Scheduler'),
  status?: string(name='Status'),
  statusTransitions?: [ 
    {
      endTime?: string(name='EndTime'),
      reasonCode?: string(name='ReasonCode'),
      reasonMessage?: string(name='ReasonMessage'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
    }
  ](name='StatusTransitions'),
  trainingJobDescription?: string(name='TrainingJobDescription'),
  trainingJobId?: string(name='TrainingJobId'),
  trainingJobName?: string(name='TrainingJobName'),
  trainingJobUrl?: string(name='TrainingJobUrl'),
  userId?: string(name='UserId'),
  userVpc?: {
    extendedCIDRs?: [ string ](name='ExtendedCIDRs'),
    securityGroupId?: string(name='SecurityGroupId'),
    switchId?: string(name='SwitchId'),
    vpcId?: string(name='VpcId'),
  }(name='UserVpc'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetTrainingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTrainingJobResponseBody(name='body'),
}

async function getTrainingJob(request: GetTrainingJobRequest): GetTrainingJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTrainingJob', 'GET', '/api/v1/trainingjobs/{TrainingJobId}', 'json', false, 'json', request);
}

model GetUserViewMetricsRequest {
  resourceGroupID: string(name='ResourceGroupID', position='Path'),
  order?: string(name='Order', position='Query'),
  pageNumber: string(name='PageNumber', position='Query'),
  pageSize: string(name='PageSize', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
  timeStep?: string(name='TimeStep', position='Query'),
  userId?: string(name='UserId', position='Query'),
  workspaceId?: string(name='WorkspaceId', position='Query'),
}

model GetUserViewMetricsResponseBody = {
  resourceGroupId?: string(name='ResourceGroupId'),
  summary?: UserViewMetric(name='Summary'),
  total?: int32(name='Total'),
  userMetrics?: [
    UserViewMetric
  ](name='UserMetrics'),
}

model GetUserViewMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserViewMetricsResponseBody(name='body'),
}

async function getUserViewMetrics(request: GetUserViewMetricsRequest): GetUserViewMetricsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetUserViewMetrics', 'GET', '/api/v1/resources/{ResourceGroupID}/usermetrics', 'json', false, 'json', request);
}

model ListAlgorithmVersionsRequest {
  algorithmId?: string(name='AlgorithmId', position='Path'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
}

model ListAlgorithmVersionsResponseBody = {
  algorithmVersions?: [ 
    {
      algorithmId?: string(name='AlgorithmId'),
      algorithmName?: string(name='AlgorithmName'),
      algorithmProvider?: string(name='AlgorithmProvider'),
      algorithmVersion?: string(name='AlgorithmVersion'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      tenantId?: string(name='TenantId'),
      userId?: string(name='UserId'),
    }
  ](name='AlgorithmVersions'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListAlgorithmVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlgorithmVersionsResponseBody(name='body'),
}

async function listAlgorithmVersions(request: ListAlgorithmVersionsRequest): ListAlgorithmVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAlgorithmVersions', 'GET', '/api/v1/algorithms/{AlgorithmId}/versions', 'json', false, 'json', request);
}

model ListAlgorithmsRequest {
  algorithmId?: string(name='AlgorithmId', position='Query'),
  algorithmName?: string(name='AlgorithmName', position='Query'),
  algorithmProvider?: string(name='AlgorithmProvider', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  workspaceId?: string(name='WorkspaceId', position='Query'),
}

model ListAlgorithmsResponseBody = {
  algorithms?: [ 
    {
      algorithmDescription?: string(name='AlgorithmDescription'),
      algorithmId?: string(name='AlgorithmId'),
      algorithmName?: string(name='AlgorithmName'),
      algorithmProvider?: string(name='AlgorithmProvider'),
      displayName?: string(name='DisplayName'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      userId?: string(name='UserId'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='Algorithms'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListAlgorithmsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlgorithmsResponseBody(name='body'),
}

async function listAlgorithms(request: ListAlgorithmsRequest): ListAlgorithmsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAlgorithms', 'GET', '/api/v1/algorithms', 'json', false, 'json', request);
}

model ListQuotasRequest {
  labels?: string(name='Labels', example='official=true,gpu=false', position='Query'),
  order?: string(name='Order', example='desc', position='Query'),
  pageNumber?: int32(name='PageNumber', example='1', position='Query'),
  pageSize?: int32(name='PageSize', example='20', position='Query'),
  parentQuotaId?: string(name='ParentQuotaId', example='quotajradxh43rgb', position='Query'),
  quotaIds?: string(name='QuotaIds', example='quota1ci8g793pgm,quotajradxh43rgb', position='Query'),
  quotaName?: string(name='QuotaName', example='quotajradxh43rgb', position='Query'),
  resourceType?: string(name='ResourceType', example='ECS', position='Query'),
  sortBy?: string(name='SortBy', example='status', position='Query'),
  statuses?: string(name='Statuses', example='Creating', position='Query'),
  workspaceIds?: string(name='WorkspaceIds', example='21345,38727', position='Query'),
}

model ListQuotasResponseBody = {
  quotas?: [
    Quota
  ](name='Quotas'),
  requestId?: string(name='RequestId', example='F082BD0D-21E1-5F9B-81A0-AB07485B03CD'),
}

model ListQuotasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListQuotasResponseBody(name='body'),
}

async function listQuotas(request: ListQuotasRequest): ListQuotasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListQuotas', 'GET', '/api/v1/quotas/', 'json', false, 'json', request);
}

model ListResourceGroupMachineGroupsRequest {
  resourceGroupID?: string(name='ResourceGroupID', position='Path'),
  creatorID?: string(name='CreatorID', position='Query'),
  ecsSpec?: string(name='EcsSpec', position='Query'),
  name?: string(name='Name', position='Query'),
  order?: string(name='Order', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  paymentDuration?: string(name='PaymentDuration', position='Query'),
  paymentDurationUnit?: string(name='PaymentDurationUnit', position='Query'),
  paymentType?: string(name='PaymentType', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
  status?: string(name='Status', position='Query'),
}

model ListResourceGroupMachineGroupsResponseBody = {
  machineGroups?: [
    MachineGroup
  ](name='MachineGroups'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListResourceGroupMachineGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceGroupMachineGroupsResponseBody(name='body'),
}

async function listResourceGroupMachineGroups(request: ListResourceGroupMachineGroupsRequest): ListResourceGroupMachineGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListResourceGroupMachineGroups', 'GET', '/api/v1/resources/{ResourceGroupID}/machinegroups', 'json', false, 'json', request);
}

model ListResourceGroupsRequest {
  computingResourceProvider?: string(name='ComputingResourceProvider', position='Query'),
  name?: string(name='Name', example='RG1', position='Query'),
  order?: string(name='Order', example='desc', position='Query'),
  pageNumber?: long(name='PageNumber', example='2', position='Query'),
  pageSize?: long(name='PageSize', example='10', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  showAll?: boolean(name='ShowAll', position='Query'),
  sortBy?: string(name='SortBy', example='DisplayName', position='Query'),
  status?: string(name='Status', example='Creating', position='Query'),
}

model ListResourceGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  resourceGroups?: [
    ResourceGroup
  ](name='ResourceGroups', example='RG1'),
  totalCount: long(name='TotalCount', example='2'),
}

model ListResourceGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceGroupsResponseBody(name='body'),
}

async function listResourceGroups(request: ListResourceGroupsRequest): ListResourceGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListResourceGroups', 'GET', '/api/v1/resources', 'json', false, 'json', request);
}

model ListTrainingJobLogsRequest {
  trainingJobId: string(name='TrainingJobId', position='Path'),
  endTime?: string(name='EndTime', example='2020-11-08T16:00:00Z', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  pageNumber?: long(name='PageNumber', example='1', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', example='100', minimum=1, maximum=2000, position='Query'),
  startTime?: string(name='StartTime', example='2020-11-08T16:00:00Z', position='Query'),
  workerId?: string(name='WorkerId', position='Query'),
}

model ListTrainingJobLogsResponseBody = {
  logs?: [ string ](name='Logs'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListTrainingJobLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTrainingJobLogsResponseBody(name='body'),
}

async function listTrainingJobLogs(request: ListTrainingJobLogsRequest): ListTrainingJobLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTrainingJobLogs', 'GET', '/api/v1/trainingjobs/{TrainingJobId}/logs', 'json', false, 'json', request);
}

model ListTrainingJobMetricsRequest {
  trainingJobId: string(name='TrainingJobId', position='Path'),
  endTime?: string(name='EndTime', example='2020-11-08T16:00:00Z', position='Query'),
  name?: string(name='Name', position='Query'),
  order?: string(name='Order', position='Query'),
  pageNumber?: long(name='PageNumber', example='1', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', example='100', minimum=1, maximum=100, position='Query'),
  startTime?: string(name='StartTime', example='2020-11-08T16:00:00Z', position='Query'),
}

model ListTrainingJobMetricsResponseBody = {
  metrics?: [ 
    {
      name?: string(name='Name'),
      timestamp?: string(name='Timestamp'),
      value?: double(name='Value'),
    }
  ](name='Metrics'),
  requestId?: string(name='RequestId'),
}

model ListTrainingJobMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTrainingJobMetricsResponseBody(name='body'),
}

async function listTrainingJobMetrics(request: ListTrainingJobMetricsRequest): ListTrainingJobMetricsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTrainingJobMetrics', 'GET', '/api/v1/trainingjobs/{TrainingJobId}/metrics', 'json', false, 'json', request);
}

model ListTrainingJobsRequest {
  algorithmName?: string(name='AlgorithmName', position='Query'),
  algorithmProvider?: string(name='AlgorithmProvider', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  isTempAlgo?: boolean(name='IsTempAlgo', position='Query'),
  labels?: map[string]any(name='Labels', shrink='json', position='Query'),
  order?: string(name='Order', position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  status?: string(name='Status', position='Query'),
  trainingJobId?: string(name='TrainingJobId', position='Query'),
  trainingJobName?: string(name='TrainingJobName', position='Query'),
  workspaceId?: string(name='WorkspaceId', position='Query'),
}

model ListTrainingJobsResponseBody = {
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  trainingJobs?: [ 
    {
      algorithmName?: string(name='AlgorithmName'),
      algorithmProvider?: string(name='AlgorithmProvider'),
      algorithmVersion?: string(name='AlgorithmVersion'),
      computeResource?: {
        ecsCount?: long(name='EcsCount'),
        ecsSpec?: string(name='EcsSpec'),
        instanceCount?: long(name='InstanceCount'),
        instanceSpec?: {
          CPU?: string(name='CPU'),
          GPU?: string(name='GPU'),
          GPUType?: string(name='GPUType'),
          memory?: string(name='Memory'),
          sharedMemory?: string(name='SharedMemory'),
        }(name='InstanceSpec'),
        resourceId?: string(name='ResourceId'),
      }(name='ComputeResource'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      hyperParameters?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='HyperParameters'),
      inputChannels?: [ 
        {
          datasetId?: string(name='DatasetId'),
          inputUri?: string(name='InputUri'),
          name?: string(name='Name'),
        }
      ](name='InputChannels'),
      isTempAlgo?: boolean(name='IsTempAlgo'),
      labels?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Labels'),
      outputChannels?: [ 
        {
          datasetId?: string(name='DatasetId'),
          name?: string(name='Name'),
          outputUri?: string(name='OutputUri'),
        }
      ](name='OutputChannels'),
      reasonCode?: string(name='ReasonCode'),
      reasonMessage?: string(name='ReasonMessage'),
      roleArn?: string(name='RoleArn'),
      scheduler?: {
        maxRunningTimeInSeconds?: long(name='MaxRunningTimeInSeconds'),
      }(name='Scheduler'),
      status?: string(name='Status'),
      statusTransitions?: [ 
        {
          endTime?: string(name='EndTime'),
          reasonCode?: string(name='ReasonCode'),
          reasonMessage?: string(name='ReasonMessage'),
          startTime?: string(name='StartTime'),
          status?: string(name='Status'),
        }
      ](name='StatusTransitions'),
      trainingJobDescription?: string(name='TrainingJobDescription'),
      trainingJobId?: string(name='TrainingJobId'),
      trainingJobName?: string(name='TrainingJobName'),
      userId?: string(name='UserId'),
      userVpc?: {
        defaultRoute?: string(name='DefaultRoute'),
        extendedCIDRs?: [ string ](name='ExtendedCIDRs'),
        securityGroupId?: string(name='SecurityGroupId'),
        switchId?: string(name='SwitchId'),
        vpcId?: string(name='VpcId'),
      }(name='UserVpc'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='TrainingJobs'),
}

model ListTrainingJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTrainingJobsResponseBody(name='body'),
}

async function listTrainingJobs(request: ListTrainingJobsRequest): ListTrainingJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTrainingJobs', 'GET', '/api/v1/trainingjobs', 'json', false, 'json', request);
}

model ScaleQuotaRequest {
  quotaId?: string(name='QuotaId', description='Quota ID', example='quotamtl37ge7gkvdz', position='Path'),
  min?: ResourceSpec(name='Min', position='Body'),
  resourceGroupIds?: [ string ](name='ResourceGroupIds', position='Body'),
}

model ScaleQuotaResponseBody = {
  quotaId?: string(name='QuotaId', description='Quota Id', example='quotamtl37ge7gkvdz'),
  requestId?: string(name='RequestId', example='F2D0392B-D749-5C48-A98A-3FAE5C9444A6'),
}

model ScaleQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ScaleQuotaResponseBody(name='body'),
}

async function scaleQuota(request: ScaleQuotaRequest): ScaleQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ScaleQuota', 'PUT', '/api/v1/quotas/{QuotaId}/action/scale', 'json', false, 'json', request);
}

model StopTrainingJobRequest {
  trainingJobId?: string(name='TrainingJobId', position='Path'),
}

model StopTrainingJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopTrainingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopTrainingJobResponseBody(name='body'),
}

async function stopTrainingJob(request: StopTrainingJobRequest): StopTrainingJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StopTrainingJob', 'PUT', '/api/v1/trainingjobs/{TrainingJobId}/stop', 'json', false, 'json', request);
}

model UpdateAlgorithmRequest {
  algorithmId?: string(name='AlgorithmId', position='Path'),
  algorithmDescription?: string(name='AlgorithmDescription', position='Body'),
  displayName?: string(name='DisplayName', position='Body'),
}

model UpdateAlgorithmResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  requestId?: string(name='RequestId'),
}

model UpdateAlgorithmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAlgorithmResponseBody(name='body'),
}

async function updateAlgorithm(request: UpdateAlgorithmRequest): UpdateAlgorithmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateAlgorithm', 'PUT', '/api/v1/algorithms/{AlgorithmId}', 'json', true, 'form', request);
}

model UpdateAlgorithmVersionRequest {
  algorithmId?: string(name='AlgorithmId', position='Path'),
  algorithmVersion?: string(name='AlgorithmVersion', position='Path'),
  algorithmSpec?: AlgorithmSpec(name='AlgorithmSpec', shrink='json', position='Body'),
}

model UpdateAlgorithmVersionResponseBody = {
  algorithmId?: string(name='AlgorithmId'),
  algorithmVersion?: string(name='AlgorithmVersion'),
}

model UpdateAlgorithmVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAlgorithmVersionResponseBody(name='body'),
}

async function updateAlgorithmVersion(request: UpdateAlgorithmVersionRequest): UpdateAlgorithmVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateAlgorithmVersion', 'PUT', '/api/v1/algorithms/{AlgorithmId}/versions/{AlgorithmVersion}', 'json', true, 'form', request);
}

model UpdateQuotaRequest {
  quotaId?: string(name='QuotaId', description='Quota ID', example='quota-20210126170216-mtl37ge7gkvdz', position='Path'),
  description?: string(name='Description', example='this is a test quota', position='Body'),
  labels?: [
    Label
  ](name='Labels', position='Body'),
  queueStrategy?: string(name='QueueStrategy', position='Body'),
}

model UpdateQuotaResponseBody = {
  quotaId?: string(name='QuotaId', description='Quota Id', example='quota-20210126170216-mtl37ge7gkvdz'),
  requestId?: string(name='RequestId', example='96496E6E-00B4-5F55-80F6-1844FA9E92DC'),
}

model UpdateQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateQuotaResponseBody(name='body'),
}

async function updateQuota(request: UpdateQuotaRequest): UpdateQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateQuota', 'PUT', '/api/v1/quotas/{QuotaId}', 'json', false, 'json', request);
}

model UpdateResourceGroupRequest {
  resourceGroupID?: string(name='ResourceGroupID', position='Path'),
  unbind?: boolean(name='Unbind', position='Body'),
  userVpc?: UserVpc(name='UserVpc', position='Body'),
}

model UpdateResourceGroupResponseBody = {
  resourceGroupID?: string(name='ResourceGroupID'),
  requestId?: string(name='requestId'),
}

model UpdateResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateResourceGroupResponseBody(name='body'),
}

async function updateResourceGroup(request: UpdateResourceGroupRequest): UpdateResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateResourceGroup', 'PUT', '/api/v1/resources/{ResourceGroupID}', 'json', false, 'json', request);
}

model UpdateTrainingJobLabelsRequest {
  trainingJobId: string(name='TrainingJobId', position='Path'),
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels', position='Body'),
}

model UpdateTrainingJobLabelsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTrainingJobLabelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTrainingJobLabelsResponseBody(name='body'),
}

async function updateTrainingJobLabels(request: UpdateTrainingJobLabelsRequest): UpdateTrainingJobLabelsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateTrainingJobLabels', 'POST', '/api/v1/trainingjobs/{TrainingJobId}/labels', 'json', false, 'json', request);
}

