/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('cms', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddonMeta {
  alias?: string(name='alias'),
  categories?: [ string ](name='categories'),
  dashboards?: [ 
    {
      description?: string(name='description'),
      name?: string(name='name'),
      url?: string(name='url'),
    }
  ](name='dashboards'),
  description?: string(name='description'),
  environments?: [ 
    {
      commonSchemaRefs?: [ 
        {
          group?: string(name='group'),
          version?: string(name='version'),
        }
      ](name='commonSchemaRefs'),
      dependencies?: {
        clusterTypes?: [ string ](name='clusterTypes'),
        features?: map[string]boolean(name='features'),
        services?: [ string ](name='services'),
      }(name='dependencies'),
      description?: string(name='description'),
      enable?: boolean(name='enable'),
      label?: string(name='label'),
      name?: string(name='name'),
      policies?: {
        alertDefaultStatus?: string(name='alertDefaultStatus'),
        bindDefaultPolicy?: boolean(name='bindDefaultPolicy'),
        bindEntity?: {
          entityGroupMode?: boolean(name='entityGroupMode'),
          entityType?: string(name='entityType'),
          singleEntityMode?: boolean(name='singleEntityMode'),
          vpcIdFieldKey?: string(name='vpcIdFieldKey'),
        }(name='bindEntity'),
        defaultInstall?: boolean(name='defaultInstall'),
        enableServiceAccount?: boolean(name='enableServiceAccount'),
        metricCheckRule?: {
          promQL?: [ string ](name='promQL'),
        }(name='metricCheckRule'),
        needRestartAfterIntegration?: boolean(name='needRestartAfterIntegration'),
        protocols?: [ 
          {
            description?: string(name='description'),
            icon?: string(name='icon'),
            label?: string(name='label'),
            name?: string(name='name'),
          }
        ](name='protocols'),
        targetAddonName?: string(name='targetAddonName'),
      }(name='policies'),
      policyType?: string(name='policyType'),
    }
  ](name='environments'),
  icon?: string(name='icon'),
  keywords?: [ string ](name='keywords'),
  language?: string(name='language'),
  latestReleaseCreateTime?: string(name='latestReleaseCreateTime'),
  name?: string(name='name'),
  once?: boolean(name='once'),
  scene?: string(name='scene'),
  version?: string(name='version'),
  weight?: int32(name='weight'),
}

model AlertEventIntegrationPolicyForModify {
  alertEventIntegrationPolicyName?: string(name='alertEventIntegrationPolicyName', description='This parameter is required.'),
  description?: string(name='description'),
  filterSetting?: FilterSetting(name='filterSetting'),
  integrationSetting?: string(name='integrationSetting'),
  transformerSetting?: [
    TransformAction
  ](name='transformerSetting'),
  type?: string(name='type'),
}

model AlertEventIntegrationPolicyForView {
  alertEventIntegrationPolicyId?: string(name='alertEventIntegrationPolicyId'),
  alertEventIntegrationPolicyName?: string(name='alertEventIntegrationPolicyName', description='This parameter is required.'),
  createTime?: string(name='createTime'),
  description?: string(name='description'),
  enable?: boolean(name='enable'),
  filterSetting?: FilterSetting(name='filterSetting'),
  integrationSetting?: string(name='integrationSetting'),
  token?: string(name='token'),
  transformerSetting?: [
    TransformAction
  ](name='transformerSetting'),
  type?: string(name='type'),
  updateTime?: string(name='updateTime'),
  userId?: string(name='userId'),
  workspace?: string(name='workspace'),
}

model AlertRuleAction {
  actions?: [ string ](name='actions'),
}

model AlertRuleAlertMetricFilterDef {
  dim?: string(name='dim'),
  dimDisabled?: boolean(name='dimDisabled'),
  displayNameCn?: string(name='displayNameCn'),
  displayNameEn?: string(name='displayNameEn'),
  hidden?: boolean(name='hidden'),
  labelDisabled?: boolean(name='labelDisabled'),
  opt?: string(name='opt'),
  supportedOpts?: [ 
    {
      displayNameCn?: string(name='displayNameCn'),
      displayNameEn?: string(name='displayNameEn'),
      value?: string(name='value'),
    }
  ](name='supportedOpts'),
}

model AlertRuleAlertMetricInput {
  filterValues?: [
    AlertRuleAlertMetricInputFilterValue
  ](name='filterValues'),
  groupId?: string(name='groupId'),
  metricId?: string(name='metricId'),
  paramValues?: [
    AlertRuleAlertMetricInputParamValue
  ](name='paramValues'),
}

model AlertRuleAlertMetricInputFilterValue {
  dim?: string(name='dim', description='This parameter is required.'),
  opt?: string(name='opt', description='This parameter is required.'),
  value?: string(name='value'),
}

model AlertRuleAlertMetricInputParamValue {
  name?: string(name='name', description='This parameter is required.'),
  value?: string(name='value', description='This parameter is required.'),
}

model AlertRuleAlertMetricParamDef {
  maxWidth?: int32(name='maxWidth'),
  minWidth?: int32(name='minWidth'),
  name?: string(name='name'),
  placeholderCn?: string(name='placeholderCn'),
  placeholderEn?: string(name='placeholderEn'),
  type?: string(name='type'),
  value?: string(name='value'),
  values?: [ 
    {
      labelCn?: string(name='labelCn'),
      labelEn?: string(name='labelEn'),
      value?: string(name='value'),
    }
  ](name='values'),
}

model AlertRuleCondition {
  alertCount?: int32(name='alertCount', description='type=SLS_CONDITION时指定，满足条件几次后告警，默认为1'),
  caseList?: [ 
    {
      condition?: string(name='condition'),
      countCondition?: string(name='countCondition'),
      level?: string(name='level'),
      type?: string(name='type'),
    }
  ](name='caseList', description='type=SLS_CONDITION时指定'),
  compareList?: [ 
    {
      aggregate?: string(name='aggregate'),
      baseUnit?: string(name='baseUnit'),
      displayUnit?: string(name='displayUnit'),
      oper?: string(name='oper'),
      value?: double(name='value'),
      valueLevelList?: [ 
        {
          level?: string(name='level'),
          value?: double(name='value'),
        }
      ](name='valueLevelList'),
      yoyTimeUnit?: string(name='yoyTimeUnit'),
      yoyTimeValue?: int32(name='yoyTimeValue'),
    }
  ](name='compareList'),
  compositeEscalation?: {
    escalations?: [ 
      {
        comparisonOperator?: string(name='comparisonOperator'),
        metricName?: string(name='metricName'),
        period?: long(name='period'),
        statistics?: string(name='statistics'),
        threshold?: double(name='threshold'),
      }
    ](name='escalations'),
    level?: string(name='level'),
    relation?: string(name='relation'),
    times?: int32(name='times'),
  }(name='compositeEscalation'),
  escalationType?: string(name='escalationType'),
  expressEscalation?: {
    level?: string(name='level'),
    rawExpression?: string(name='rawExpression'),
    times?: int32(name='times'),
  }(name='expressEscalation'),
  noDataAlertLevel?: string(name='noDataAlertLevel', description='无数据时按什么级别告警，不指定则不对无数据报警'),
  noDataAppendValue?: string(name='noDataAppendValue'),
  noDataPolicy?: string(name='noDataPolicy'),
  oper?: string(name='oper'),
  relation?: string(name='relation'),
  simpleEscalation?: {
    escalations?: [ 
      {
        comparisonOperator?: string(name='comparisonOperator'),
        level?: string(name='level'),
        statistics?: string(name='statistics'),
        threshold?: double(name='threshold'),
        times?: int32(name='times'),
      }
    ](name='escalations'),
    metricName?: string(name='metricName'),
    period?: long(name='period'),
  }(name='simpleEscalation'),
  type?: string(name='type', description='规则条件类型，可选值：SLS_CONDITION

This parameter is required.'),
  value?: double(name='value'),
}

model AlertRuleDataSource {
  appType?: string(name='appType'),
  dsList?: [ 
    {
      project?: string(name='project'),
      regionId?: string(name='regionId'),
      store?: string(name='store'),
      type?: string(name='type'),
    }
  ](name='dsList'),
  instanceId?: string(name='instanceId', description='实例id，当type=PROMETHEUS_DS/ENTERPRISE_DS时必填，为prometheus实例的clusterId或指标仓库名称'),
  namespace?: string(name='namespace'),
  regionId?: string(name='regionId'),
  type?: string(name='type', description='数据源类型

This parameter is required.'),
}

model AlertRuleLabelFilter {
  labels?: map[string]string(name='labels'),
  opt?: string(name='opt'),
}

model AlertRuleNotification {
  contacts?: [ string ](name='contacts'),
  customWebhooks?: [ string ](name='customWebhooks'),
  dingWebhooks?: [ string ](name='dingWebhooks'),
  fsWebhooks?: [ string ](name='fsWebhooks'),
  groups?: [ string ](name='groups'),
  notifyTime?: AlertRuleTimeSpan(name='notifyTime'),
  silenceTime?: long(name='silenceTime'),
  slackWebhooks?: [ string ](name='slackWebhooks'),
  wxWebhooks?: [ string ](name='wxWebhooks'),
}

model AlertRuleNotificationFilter {
  contacts?: [ string ](name='contacts'),
  customWebhooks?: [ string ](name='customWebhooks'),
  dingWebhooks?: [ string ](name='dingWebhooks'),
  fsWebhooks?: [ string ](name='fsWebhooks'),
  groups?: [ string ](name='groups'),
  slackWebhooks?: [ string ](name='slackWebhooks'),
  wxWebhooks?: [ string ](name='wxWebhooks'),
}

model AlertRuleQuery {
  checkAfterDataComplete?: boolean(name='checkAfterDataComplete'),
  dimensions?: [ map[string]string ](name='dimensions'),
  domain?: string(name='domain'),
  duration?: long(name='duration'),
  entityFilter?: {
    domain?: string(name='domain'),
    filters?: [ 
      {
        field?: string(name='field'),
        operator?: string(name='operator'),
        value?: string(name='value'),
      }
    ](name='filters'),
    type?: string(name='type'),
  }(name='entityFilter'),
  expr?: string(name='expr'),
  firstJoin?: AlertRuleSlsQueryJoin(name='firstJoin'),
  groupFieldList?: [ string ](name='groupFieldList'),
  groupId?: string(name='groupId'),
  groupType?: string(name='groupType'),
  metric?: string(name='metric'),
  metricSet?: string(name='metricSet'),
  namespace?: string(name='namespace'),
  queries?: [ 
    {
      apmAlertMetricId?: string(name='apmAlertMetricId'),
      apmFilters?: [ 
        {
          dim?: string(name='dim'),
          type?: string(name='type'),
          value?: string(name='value'),
        }
      ](name='apmFilters'),
      apmGroupBy?: [ string ](name='apmGroupBy'),
      duration?: long(name='duration'),
      end?: long(name='end', description='时间偏移结束时间(相对)，如果指定了start、end，则不指定window。'),
      expr?: string(name='expr', description='查询表达式'),
      start?: long(name='start', description='sls查询的时间偏移开始时间(相对)，如果指定了start、end，则不指定window。  例如：start=15， timeUnit=minute，表示15分钟前'),
      timeUnit?: string(name='timeUnit', description='start和end、window的时间单位： day/hour/minute/second'),
      window?: long(name='window', description='整点时间查询区间。  如果指定了window则不指定start、end'),
    }
  ](name='queries'),
  relationType?: string(name='relationType'),
  secondJoin?: AlertRuleSlsQueryJoin(name='secondJoin'),
  serviceIds?: [ string ](name='serviceIds'),
  type?: string(name='type', description='查询类型

This parameter is required.'),
}

model AlertRuleSend {
  action?: AlertRuleAction(name='action'),
  notification?: AlertRuleNotification(name='notification'),
  sendToArms?: boolean(name='sendToArms'),
}

model AlertRuleSlsQueryJoin {
  conditions?: [ 
    {
      firstField?: string(name='firstField', description='条件的左操作参数，格式为$<query_idx>.<结果集字段名>'),
      oper?: string(name='oper', description='<, >, ==, !=, <=, >='),
      secondField?: string(name='secondField', description='条件的右操作参数，格式为$<query_idx>.<结果集字段名>'),
    }
  ](name='conditions'),
  type?: string(name='type', description='集合操作类型。
  ● CrossJoin： 笛卡尔积
  ● FullJoin：全联
  ● InnerJoin：内联
  ● LeftExclude： 左斥
  ● RightExclude：右斥
  ● LeftJoin：左联
  ● RightJoin：右联
  ● NoJoin：不合并
  ● Concat： 拼接
  https://help.aliyun.com/zh/sls/user-guide/set-query-statistics-statement

This parameter is required.'),
}

model AlertRuleTimeSpan {
  dayOfWeek?: [ int32 ](name='dayOfWeek'),
  endTime?: string(name='endTime'),
  gmtOffset?: string(name='gmtOffset'),
  startTime?: string(name='startTime'),
}

model BizTraceConfig {
  advancedConfig?: string(name='advancedConfig'),
  bizTraceCode?: string(name='bizTraceCode'),
  bizTraceId?: string(name='bizTraceId'),
  bizTraceName?: string(name='bizTraceName'),
  createTime?: string(name='createTime'),
  regionId?: string(name='regionId'),
  ruleConfig?: string(name='ruleConfig'),
  workspace?: string(name='workspace'),
}

model DataStorageItem {
  dataType?: string(name='dataType'),
  project?: string(name='project'),
  regionId?: string(name='regionId'),
  storeName?: string(name='storeName'),
  storeType?: string(name='storeType'),
}

model EntityDiscoverRule {
  annotations?: [ 
    {
      op?: string(name='op'),
      tagKey?: string(name='tagKey'),
      tagValues?: [ string ](name='tagValues'),
    }
  ](name='annotations'),
  entityTypes?: [ string ](name='entityTypes'),
  fieldRules?: [ 
    {
      fieldKey?: string(name='fieldKey'),
      fieldValues?: [ string ](name='fieldValues'),
      op?: string(name='op'),
    }
  ](name='fieldRules'),
  instanceIds?: [ string ](name='instanceIds'),
  ipMatchRule?: [ 
    {
      ipCIDR?: string(name='ipCIDR'),
      ipFieldKey?: string(name='ipFieldKey'),
    }
  ](name='ipMatchRule'),
  labels?: [ 
    {
      op?: string(name='op'),
      tagKey?: string(name='tagKey'),
      tagValues?: [ string ](name='tagValues'),
    }
  ](name='labels'),
  regionIds?: [ string ](name='regionIds'),
  resourceGroupId?: string(name='resourceGroupId'),
  tags?: [ 
    {
      op?: string(name='op'),
      tagKey?: string(name='tagKey'),
      tagValues?: [ string ](name='tagValues'),
    }
  ](name='tags'),
}

model EntityGroupBase {
  description?: string(name='description'),
  entityGroupId?: string(name='entityGroupId'),
  entityGroupName?: string(name='entityGroupName'),
  entityQueries?: [ 
    {
      entityType?: string(name='entityType'),
      spl?: string(name='spl'),
    }
  ](name='entityQueries'),
  entityRules?: EntityDiscoverRule(name='entityRules'),
  regionId?: string(name='regionId'),
  userId?: string(name='userId'),
  workspace?: string(name='workspace'),
}

model FilterSetting {
  conditions?: [ 
    {
      field?: string(name='field'),
      op?: string(name='op'),
      value?: string(name='value'),
    }
  ](name='conditions'),
  expression?: string(name='expression'),
  relation?: string(name='relation'),
}

model IncidentContactStruct {
  channel?: [ string ](name='channel'),
  contactId?: string(name='contactId'),
  contactType?: string(name='contactType'),
}

model IncidentEscalationStageStruct {
  contact?: [
    IncidentContactStruct
  ](name='contact'),
  cycleNotifyCount?: int32(name='cycleNotifyCount'),
  cycleNotifyTime?: int32(name='cycleNotifyTime'),
  description?: string(name='description'),
  effectTime?: string(name='effectTime'),
  name?: string(name='name'),
  stageIndex?: int32(name='stageIndex'),
  timeZone?: string(name='timeZone'),
  waitToNextStageTime?: int32(name='waitToNextStageTime'),
}

model IncidentEscalationStruct {
  createTime?: long(name='createTime'),
  description?: string(name='description'),
  incidentEscalationId?: string(name='incidentEscalationId'),
  modifyTime?: long(name='modifyTime'),
  name?: string(name='name'),
  regionId?: string(name='regionId'),
  stage?: [
    IncidentEscalationStageStruct
  ](name='stage'),
  workspace?: string(name='workspace'),
}

model IncidentEventStruct {
  autoRecoverTime?: long(name='autoRecoverTime'),
  content?: string(name='content'),
  count?: int32(name='count'),
  dimension?: map[string]string(name='dimension'),
  groupBy?: map[string]string(name='groupBy'),
  incidentEventId?: string(name='incidentEventId'),
  incidentId?: string(name='incidentId'),
  lastTime?: long(name='lastTime'),
  recoverTime?: long(name='recoverTime'),
  resource?: map[string]string(name='resource'),
  status?: long(name='status'),
  time?: string(name='time'),
  title?: string(name='title'),
  userId?: string(name='userId'),
}

model IncidentMemberStruct {
  acknowledge?: {
    breakLevel?: string(name='breakLevel'),
    verifyTime?: long(name='verifyTime'),
  }(name='acknowledge'),
  contactId?: string(name='contactId'),
  contacts?: [ 
    {
      channel?: string(name='channel'),
      contactMask?: string(name='contactMask'),
    }
  ](name='contacts'),
  escalation?: {
    description?: string(name='description'),
    incidentEscalationId?: string(name='incidentEscalationId'),
    name?: string(name='name'),
    stageIndex?: string(name='stageIndex'),
    title?: string(name='title'),
  }(name='escalation'),
  incidentId?: string(name='incidentId'),
  incidentMemberId?: string(name='incidentMemberId'),
  scheduleGroup?: {
    contactId?: string(name='contactId'),
    name?: string(name='name'),
  }(name='scheduleGroup'),
  time?: long(name='time'),
  userId?: long(name='userId'),
}

model IncidentNoteStruct {
  content?: string(name='content'),
  format?: string(name='format'),
  incidentId?: string(name='incidentId'),
  noteId?: string(name='noteId'),
  operator?: {
    contact?: string(name='contact'),
    contactId?: string(name='contactId'),
    name?: string(name='name'),
    userId?: long(name='userId'),
  }(name='operator'),
  time?: long(name='time'),
  type?: string(name='type'),
}

model IncidentPlanCorporationStruct {
  channel?: string(name='channel'),
  robotId?: string(name='robotId'),
}

model IncidentPlanFieldPath {
  fieldAlias?: string(name='fieldAlias'),
  fieldPath?: [ string ](name='fieldPath'),
}

model IncidentPlanStruct {
  autoRecoverSeconds?: int32(name='autoRecoverSeconds'),
  closeExpire?: long(name='closeExpire'),
  corporation?: [
    IncidentPlanCorporationStruct
  ](name='corporation'),
  description?: string(name='description'),
  escalationId?: [ string ](name='escalationId'),
  gmtCreate?: long(name='gmtCreate'),
  gmtModified?: long(name='gmtModified'),
  groupBy?: [
    IncidentPlanFieldPath
  ](name='groupBy'),
  incidentPlanId?: string(name='incidentPlanId'),
  name?: string(name='name'),
  resourceFiled?: [
    IncidentPlanFieldPath
  ](name='resourceFiled'),
  status?: string(name='status'),
  userId?: long(name='userId'),
  workspace?: string(name='workspace'),
}

model IncidentResourceDetail {
  extraId?: string(name='extraId'),
  resourceId?: map[string]any(name='resourceId'),
  type?: string(name='type'),
}

model IncidentResourceStruct {
  description?: string(name='description'),
  incidentId?: string(name='incidentId'),
  incidentResourceId?: string(name='incidentResourceId'),
  resource?: IncidentResourceDetail(name='resource'),
  source?: string(name='source'),
  time?: long(name='time'),
  userId?: long(name='userId'),
}

model IncidentStruct {
  content?: string(name='content'),
  escalations?: [
    IncidentEscalationStruct
  ](name='escalations'),
  incidentId?: string(name='incidentId'),
  incidentPlan?: IncidentPlanStruct(name='incidentPlan'),
  resource?: IncidentResourceDetail(name='resource'),
  severity?: string(name='severity'),
  status?: string(name='status'),
  time?: long(name='time'),
  title?: string(name='title'),
  userId?: string(name='userId'),
}

model IncidentTimeline {
  childType?: string(name='childType'),
  content?: string(name='content'),
  incidentId?: string(name='incidentId'),
  incidentTimelineId?: string(name='incidentTimelineId'),
  time?: long(name='time'),
  timelineId?: string(name='timelineId'),
  title?: string(name='title'),
  type?: string(name='type'),
  userId?: string(name='userId'),
}

model MaintainWindowForModify {
  description?: string(name='description'),
  effectTimeRange?: {
    dayInWeek?: [ int32 ](name='dayInWeek'),
    endTimeInMinute?: int32(name='endTimeInMinute'),
    startTimeInMinute?: int32(name='startTimeInMinute'),
    timeZone?: string(name='timeZone'),
  }(name='effectTimeRange'),
  effective?: string(name='effective'),
  endTime?: string(name='endTime'),
  filterSetting?: FilterSetting(name='filterSetting'),
  maintainWindowName?: string(name='maintainWindowName', description='This parameter is required.'),
  startTime?: string(name='startTime'),
}

model MaintainWindowForView {
  createTime?: string(name='createTime'),
  description?: string(name='description'),
  effectTimeRange?: {
    dayInWeek?: [ int32 ](name='dayInWeek'),
    endTimeInMinute?: int32(name='endTimeInMinute'),
    startTimeInMinute?: int32(name='startTimeInMinute'),
    timeZone?: string(name='timeZone'),
  }(name='effectTimeRange'),
  effective?: string(name='effective'),
  enable?: boolean(name='enable'),
  endTime?: string(name='endTime'),
  filterSetting?: FilterSetting(name='filterSetting'),
  maintainWindowId?: string(name='maintainWindowId'),
  maintainWindowName?: string(name='maintainWindowName', description='This parameter is required.'),
  startTime?: string(name='startTime'),
  updateTime?: string(name='updateTime'),
  userId?: string(name='userId'),
  workspace?: string(name='workspace'),
}

model MergeContact {
  email?: string(name='email'),
  emailVerify?: boolean(name='emailVerify'),
  extend?: map[string]any(name='extend'),
  gmtCreate?: string(name='gmtCreate'),
  gmtModified?: string(name='gmtModified'),
  identifier?: string(name='identifier'),
  lang?: string(name='lang'),
  name?: string(name='name'),
  phone?: string(name='phone'),
  phoneCode?: string(name='phoneCode'),
  phoneVerify?: boolean(name='phoneVerify'),
  source?: string(name='source'),
}

model MergeContactGroup {
  contacts?: [ string ](name='contacts'),
  extend?: map[string]any(name='extend'),
  gmtCreate?: string(name='gmtCreate'),
  gmtModified?: string(name='gmtModified'),
  identifier?: string(name='identifier'),
  name?: string(name='name'),
  source?: string(name='source'),
}

model MergeRobot {
  createTime?: string(name='createTime'),
  extend?: {
    cardTemplate?: string(name='cardTemplate'),
    dailyNoc?: boolean(name='dailyNoc'),
    dailyNocTime?: string(name='dailyNocTime'),
    dingSignKey?: string(name='dingSignKey'),
    enableOutgoing?: boolean(name='enableOutgoing'),
    token?: string(name='token'),
  }(name='extend'),
  gmtModified?: string(name='gmtModified'),
  identifier?: string(name='identifier'),
  lang?: string(name='lang'),
  name?: string(name='name'),
  source?: string(name='source'),
  type?: string(name='type'),
  webhook?: string(name='webhook'),
}

model MergeWebhook {
  contentType?: string(name='contentType'),
  extend?: string(name='extend'),
  gmtCreate?: string(name='gmtCreate'),
  gmtModified?: map[string]any(name='gmtModified'),
  headers?: string(name='headers'),
  identifier?: string(name='identifier'),
  lang?: string(name='lang'),
  method?: string(name='method'),
  name?: string(name='name'),
  source?: string(name='source'),
  type?: string(name='type'),
  webhook?: string(name='webhook'),
}

model NotifyStrategyForModify {
  customTemplateEntries?: [ 
    {
      targetType?: string(name='targetType', description='This parameter is required.'),
      templateUuid?: string(name='templateUuid', description='This parameter is required.'),
    }
  ](name='customTemplateEntries'),
  description?: string(name='description'),
  groupingSetting?: {
    groupingKeys?: [ string ](name='groupingKeys'),
    periodMin?: int32(name='periodMin'),
    silenceSec?: int32(name='silenceSec'),
    times?: int32(name='times'),
  }(name='groupingSetting', description='This parameter is required.'),
  ignoreRestoredNotification?: boolean(name='ignoreRestoredNotification'),
  notifyStrategyName?: string(name='notifyStrategyName', description='This parameter is required.'),
  routes?: [ 
    {
      channels?: [ 
        {
          channelType?: string(name='channelType', description='This parameter is required.'),
          enabledSubChannels?: [ string ](name='enabledSubChannels'),
          receivers?: [ string ](name='receivers', description='This parameter is required.'),
        }
      ](name='channels'),
      effectTimeRange?: {
        dayInWeek?: [ int32 ](name='dayInWeek'),
        endTimeInMinute?: int32(name='endTimeInMinute'),
        startTimeInMinute?: int32(name='startTimeInMinute'),
        timeZone?: string(name='timeZone'),
      }(name='effectTimeRange'),
      filterSetting?: FilterSetting(name='filterSetting'),
      severities?: [ string ](name='severities'),
    }
  ](name='routes', description='This parameter is required.'),
}

model NotifyStrategyForView {
  createTime?: string(name='createTime'),
  customTemplateEntries?: [ 
    {
      targetType?: string(name='targetType', description='This parameter is required.'),
      templateUuid?: string(name='templateUuid', description='This parameter is required.'),
    }
  ](name='customTemplateEntries'),
  description?: string(name='description'),
  enable?: boolean(name='enable'),
  groupingSetting?: {
    groupingKeys?: [ string ](name='groupingKeys'),
    periodMin?: int32(name='periodMin'),
    silenceSec?: int32(name='silenceSec'),
    times?: int32(name='times'),
  }(name='groupingSetting', description='This parameter is required.'),
  ignoreRestoredNotification?: boolean(name='ignoreRestoredNotification'),
  notifyStrategyId?: string(name='notifyStrategyId'),
  notifyStrategyName?: string(name='notifyStrategyName', description='This parameter is required.'),
  routes?: [ 
    {
      channels?: [ 
        {
          channelType?: string(name='channelType', description='This parameter is required.'),
          enabledSubChannels?: [ string ](name='enabledSubChannels'),
          receivers?: [ string ](name='receivers', description='This parameter is required.'),
        }
      ](name='channels'),
      effectTimeRange?: {
        dayInWeek?: [ int32 ](name='dayInWeek'),
        endTimeInMinute?: int32(name='endTimeInMinute'),
        startTimeInMinute?: int32(name='startTimeInMinute'),
        timeZone?: string(name='timeZone'),
      }(name='effectTimeRange'),
      filterSetting?: FilterSetting(name='filterSetting'),
      severities?: [ string ](name='severities'),
    }
  ](name='routes', description='This parameter is required.'),
  updateTime?: string(name='updateTime'),
  userId?: string(name='userId'),
  workspace?: string(name='workspace'),
}

model PrometheusManagedInstance {
  createTime?: string(name='createTime'),
  instanceType?: string(name='instanceType'),
  prometheusInstanceId?: string(name='prometheusInstanceId'),
  prometheusInstanceName?: string(name='prometheusInstanceName'),
  regionId?: string(name='regionId'),
  status?: string(name='status'),
  workspace?: string(name='workspace'),
}

model RumDnsResponse {
  domain?: string(name='domain'),
  message?: string(name='message'),
  result?: boolean(name='result'),
}

model SubscriptionForModify {
  description?: string(name='description'),
  filterSetting?: FilterSetting(name='filterSetting'),
  notifyStrategyId?: string(name='notifyStrategyId'),
  pushingSetting?: {
    alertActionIds?: [ string ](name='alertActionIds'),
    responsePlanId?: string(name='responsePlanId'),
    restoreActionIds?: [ string ](name='restoreActionIds'),
    templateUuid?: string(name='templateUuid'),
  }(name='pushingSetting'),
  subscriptionName?: string(name='subscriptionName', description='This parameter is required.'),
}

model SubscriptionForView {
  createTime?: string(name='createTime'),
  description?: string(name='description'),
  enable?: boolean(name='enable'),
  filterSetting?: FilterSetting(name='filterSetting'),
  notifyStrategyId?: string(name='notifyStrategyId'),
  pushingSetting?: {
    alertActionIds?: [ string ](name='alertActionIds'),
    responsePlanId?: string(name='responsePlanId'),
    restoreActionIds?: [ string ](name='restoreActionIds'),
    templateUuid?: string(name='templateUuid'),
  }(name='pushingSetting'),
  subscriptionId?: string(name='subscriptionId'),
  subscriptionName?: string(name='subscriptionName', description='This parameter is required.'),
  updateTime?: string(name='updateTime'),
  userId?: string(name='userId'),
  workspace?: string(name='workspace'),
}

model TransformAction {
  filterSetting?: FilterSetting(name='filterSetting'),
  labelKey?: string(name='labelKey'),
  mapping?: map[string]string(name='mapping'),
  regExp?: string(name='regExp'),
  source?: string(name='source'),
  target?: string(name='target'),
  type?: string(name='type'),
  value?: string(name='value'),
  variable?: string(name='variable'),
}

model TransformerForModify {
  actions?: [
    TransformAction
  ](name='actions'),
  description?: string(name='description'),
  filterSetting?: FilterSetting(name='filterSetting'),
  quitAfterMatch?: boolean(name='quitAfterMatch'),
  sortId?: int32(name='sortId'),
  transformerName?: string(name='transformerName', description='This parameter is required.'),
}

model TransformerForView {
  actions?: [
    TransformAction
  ](name='actions'),
  createTime?: string(name='createTime'),
  description?: string(name='description'),
  enable?: boolean(name='enable'),
  filterSetting?: FilterSetting(name='filterSetting'),
  quitAfterMatch?: boolean(name='quitAfterMatch'),
  sortId?: int32(name='sortId'),
  transformerId?: string(name='transformerId'),
  transformerName?: string(name='transformerName', description='This parameter is required.'),
  updateTime?: string(name='updateTime'),
  userId?: string(name='userId'),
  workspace?: string(name='workspace'),
}

model CreateAddonReleaseRequest {
  addonName?: string(name='addonName', description='The Addon name of the component that needs to be monitored.

This parameter is required.', example='cs-gpu'),
  aliyunLang?: string(name='aliyunLang', description='The language type of the component.', example='zh'),
  dryRun?: boolean(name='dryRun', description='Whether it is a dry run, default is false.', example='false'),
  entityRules?: EntityDiscoverRule(name='entityRules', description='Field rules'),
  envType?: string(name='envType', description='Environment type. If the Policy type is CS and ECS, use accordingly; otherwise, it is unified as Cloud.', example='CS'),
  parentAddonReleaseId?: string(name='parentAddonReleaseId', description='Parent AddonReleaseId.', example='policy-xxxxxxxxxxx'),
  releaseName?: string(name='releaseName', description='The plugin name after access. If not specified, a default rule name will be generated.', example='test-gpu-integration-name'),
  values?: string(name='values', description='Input metadata.', example='{"install":{"mode":"auto-install","listenPort":"9400"},"discoverMode":"instances","discover":{"instances":"worker-k8s-for-cs-c126d87c76218487e83ab322017f11b44"},"scrapeInterval":"15","enableSecuritecs-nodeyGroupInjection":"true","metricTags":""}'),
  version?: string(name='version', description='The version of the Addon component that needs to be monitored.

This parameter is required.', example='0.0.2'),
  workspace?: string(name='workspace', description='The workspace name for installing the component resources.', example='default'),
}

model CreateAddonReleaseResponseBody = {
  release?: {
    addonName?: string(name='addonName', description='The Addon name of the component being monitored.', example='cs-gpu'),
    alertRuleCount?: long(name='alertRuleCount', description='Number of alert groups.', example='6'),
    conditions?: [ 
      {
        firstTransitionTime?: string(name='firstTransitionTime', description='First transition time.', example='2024-11-04T16:10:22+08:00'),
        lastTransitionTime?: string(name='lastTransitionTime', description='Last transition time.', example='2024-11-04T16:10:22+08:00'),
        message?: string(name='message', description='Detailed information.', example='The addon loaded successfully'),
        status?: string(name='status', description='Phase status.', example='{\\\\"phase\\\\": \\\\"Created\\\\", \\\\"executionDetails\\\\": [], \\\\"invocations\\\\": [], \\\\"latestExecError\\\\": {\\\\"message\\\\": \\\\"\\\\", \\\\"code\\\\": \\\\"\\\\", \\\\"requestId\\\\": \\\\"\\\\", \\\\"extraInfo\\\\": \\\\"\\\\", \\\\"title\\\\": \\\\"\\\\"}}'),
        type?: string(name='type', description='Phase type.', example='Loaded'),
      }
    ](name='conditions', description='Component installation phase information.'),
    config?: string(name='config', description='Component configuration.', example='{"install":{"mode":"auto-install","listenPort":"9400"},"discoverMode":"instances","discover":{"instances":"worker-k8s-for-cs-c126d87c76218487e83ab322017f11b44"},"scrapeInterval":"15","enableSecuritecs-nodeyGroupInjection":"true","metricTags":""}'),
    createTime?: string(name='createTime', description='Connection time.', example='2024-11-05T15:21:30+08:00'),
    dashboardCount?: long(name='dashboardCount', description='Number of dashboards.', example='3'),
    entityRules?: EntityGroupBase(name='entityRules', description='Entity details.'),
    envType?: string(name='envType', description='Environment type.', example='CS'),
    environmentId?: string(name='environmentId', description='Environment ID.', example='policy-xxxxxxxxxxx'),
    exporterCount?: long(name='exporterCount', description='Number of plugins.', example='2'),
    haveConfig?: boolean(name='haveConfig', description='Whether it has configuration.', example='true'),
    installUserId?: string(name='installUserId', description='ID of the user who installed it.', example='1654218965xxxxxx'),
    language?: string(name='language', description='Language.', example='zh'),
    managed?: boolean(name='managed', description='Whether it is a managed component.', example='true'),
    parentAddonReleaseId?: string(name='parentAddonReleaseId', description='Parent AddonReleaseId.', example='policy-xxxxxxxxxxx'),
    policyId?: string(name='policyId', description='Policy environment ID.', example='policy-xxxxxxxxxx'),
    regionId?: string(name='regionId', description='Region ID.', example='cn-hangzhou'),
    releaseId?: string(name='releaseId', description='ReleaseID after installation.', example='2e898e60-5e6a-46d1-a994-xxxxxxxxxx'),
    releaseName?: string(name='releaseName', description='Name of the Release.', example='test-gpu-integration-name'),
    scene?: string(name='scene', description='Component scenario.', example='1'),
    status?: string(name='status', description='Component status.', example='200'),
    updateTime?: string(name='updateTime', description='Update time.', example='2024-09-13T02:21:02Z'),
    userId?: string(name='userId', description='ID of the owner user.', example='165421896xxxxxx'),
    version?: string(name='version', description='Component version.', example='1.0.0'),
    workspace?: string(name='workspace', description='Workspace.', example='default'),
  }(name='release', description='Accessed component information.'),
  requestId?: string(name='requestId', description='Request ID.', example='0CEC5375-C554-562B-A65F-9A629907C1F0'),
}

model CreateAddonReleaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAddonReleaseResponseBody(name='body'),
}

/**
 * @summary Install the access component, representing a single access attempt
 *
 * @description Used to create a site monitoring task
 *
 * @param request CreateAddonReleaseRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAddonReleaseResponse
 */
async function createAddonReleaseWithOptions(policyId: string, request: CreateAddonReleaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAddonReleaseResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.addonName)) {
    body['addonName'] = request.addonName;
  }
  if (!Util.isUnset(request.aliyunLang)) {
    body['aliyunLang'] = request.aliyunLang;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['dryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.entityRules)) {
    body['entityRules'] = request.entityRules;
  }
  if (!Util.isUnset(request.envType)) {
    body['envType'] = request.envType;
  }
  if (!Util.isUnset(request.parentAddonReleaseId)) {
    body['parentAddonReleaseId'] = request.parentAddonReleaseId;
  }
  if (!Util.isUnset(request.releaseName)) {
    body['releaseName'] = request.releaseName;
  }
  if (!Util.isUnset(request.values)) {
    body['values'] = request.values;
  }
  if (!Util.isUnset(request.version)) {
    body['version'] = request.version;
  }
  if (!Util.isUnset(request.workspace)) {
    body['workspace'] = request.workspace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAddonRelease',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/integration-policies/${OpenApiUtil.getEncodeParam(policyId)}/addon-releases`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Install the access component, representing a single access attempt
 *
 * @description Used to create a site monitoring task
 *
 * @param request CreateAddonReleaseRequest
 * @return CreateAddonReleaseResponse
 */
async function createAddonRelease(policyId: string, request: CreateAddonReleaseRequest): CreateAddonReleaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAddonReleaseWithOptions(policyId, request, headers, runtime);
}

model CreateAggTaskGroupRequest {
  aggTaskGroupConfig?: string(name='aggTaskGroupConfig', description='Aggregation task group configuration.
Currently, only the “RecordingRuleYaml” format is supported, which must comply with the format requirements of open-source Prometheus RecordingRules.

This parameter is required.', example='groups:
- name: "node.rules"
  interval: "60s"
  rules:
  - record: "node_namespace_pod:kube_pod_info:"
    expr: "max(label_replace(kube_pod_info{job=\\\\"kubernetes-pods-kube-state-metrics\\\\"\\\\
      }, \\\\"pod\\\\", \\\\"$1\\\\", \\\\"pod\\\\", \\\\"(.*)\\\\")) by (node, namespace, pod, cluster)"'),
  aggTaskGroupConfigType?: string(name='aggTaskGroupConfigType', description='Aggregation task group configuration type, default is “RecordingRuleYaml” (open-source Prometheus RecordingRule format).', example='RecordingRuleYaml'),
  aggTaskGroupName?: string(name='aggTaskGroupName', description='Aggregation task group name.

This parameter is required.', example='test-group'),
  cronExpr?: string(name='cronExpr', description='When the scheduling mode is selected as “Cron”, this is the specific scheduling expression. For example, “0/1 * * * *” means starting from 0 minutes and scheduling every 1 minute.', example='0/1 * * * *'),
  delay?: int32(name='delay', description='Fixed delay time for scheduling, in seconds, default is 30.', example='30'),
  description?: string(name='description', description='Description of the aggregation task group.', example='desc'),
  fromTime?: long(name='fromTime', description='The second-level timestamp corresponding to the start time of the schedule.', example='1724996015'),
  maxRetries?: int32(name='maxRetries', description='Maximum number of retries for executing the aggregation task, default is 20.', example='20'),
  maxRunTimeInSeconds?: int32(name='maxRunTimeInSeconds', description='Maximum retry time for executing the aggregation task, in seconds, default is 600.', example='600'),
  precheckString?: string(name='precheckString', description='Pre-check configuration, no configuration by default. The input string needs to be correctly parsed as JSON.', example='{"policy":"skip","prometheusId":"xxx","query":"scalar(sum(count_over_time(up{job=\\\\"_arms/kubelet/cadvisor\\\\"}[15s])) / 21)","threshold":0.5,"timeout":15,"type":"promql"}'),
  scheduleMode?: string(name='scheduleMode', description='Scheduling mode, either “Cron” or “FixedRate”, default is “FixedRate”.', example='FixedRate'),
  scheduleTimeExpr?: string(name='scheduleTimeExpr', description='Scheduling time expression, recommended “@s” or “@m”, indicating the alignment granularity of the scheduling time window, default is “@m”.', example='@m'),
  status?: string(name='status', description='Status of the aggregation task group, either “Running” or “Stopped”. Default is Running.', example='Running'),
  tags?: [ 
    {
      key?: string(name='key', description='Key of the resource group tag.', example='key1'),
      value?: string(name='value', description='Value of the resource group tag.', example='value1'),
    }
  ](name='tags', description='Resource group tags.'),
  targetPrometheusId?: string(name='targetPrometheusId', description='The target Prometheus instance ID of the aggregation task group.

This parameter is required.', example='rw-pq4apob9jm'),
  toTime?: long(name='toTime', description='The second-level timestamp corresponding to the end time of the schedule, 0 indicates that the scheduling does not stop.', example='0'),
  overrideIfExists?: boolean(name='overrideIfExists', description='Whether to overwrite and update if a resource with the same name exists when creating an aggregation task group.', example='true'),
}

model CreateAggTaskGroupResponseBody = {
  aggTaskGroupConfigHash?: string(name='aggTaskGroupConfigHash', description='Summary of the aggregation task group configuration.', example='a54136014dc386a92c83a6ef1e97ff22'),
  aggTaskGroupId?: string(name='aggTaskGroupId', description='Aggregation task group ID.', example='aggTaskGroup-f4b8e50525cf41c894488c0c71ec483f'),
  aggTaskGroupName?: string(name='aggTaskGroupName', description='Aggregation task group name.', example='pipeline-aggtask-group'),
  requestId?: string(name='requestId', description='Request ID.', example='16C0A6D6-C3E7-511D-A60B-A87FD85F5BA7'),
  sourcePrometheusId?: string(name='sourcePrometheusId', description='Source Prometheus instance ID of the aggregation task group.', example='rw-ecc04af14729b1a16e40a0d10068'),
  status?: string(name='status', description='Current status of the aggregation task group.', example='Pending2Running'),
}

model CreateAggTaskGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAggTaskGroupResponseBody(name='body'),
}

/**
 * @summary Create Aggregation Task Group
 *
 * @param request CreateAggTaskGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAggTaskGroupResponse
 */
async function createAggTaskGroupWithOptions(instanceId: string, request: CreateAggTaskGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAggTaskGroupResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.overrideIfExists)) {
    query['overrideIfExists'] = request.overrideIfExists;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.aggTaskGroupConfig)) {
    body['aggTaskGroupConfig'] = request.aggTaskGroupConfig;
  }
  if (!Util.isUnset(request.aggTaskGroupConfigType)) {
    body['aggTaskGroupConfigType'] = request.aggTaskGroupConfigType;
  }
  if (!Util.isUnset(request.aggTaskGroupName)) {
    body['aggTaskGroupName'] = request.aggTaskGroupName;
  }
  if (!Util.isUnset(request.cronExpr)) {
    body['cronExpr'] = request.cronExpr;
  }
  if (!Util.isUnset(request.delay)) {
    body['delay'] = request.delay;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.fromTime)) {
    body['fromTime'] = request.fromTime;
  }
  if (!Util.isUnset(request.maxRetries)) {
    body['maxRetries'] = request.maxRetries;
  }
  if (!Util.isUnset(request.maxRunTimeInSeconds)) {
    body['maxRunTimeInSeconds'] = request.maxRunTimeInSeconds;
  }
  if (!Util.isUnset(request.precheckString)) {
    body['precheckString'] = request.precheckString;
  }
  if (!Util.isUnset(request.scheduleMode)) {
    body['scheduleMode'] = request.scheduleMode;
  }
  if (!Util.isUnset(request.scheduleTimeExpr)) {
    body['scheduleTimeExpr'] = request.scheduleTimeExpr;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.targetPrometheusId)) {
    body['targetPrometheusId'] = request.targetPrometheusId;
  }
  if (!Util.isUnset(request.toTime)) {
    body['toTime'] = request.toTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAggTaskGroup',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/prometheus-instances/${OpenApiUtil.getEncodeParam(instanceId)}/agg-task-groups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create Aggregation Task Group
 *
 * @param request CreateAggTaskGroupRequest
 * @return CreateAggTaskGroupResponse
 */
async function createAggTaskGroup(instanceId: string, request: CreateAggTaskGroupRequest): CreateAggTaskGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAggTaskGroupWithOptions(instanceId, request, headers, runtime);
}

model CreateEntityStoreResponseBody = {
  requestId?: string(name='requestId', description='request ID', example='264C3E89-XXXX-XXXX-XXXX-CE9C2196C7DC'),
  workspaceName?: string(name='workspaceName', description='workspace name', example='workspace-test-001'),
}

model CreateEntityStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEntityStoreResponseBody(name='body'),
}

/**
 * @summary Create storage related to EntityStore
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEntityStoreResponse
 */
async function createEntityStoreWithOptions(workspaceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): CreateEntityStoreResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CreateEntityStore',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspaceName)}/entitystore`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create storage related to EntityStore
 *
 * @return CreateEntityStoreResponse
 */
async function createEntityStore(workspaceName: string): CreateEntityStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createEntityStoreWithOptions(workspaceName, headers, runtime);
}

model CreateIntegrationPolicyRequest {
  entityGroup?: {
    clusterEntityType?: string(name='clusterEntityType', description='Cluster entity type, such as acs.ack.cluster/acs.one.cluster/acs.asi.cluster or others.', example='acs.ack.cluster'),
    clusterId?: string(name='clusterId', description='Cluster ID.', example='na61prod3-na61cloudhdfsssd'),
    disablePolicyShare?: boolean(name='disablePolicyShare', description='Whether to disable unique binding of the Policy. If enabled, multiple Policies can be created for a single container cluster.', example='ture'),
    entityGroupId?: string(name='entityGroupId', description='Entity group ID.', example='eg-b79f65d11fb94e779867cf937c3a3002'),
    entityUserId?: string(name='entityUserId'),
    vpcId?: string(name='vpcId', description='VPC (Virtual Private Cloud) ID.', example='vpc-bp18fgg3ffxa9czna40xt'),
  }(name='entityGroup', description='Entity group for creating the policy. Policies can be quickly created using the entity group, and `clusterId` and `vpcId` are independent of each other.'),
  policyName?: string(name='policyName', description='Policy name', example='prod-database'),
  policyType?: string(name='policyType', description='Policy type: CS/ECS/Cloud

This parameter is required.', example='CS'),
  resourceGroupId?: string(name='resourceGroupId', description='Resource group ID.', example='rg-aekz2km4kmhtbii'),
  tags?: [ 
    {
      key?: string(name='key', description='Tag `key` value.', example='use'),
      value?: string(name='value', description='Tag `value` value.', example='database'),
    }
  ](name='tags', description='Resource tags.'),
  workspace?: string(name='workspace', description='Workspace.', example='prometheus'),
}

model CreateIntegrationPolicyResponseBody = {
  created?: boolean(name='created', description='Whether it was created.', example='true'),
  policy?: {
    entityGroupId?: string(name='entityGroupId', description='Entity group ID.', example='eg-b79f65d11fb94e779867cf937c3a3002'),
    policyId?: string(name='policyId', description='Policy ID.', example='policy-14c8e9a29b0a46da843f8781471062ff'),
    policyName?: string(name='policyName', description='Policy name.', example='metrics-inner-manage'),
    policyType?: string(name='policyType', description='Policy type.', example='CS'),
    regionId?: string(name='regionId', description='Region ID.', example='cn-heyuan'),
    userId?: string(name='userId', description='User ID.', example='u1234567'),
    workspace?: string(name='workspace', description='The workspace where the Policy resides.', example='prometheus'),
  }(name='policy', description='Uploaded policy.'),
  requestId?: string(name='requestId', description='Request ID.', example='CD8BA7D6-995D-578D-9941-78B0FECD14B5'),
}

model CreateIntegrationPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateIntegrationPolicyResponseBody(name='body'),
}

/**
 * @summary Create Access Center Policy
 *
 * @description This interface is used to support users in creating event integration.
 *
 * @param request CreateIntegrationPolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIntegrationPolicyResponse
 */
async function createIntegrationPolicyWithOptions(request: CreateIntegrationPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIntegrationPolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.entityGroup)) {
    body['entityGroup'] = request.entityGroup;
  }
  if (!Util.isUnset(request.policyName)) {
    body['policyName'] = request.policyName;
  }
  if (!Util.isUnset(request.policyType)) {
    body['policyType'] = request.policyType;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.workspace)) {
    body['workspace'] = request.workspace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIntegrationPolicy',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/integration-policies`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create Access Center Policy
 *
 * @description This interface is used to support users in creating event integration.
 *
 * @param request CreateIntegrationPolicyRequest
 * @return CreateIntegrationPolicyResponse
 */
async function createIntegrationPolicy(request: CreateIntegrationPolicyRequest): CreateIntegrationPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIntegrationPolicyWithOptions(request, headers, runtime);
}

model CreatePrometheusInstanceRequest {
  archiveDuration?: int32(name='archiveDuration', description='The number of days to automatically archive and save after the storage expires, 0 means no archiving. The range of archiving days is as follows:
* V1: 60~365 days.
* V2: 60~3650 days (3650 indicates permanent storage).', example='60', nullable=true),
  authFreeReadPolicy?: string(name='authFreeReadPolicy', description='Password-free read policy (supports IP segments and VpcId).', example='{
  "SourceIp": [
    "192.168.1.0/24",
    "172.168.2.22"
  ],
  "SourceVpc": [
    "vpc-xx1",
    "vpc-xx2"
  ]
}'),
  authFreeWritePolicy?: string(name='authFreeWritePolicy', description='Password-free write policy.', example='{
  "SourceIp": [
    "192.168.1.0/24",
    "172.168.2.22"
  ],
  "SourceVpc": [
    "vpc-xx1",
    "vpc-xx2"
  ]
}'),
  enableAuthFreeRead?: boolean(name='enableAuthFreeRead', description='Whether to enable password-free read (only supported in V2 version).', example='true'),
  enableAuthFreeWrite?: boolean(name='enableAuthFreeWrite', description='Whether to enable password-free write (only supported in V2 version).', example='true'),
  enableAuthToken?: boolean(name='enableAuthToken', description='Whether to enable authorization Token (only supported in V1 version).', example='true'),
  paymentType?: string(name='paymentType', description='Billing method:
* POSTPAY: Postpaid by metric reporting volume.
* POSTPAY_GB: Postpaid by metric write volume.
Note, if left blank, the user\\\\"s default billing method configuration will be used. If the user has not configured a default, the system defaults to billing by metric reporting volume.', example='POSTPAY'),
  prometheusInstanceName?: string(name='prometheusInstanceName', description='Instance name.

This parameter is required.', example='name1'),
  status?: string(name='status', description='Instance status.', example='Running'),
  storageDuration?: int32(name='storageDuration', description='Storage duration (days):
* By write volume: 90, 180.
* By metric reporting volume: 15, 30, 60, 90, 180.', example='90'),
  tags?: [ 
    {
      key?: string(name='key', description='Tag key.', example='key1'),
      value?: string(name='value', description='Tag value.', example='110109200001214284'),
    }
  ](name='tags', description='Tag values.'),
  workspace?: string(name='workspace', description='Belonging workspace, default value: default-cms-{userId}-{regionId}.', example='wokspace1'),
}

model CreatePrometheusInstanceResponseBody = {
  prometheusInstanceId?: string(name='prometheusInstanceId', description='Instance ID.', example='rw-abc123'),
  requestId?: string(name='requestId', description='ID of the request.', example='264C3E89-BE6E-5F82-A484-CE9C2196C7DC'),
}

model CreatePrometheusInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePrometheusInstanceResponseBody(name='body'),
}

/**
 * @summary Create a Prometheus monitoring instance
 *
 * @param request CreatePrometheusInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePrometheusInstanceResponse
 */
async function createPrometheusInstanceWithOptions(request: CreatePrometheusInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePrometheusInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.archiveDuration)) {
    body['archiveDuration'] = request.archiveDuration;
  }
  if (!Util.isUnset(request.authFreeReadPolicy)) {
    body['authFreeReadPolicy'] = request.authFreeReadPolicy;
  }
  if (!Util.isUnset(request.authFreeWritePolicy)) {
    body['authFreeWritePolicy'] = request.authFreeWritePolicy;
  }
  if (!Util.isUnset(request.enableAuthFreeRead)) {
    body['enableAuthFreeRead'] = request.enableAuthFreeRead;
  }
  if (!Util.isUnset(request.enableAuthFreeWrite)) {
    body['enableAuthFreeWrite'] = request.enableAuthFreeWrite;
  }
  if (!Util.isUnset(request.enableAuthToken)) {
    body['enableAuthToken'] = request.enableAuthToken;
  }
  if (!Util.isUnset(request.paymentType)) {
    body['paymentType'] = request.paymentType;
  }
  if (!Util.isUnset(request.prometheusInstanceName)) {
    body['prometheusInstanceName'] = request.prometheusInstanceName;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.storageDuration)) {
    body['storageDuration'] = request.storageDuration;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.workspace)) {
    body['workspace'] = request.workspace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePrometheusInstance',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/prometheus-instances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create a Prometheus monitoring instance
 *
 * @param request CreatePrometheusInstanceRequest
 * @return CreatePrometheusInstanceResponse
 */
async function createPrometheusInstance(request: CreatePrometheusInstanceRequest): CreatePrometheusInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPrometheusInstanceWithOptions(request, headers, runtime);
}

model CreatePrometheusViewRequest {
  authFreeReadPolicy?: string(name='authFreeReadPolicy', description='Not enabled yet', example='{
  "SourceIp": [
    "192.168.1.0/24",
    "172.168.2.22"
  ],
  "SourceVpc": [
    "vpc-xx1",
    "vpc-xx2"
  ]
}'),
  enableAuthFreeRead?: boolean(name='enableAuthFreeRead', description='Whether to support password-free read', example='true'),
  enableAuthToken?: boolean(name='enableAuthToken', description='Whether to support authToken', example='true'),
  prometheusInstances?: [ 
    {
      prometheusInstanceId?: string(name='prometheusInstanceId', description='Instance ID.', example='arms-1d581fac20a462dcde743d9628'),
      regionId?: string(name='regionId', description='Region ID.', example='cn-wulanchabu'),
      userId?: string(name='userId', description='User ID.', example='167271234567890'),
    }
  ](name='prometheusInstances', description='List of Prometheus instances.

This parameter is required.'),
  prometheusViewName?: string(name='prometheusViewName', description='Prometheus view name.

This parameter is required.', example='test-prom-view-name'),
  resourceGroupId?: string(name='resourceGroupId', description='Resource group ID.', example='rg-acfm3gn5i6bigbi'),
  status?: string(name='status', description='Not enabled yet.', example='null'),
  tags?: [ 
    {
      key?: string(name='key', description='Tag key.', example='test-key'),
      value?: string(name='value', description='Tag value.', example='test-value'),
    }
  ](name='tags', description='The operation to be performed.'),
  version?: string(name='version', description='- V1: Old version
- V2: New version

This parameter is required.', example='V2'),
  workspace?: string(name='workspace', description='Default value: default-cms-{userId}-{regionId}', example='cms-monitor-test-aysls-pub-cn-zhangjiakou-spe-monitor'),
}

model CreatePrometheusViewResponseBody = {
  prometheusViewId?: string(name='prometheusViewId', description='Prometheus view ID.', example='cd5237f7dbd574cf9bbd648ff9efb16cd'),
  requestId?: string(name='requestId', description='ID of the request', example='8FDE2569-626B-5176-9844-28877A*****'),
}

model CreatePrometheusViewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePrometheusViewResponseBody(name='body'),
}

/**
 * @summary Create Prometheus View
 *
 * @description Used to create a site monitoring task
 *
 * @param request CreatePrometheusViewRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePrometheusViewResponse
 */
async function createPrometheusViewWithOptions(request: CreatePrometheusViewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePrometheusViewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.authFreeReadPolicy)) {
    body['authFreeReadPolicy'] = request.authFreeReadPolicy;
  }
  if (!Util.isUnset(request.enableAuthFreeRead)) {
    body['enableAuthFreeRead'] = request.enableAuthFreeRead;
  }
  if (!Util.isUnset(request.enableAuthToken)) {
    body['enableAuthToken'] = request.enableAuthToken;
  }
  if (!Util.isUnset(request.prometheusInstances)) {
    body['prometheusInstances'] = request.prometheusInstances;
  }
  if (!Util.isUnset(request.prometheusViewName)) {
    body['prometheusViewName'] = request.prometheusViewName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.version)) {
    body['version'] = request.version;
  }
  if (!Util.isUnset(request.workspace)) {
    body['workspace'] = request.workspace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePrometheusView',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/prometheus-views`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create Prometheus View
 *
 * @description Used to create a site monitoring task
 *
 * @param request CreatePrometheusViewRequest
 * @return CreatePrometheusViewResponse
 */
async function createPrometheusView(request: CreatePrometheusViewRequest): CreatePrometheusViewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPrometheusViewWithOptions(request, headers, runtime);
}

model CreatePrometheusVirtualInstanceRequest {
  namespace?: string(name='namespace', description='Each cloud product can only create one virtual instance in each region.

This parameter is required.', example='cms_prometheus'),
}

model CreatePrometheusVirtualInstanceResponseBody = {
  instance?: {
    createdAt?: string(name='createdAt', description='Creation time', example='1751520976660'),
    httpApiUrl?: string(name='httpApiUrl', description='HTTP API query address', example='http://xxxxxxx'),
    instanceId?: string(name='instanceId', description='Region ID', example='rw-e815960b4c9ebc5c3d89790c7e82'),
    namespace?: string(name='namespace', description='Cloud product', example='ack-csi-fuse'),
    regionId?: string(name='regionId', description='User ID', example='cn-zhengzhou-jva'),
    userId?: string(name='userId', description='User ID', example='167212345678'),
  }(name='instance', description='Instance ID'),
  requestId?: string(name='requestId', description='ID of the request', example='0B9377D9-C56B-5C2E-A8A4-************'),
}

model CreatePrometheusVirtualInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePrometheusVirtualInstanceResponseBody(name='body'),
}

/**
 * @summary Create Prometheus Monitoring Instance
 *
 * @description Create a Prometheus monitoring virtual instance.
 *
 * @param request CreatePrometheusVirtualInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePrometheusVirtualInstanceResponse
 */
async function createPrometheusVirtualInstanceWithOptions(request: CreatePrometheusVirtualInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePrometheusVirtualInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.namespace)) {
    body['namespace'] = request.namespace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePrometheusVirtualInstance',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/virtual-instances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create Prometheus Monitoring Instance
 *
 * @description Create a Prometheus monitoring virtual instance.
 *
 * @param request CreatePrometheusVirtualInstanceRequest
 * @return CreatePrometheusVirtualInstanceResponse
 */
async function createPrometheusVirtualInstance(request: CreatePrometheusVirtualInstanceRequest): CreatePrometheusVirtualInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPrometheusVirtualInstanceWithOptions(request, headers, runtime);
}

model CreateServiceRequest {
  attributes?: string(name='attributes', description='Extended attributes.', example='{"language":"java"}'),
  description?: string(name='description', description='Service description, only valid when `serviceType=RUM`.', example='mag测试应用'),
  displayName?: string(name='displayName', description='Display name, only valid when `serviceType=RUM`.', example='mag测试应用'),
  pid?: string(name='pid', description='Application ID, generally not required to be specified.', example='bx3udsi5ie@ed2ba6beebdb6de'),
  serviceName?: string(name='serviceName', description='Service name

This parameter is required.', example='mag_test'),
  serviceStatus?: string(name='serviceStatus', description='Service status, not required for service creation.', example='Created'),
  serviceType?: string(name='serviceType', description='Service type

This parameter is required.', example='TRACE'),
}

model CreateServiceResponseBody = {
  pid?: string(name='pid', description='Historical compatible ARMS application ID', example='cwzxvuc6uo@d60088ad4797d26'),
  requestId?: string(name='requestId', description='Request ID.', example='3A2FA9E9-9CF1-5CB1-A808-52828F14310D'),
  serviceId?: string(name='serviceId', description='Service ID', example='cwzxvuc6uo@4bc6b15ad81f166174ffb'),
}

model CreateServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateServiceResponseBody(name='body'),
}

/**
 * @summary Create Service
 *
 * @param request CreateServiceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateServiceResponse
 */
async function createServiceWithOptions(workspace: string, request: CreateServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.attributes)) {
    body['attributes'] = request.attributes;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.pid)) {
    body['pid'] = request.pid;
  }
  if (!Util.isUnset(request.serviceName)) {
    body['serviceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.serviceStatus)) {
    body['serviceStatus'] = request.serviceStatus;
  }
  if (!Util.isUnset(request.serviceType)) {
    body['serviceType'] = request.serviceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateService',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspace)}/service`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create Service
 *
 * @param request CreateServiceRequest
 * @return CreateServiceResponse
 */
async function createService(workspace: string, request: CreateServiceRequest): CreateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceWithOptions(workspace, request, headers, runtime);
}

model CreateTicketRequest {
  accessTokenExpirationTime?: long(name='accessTokenExpirationTime', description='- Access token expiration time (in seconds), which is the expiration time for the user to access the page interface. The default value is 86400 seconds (one day), and the range of values is from 0 to 86400 seconds (one day).
- The access token expiration time is the minimum value between `accessTokenExpirationTime` and `expirationTime`.
- If called through STS, the access token expiration time (i.e., the time during which the user can access the page interface) is the minimum value among `accessTokenExpirationTime`, `expirationTime`, and the STS expiration time.', example='600'),
  expirationTime?: long(name='expirationTime', description='- Expiration time (in seconds), which is the expiration time for the embedded page URL. The default value is 86400 seconds (one day), and the range of values is from 0 to 2592000 seconds (30 days).', example='86400'),
}

model CreateTicketResponseBody = {
  ticket?: string(name='ticket', description='免登录票据。', example='eyJ***************.eyJ******************.KUT****************'),
}

model CreateTicketResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTicketResponseBody(name='body'),
}

/**
 * @summary Create Ticket
 *
 * @param request CreateTicketRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTicketResponse
 */
async function createTicketWithOptions(request: CreateTicketRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTicketResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessTokenExpirationTime)) {
    query['accessTokenExpirationTime'] = request.accessTokenExpirationTime;
  }
  if (!Util.isUnset(request.expirationTime)) {
    query['expirationTime'] = request.expirationTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTicket',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/tickets`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create Ticket
 *
 * @param request CreateTicketRequest
 * @return CreateTicketResponse
 */
async function createTicket(request: CreateTicketRequest): CreateTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTicketWithOptions(request, headers, runtime);
}

model CreateUmodelRequest {
  description?: string(name='description', description='Umodel description', example='workspace test'),
}

model CreateUmodelResponseBody = {
  requestId?: string(name='requestId', description='Request ID', example='123-0F43-23423-AC43-34234'),
  workspace?: string(name='workspace', description='Workspace name', example='workspace-test'),
}

model CreateUmodelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateUmodelResponseBody(name='body'),
}

/**
 * @summary Create Umodel configuration
 *
 * @description Create Umodel configuration in the specified workspace
 *
 * @param request CreateUmodelRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUmodelResponse
 */
async function createUmodelWithOptions(workspace: string, request: CreateUmodelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateUmodelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateUmodel',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspace)}/umodel`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create Umodel configuration
 *
 * @description Create Umodel configuration in the specified workspace
 *
 * @param request CreateUmodelRequest
 * @return CreateUmodelResponse
 */
async function createUmodel(workspace: string, request: CreateUmodelRequest): CreateUmodelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createUmodelWithOptions(workspace, request, headers, runtime);
}

model DeleteAddonReleaseRequest {
  addonName?: string(name='addonName', description='Addon name. When AddonName is provided, it will ignore the ReleaseName parameter and batch uninstall all AddonReleases belonging to the same Addon.', example='cs-gpu'),
  force?: boolean(name='force', description='Whether to force deletion, default is false.', example='false'),
  releaseName?: string(name='releaseName', description='The name of the AddonRelease.', example='test-gpu-integration-name'),
}

model DeleteAddonReleaseResponseBody = {
  requestId?: string(name='requestId', description='Request ID.', example='264C3E89-BE6E-5F82-A484-CE9C2196C7DC'),
}

model DeleteAddonReleaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAddonReleaseResponseBody(name='body'),
}

/**
 * @summary Delete addon release information
 *
 * @param request DeleteAddonReleaseRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAddonReleaseResponse
 */
async function deleteAddonReleaseWithOptions(policyId: string, request: DeleteAddonReleaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAddonReleaseResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.addonName)) {
    query['addonName'] = request.addonName;
  }
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }
  if (!Util.isUnset(request.releaseName)) {
    query['releaseName'] = request.releaseName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAddonRelease',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/integration-policies/${OpenApiUtil.getEncodeParam(policyId)}/addon-releases`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete addon release information
 *
 * @param request DeleteAddonReleaseRequest
 * @return DeleteAddonReleaseResponse
 */
async function deleteAddonRelease(policyId: string, request: DeleteAddonReleaseRequest): DeleteAddonReleaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAddonReleaseWithOptions(policyId, request, headers, runtime);
}

model DeleteAggTaskGroupResponseBody = {
  requestId?: string(name='requestId', description='Request ID.', example='264C3E89-XXXX-XXXX-XXXX-CE9C2196C7DC'),
}

model DeleteAggTaskGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAggTaskGroupResponseBody(name='body'),
}

/**
 * @summary Delete Aggregation Task Group
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAggTaskGroupResponse
 */
async function deleteAggTaskGroupWithOptions(instanceId: string, groupId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAggTaskGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAggTaskGroup',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/prometheus-instances/${OpenApiUtil.getEncodeParam(instanceId)}/agg-task-groups/${OpenApiUtil.getEncodeParam(groupId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete Aggregation Task Group
 *
 * @return DeleteAggTaskGroupResponse
 */
async function deleteAggTaskGroup(instanceId: string, groupId: string): DeleteAggTaskGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAggTaskGroupWithOptions(instanceId, groupId, headers, runtime);
}

model DeleteEntityStoreResponseBody = {
  requestId?: string(name='requestId', description='request ID', example='264C3E89-XXXX-XXXX-XXXX-CE9C2196C7DC'),
}

model DeleteEntityStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteEntityStoreResponseBody(name='body'),
}

/**
 * @summary Delete EntityStore related storage
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEntityStoreResponse
 */
async function deleteEntityStoreWithOptions(workspaceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteEntityStoreResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteEntityStore',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspaceName)}/entitystore`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete EntityStore related storage
 *
 * @return DeleteEntityStoreResponse
 */
async function deleteEntityStore(workspaceName: string): DeleteEntityStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEntityStoreWithOptions(workspaceName, headers, runtime);
}

model DeleteIntegrationPolicyRequest {
  force?: boolean(name='force', description='Whether to forcibly delete the cloud-native all-in-one machine,
default value: `false`.', example='false'),
}

model DeleteIntegrationPolicyResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='CD8BA7D6-995D-578D-9941-78B0FECD14B5'),
}

model DeleteIntegrationPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteIntegrationPolicyResponseBody(name='body'),
}

/**
 * @summary Delete Access Center Policy
 *
 * @param request DeleteIntegrationPolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIntegrationPolicyResponse
 */
async function deleteIntegrationPolicyWithOptions(policyId: string, request: DeleteIntegrationPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteIntegrationPolicyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIntegrationPolicy',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/integration-policies/${OpenApiUtil.getEncodeParam(policyId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete Access Center Policy
 *
 * @param request DeleteIntegrationPolicyRequest
 * @return DeleteIntegrationPolicyResponse
 */
async function deleteIntegrationPolicy(policyId: string, request: DeleteIntegrationPolicyRequest): DeleteIntegrationPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteIntegrationPolicyWithOptions(policyId, request, headers, runtime);
}

model DeletePrometheusInstanceResponseBody = {
  requestId?: string(name='requestId', description='ID of the request', example='8FDE2569-626B-5176-9844-28877A*****'),
}

model DeletePrometheusInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePrometheusInstanceResponseBody(name='body'),
}

/**
 * @summary Delete prom instance
 *
 * @description Delete a Prometheus instance.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePrometheusInstanceResponse
 */
async function deletePrometheusInstanceWithOptions(prometheusInstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePrometheusInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeletePrometheusInstance',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/prometheus-instances/${OpenApiUtil.getEncodeParam(prometheusInstanceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete prom instance
 *
 * @description Delete a Prometheus instance.
 *
 * @return DeletePrometheusInstanceResponse
 */
async function deletePrometheusInstance(prometheusInstanceId: string): DeletePrometheusInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePrometheusInstanceWithOptions(prometheusInstanceId, headers, runtime);
}

model DeletePrometheusViewResponseBody = {
  requestId?: string(name='requestId', description='ID of the request', example='0CEC5375-C554-562B-A65F-9A629907C1F0'),
}

model DeletePrometheusViewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePrometheusViewResponseBody(name='body'),
}

/**
 * @summary Delete prometheus view instance
 *
 * @description Delete prometheus view instance.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePrometheusViewResponse
 */
async function deletePrometheusViewWithOptions(prometheusViewId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePrometheusViewResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeletePrometheusView',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/prometheus-views/${OpenApiUtil.getEncodeParam(prometheusViewId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete prometheus view instance
 *
 * @description Delete prometheus view instance.
 *
 * @return DeletePrometheusViewResponse
 */
async function deletePrometheusView(prometheusViewId: string): DeletePrometheusViewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePrometheusViewWithOptions(prometheusViewId, headers, runtime);
}

model DeleteServiceResponseBody = {
  requestId?: string(name='requestId', description='Request ID', example='51B6A3E8-EA9E-5143-BE11-8E5F83474C95'),
}

model DeleteServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteServiceResponseBody(name='body'),
}

/**
 * @summary Delete Service
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteServiceResponse
 */
async function deleteServiceWithOptions(workspace: string, serviceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteService',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspace)}/service/${OpenApiUtil.getEncodeParam(serviceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete Service
 *
 * @return DeleteServiceResponse
 */
async function deleteService(workspace: string, serviceId: string): DeleteServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceWithOptions(workspace, serviceId, headers, runtime);
}

model DeleteUmodelResponseBody = {
  requestId?: string(name='requestId', description='request ID', example='123123-3213-345-9941-345345345'),
}

model DeleteUmodelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteUmodelResponseBody(name='body'),
}

/**
 * @summary Delete Umodel configuration information
 *
 * @description Delete the Umodel under the specified workspace
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteUmodelResponse
 */
async function deleteUmodelWithOptions(workspace: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteUmodelResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteUmodel',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspace)}/umodel`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete Umodel configuration information
 *
 * @description Delete the Umodel under the specified workspace
 *
 * @return DeleteUmodelResponse
 */
async function deleteUmodel(workspace: string): DeleteUmodelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteUmodelWithOptions(workspace, headers, runtime);
}

model DeleteUmodelDataRequest {
  domain?: string(name='domain', description='Can specify the name of a specific Umodel data, leaving it blank means all', example='apm'),
  kind?: string(name='kind', description='Can specify the kind of a specific Umodel data, leaving it blank means all', example='metric_set'),
  name?: string(name='name', description='Can specify the name of a specific Umodel data, leaving it blank means all', example='test'),
}

model DeleteUmodelDataResponseBody = {
  requestId?: string(name='requestId', description='Request ID', example='111111-222-333-1111-33333'),
}

model DeleteUmodelDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteUmodelDataResponseBody(name='body'),
}

/**
 * @summary Delete Umodel Elements
 *
 * @description Delete the Umodel Data under a specified workspace
 *
 * @param request DeleteUmodelDataRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteUmodelDataResponse
 */
async function deleteUmodelDataWithOptions(workspace: string, request: DeleteUmodelDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteUmodelDataResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.domain)) {
    query['domain'] = request.domain;
  }
  if (!Util.isUnset(request.kind)) {
    query['kind'] = request.kind;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUmodelData',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspace)}/umodel/data`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete Umodel Elements
 *
 * @description Delete the Umodel Data under a specified workspace
 *
 * @param request DeleteUmodelDataRequest
 * @return DeleteUmodelDataResponse
 */
async function deleteUmodelData(workspace: string, request: DeleteUmodelDataRequest): DeleteUmodelDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteUmodelDataWithOptions(workspace, request, headers, runtime);
}

model DeleteWorkspaceResponseBody = {
  requestId?: string(name='requestId', description='Request ID', example='264C3E89-XXXX-XXXX-XXXX-CE9C2196C7DC'),
}

model DeleteWorkspaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteWorkspaceResponseBody(name='body'),
}

/**
 * @summary Delete Workspace
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteWorkspaceResponse
 */
async function deleteWorkspaceWithOptions(workspaceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteWorkspaceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteWorkspace',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspaceName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete Workspace
 *
 * @return DeleteWorkspaceResponse
 */
async function deleteWorkspace(workspaceName: string): DeleteWorkspaceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteWorkspaceWithOptions(workspaceName, headers, runtime);
}

model GetAddonReleaseResponseBody = {
  config?: string(name='config', description='Component configuration.', example='{"install":{"mode":"auto-install","listenPort":"9400"},"discoverMode":"instances","discover":{"instances":"worker-k8s-for-cs-c126d87c76218487e83ab322017f11b44"},"scrapeInterval":"15","enableSecuritecs-nodeyGroupInjection":"true","metricTags":""}'),
  release?: {
    addonName?: string(name='addonName', description='Addon component name.', example='cs-gpu'),
    alertRuleCount?: long(name='alertRuleCount', description='Number of alert rules.', example='6'),
    conditions?: [ 
      {
        firstTransitionTime?: string(name='firstTransitionTime', description='First transition time.', example='2024-11-04T16:10:22+08:00'),
        lastTransitionTime?: string(name='lastTransitionTime', description='Last transition time.', example='2024-11-04T16:10:22+08:00'),
        message?: string(name='message', description='Details.', example='The addon loaded successfully'),
        status?: string(name='status', description='Phase status.', example='True'),
        type?: string(name='type', description='Phase type.', example='Loaded'),
      }
    ](name='conditions', description='Installation phase information.'),
    config?: string(name='config', description='Component configuration information.', example='{"install":{"mode":"auto-install","listenPort":"9400"},"discoverMode":"instances","discover":{"instances":"worker-k8s-for-cs-c126d87c76218487e83ab322017f11b44"},"scrapeInterval":"15","enableSecuritecs-nodeyGroupInjection":"true","metricTags":""}'),
    createTime?: string(name='createTime', description='Connection time.', example='2024-11-04T16:10:12+08:00'),
    dashboardCount?: long(name='dashboardCount', description='Number of dashboards.', example='3'),
    entityRules?: EntityGroupBase(name='entityRules', description='Entity details.'),
    envType?: string(name='envType', description='Environment type.', example='CS'),
    environmentId?: string(name='environmentId', description='Environment ID.', example='policy-xxxxxxxxxxx'),
    exporterCount?: long(name='exporterCount', description='Number of plugins.', example='2'),
    haveConfig?: boolean(name='haveConfig', description='Whether there is a configuration.', example='true'),
    installUserId?: string(name='installUserId', description='User ID for connection.', example='1707xxxxxxxxxxxx'),
    language?: string(name='language', description='Language.', example='zh'),
    managed?: boolean(name='managed', description='Whether it is a managed component.', example='true'),
    parentAddonReleaseId?: string(name='parentAddonReleaseId', description='Parent AddonRelease ID.', example='policy-xxxxxxxxxxxxx'),
    policyId?: string(name='policyId', description='Policy ID.', example='policy-xxxxxxxxxxxxx'),
    regionId?: string(name='regionId', description='Region ID.', example='cn-hangzhou'),
    releaseId?: string(name='releaseId', description='Release ID.', example='7339d808-66f9-4d40-83fa-xxxxxxxxxxx'),
    releaseName?: string(name='releaseName', description='The name of the Release.', example='test-gpu-integration-name'),
    scene?: string(name='scene', description='Component scenario.', example='container'),
    status?: string(name='status', description='Component status.', example='running'),
    updateTime?: string(name='updateTime', description='Update time.', example='2024-11-04T16:10:12+08:00'),
    userId?: string(name='userId', description='Owner user ID.', example='1707xxxxxxxxxxxx'),
    version?: string(name='version', description='Component version.', example='0.0.2'),
    workspace?: string(name='workspace', description='Workspace.', example='default'),
  }(name='release', description='Detailed information.'),
  requestId?: string(name='requestId', description='Request ID.', example='0B9377D9-C56B-5C2E-A8A4-A01D6CC3F4B8'),
}

model GetAddonReleaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAddonReleaseResponseBody(name='body'),
}

/**
 * @summary Check addon release (view connection status)
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAddonReleaseResponse
 */
async function getAddonReleaseWithOptions(releaseName: string, policyId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAddonReleaseResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAddonRelease',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/integration-policies/${OpenApiUtil.getEncodeParam(policyId)}/addon-releases/${OpenApiUtil.getEncodeParam(releaseName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Check addon release (view connection status)
 *
 * @return GetAddonReleaseResponse
 */
async function getAddonRelease(releaseName: string, policyId: string): GetAddonReleaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAddonReleaseWithOptions(releaseName, policyId, headers, runtime);
}

model GetAggTaskGroupResponseBody = {
  aggTaskGroup?: {
    aggTaskGroupConfig?: string(name='aggTaskGroupConfig', description='Aggregation task group configuration.', example='groups:
- name: "node.rules"
  interval: "60s"
  rules:
  - record: "node_namespace_pod:kube_pod_info:"
    expr: "max(label_replace(kube_pod_info{job=\\\\"kubernetes-pods-kube-state-metrics\\\\"\\\\
      }, \\\\"pod\\\\", \\\\"$1\\\\", \\\\"pod\\\\", \\\\"(.*)\\\\")) by (node, namespace, pod, cluster)"'),
    aggTaskGroupConfigHash?: string(name='aggTaskGroupConfigHash', description='Summary of the aggregation task group configuration.', example='a54136xxx'),
    aggTaskGroupId?: string(name='aggTaskGroupId', description='ID of the aggregation task group.', example='aggTaskGroup-xx'),
    aggTaskGroupName?: string(name='aggTaskGroupName', description='Name of the aggregation task group.', example='pipeline-aggtask-group'),
    cronExpr?: string(name='cronExpr', description='Scheduling expression for the aggregation task group when the scheduling mode is \\\\"Cron\\\\".', example='0 1 3 * * ? *'),
    delay?: int32(name='delay', description='Fixed delay time (in seconds) for scheduling.', example='2'),
    description?: string(name='description', description='Description of the aggregation task group.', example='test'),
    fromTime?: long(name='fromTime', description='Second-level timestamp corresponding to the start time of scheduling (not yet effective).', example='1757409495'),
    maxRetries?: int32(name='maxRetries', description='Maximum number of retries for executing the aggregation task.', example='2'),
    maxRunTimeInSeconds?: int32(name='maxRunTimeInSeconds', description='Maximum retry time for executing the aggregation task.', example='50'),
    precheckString?: string(name='precheckString', description='Pre-check configuration.', example='{"policy":"skip","prometheusId":"rw-xx","query":"noPrecheck","threshold":0.5,"timeout":15,"type":"none"}'),
    regionId?: string(name='regionId', description='Region ID.', example='cn-zhangjiakou'),
    scheduleMode?: string(name='scheduleMode', description='Scheduling mode.', example='FixedRate'),
    scheduleTimeExpr?: string(name='scheduleTimeExpr', description='Scheduling time expression.', example='@m'),
    sourcePrometheusId?: string(name='sourcePrometheusId', description='ID of the source Prometheus instance for the aggregation task group.', example='rw-xxx'),
    status?: string(name='status', description='Status of the aggregation task group.', example='Running'),
    tags?: [ 
      {
        key?: string(name='key', description='Key of the resource group tag.', example='key1'),
        value?: string(name='value', description='The value of the resource group tag.', example='value1'),
      }
    ](name='tags', description='Resource group tags'),
    targetPrometheusId?: string(name='targetPrometheusId', description='The target Prometheus instance ID of the aggregation task group.', example='rw-xxx'),
    toTime?: long(name='toTime', description='The second-level timestamp corresponding to the end time of the scheduling.', example='1757409495'),
    updateTime?: string(name='updateTime', description='The update time (timestamp) of the aggregation task group.', example='1757409499000'),
    userId?: string(name='userId', description='The user to whom the aggregation task group belongs.', example='123xxx'),
  }(name='aggTaskGroup', description='Aggregation task group.'),
  requestId?: string(name='requestId', description='Request ID', example='68DAF543-35DF-5762-BE90-F5C00B5DC036'),
  success?: boolean(name='success', description='Whether the request was successful', example='True'),
}

model GetAggTaskGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAggTaskGroupResponseBody(name='body'),
}

/**
 * @summary Describes the aggregation task group
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAggTaskGroupResponse
 */
async function getAggTaskGroupWithOptions(instanceId: string, groupId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAggTaskGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAggTaskGroup',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/prometheus-instances/${OpenApiUtil.getEncodeParam(instanceId)}/agg-task-groups/${OpenApiUtil.getEncodeParam(groupId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Describes the aggregation task group
 *
 * @return GetAggTaskGroupResponse
 */
async function getAggTaskGroup(instanceId: string, groupId: string): GetAggTaskGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAggTaskGroupWithOptions(instanceId, groupId, headers, runtime);
}

model GetEntityStoreResponseBody = {
  regionId?: string(name='regionId', description='Region ID', example='cn-heyuan'),
  requestId?: string(name='requestId', description='Request ID', example='264C3E89-XXXX-XXXX-XXXX-CE9C2196C7DC'),
  workspaceName?: string(name='workspaceName', description='Workspace name', example='workspace-test-001'),
}

model GetEntityStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEntityStoreResponseBody(name='body'),
}

/**
 * @summary Get EntityStore related storage information
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEntityStoreResponse
 */
async function getEntityStoreWithOptions(workspaceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetEntityStoreResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetEntityStore',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspaceName)}/entitystore`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get EntityStore related storage information
 *
 * @return GetEntityStoreResponse
 */
async function getEntityStore(workspaceName: string): GetEntityStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEntityStoreWithOptions(workspaceName, headers, runtime);
}

model GetEntityStoreDataHeaders {
  commonHeaders?: map[string]string,
  acceptEncoding?: string(name='acceptEncoding', description='Content encoding type for the compression algorithm', example='gzip'),
}

model GetEntityStoreDataRequest {
  from?: int32(name='from', description='Start time of the query.

Unix timestamp format, representing the number of seconds since 1970-1-1 00:00:00 UTC.

This parameter is required.', example='1721767203'),
  query?: string(name='query', description='Query statement

This parameter is required.', example='.entity with(domain=\\\\"acs\\\\", type=\\\\"acs.k8s.node\\\\") | limit 0, 10'),
  to?: int32(name='to', description='End time of the query.

Unix timestamp format, representing the number of seconds since 1970-1-1 00:00:00 UTC.

This parameter is required.', example='1721767283'),
}

model GetEntityStoreDataResponseBody = {
  data?: [[ string ]  ](name='data', description='Total list of returned data'),
  header?: [ string ](name='header', description='List of request headers'),
  requestId?: string(name='requestId', description='Request ID', example='264C3E89-XXXX-XXXX-XXXX-CE9C2196C7DC'),
  responseStatus?: {
    executionStates?: string(name='executionStates', description='Information during the execution process', example='{}'),
    level?: string(name='level', description='Status level', example='Info,Warn,Error'),
    result?: string(name='result', description='Execution result', example='Success,PartialSuccess,Error'),
    retryPolicy?: string(name='retryPolicy', description='Retry policy', example='None,Once,Continuous'),
    statusItem?: [ 
      {
        code?: string(name='code', description='Status code', example='Success,ExecuteTimeout,UModelNotExist'),
        level?: string(name='level', description='Status level', example='Info,Warn,Error'),
        message?: string(name='message', description='Calculation execution information', example='Query execution timeout after 30 seconds'),
        suggestion?: string(name='suggestion', description='Suggestions when an error occurs during execution', example='Try to reduce the query scope or increase timeout limit, then retry'),
      }
    ](name='statusItem', description='Detailed status information list'),
  }(name='responseStatus', description='Result status'),
}

model GetEntityStoreDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEntityStoreDataResponseBody(name='body'),
}

/**
 * @summary Query the entity and relationship data under a specified Workspace, returning the entity data within a certain time range (the returned result is transmitted after compression).
 *
 * @param request GetEntityStoreDataRequest
 * @param headers GetEntityStoreDataHeaders
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEntityStoreDataResponse
 */
async function getEntityStoreDataWithOptions(workspace: string, request: GetEntityStoreDataRequest, headers: GetEntityStoreDataHeaders, runtime: Util.RuntimeOptions): GetEntityStoreDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.from)) {
    body['from'] = request.from;
  }
  if (!Util.isUnset(request.query)) {
    body['query'] = request.query;
  }
  if (!Util.isUnset(request.to)) {
    body['to'] = request.to;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.acceptEncoding)) {
    realHeaders['acceptEncoding'] = Util.toJSONString(headers.acceptEncoding);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetEntityStoreData',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspace)}/entitiesAndRelations`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Query the entity and relationship data under a specified Workspace, returning the entity data within a certain time range (the returned result is transmitted after compression).
 *
 * @param request GetEntityStoreDataRequest
 * @return GetEntityStoreDataResponse
 */
async function getEntityStoreData(workspace: string, request: GetEntityStoreDataRequest): GetEntityStoreDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetEntityStoreDataHeaders{};
  return getEntityStoreDataWithOptions(workspace, request, headers, runtime);
}

model GetIntegrationPolicyResponseBody = {
  policy?: {
    bindResource?: {
      clusterId?: string(name='clusterId', description='Cluster ID.', example='00b1630f02814f95a9bce717d8d56bb2'),
      clusterType?: string(name='clusterType', description='Cluster type.', example='ManagedKubernetes'),
      vpcCidr?: string(name='vpcCidr', description='VPC CIDR.', example='10.12.0.1/16'),
      vpcId?: string(name='vpcId', description='VPC ID.', example='vpc-2zegqpeyxplhtmdg70xnr'),
    }(name='bindResource', description='Bound resource information.'),
    csUmodelStatus?: boolean(name='csUmodelStatus', description='Cs umodel status'),
    entityGroup?: {
      description?: string(name='description', description='Description.', example='xxxxxx'),
      entityGroupId?: string(name='entityGroupId', description='Entity group ID.', example='eg-b79f65d11fb94e779867cf937c3a3002'),
      entityGroupName?: string(name='entityGroupName', description='Entity group name.', example='prod-database'),
      entityRules?: {
        annotations?: [ 
          {
            op?: string(name='op', description='Operation to be performed.', example='add'),
            tagKey?: string(name='tagKey', description='Tag key.', example='use'),
            tagValues?: [ string ](name='tagValues', description='Tag values.'),
          }
        ](name='annotations', description='Annotations.'),
        entityTypes?: [ string ](name='entityTypes', description='List of entity types.'),
        fieldRules?: [ 
          {
            fieldKey?: string(name='fieldKey', description='Unique identifier for the field.', example='test'),
            fieldValues?: [ string ](name='fieldValues', description='Field content.'),
            op?: string(name='op', description='Operation to be performed.', example='add'),
          }
        ](name='fieldRules', description='List of field rules.'),
        instanceIds?: [ string ](name='instanceIds', description='Instance ID.'),
        ipMatchRule?: {
          ipCidr?: string(name='ipCidr', description='IP segment.', example='10.10.0.1/16'),
          ipFieldKey?: string(name='ipFieldKey', description='Key for the IP field.', example='test-key'),
        }(name='ipMatchRule', description='IP matching rule.'),
        labels?: [ 
          {
            op?: string(name='op', description='The operation to be performed.', example='add'),
            tagKey?: string(name='tagKey', description='The tag key of the instance.', example='key1'),
            tagValues?: [ string ](name='tagValues', description='List of tag values.'),
          }
        ](name='labels', description='Labels.'),
        regionIds?: [ string ](name='regionIds', description='List of region IDs.'),
        resourceGroupId?: string(name='resourceGroupId', description='Resource group ID.', example='rg-aek3aqsuvlv3yyq'),
        tags?: [ 
          {
            op?: string(name='op', description='The operation to be performed.', example='add'),
            tagKey?: string(name='tagKey', description='The tag key of the instance.', example='key2'),
            tagValues?: [ string ](name='tagValues', description='List of tag values.'),
          }
        ](name='tags', description='Tag values.'),
      }(name='entityRules', description='Entity rules.'),
      query?: string(name='query', description='For querying', example='status: 200 AND totalTime > 0.5'),
      regionId?: string(name='regionId', description='Region ID.', example='cn-heyuan'),
      userId?: string(name='userId', description='User ID.', example='u123456'),
      workspace?: string(name='workspace', description='Workspace.', example='test-api'),
    }(name='entityGroup', description='Entity group.'),
    managedInfo?: {
      securityGroupId?: string(name='securityGroupId', description='Security group ID.', example='sg-xxxxxx'),
      vswitchId?: string(name='vswitchId', description='VSwitch ID.', example='vsw-xxxxxxxxx'),
    }(name='managedInfo', description='Policy management information.'),
    policyId?: string(name='policyId', description='Policy ID.', example='policy-c9efed2b99c348d49e589c5f780fc074'),
    policyName?: string(name='policyName', description='Rule name.', example='ControlPolicy4DetailVportInfo'),
    policyType?: string(name='policyType', description='Access policy type.', example='CS'),
    regionId?: string(name='regionId', description='Region ID.', example='cn-heyuan'),
    resourceGroupId?: string(name='resourceGroupId', description='Resource group ID.', example='rg-xxxxx'),
    tags?: [ 
      {
        key?: string(name='key', description='Tag key.', example='use'),
        value?: string(name='value', description='Tag value.', example='db'),
      }
    ](name='tags', description='Tag keys.'),
    userId?: string(name='userId', description='User ID.', example='u123456'),
    workspace?: string(name='workspace', description='Workspace.', example='prometheus'),
  }(name='policy', description='Access policy.'),
  requestId?: string(name='requestId', description='ID of the request.', example='0B9377D9-C56B-5C2E-A8A4-A01D6CC3F4B8'),
}

model GetIntegrationPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetIntegrationPolicyResponseBody(name='body'),
}

/**
 * @summary Query the list of access center policies
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetIntegrationPolicyResponse
 */
async function getIntegrationPolicyWithOptions(policyId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetIntegrationPolicyResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetIntegrationPolicy',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/integration-policies/${OpenApiUtil.getEncodeParam(policyId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Query the list of access center policies
 *
 * @return GetIntegrationPolicyResponse
 */
async function getIntegrationPolicy(policyId: string): GetIntegrationPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIntegrationPolicyWithOptions(policyId, headers, runtime);
}

model GetPrometheusInstanceRequest {
  aliyunLang?: string(name='aliyunLang', description='Language setting, default is Chinese zh | en', example='zh'),
  resourceGroupId?: string(name='resourceGroupId', description='Resource group ID.', example='rg-aek2bhocin5e2na'),
}

model GetPrometheusInstanceResponseBody = {
  prometheusInstance?: {
    accessType?: string(name='accessType', description='Access type:
readWrite, readOnly, httpReadOnly', example='readOnly'),
    archiveDuration?: int32(name='archiveDuration', description='Number of days to automatically archive and save after storage expiration. 0 means no archiving, 3650 means permanent saving.', example='90'),
    authFreeReadPolicy?: string(name='authFreeReadPolicy', description='Password-free read policy (supports IP segments and VpcId).', example='{
  "SourceIp": [
    "192.168.1.0/24",
    "172.168.2.22"
  ],
  "SourceVpc": [
    "vpc-xx1",
    "vpc-xx2"
  ]
}'),
    authFreeWritePolicy?: string(name='authFreeWritePolicy', description='Password-free write policy (supports IP segments and VpcId).', example='{
  "SourceIp": [
    "192.168.1.0/24",
    "172.168.2.22"
  ],
  "SourceVpc": [
    "vpc-xx1",
    "vpc-xx2"
  ]
}'),
    authToken?: string(name='authToken', description='authToken string.', example='eJwixxxxx'),
    createTime?: string(name='createTime', description='Instance creation time, using UTC+0, formatted as yyyy-MM-ddTHH:mmZ.', example='2025-08-10T02:07:53Z'),
    enableAuthFreeRead?: boolean(name='enableAuthFreeRead', description='Whether to enable password-free reading.', example='true'),
    enableAuthFreeWrite?: boolean(name='enableAuthFreeWrite', description='Whether to enable password-free writing.', example='true'),
    enableAuthToken?: boolean(name='enableAuthToken', description='Whether to enable authentication token.', example='true'),
    extraInfo?: map[string]string(name='extraInfo', description='Additional information.'),
    folderUrl?: string(name='folderUrl', description='URL of the visualization dashboard directory.', example='https://gnew.console.aliyun.com/dashboards/f/c49a80d2a551d4a20a8c4b996b0be4e52/xxxxxxx'),
    grafanaInstanceId?: string(name='grafanaInstanceId', description='ID of the managed Grafana instance that is bound.', example='SHARED'),
    grafanaInstanceName?: string(name='grafanaInstanceName', description='Name of the managed Grafana instance that is bound.', example='共享版'),
    httpApiInterUrl?: string(name='httpApiInterUrl', description='HTTP public network address.', example='http://workspace-default-cms-xxxxxxx'),
    httpApiIntraUrl?: string(name='httpApiIntraUrl', description='HTTP intranet address.', example='http://workspace-default-cms-xxxxxxx'),
    instanceType?: string(name='instanceType', description='Prometheus instance type.', example='remote-write'),
    paymentType?: string(name='paymentType', description='Billing method:
POSTPAY: Pay-as-you-go based on metric reporting volume.
POSTPAY_GB: Pay-as-you-go based on metric write volume.', example='POSTPAY'),
    paymentTypeUpdateTime?: string(name='paymentTypeUpdateTime', description='Time when the billing method of the instance was updated.', example='2025-08-10T02:07:53Z'),
    product?: string(name='product', description='The product to which the Prometheus instance belongs (arms or cms).', example='cms'),
    prometheusInstanceId?: string(name='prometheusInstanceId', description='Instance ID.', example='rw-524ada714221af267c73122af2e1'),
    prometheusInstanceName?: string(name='prometheusInstanceName', description='Instance name.', example='test-prom-name'),
    pushGatewayInterUrl?: string(name='pushGatewayInterUrl', description='Public network address of PushGateway.', example='http://workspace-default-cms-xxxxxxx'),
    pushGatewayIntraUrl?: string(name='pushGatewayIntraUrl', description='Intranet address of PushGateway.', example='http://workspace-default-cms-xxxxxxx'),
    regionId?: string(name='regionId', description='Region ID.', example='cn-heyuan'),
    remoteReadInterUrl?: string(name='remoteReadInterUrl', description='Public network read address.', example='http://workspace-default-cms-xxxxxxx'),
    remoteReadIntraUrl?: string(name='remoteReadIntraUrl', description='Intranet read address.', example='https://workspace-default-cms-1xxxxxxxxxx'),
    remoteWriteInterUrl?: string(name='remoteWriteInterUrl', description='Public network write address.', example='https://workspace-default-cms-xxxxxxxxxx'),
    remoteWriteIntraUrl?: string(name='remoteWriteIntraUrl', description='Intranet write address.', example='https://workspace-default-cms-xxxxxxxxxx'),
    resourceGroupId?: string(name='resourceGroupId', description='Resource group ID.', example='rg-acfm3gn5i6bigbi'),
    resourceType?: string(name='resourceType', description='Fixed value: PrometheusInstance.', example='Prometheus'),
    status?: string(name='status', description='Instance status.', example='Running'),
    storageDuration?: int32(name='storageDuration', description='Storage duration (in days).', example='90'),
    supportAuthTypes?: [ string ](name='supportAuthTypes', description='Supported authentication types.'),
    tags?: [ 
      {
        key?: string(name='key', description='Tag key.', example='openStorage'),
        value?: string(name='value', description='Matched value.', example='130303196111114281'),
      }
    ](name='tags', description='List of tags.'),
    userId?: string(name='userId', description='User ID.', example='170731234567'),
    version?: string(name='version', description='Version.', example='V1'),
    workspace?: string(name='workspace', description='The workspace to which the Prometheus instance belongs.', example='ws1'),
  }(name='prometheusInstance', description='Details of the Prometheus instance.'),
  requestId?: string(name='requestId', description='Unique identifier for the request.', example='264C3E89-XXXX-XXXX-XXXX-CE9C2196C7DC'),
}

model GetPrometheusInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPrometheusInstanceResponseBody(name='body'),
}

/**
 * @summary Query the instance in a specified environment
 *
 * @description Retrieve details of a Prometheus instance.
 *
 * @param request GetPrometheusInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPrometheusInstanceResponse
 */
async function getPrometheusInstanceWithOptions(prometheusInstanceId: string, request: GetPrometheusInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetPrometheusInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.aliyunLang)) {
    query['aliyunLang'] = request.aliyunLang;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPrometheusInstance',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/prometheus-instances/${OpenApiUtil.getEncodeParam(prometheusInstanceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Query the instance in a specified environment
 *
 * @description Retrieve details of a Prometheus instance.
 *
 * @param request GetPrometheusInstanceRequest
 * @return GetPrometheusInstanceResponse
 */
async function getPrometheusInstance(prometheusInstanceId: string, request: GetPrometheusInstanceRequest): GetPrometheusInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPrometheusInstanceWithOptions(prometheusInstanceId, request, headers, runtime);
}

model GetPrometheusViewRequest {
  aliyunLang?: string(name='aliyunLang', description='Language environment, default is Chinese zh | en', example='zh'),
  resourceGroupId?: string(name='resourceGroupId', description='Resource group ID.', example='rg-aek2bhocin5e2na'),
}

model GetPrometheusViewResponseBody = {
  prometheusView?: {
    authFreeReadPolicy?: string(name='authFreeReadPolicy', description='Password-free read policy (supports IP segments and VpcId).', example='{
  "SourceIp": [
    "192.168.1.0/24",
    "172.168.2.22"
  ],
  "SourceVpc": [
    "vpc-xx1",
    "vpc-xx2"
  ]
}'),
    authToken?: string(name='authToken', description='authToken string.', example='eJxxxxxx'),
    createTime?: string(name='createTime', description='Instance creation time, using UTC+0 time, format is yyyy-MM-ddTHH:mmZ.', example='2025-08-10T02:07:53Z'),
    enableAuthFreeRead?: boolean(name='enableAuthFreeRead', description='Whether to enable password-free read.', example='true'),
    enableAuthToken?: boolean(name='enableAuthToken', description='Whether to enable authToken.', example='true'),
    folderUrl?: string(name='folderUrl', description='Observability dashboard URL.', example='https://xxxx'),
    grafanaInstanceId?: string(name='grafanaInstanceId', description='Bound managed Grafana instance ID.', example='g-xxx'),
    grafanaInstanceName?: string(name='grafanaInstanceName', description='Bound managed Grafana instance name.', example='gxxx'),
    httpApiInterUrl?: string(name='httpApiInterUrl', description='Public HTTP address.', example='http://xxxxxxxx'),
    httpApiIntraUrl?: string(name='httpApiIntraUrl', description='Private HTTP address.', example='http://xxxxxxxx'),
    instanceType?: string(name='instanceType', description='Instance type, fixed value prom-view.', example='prom-view'),
    paymentType?: string(name='paymentType', description='Payment type. Currently, the fixed value is FREE (free).', example='FREE'),
    product?: string(name='product', description='Product that the prom instance belongs to.', example='cms'),
    prometheusInstances?: [ 
      {
        prometheusInstanceId?: string(name='prometheusInstanceId', description='Instance ID.', example='rw-63549e054ff596a4149927961dff'),
        regionId?: string(name='regionId', description='Region ID', example='cn-north-2-gov-1'),
        userId?: string(name='userId', description='User ID.', example='122xxxxx'),
      }
    ](name='prometheusInstances', description='Prometheus instance list.'),
    prometheusViewId?: string(name='prometheusViewId', description='Prometheus view ID.', example='view-xxx'),
    prometheusViewName?: string(name='prometheusViewName', description='Prometheus view name.', example='view1'),
    regionId?: string(name='regionId', description='Region ID', example='cn-shanghai'),
    remoteReadInterUrl?: string(name='remoteReadInterUrl', description='Remote read public URL.', example='http://workspace-default-cms-xxx-cn-hangzhou.cn-hangzhou.log.aliyuncs.com/prometheus/workspace-default-cms-xxx-cn-hangzhou/xxx/api/v1/read'),
    remoteReadIntraUrl?: string(name='remoteReadIntraUrl', description='Remote read intranet URL.', example='http://workspace-default-cms-xxx-cn-hangzhou.cn-hangzhou-intranet.log.aliyuncs.com/prometheus/workspace-default-cms-xxx-cn-hangzhou/xxx/api/v1/read'),
    resourceGroupId?: string(name='resourceGroupId', description='Resource group ID.', example='rg-acfm3gn5i6bigbi'),
    resourceType?: string(name='resourceType', description='Fixed value: PrometheusView', example='RegistryModule'),
    status?: string(name='status', description='Backend data storage status', example='Pending2Running'),
    supportAuthTypes?: [ string ](name='supportAuthTypes', description='Supported authentication types.'),
    tags?: [ 
      {
        key?: string(name='key', description='PagerDuty integration key.', example='global_score_series'),
        value?: string(name='value', description='Tag value.', example='371293199010092839'),
      }
    ](name='tags', description='Instance tag keys.'),
    userId?: string(name='userId', description='User ID.', example='11222'),
    version?: string(name='version', description='Version.', example='V1'),
    workspace?: string(name='workspace', description='Workspace to which the environment belongs', example='cms-monitor-test-aysls-pub-cn-fuzhou-monitor'),
  }(name='prometheusView', description='View instance.'),
  requestId?: string(name='requestId', description='Id of the request', example='0B9377D9-C56B-5C2E-A8A4-A01D6CC3F4B8'),
}

model GetPrometheusViewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPrometheusViewResponseBody(name='body'),
}

/**
 * @summary Query a specified Prometheus view instance
 *
 * @description Query a specified Prometheus view instance.
 *
 * @param request GetPrometheusViewRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPrometheusViewResponse
 */
async function getPrometheusViewWithOptions(prometheusViewId: string, request: GetPrometheusViewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetPrometheusViewResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.aliyunLang)) {
    query['aliyunLang'] = request.aliyunLang;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPrometheusView',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/prometheus-views/${OpenApiUtil.getEncodeParam(prometheusViewId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Query a specified Prometheus view instance
 *
 * @description Query a specified Prometheus view instance.
 *
 * @param request GetPrometheusViewRequest
 * @return GetPrometheusViewResponse
 */
async function getPrometheusView(prometheusViewId: string, request: GetPrometheusViewRequest): GetPrometheusViewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPrometheusViewWithOptions(prometheusViewId, request, headers, runtime);
}

model GetServiceResponseBody = {
  requestId?: string(name='requestId', description='Request ID', example='264C3E89-BE6E-5F82-A484-CE9C2196C7DC'),
  service?: {
    attributes?: string(name='attributes', description='Extended information.', example='{"language":"java"}'),
    createTime?: string(name='createTime', description='Creation time', example='2025-05-13T03:32:55Z'),
    description?: string(name='description', description='Description, only valid when serviceType=RUM.', example='test'),
    displayName?: string(name='displayName', description='Display name, only valid when serviceType=RUM.', example='demo应用'),
    pid?: string(name='pid', description='Legacy ARMS application ID', example='by6rjzro2j@0fe8dfa799e5906'),
    regionId?: string(name='regionId', description='Region ID', example='cn-heyuan'),
    serviceId?: string(name='serviceId', description='Service ID.', example='cwzxvuc6uo@4bc6b15ad81f166174ffb'),
    serviceName?: string(name='serviceName', description='Service name', example='demo-app'),
    serviceStatus?: string(name='serviceStatus', description='Service status, only valid when serviceType=RUM.', example='Running'),
    serviceType?: string(name='serviceType', description='Service type.', example='TRACE'),
    workspace?: string(name='workspace', description='Workspace name', example='default-cms-1106439496876715-cn-hangzhou'),
  }(name='service', description='Service object.'),
}

model GetServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetServiceResponseBody(name='body'),
}

/**
 * @summary Query Service
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetServiceResponse
 */
async function getServiceWithOptions(workspace: string, serviceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetService',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspace)}/service/${OpenApiUtil.getEncodeParam(serviceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Query Service
 *
 * @return GetServiceResponse
 */
async function getService(workspace: string, serviceId: string): GetServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceWithOptions(workspace, serviceId, headers, runtime);
}

model GetServiceObservabilityResponseBody = {
  entryPointInfo?: {
    authToken?: string(name='authToken', description='Authentication Token for Data Reporting', example='gaddp****@de20f2***1ce***'),
    privateDomain?: string(name='privateDomain', description='Private Network Access Address', example='project-xtrace-xxxx-cn-hangzhou.cn-hangzhou-intranet.log.aliyuncs.com'),
    project?: string(name='project', description='SLS Project', example='proj-xtrace-xxxxx'),
    publicDomain?: string(name='publicDomain', description='Public Network Access Address', example='project-xtrace-xxxx-cn-hangzhou.cn-hangzhou.log.aliyuncs.com'),
  }(name='entryPointInfo', description='Endpoint and Authentication Information'),
  feeType?: string(name='feeType', description='Billing Type', example='arms=serverless;xtrace=serverless'),
  quotas?: map[string]string(name='quotas', description='Quota Configuration'),
  regionId?: string(name='regionId', description='Region', example='cn-hangzhou'),
  requestId?: string(name='requestId', description='Request ID', example='4852B9B5-345C-5CBC-A15F-786D83ECCBBA'),
  settings?: map[string]string(name='settings', description='System Configuration'),
  status?: string(name='status', description='Resource Initialization Status', example='Running'),
  type?: string(name='type', description='Application Observability Type', example='apm'),
  workspace?: string(name='workspace', description='Workspace Name', example='default-cms-1654218***343050-cn-hangzhou'),
}

model GetServiceObservabilityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetServiceObservabilityResponseBody(name='body'),
}

/**
 * @summary Get Application Observability Instance
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetServiceObservabilityResponse
 */
async function getServiceObservabilityWithOptions(workspace: string, type: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceObservabilityResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetServiceObservability',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspace)}/service-observability/${OpenApiUtil.getEncodeParam(type)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get Application Observability Instance
 *
 * @return GetServiceObservabilityResponse
 */
async function getServiceObservability(workspace: string, type: string): GetServiceObservabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceObservabilityWithOptions(workspace, type, headers, runtime);
}

model GetUmodelResponseBody = {
  commonSchemaRef?: [ 
    {
      group?: string(name='group', description='Common Umodel Schema group', example='test-job-123123'),
      version?: string(name='version', description='Version', example='5'),
    }
  ](name='commonSchemaRef', description='This field does not need to be filled currently'),
  description?: string(name='description', description='Umodel description', example='workspace test'),
  regionId?: string(name='regionId', description='Region', example='cn-heyuan'),
  requestId?: string(name='requestId', description='Request ID', example='123-123123-sdf-435-3123'),
  workspace?: string(name='workspace', description='Workspace name', example='workspace-test'),
}

model GetUmodelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUmodelResponseBody(name='body'),
}

/**
 * @summary Get Umodel configuration information
 *
 * @description Get Umodel configuration information
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetUmodelResponse
 */
async function getUmodelWithOptions(workspace: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetUmodelResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetUmodel',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspace)}/umodel`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get Umodel configuration information
 *
 * @description Get Umodel configuration information
 *
 * @return GetUmodelResponse
 */
async function getUmodel(workspace: string): GetUmodelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUmodelWithOptions(workspace, headers, runtime);
}

model GetUmodelDataRequest {
  content?: any(name='content', description='Query conditions', example='{
	"filter": {
		"domains": []
	},
	"offset": 0,
	"size": 100000
}'),
  method?: string(name='method', description='Method

This parameter is required.', example='ListData'),
}

model GetUmodelDataResponseBody = {
  errors?: [ 
    {
      message?: string(name='message', description='Details.', example='ok'),
      type?: string(name='type', description='Error type', example='external'),
    }
  ](name='errors', description='Error information'),
  links?: [ any ](name='links', description='List of node link relationships'),
  nodes?: [ any ](name='nodes', description='List of nodes'),
  requestId?: string(name='requestId', description='Request ID', example='123-123-234-345-123'),
  totalLinksCount?: int32(name='totalLinksCount', description='Total number of node links', example='0'),
  totalNodesCount?: int32(name='totalNodesCount', description='Total number of nodes', example='0'),
}

model GetUmodelDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUmodelDataResponseBody(name='body'),
}

/**
 * @summary Retrieve associated Umodel graph data
 *
 * @description Find Umodel
 *
 * @param request GetUmodelDataRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetUmodelDataResponse
 */
async function getUmodelDataWithOptions(workspace: string, request: GetUmodelDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetUmodelDataResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.method)) {
    query['method'] = request.method;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetUmodelData',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspace)}/umodel/graph`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Retrieve associated Umodel graph data
 *
 * @description Find Umodel
 *
 * @param request GetUmodelDataRequest
 * @return GetUmodelDataResponse
 */
async function getUmodelData(workspace: string, request: GetUmodelDataRequest): GetUmodelDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUmodelDataWithOptions(workspace, request, headers, runtime);
}

model GetWorkspaceResponseBody = {
  createTime?: string(name='createTime', description='Creation Time

Use the UTC time format: yyyy-MM-ddTHH:mm:ss.SSSZ', example='2025-03-11T08:21:58Z'),
  description?: string(name='description', description='Workspace Description', example='workspace test'),
  displayName?: string(name='displayName', description='Workspace Display Name', example='workspace-test'),
  lastModifyTime?: string(name='lastModifyTime', description='Last Modified Time

Use the UTC time format: yyyy-MM-ddTHH:mm:ssZ', example='2025-03-11T08:21:58Z'),
  regionId?: string(name='regionId', description='Region ID', example='cn-heyuan'),
  requestId?: string(name='requestId', description='Request ID', example='264C3E89-XXXX-XXXX-XXXX-CE9C2196C7DC'),
  slsProject?: string(name='slsProject', description='Log Service Project Name', example='sls-project-test-001'),
  workspaceName?: string(name='workspaceName', description='Workspace Name

This parameter is required.', example='workspace-test-001'),
}

model GetWorkspaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetWorkspaceResponseBody(name='body'),
}

/**
 * @summary Get Workspace
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetWorkspaceResponse
 */
async function getWorkspaceWithOptions(workspaceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetWorkspaceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetWorkspace',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspaceName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get Workspace
 *
 * @return GetWorkspaceResponse
 */
async function getWorkspace(workspaceName: string): GetWorkspaceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getWorkspaceWithOptions(workspaceName, headers, runtime);
}

model ListAddonReleasesRequest {
  addonName?: string(name='addonName', description='Addon component name.', example='cs-gpu'),
  parentAddonReleaseId?: string(name='parentAddonReleaseId', description='Parent AddonReleaseId.', example='policy-xxxxxxxxxxxxx'),
}

model ListAddonReleasesResponseBody = {
  releases?: [ 
    {
      addonName?: string(name='addonName', description='Addon name.', example='cs-gpu'),
      alertRuleCount?: long(name='alertRuleCount', description='Number of alert rules.', example='6'),
      apiVersion?: string(name='apiVersion', description='API version.', example='2023-03-30'),
      conditions?: [ 
        {
          firstTransitionTime?: string(name='firstTransitionTime', description='First transition time.', example='2024-11-04T16:10:22+08:00'),
          lastTransitionTime?: string(name='lastTransitionTime', description='Last transition time.', example='2024-11-04T16:10:22+08:00'),
          message?: string(name='message', description='Details.', example='The addon loaded successfully'),
          status?: string(name='status', description='Phase status.', example='True'),
          type?: string(name='type', description='Phase type.', example='Loaded'),
        }
      ](name='conditions', description='Installation phase information.'),
      config?: string(name='config', description='Component configuration information.', example='{"install":{"mode":"auto-install","listenPort":"9400"},"discoverMode":"instances","discover":{"instances":"worker-k8s-for-cs-c126d87c76218487e83ab322017f11b44"},"scrapeInterval":"15","enableSecuritecs-nodeyGroupInjection":"true","metricTags":""}'),
      createTime?: string(name='createTime', description='Access time.', example='2024-11-04T16:10:12+08:00'),
      dashboardCount?: long(name='dashboardCount', description='Number of dashboards.', example='3'),
      entityRules?: EntityGroupBase(name='entityRules', description='Entity details.'),
      envType?: string(name='envType', description='Environment type.', example='CS'),
      environmentId?: string(name='environmentId', description='Environment ID.', example='policy-xxxxxxxxxxxx'),
      exporterCount?: long(name='exporterCount', description='Number of plugins.', example='2'),
      haveConfig?: boolean(name='haveConfig', description='Whether there is a configuration.', example='true'),
      installUserId?: string(name='installUserId', description='Access user ID.', example='175xxxxxxxxx'),
      language?: string(name='language', description='Language.', example='zh'),
      managed?: boolean(name='managed', description='Whether it is a managed component.', example='true'),
      nextVersion?: string(name='nextVersion', description='Starting version number for the remaining list.', example='None'),
      parentAddonReleaseId?: string(name='parentAddonReleaseId', description='Parent AddonReleaseId.', example='policy-xxxxxxxxxxxxxx'),
      policyId?: string(name='policyId', description='Policy ID.', example='policy-xxxxxxxxxxxxxx'),
      regionId?: string(name='regionId', description='Region ID.', example='cn-hangzhou'),
      releaseId?: string(name='releaseId', description='Release ID.', example='7339d808-66f9-4d40-83fa-xxxxxxxxxxx'),
      releaseName?: string(name='releaseName', description='Release name.', example='test-gpu-integration-name'),
      scene?: string(name='scene', description='Component scenario.', example='container'),
      status?: string(name='status', description='Status.', example='running'),
      subAddonRelease?: {
        ready?: int32(name='ready', description='Number of ready sub-Releases.', example='2'),
        total?: int32(name='total', description='Number of sub-Releases.', example='3'),
      }(name='subAddonRelease', description='Sub-AddonRelease statistics.'),
      updateTime?: string(name='updateTime', description='Update time.', example='2024-11-04T16:10:23+08:00'),
      userId?: string(name='userId', description='Owner user ID.', example='175xxxxxxxxxxxxx'),
      version?: string(name='version', description='Component version.', example='0.0.2'),
      workspace?: string(name='workspace', description='Workspace.', example='default'),
    }
  ](name='releases', description='Set of add-on component information.'),
  requestId?: string(name='requestId', description='Request ID.', example='CD8BA7D6-995D-578D-9941-78B0FECD14B5'),
  total?: long(name='total', description='Number of components.', example='1'),
}

model ListAddonReleasesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAddonReleasesResponseBody(name='body'),
}

/**
 * @summary List of addon releases
 *
 * @description Query the list of access configurations
 *
 * @param request ListAddonReleasesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAddonReleasesResponse
 */
async function listAddonReleasesWithOptions(policyId: string, request: ListAddonReleasesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAddonReleasesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.addonName)) {
    query['addonName'] = request.addonName;
  }
  if (!Util.isUnset(request.parentAddonReleaseId)) {
    query['parentAddonReleaseId'] = request.parentAddonReleaseId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAddonReleases',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/integration-policies/${OpenApiUtil.getEncodeParam(policyId)}/addon-releases`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary List of addon releases
 *
 * @description Query the list of access configurations
 *
 * @param request ListAddonReleasesRequest
 * @return ListAddonReleasesResponse
 */
async function listAddonReleases(policyId: string, request: ListAddonReleasesRequest): ListAddonReleasesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAddonReleasesWithOptions(policyId, request, headers, runtime);
}

model ListAggTaskGroupsRequest {
  filterAggTaskGroupIds?: string(name='filterAggTaskGroupIds', description='List of IDs for the aggregation task groups, which must be JSON parseable.', example='["aggTaskGroup-xxx"]'),
  filterAggTaskGroupNames?: string(name='filterAggTaskGroupNames', description='List of names for the aggregation task groups, which must be JSON parseable.', example='["apiserver_request_total"]'),
  maxResults?: int32(name='maxResults', description='Maximum number of records to return.', example='20'),
  nextToken?: string(name='nextToken', description='Query token.', example='28036394xxx'),
  query?: string(name='query', description='Name search, supports fuzzy matching.', example='test'),
  status?: string(name='status', description='Status of the aggregation task group, either \\\\"Running\\\\" or \\\\"Stopped\\\\". Default is Running.', example='Running'),
  tags?: [ 
    {
      key?: string(name='key', description='Key of the resource group tag.', example='key1'),
      value?: string(name='value', description='Value of the resource group tag.', example='value1'),
    }
  ](name='tags', description='Resource group tags.'),
  targetPrometheusId?: string(name='targetPrometheusId', description='The target Prometheus instance ID for the aggregation task group.', example='rw-pq4apob9jm'),
}

model ListAggTaskGroupsShrinkRequest {
  filterAggTaskGroupIds?: string(name='filterAggTaskGroupIds', description='List of IDs for the aggregation task groups, which must be JSON parseable.', example='["aggTaskGroup-xxx"]'),
  filterAggTaskGroupNames?: string(name='filterAggTaskGroupNames', description='List of names for the aggregation task groups, which must be JSON parseable.', example='["apiserver_request_total"]'),
  maxResults?: int32(name='maxResults', description='Maximum number of records to return.', example='20'),
  nextToken?: string(name='nextToken', description='Query token.', example='28036394xxx'),
  query?: string(name='query', description='Name search, supports fuzzy matching.', example='test'),
  status?: string(name='status', description='Status of the aggregation task group, either \\\\"Running\\\\" or \\\\"Stopped\\\\". Default is Running.', example='Running'),
  tagsShrink?: string(name='tags', description='Resource group tags.'),
  targetPrometheusId?: string(name='targetPrometheusId', description='The target Prometheus instance ID for the aggregation task group.', example='rw-pq4apob9jm'),
}

model ListAggTaskGroupsResponseBody = {
  aggTaskGroups?: [ 
    {
      aggTaskGroupConfigHash?: string(name='aggTaskGroupConfigHash', description='Hash of the aggregation task group configuration.', example='a54136014xxx'),
      aggTaskGroupId?: string(name='aggTaskGroupId', description='ID of the aggregation task group.', example='aggTaskGroup-xxxx'),
      aggTaskGroupName?: string(name='aggTaskGroupName', description='Name of the aggregation task group.', example='pipeline-aggtask-group'),
      cronExpr?: string(name='cronExpr', description='Cron expression for the aggregation task group when the scheduling mode is set to \\\\"Cron\\\\".', example='0 10 8 1 * ? *'),
      delay?: int32(name='delay', description='Fixed delay time (in seconds) for scheduling.', example='30'),
      description?: string(name='description', description='Description of the aggregation task group.', example='workspace api monitor update test'),
      fromTime?: long(name='fromTime', description='Start time of the schedule in seconds since epoch.', example='1757409499000'),
      interval?: string(name='interval', description='Scheduling interval.', example='2025-04-24 00:00:00,2025-04-24 00:00:00'),
      maxRetries?: int32(name='maxRetries', description='Maximum number of retries for the aggregation task.', example='2'),
      maxRunTimeInSeconds?: int32(name='maxRunTimeInSeconds', description='Maximum retry time (in seconds) for the aggregation task.', example='200'),
      regionId?: string(name='regionId', description='Region ID.', example='cn-hangzhou'),
      scheduleMode?: string(name='scheduleMode', description='Scheduling mode.', example='FixedRate'),
      scheduleTimeExpr?: string(name='scheduleTimeExpr', description='Scheduling time expression.', example='@m'),
      sourcePrometheusId?: string(name='sourcePrometheusId', description='The source Prometheus instance ID of the aggregation task group.', example='rw-xxx'),
      status?: string(name='status', description='Status of the aggregation task group.', example='Running'),
      tags?: [ 
        {
          key?: string(name='key', description='Key of the resource group tag.', example='key1'),
          value?: string(name='value', description='Value of the resource group tag.', example='value1'),
        }
      ](name='tags', description='Resource group tags'),
      targetPrometheusId?: string(name='targetPrometheusId', description='The target Prometheus instance ID of the aggregation task group.', example='rw-xxx'),
      toTime?: long(name='toTime', description='The second-level timestamp corresponding to the end time of scheduling.', example='0'),
      updateTime?: string(name='updateTime', description='Update time of the aggregation task group.', example='1757409499000'),
    }
  ](name='aggTaskGroups', description='List of aggregation task groups.'),
  maxResults?: int32(name='maxResults', description='The maximum number of records returned.', example='100'),
  nextToken?: string(name='nextToken', description='Token for the next query.', example='aa9d0e569b880xxx'),
  requestId?: string(name='requestId', description='Request ID.', example='7BF1F4D6-B9A8-5F0B-8C1D-4347FFCB798E'),
  totalCount?: int32(name='totalCount', description='Total number of instances.', example='5'),
}

model ListAggTaskGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAggTaskGroupsResponseBody(name='body'),
}

/**
 * @summary List Aggregation Task Groups
 *
 * @param tmpReq ListAggTaskGroupsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAggTaskGroupsResponse
 */
async function listAggTaskGroupsWithOptions(instanceId: string, tmpReq: ListAggTaskGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAggTaskGroupsResponse {
  Util.validateModel(tmpReq);
  var request = new ListAggTaskGroupsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'tags', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.filterAggTaskGroupIds)) {
    query['filterAggTaskGroupIds'] = request.filterAggTaskGroupIds;
  }
  if (!Util.isUnset(request.filterAggTaskGroupNames)) {
    query['filterAggTaskGroupNames'] = request.filterAggTaskGroupNames;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.status)) {
    query['status'] = request.status;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.targetPrometheusId)) {
    query['targetPrometheusId'] = request.targetPrometheusId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAggTaskGroups',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/prometheus-instances/${OpenApiUtil.getEncodeParam(instanceId)}/agg-task-groups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary List Aggregation Task Groups
 *
 * @param request ListAggTaskGroupsRequest
 * @return ListAggTaskGroupsResponse
 */
async function listAggTaskGroups(instanceId: string, request: ListAggTaskGroupsRequest): ListAggTaskGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAggTaskGroupsWithOptions(instanceId, request, headers, runtime);
}

model ListAlertActionsRequest {
  alertActionIds?: [ string ](name='alertActionIds', description='Unique identifier for the action integration.'),
  alertActionName?: string(name='alertActionName', description='Name of the action integration.', example='testName'),
  pageNumber?: int32(name='pageNumber', description='Page number. Default is 1.', example='1'),
  pageSize?: int32(name='pageSize', description='Page size. Default is 100.', example='100'),
  type?: string(name='type', description='Type of the action integration.', example='FC'),
}

model ListAlertActionsShrinkRequest {
  alertActionIdsShrink?: string(name='alertActionIds', description='Unique identifier for the action integration.'),
  alertActionName?: string(name='alertActionName', description='Name of the action integration.', example='testName'),
  pageNumber?: int32(name='pageNumber', description='Page number. Default is 1.', example='1'),
  pageSize?: int32(name='pageSize', description='Page size. Default is 100.', example='100'),
  type?: string(name='type', description='Type of the action integration.', example='FC'),
}

model ListAlertActionsResponseBody = {
  alertActions?: [ 
    {
      alertActionId?: string(name='alertActionId', description='Unique identifier for the action integration.', example='test'),
      alertActionName?: string(name='alertActionName', description='Alert action name.', example='testName'),
      ebParam?: {
        ebSource?: string(name='ebSource', description='Event source.', example='test'),
        eventBusName?: string(name='eventBusName', description='Event bus name.', example='test'),
        regionId?: string(name='regionId', description='Region ID.', example='cn-heyuan'),
        subject?: string(name='subject', description='Subject.', example='test'),
      }(name='ebParam', description='Event Bridge parameters.'),
      essParam?: {
        essGroupId?: string(name='essGroupId', description='Elastic scaling group ID.', example='testId'),
        essRuleId?: string(name='essRuleId', description='Elastic scaling rule ID.', example='testId'),
        regionId?: string(name='regionId', description='Region ID.', example='cn-beijing'),
      }(name='essParam', description='Elastic scaling parameters.'),
      fc3Param?: {
        function?: string(name='function', description='Function name of the Function Compute service.', example='test'),
        qualifier?: string(name='qualifier', description='Version or alias of the function.', example='test'),
        regionId?: string(name='regionId', description='Region ID.', example='cn-qingdao'),
      }(name='fc3Param', description='Function Compute 3.0 parameters.'),
      fcParam?: {
        function?: string(name='function', description='Function name in the Function Compute service.', example='test'),
        regionId?: string(name='regionId', description='Region ID.', example='cn-beijing'),
        service?: string(name='service', description='Function Compute service name.', example='test'),
      }(name='fcParam', description='Function Compute parameters.'),
      mnsParam?: {
        mnsType?: string(name='mnsType', description='Resource type of the Lightweight Message Queue (formerly MNS).', example='queue'),
        name?: string(name='name', description='Resource name.

- If the resource type is queue, the resource name is the queue name.
- If the resource type is topic, the resource name is the topic name.', example='test'),
        regionId?: string(name='regionId', description='Region ID.', example='cn-hangzhou'),
      }(name='mnsParam', description='Lightweight Message Queue (formerly MNS) parameters.'),
      pagerDutyParam?: {
        key?: string(name='key', description='Integration key for PagerDuty.', example='fsfer4543t5t65g4t4'),
        url?: string(name='url', description='Integration webhook for PagerDuty. Supports V1 and V2 versions.', example='https://events.pagerduty.com/v2/enqueue'),
      }(name='pagerDutyParam', description='PagerDuty parameters'),
      slsParam?: {
        logstore?: string(name='logstore', description='Logstore name of the Log Service.', example='test'),
        project?: string(name='project', description='Log Service project name.', example='test'),
        regionId?: string(name='regionId', description='Region ID.', example='cn-hangzhou'),
      }(name='slsParam', description='Log Service parameters.'),
      type?: string(name='type', description='Action integration type.', example='FC'),
      webhookParam?: {
        contentType?: string(name='contentType', description='Data format, effective when the request method is POST.', example='JSON'),
        headers?: map[string]string(name='headers', description='Request headers.'),
        method?: string(name='method', description='Webhook request method.', example='GET'),
        url?: string(name='url', description='The URL address for the alarm callback.', example='http://www.test.com'),
      }(name='webhookParam', description='Webhook parameters'),
    }
  ](name='alertActions', description='List of alert action configurations.'),
  pageNumber?: long(name='pageNumber', description='Page number.', example='1'),
  pageSize?: long(name='pageSize', description='Page size.', example='100'),
  requestId?: string(name='requestId', description='Request ID.', example='8FDE2569-626B-5176-9844-28877A*****'),
  total?: int32(name='total', description='Total number of items.', example='9'),
}

model ListAlertActionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAlertActionsResponseBody(name='body'),
}

/**
 * @summary Query Alert Actions
 *
 * @param tmpReq ListAlertActionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAlertActionsResponse
 */
async function listAlertActionsWithOptions(tmpReq: ListAlertActionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAlertActionsResponse {
  Util.validateModel(tmpReq);
  var request = new ListAlertActionsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.alertActionIds)) {
    request.alertActionIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alertActionIds, 'alertActionIds', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.alertActionIdsShrink)) {
    query['alertActionIds'] = request.alertActionIdsShrink;
  }
  if (!Util.isUnset(request.alertActionName)) {
    query['alertActionName'] = request.alertActionName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlertActions',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/alertActions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Query Alert Actions
 *
 * @param request ListAlertActionsRequest
 * @return ListAlertActionsResponse
 */
async function listAlertActions(request: ListAlertActionsRequest): ListAlertActionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAlertActionsWithOptions(request, headers, runtime);
}

model ListIntegrationPoliciesRequest {
  addonName?: string(name='addonName', description='Addon Name.', example='cs-default'),
  bindResourceId?: string(name='bindResourceId', description='Bound Resource ID.', example='622d27c2e87d49debceeebc7c642610e'),
  entityGroupIds?: string(name='entityGroupIds', description='Filter for entity IDs, separated by commas.', example='eg-1,eg-2,eg-3'),
  filterRegionIds?: string(name='filterRegionIds', description='Used for Region query, separated by commas.', example='cn-beijing,cn-hangzhou'),
  maxResults?: int32(name='maxResults', description='Maximum number of results to return, default is 30, with a maximum of 100.', example='30'),
  nextToken?: string(name='nextToken', description='Used to return more results. This parameter is not required for the first query; for subsequent queries, use the Token obtained from the previous response.', example='mvnX6zqg3P'),
  policyId?: string(name='policyId', description='Policy ID.', example='policy-93817a401f78435596d745a97d2e85a1'),
  policyName?: string(name='policyName', description='Rule Name.', example='prod-database'),
  policyType?: string(name='policyType', description='Policy Type', example='CS'),
  prometheusInstanceId?: string(name='prometheusInstanceId', description='Instance ID.', example='cmee-622d27c2e87d49debceeebc7c642610e'),
  query?: string(name='query', description='Used for general queries.', example='test'),
  resourceGroupId?: string(name='resourceGroupId', description='Resource Group ID.', example='rg-xxxxx'),
  tag?: [ 
    {
      key?: string(name='key', description='Tag key', example='test'),
      value?: string(name='value', description='Tag value', example='value'),
    }
  ](name='tag', description='Tag list.'),
  workspace?: string(name='workspace', description='Workspace.', example='demo'),
}

model ListIntegrationPoliciesShrinkRequest {
  addonName?: string(name='addonName', description='Addon Name.', example='cs-default'),
  bindResourceId?: string(name='bindResourceId', description='Bound Resource ID.', example='622d27c2e87d49debceeebc7c642610e'),
  entityGroupIds?: string(name='entityGroupIds', description='Filter for entity IDs, separated by commas.', example='eg-1,eg-2,eg-3'),
  filterRegionIds?: string(name='filterRegionIds', description='Used for Region query, separated by commas.', example='cn-beijing,cn-hangzhou'),
  maxResults?: int32(name='maxResults', description='Maximum number of results to return, default is 30, with a maximum of 100.', example='30'),
  nextToken?: string(name='nextToken', description='Used to return more results. This parameter is not required for the first query; for subsequent queries, use the Token obtained from the previous response.', example='mvnX6zqg3P'),
  policyId?: string(name='policyId', description='Policy ID.', example='policy-93817a401f78435596d745a97d2e85a1'),
  policyName?: string(name='policyName', description='Rule Name.', example='prod-database'),
  policyType?: string(name='policyType', description='Policy Type', example='CS'),
  prometheusInstanceId?: string(name='prometheusInstanceId', description='Instance ID.', example='cmee-622d27c2e87d49debceeebc7c642610e'),
  query?: string(name='query', description='Used for general queries.', example='test'),
  resourceGroupId?: string(name='resourceGroupId', description='Resource Group ID.', example='rg-xxxxx'),
  tagShrink?: string(name='tag', description='Tag list.'),
  workspace?: string(name='workspace', description='Workspace.', example='demo'),
}

model ListIntegrationPoliciesResponseBody = {
  maxResults?: int32(name='maxResults', description='Page size
Default value:
	50
Maximum value:
	50', example='100'),
  nextToken?: string(name='nextToken', description='Pagination Token', example='44ANBjKZmQeKnaB1fXRq06w7sFYK3MUcCALMD9qQbmEiE'),
  policies?: [ 
    {
      bindResource?: {
        clusterId?: string(name='clusterId', description='Cluster ID.', example='cv68tt87d78vyc89zy9v'),
        clusterType?: string(name='clusterType', description='Cluster type.', example='ManagedKubernetes'),
        vpcCidr?: string(name='vpcCidr', description='VPC CIDR', example='100.100.0.1/16'),
        vpcId?: string(name='vpcId', description='Virtual Private Cloud (VPC).', example='vpc-uf664nyle5khp5d4d7hdo'),
      }(name='bindResource', description='Bound resource information'),
      csUmodelStatus?: boolean(name='csUmodelStatus', description='Cs Umodel Status', example='true'),
      entityGroup?: {
        description?: string(name='description', description='Description.', example='xxxx'),
        entityGroupId?: string(name='entityGroupId', description='Entity group ID', example='eg-b79f65d11fb94e779867cf937c3a3002'),
        entityGroupName?: string(name='entityGroupName', description='Entity group name', example='test-eg'),
        entityRules?: {
          annotations?: [ 
            {
              op?: string(name='op', description='Operation to be performed.', example='add'),
              tagKey?: string(name='tagKey', description='Tag key', example='key'),
              tagValues?: [ string ](name='tagValues', description='Tag values'),
            }
          ](name='annotations', description='Annotations'),
          entityTypes?: [ string ](name='entityTypes', description='List of entity types'),
          fieldRules?: [ 
            {
              fieldKey?: string(name='fieldKey', description='Unique identifier for the field.', example='test'),
              fieldValues?: [ string ](name='fieldValues', description='Field content, multiple values separated by commas.'),
              op?: string(name='op', description='Operation to be performed.', example='add'),
            }
          ](name='fieldRules', description='Field rules'),
          instanceIds?: [ string ](name='instanceIds', description='Instance IDs.'),
          ipMatchRule?: {
            ipCidr?: string(name='ipCidr', description='IP segment', example='100.100.1.0/16'),
            ipFieldKey?: string(name='ipFieldKey', description='Key of the IP field', example='xxxx'),
          }(name='ipMatchRule', description='IP match rule'),
          labels?: [ 
            {
              op?: string(name='op', description='Operation to be performed.', example='add'),
              tagKey?: string(name='tagKey', description='Tag key.', example='test'),
              tagValues?: [ string ](name='tagValues', description='Tag values'),
            }
          ](name='labels', description='Labels'),
          regionIds?: [ string ](name='regionIds', description='List of region IDs'),
          resourceGroupId?: string(name='resourceGroupId', description='Resource group ID.', example='rg-5i6dbwxfxuqihk7k'),
          tags?: [ 
            {
              op?: string(name='op', description='Operation to be performed.', example='add'),
              tagKey?: string(name='tagKey', description='Tag key.', example='key'),
              tagValues?: [ string ](name='tagValues', description='Tag value.'),
            }
          ](name='tags', description='Instance tag information.'),
        }(name='entityRules', description='Entity group'),
        query?: string(name='query', description='Search keyword, supports document library name and description', example='哈弗'),
        regionId?: string(name='regionId', description='Region ID.', example='cn-heyuan'),
        userId?: string(name='userId', description='User ID', example='1236812738'),
        workspace?: string(name='workspace', description='Workspace.', example='test-api'),
      }(name='entityGroup', description='Entity group'),
      feePackage?: string(name='feePackage'),
      managedInfo?: {
        eniId?: string(name='eniId', description='ENI card ID of the managed probe. For example: eni-xxxx.', example='eni-12345678'),
        securityGroupId?: string(name='securityGroupId', description='Security group ID', example='sg-xxxxx'),
        vswitchId?: string(name='vswitchId', description='VSwitch ID.', example='vsw-xxxxxx'),
      }(name='managedInfo', description='Policy network management information.'),
      policyId?: string(name='policyId', description='Policy ID.', example='policy-ac38a7cb02d14ff48bc9f97d0a75063e'),
      policyName?: string(name='policyName', description='Rule name.', example='6f5HSsg3AP'),
      policyType?: string(name='policyType', description='Access center policy type', example='ECS'),
      regionId?: string(name='regionId', description='Region ID.', example='cn-heyuan'),
      resourceGroupId?: string(name='resourceGroupId', description='Resource group ID.', example='rg-xxxxx'),
      subAddonRelease?: {
        ready?: int32(name='ready', description='Number of ready sub-releases', example='30'),
        total?: int32(name='total', description='Number of rules.', example='278'),
      }(name='subAddonRelease', description='Number of sub-releases'),
      tags?: [ 
        {
          key?: string(name='key', description='Tag key', example='key'),
          value?: string(name='value', description='Match value.', example='value'),
        }
      ](name='tags', description='Resource tag key values.'),
      userId?: string(name='userId', description='User ID', example='128470923'),
      workspace?: string(name='workspace', description='Workspace.', example='test-api'),
    }
  ](name='policies', description='Access policy list'),
  requestId?: string(name='requestId', description='ID of the request', example='CD8BA7D6-995D-578D-9941-78B0FECD14B5'),
  totalCount?: int32(name='totalCount', description='Total number of entries', example='0'),
}

model ListIntegrationPoliciesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListIntegrationPoliciesResponseBody(name='body'),
}

/**
 * @summary Query Access Center Policy List Information
 *
 * @description Query Integration List
 *
 * @param tmpReq ListIntegrationPoliciesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListIntegrationPoliciesResponse
 */
async function listIntegrationPoliciesWithOptions(tmpReq: ListIntegrationPoliciesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIntegrationPoliciesResponse {
  Util.validateModel(tmpReq);
  var request = new ListIntegrationPoliciesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tag)) {
    request.tagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tag, 'tag', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.addonName)) {
    query['addonName'] = request.addonName;
  }
  if (!Util.isUnset(request.bindResourceId)) {
    query['bindResourceId'] = request.bindResourceId;
  }
  if (!Util.isUnset(request.entityGroupIds)) {
    query['entityGroupIds'] = request.entityGroupIds;
  }
  if (!Util.isUnset(request.filterRegionIds)) {
    query['filterRegionIds'] = request.filterRegionIds;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.policyId)) {
    query['policyId'] = request.policyId;
  }
  if (!Util.isUnset(request.policyName)) {
    query['policyName'] = request.policyName;
  }
  if (!Util.isUnset(request.policyType)) {
    query['policyType'] = request.policyType;
  }
  if (!Util.isUnset(request.prometheusInstanceId)) {
    query['prometheusInstanceId'] = request.prometheusInstanceId;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tagShrink)) {
    query['tag'] = request.tagShrink;
  }
  if (!Util.isUnset(request.workspace)) {
    query['workspace'] = request.workspace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIntegrationPolicies',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/integration-policies`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Query Access Center Policy List Information
 *
 * @description Query Integration List
 *
 * @param request ListIntegrationPoliciesRequest
 * @return ListIntegrationPoliciesResponse
 */
async function listIntegrationPolicies(request: ListIntegrationPoliciesRequest): ListIntegrationPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIntegrationPoliciesWithOptions(request, headers, runtime);
}

model ListIntegrationPolicyCustomScrapeJobRulesRequest {
  addonReleaseName?: string(name='addonReleaseName', description='Addon Release name.', example='release12345678'),
  encryptYaml?: boolean(name='encryptYaml', description='Whether to encrypt Yaml.', example='true'),
  namespace?: string(name='namespace', description='Namespace.', example='arms-prom'),
}

model ListIntegrationPolicyCustomScrapeJobRulesResponseBody = {
  clusterId?: string(name='clusterId', description='Cluster ID.', example='et15prod-et15storage'),
  customScrapeJobRules?: [ 
    {
      addonName?: string(name='addonName', description='Addon name.', example='cloud-ecs'),
      addonReleaseName?: string(name='addonReleaseName', description='Addon Release name', example='release-12345678'),
      addonVersion?: string(name='addonVersion', description='Addon version', example='0.0.1'),
      configYaml?: string(name='configYaml', description='Configuration yaml', example='scrape_cofnigs:
- jobxxxxxx'),
      enableStatus?: string(name='enableStatus', description='Enable status', example='mini'),
      encryptYaml?: boolean(name='encryptYaml', description='Encrypt yaml', example='true'),
      matchedPodCount?: long(name='matchedPodCount', description='Matched pod count', example='1'),
      message?: string(name='message', description='Detailed information.', example='ok'),
      name?: string(name='name', description='Service name.', example='dlab1'),
      namespace?: string(name='namespace', description='Namespace', example='prod-data'),
      scrapeConfigs?: [ 
        {
          jobName?: string(name='jobName', description='Scraping job name', example='mysql-exporter'),
          message?: string(name='message', description='Detailed information.', example='successful'),
          metricsPath?: string(name='metricsPath', description='Metrics path', example='/metrics'),
          scheme?: string(name='scheme', description='Call method.', example='http'),
          scrapeInterval?: string(name='scrapeInterval', description='Scrape interval', example='30s'),
          scrapeTimeout?: string(name='scrapeTimeout', description='Scrape timeout', example='60s'),
          serviceDiscoveryConfigs?: [ string ](name='serviceDiscoveryConfigs', description='Service discovery configuration'),
        }
      ](name='scrapeConfigs', description='Custom configurations'),
    }
  ](name='customScrapeJobRules', description='Custom scraping job rules'),
  policyId?: string(name='policyId', description='Policy ID.', example='policy-15abcc24c06f4797832b5954198e1ed1'),
  requestId?: string(name='requestId', description='ID of the request', example='0CEC5375-C554-562B-A65F-9A629907C1F0'),
}

model ListIntegrationPolicyCustomScrapeJobRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListIntegrationPolicyCustomScrapeJobRulesResponseBody(name='body'),
}

/**
 * @summary Get storage requirement information for the access center policy
 *
 * @param request ListIntegrationPolicyCustomScrapeJobRulesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListIntegrationPolicyCustomScrapeJobRulesResponse
 */
async function listIntegrationPolicyCustomScrapeJobRulesWithOptions(policyId: string, request: ListIntegrationPolicyCustomScrapeJobRulesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIntegrationPolicyCustomScrapeJobRulesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.addonReleaseName)) {
    query['addonReleaseName'] = request.addonReleaseName;
  }
  if (!Util.isUnset(request.encryptYaml)) {
    query['encryptYaml'] = request.encryptYaml;
  }
  if (!Util.isUnset(request.namespace)) {
    query['namespace'] = request.namespace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIntegrationPolicyCustomScrapeJobRules',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/integration-policies/${OpenApiUtil.getEncodeParam(policyId)}/custom-scrape-job-rules`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get storage requirement information for the access center policy
 *
 * @param request ListIntegrationPolicyCustomScrapeJobRulesRequest
 * @return ListIntegrationPolicyCustomScrapeJobRulesResponse
 */
async function listIntegrationPolicyCustomScrapeJobRules(policyId: string, request: ListIntegrationPolicyCustomScrapeJobRulesRequest): ListIntegrationPolicyCustomScrapeJobRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIntegrationPolicyCustomScrapeJobRulesWithOptions(policyId, request, headers, runtime);
}

model ListIntegrationPolicyDashboardsRequest {
  addonName?: string(name='addonName', description='Addon Name.', example='cs-default'),
  language?: string(name='language', description='Query Language', example='zh'),
  scene?: string(name='scene', description='Component Scenario.', example='databse'),
}

model ListIntegrationPolicyDashboardsResponseBody = {
  dashboards?: [ 
    {
      engine?: string(name='engine', description='Dashboard engine:
grafana: shared grafana.
cms: cms self-developed dashboard engine.', example='grafana'),
      folderUid?: string(name='folderUid', description='UID of the dashboard folder.', example='Env-AAA'),
      name?: string(name='name', description='Dashboard name', example='k8s-pod'),
      region?: string(name='region', description='Region', example='cn-hongkong'),
      tags?: [ string ](name='tags', description='List of tags.'),
      title?: string(name='title', description='Title of the UI module (not name)', example='test'),
      uid?: string(name='uid', description='ID of the current Alibaba Cloud primary account, read-only', example='1258199346721590'),
      url?: string(name='url', description='pagerDuty integration webhook. Supports V1 and V2 versions', example='https://agi.alicdn.com/user/0/0_0_5255362686.png?x-oss-process=image/quality,q_75/format,jpg&file=1734574878007.jpg'),
    }
  ](name='dashboards', description='List of dashboards.'),
  requestId?: string(name='requestId', description='ID of the request', example='CD8BA7D6-995D-578D-9941-78B0FECD14B5'),
  total?: int32(name='total', description='Number of components.', example='1'),
}

model ListIntegrationPolicyDashboardsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListIntegrationPolicyDashboardsResponseBody(name='body'),
}

/**
 * @summary Policy Dashboard List
 *
 * @description This article provides an example of querying the alarm template list. The result shows that there are 2 alarm templates in the list, which are `ECS_Template1` and `ECS_Template2`.
 *
 * @param request ListIntegrationPolicyDashboardsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListIntegrationPolicyDashboardsResponse
 */
async function listIntegrationPolicyDashboardsWithOptions(policyId: string, request: ListIntegrationPolicyDashboardsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIntegrationPolicyDashboardsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.addonName)) {
    query['addonName'] = request.addonName;
  }
  if (!Util.isUnset(request.language)) {
    query['language'] = request.language;
  }
  if (!Util.isUnset(request.scene)) {
    query['scene'] = request.scene;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIntegrationPolicyDashboards',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/integration-policies/${OpenApiUtil.getEncodeParam(policyId)}/dashboards`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Policy Dashboard List
 *
 * @description This article provides an example of querying the alarm template list. The result shows that there are 2 alarm templates in the list, which are `ECS_Template1` and `ECS_Template2`.
 *
 * @param request ListIntegrationPolicyDashboardsRequest
 * @return ListIntegrationPolicyDashboardsResponse
 */
async function listIntegrationPolicyDashboards(policyId: string, request: ListIntegrationPolicyDashboardsRequest): ListIntegrationPolicyDashboardsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIntegrationPolicyDashboardsWithOptions(policyId, request, headers, runtime);
}

model ListIntegrationPolicyPodMonitorsRequest {
  addonReleaseName?: string(name='addonReleaseName', description='Addon Release name.', example='release-123456789'),
  encryptYaml?: boolean(name='encryptYaml', description='Whether to encrypt Yaml.', example='true'),
  namespace?: string(name='namespace', description='Namespace.', example='default'),
}

model ListIntegrationPolicyPodMonitorsResponseBody = {
  clusterId?: string(name='clusterId', description='Cluster ID.', example='et15prod-et15storage'),
  podMonitors?: [ 
    {
      addonName?: string(name='addonName', description='Addon name.', example='cloud-ecs'),
      addonReleaseName?: string(name='addonReleaseName', description='Addon Release name.', example='release-2345678'),
      addonVersion?: string(name='addonVersion', description='Addon version.', example='0.0.1'),
      configYaml?: string(name='configYaml', description='Configuration yaml.', example='apiVersion: xxxxx'),
      enableStatus?: string(name='enableStatus', description='Enable status.', example='run'),
      encryptYaml?: boolean(name='encryptYaml', description='Encrypt yaml.', example='YXBpVmVyc2lvbjogeHh4eHgK'),
      endpoints?: [ 
        {
          interval?: string(name='interval', description='Collection interval', example='30s'),
          matchedTargetCount?: long(name='matchedTargetCount', description='Number of matched targets', example='1'),
          path?: string(name='path', description='Metric collection path', example='/metrics'),
          port?: string(name='port', description='Port number', example='9100'),
          targetPort?: string(name='targetPort', description='Target port', example='https'),
        }
      ](name='endpoints', description='Instance endpoints.'),
      matchedPodCount?: long(name='matchedPodCount', description='Number of matched pods', example='3'),
      name?: string(name='name', description='Collection name.', example='znzmo_entity_test'),
      namespace?: string(name='namespace', description='Namespace', example='sla-ns-d5aeb2b4f91b47'),
    }
  ](name='podMonitors', description='PodMonitor list'),
  policyId?: string(name='policyId', description='Policy ID.', example='policy-c9efed2b99c348d49e589c5f780fc074'),
  requestId?: string(name='requestId', description='ID of the request', example='CD8BA7D6-995D-578D-9941-78B0FECD14B5'),
}

model ListIntegrationPolicyPodMonitorsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListIntegrationPolicyPodMonitorsResponseBody(name='body'),
}

/**
 * @summary Get PodMonitor Resources of Access Center Policy
 *
 * @description This article provides an example to query the alarm template list. The result shows that there are 2 alarm templates in the alarm template list, which are `ECS_Template1` and `ECS_Template2`.
 *
 * @param request ListIntegrationPolicyPodMonitorsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListIntegrationPolicyPodMonitorsResponse
 */
async function listIntegrationPolicyPodMonitorsWithOptions(policyId: string, request: ListIntegrationPolicyPodMonitorsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIntegrationPolicyPodMonitorsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.addonReleaseName)) {
    query['addonReleaseName'] = request.addonReleaseName;
  }
  if (!Util.isUnset(request.encryptYaml)) {
    query['encryptYaml'] = request.encryptYaml;
  }
  if (!Util.isUnset(request.namespace)) {
    query['namespace'] = request.namespace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIntegrationPolicyPodMonitors',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/integration-policies/${OpenApiUtil.getEncodeParam(policyId)}/pod-monitors`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get PodMonitor Resources of Access Center Policy
 *
 * @description This article provides an example to query the alarm template list. The result shows that there are 2 alarm templates in the alarm template list, which are `ECS_Template1` and `ECS_Template2`.
 *
 * @param request ListIntegrationPolicyPodMonitorsRequest
 * @return ListIntegrationPolicyPodMonitorsResponse
 */
async function listIntegrationPolicyPodMonitors(policyId: string, request: ListIntegrationPolicyPodMonitorsRequest): ListIntegrationPolicyPodMonitorsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIntegrationPolicyPodMonitorsWithOptions(policyId, request, headers, runtime);
}

model ListIntegrationPolicyStorageRequirementsRequest {
  addonName?: string(name='addonName', description='Addon Release Name', example='release-1234357'),
  addonReleaseName?: string(name='addonReleaseName', description='Name of AddonRelease.', example='kafka-17201012937917'),
  storageType?: string(name='storageType', description='Storage Type, LogStore/Prometheus/TraceStore/EventStore/EntityStore.', example='LogStore'),
}

model ListIntegrationPolicyStorageRequirementsResponseBody = {
  requestId?: string(name='requestId', description='ID of the request', example='0CEC5375-C554-562B-A65F-9A629907C1F0'),
  storageRequirements?: [ 
    {
      addonReleaseNames?: [ string ](name='addonReleaseNames', description='Collection of AddonReleases.'),
      apiVersion?: string(name='apiVersion', description='API Version', example='v1'),
      kind?: string(name='kind', description='Resource kind', example='Pod'),
      metadata?: {
        annotations?: map[string]string(name='annotations', description='Annotations'),
        labels?: map[string]string(name='labels', description='Resource labels'),
        name?: string(name='name', description='Resource name', example='pod-1234567'),
        namespace?: string(name='namespace', description='Namespace', example='arms-prom'),
      }(name='metadata', description='Metadata'),
      spec?: {
        entityId?: string(name='entityId', description='Instance ID, which can be specified if you need to pinpoint to the instance level. It depends on the data in EntityStore.', example='es-xxxxx'),
        instance?: string(name='instance', description='Prom Instance ID.', example='i-bp122p85gthbniw8rsu9'),
        instanceName?: string(name='instanceName', description='Prom instance name', example='category_predict'),
        project?: string(name='project', description='Optional parameter, determined based on the current environment type', example='datagrid_cdm'),
        region?: string(name='region', description='Region', example='cn-shenzhen'),
        shareScope?: string(name='shareScope', description='Storage sharing scope: Environment | Region | Workspace | Custom', example='Region'),
        storageType?: string(name='storageType', description='Instance storage type', example='Prometheus'),
        systemTags?: map[string]string(name='systemTags', description='Tags to be applied to the target storage (injected as system tags)'),
        tags?: map[string]string(name='tags', description='Tags to be applied to the target storage (injected as regular tags)'),
        userId?: string(name='userId', description='User ID', example='12345678'),
        workspace?: string(name='workspace', description='Workspace', example='test-api'),
      }(name='spec', description='Resource spec'),
      status?: {
        instanceId?: string(name='instanceId', description='Instance ID', example='rmq-cn-uqm3ket1t0u'),
        interUrl?: string(name='interUrl', description='Internal URL', example='http://192.168.xxxxxx'),
        intraUrl?: string(name='intraUrl', description='External URL', example='http://100.100.xxxxxx'),
        name?: string(name='name', description='存储需求名称', example='sr-xxxx'),
        project?: string(name='project', description='存储需求项目', example='jiuwu_algo'),
        promMetricStore?: string(name='promMetricStore', description='Prom\\\\"s metric center', example='xxxx'),
        region?: string(name='region', description='Region', example='cn-hangzhou'),
        storageType?: string(name='storageType', description='Instance storage type', example='Prometheus'),
        workspace?: string(name='workspace', description='Workspace.', example='default'),
      }(name='status', description='Storage requirement status'),
    }
  ](name='storageRequirements', description='List of storage requirements'),
}

model ListIntegrationPolicyStorageRequirementsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListIntegrationPolicyStorageRequirementsResponseBody(name='body'),
}

/**
 * @summary Get Storage Requirements Information for Access Center Policy
 *
 * @description During the effective period of the policy, all alarms within the application group will no longer send notifications.
 *  
 * This article provides an example of creating a pause alarm notification policy `PauseNotify` for the application group `7301****`. This application group will pause alarms from `1622949300000` to `1623208500000` (Beijing Time `2021-06-06 11:15:00` to `2021-06-09 11:15:00`).
 *
 * @param request ListIntegrationPolicyStorageRequirementsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListIntegrationPolicyStorageRequirementsResponse
 */
async function listIntegrationPolicyStorageRequirementsWithOptions(policyId: string, request: ListIntegrationPolicyStorageRequirementsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIntegrationPolicyStorageRequirementsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.addonName)) {
    query['addonName'] = request.addonName;
  }
  if (!Util.isUnset(request.addonReleaseName)) {
    query['addonReleaseName'] = request.addonReleaseName;
  }
  if (!Util.isUnset(request.storageType)) {
    query['storageType'] = request.storageType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIntegrationPolicyStorageRequirements',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/integration-policies/${OpenApiUtil.getEncodeParam(policyId)}/storage-requirements`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get Storage Requirements Information for Access Center Policy
 *
 * @description During the effective period of the policy, all alarms within the application group will no longer send notifications.
 *  
 * This article provides an example of creating a pause alarm notification policy `PauseNotify` for the application group `7301****`. This application group will pause alarms from `1622949300000` to `1623208500000` (Beijing Time `2021-06-06 11:15:00` to `2021-06-09 11:15:00`).
 *
 * @param request ListIntegrationPolicyStorageRequirementsRequest
 * @return ListIntegrationPolicyStorageRequirementsResponse
 */
async function listIntegrationPolicyStorageRequirements(policyId: string, request: ListIntegrationPolicyStorageRequirementsRequest): ListIntegrationPolicyStorageRequirementsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIntegrationPolicyStorageRequirementsWithOptions(policyId, request, headers, runtime);
}

model ListPrometheusDashboardsRequest {
  aliyunLang?: string(name='aliyunLang', description='Language environment, default is Chinese zh | en', example='zh'),
  resourceGroupId?: string(name='resourceGroupId', description='Resource Group ID.', example='rg-acfm3gn5i6bigbi'),
}

model ListPrometheusDashboardsResponseBody = {
  prometheusDashboards?: [ 
    {
      id?: string(name='id', description='Dashboard ID.', example='1'),
      name?: string(name='name', description='Dashboard name.', example='pod'),
      tags?: [ string ](name='tags', description='Tags.'),
      title?: string(name='title', description='Dashboard title.', example='ceshi'),
      uid?: string(name='uid', description='Dashboard UID.', example='1987395500251724'),
      url?: string(name='url', description='Dashboard URL address.', example='https://gnew.console.aliyun.com/d/xxx-17460385-807-7-6/cs-cost-application'),
    }
  ](name='prometheusDashboards', description='List of Prometheus instance dashboards.'),
  requestId?: string(name='requestId', description='ID of the request', example='8FDE2569-626B-5176-9844-28877A*****'),
  totalCount?: int32(name='totalCount', description='Total number of instances', example='66'),
}

model ListPrometheusDashboardsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPrometheusDashboardsResponseBody(name='body'),
}

/**
 * @summary Get Prometheus Instance Dashboard List
 *
 * @description Get the list of Prometheus instance dashboards.
 *
 * @param request ListPrometheusDashboardsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPrometheusDashboardsResponse
 */
async function listPrometheusDashboardsWithOptions(prometheusInstanceId: string, request: ListPrometheusDashboardsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPrometheusDashboardsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.aliyunLang)) {
    query['aliyunLang'] = request.aliyunLang;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrometheusDashboards',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/prometheus-instances/${OpenApiUtil.getEncodeParam(prometheusInstanceId)}/dashboards`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get Prometheus Instance Dashboard List
 *
 * @description Get the list of Prometheus instance dashboards.
 *
 * @param request ListPrometheusDashboardsRequest
 * @return ListPrometheusDashboardsResponse
 */
async function listPrometheusDashboards(prometheusInstanceId: string, request: ListPrometheusDashboardsRequest): ListPrometheusDashboardsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPrometheusDashboardsWithOptions(prometheusInstanceId, request, headers, runtime);
}

model ListPrometheusInstancesRequest {
  filterRegionIds?: string(name='filterRegionIds', description='Specified list of regionIds to filter (comma-separated).', example='cn-shenzhen', nullable=true),
  maxResults?: int32(name='maxResults', description='Maximum number of records to return.', example='10', nullable=true),
  nextToken?: string(name='nextToken', description='Query token.', example='xxxxxxxxxx', nullable=true),
  prometheusInstanceIds?: string(name='prometheusInstanceIds', description='List of instance IDs (comma-separated)', example='rw-00001,rw-00002,rw-00003', nullable=true),
  prometheusInstanceName?: string(name='prometheusInstanceName', description='Instance name (partial match supported)', example='test', nullable=true),
  resourceGroupId?: string(name='resourceGroupId', description='Resource group ID.', example='rg-aek2bhocin5e2na'),
  resourceType?: string(name='resourceType', description='Resource type of the instance.', example='Prometheus', nullable=true),
  tag?: [ 
    {
      key?: string(name='key', description='Tag key', example='testKey'),
      value?: string(name='value', description='Tag value.', example='testValue'),
    }
  ](name='tag', description='List of tags.'),
  version?: string(name='version', description='Instance version: V1 or V2', example='V2', nullable=true),
}

model ListPrometheusInstancesShrinkRequest {
  filterRegionIds?: string(name='filterRegionIds', description='Specified list of regionIds to filter (comma-separated).', example='cn-shenzhen', nullable=true),
  maxResults?: int32(name='maxResults', description='Maximum number of records to return.', example='10', nullable=true),
  nextToken?: string(name='nextToken', description='Query token.', example='xxxxxxxxxx', nullable=true),
  prometheusInstanceIds?: string(name='prometheusInstanceIds', description='List of instance IDs (comma-separated)', example='rw-00001,rw-00002,rw-00003', nullable=true),
  prometheusInstanceName?: string(name='prometheusInstanceName', description='Instance name (partial match supported)', example='test', nullable=true),
  resourceGroupId?: string(name='resourceGroupId', description='Resource group ID.', example='rg-aek2bhocin5e2na'),
  resourceType?: string(name='resourceType', description='Resource type of the instance.', example='Prometheus', nullable=true),
  tagShrink?: string(name='tag', description='List of tags.'),
  version?: string(name='version', description='Instance version: V1 or V2', example='V2', nullable=true),
}

model ListPrometheusInstancesResponseBody = {
  maxResults?: int32(name='maxResults', description='Maximum number of records to return.', example='10', nullable=true),
  nextToken?: string(name='nextToken', description='Token for the next query.', example='xxxxxxxxxx'),
  prometheusInstances?: [ 
    {
      accessType?: string(name='accessType', description='Access type:
readWrite, readOnly, httpReadOnly', example='readWrite'),
      createTime?: string(name='createTime', description='Instance creation time, using UTC+0 time, formatted as yyyy-MM-ddTHH:mmZ', example='2025-08-10T02:07:53Z'),
      instanceType?: string(name='instanceType', description='Instance type.', example='remote-write'),
      paymentType?: string(name='paymentType', description='POSTPAY: Postpaid by metric.
POSTPAY_GB: Postpaid by write volume.
PREPAY: Prepaid.
FREE: Free.', example='POSTPAY_GB'),
      product?: string(name='product', description='Product to which the prom instance belongs', example='arms'),
      prometheusInstanceId?: string(name='prometheusInstanceId', description='Instance ID.', example='rw-63549e054ff596a4149927961dff'),
      prometheusInstanceName?: string(name='prometheusInstanceName', description='Instance name.', example='test-prom-name'),
      regionId?: string(name='regionId', description='Region ID', example='cn-nanjing'),
      resourceGroupId?: string(name='resourceGroupId', description='Resource group ID.', example='rg-aek2bhocin5e2na'),
      resourceType?: string(name='resourceType', description='Resource type.', example='Prometheus'),
      status?: string(name='status', description='Backend data storage status', example='Pending2Running'),
      supportAuthTypes?: [ string ](name='supportAuthTypes', description='Supported authentication types.'),
      tags?: [ 
        {
          key?: string(name='key', description='Tag key', example='testKey'),
          value?: string(name='value', description='Tag value.', example='testValue'),
        }
      ](name='tags', description='Tags key.'),
      userId?: string(name='userId', description='User ID.', example='17073812345'),
      version?: string(name='version', description='Version', example='*'),
      workspace?: string(name='workspace', description='Workspace to which the Prometheus instance belongs', example='default-cms-115214006-cn-hangzhou'),
    }
  ](name='prometheusInstances', description='List of Prometheus instances.'),
  requestId?: string(name='requestId', description='ID of the request', example='264C3E89-XXXX-XXXX-XXXX-CE9C2196C7DC'),
  totalCount?: int32(name='totalCount', description='Total number of instances', example='66'),
}

model ListPrometheusInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPrometheusInstancesResponseBody(name='body'),
}

/**
 * @summary Get the list of Prometheus instance information
 *
 * @description Get the list of Prometheus instances.
 *
 * @param tmpReq ListPrometheusInstancesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPrometheusInstancesResponse
 */
async function listPrometheusInstancesWithOptions(tmpReq: ListPrometheusInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPrometheusInstancesResponse {
  Util.validateModel(tmpReq);
  var request = new ListPrometheusInstancesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tag)) {
    request.tagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tag, 'tag', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.filterRegionIds)) {
    query['filterRegionIds'] = request.filterRegionIds;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prometheusInstanceIds)) {
    query['prometheusInstanceIds'] = request.prometheusInstanceIds;
  }
  if (!Util.isUnset(request.prometheusInstanceName)) {
    query['prometheusInstanceName'] = request.prometheusInstanceName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagShrink)) {
    query['tag'] = request.tagShrink;
  }
  if (!Util.isUnset(request.version)) {
    query['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrometheusInstances',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/prometheus-instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get the list of Prometheus instance information
 *
 * @description Get the list of Prometheus instances.
 *
 * @param request ListPrometheusInstancesRequest
 * @return ListPrometheusInstancesResponse
 */
async function listPrometheusInstances(request: ListPrometheusInstancesRequest): ListPrometheusInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPrometheusInstancesWithOptions(request, headers, runtime);
}

model ListPrometheusViewsRequest {
  filterRegionIds?: string(name='filterRegionIds', description='Filter by RegionID.', example='cn-zhangjiakou,cn-beijing'),
  maxResults?: int32(name='maxResults', description='Maximum number of records to return.', example='100', nullable=true),
  nextToken?: string(name='nextToken', description='Query token.', example='44ANBjKZmQeKnaB1fXRq06w7sFYK3MUcCALMD9qQbmEiE', nullable=true),
  prometheusViewIds?: string(name='prometheusViewIds', description='List of Prometheus view instance IDs.', example='view-xxx'),
  prometheusViewName?: string(name='prometheusViewName', description='Prometheus view name.', example='view1'),
  resourceGroupId?: string(name='resourceGroupId', description='Resource group ID.', example='rg-acfm3gn5i6bigbi'),
  resourceType?: string(name='resourceType', description='Resource type.', example='PROMETHEUSVIEW'),
  tag?: [ 
    {
      key?: string(name='key', description='Tag key', example='key1'),
      value?: string(name='value', description='Match value.', example='value1'),
    }
  ](name='tag', description='List of tags.'),
  version?: string(name='version', description='Instance version: V1 or V2', example='V2'),
  workspace?: string(name='workspace', description='Workspace name', example='workspace-test'),
}

model ListPrometheusViewsShrinkRequest {
  filterRegionIds?: string(name='filterRegionIds', description='Filter by RegionID.', example='cn-zhangjiakou,cn-beijing'),
  maxResults?: int32(name='maxResults', description='Maximum number of records to return.', example='100', nullable=true),
  nextToken?: string(name='nextToken', description='Query token.', example='44ANBjKZmQeKnaB1fXRq06w7sFYK3MUcCALMD9qQbmEiE', nullable=true),
  prometheusViewIds?: string(name='prometheusViewIds', description='List of Prometheus view instance IDs.', example='view-xxx'),
  prometheusViewName?: string(name='prometheusViewName', description='Prometheus view name.', example='view1'),
  resourceGroupId?: string(name='resourceGroupId', description='Resource group ID.', example='rg-acfm3gn5i6bigbi'),
  resourceType?: string(name='resourceType', description='Resource type.', example='PROMETHEUSVIEW'),
  tagShrink?: string(name='tag', description='List of tags.'),
  version?: string(name='version', description='Instance version: V1 or V2', example='V2'),
  workspace?: string(name='workspace', description='Workspace name', example='workspace-test'),
}

model ListPrometheusViewsResponseBody = {
  maxResults?: int32(name='maxResults', description='Maximum number of records to return.', example='10', nullable=true),
  nextToken?: string(name='nextToken', description='Token for the next query.', example='2-ba4d-4b9f-aa24-dcb067a30f1c'),
  prometheusViews?: [ 
    {
      createTime?: string(name='createTime', description='Instance creation time, using UTC+0 time, formatted as yyyy-MM-ddTHH:mmZ', example='2025-07-12T02:18:36Z'),
      instanceType?: string(name='instanceType', description='Instance type:
prom-view: new version aggregated view
global-view: old version aggregated view', example='prom-view'),
      paymentType?: string(name='paymentType', description='Payment type. Currently, the fixed value is FREE (free).', example='FREE'),
      product?: string(name='product', description='Product that the prom instance belongs to (arms or cms).', example='cms'),
      prometheusInstanceCount?: int32(name='prometheusInstanceCount', description='Number of Prometheus instances in the view.', example='2'),
      prometheusViewId?: string(name='prometheusViewId', description='Prometheus view ID.', example='view-xxx'),
      prometheusViewName?: string(name='prometheusViewName', description='Prometheus view name.', example='view1'),
      regionId?: string(name='regionId', description='Region ID.', example='cn-zhangjiakou'),
      resourceGroupId?: string(name='resourceGroupId', description='Resource group ID.', example='rg-acfm3gn5i6bigbi'),
      resourceType?: string(name='resourceType', description='Fixed value: PrometheusView.', example='PrometheusView'),
      status?: string(name='status', description='Backend data storage status.', example='Running'),
      tags?: [ 
        {
          key?: string(name='key', description='Tag key', example='key1'),
          value?: string(name='value', description='Match value.', example='value1'),
        }
      ](name='tags', description='Tag values.'),
      userId?: string(name='userId', description='User ID.', example='123xxx'),
      version?: string(name='version', description='Version.', example='V2'),
      workspace?: string(name='workspace', description='Workspace that the prom instance belongs to.', example='default-cms-1490404746278495-cn-hangzhou'),
    }
  ](name='prometheusViews', description='List of Prometheus view instances.'),
  requestId?: string(name='requestId', description='ID of the request', example='0CEC5375-C554-562B-A65F-9A629907C1F0'),
  totalCount?: int32(name='totalCount', description='Total number of instances', example='66'),
}

model ListPrometheusViewsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPrometheusViewsResponseBody(name='body'),
}

/**
 * @summary Retrieve a list of Prometheus view instance information
 *
 * @description Retrieve a list of Prometheus view instance information.
 *
 * @param tmpReq ListPrometheusViewsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPrometheusViewsResponse
 */
async function listPrometheusViewsWithOptions(tmpReq: ListPrometheusViewsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPrometheusViewsResponse {
  Util.validateModel(tmpReq);
  var request = new ListPrometheusViewsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tag)) {
    request.tagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tag, 'tag', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.filterRegionIds)) {
    query['filterRegionIds'] = request.filterRegionIds;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prometheusViewIds)) {
    query['prometheusViewIds'] = request.prometheusViewIds;
  }
  if (!Util.isUnset(request.prometheusViewName)) {
    query['prometheusViewName'] = request.prometheusViewName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagShrink)) {
    query['tag'] = request.tagShrink;
  }
  if (!Util.isUnset(request.version)) {
    query['version'] = request.version;
  }
  if (!Util.isUnset(request.workspace)) {
    query['workspace'] = request.workspace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrometheusViews',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/prometheus-views`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Retrieve a list of Prometheus view instance information
 *
 * @description Retrieve a list of Prometheus view instance information.
 *
 * @param request ListPrometheusViewsRequest
 * @return ListPrometheusViewsResponse
 */
async function listPrometheusViews(request: ListPrometheusViewsRequest): ListPrometheusViewsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPrometheusViewsWithOptions(request, headers, runtime);
}

model ListPrometheusVirtualInstancesRequest {
  namespace?: string(name='namespace', description='Optional cloud product', example='ack-csi-fuse'),
}

model ListPrometheusVirtualInstancesResponseBody = {
  instances?: [ 
    {
      createdAt?: string(name='createdAt', description='Creation time', example='1750315319946'),
      httpApiUrl?: string(name='httpApiUrl', description='HTTP API URL.', example='http://xxxxxxxx'),
      instanceId?: string(name='instanceId', description='Applicable data source type: PROMETHEUS_DS

Prometheus instance ID', example='rw-b8cfbbe94194ac37fe83f3d2d16a'),
      namespace?: string(name='namespace', description='Applicable query type: CMS_BASIC_QUERY.

Namespace of the metric', example='arms-prom'),
      regionId?: string(name='regionId', description='Region ID.', example='cn-shanghai-cloudspe'),
      userId?: string(name='userId', description='User ID.', example='17073812345'),
    }
  ](name='instances', description='Instance information.'),
  requestId?: string(name='requestId', description='ID of the request', example='264C3E89-XXXX-XXXX-XXXX-CE9C2196C7DC'),
}

model ListPrometheusVirtualInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPrometheusVirtualInstancesResponseBody(name='body'),
}

/**
 * @summary Get Prometheus Virtual Instance
 *
 * @description Used for creating a site monitoring task
 *
 * @param request ListPrometheusVirtualInstancesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPrometheusVirtualInstancesResponse
 */
async function listPrometheusVirtualInstancesWithOptions(request: ListPrometheusVirtualInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPrometheusVirtualInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.namespace)) {
    query['namespace'] = request.namespace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrometheusVirtualInstances',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/virtual-instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get Prometheus Virtual Instance
 *
 * @description Used for creating a site monitoring task
 *
 * @param request ListPrometheusVirtualInstancesRequest
 * @return ListPrometheusVirtualInstancesResponse
 */
async function listPrometheusVirtualInstances(request: ListPrometheusVirtualInstancesRequest): ListPrometheusVirtualInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPrometheusVirtualInstancesWithOptions(request, headers, runtime);
}

model ListServicesRequest {
  maxResults?: int32(name='maxResults', description='The maximum number of records to return in this request.', example='10'),
  nextToken?: string(name='nextToken', description='Token for the next query, an empty value indicates the last page.', example='7-b81a-4bc9-bbfa-a50cc6988667'),
  serviceType?: string(name='serviceType', description='Service type', example='apm'),
}

model ListServicesResponseBody = {
  maxResults?: int32(name='maxResults', description='Maximum number of results to return, with a maximum value of 200', example='10'),
  nextToken?: string(name='nextToken', description='Pagination token', example='2-ba4d-4b9f-aa24-dcb067a30f1c'),
  requestId?: string(name='requestId', description='Request ID', example='0CEC5375-C554-562B-A65F-9A629907C1F0'),
  services?: [ 
    {
      attributes?: string(name='attributes', description='Extended information.', example='{"language":"java"}'),
      createTime?: string(name='createTime', description='Creation time', example='2025-07-01T02:23:59Z'),
      description?: string(name='description', description='Service description, valid only when serviceType=RUM.', example='workspace api monitor test'),
      displayName?: string(name='displayName', description='Display name, valid only when serviceType=RUM.', example='test'),
      pid?: string(name='pid', description='Historical compatible ARMS application ID', example='kgcsf@192197e828d51aa'),
      serviceId?: string(name='serviceId', description='Service ID', example='jm2pl0yoqf@d4905cb11a4f218dfb0a8'),
      serviceName?: string(name='serviceName', description='Service name', example='demo-app'),
      serviceStatus?: string(name='serviceStatus', description='Service status, valid only when serviceType=RUM.', example='Running'),
      serviceType?: string(name='serviceType', description='Service type', example='TRACE'),
      workspace?: string(name='workspace', description='Workspace.', example='default-cms-1192928460540589-cn-hangzhou'),
    }
  ](name='services', description='List of service information.'),
  totalCount?: int32(name='totalCount', description='Total count', example='66'),
}

model ListServicesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListServicesResponseBody(name='body'),
}

/**
 * @summary List Resource Services
 *
 * @param request ListServicesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListServicesResponse
 */
async function listServicesWithOptions(workspace: string, request: ListServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServicesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['serviceType'] = request.serviceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServices',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspace)}/services`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary List Resource Services
 *
 * @param request ListServicesRequest
 * @return ListServicesResponse
 */
async function listServices(workspace: string, request: ListServicesRequest): ListServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServicesWithOptions(workspace, request, headers, runtime);
}

model ListWorkspacesRequest {
  maxResults?: int32(name='maxResults', description='Page size
Default value:
	50
Maximum value:
	50', example='10'),
  nextToken?: string(name='nextToken', description='Pagination Token', example='xxxxxxxxxx'),
  region?: string(name='region', description='Region', example='cn-heyuan', nullable=true),
  workspaceName?: string(name='workspaceName', description='Workspace name, fuzzy search', example='workspace-test-001'),
  workspaceNameList?: [ string ](name='workspaceNameList', description='Workspace name, exact match', example='workspace-test-001', nullable=true),
}

model ListWorkspacesShrinkRequest {
  maxResults?: int32(name='maxResults', description='Page size
Default value:
	50
Maximum value:
	50', example='10'),
  nextToken?: string(name='nextToken', description='Pagination Token', example='xxxxxxxxxx'),
  region?: string(name='region', description='Region', example='cn-heyuan', nullable=true),
  workspaceName?: string(name='workspaceName', description='Workspace name, fuzzy search', example='workspace-test-001'),
  workspaceNameListShrink?: string(name='workspaceNameList', description='Workspace name, exact match', example='workspace-test-001', nullable=true),
}

model ListWorkspacesResponseBody = {
  maxResults?: int32(name='maxResults', description='Page size
Default value:
	50
Maximum value:
	50', example='10'),
  nextToken?: string(name='nextToken', description='Pagination Token', example='xxxxxxxxxx'),
  requestId?: string(name='requestId', description='Request ID', example='264C3E89-XXXX-XXXX-XXXX-CE9C2196C7DC'),
  total?: int32(name='total', description='Total count', example='1'),
  workspaces?: [ 
    {
      createTime?: string(name='createTime', description='Creation time

Use the UTC time format: yyyy-MM-ddTHH:mm:ssZ', example='2025-03-11T08:21:58Z'),
      description?: string(name='description', description='Workspace description', example='workspace test'),
      displayName?: string(name='displayName', description='Workspace display name', example='workspace-test'),
      lastModifyTime?: string(name='lastModifyTime', description='Last modified time

Use the UTC time format: yyyy-MM-ddTHH:mm:ssZ', example='2025-03-11T08:21:58Z'),
      regionId?: string(name='regionId', description='Region ID', example='cn-heyuan'),
      slsProject?: string(name='slsProject', description='Log Service project name', example='sls-project-test-001'),
      workspaceName?: string(name='workspaceName', description='Workspace name

This parameter is required.', example='workspace-test-001'),
    }
  ](name='workspaces', description='List of workspaces'),
}

model ListWorkspacesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWorkspacesResponseBody(name='body'),
}

/**
 * @summary Get Workspace List
 *
 * @param tmpReq ListWorkspacesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListWorkspacesResponse
 */
async function listWorkspacesWithOptions(tmpReq: ListWorkspacesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListWorkspacesResponse {
  Util.validateModel(tmpReq);
  var request = new ListWorkspacesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.workspaceNameList)) {
    request.workspaceNameListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.workspaceNameList, 'workspaceNameList', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.region)) {
    query['region'] = request.region;
  }
  if (!Util.isUnset(request.workspaceName)) {
    query['workspaceName'] = request.workspaceName;
  }
  if (!Util.isUnset(request.workspaceNameListShrink)) {
    query['workspaceNameList'] = request.workspaceNameListShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkspaces',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get Workspace List
 *
 * @param request ListWorkspacesRequest
 * @return ListWorkspacesResponse
 */
async function listWorkspaces(request: ListWorkspacesRequest): ListWorkspacesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listWorkspacesWithOptions(request, headers, runtime);
}

model PutWorkspaceRequest {
  description?: string(name='description', description='Description of the workspace', example='workspace test'),
  displayName?: string(name='displayName', description='Display name of the workspace', example='workspace-test'),
  slsProject?: string(name='slsProject', description='Name of the Log Service project

This parameter is required.', example='sls-project-test-001'),
}

model PutWorkspaceResponseBody = {
  requestId?: string(name='requestId', description='ID of the request', example='264C3E89-XXXX-XXXX-XXXX-CE9C2196C7DC'),
  workspaceName?: string(name='workspaceName', description='Name of the workspace.', example='workspace-test-001'),
}

model PutWorkspaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PutWorkspaceResponseBody(name='body'),
}

/**
 * @summary Create Workspace
 *
 * @param request PutWorkspaceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutWorkspaceResponse
 */
async function putWorkspaceWithOptions(workspaceName: string, request: PutWorkspaceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutWorkspaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.slsProject)) {
    body['slsProject'] = request.slsProject;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutWorkspace',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspaceName)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create Workspace
 *
 * @param request PutWorkspaceRequest
 * @return PutWorkspaceResponse
 */
async function putWorkspace(workspaceName: string, request: PutWorkspaceRequest): PutWorkspaceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putWorkspaceWithOptions(workspaceName, request, headers, runtime);
}

model UpdateAddonReleaseRequest {
  addonVersion?: string(name='addonVersion', description='Addon version information.', example='0.0.2'),
  dryRun?: boolean(name='dryRun', description='Whether to pre-check this request.', example='true'),
  entityRules?: EntityDiscoverRule(name='entityRules', description='Entity discovery rules.'),
  values?: string(name='values', description='Metadata information.', example='{"install":{"mode":"auto-install","listenPort":"9400"},"discoverMode":"instances","discover":{"instances":"worker-k8s-for-cs-c126d87c76218487e83ab322017f11b44"},"scrapeInterval":"15","enableSecuritecs-nodeyGroupInjection":"true","metricTags":""}'),
}

model UpdateAddonReleaseResponseBody = {
  requestId?: string(name='requestId', description='Request ID.', example='9F00A7AF-2728-5424-B321-79D39C00A1EC'),
}

model UpdateAddonReleaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAddonReleaseResponseBody(name='body'),
}

/**
 * @summary Upgrade Access Component
 *
 * @param request UpdateAddonReleaseRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAddonReleaseResponse
 */
async function updateAddonReleaseWithOptions(releaseName: string, policyId: string, request: UpdateAddonReleaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAddonReleaseResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.addonVersion)) {
    body['addonVersion'] = request.addonVersion;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['dryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.entityRules)) {
    body['entityRules'] = request.entityRules;
  }
  if (!Util.isUnset(request.values)) {
    body['values'] = request.values;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAddonRelease',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/integration-policies/${OpenApiUtil.getEncodeParam(policyId)}/addon-releases/${OpenApiUtil.getEncodeParam(releaseName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Upgrade Access Component
 *
 * @param request UpdateAddonReleaseRequest
 * @return UpdateAddonReleaseResponse
 */
async function updateAddonRelease(releaseName: string, policyId: string, request: UpdateAddonReleaseRequest): UpdateAddonReleaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAddonReleaseWithOptions(releaseName, policyId, request, headers, runtime);
}

model UpdateAggTaskGroupRequest {
  aggTaskGroupConfig?: string(name='aggTaskGroupConfig', description='Aggregation task group configuration. Currently, only the “RecordingRuleYaml” format is supported, and it must comply with the format requirements of open-source Prometheus RecordingRules.

This parameter is required.', example='groups:
- name: "node.rules"
  interval: "60s"
  rules:
  - record: "node_namespace_pod:kube_pod_info:"
    expr: "max(label_replace(kube_pod_info{job=\\\\"kubernetes-pods-kube-state-metrics\\\\"\\\\
      }, \\\\"pod\\\\", \\\\"$1\\\\", \\\\"pod\\\\", \\\\"(.*)\\\\")) by (node, namespace, pod, cluster)"'),
  aggTaskGroupConfigType?: string(name='aggTaskGroupConfigType', description='Aggregation task group configuration type, default is “RecordingRuleYaml” (open-source Prometheus RecordingRule format).', example='RecordingRuleYaml'),
  aggTaskGroupName?: string(name='aggTaskGroupName', description='Aggregation task group name.', example='test-group'),
  cronExpr?: string(name='cronExpr', description='When the scheduling mode is set to “Cron”, this is the specific scheduling expression. For example, “0/1 * * * *” means starting from 0 minutes, schedule every 1 minute.', example='0/1 * * * *'),
  delay?: int32(name='delay', description='Fixed delay time for scheduling, in seconds, default is 30.', example='30'),
  description?: string(name='description', description='Description of the aggregation task group.', example='desc'),
  fromTime?: long(name='fromTime', description='The second-level timestamp corresponding to the start time of the scheduling.', example='1724996015'),
  maxRetries?: int32(name='maxRetries', description='Maximum number of retries for executing the aggregation task, default is 20.', example='20'),
  maxRunTimeInSeconds?: int32(name='maxRunTimeInSeconds', description='Maximum retry time for executing the aggregation task, in seconds, default is 600.', example='600'),
  precheckString?: string(name='precheckString', description='Pre-check configuration, no configuration by default. The input string needs to be correctly parsed as JSON.', example='{"policy":"skip","prometheusId":"xxx","query":"scalar(sum(count_over_time(up{job=\\\\"_arms/kubelet/cadvisor\\\\"}[15s])) / 21)","threshold":0.5,"timeout":15,"type":"promql"}'),
  scheduleMode?: string(name='scheduleMode', description='Scheduling mode, either “Cron” or “FixedRate”, default is “FixedRate”.', example='FixedRate'),
  scheduleTimeExpr?: string(name='scheduleTimeExpr', description='Scheduling time expression, recommended values are “@s” or “@m”, indicating the granularity of the scheduling time window alignment, default is “@m”.', example='@m'),
  status?: string(name='status', description='Status of the aggregation task group, either “Running” or “Stopped”. Default is Running.', example='Running'),
  tags?: [ 
    {
      key?: string(name='key', description='Key of the resource group tag.', example='key1'),
      value?: string(name='value', description='Value of the resource group tag.', example='value1'),
    }
  ](name='tags', description='Resource group tags.'),
  targetPrometheusId?: string(name='targetPrometheusId', description='Target Prometheus instance ID of the aggregation task group.

This parameter is required.', example='rw-pq4apob9jm'),
  toTime?: long(name='toTime', description='The second-level timestamp corresponding to the end time of the scheduling, 0 indicates that the scheduling does not stop.', example='0'),
}

model UpdateAggTaskGroupResponseBody = {
  aggTaskGroupConfigHash?: string(name='aggTaskGroupConfigHash', description='Summary of the aggregation task group configuration.', example='a54136014dc386a92c83a6ef1e97ff22'),
  aggTaskGroupId?: string(name='aggTaskGroupId', description='Aggregation task group ID', example='aggTaskGroup-5fb2c3ade63a4709bcb059d13493b7b8'),
  aggTaskGroupName?: string(name='aggTaskGroupName', description='Aggregation task group name', example='pipeline-aggtask-group'),
  requestId?: string(name='requestId', description='Request ID', example='8FDE2569-626B-5176-9844-28877A*****'),
  sourcePrometheusId?: string(name='sourcePrometheusId', description='Source Prometheus instance ID of the aggregation task group', example='rw-083e17834e279f8c627fe91a2d72'),
  status?: string(name='status', description='Current status of the aggregation task group', example='Running'),
}

model UpdateAggTaskGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAggTaskGroupResponseBody(name='body'),
}

/**
 * @summary Apply Aggregation Task Group
 *
 * @param request UpdateAggTaskGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAggTaskGroupResponse
 */
async function updateAggTaskGroupWithOptions(instanceId: string, groupId: string, request: UpdateAggTaskGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAggTaskGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.aggTaskGroupConfig)) {
    body['aggTaskGroupConfig'] = request.aggTaskGroupConfig;
  }
  if (!Util.isUnset(request.aggTaskGroupConfigType)) {
    body['aggTaskGroupConfigType'] = request.aggTaskGroupConfigType;
  }
  if (!Util.isUnset(request.aggTaskGroupName)) {
    body['aggTaskGroupName'] = request.aggTaskGroupName;
  }
  if (!Util.isUnset(request.cronExpr)) {
    body['cronExpr'] = request.cronExpr;
  }
  if (!Util.isUnset(request.delay)) {
    body['delay'] = request.delay;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.fromTime)) {
    body['fromTime'] = request.fromTime;
  }
  if (!Util.isUnset(request.maxRetries)) {
    body['maxRetries'] = request.maxRetries;
  }
  if (!Util.isUnset(request.maxRunTimeInSeconds)) {
    body['maxRunTimeInSeconds'] = request.maxRunTimeInSeconds;
  }
  if (!Util.isUnset(request.precheckString)) {
    body['precheckString'] = request.precheckString;
  }
  if (!Util.isUnset(request.scheduleMode)) {
    body['scheduleMode'] = request.scheduleMode;
  }
  if (!Util.isUnset(request.scheduleTimeExpr)) {
    body['scheduleTimeExpr'] = request.scheduleTimeExpr;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.targetPrometheusId)) {
    body['targetPrometheusId'] = request.targetPrometheusId;
  }
  if (!Util.isUnset(request.toTime)) {
    body['toTime'] = request.toTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAggTaskGroup',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/prometheus-instances/${OpenApiUtil.getEncodeParam(instanceId)}/agg-task-groups/${OpenApiUtil.getEncodeParam(groupId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Apply Aggregation Task Group
 *
 * @param request UpdateAggTaskGroupRequest
 * @return UpdateAggTaskGroupResponse
 */
async function updateAggTaskGroup(instanceId: string, groupId: string, request: UpdateAggTaskGroupRequest): UpdateAggTaskGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAggTaskGroupWithOptions(instanceId, groupId, request, headers, runtime);
}

model UpdateAggTaskGroupStatusRequest {
  status?: string(name='status', description='Status of the aggregation task group, either “Running” or “Stopped”. Default is Running.

This parameter is required.', example='Running'),
}

model UpdateAggTaskGroupStatusResponseBody = {
  aggTaskGroupConfigHash?: string(name='aggTaskGroupConfigHash', description='Summary of the aggregation task group configuration.', example='a54136014dc386a92c83a6ef1e97ff22'),
  aggTaskGroupId?: string(name='aggTaskGroupId', description='Aggregation task group ID.', example='aggTaskGroup-xxx'),
  aggTaskGroupName?: string(name='aggTaskGroupName', description='Aggregation task group name.', example='pipeline-aggtask-group'),
  requestId?: string(name='requestId', description='Request ID.', example='0CEC5375-C554-562B-A65F-***'),
  sourcePrometheusId?: string(name='sourcePrometheusId', description='Source Prometheus instance ID of the aggregation task group.', example='rw-xxx'),
  status?: string(name='status', description='The current status of the aggregated task group.', example='Running'),
}

model UpdateAggTaskGroupStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAggTaskGroupStatusResponseBody(name='body'),
}

/**
 * @summary Update Aggregation Task Group Status
 *
 * @param request UpdateAggTaskGroupStatusRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAggTaskGroupStatusResponse
 */
async function updateAggTaskGroupStatusWithOptions(instanceId: string, groupId: string, request: UpdateAggTaskGroupStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAggTaskGroupStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAggTaskGroupStatus',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/prometheus-instances/${OpenApiUtil.getEncodeParam(instanceId)}/agg-task-groups/${OpenApiUtil.getEncodeParam(groupId)}/status`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update Aggregation Task Group Status
 *
 * @param request UpdateAggTaskGroupStatusRequest
 * @return UpdateAggTaskGroupStatusResponse
 */
async function updateAggTaskGroupStatus(instanceId: string, groupId: string, request: UpdateAggTaskGroupStatusRequest): UpdateAggTaskGroupStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAggTaskGroupStatusWithOptions(instanceId, groupId, request, headers, runtime);
}

model UpdateIntegrationPolicyRequest {
  feePackage?: string(name='feePackage', description='Fee package type, CS_Pro/CS_Basic/empty.', example='CS_Pro'),
  policyName?: string(name='policyName', description='Rule name, minimum 3 characters, maximum 63 characters, must start with a letter.', example='metrics-inner-manage'),
  resourceGroupId?: string(name='resourceGroupId', description='Resource group ID of the instance.', example='rg-aekzoiafjtr7zyq'),
  tags?: [ 
    {
      key?: string(name='key', description='Tag `key` value.', example='algo_bhv_expose_in_airec_exposure'),
      value?: string(name='value', description='Tag `value` value.', example='[{\\\\"Id\\\\": \\\\"kgqie6hm\\\\", \\\\"Name\\\\": \\\\"Sheet1\\\\"}]'),
    }
  ](name='tags', description='Resource tags.'),
}

model UpdateIntegrationPolicyResponseBody = {
  requestId?: string(name='requestId', description='ID of the request', example='0CEC5375-C554-562B-A65F-9A629907C1F0'),
}

model UpdateIntegrationPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateIntegrationPolicyResponseBody(name='body'),
}

/**
 * @summary Update the specified policy
 *
 * @param request UpdateIntegrationPolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateIntegrationPolicyResponse
 */
async function updateIntegrationPolicyWithOptions(integrationPolicyId: string, request: UpdateIntegrationPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateIntegrationPolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.feePackage)) {
    body['feePackage'] = request.feePackage;
  }
  if (!Util.isUnset(request.policyName)) {
    body['policyName'] = request.policyName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIntegrationPolicy',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/integration-policies/${OpenApiUtil.getEncodeParam(integrationPolicyId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update the specified policy
 *
 * @param request UpdateIntegrationPolicyRequest
 * @return UpdateIntegrationPolicyResponse
 */
async function updateIntegrationPolicy(integrationPolicyId: string, request: UpdateIntegrationPolicyRequest): UpdateIntegrationPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateIntegrationPolicyWithOptions(integrationPolicyId, request, headers, runtime);
}

model UpdatePrometheusInstanceRequest {
  archiveDuration?: integer(name='archiveDuration', description='The number of days to automatically archive and save after the storage expires, 0 means no archiving. The range of archiving days:
V1: 1~365 days. Only supported for metric write volume.
V2: 1~3650 days (3650 indicates permanent storage).', example='365', nullable=true),
  authFreeReadPolicy?: string(name='authFreeReadPolicy', description='Password-free read policy (supports IP segments and VpcId).', example='{
  "SourceIp": [
    "192.168.1.0/24",
    "172.168.2.22"
  ],
  "SourceVpc": [
    "vpc-xx1",
    "vpc-xx2"
  ]
}'),
  authFreeWritePolicy?: string(name='authFreeWritePolicy', description='Password-free write policy (supports IP segments and VpcId).', example='{
  "SourceIp": [
    "192.168.1.0/24",
    "172.168.2.22"
  ],
  "SourceVpc": [
    "vpc-xx1",
    "vpc-xx2"
  ]
}'),
  enableAuthFreeRead?: boolean(name='enableAuthFreeRead', description='Whether to enable password-free read.', example='true'),
  enableAuthFreeWrite?: boolean(name='enableAuthFreeWrite', description='Whether to enable password-free write.', example='true'),
  enableAuthToken?: boolean(name='enableAuthToken', description='Whether to enable access token authentication.', example='true'),
  paymentType?: string(name='paymentType', description='Billing method (can only be modified once during the instance\\\\"s lifecycle):
POSTPAY: Postpaid by metric reporting volume.
POSTPAY_GB: Postpaid by metric write volume.', example='POSTPAY_GB'),
  prometheusInstanceName?: string(name='prometheusInstanceName', description='Instance name.', example='test-prom-name'),
  status?: string(name='status', description='Instance storage DB status (only supports RUNNING). If empty, the storage DB status will not be changed.', example='RUNNING'),
  storageDuration?: integer(name='storageDuration', description='Storage duration (days):
By write volume: 90, 180.
By metric reporting volume: 15, 30, 60, 90, 180.', example='90'),
  workspace?: string(name='workspace', description='Belonging workspace.', example='default-cms-1500199863951574-cn-shanghai'),
}

model UpdatePrometheusInstanceResponseBody = {
  prometheusInstanceId?: string(name='prometheusInstanceId', description='Instance ID.', example='rw-abc123'),
  requestId?: string(name='requestId', description='ID of the request', example='1E92F783-E057-58F1-BD5C-92DED088E7A5'),
}

model UpdatePrometheusInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePrometheusInstanceResponseBody(name='body'),
}

/**
 * @summary Update Prometheus instance information
 *
 * @description Update Prometheus instance information.
 *
 * @param request UpdatePrometheusInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePrometheusInstanceResponse
 */
async function updatePrometheusInstanceWithOptions(prometheusInstanceId: string, request: UpdatePrometheusInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePrometheusInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.archiveDuration)) {
    body['archiveDuration'] = request.archiveDuration;
  }
  if (!Util.isUnset(request.authFreeReadPolicy)) {
    body['authFreeReadPolicy'] = request.authFreeReadPolicy;
  }
  if (!Util.isUnset(request.authFreeWritePolicy)) {
    body['authFreeWritePolicy'] = request.authFreeWritePolicy;
  }
  if (!Util.isUnset(request.enableAuthFreeRead)) {
    body['enableAuthFreeRead'] = request.enableAuthFreeRead;
  }
  if (!Util.isUnset(request.enableAuthFreeWrite)) {
    body['enableAuthFreeWrite'] = request.enableAuthFreeWrite;
  }
  if (!Util.isUnset(request.enableAuthToken)) {
    body['enableAuthToken'] = request.enableAuthToken;
  }
  if (!Util.isUnset(request.paymentType)) {
    body['paymentType'] = request.paymentType;
  }
  if (!Util.isUnset(request.prometheusInstanceName)) {
    body['prometheusInstanceName'] = request.prometheusInstanceName;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.storageDuration)) {
    body['storageDuration'] = request.storageDuration;
  }
  if (!Util.isUnset(request.workspace)) {
    body['workspace'] = request.workspace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePrometheusInstance',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/prometheus-instances/${OpenApiUtil.getEncodeParam(prometheusInstanceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update Prometheus instance information
 *
 * @description Update Prometheus instance information.
 *
 * @param request UpdatePrometheusInstanceRequest
 * @return UpdatePrometheusInstanceResponse
 */
async function updatePrometheusInstance(prometheusInstanceId: string, request: UpdatePrometheusInstanceRequest): UpdatePrometheusInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePrometheusInstanceWithOptions(prometheusInstanceId, request, headers, runtime);
}

model UpdatePrometheusViewRequest {
  authFreeReadPolicy?: string(name='authFreeReadPolicy', description='Password-free read policy (supports IP segments and VpcId).', example='{
  "SourceIp": [
    "192.168.1.0/24",
    "172.168.2.22"
  ],
  "SourceVpc": [
    "vpc-xx1",
    "vpc-xx2"
  ]
}'),
  enableAuthFreeRead?: boolean(name='enableAuthFreeRead', description='Whether to support password-free read.', example='true'),
  enableAuthToken?: boolean(name='enableAuthToken', description='Whether to support authToken.', example='false'),
  prometheusInstances?: [ 
    {
      prometheusInstanceId?: string(name='prometheusInstanceId', description='Instance ID.', example='c7ba84651c71e442c8d0653085d862164'),
      regionId?: string(name='regionId', description='Region.', example='cn-north-2-gov-1'),
      userId?: string(name='userId', description='User ID.', example='16727123456789'),
    }
  ](name='prometheusInstances', description='List of Prometheus instances.'),
  prometheusViewName?: string(name='prometheusViewName', description='Prometheus view name.', example='test-prom-view-name'),
  status?: string(name='status', description='Running status.', example='Running'),
  workspace?: string(name='workspace', description='Belonging workspace.', example='default-cms-108490012345-cn-heyuan'),
}

model UpdatePrometheusViewResponseBody = {
  prometheusViewId?: string(name='prometheusViewId', description='Prometheus view instance ID.', example='rw-xxxxxx'),
  requestId?: string(name='requestId', description='ID of the request.', example='64D964F5-76C7-19A2-9399-457744AB3619'),
}

model UpdatePrometheusViewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePrometheusViewResponseBody(name='body'),
}

/**
 * @summary Update Prometheus view instance information
 *
 * @description Update Prometheus view instance information.
 *
 * @param request UpdatePrometheusViewRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePrometheusViewResponse
 */
async function updatePrometheusViewWithOptions(prometheusViewId: string, request: UpdatePrometheusViewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePrometheusViewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.authFreeReadPolicy)) {
    body['authFreeReadPolicy'] = request.authFreeReadPolicy;
  }
  if (!Util.isUnset(request.enableAuthFreeRead)) {
    body['enableAuthFreeRead'] = request.enableAuthFreeRead;
  }
  if (!Util.isUnset(request.enableAuthToken)) {
    body['enableAuthToken'] = request.enableAuthToken;
  }
  if (!Util.isUnset(request.prometheusInstances)) {
    body['prometheusInstances'] = request.prometheusInstances;
  }
  if (!Util.isUnset(request.prometheusViewName)) {
    body['prometheusViewName'] = request.prometheusViewName;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.workspace)) {
    body['workspace'] = request.workspace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePrometheusView',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/prometheus-views/${OpenApiUtil.getEncodeParam(prometheusViewId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update Prometheus view instance information
 *
 * @description Update Prometheus view instance information.
 *
 * @param request UpdatePrometheusViewRequest
 * @return UpdatePrometheusViewResponse
 */
async function updatePrometheusView(prometheusViewId: string, request: UpdatePrometheusViewRequest): UpdatePrometheusViewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePrometheusViewWithOptions(prometheusViewId, request, headers, runtime);
}

model UpdateServiceRequest {
  attributes?: string(name='attributes', description='Extended attributes.', example='{"language":"java"}'),
  description?: string(name='description', description='Service description, only valid when serviceType=RUM.', example='test'),
  displayName?: string(name='displayName', description='Display name, only valid when serviceType=RUM.', example='api-monitor-test'),
  serviceStatus?: string(name='serviceStatus', description='Service status, only valid when serviceType=RUM.', example='Stopped'),
}

model UpdateServiceResponseBody = {
  requestId?: string(name='requestId', description='Request ID.', example='123-0F43-23423-AC43-34234'),
  serviceId?: string(name='serviceId', description='Service ID.', example='em87vd@c2e25bcfe0e21ce0***'),
}

model UpdateServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateServiceResponseBody(name='body'),
}

/**
 * @summary Update Service
 *
 * @param request UpdateServiceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateServiceResponse
 */
async function updateServiceWithOptions(workspace: string, serviceId: string, request: UpdateServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.attributes)) {
    body['attributes'] = request.attributes;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.displayName)) {
    body['displayName'] = request.displayName;
  }
  if (!Util.isUnset(request.serviceStatus)) {
    body['serviceStatus'] = request.serviceStatus;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateService',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspace)}/service/${OpenApiUtil.getEncodeParam(serviceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update Service
 *
 * @param request UpdateServiceRequest
 * @return UpdateServiceResponse
 */
async function updateService(workspace: string, serviceId: string, request: UpdateServiceRequest): UpdateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceWithOptions(workspace, serviceId, request, headers, runtime);
}

model UpdateUmodelRequest {
  description?: string(name='description', description='Description.', example='workspace test'),
}

model UpdateUmodelResponseBody = {
  requestId?: string(name='requestId', description='Request ID', example='234324-123-123-123-23423'),
  workspace?: string(name='workspace', description='Workspace name', example='workspace-test'),
}

model UpdateUmodelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateUmodelResponseBody(name='body'),
}

/**
 * @summary Update Umodel configuration information
 *
 * @description Update Umodel configuration information
 *
 * @param request UpdateUmodelRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateUmodelResponse
 */
async function updateUmodelWithOptions(workspace: string, request: UpdateUmodelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateUmodelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUmodel',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspace)}/umodel`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update Umodel configuration information
 *
 * @description Update Umodel configuration information
 *
 * @param request UpdateUmodelRequest
 * @return UpdateUmodelResponse
 */
async function updateUmodel(workspace: string, request: UpdateUmodelRequest): UpdateUmodelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateUmodelWithOptions(workspace, request, headers, runtime);
}

model UpsertUmodelDataRequest {
  elements?: [ any ](name='elements', description='Element content'),
  method?: string(name='method', description='Method', example='Upsert'),
}

model UpsertUmodelDataResponseBody = {
  requestId?: string(name='requestId', description='Request ID.', example='0CEC5375-C554-562B-A65F-9A629907C1F0'),
}

model UpsertUmodelDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpsertUmodelDataResponseBody(name='body'),
}

/**
 * @summary Write Umodel Elements
 *
 * @param request UpsertUmodelDataRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpsertUmodelDataResponse
 */
async function upsertUmodelDataWithOptions(workspace: string, request: UpsertUmodelDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpsertUmodelDataResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.method)) {
    query['method'] = request.method;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.elements)) {
    body['elements'] = request.elements;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpsertUmodelData',
    version = '2024-03-30',
    protocol = 'HTTPS',
    pathname = `/workspace/${OpenApiUtil.getEncodeParam(workspace)}/umodel/data`,
    method = 'PATCH',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Write Umodel Elements
 *
 * @param request UpsertUmodelDataRequest
 * @return UpsertUmodelDataResponse
 */
async function upsertUmodelData(workspace: string, request: UpsertUmodelDataRequest): UpsertUmodelDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return upsertUmodelDataWithOptions(workspace, request, headers, runtime);
}

