/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Cms';
  @version = '2018-03-08';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AccessKeyGetRequest {
  userId?: long(name='UserId', position='Query'),
}

model AccessKeyGetResponseBody = {
  accessKey?: string(name='AccessKey'),
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  secretKey?: string(name='SecretKey'),
  success?: boolean(name='Success'),
  userId?: long(name='UserId'),
}

model AccessKeyGetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AccessKeyGetResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AccessKeyGet  AccessKeyGetRequest
  * @return AccessKeyGetResponse
 */
async function accessKeyGet(request: AccessKeyGetRequest): AccessKeyGetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AccessKeyGet', 'POST', '/', 'json', false, 'json', request);
}

model AddMyGroupInstancesRequest {
  groupId: long(name='GroupId', description='This parameter is required.', position='Query'),
  instances?: string(name='Instances', position='Query'),
}

model AddMyGroupInstancesResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddMyGroupInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddMyGroupInstancesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AddMyGroupInstances  AddMyGroupInstancesRequest
  * @return AddMyGroupInstancesResponse
 */
async function addMyGroupInstances(request: AddMyGroupInstancesRequest): AddMyGroupInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddMyGroupInstances', 'POST', '/', 'json', false, 'json', request);
}

model CreateAlarmRequest {
  comparisonOperator: string(name='ComparisonOperator', description='This parameter is required.', example='>', position='Query'),
  contactGroups?: string(name='ContactGroups', position='Query'),
  dimensions: string(name='Dimensions', description='This parameter is required.', example='[{"instanceId":"i-2zecrzcri3d6fhd2ff7j "}]', position='Query'),
  dryRun?: boolean(name='DryRun', example='true', position='Query'),
  endTime?: int32(name='EndTime', example='24', position='Query'),
  evaluationCount?: int32(name='EvaluationCount', example='3', position='Query'),
  metricName: string(name='MetricName', description='This parameter is required.', example='CPUUtilization', position='Query'),
  name: string(name='Name', description='This parameter is required.', example='abc', position='Query'),
  namespace: string(name='Namespace', description='This parameter is required.', example='acs_ecs_dashboard', position='Query'),
  notifyType?: int32(name='NotifyType', example='1', position='Query'),
  period?: int32(name='Period', example='60', position='Query'),
  silenceTime?: int32(name='SilenceTime', example='86400', position='Query'),
  startTime?: int32(name='StartTime', example='0', position='Query'),
  statistics: string(name='Statistics', description='This parameter is required.', example='Average', position='Query'),
  threshold: string(name='Threshold', description='This parameter is required.', example='90', position='Query'),
  webhook?: string(name='Webhook', example='http://www.net.cn/example_callback.htm', position='Query'),
}

model CreateAlarmResponseBody = {
  code?: string(name='Code', example='200'),
  data?: string(name='Data', example='0c4af0f1-a864-468b-bed3-15c7deff75ee'),
  message?: string(name='Message', example='Success'),
  requestId?: string(name='RequestId', example='910ABE4E-DC9D-4231-9DC0-C96835553327'),
  success?: boolean(name='Success', example='true'),
}

model CreateAlarmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAlarmResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateAlarm  CreateAlarmRequest
  * @return CreateAlarmResponse
 */
async function createAlarm(request: CreateAlarmRequest): CreateAlarmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAlarm', 'POST', '/', 'json', false, 'json', request);
}

model CreateHybridDoubleWriteRequest {
  namespace: string(name='Namespace', description='This parameter is required.', example='test-target', position='Query'),
  sourceNamespace: string(name='SourceNamespace', description='This parameter is required.', example='test-source', position='Query'),
  sourceUserId: long(name='SourceUserId', description='This parameter is required.', example='12706766********', position='Query'),
  userId: long(name='UserId', description='This parameter is required.', example='12706766********', position='Query'),
}

model CreateHybridDoubleWriteResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='success'),
  requestId?: string(name='RequestId', example='FAAC3C5D-00BF-543A-9E08-FAAC3C5D'),
  success?: boolean(name='Success', example='true'),
}

model CreateHybridDoubleWriteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateHybridDoubleWriteResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateHybridDoubleWrite  CreateHybridDoubleWriteRequest
  * @return CreateHybridDoubleWriteResponse
 */
async function createHybridDoubleWrite(request: CreateHybridDoubleWriteRequest): CreateHybridDoubleWriteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateHybridDoubleWrite', 'POST', '/', 'json', false, 'json', request);
}

model CreateMonitoringTemplateRequest {
  alertTemplatesJson: string(name='AlertTemplatesJson', description='This parameter is required.', position='Query'),
  description?: string(name='Description', position='Query'),
  hostAvailabilityTemplate?: string(name='HostAvailabilityTemplate', position='Query'),
  name: string(name='Name', description='This parameter is required.', position='Query'),
  namespace: string(name='Namespace', description='This parameter is required.', position='Query'),
  processMonitorTemplates?: string(name='ProcessMonitorTemplates', position='Query'),
  systemEventTemplates?: string(name='SystemEventTemplates', position='Query'),
}

model CreateMonitoringTemplateResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateMonitoringTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMonitoringTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMonitoringTemplate  CreateMonitoringTemplateRequest
  * @return CreateMonitoringTemplateResponse
 */
async function createMonitoringTemplate(request: CreateMonitoringTemplateRequest): CreateMonitoringTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMonitoringTemplate', 'POST', '/', 'json', false, 'json', request);
}

model CreateMyGroupsRequest {
  bindUrl?: string(name='BindUrl', position='Query'),
  contactGroups?: string(name='ContactGroups', position='Query'),
  groupName?: string(name='GroupName', position='Query'),
  options?: string(name='Options', position='Query'),
  serviceId?: long(name='ServiceId', position='Query'),
  type?: string(name='Type', position='Query'),
}

model CreateMyGroupsResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  groupId?: long(name='GroupId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateMyGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMyGroupsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMyGroups  CreateMyGroupsRequest
  * @return CreateMyGroupsResponse
 */
async function createMyGroups(request: CreateMyGroupsRequest): CreateMyGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMyGroups', 'POST', '/', 'json', false, 'json', request);
}

model CreateTaskRequest {
  address: string(name='Address', description='This parameter is required.', example='http://www.aliyun.com', position='Query'),
  alertIds?: string(name='AlertIds', position='Query'),
  alertRule?: string(name='AlertRule', position='Query'),
  interval?: string(name='Interval', example='1', position='Query'),
  intervalUnit?: string(name='IntervalUnit', position='Query'),
  ispCity: string(name='IspCity', description='This parameter is required.', example='[{"city":"546","isp":"465"},{"city":"572","isp":"465"},{"city":"738","isp":"465"}]', position='Query'),
  options?: string(name='Options', example='{"http_method":"get","header":"xx=bb","cookie":"test=aa","time_out":30000,"match_rule":0,"response_content":"aa"}', position='Query'),
  taskName: string(name='TaskName', description='This parameter is required.', example='aliyunTest', position='Query'),
  taskType: string(name='TaskType', description='1.http
2.ping
3.tcp
4.udp
5.dns
6.smtp
7.pop3
8.ftp

This parameter is required.', example='1', position='Query'),
  caller?: string(name='caller', position='Query'),
}

model CreateTaskResponseBody = {
  alertRule?: string(name='AlertRule'),
  code?: string(name='Code', example='200'),
  createResultList?: {
    contact?: [ 
    {
      taskId?: string(name='TaskId'),
      taskName?: string(name='TaskName'),
    }
  ](name='Contact')
  }(name='CreateResultList'),
  data?: string(name='Data'),
  message?: string(name='Message', example='successfull'),
  requestId?: string(name='RequestId', example='a4e6f550-7eac-4a13-b11f-6742aa2d42d1'),
  success?: string(name='Success', example='true'),
}

model CreateTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateTask  CreateTaskRequest
  * @return CreateTaskResponse
 */
async function createTask(request: CreateTaskRequest): CreateTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTask', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAlarmRequest {
  id: string(name='Id', description='This parameter is required.', example='576fbae7-2fd1-411a-ae13-6f09f4fafdde', position='Query'),
}

model DeleteAlarmResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='Success'),
  requestId?: string(name='RequestId', example='A9371CD8-369D-49FA-BED9-35050A0DC6A2'),
  success?: boolean(name='Success', example='true'),
}

model DeleteAlarmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAlarmResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteAlarm  DeleteAlarmRequest
  * @return DeleteAlarmResponse
 */
async function deleteAlarm(request: DeleteAlarmRequest): DeleteAlarmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAlarm', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCustomMetricRequest {
  groupId: string(name='GroupId', description='This parameter is required.', position='Query'),
  md5?: string(name='Md5', position='Query'),
  metricName?: string(name='MetricName', position='Query'),
  UUID?: string(name='UUID', position='Query'),
}

model DeleteCustomMetricResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DeleteCustomMetricResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCustomMetricResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteCustomMetric  DeleteCustomMetricRequest
  * @return DeleteCustomMetricResponse
 */
async function deleteCustomMetric(request: DeleteCustomMetricRequest): DeleteCustomMetricResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCustomMetric', 'POST', '/', 'json', false, 'json', request);
}

model DeleteHybridDoubleWriteRequest {
  sourceNamespace: string(name='SourceNamespace', description='This parameter is required.', example='test-source', position='Query'),
  sourceUserId: long(name='SourceUserId', description='This parameter is required.', example='12706766********', position='Query'),
}

model DeleteHybridDoubleWriteResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='success'),
  requestId?: string(name='RequestId', example='6F815BDC-9063-5417-BA88-E1BBD84BAA1E'),
  success?: boolean(name='Success', example='true'),
}

model DeleteHybridDoubleWriteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteHybridDoubleWriteResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteHybridDoubleWrite  DeleteHybridDoubleWriteRequest
  * @return DeleteHybridDoubleWriteResponse
 */
async function deleteHybridDoubleWrite(request: DeleteHybridDoubleWriteRequest): DeleteHybridDoubleWriteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteHybridDoubleWrite', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMetricRuleTargetsRequest {
  ruleId: string(name='RuleId', description='This parameter is required.', position='Query'),
  targetIds?: [ string ](name='TargetIds', position='Query'),
}

model DeleteMetricRuleTargetsResponseBody = {
  code?: string(name='Code'),
  failIds?: {
    targetIds?: {
      targetId?: [ string ](name='TargetId')
    }(name='TargetIds'),
  }(name='FailIds'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMetricRuleTargetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMetricRuleTargetsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMetricRuleTargets  DeleteMetricRuleTargetsRequest
  * @return DeleteMetricRuleTargetsResponse
 */
async function deleteMetricRuleTargets(request: DeleteMetricRuleTargetsRequest): DeleteMetricRuleTargetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMetricRuleTargets', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMetricRulesRequest {
  id: [ string ](name='Id', description='This parameter is required.', position='Query'),
}

model DeleteMetricRulesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMetricRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMetricRulesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMetricRules  DeleteMetricRulesRequest
  * @return DeleteMetricRulesResponse
 */
async function deleteMetricRules(request: DeleteMetricRulesRequest): DeleteMetricRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMetricRules', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMyGroupInstancesRequest {
  category: string(name='Category', description='This parameter is required.', position='Query'),
  groupId: long(name='GroupId', description='This parameter is required.', position='Query'),
  instanceIdList?: string(name='InstanceIdList', position='Query'),
  instanceIds?: string(name='InstanceIds', position='Query'),
}

model DeleteMyGroupInstancesResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMyGroupInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMyGroupInstancesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMyGroupInstances  DeleteMyGroupInstancesRequest
  * @return DeleteMyGroupInstancesResponse
 */
async function deleteMyGroupInstances(request: DeleteMyGroupInstancesRequest): DeleteMyGroupInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMyGroupInstances', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMyGroupsRequest {
  groupId?: long(name='GroupId', position='Query'),
}

model DeleteMyGroupsResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  group?: {
    bindUrls?: string(name='BindUrls'),
    contactGroups?: {
      contactGroup?: [ 
      {
        name?: string(name='Name'),
      }
    ](name='ContactGroup')
    }(name='ContactGroups'),
    groupId?: long(name='GroupId'),
    groupName?: string(name='GroupName'),
    serviceId?: string(name='ServiceId'),
    type?: string(name='Type'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMyGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMyGroupsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMyGroups  DeleteMyGroupsRequest
  * @return DeleteMyGroupsResponse
 */
async function deleteMyGroups(request: DeleteMyGroupsRequest): DeleteMyGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMyGroups', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTasksRequest {
  isDeleteAlarms?: int32(name='IsDeleteAlarms', example='1', position='Query'),
  taskIds: string(name='TaskIds', description='This parameter is required.', example='["2b5e6f7d-108f-4117-85fb-b202ba033468"]', position='Query'),
}

model DeleteTasksResponseBody = {
  code?: string(name='Code', example='200'),
  data?: string(name='Data', example='{"count":1}'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', example='a4e6f550-7eac-4a13-b11f-6742aa2d42d1'),
  success?: string(name='Success', example='true'),
}

model DeleteTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteTasks  DeleteTasksRequest
  * @return DeleteTasksResponse
 */
async function deleteTasks(request: DeleteTasksRequest): DeleteTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAlarmHistoryRequest {
  alertName?: string(name='AlertName', position='Query'),
  ascending?: boolean(name='Ascending', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  metricName?: string(name='MetricName', position='Query'),
  namespace?: string(name='Namespace', position='Query'),
  onlyCount?: boolean(name='OnlyCount', position='Query'),
  page?: int32(name='Page', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  ruleName?: string(name='RuleName', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  state?: string(name='State', position='Query'),
  status?: string(name='Status', position='Query'),
}

model DescribeAlarmHistoryResponseBody = {
  alarmHistoryList?: {
    alarmHistory?: [ 
    {
      alertName?: string(name='AlertName'),
      alertTime?: long(name='AlertTime'),
      contactALIIMs?: {
        contactALIIM?: [ string ](name='ContactALIIM')
      }(name='ContactALIIMs'),
      contactGroups?: {
        contactGroup?: [ string ](name='ContactGroup')
      }(name='ContactGroups'),
      contactMails?: {
        contactMail?: [ string ](name='ContactMail')
      }(name='ContactMails'),
      contactSmses?: {
        contactSms?: [ string ](name='ContactSms')
      }(name='ContactSmses'),
      contacts?: {
        contact?: [ string ](name='Contact')
      }(name='Contacts'),
      dimensions?: string(name='Dimensions'),
      evaluationCount?: int32(name='EvaluationCount'),
      expression?: string(name='Expression'),
      groupId?: string(name='GroupId'),
      id?: string(name='Id'),
      instanceName?: string(name='InstanceName'),
      lastTime?: long(name='LastTime'),
      level?: string(name='Level'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      preLevel?: string(name='PreLevel'),
      ruleName?: string(name='RuleName'),
      state?: string(name='State'),
      status?: int32(name='Status'),
      userId?: string(name='UserId'),
      value?: string(name='Value'),
      webhooks?: string(name='Webhooks'),
    }
  ](name='AlarmHistory')
  }(name='AlarmHistoryList'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: string(name='Total'),
}

model DescribeAlarmHistoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAlarmHistoryResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeAlarmHistory  DescribeAlarmHistoryRequest
  * @return DescribeAlarmHistoryResponse
 */
async function describeAlarmHistory(request: DescribeAlarmHistoryRequest): DescribeAlarmHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAlarmHistory', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAlarmsRequest {
  alertState?: string(name='AlertState', position='Query'),
  displayName?: string(name='DisplayName', position='Query'),
  enableState?: boolean(name='EnableState', position='Query'),
  groupBy?: string(name='GroupBy', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  metricName?: string(name='MetricName', position='Query'),
  nameKeyword?: string(name='NameKeyword', position='Query'),
  names?: string(name='Names', position='Query'),
  namespace?: string(name='Namespace', position='Query'),
  page?: string(name='Page', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
}

model DescribeAlarmsResponseBody = {
  code?: int32(name='Code'),
  datapoints?: {
    alarm?: [ 
    {
      comparisonOperator?: string(name='ComparisonOperator'),
      contactGroups?: string(name='ContactGroups'),
      dimensions?: string(name='Dimensions'),
      displayName?: string(name='DisplayName'),
      effectiveInterval?: string(name='EffectiveInterval'),
      enable?: boolean(name='Enable'),
      escalations?: {
        critical?: {
          alertSensitivity?: string(name='AlertSensitivity'),
          comparisonOperator?: string(name='ComparisonOperator'),
          historyDataRange?: string(name='HistoryDataRange'),
          preCondition?: string(name='PreCondition'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Critical'),
        info?: {
          alertSensitivity?: string(name='AlertSensitivity'),
          comparisonOperator?: string(name='ComparisonOperator'),
          historyDataRange?: string(name='HistoryDataRange'),
          preCondition?: string(name='PreCondition'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Info'),
        warn?: {
          alertSensitivity?: string(name='AlertSensitivity'),
          comparisonOperator?: string(name='ComparisonOperator'),
          historyDataRange?: string(name='HistoryDataRange'),
          preCondition?: string(name='PreCondition'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Warn'),
      }(name='Escalations'),
      evaluationCount?: string(name='EvaluationCount'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      level?: string(name='Level'),
      metricName?: string(name='MetricName'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      period?: string(name='Period'),
      resources?: string(name='Resources'),
      ruleName?: string(name='RuleName'),
      ruleType?: string(name='RuleType'),
      silenceTime?: string(name='SilenceTime'),
      state?: string(name='State'),
      statistics?: string(name='Statistics'),
      subject?: string(name='Subject'),
      threshold?: string(name='Threshold'),
      uuid?: string(name='Uuid'),
      webhook?: string(name='Webhook'),
    }
  ](name='Alarm')
  }(name='Datapoints'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: string(name='Total'),
  traceId?: string(name='TraceId'),
}

model DescribeAlarmsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAlarmsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeAlarms  DescribeAlarmsRequest
  * @return DescribeAlarmsResponse
 */
async function describeAlarms(request: DescribeAlarmsRequest): DescribeAlarmsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAlarms', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAlarmsForResourcesRequest {
  alertState?: string(name='AlertState', position='Query'),
  dimensions: string(name='Dimensions', description='This parameter is required.', position='Query'),
  enableState?: boolean(name='EnableState', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  metricName?: string(name='MetricName', position='Query'),
  namespace: string(name='Namespace', description='This parameter is required.', position='Query'),
  page?: string(name='Page', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
}

model DescribeAlarmsForResourcesResponseBody = {
  code?: int32(name='Code'),
  datapoints?: {
    alarm?: [ 
    {
      comparisonOperator?: string(name='ComparisonOperator'),
      contactGroups?: string(name='ContactGroups'),
      displayName?: string(name='DisplayName'),
      effectiveInterval?: string(name='EffectiveInterval'),
      enable?: boolean(name='Enable'),
      escalations?: {
        critical?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Critical'),
        info?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Info'),
        warn?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Warn'),
      }(name='Escalations'),
      evaluationCount?: string(name='EvaluationCount'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      level?: string(name='Level'),
      metricName?: string(name='MetricName'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      period?: string(name='Period'),
      resources?: string(name='Resources'),
      silenceTime?: string(name='SilenceTime'),
      state?: string(name='State'),
      statistics?: string(name='Statistics'),
      subject?: string(name='Subject'),
      threshold?: string(name='Threshold'),
      uuid?: string(name='Uuid'),
      webhook?: string(name='Webhook'),
    }
  ](name='Alarm')
  }(name='Datapoints'),
  dimensions?: string(name='Dimensions'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: string(name='Total'),
  traceId?: string(name='TraceId'),
}

model DescribeAlarmsForResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAlarmsForResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeAlarmsForResources  DescribeAlarmsForResourcesRequest
  * @return DescribeAlarmsForResourcesResponse
 */
async function describeAlarmsForResources(request: DescribeAlarmsForResourcesRequest): DescribeAlarmsForResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAlarmsForResources', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAlertHistoryListRequest {
  alertName?: string(name='AlertName', position='Query'),
  ascending?: boolean(name='Ascending', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  metricName?: string(name='MetricName', position='Query'),
  namespace?: string(name='Namespace', position='Query'),
  onlyCount?: boolean(name='OnlyCount', position='Query'),
  page?: int32(name='Page', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  ruleName?: string(name='RuleName', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  state?: string(name='State', position='Query'),
  status?: string(name='Status', position='Query'),
}

model DescribeAlertHistoryListResponseBody = {
  alarmHistoryList?: {
    alarmHistory?: [ 
    {
      alertName?: string(name='AlertName'),
      alertTime?: long(name='AlertTime'),
      contactALIIMs?: {
        contactALIIM?: [ string ](name='ContactALIIM')
      }(name='ContactALIIMs'),
      contactGroups?: {
        contactGroup?: [ string ](name='ContactGroup')
      }(name='ContactGroups'),
      contactMails?: {
        contactMail?: [ string ](name='ContactMail')
      }(name='ContactMails'),
      contactSmses?: {
        contactSms?: [ string ](name='ContactSms')
      }(name='ContactSmses'),
      contacts?: {
        contact?: [ string ](name='Contact')
      }(name='Contacts'),
      dimensions?: string(name='Dimensions'),
      evaluationCount?: int32(name='EvaluationCount'),
      expression?: string(name='Expression'),
      groupId?: string(name='GroupId'),
      id?: string(name='Id'),
      instanceName?: string(name='InstanceName'),
      lastTime?: long(name='LastTime'),
      level?: string(name='Level'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      preLevel?: string(name='PreLevel'),
      ruleName?: string(name='RuleName'),
      state?: string(name='State'),
      status?: int32(name='Status'),
      userId?: string(name='UserId'),
      value?: string(name='Value'),
      webhooks?: string(name='Webhooks'),
    }
  ](name='AlarmHistory')
  }(name='AlarmHistoryList'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: string(name='Total'),
}

model DescribeAlertHistoryListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAlertHistoryListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeAlertHistoryList  DescribeAlertHistoryListRequest
  * @return DescribeAlertHistoryListResponse
 */
async function describeAlertHistoryList(request: DescribeAlertHistoryListRequest): DescribeAlertHistoryListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAlertHistoryList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeContactRequest {
  contactName: string(name='ContactName', description='This parameter is required.', position='Query'),
}

model DescribeContactResponseBody = {
  code?: int32(name='Code'),
  datapoints?: {
    channels?: {
      channel?: [ 
      {
        type?: string(name='Type'),
        value?: string(name='Value'),
      }
    ](name='Channel')
    }(name='Channels'),
    name?: string(name='Name'),
  }(name='Datapoints'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeContactResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeContactResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeContact  DescribeContactRequest
  * @return DescribeContactResponse
 */
async function describeContact(request: DescribeContactRequest): DescribeContactResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeContact', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHybridDoubleWriteRequest {
  sourceNamespace?: string(name='SourceNamespace', example='test-source', position='Query'),
  sourceUserId?: string(name='SourceUserId', example='12706766**********', position='Query'),
  targetNamespace?: string(name='TargetNamespace', position='Query'),
  targetUserId?: string(name='TargetUserId', position='Query'),
}

model DescribeHybridDoubleWriteResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='Success'),
  requestId?: string(name='RequestId', example='7985D471-3FA8-4EE9-8F4B-45C19DF3D36F'),
  result?: [ 
    {
      namespace?: string(name='Namespace', example='test-target'),
      sourceNamespace?: string(name='SourceNamespace', example='test-source'),
      sourceUserId?: long(name='SourceUserId', example='12706766**********'),
      userId?: long(name='UserId', example='11234766**********'),
    }
  ](name='Result'),
  success?: string(name='Success', example='true'),
}

model DescribeHybridDoubleWriteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHybridDoubleWriteResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeHybridDoubleWrite  DescribeHybridDoubleWriteRequest
  * @return DescribeHybridDoubleWriteResponse
 */
async function describeHybridDoubleWrite(request: DescribeHybridDoubleWriteRequest): DescribeHybridDoubleWriteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHybridDoubleWrite', 'POST', '/', 'json', false, 'json', request);
}

model DescribeISPAreaCityRequest {
  city?: string(name='City', position='Query'),
  isp?: string(name='Isp', position='Query'),
}

model DescribeISPAreaCityResponseBody = {
  code?: string(name='Code', example='200'),
  data?: string(name='Data'),
  message?: string(name='Message', example='successful'),
  requestId?: string(name='RequestId', example='84C8BA48-7FD3-46F8-AEE3-E24657C22289'),
  success?: string(name='Success', example='true'),
}

model DescribeISPAreaCityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeISPAreaCityResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeISPAreaCity  DescribeISPAreaCityRequest
  * @return DescribeISPAreaCityResponse
 */
async function describeISPAreaCity(request: DescribeISPAreaCityRequest): DescribeISPAreaCityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeISPAreaCity', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMetricRuleListRequest {
  alertState?: string(name='AlertState', position='Query'),
  dimensions?: string(name='Dimensions', position='Query'),
  enableState?: boolean(name='EnableState', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  metricName?: string(name='MetricName', position='Query'),
  namespace?: string(name='Namespace', position='Query'),
  page?: string(name='Page', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  ruleIds?: string(name='RuleIds', position='Query'),
  ruleName?: string(name='RuleName', position='Query'),
}

model DescribeMetricRuleListResponseBody = {
  alarms?: {
    alarm?: [ 
    {
      alertState?: string(name='AlertState'),
      contactGroups?: string(name='ContactGroups'),
      dimensions?: string(name='Dimensions'),
      effectiveInterval?: string(name='EffectiveInterval'),
      enableState?: boolean(name='EnableState'),
      escalations?: {
        critical?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Critical'),
        info?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Info'),
        warn?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Warn'),
      }(name='Escalations'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      mailSubject?: string(name='MailSubject'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      period?: string(name='Period'),
      resources?: string(name='Resources'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      silenceTime?: string(name='SilenceTime'),
      sourceType?: string(name='SourceType'),
      webhook?: string(name='Webhook'),
    }
  ](name='Alarm')
  }(name='Alarms'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: string(name='Total'),
}

model DescribeMetricRuleListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMetricRuleListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeMetricRuleList  DescribeMetricRuleListRequest
  * @return DescribeMetricRuleListResponse
 */
async function describeMetricRuleList(request: DescribeMetricRuleListRequest): DescribeMetricRuleListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMetricRuleList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTaskDetailRequest {
  taskId: string(name='TaskId', description='This parameter is required.', example='339e0d96-2505-425f-a5c6-22e2c12f8fee', position='Query'),
}

model DescribeTaskDetailResponseBody = {
  code?: string(name='Code', example='200'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', example='a4e6f550-7eac-4a13-b11f-6742aa2d42d1'),
  success?: string(name='Success', example='true'),
}

model DescribeTaskDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTaskDetailResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeTaskDetail  DescribeTaskDetailRequest
  * @return DescribeTaskDetailResponse
 */
async function describeTaskDetail(request: DescribeTaskDetailRequest): DescribeTaskDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTaskDetail', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTasksRequest {
  keyword?: string(name='Keyword', position='Query'),
  page?: int32(name='Page', example='1', position='Query'),
  pageSize?: int32(name='PageSize', example='10', position='Query'),
  taskId?: string(name='TaskId', example='18b0c27f-bab3-441d-a747-9cdcaa8bbac8', position='Query'),
  taskType?: string(name='TaskType', example='1', position='Query'),
}

model DescribeTasksResponseBody = {
  code?: string(name='Code', example='200'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='1'),
  requestId?: string(name='RequestId', example='6A46B8E4-D39E-4DB5-B422-231410654E8E'),
  success?: string(name='Success', example='true'),
  totalCount?: int32(name='TotalCount', example='14'),
}

model DescribeTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeTasks  DescribeTasksRequest
  * @return DescribeTasksResponse
 */
async function describeTasks(request: DescribeTasksRequest): DescribeTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTasks', 'POST', '/', 'json', false, 'json', request);
}

model DisableAlarmRequest {
  id: string(name='Id', description='This parameter is required.', example='576fbae7-2fd1-411a-ae13-6f09f4fafdde', position='Query'),
}

model DisableAlarmResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='Success'),
  requestId?: string(name='RequestId', example='DEF01F10-E747-42FE-9152-85CB43B1B552'),
  success?: boolean(name='Success', example='true'),
}

model DisableAlarmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableAlarmResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DisableAlarm  DisableAlarmRequest
  * @return DisableAlarmResponse
 */
async function disableAlarm(request: DisableAlarmRequest): DisableAlarmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableAlarm', 'POST', '/', 'json', false, 'json', request);
}

model EnableAlarmRequest {
  id: string(name='Id', description='This parameter is required.', example='576fbae7-2fd1-411a-ae13-6f09f4fafdde', position='Query'),
}

model EnableAlarmResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='Success'),
  requestId?: string(name='RequestId', example='1C5E0E5D-76D5-469C-9FA8-D74799B24860'),
  success?: boolean(name='Success', example='true'),
}

model EnableAlarmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableAlarmResponseBody(name='body'),
}

/**
  * @param request  the request parameters of EnableAlarm  EnableAlarmRequest
  * @return EnableAlarmResponse
 */
async function enableAlarm(request: EnableAlarmRequest): EnableAlarmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableAlarm', 'POST', '/', 'json', false, 'json', request);
}

model GetContactsRequest {
  groupName: string(name='GroupName', description='This parameter is required.', position='Query'),
}

model GetContactsResponseBody = {
  code?: int32(name='Code'),
  datapoints?: {
    contacts?: {
      contact?: [ string ](name='Contact')
    }(name='Contacts'),
    name?: string(name='Name'),
  }(name='Datapoints'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetContactsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetContactsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetContacts  GetContactsRequest
  * @return GetContactsResponse
 */
async function getContacts(request: GetContactsRequest): GetContactsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetContacts', 'POST', '/', 'json', false, 'json', request);
}

model GetLineSplitResultRequest {
  line?: string(name='Line', position='Query'),
  prefix?: string(name='Prefix', position='Query'),
  regex?: string(name='Regex', position='Query'),
  selectContent?: string(name='SelectContent', position='Query'),
  splitType?: string(name='SplitType', example='simple|regex', position='Query'),
}

model GetLineSplitResultResponseBody = {
  code?: long(name='Code'),
  errorCode?: long(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  resource?: {
    additionalRegex?: string(name='AdditionalRegex'),
    endSplitSymbol?: string(name='EndSplitSymbol'),
    regex?: string(name='Regex'),
    regexSplitResult?: [ string ](name='RegexSplitResult'),
    startSplitSymbol?: string(name='StartSplitSymbol'),
    startSplitSymbolIndex?: long(name='StartSplitSymbolIndex'),
  }(name='Resource'),
  success?: boolean(name='Success'),
}

model GetLineSplitResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLineSplitResultResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetLineSplitResult  GetLineSplitResultRequest
  * @return GetLineSplitResultResponse
 */
async function getLineSplitResult(request: GetLineSplitResultRequest): GetLineSplitResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetLineSplitResult', 'POST', '/', 'json', false, 'json', request);
}

model GetLogColumnTranslateResultRequest {
  columnValue?: string(name='ColumnValue', position='Query'),
  translateConfig?: string(name='TranslateConfig', position='Query'),
}

model GetLogColumnTranslateResultResponseBody = {
  code?: long(name='Code'),
  errorCode?: long(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resource?: string(name='Resource'),
  success?: boolean(name='Success'),
}

model GetLogColumnTranslateResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLogColumnTranslateResultResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetLogColumnTranslateResult  GetLogColumnTranslateResultRequest
  * @return GetLogColumnTranslateResultResponse
 */
async function getLogColumnTranslateResult(request: GetLogColumnTranslateResultRequest): GetLogColumnTranslateResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetLogColumnTranslateResult', 'POST', '/', 'json', false, 'json', request);
}

model GetMonitoringTemplateRequest {
  id?: string(name='Id', position='Query'),
  name?: string(name='Name', position='Query'),
}

model GetMonitoringTemplateResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  resource?: {
    alertTemplatesJson?: string(name='AlertTemplatesJson'),
    description?: string(name='Description'),
    hostAvailabilityTemplate?: string(name='HostAvailabilityTemplate'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    namespace?: string(name='Namespace'),
    processMonitorTemplates?: string(name='ProcessMonitorTemplates'),
    restVersion?: string(name='RestVersion'),
    systemEventTemplates?: string(name='SystemEventTemplates'),
  }(name='Resource'),
  success?: boolean(name='Success'),
}

model GetMonitoringTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMonitoringTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetMonitoringTemplate  GetMonitoringTemplateRequest
  * @return GetMonitoringTemplateResponse
 */
async function getMonitoringTemplate(request: GetMonitoringTemplateRequest): GetMonitoringTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMonitoringTemplate', 'POST', '/', 'json', false, 'json', request);
}

model GetMyGroupsRequest {
  bindUrl?: string(name='BindUrl', position='Query'),
  groupId?: long(name='GroupId', position='Query'),
  groupName?: string(name='GroupName', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  selectContactGroups?: boolean(name='SelectContactGroups', position='Query'),
  type?: string(name='Type', position='Query'),
}

model GetMyGroupsResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  group?: {
    bindUrl?: string(name='BindUrl'),
    contactGroups?: {
      contactGroup?: [ 
      {
        name?: string(name='Name'),
      }
    ](name='ContactGroup')
    }(name='ContactGroups'),
    groupId?: long(name='GroupId'),
    groupName?: string(name='GroupName'),
    serviceId?: long(name='ServiceId'),
    type?: string(name='Type'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMyGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMyGroupsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetMyGroups  GetMyGroupsRequest
  * @return GetMyGroupsResponse
 */
async function getMyGroups(request: GetMyGroupsRequest): GetMyGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMyGroups', 'POST', '/', 'json', false, 'json', request);
}

model ListAlarmRequest {
  dimension?: string(name='Dimension', example='{"instanceId":"XXX"}', position='Query'),
  id?: string(name='Id', example='i-2ze3w55tr2rcpejpcfap_72071739-396b-497d-849c-59a73de44bcf', position='Query'),
  isEnable?: boolean(name='IsEnable', example='true', position='Query'),
  name?: string(name='Name', position='Query'),
  namespace?: string(name='Namespace', example='acs_ecs_dashboard', position='Query'),
  pageNumber?: int32(name='PageNumber', example='1', position='Query'),
  pageSize?: int32(name='PageSize', example='2', position='Query'),
  state?: string(name='State', example='ok', position='Query'),
}

model ListAlarmResponseBody = {
  alarmList?: {
    alarm?: [ 
    {
      comparisonOperator?: string(name='ComparisonOperator', example='>'),
      contactGroups?: string(name='ContactGroups', example='["test4nudou"]'),
      dimensions?: string(name='Dimensions', example='["{\\"instanceId\\":\\" i-abcdefgh123456\\"}"]'),
      enable?: boolean(name='Enable', example='true'),
      endTime?: int32(name='EndTime', example='24'),
      evaluationCount?: int32(name='EvaluationCount', example='3'),
      id?: string(name='Id', example='i-2ze3w55tr2rcpejpcfap_72071739-396b-497d-849c-59a73de44bcf'),
      metricName?: string(name='MetricName', example='CPUUtilization'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace', example='acs_ecs_dashboard'),
      notifyType?: int32(name='NotifyType', example='0'),
      period?: int32(name='Period', example='300'),
      silenceTime?: int32(name='SilenceTime', example='86400'),
      startTime?: int32(name='StartTime', example='0'),
      state?: string(name='State', example='ok'),
      statistics?: string(name='Statistics', example='Average'),
      threshold?: string(name='Threshold', example='90'),
      webhook?: string(name='Webhook', example='null'),
    }
  ](name='Alarm')
  }(name='AlarmList'),
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='Success'),
  nextToken?: int32(name='NextToken', example='2'),
  requestId?: string(name='RequestId', example='EFD27F56-5799-4CE8-B625-56DF3332331C'),
  success?: boolean(name='Success', example='true'),
  total?: int32(name='Total', example='27'),
}

model ListAlarmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAlarmResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListAlarm  ListAlarmRequest
  * @return ListAlarmResponse
 */
async function listAlarm(request: ListAlarmRequest): ListAlarmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAlarm', 'POST', '/', 'json', false, 'json', request);
}

model ListAlarmHistoryRequest {
  cursor?: string(name='Cursor', example='1', position='Query'),
  endTime?: string(name='EndTime', example='1548927491223', position='Query'),
  id?: string(name='Id', example='1a775e37-dfba-430c-ab9f-7036475c8bfb_2dbe619b-0483-402e-9437-7c7a38fba7ed', position='Query'),
  size?: int32(name='Size', example='3', position='Query'),
  startTime?: string(name='StartTime', example='1548913091223', position='Query'),
}

model ListAlarmHistoryResponseBody = {
  alarmHistoryList?: {
    alarmHistory?: [ 
    {
      alarmTime?: long(name='AlarmTime', example='1548926982000'),
      contactGroups?: string(name='ContactGroups'),
      dimension?: string(name='Dimension', example='{"instanceId":"XXX"}'),
      evaluationCount?: int32(name='EvaluationCount', example='3'),
      id?: string(name='Id', example='1a775e37-dfba-430c-ab9f-7036475c8bfb_2dbe619b-0483-402e-9437-7c7a38fba7ed'),
      instanceName?: string(name='InstanceName', example='test-demo'),
      lastTime?: long(name='LastTime', example='2851651669'),
      metricName?: string(name='MetricName', example='CPUUtilization'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace', example='acs_ecs_dashboard'),
      state?: string(name='State', example='ALARM'),
      status?: int32(name='Status', example='2'),
      value?: string(name='Value', example='84401454'),
    }
  ](name='AlarmHistory')
  }(name='AlarmHistoryList'),
  code?: string(name='Code', example='200'),
  cursor?: string(name='Cursor', example='1'),
  message?: string(name='Message', example='Success'),
  requestId?: string(name='RequestId', example='1DBBCE29-0F69-435C-B65C-53D1011D1D72'),
  success?: boolean(name='Success', example='true'),
}

model ListAlarmHistoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAlarmHistoryResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListAlarmHistory  ListAlarmHistoryRequest
  * @return ListAlarmHistoryResponse
 */
async function listAlarmHistory(request: ListAlarmHistoryRequest): ListAlarmHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAlarmHistory', 'POST', '/', 'json', false, 'json', request);
}

model ListContactGroupRequest {
  pageNumber?: int32(name='PageNumber', example='1', position='Query'),
  pageSize?: int32(name='PageSize', example='100', position='Query'),
}

model ListContactGroupResponseBody = {
  code?: string(name='Code', example='200'),
  contactGroups?: {
    contactGroup?: [ string ](name='ContactGroup')
  }(name='ContactGroups'),
  message?: string(name='Message', example='Success'),
  nextToken?: int32(name='NextToken', example='2'),
  requestId?: string(name='RequestId', example='D3D03B0A-CF1A-4DAB-BF0D-D4B6ACD5677A'),
  success?: boolean(name='Success', example='true'),
  total?: int32(name='Total', example='3'),
}

model ListContactGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListContactGroupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListContactGroup  ListContactGroupRequest
  * @return ListContactGroupResponse
 */
async function listContactGroup(request: ListContactGroupRequest): ListContactGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListContactGroup', 'POST', '/', 'json', false, 'json', request);
}

model ListEventRulesRequest {
  groupId?: string(name='GroupId', position='Query'),
  namePrefix?: string(name='NamePrefix', position='Query'),
  page?: string(name='Page', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
}

model ListEventRulesResponseBody = {
  code?: string(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  datapoints?: {
    eventRule?: [ 
    {
      description?: string(name='Description'),
      eventPattern?: {
        eventPattern?: [ 
        {
          eventTypeList?: {
            eventTypeList?: [ string ](name='EventTypeList')
          }(name='EventTypeList'),
          levelList?: {
            levelList?: [ string ](name='LevelList')
          }(name='LevelList'),
          nameList?: {
            nameList?: [ string ](name='NameList')
          }(name='NameList'),
          product?: string(name='Product'),
          statusList?: {
            statusList?: [ string ](name='StatusList')
          }(name='StatusList'),
        }
      ](name='EventPattern')
      }(name='EventPattern'),
      eventType?: string(name='EventType'),
      groupId?: string(name='GroupId'),
      name?: string(name='Name'),
      state?: string(name='State'),
    }
  ](name='EventRule')
  }(name='Datapoints'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListEventRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEventRulesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListEventRules  ListEventRulesRequest
  * @return ListEventRulesResponse
 */
async function listEventRules(request: ListEventRulesRequest): ListEventRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEventRules', 'POST', '/', 'json', false, 'json', request);
}

model ListMyGroupInstancesRequest {
  category?: string(name='Category', position='Query'),
  groupId: long(name='GroupId', description='This parameter is required.', position='Query'),
  instanceIds?: string(name='InstanceIds', position='Query'),
  keyword?: string(name='Keyword', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  total?: boolean(name='Total', position='Query'),
}

model ListMyGroupInstancesResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  resources?: {
    resource?: [ 
    {
      aliUid?: long(name='AliUid'),
      category?: string(name='Category'),
      id?: long(name='Id'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Resource')
  }(name='Resources'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListMyGroupInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMyGroupInstancesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMyGroupInstances  ListMyGroupInstancesRequest
  * @return ListMyGroupInstancesResponse
 */
async function listMyGroupInstances(request: ListMyGroupInstancesRequest): ListMyGroupInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMyGroupInstances', 'POST', '/', 'json', false, 'json', request);
}

model ListMyGroupsRequest {
  bindUrls?: string(name='BindUrls', position='Query'),
  groupName?: string(name='GroupName', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  keyword?: string(name='Keyword', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  selectContactGroups?: boolean(name='SelectContactGroups', position='Query'),
  type?: string(name='Type', position='Query'),
}

model ListMyGroupsResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  resources?: {
    resource?: [ 
    {
      bindUrl?: string(name='BindUrl'),
      bindUrls?: string(name='BindUrls'),
      contactGroups?: {
        contactGroup?: [ 
        {
          name?: string(name='Name'),
        }
      ](name='ContactGroup')
      }(name='ContactGroups'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      groupId?: long(name='GroupId'),
      groupName?: string(name='GroupName'),
      serviceId?: string(name='ServiceId'),
      type?: string(name='Type'),
    }
  ](name='Resource')
  }(name='Resources'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListMyGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMyGroupsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMyGroups  ListMyGroupsRequest
  * @return ListMyGroupsResponse
 */
async function listMyGroups(request: ListMyGroupsRequest): ListMyGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMyGroups', 'POST', '/', 'json', false, 'json', request);
}

model ModifyTaskRequest {
  address?: string(name='Address', example='http://www.aliyun.com', position='Query'),
  alertIds?: string(name='AlertIds', example='5e9b-4c12-b39e-7f277ac44b11', position='Query'),
  alertRule?: string(name='AlertRule', example='[{"alarmActions":"xxx","metricName":"Availability","expression":"$Availability<96"}]', position='Query'),
  interval?: string(name='Interval', example='1', position='Query'),
  intervalUnit?: string(name='IntervalUnit', position='Query'),
  ispCity?: string(name='IspCity', example='[{"city":"546","isp":"465"},{"city":"572","isp":"465"},{"city":"738","isp":"465"}]', position='Query'),
  options?: string(name='Options', position='Query'),
  taskId: string(name='TaskId', description='This parameter is required.', example='8f880e3d-d924-47ab-84d2-fa1a72e24211', position='Query'),
  taskName?: string(name='TaskName', example='aliyunTest', position='Query'),
  caller?: string(name='caller', example='cms', position='Query'),
}

model ModifyTaskResponseBody = {
  code?: string(name='Code', example='200'),
  data?: string(name='Data', example='{"count":1}'),
  message?: string(name='Message', example='successfull'),
  requestId?: string(name='RequestId', example='a4e6f550-7eac-4a13-b11f-6742aa2d42d1'),
  success?: string(name='Success', example='true'),
}

model ModifyTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyTask  ModifyTaskRequest
  * @return ModifyTaskResponse
 */
async function modifyTask(request: ModifyTaskRequest): ModifyTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyTask', 'POST', '/', 'json', false, 'json', request);
}

model NodeListRequest {
  hostName?: string(name='HostName', position='Query'),
  instanceIds?: string(name='InstanceIds', position='Query'),
  instanceRegionId?: string(name='InstanceRegionId', position='Query'),
  keyWord?: string(name='KeyWord', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  serialNumbers?: string(name='SerialNumbers', position='Query'),
  status?: string(name='Status', position='Query'),
  userId: long(name='UserId', description='This parameter is required.', position='Query'),
}

model NodeListResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  nodes?: {
    node?: [ 
    {
      aliUid?: long(name='AliUid'),
      aliyunHost?: boolean(name='AliyunHost'),
      eipAddress?: string(name='EipAddress'),
      eipId?: string(name='EipId'),
      hostName?: string(name='HostName'),
      instanceId?: string(name='InstanceId'),
      instanceTypeFamily?: string(name='InstanceTypeFamily'),
      ipGroup?: string(name='IpGroup'),
      natIp?: string(name='NatIp'),
      networkType?: string(name='NetworkType'),
      operatingSystem?: string(name='OperatingSystem'),
      region?: string(name='Region'),
      serialNumber?: string(name='SerialNumber'),
      tianjimonVersion?: string(name='TianjimonVersion'),
    }
  ](name='Node')
  }(name='Nodes'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  pageTotal?: int32(name='PageTotal'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model NodeListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: NodeListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of NodeList  NodeListRequest
  * @return NodeListResponse
 */
async function nodeList(request: NodeListRequest): NodeListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'NodeList', 'POST', '/', 'json', false, 'json', request);
}

model NodeProcessCreateRequest {
  command?: string(name='Command', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  name?: string(name='Name', position='Query'),
  processName?: string(name='ProcessName', position='Query'),
  processUser?: string(name='ProcessUser', position='Query'),
}

model NodeProcessCreateResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model NodeProcessCreateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: NodeProcessCreateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of NodeProcessCreate  NodeProcessCreateRequest
  * @return NodeProcessCreateResponse
 */
async function nodeProcessCreate(request: NodeProcessCreateRequest): NodeProcessCreateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'NodeProcessCreate', 'POST', '/', 'json', false, 'json', request);
}

model NodeProcessesRequest {
  instanceId?: string(name='InstanceId', position='Query'),
}

model NodeProcessesResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  nodeProcesses?: {
    nodeProcess?: [ 
    {
      command?: string(name='Command'),
      id?: long(name='Id'),
      instanceId?: string(name='InstanceId'),
      name?: string(name='Name'),
      processName?: string(name='ProcessName'),
      processUser?: string(name='ProcessUser'),
    }
  ](name='NodeProcess')
  }(name='NodeProcesses'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model NodeProcessesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: NodeProcessesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of NodeProcesses  NodeProcessesRequest
  * @return NodeProcessesResponse
 */
async function nodeProcesses(request: NodeProcessesRequest): NodeProcessesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'NodeProcesses', 'POST', '/', 'json', false, 'json', request);
}

model NodeStatusListRequest {
  instanceIds: string(name='InstanceIds', description='This parameter is required.', example='i-abcdefgh123456,i-abcdefgh123457', position='Query'),
}

model NodeStatusListResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  errorMessage?: string(name='ErrorMessage', example='InstanceIds is mandatory for this action.'),
  nodeStatusList?: {
    nodeStatus?: [ 
    {
      autoInstall?: boolean(name='AutoInstall', example='true'),
      instanceId?: string(name='InstanceId', example='i-abcdefgh123456'),
      status?: string(name='Status', example='running'),
    }
  ](name='NodeStatus')
  }(name='NodeStatusList'),
  requestId?: string(name='RequestId', example='1BB8FE8E-9BBE-490F-82EC-BF70FB849D55'),
  success?: boolean(name='Success', example='true'),
}

model NodeStatusListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: NodeStatusListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of NodeStatusList  NodeStatusListRequest
  * @return NodeStatusListResponse
 */
async function nodeStatusList(request: NodeStatusListRequest): NodeStatusListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'NodeStatusList', 'POST', '/', 'json', false, 'json', request);
}

model NodeUninstallRequest {
  instanceId?: string(name='InstanceId', position='Query'),
}

model NodeUninstallResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model NodeUninstallResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: NodeUninstallResponseBody(name='body'),
}

/**
  * @param request  the request parameters of NodeUninstall  NodeUninstallRequest
  * @return NodeUninstallResponse
 */
async function nodeUninstall(request: NodeUninstallRequest): NodeUninstallResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'NodeUninstall', 'POST', '/', 'json', false, 'json', request);
}

model PutCustomMetricRequest {
  metricList?: string(name='MetricList', position='Query'),
}

model PutCustomMetricResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model PutCustomMetricResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PutCustomMetricResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PutCustomMetric  PutCustomMetricRequest
  * @return PutCustomMetricResponse
 */
async function putCustomMetric(request: PutCustomMetricRequest): PutCustomMetricResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PutCustomMetric', 'POST', '/', 'json', false, 'json', request);
}

model PutEventRequest {
  eventInfo?: string(name='EventInfo', position='Query'),
}

model PutEventResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model PutEventResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PutEventResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PutEvent  PutEventRequest
  * @return PutEventResponse
 */
async function putEvent(request: PutEventRequest): PutEventResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PutEvent', 'POST', '/', 'json', false, 'json', request);
}

model PutEventRuleRequest {
  description?: string(name='Description', position='Query'),
  eventPattern: [ 
    {
      eventTypeList?: [ string ](name='EventTypeList'),
      levelList?: [ string ](name='LevelList'),
      nameList?: [ string ](name='NameList'),
      product?: string(name='Product'),
      statusList?: [ string ](name='StatusList'),
    }
  ](name='EventPattern', description='This parameter is required.', position='Query'),
  eventType?: string(name='EventType', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  name: string(name='Name', description='This parameter is required.', position='Query'),
  state?: string(name='State', position='Query'),
}

model PutEventRuleResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutEventRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PutEventRuleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PutEventRule  PutEventRuleRequest
  * @return PutEventRuleResponse
 */
async function putEventRule(request: PutEventRuleRequest): PutEventRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PutEventRule', 'POST', '/', 'json', false, 'json', request);
}

model PutEventTargetsRequest {
  contactParameters?: [ 
    {
      contactGroupName?: string(name='ContactGroupName'),
      id?: string(name='Id'),
      level?: string(name='Level'),
    }
  ](name='ContactParameters', position='Query'),
  fcParameters?: [ 
    {
      functionName?: string(name='FunctionName'),
      id?: string(name='Id'),
      region?: string(name='Region'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='FcParameters', position='Query'),
  mnsParameters?: [ 
    {
      id?: string(name='Id'),
      queue?: string(name='Queue'),
      region?: string(name='Region'),
    }
  ](name='MnsParameters', position='Query'),
  ruleName: string(name='RuleName', description='This parameter is required.', position='Query'),
  slsParameters?: [ 
    {
      id?: string(name='Id'),
      logStore?: string(name='LogStore'),
      project?: string(name='Project'),
      region?: string(name='Region'),
    }
  ](name='SlsParameters', position='Query'),
  webhookParameters?: [ 
    {
      id?: string(name='Id'),
      method?: string(name='Method'),
      protocol?: string(name='Protocol'),
      url?: string(name='Url'),
    }
  ](name='WebhookParameters', position='Query'),
}

model PutEventTargetsResponseBody = {
  code?: string(name='Code'),
  contactParameters?: {
    contactParameter?: [ 
    {
      contactGroupName?: string(name='ContactGroupName'),
      id?: int32(name='Id'),
      level?: string(name='Level'),
    }
  ](name='ContactParameter')
  }(name='ContactParameters'),
  failedContactParameters?: {
    contactParameter?: [ 
    {
      contactGroupName?: string(name='ContactGroupName'),
      id?: int32(name='Id'),
      level?: string(name='Level'),
    }
  ](name='ContactParameter')
  }(name='FailedContactParameters'),
  failedFcParameters?: {
    fcParameter?: [ 
    {
      functionName?: string(name='FunctionName'),
      id?: int32(name='Id'),
      region?: string(name='Region'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='FcParameter')
  }(name='FailedFcParameters'),
  failedMnsParameters?: {
    mnsParameter?: [ 
    {
      id?: int32(name='Id'),
      queue?: string(name='Queue'),
      region?: string(name='Region'),
    }
  ](name='MnsParameter')
  }(name='FailedMnsParameters'),
  failedParameterCount?: string(name='FailedParameterCount'),
  failedSlsParameters?: {
    failedSlsParameter?: [ 
    {
      id?: string(name='Id'),
      logStore?: string(name='LogStore'),
      project?: string(name='Project'),
      region?: string(name='Region'),
    }
  ](name='FailedSlsParameter')
  }(name='FailedSlsParameters'),
  fcParameters?: {
    fcParameter?: [ 
    {
      functionName?: string(name='FunctionName'),
      id?: int32(name='Id'),
      region?: string(name='Region'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='FcParameter')
  }(name='FcParameters'),
  message?: string(name='Message'),
  mnsParameters?: {
    mnsParameter?: [ 
    {
      id?: int32(name='Id'),
      queue?: string(name='Queue'),
      region?: string(name='Region'),
    }
  ](name='MnsParameter')
  }(name='MnsParameters'),
  parameterCount?: string(name='ParameterCount'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutEventTargetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PutEventTargetsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PutEventTargets  PutEventTargetsRequest
  * @return PutEventTargetsResponse
 */
async function putEventTargets(request: PutEventTargetsRequest): PutEventTargetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PutEventTargets', 'POST', '/', 'json', false, 'json', request);
}

model PutMetricRuleTargetsRequest {
  actions?: string(name='Actions', position='Body'),
  ruleName: string(name='RuleName', description='This parameter is required.', position='Query'),
  targets: [ 
    {
      arn?: string(name='Arn'),
      id?: string(name='Id'),
      level?: string(name='Level'),
    }
  ](name='Targets', description='This parameter is required.', position='Query'),
}

model PutMetricRuleTargetsResponseBody = {
  code?: string(name='Code'),
  failData?: {
    targets?: {
      target?: [ 
      {
        arn?: string(name='Arn'),
        id?: string(name='Id'),
        level?: string(name='Level'),
      }
    ](name='Target')
    }(name='Targets'),
  }(name='FailData'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutMetricRuleTargetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PutMetricRuleTargetsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PutMetricRuleTargets  PutMetricRuleTargetsRequest
  * @return PutMetricRuleTargetsResponse
 */
async function putMetricRuleTargets(request: PutMetricRuleTargetsRequest): PutMetricRuleTargetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PutMetricRuleTargets', 'POST', '/', 'json', true, 'form', request);
}

model PutResourceMetricRuleRequest {
  escalations?: {
    critical: {
        comparisonOperator?: string(name='ComparisonOperator'),
        statistics?: string(name='Statistics'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Critical'),
    info: {
        comparisonOperator?: string(name='ComparisonOperator'),
        statistics?: string(name='Statistics'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Info'),
    warn: {
        comparisonOperator?: string(name='ComparisonOperator'),
        statistics?: string(name='Statistics'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Warn'),
  }(name='Escalations', position='Query'),
  contactGroups?: string(name='ContactGroups', position='Query'),
  effectiveInterval?: string(name='EffectiveInterval', position='Query'),
  emailSubject?: string(name='EmailSubject', position='Query'),
  interval?: string(name='Interval', position='Query'),
  metricName: string(name='MetricName', description='This parameter is required.', position='Query'),
  namespace: string(name='Namespace', description='This parameter is required.', position='Query'),
  noEffectiveInterval?: string(name='NoEffectiveInterval', position='Query'),
  period?: string(name='Period', position='Query'),
  resources: string(name='Resources', description='This parameter is required.', position='Query'),
  ruleId: string(name='RuleId', description='This parameter is required.', position='Query'),
  ruleName?: string(name='RuleName', position='Query'),
  silenceTime?: int32(name='SilenceTime', position='Query'),
  webhook?: string(name='Webhook', position='Query'),
}

model PutResourceMetricRuleResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutResourceMetricRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PutResourceMetricRuleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PutResourceMetricRule  PutResourceMetricRuleRequest
  * @return PutResourceMetricRuleResponse
 */
async function putResourceMetricRule(request: PutResourceMetricRuleRequest): PutResourceMetricRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PutResourceMetricRule', 'POST', '/', 'json', false, 'json', request);
}

model QueryCustomMetricListRequest {
  dimension?: string(name='Dimension', position='Query'),
  groupId: string(name='GroupId', description='This parameter is required.', position='Query'),
  md5?: string(name='Md5', position='Query'),
  metricName?: string(name='MetricName', position='Query'),
  page?: string(name='Page', position='Query'),
  size?: string(name='Size', position='Query'),
}

model QueryCustomMetricListResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model QueryCustomMetricListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryCustomMetricListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryCustomMetricList  QueryCustomMetricListRequest
  * @return QueryCustomMetricListResponse
 */
async function queryCustomMetricList(request: QueryCustomMetricListRequest): QueryCustomMetricListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryCustomMetricList', 'POST', '/', 'json', false, 'json', request);
}

model QueryMetricDataRequest {
  dimensions?: string(name='Dimensions', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  express?: string(name='Express', position='Query'),
  length?: string(name='Length', position='Query'),
  metric: string(name='Metric', description='This parameter is required.', position='Query'),
  period?: string(name='Period', position='Query'),
  project: string(name='Project', description='This parameter is required.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model QueryMetricDataResponseBody = {
  code?: string(name='Code'),
  datapoints?: string(name='Datapoints'),
  message?: string(name='Message'),
  period?: string(name='Period'),
  requestId?: string(name='RequestId'),
}

model QueryMetricDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMetricDataResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMetricData  QueryMetricDataRequest
  * @return QueryMetricDataResponse
 */
async function queryMetricData(request: QueryMetricDataRequest): QueryMetricDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMetricData', 'POST', '/', 'json', false, 'json', request);
}

model QueryMetricLastRequest {
  cursor?: string(name='Cursor', example='1000', position='Query'),
  dimensions?: string(name='Dimensions', example='[{"instanceId":"XXX"}]', position='Query'),
  endTime?: string(name='EndTime', example='2019-01-31 10:10:00', position='Query'),
  express?: string(name='Express', example='{"groupby":["userId","instanceId"]}', position='Query'),
  length?: string(name='Length', example='1000', position='Query'),
  metric: string(name='Metric', description='This parameter is required.', example='CPUUtilization', position='Query'),
  page?: string(name='Page', example='1', position='Query'),
  period?: string(name='Period', example='60', position='Query'),
  project: string(name='Project', description='This parameter is required.', example='acs_ecs_dashboard', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', example='000', position='Query'),
  startTime?: string(name='StartTime', example='2019-01-31 10:00:00', position='Query'),
}

model QueryMetricLastResponseBody = {
  code?: string(name='Code', example='200'),
  cursor?: string(name='Cursor', example='10000'),
  datapoints?: string(name='Datapoints', example='[{"timestamp":1548900600000,"userId":"000","instanceId":"abc","Minimum":6.3,"Average":6.3,"Maximum":6.3}]'),
  message?: string(name='Message', example='Success'),
  period?: string(name='Period', example='60'),
  requestId?: string(name='RequestId', example='021472A6-25E3-4094-8D00-BA4B6A5486C3'),
  success?: string(name='Success', example='true'),
}

model QueryMetricLastResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMetricLastResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMetricLast  QueryMetricLastRequest
  * @return QueryMetricLastResponse
 */
async function queryMetricLast(request: QueryMetricLastRequest): QueryMetricLastResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMetricLast', 'POST', '/', 'json', false, 'json', request);
}

model QueryMetricListRequest {
  cursor?: string(name='Cursor', example='1000', position='Query'),
  dimensions?: string(name='Dimensions', example='[{"instanceId": "i-abcdefgh123456"}]', position='Query'),
  endTime?: string(name='EndTime', example='2019-01-30 00:10:00', position='Query'),
  express?: string(name='Express', example='{"groupby":["userId","instanceId"]}', position='Query'),
  length?: string(name='Length', example='1000', position='Query'),
  metric: string(name='Metric', description='This parameter is required.', example='cpu_idle', position='Query'),
  period?: string(name='Period', example='60', position='Query'),
  project: string(name='Project', description='This parameter is required.', example='acs_ecs_dashboard', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', example='000', position='Query'),
  startTime?: string(name='StartTime', example='2019-01-30 00:00:00', position='Query'),
}

model QueryMetricListResponseBody = {
  code?: string(name='Code', example='200'),
  cursor?: string(name='Cursor', example='1000'),
  datapoints?: string(name='Datapoints', example='[{"timestamp":1548777660000,"userId":"123","instanceId":"i-abc","Minimum":9.92,"Average":9.92,"Maximum":9.92}]'),
  message?: string(name='Message', example='Success'),
  period?: string(name='Period', example='60'),
  requestId?: string(name='RequestId', example='3121AE7D-4AFF-4C25-8F1D-C8226EBB1F42'),
  success?: string(name='Success', example='true'),
}

model QueryMetricListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMetricListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMetricList  QueryMetricListRequest
  * @return QueryMetricListResponse
 */
async function queryMetricList(request: QueryMetricListRequest): QueryMetricListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMetricList', 'POST', '/', 'json', false, 'json', request);
}

model QueryMetricMetaRequest {
  labels?: string(name='Labels', example='[{\\"name\\":\\"alertUnit\\",\\"value\\":\\"%\\"}]', position='Query'),
  metric?: string(name='Metric', example='CPUUtilization', position='Query'),
  pageNumber?: int32(name='PageNumber', example='1', position='Query'),
  pageSize?: int32(name='PageSize', example='30', position='Query'),
  project?: string(name='Project', example='acs_ecs_dashboard', position='Query'),
}

model QueryMetricMetaResponseBody = {
  errorCode?: string(name='ErrorCode', example='200'),
  errorMessage?: string(name='ErrorMessage', example='Success'),
  requestId?: string(name='RequestId', example='0CCE0AF0-053C-4B13-A583-DC9A85785D49'),
  resources?: {
    resource?: [ 
    {
      description?: string(name='Description', example='ECS.CPUUtilization'),
      dimensions?: string(name='Dimensions', example='instanceId'),
      labels?: string(name='Labels', example='[{\\"name\\":\\"alertUnit\\",\\"value\\":\\"%\\"},{\\"name\\":\\"alertDefault\\",\\"value\\":\\"80\\"},{\\"name\\":\\"minAlertPeriod\\",\\"value\\":\\"60\\"},{\\"name\\":\\"metricCategory\\",\\"value\\":\\"instanceId\\"},{\\"name\\":\\"is_alarm\\",\\"value\\":\\"true\\"}]"'),
      metric?: string(name='Metric', example='CPUUtilization'),
      periods?: string(name='Periods', example='60,300'),
      project?: string(name='Project', example='acs_ecs_dashboard'),
      statistics?: string(name='Statistics', example='Average,Minimum,Maximum'),
      unit?: string(name='Unit', example='%'),
    }
  ](name='Resource')
  }(name='Resources'),
  success?: boolean(name='Success', example='true'),
}

model QueryMetricMetaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMetricMetaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMetricMeta  QueryMetricMetaRequest
  * @return QueryMetricMetaResponse
 */
async function queryMetricMeta(request: QueryMetricMetaRequest): QueryMetricMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMetricMeta', 'POST', '/', 'json', false, 'json', request);
}

model QueryMetricTopRequest {
  dimensions?: string(name='Dimensions', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  express?: string(name='Express', position='Query'),
  length?: string(name='Length', position='Query'),
  metric: string(name='Metric', description='This parameter is required.', position='Query'),
  orderDesc?: string(name='OrderDesc', position='Query'),
  orderby?: string(name='Orderby', position='Query'),
  period?: string(name='Period', position='Query'),
  project: string(name='Project', description='This parameter is required.', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model QueryMetricTopResponseBody = {
  code?: string(name='Code'),
  datapoints?: string(name='Datapoints'),
  message?: string(name='Message'),
  period?: string(name='Period'),
  requestId?: string(name='RequestId'),
}

model QueryMetricTopResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMetricTopResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMetricTop  QueryMetricTopRequest
  * @return QueryMetricTopResponse
 */
async function queryMetricTop(request: QueryMetricTopRequest): QueryMetricTopResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMetricTop', 'POST', '/', 'json', false, 'json', request);
}

model QueryProjectMetaRequest {
  labels?: string(name='Labels', example='[{\\"name\\":\\"product\\",\\"value\\":\\"MongoDB\\"]', position='Query'),
  pageNumber?: int32(name='PageNumber', example='1', position='Query'),
  pageSize?: int32(name='PageSize', example='30', position='Query'),
}

model QueryProjectMetaResponseBody = {
  errorCode?: string(name='ErrorCode', example='200'),
  errorMessage?: string(name='ErrorMessage', example='Success'),
  requestId?: string(name='RequestId', example='D3DBF9F5-7C4D-4A67-B869-097C069C481D'),
  resources?: {
    resource?: [ 
    {
      description?: string(name='Description', example='ApsaraDB for MongoDB'),
      labels?: string(name='Labels', example='[{\\"name\\":\\"product\\",\\"value\\":\\"MongoDB\\"]'),
      project?: string(name='Project', example='acs_mongodb'),
    }
  ](name='Resource')
  }(name='Resources'),
  success?: boolean(name='Success', example='true'),
}

model QueryProjectMetaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryProjectMetaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryProjectMeta  QueryProjectMetaRequest
  * @return QueryProjectMetaResponse
 */
async function queryProjectMeta(request: QueryProjectMetaRequest): QueryProjectMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryProjectMeta', 'POST', '/', 'json', false, 'json', request);
}

model QueryStaticsAvailabilityRequest {
  taskId: string(name='TaskId', description='This parameter is required.', position='Query'),
  timeRange?: string(name='TimeRange', position='Query'),
}

model QueryStaticsAvailabilityResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QueryStaticsAvailabilityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryStaticsAvailabilityResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryStaticsAvailability  QueryStaticsAvailabilityRequest
  * @return QueryStaticsAvailabilityResponse
 */
async function queryStaticsAvailability(request: QueryStaticsAvailabilityRequest): QueryStaticsAvailabilityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryStaticsAvailability', 'POST', '/', 'json', false, 'json', request);
}

model QueryStaticsResponseTimeRequest {
  taskId: string(name='TaskId', description='This parameter is required.', position='Query'),
  timeRange?: string(name='TimeRange', position='Query'),
}

model QueryStaticsResponseTimeResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QueryStaticsResponseTimeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryStaticsResponseTimeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryStaticsResponseTime  QueryStaticsResponseTimeRequest
  * @return QueryStaticsResponseTimeResponse
 */
async function queryStaticsResponseTime(request: QueryStaticsResponseTimeRequest): QueryStaticsResponseTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryStaticsResponseTime', 'POST', '/', 'json', false, 'json', request);
}

model QuerySystemEventCountRequest {
  queryJson?: string(name='QueryJson', position='Query'),
}

model QuerySystemEventCountResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QuerySystemEventCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySystemEventCountResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QuerySystemEventCount  QuerySystemEventCountRequest
  * @return QuerySystemEventCountResponse
 */
async function querySystemEventCount(request: QuerySystemEventCountRequest): QuerySystemEventCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QuerySystemEventCount', 'POST', '/', 'json', false, 'json', request);
}

model QuerySystemEventDemoRequest {
  eventName: string(name='EventName', description='This parameter is required.', position='Query'),
  product: string(name='Product', description='This parameter is required.', position='Query'),
}

model QuerySystemEventDemoResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QuerySystemEventDemoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySystemEventDemoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QuerySystemEventDemo  QuerySystemEventDemoRequest
  * @return QuerySystemEventDemoResponse
 */
async function querySystemEventDemo(request: QuerySystemEventDemoRequest): QuerySystemEventDemoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QuerySystemEventDemo', 'POST', '/', 'json', false, 'json', request);
}

model QueryTaskConfigRequest {
}

model QueryTaskConfigResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QueryTaskConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryTaskConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryTaskConfig  QueryTaskConfigRequest
  * @return QueryTaskConfigResponse
 */
async function queryTaskConfig(request: QueryTaskConfigRequest): QueryTaskConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryTaskConfig', 'POST', '/', 'json', false, 'json', request);
}

model QueryTaskMonitorDataRequest {
  cursor?: string(name='Cursor', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  length?: int32(name='Length', position='Query'),
  period?: string(name='Period', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  taskId: string(name='TaskId', description='This parameter is required.', position='Query'),
  type?: string(name='Type', position='Query'),
  metricName: string(name='metricName', description='This parameter is required.', position='Query'),
}

model QueryTaskMonitorDataResponseBody = {
  code?: string(name='Code'),
  cursor?: string(name='Cursor'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  traceId?: string(name='TraceId'),
}

model QueryTaskMonitorDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryTaskMonitorDataResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryTaskMonitorData  QueryTaskMonitorDataRequest
  * @return QueryTaskMonitorDataResponse
 */
async function queryTaskMonitorData(request: QueryTaskMonitorDataRequest): QueryTaskMonitorDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryTaskMonitorData', 'POST', '/', 'json', false, 'json', request);
}

model TaskConfigListRequest {
  groupId?: long(name='GroupId', position='Query'),
  id?: long(name='Id', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  taskName?: string(name='TaskName', position='Query'),
}

model TaskConfigListResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  pageTotal?: int32(name='PageTotal'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskList?: {
    nodeTaskConfig?: [ 
    {
      alertConfig?: string(name='AlertConfig'),
      disabled?: boolean(name='Disabled'),
      groupId?: long(name='GroupId'),
      groupName?: string(name='GroupName'),
      id?: long(name='Id'),
      instanceList?: {
        string?: [ string ](name='String')
      }(name='InstanceList'),
      jsonData?: string(name='JsonData'),
      taskName?: string(name='TaskName'),
      taskScope?: string(name='TaskScope'),
      taskType?: string(name='TaskType'),
    }
  ](name='NodeTaskConfig')
  }(name='TaskList'),
  total?: int32(name='Total'),
}

model TaskConfigListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TaskConfigListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of TaskConfigList  TaskConfigListRequest
  * @return TaskConfigListResponse
 */
async function taskConfigList(request: TaskConfigListRequest): TaskConfigListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TaskConfigList', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAlarmRequest {
  comparisonOperator?: string(name='ComparisonOperator', example='>', position='Query'),
  contactGroups?: string(name='ContactGroups', position='Query'),
  dryRun?: boolean(name='DryRun', example='false', position='Query'),
  endTime?: int32(name='EndTime', example='24', position='Query'),
  evaluationCount?: int32(name='EvaluationCount', example='3', position='Query'),
  id: string(name='Id', description='This parameter is required.', example='576fbae7-2fd1-411a-ae13-6f09f4fafdde', position='Query'),
  name?: string(name='Name', example='test_modify', position='Query'),
  notifyType?: int32(name='NotifyType', example='1', position='Query'),
  period?: int32(name='Period', example='60', position='Query'),
  silenceTime?: int32(name='SilenceTime', example='86400', position='Query'),
  startTime?: int32(name='StartTime', example='0', position='Query'),
  statistics?: string(name='Statistics', example='Average', position='Query'),
  threshold: string(name='Threshold', description='This parameter is required.', example='40', position='Query'),
  webhook?: string(name='Webhook', example='http://www.net.cn/example_callback.htm', position='Query'),
}

model UpdateAlarmResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='Success'),
  requestId?: string(name='RequestId', example='945B9183-95C0-44FF-B30C-9ED37D44F6DC'),
  success?: boolean(name='Success', example='true'),
}

model UpdateAlarmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAlarmResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateAlarm  UpdateAlarmRequest
  * @return UpdateAlarmResponse
 */
async function updateAlarm(request: UpdateAlarmRequest): UpdateAlarmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAlarm', 'POST', '/', 'json', false, 'json', request);
}

model UpdateMonitoringTemplateRequest {
  alertTemplatesJson: string(name='AlertTemplatesJson', description='This parameter is required.', position='Query'),
  description?: string(name='Description', position='Query'),
  hostAvailabilityTemplate?: string(name='HostAvailabilityTemplate', position='Query'),
  id: long(name='Id', description='This parameter is required.', position='Query'),
  name?: string(name='Name', position='Query'),
  processMonitorTemplates?: string(name='ProcessMonitorTemplates', position='Query'),
  restVersion: long(name='RestVersion', description='This parameter is required.', position='Query'),
  systemEventTemplates?: string(name='SystemEventTemplates', position='Query'),
}

model UpdateMonitoringTemplateResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateMonitoringTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMonitoringTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateMonitoringTemplate  UpdateMonitoringTemplateRequest
  * @return UpdateMonitoringTemplateResponse
 */
async function updateMonitoringTemplate(request: UpdateMonitoringTemplateRequest): UpdateMonitoringTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMonitoringTemplate', 'POST', '/', 'json', false, 'json', request);
}

