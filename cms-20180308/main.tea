/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('cms', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AccessKeyGetRequest {
  regionId?: string(name='RegionId'),
  userId?: long(name='UserId'),
}

model AccessKeyGetResponseBody = {
  accessKey?: string(name='AccessKey'),
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  secretKey?: string(name='SecretKey'),
  success?: boolean(name='Success'),
  userId?: long(name='UserId'),
}

model AccessKeyGetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AccessKeyGetResponseBody(name='body'),
}

/**
 * @summary AccessKeyGet
 *
 * @param request AccessKeyGetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AccessKeyGetResponse
 */
async function accessKeyGetWithOptions(request: AccessKeyGetRequest, runtime: Util.RuntimeOptions): AccessKeyGetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AccessKeyGet',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary AccessKeyGet
 *
 * @param request AccessKeyGetRequest
 * @return AccessKeyGetResponse
 */
async function accessKeyGet(request: AccessKeyGetRequest): AccessKeyGetResponse {
  var runtime = new Util.RuntimeOptions{};
  return accessKeyGetWithOptions(request, runtime);
}

model AddMyGroupInstancesRequest {
  groupId?: long(name='GroupId', description='This parameter is required.'),
  instances?: string(name='Instances'),
  regionId?: string(name='RegionId'),
}

model AddMyGroupInstancesResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddMyGroupInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddMyGroupInstancesResponseBody(name='body'),
}

/**
 * @param request AddMyGroupInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddMyGroupInstancesResponse
 */
async function addMyGroupInstancesWithOptions(request: AddMyGroupInstancesRequest, runtime: Util.RuntimeOptions): AddMyGroupInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.instances)) {
    query['Instances'] = request.instances;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddMyGroupInstances',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddMyGroupInstancesRequest
 * @return AddMyGroupInstancesResponse
 */
async function addMyGroupInstances(request: AddMyGroupInstancesRequest): AddMyGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMyGroupInstancesWithOptions(request, runtime);
}

model CreateAlarmRequest {
  comparisonOperator?: string(name='ComparisonOperator', description='This parameter is required.', example='>'),
  contactGroups?: string(name='ContactGroups'),
  dimensions?: string(name='Dimensions', description='This parameter is required.', example='[{"instanceId":"i-2zecrzcri3d6fhd2ff7j "}]'),
  dryRun?: boolean(name='DryRun', example='true'),
  endTime?: int32(name='EndTime', example='24'),
  evaluationCount?: int32(name='EvaluationCount', example='3'),
  metricName?: string(name='MetricName', description='This parameter is required.', example='CPUUtilization'),
  name?: string(name='Name', description='This parameter is required.', example='abc'),
  namespace?: string(name='Namespace', description='This parameter is required.', example='acs_ecs_dashboard'),
  notifyType?: int32(name='NotifyType', example='1'),
  period?: int32(name='Period', example='60'),
  regionId?: string(name='RegionId'),
  silenceTime?: int32(name='SilenceTime', example='86400'),
  startTime?: int32(name='StartTime', example='0'),
  statistics?: string(name='Statistics', description='This parameter is required.', example='Average'),
  threshold?: string(name='Threshold', description='This parameter is required.', example='90'),
  webhook?: string(name='Webhook', example='http://www.net.cn/example_callback.htm'),
}

model CreateAlarmResponseBody = {
  code?: string(name='Code', example='200'),
  data?: string(name='Data', example='0c4af0f1-a864-468b-bed3-15c7deff75ee'),
  message?: string(name='Message', example='Success'),
  requestId?: string(name='RequestId', example='910ABE4E-DC9D-4231-9DC0-C96835553327'),
  success?: boolean(name='Success', example='true'),
}

model CreateAlarmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAlarmResponseBody(name='body'),
}

/**
 * @summary CreateAlarm
 *
 * @param request CreateAlarmRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAlarmResponse
 */
async function createAlarmWithOptions(request: CreateAlarmRequest, runtime: Util.RuntimeOptions): CreateAlarmResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comparisonOperator)) {
    query['ComparisonOperator'] = request.comparisonOperator;
  }
  if (!Util.isUnset(request.contactGroups)) {
    query['ContactGroups'] = request.contactGroups;
  }
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.notifyType)) {
    query['NotifyType'] = request.notifyType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.silenceTime)) {
    query['SilenceTime'] = request.silenceTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.statistics)) {
    query['Statistics'] = request.statistics;
  }
  if (!Util.isUnset(request.threshold)) {
    query['Threshold'] = request.threshold;
  }
  if (!Util.isUnset(request.webhook)) {
    query['Webhook'] = request.webhook;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlarm',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary CreateAlarm
 *
 * @param request CreateAlarmRequest
 * @return CreateAlarmResponse
 */
async function createAlarm(request: CreateAlarmRequest): CreateAlarmResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAlarmWithOptions(request, runtime);
}

model CreateHybridDoubleWriteRequest {
  namespace?: string(name='Namespace', description='This parameter is required.', example='test-target'),
  sourceNamespace?: string(name='SourceNamespace', description='This parameter is required.', example='test-source'),
  sourceUserId?: long(name='SourceUserId', description='This parameter is required.', example='12706766********'),
  userId?: long(name='UserId', description='This parameter is required.', example='12706766********'),
}

model CreateHybridDoubleWriteResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='success'),
  requestId?: string(name='RequestId', example='FAAC3C5D-00BF-543A-9E08-FAAC3C5D'),
  success?: boolean(name='Success', example='true'),
}

model CreateHybridDoubleWriteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateHybridDoubleWriteResponseBody(name='body'),
}

/**
 * @summary 创建双写配置
 *
 * @param request CreateHybridDoubleWriteRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHybridDoubleWriteResponse
 */
async function createHybridDoubleWriteWithOptions(request: CreateHybridDoubleWriteRequest, runtime: Util.RuntimeOptions): CreateHybridDoubleWriteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.sourceNamespace)) {
    query['SourceNamespace'] = request.sourceNamespace;
  }
  if (!Util.isUnset(request.sourceUserId)) {
    query['SourceUserId'] = request.sourceUserId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHybridDoubleWrite',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建双写配置
 *
 * @param request CreateHybridDoubleWriteRequest
 * @return CreateHybridDoubleWriteResponse
 */
async function createHybridDoubleWrite(request: CreateHybridDoubleWriteRequest): CreateHybridDoubleWriteResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHybridDoubleWriteWithOptions(request, runtime);
}

model CreateMonitoringTemplateRequest {
  alertTemplatesJson?: string(name='AlertTemplatesJson', description='This parameter is required.'),
  description?: string(name='Description'),
  hostAvailabilityTemplate?: string(name='HostAvailabilityTemplate'),
  name?: string(name='Name', description='This parameter is required.'),
  namespace?: string(name='Namespace', description='This parameter is required.'),
  processMonitorTemplates?: string(name='ProcessMonitorTemplates'),
  regionId?: string(name='RegionId'),
  systemEventTemplates?: string(name='SystemEventTemplates'),
}

model CreateMonitoringTemplateResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateMonitoringTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMonitoringTemplateResponseBody(name='body'),
}

/**
 * @param request CreateMonitoringTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMonitoringTemplateResponse
 */
async function createMonitoringTemplateWithOptions(request: CreateMonitoringTemplateRequest, runtime: Util.RuntimeOptions): CreateMonitoringTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertTemplatesJson)) {
    query['AlertTemplatesJson'] = request.alertTemplatesJson;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.hostAvailabilityTemplate)) {
    query['HostAvailabilityTemplate'] = request.hostAvailabilityTemplate;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.processMonitorTemplates)) {
    query['ProcessMonitorTemplates'] = request.processMonitorTemplates;
  }
  if (!Util.isUnset(request.systemEventTemplates)) {
    query['SystemEventTemplates'] = request.systemEventTemplates;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitoringTemplate',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMonitoringTemplateRequest
 * @return CreateMonitoringTemplateResponse
 */
async function createMonitoringTemplate(request: CreateMonitoringTemplateRequest): CreateMonitoringTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitoringTemplateWithOptions(request, runtime);
}

model CreateMyGroupsRequest {
  bindUrl?: string(name='BindUrl'),
  contactGroups?: string(name='ContactGroups'),
  groupName?: string(name='GroupName'),
  options?: string(name='Options'),
  regionId?: string(name='RegionId'),
  serviceId?: long(name='ServiceId'),
  type?: string(name='Type'),
}

model CreateMyGroupsResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  groupId?: long(name='GroupId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateMyGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMyGroupsResponseBody(name='body'),
}

/**
 * @param request CreateMyGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMyGroupsResponse
 */
async function createMyGroupsWithOptions(request: CreateMyGroupsRequest, runtime: Util.RuntimeOptions): CreateMyGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bindUrl)) {
    query['BindUrl'] = request.bindUrl;
  }
  if (!Util.isUnset(request.contactGroups)) {
    query['ContactGroups'] = request.contactGroups;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.options)) {
    query['Options'] = request.options;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['ServiceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMyGroups',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMyGroupsRequest
 * @return CreateMyGroupsResponse
 */
async function createMyGroups(request: CreateMyGroupsRequest): CreateMyGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMyGroupsWithOptions(request, runtime);
}

model CreateTaskRequest {
  address?: string(name='Address', description='This parameter is required.', example='http://www.aliyun.com'),
  alertIds?: string(name='AlertIds'),
  alertRule?: string(name='AlertRule'),
  interval?: string(name='Interval', example='1'),
  intervalUnit?: string(name='IntervalUnit'),
  ispCity?: string(name='IspCity', description='This parameter is required.', example='[{"city":"546","isp":"465"},{"city":"572","isp":"465"},{"city":"738","isp":"465"}]'),
  options?: string(name='Options', example='{"http_method":"get","header":"xx=bb","cookie":"test=aa","time_out":30000,"match_rule":0,"response_content":"aa"}'),
  regionId?: string(name='RegionId'),
  taskName?: string(name='TaskName', description='This parameter is required.', example='aliyunTest'),
  taskType?: string(name='TaskType', description='1.http
2.ping
3.tcp
4.udp
5.dns
6.smtp
7.pop3
8.ftp

This parameter is required.', example='1'),
  caller?: string(name='caller'),
}

model CreateTaskResponseBody = {
  alertRule?: string(name='AlertRule'),
  code?: string(name='Code', example='200'),
  createResultList?: {
    contact?: [ 
    {
      taskId?: string(name='TaskId'),
      taskName?: string(name='TaskName'),
    }
  ](name='Contact')
  }(name='CreateResultList'),
  data?: string(name='Data'),
  message?: string(name='Message', example='successfull'),
  requestId?: string(name='RequestId', example='a4e6f550-7eac-4a13-b11f-6742aa2d42d1'),
  success?: string(name='Success', example='true'),
}

model CreateTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTaskResponseBody(name='body'),
}

/**
 * @summary CreateTask
 *
 * @param request CreateTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTaskResponse
 */
async function createTaskWithOptions(request: CreateTaskRequest, runtime: Util.RuntimeOptions): CreateTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.alertIds)) {
    query['AlertIds'] = request.alertIds;
  }
  if (!Util.isUnset(request.alertRule)) {
    query['AlertRule'] = request.alertRule;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.intervalUnit)) {
    query['IntervalUnit'] = request.intervalUnit;
  }
  if (!Util.isUnset(request.ispCity)) {
    query['IspCity'] = request.ispCity;
  }
  if (!Util.isUnset(request.options)) {
    query['Options'] = request.options;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  if (!Util.isUnset(request.caller)) {
    query['caller'] = request.caller;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTask',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary CreateTask
 *
 * @param request CreateTaskRequest
 * @return CreateTaskResponse
 */
async function createTask(request: CreateTaskRequest): CreateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTaskWithOptions(request, runtime);
}

model DeleteAlarmRequest {
  id?: string(name='Id', description='This parameter is required.', example='576fbae7-2fd1-411a-ae13-6f09f4fafdde'),
  regionId?: string(name='RegionId'),
}

model DeleteAlarmResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='Success'),
  requestId?: string(name='RequestId', example='A9371CD8-369D-49FA-BED9-35050A0DC6A2'),
  success?: boolean(name='Success', example='true'),
}

model DeleteAlarmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAlarmResponseBody(name='body'),
}

/**
 * @summary DeleteAlarm
 *
 * @param request DeleteAlarmRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAlarmResponse
 */
async function deleteAlarmWithOptions(request: DeleteAlarmRequest, runtime: Util.RuntimeOptions): DeleteAlarmResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlarm',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DeleteAlarm
 *
 * @param request DeleteAlarmRequest
 * @return DeleteAlarmResponse
 */
async function deleteAlarm(request: DeleteAlarmRequest): DeleteAlarmResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlarmWithOptions(request, runtime);
}

model DeleteCustomMetricRequest {
  groupId?: string(name='GroupId', description='This parameter is required.'),
  md5?: string(name='Md5'),
  metricName?: string(name='MetricName'),
  regionId?: string(name='RegionId'),
  UUID?: string(name='UUID'),
}

model DeleteCustomMetricResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DeleteCustomMetricResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCustomMetricResponseBody(name='body'),
}

/**
 * @summary DeleteCustomMetric
 *
 * @param request DeleteCustomMetricRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomMetricResponse
 */
async function deleteCustomMetricWithOptions(request: DeleteCustomMetricRequest, runtime: Util.RuntimeOptions): DeleteCustomMetricResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.md5)) {
    query['Md5'] = request.md5;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.UUID)) {
    query['UUID'] = request.UUID;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomMetric',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DeleteCustomMetric
 *
 * @param request DeleteCustomMetricRequest
 * @return DeleteCustomMetricResponse
 */
async function deleteCustomMetric(request: DeleteCustomMetricRequest): DeleteCustomMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomMetricWithOptions(request, runtime);
}

model DeleteHybridDoubleWriteRequest {
  sourceNamespace?: string(name='SourceNamespace', description='This parameter is required.', example='test-source'),
  sourceUserId?: long(name='SourceUserId', description='This parameter is required.', example='12706766********'),
}

model DeleteHybridDoubleWriteResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='success'),
  requestId?: string(name='RequestId', example='6F815BDC-9063-5417-BA88-E1BBD84BAA1E'),
  success?: boolean(name='Success', example='true'),
}

model DeleteHybridDoubleWriteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteHybridDoubleWriteResponseBody(name='body'),
}

/**
 * @summary 删除双写配置
 *
 * @param request DeleteHybridDoubleWriteRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHybridDoubleWriteResponse
 */
async function deleteHybridDoubleWriteWithOptions(request: DeleteHybridDoubleWriteRequest, runtime: Util.RuntimeOptions): DeleteHybridDoubleWriteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceNamespace)) {
    query['SourceNamespace'] = request.sourceNamespace;
  }
  if (!Util.isUnset(request.sourceUserId)) {
    query['SourceUserId'] = request.sourceUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHybridDoubleWrite',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除双写配置
 *
 * @param request DeleteHybridDoubleWriteRequest
 * @return DeleteHybridDoubleWriteResponse
 */
async function deleteHybridDoubleWrite(request: DeleteHybridDoubleWriteRequest): DeleteHybridDoubleWriteResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHybridDoubleWriteWithOptions(request, runtime);
}

model DeleteMetricRuleTargetsRequest {
  regionId?: string(name='RegionId'),
  ruleId?: string(name='RuleId', description='This parameter is required.'),
  targetIds?: [ string ](name='TargetIds'),
}

model DeleteMetricRuleTargetsResponseBody = {
  code?: string(name='Code'),
  failIds?: {
    targetIds?: {
      targetId?: [ string ](name='TargetId')
    }(name='TargetIds'),
  }(name='FailIds'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMetricRuleTargetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMetricRuleTargetsResponseBody(name='body'),
}

/**
 * @summary DeleteMetricRuleTargets
 *
 * @param request DeleteMetricRuleTargetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMetricRuleTargetsResponse
 */
async function deleteMetricRuleTargetsWithOptions(request: DeleteMetricRuleTargetsRequest, runtime: Util.RuntimeOptions): DeleteMetricRuleTargetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.targetIds)) {
    query['TargetIds'] = request.targetIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMetricRuleTargets',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DeleteMetricRuleTargets
 *
 * @param request DeleteMetricRuleTargetsRequest
 * @return DeleteMetricRuleTargetsResponse
 */
async function deleteMetricRuleTargets(request: DeleteMetricRuleTargetsRequest): DeleteMetricRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRuleTargetsWithOptions(request, runtime);
}

model DeleteMetricRulesRequest {
  id?: [ string ](name='Id', description='This parameter is required.'),
  regionId?: string(name='RegionId'),
}

model DeleteMetricRulesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMetricRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMetricRulesResponseBody(name='body'),
}

/**
 * @summary DeleteMetricRules
 *
 * @param request DeleteMetricRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMetricRulesResponse
 */
async function deleteMetricRulesWithOptions(request: DeleteMetricRulesRequest, runtime: Util.RuntimeOptions): DeleteMetricRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMetricRules',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DeleteMetricRules
 *
 * @param request DeleteMetricRulesRequest
 * @return DeleteMetricRulesResponse
 */
async function deleteMetricRules(request: DeleteMetricRulesRequest): DeleteMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRulesWithOptions(request, runtime);
}

model DeleteMyGroupInstancesRequest {
  category?: string(name='Category', description='This parameter is required.'),
  groupId?: long(name='GroupId', description='This parameter is required.'),
  instanceIdList?: string(name='InstanceIdList'),
  instanceIds?: string(name='InstanceIds'),
  regionId?: string(name='RegionId'),
}

model DeleteMyGroupInstancesResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMyGroupInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMyGroupInstancesResponseBody(name='body'),
}

/**
 * @summary deletemygroupinstances
 *
 * @param request DeleteMyGroupInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMyGroupInstancesResponse
 */
async function deleteMyGroupInstancesWithOptions(request: DeleteMyGroupInstancesRequest, runtime: Util.RuntimeOptions): DeleteMyGroupInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.instanceIdList)) {
    query['InstanceIdList'] = request.instanceIdList;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMyGroupInstances',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary deletemygroupinstances
 *
 * @param request DeleteMyGroupInstancesRequest
 * @return DeleteMyGroupInstancesResponse
 */
async function deleteMyGroupInstances(request: DeleteMyGroupInstancesRequest): DeleteMyGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMyGroupInstancesWithOptions(request, runtime);
}

model DeleteMyGroupsRequest {
  groupId?: long(name='GroupId'),
  regionId?: string(name='RegionId'),
}

model DeleteMyGroupsResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  group?: {
    bindUrls?: string(name='BindUrls'),
    contactGroups?: {
      contactGroup?: [ 
      {
        name?: string(name='Name'),
      }
    ](name='ContactGroup')
    }(name='ContactGroups'),
    groupId?: long(name='GroupId'),
    groupName?: string(name='GroupName'),
    serviceId?: string(name='ServiceId'),
    type?: string(name='Type'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMyGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMyGroupsResponseBody(name='body'),
}

/**
 * @param request DeleteMyGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMyGroupsResponse
 */
async function deleteMyGroupsWithOptions(request: DeleteMyGroupsRequest, runtime: Util.RuntimeOptions): DeleteMyGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMyGroups',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteMyGroupsRequest
 * @return DeleteMyGroupsResponse
 */
async function deleteMyGroups(request: DeleteMyGroupsRequest): DeleteMyGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMyGroupsWithOptions(request, runtime);
}

model DeleteTasksRequest {
  isDeleteAlarms?: int32(name='IsDeleteAlarms', example='1'),
  regionId?: string(name='RegionId'),
  taskIds?: string(name='TaskIds', description='This parameter is required.', example='["2b5e6f7d-108f-4117-85fb-b202ba033468"]'),
}

model DeleteTasksResponseBody = {
  code?: string(name='Code', example='200'),
  data?: string(name='Data', example='{"count":1}'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', example='a4e6f550-7eac-4a13-b11f-6742aa2d42d1'),
  success?: string(name='Success', example='true'),
}

model DeleteTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTasksResponseBody(name='body'),
}

/**
 * @param request DeleteTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTasksResponse
 */
async function deleteTasksWithOptions(request: DeleteTasksRequest, runtime: Util.RuntimeOptions): DeleteTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.isDeleteAlarms)) {
    query['IsDeleteAlarms'] = request.isDeleteAlarms;
  }
  if (!Util.isUnset(request.taskIds)) {
    query['TaskIds'] = request.taskIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTasks',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteTasksRequest
 * @return DeleteTasksResponse
 */
async function deleteTasks(request: DeleteTasksRequest): DeleteTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTasksWithOptions(request, runtime);
}

model DescribeAlarmHistoryRequest {
  alertName?: string(name='AlertName'),
  ascending?: boolean(name='Ascending'),
  endTime?: string(name='EndTime'),
  groupId?: string(name='GroupId'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  onlyCount?: boolean(name='OnlyCount'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  ruleName?: string(name='RuleName'),
  startTime?: string(name='StartTime'),
  state?: string(name='State'),
  status?: string(name='Status'),
}

model DescribeAlarmHistoryResponseBody = {
  alarmHistoryList?: {
    alarmHistory?: [ 
    {
      alertName?: string(name='AlertName'),
      alertTime?: long(name='AlertTime'),
      contactALIIMs?: {
        contactALIIM?: [ string ](name='ContactALIIM')
      }(name='ContactALIIMs'),
      contactGroups?: {
        contactGroup?: [ string ](name='ContactGroup')
      }(name='ContactGroups'),
      contactMails?: {
        contactMail?: [ string ](name='ContactMail')
      }(name='ContactMails'),
      contactSmses?: {
        contactSms?: [ string ](name='ContactSms')
      }(name='ContactSmses'),
      contacts?: {
        contact?: [ string ](name='Contact')
      }(name='Contacts'),
      dimensions?: string(name='Dimensions'),
      evaluationCount?: int32(name='EvaluationCount'),
      expression?: string(name='Expression'),
      groupId?: string(name='GroupId'),
      id?: string(name='Id'),
      instanceName?: string(name='InstanceName'),
      lastTime?: long(name='LastTime'),
      level?: string(name='Level'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      preLevel?: string(name='PreLevel'),
      ruleName?: string(name='RuleName'),
      state?: string(name='State'),
      status?: int32(name='Status'),
      userId?: string(name='UserId'),
      value?: string(name='Value'),
      webhooks?: string(name='Webhooks'),
    }
  ](name='AlarmHistory')
  }(name='AlarmHistoryList'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: string(name='Total'),
}

model DescribeAlarmHistoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAlarmHistoryResponseBody(name='body'),
}

/**
 * @summary DescribeAlarmHistory
 *
 * @param request DescribeAlarmHistoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAlarmHistoryResponse
 */
async function describeAlarmHistoryWithOptions(request: DescribeAlarmHistoryRequest, runtime: Util.RuntimeOptions): DescribeAlarmHistoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertName)) {
    query['AlertName'] = request.alertName;
  }
  if (!Util.isUnset(request.ascending)) {
    query['Ascending'] = request.ascending;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.onlyCount)) {
    query['OnlyCount'] = request.onlyCount;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAlarmHistory',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DescribeAlarmHistory
 *
 * @param request DescribeAlarmHistoryRequest
 * @return DescribeAlarmHistoryResponse
 */
async function describeAlarmHistory(request: DescribeAlarmHistoryRequest): DescribeAlarmHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlarmHistoryWithOptions(request, runtime);
}

model DescribeAlarmsRequest {
  alertState?: string(name='AlertState'),
  displayName?: string(name='DisplayName'),
  enableState?: boolean(name='EnableState'),
  groupBy?: string(name='GroupBy'),
  groupId?: string(name='GroupId'),
  metricName?: string(name='MetricName'),
  nameKeyword?: string(name='NameKeyword'),
  names?: string(name='Names'),
  namespace?: string(name='Namespace'),
  page?: string(name='Page'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model DescribeAlarmsResponseBody = {
  code?: int32(name='Code'),
  datapoints?: {
    alarm?: [ 
    {
      comparisonOperator?: string(name='ComparisonOperator'),
      contactGroups?: string(name='ContactGroups'),
      dimensions?: string(name='Dimensions'),
      displayName?: string(name='DisplayName'),
      effectiveInterval?: string(name='EffectiveInterval'),
      enable?: boolean(name='Enable'),
      escalations?: {
        critical?: {
          alertSensitivity?: string(name='AlertSensitivity'),
          comparisonOperator?: string(name='ComparisonOperator'),
          historyDataRange?: string(name='HistoryDataRange'),
          preCondition?: string(name='PreCondition'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Critical'),
        info?: {
          alertSensitivity?: string(name='AlertSensitivity'),
          comparisonOperator?: string(name='ComparisonOperator'),
          historyDataRange?: string(name='HistoryDataRange'),
          preCondition?: string(name='PreCondition'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Info'),
        warn?: {
          alertSensitivity?: string(name='AlertSensitivity'),
          comparisonOperator?: string(name='ComparisonOperator'),
          historyDataRange?: string(name='HistoryDataRange'),
          preCondition?: string(name='PreCondition'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Warn'),
      }(name='Escalations'),
      evaluationCount?: string(name='EvaluationCount'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      level?: string(name='Level'),
      metricName?: string(name='MetricName'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      period?: string(name='Period'),
      resources?: string(name='Resources'),
      ruleName?: string(name='RuleName'),
      ruleType?: string(name='RuleType'),
      silenceTime?: string(name='SilenceTime'),
      state?: string(name='State'),
      statistics?: string(name='Statistics'),
      subject?: string(name='Subject'),
      threshold?: string(name='Threshold'),
      uuid?: string(name='Uuid'),
      webhook?: string(name='Webhook'),
    }
  ](name='Alarm')
  }(name='Datapoints'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: string(name='Total'),
  traceId?: string(name='TraceId'),
}

model DescribeAlarmsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAlarmsResponseBody(name='body'),
}

/**
 * @summary DescribeAlarms
 *
 * @param request DescribeAlarmsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAlarmsResponse
 */
async function describeAlarmsWithOptions(request: DescribeAlarmsRequest, runtime: Util.RuntimeOptions): DescribeAlarmsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertState)) {
    query['AlertState'] = request.alertState;
  }
  if (!Util.isUnset(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.enableState)) {
    query['EnableState'] = request.enableState;
  }
  if (!Util.isUnset(request.groupBy)) {
    query['GroupBy'] = request.groupBy;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.nameKeyword)) {
    query['NameKeyword'] = request.nameKeyword;
  }
  if (!Util.isUnset(request.names)) {
    query['Names'] = request.names;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAlarms',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DescribeAlarms
 *
 * @param request DescribeAlarmsRequest
 * @return DescribeAlarmsResponse
 */
async function describeAlarms(request: DescribeAlarmsRequest): DescribeAlarmsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlarmsWithOptions(request, runtime);
}

model DescribeAlarmsForResourcesRequest {
  alertState?: string(name='AlertState'),
  dimensions?: string(name='Dimensions', description='This parameter is required.'),
  enableState?: boolean(name='EnableState'),
  groupId?: string(name='GroupId'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace', description='This parameter is required.'),
  page?: string(name='Page'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model DescribeAlarmsForResourcesResponseBody = {
  code?: int32(name='Code'),
  datapoints?: {
    alarm?: [ 
    {
      comparisonOperator?: string(name='ComparisonOperator'),
      contactGroups?: string(name='ContactGroups'),
      displayName?: string(name='DisplayName'),
      effectiveInterval?: string(name='EffectiveInterval'),
      enable?: boolean(name='Enable'),
      escalations?: {
        critical?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Critical'),
        info?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Info'),
        warn?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Warn'),
      }(name='Escalations'),
      evaluationCount?: string(name='EvaluationCount'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      level?: string(name='Level'),
      metricName?: string(name='MetricName'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      period?: string(name='Period'),
      resources?: string(name='Resources'),
      silenceTime?: string(name='SilenceTime'),
      state?: string(name='State'),
      statistics?: string(name='Statistics'),
      subject?: string(name='Subject'),
      threshold?: string(name='Threshold'),
      uuid?: string(name='Uuid'),
      webhook?: string(name='Webhook'),
    }
  ](name='Alarm')
  }(name='Datapoints'),
  dimensions?: string(name='Dimensions'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: string(name='Total'),
  traceId?: string(name='TraceId'),
}

model DescribeAlarmsForResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAlarmsForResourcesResponseBody(name='body'),
}

/**
 * @summary describealarmsforresources
 *
 * @param request DescribeAlarmsForResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAlarmsForResourcesResponse
 */
async function describeAlarmsForResourcesWithOptions(request: DescribeAlarmsForResourcesRequest, runtime: Util.RuntimeOptions): DescribeAlarmsForResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertState)) {
    query['AlertState'] = request.alertState;
  }
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.enableState)) {
    query['EnableState'] = request.enableState;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAlarmsForResources',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary describealarmsforresources
 *
 * @param request DescribeAlarmsForResourcesRequest
 * @return DescribeAlarmsForResourcesResponse
 */
async function describeAlarmsForResources(request: DescribeAlarmsForResourcesRequest): DescribeAlarmsForResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlarmsForResourcesWithOptions(request, runtime);
}

model DescribeAlertHistoryListRequest {
  alertName?: string(name='AlertName'),
  ascending?: boolean(name='Ascending'),
  endTime?: string(name='EndTime'),
  groupId?: string(name='GroupId'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  onlyCount?: boolean(name='OnlyCount'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  ruleName?: string(name='RuleName'),
  startTime?: string(name='StartTime'),
  state?: string(name='State'),
  status?: string(name='Status'),
}

model DescribeAlertHistoryListResponseBody = {
  alarmHistoryList?: {
    alarmHistory?: [ 
    {
      alertName?: string(name='AlertName'),
      alertTime?: long(name='AlertTime'),
      contactALIIMs?: {
        contactALIIM?: [ string ](name='ContactALIIM')
      }(name='ContactALIIMs'),
      contactGroups?: {
        contactGroup?: [ string ](name='ContactGroup')
      }(name='ContactGroups'),
      contactMails?: {
        contactMail?: [ string ](name='ContactMail')
      }(name='ContactMails'),
      contactSmses?: {
        contactSms?: [ string ](name='ContactSms')
      }(name='ContactSmses'),
      contacts?: {
        contact?: [ string ](name='Contact')
      }(name='Contacts'),
      dimensions?: string(name='Dimensions'),
      evaluationCount?: int32(name='EvaluationCount'),
      expression?: string(name='Expression'),
      groupId?: string(name='GroupId'),
      id?: string(name='Id'),
      instanceName?: string(name='InstanceName'),
      lastTime?: long(name='LastTime'),
      level?: string(name='Level'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      preLevel?: string(name='PreLevel'),
      ruleName?: string(name='RuleName'),
      state?: string(name='State'),
      status?: int32(name='Status'),
      userId?: string(name='UserId'),
      value?: string(name='Value'),
      webhooks?: string(name='Webhooks'),
    }
  ](name='AlarmHistory')
  }(name='AlarmHistoryList'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: string(name='Total'),
}

model DescribeAlertHistoryListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAlertHistoryListResponseBody(name='body'),
}

/**
 * @param request DescribeAlertHistoryListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAlertHistoryListResponse
 */
async function describeAlertHistoryListWithOptions(request: DescribeAlertHistoryListRequest, runtime: Util.RuntimeOptions): DescribeAlertHistoryListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertName)) {
    query['AlertName'] = request.alertName;
  }
  if (!Util.isUnset(request.ascending)) {
    query['Ascending'] = request.ascending;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.onlyCount)) {
    query['OnlyCount'] = request.onlyCount;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAlertHistoryList',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAlertHistoryListRequest
 * @return DescribeAlertHistoryListResponse
 */
async function describeAlertHistoryList(request: DescribeAlertHistoryListRequest): DescribeAlertHistoryListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlertHistoryListWithOptions(request, runtime);
}

model DescribeContactRequest {
  contactName?: string(name='ContactName', description='This parameter is required.'),
  regionId?: string(name='RegionId'),
}

model DescribeContactResponseBody = {
  code?: int32(name='Code'),
  datapoints?: {
    channels?: {
      channel?: [ 
      {
        type?: string(name='Type'),
        value?: string(name='Value'),
      }
    ](name='Channel')
    }(name='Channels'),
    name?: string(name='Name'),
  }(name='Datapoints'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeContactResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeContactResponseBody(name='body'),
}

/**
 * @param request DescribeContactRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContactResponse
 */
async function describeContactWithOptions(request: DescribeContactRequest, runtime: Util.RuntimeOptions): DescribeContactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContact',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeContactRequest
 * @return DescribeContactResponse
 */
async function describeContact(request: DescribeContactRequest): DescribeContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContactWithOptions(request, runtime);
}

model DescribeHybridDoubleWriteRequest {
  sourceNamespace?: string(name='SourceNamespace', example='test-source'),
  sourceUserId?: string(name='SourceUserId', example='12706766**********'),
  targetNamespace?: string(name='TargetNamespace'),
  targetUserId?: string(name='TargetUserId'),
}

model DescribeHybridDoubleWriteResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='Success'),
  requestId?: string(name='RequestId', example='7985D471-3FA8-4EE9-8F4B-45C19DF3D36F'),
  result?: [ 
    {
      namespace?: string(name='Namespace', example='test-target'),
      sourceNamespace?: string(name='SourceNamespace', example='test-source'),
      sourceUserId?: long(name='SourceUserId', example='12706766**********'),
      userId?: long(name='UserId', example='11234766**********'),
    }
  ](name='Result'),
  success?: string(name='Success', example='true'),
}

model DescribeHybridDoubleWriteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHybridDoubleWriteResponseBody(name='body'),
}

/**
 * @summary 查询本数据源被双写到哪里
 *
 * @param request DescribeHybridDoubleWriteRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHybridDoubleWriteResponse
 */
async function describeHybridDoubleWriteWithOptions(request: DescribeHybridDoubleWriteRequest, runtime: Util.RuntimeOptions): DescribeHybridDoubleWriteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceNamespace)) {
    query['SourceNamespace'] = request.sourceNamespace;
  }
  if (!Util.isUnset(request.sourceUserId)) {
    query['SourceUserId'] = request.sourceUserId;
  }
  if (!Util.isUnset(request.targetNamespace)) {
    query['TargetNamespace'] = request.targetNamespace;
  }
  if (!Util.isUnset(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHybridDoubleWrite',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询本数据源被双写到哪里
 *
 * @param request DescribeHybridDoubleWriteRequest
 * @return DescribeHybridDoubleWriteResponse
 */
async function describeHybridDoubleWrite(request: DescribeHybridDoubleWriteRequest): DescribeHybridDoubleWriteResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHybridDoubleWriteWithOptions(request, runtime);
}

model DescribeISPAreaCityRequest {
  city?: string(name='City'),
  isp?: string(name='Isp'),
}

model DescribeISPAreaCityResponseBody = {
  code?: string(name='Code', example='200'),
  data?: string(name='Data'),
  message?: string(name='Message', example='successful'),
  requestId?: string(name='RequestId', example='84C8BA48-7FD3-46F8-AEE3-E24657C22289'),
  success?: string(name='Success', example='true'),
}

model DescribeISPAreaCityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeISPAreaCityResponseBody(name='body'),
}

/**
 * @summary 获取探针列表
 *
 * @param request DescribeISPAreaCityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeISPAreaCityResponse
 */
async function describeISPAreaCityWithOptions(request: DescribeISPAreaCityRequest, runtime: Util.RuntimeOptions): DescribeISPAreaCityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.city)) {
    query['City'] = request.city;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeISPAreaCity',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取探针列表
 *
 * @param request DescribeISPAreaCityRequest
 * @return DescribeISPAreaCityResponse
 */
async function describeISPAreaCity(request: DescribeISPAreaCityRequest): DescribeISPAreaCityResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeISPAreaCityWithOptions(request, runtime);
}

model DescribeMetricRuleListRequest {
  alertState?: string(name='AlertState'),
  dimensions?: string(name='Dimensions'),
  enableState?: boolean(name='EnableState'),
  groupId?: string(name='GroupId'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  page?: string(name='Page'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
  ruleIds?: string(name='RuleIds'),
  ruleName?: string(name='RuleName'),
}

model DescribeMetricRuleListResponseBody = {
  alarms?: {
    alarm?: [ 
    {
      alertState?: string(name='AlertState'),
      contactGroups?: string(name='ContactGroups'),
      dimensions?: string(name='Dimensions'),
      effectiveInterval?: string(name='EffectiveInterval'),
      enableState?: boolean(name='EnableState'),
      escalations?: {
        critical?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Critical'),
        info?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Info'),
        warn?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Warn'),
      }(name='Escalations'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      mailSubject?: string(name='MailSubject'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      period?: string(name='Period'),
      resources?: string(name='Resources'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      silenceTime?: string(name='SilenceTime'),
      sourceType?: string(name='SourceType'),
      webhook?: string(name='Webhook'),
    }
  ](name='Alarm')
  }(name='Alarms'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: string(name='Total'),
}

model DescribeMetricRuleListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMetricRuleListResponseBody(name='body'),
}

/**
 * @param request DescribeMetricRuleListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMetricRuleListResponse
 */
async function describeMetricRuleListWithOptions(request: DescribeMetricRuleListRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertState)) {
    query['AlertState'] = request.alertState;
  }
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.enableState)) {
    query['EnableState'] = request.enableState;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleIds)) {
    query['RuleIds'] = request.ruleIds;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetricRuleList',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeMetricRuleListRequest
 * @return DescribeMetricRuleListResponse
 */
async function describeMetricRuleList(request: DescribeMetricRuleListRequest): DescribeMetricRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleListWithOptions(request, runtime);
}

model DescribeTaskDetailRequest {
  regionId?: string(name='RegionId'),
  taskId?: string(name='TaskId', description='This parameter is required.', example='339e0d96-2505-425f-a5c6-22e2c12f8fee'),
}

model DescribeTaskDetailResponseBody = {
  code?: string(name='Code', example='200'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', example='a4e6f550-7eac-4a13-b11f-6742aa2d42d1'),
  success?: string(name='Success', example='true'),
}

model DescribeTaskDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTaskDetailResponseBody(name='body'),
}

/**
 * @param request DescribeTaskDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTaskDetailResponse
 */
async function describeTaskDetailWithOptions(request: DescribeTaskDetailRequest, runtime: Util.RuntimeOptions): DescribeTaskDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTaskDetail',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeTaskDetailRequest
 * @return DescribeTaskDetailResponse
 */
async function describeTaskDetail(request: DescribeTaskDetailRequest): DescribeTaskDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTaskDetailWithOptions(request, runtime);
}

model DescribeTasksRequest {
  keyword?: string(name='Keyword'),
  page?: int32(name='Page', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
  regionId?: string(name='RegionId'),
  taskId?: string(name='TaskId', example='18b0c27f-bab3-441d-a747-9cdcaa8bbac8'),
  taskType?: string(name='TaskType', example='1'),
}

model DescribeTasksResponseBody = {
  code?: string(name='Code', example='200'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='1'),
  requestId?: string(name='RequestId', example='6A46B8E4-D39E-4DB5-B422-231410654E8E'),
  success?: string(name='Success', example='true'),
  totalCount?: int32(name='TotalCount', example='14'),
}

model DescribeTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTasksResponseBody(name='body'),
}

/**
 * @summary DescribeTasks
 *
 * @param request DescribeTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTasksResponse
 */
async function describeTasksWithOptions(request: DescribeTasksRequest, runtime: Util.RuntimeOptions): DescribeTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTasks',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DescribeTasks
 *
 * @param request DescribeTasksRequest
 * @return DescribeTasksResponse
 */
async function describeTasks(request: DescribeTasksRequest): DescribeTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTasksWithOptions(request, runtime);
}

model DisableAlarmRequest {
  id?: string(name='Id', description='This parameter is required.', example='576fbae7-2fd1-411a-ae13-6f09f4fafdde'),
  regionId?: string(name='RegionId'),
}

model DisableAlarmResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='Success'),
  requestId?: string(name='RequestId', example='DEF01F10-E747-42FE-9152-85CB43B1B552'),
  success?: boolean(name='Success', example='true'),
}

model DisableAlarmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableAlarmResponseBody(name='body'),
}

/**
 * @summary DisableAlarm
 *
 * @param request DisableAlarmRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableAlarmResponse
 */
async function disableAlarmWithOptions(request: DisableAlarmRequest, runtime: Util.RuntimeOptions): DisableAlarmResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableAlarm',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DisableAlarm
 *
 * @param request DisableAlarmRequest
 * @return DisableAlarmResponse
 */
async function disableAlarm(request: DisableAlarmRequest): DisableAlarmResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableAlarmWithOptions(request, runtime);
}

model EnableAlarmRequest {
  id?: string(name='Id', description='This parameter is required.', example='576fbae7-2fd1-411a-ae13-6f09f4fafdde'),
  regionId?: string(name='RegionId'),
}

model EnableAlarmResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='Success'),
  requestId?: string(name='RequestId', example='1C5E0E5D-76D5-469C-9FA8-D74799B24860'),
  success?: boolean(name='Success', example='true'),
}

model EnableAlarmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableAlarmResponseBody(name='body'),
}

/**
 * @summary EnableAlarm
 *
 * @param request EnableAlarmRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableAlarmResponse
 */
async function enableAlarmWithOptions(request: EnableAlarmRequest, runtime: Util.RuntimeOptions): EnableAlarmResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableAlarm',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary EnableAlarm
 *
 * @param request EnableAlarmRequest
 * @return EnableAlarmResponse
 */
async function enableAlarm(request: EnableAlarmRequest): EnableAlarmResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableAlarmWithOptions(request, runtime);
}

model GetContactsRequest {
  groupName?: string(name='GroupName', description='This parameter is required.'),
  regionId?: string(name='RegionId'),
}

model GetContactsResponseBody = {
  code?: int32(name='Code'),
  datapoints?: {
    contacts?: {
      contact?: [ string ](name='Contact')
    }(name='Contacts'),
    name?: string(name='Name'),
  }(name='Datapoints'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetContactsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetContactsResponseBody(name='body'),
}

/**
 * @param request GetContactsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetContactsResponse
 */
async function getContactsWithOptions(request: GetContactsRequest, runtime: Util.RuntimeOptions): GetContactsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetContacts',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetContactsRequest
 * @return GetContactsResponse
 */
async function getContacts(request: GetContactsRequest): GetContactsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getContactsWithOptions(request, runtime);
}

model GetLineSplitResultRequest {
  line?: string(name='Line'),
  prefix?: string(name='Prefix'),
  regex?: string(name='Regex'),
  selectContent?: string(name='SelectContent'),
  splitType?: string(name='SplitType', example='simple|regex'),
}

model GetLineSplitResultResponseBody = {
  code?: long(name='Code'),
  errorCode?: long(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  resource?: {
    additionalRegex?: string(name='AdditionalRegex'),
    endSplitSymbol?: string(name='EndSplitSymbol'),
    regex?: string(name='Regex'),
    regexSplitResult?: [ string ](name='RegexSplitResult'),
    startSplitSymbol?: string(name='StartSplitSymbol'),
    startSplitSymbolIndex?: long(name='StartSplitSymbolIndex'),
  }(name='Resource'),
  success?: boolean(name='Success'),
}

model GetLineSplitResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLineSplitResultResponseBody(name='body'),
}

/**
 * @summary 获取行切分结果
 *
 * @param request GetLineSplitResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLineSplitResultResponse
 */
async function getLineSplitResultWithOptions(request: GetLineSplitResultRequest, runtime: Util.RuntimeOptions): GetLineSplitResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.line)) {
    query['Line'] = request.line;
  }
  if (!Util.isUnset(request.prefix)) {
    query['Prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.regex)) {
    query['Regex'] = request.regex;
  }
  if (!Util.isUnset(request.selectContent)) {
    query['SelectContent'] = request.selectContent;
  }
  if (!Util.isUnset(request.splitType)) {
    query['SplitType'] = request.splitType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLineSplitResult',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取行切分结果
 *
 * @param request GetLineSplitResultRequest
 * @return GetLineSplitResultResponse
 */
async function getLineSplitResult(request: GetLineSplitResultRequest): GetLineSplitResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLineSplitResultWithOptions(request, runtime);
}

model GetLogColumnTranslateResultRequest {
  columnValue?: string(name='ColumnValue'),
  translateConfig?: string(name='TranslateConfig'),
}

model GetLogColumnTranslateResultResponseBody = {
  code?: long(name='Code'),
  errorCode?: long(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resource?: string(name='Resource'),
  success?: boolean(name='Success'),
}

model GetLogColumnTranslateResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLogColumnTranslateResultResponseBody(name='body'),
}

/**
 * @summary 获取日期提取结果的翻译
 *
 * @param request GetLogColumnTranslateResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLogColumnTranslateResultResponse
 */
async function getLogColumnTranslateResultWithOptions(request: GetLogColumnTranslateResultRequest, runtime: Util.RuntimeOptions): GetLogColumnTranslateResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.columnValue)) {
    query['ColumnValue'] = request.columnValue;
  }
  if (!Util.isUnset(request.translateConfig)) {
    query['TranslateConfig'] = request.translateConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLogColumnTranslateResult',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取日期提取结果的翻译
 *
 * @param request GetLogColumnTranslateResultRequest
 * @return GetLogColumnTranslateResultResponse
 */
async function getLogColumnTranslateResult(request: GetLogColumnTranslateResultRequest): GetLogColumnTranslateResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLogColumnTranslateResultWithOptions(request, runtime);
}

model GetMonitoringTemplateRequest {
  id?: string(name='Id'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model GetMonitoringTemplateResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  resource?: {
    alertTemplatesJson?: string(name='AlertTemplatesJson'),
    description?: string(name='Description'),
    hostAvailabilityTemplate?: string(name='HostAvailabilityTemplate'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    namespace?: string(name='Namespace'),
    processMonitorTemplates?: string(name='ProcessMonitorTemplates'),
    restVersion?: string(name='RestVersion'),
    systemEventTemplates?: string(name='SystemEventTemplates'),
  }(name='Resource'),
  success?: boolean(name='Success'),
}

model GetMonitoringTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMonitoringTemplateResponseBody(name='body'),
}

/**
 * @param request GetMonitoringTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMonitoringTemplateResponse
 */
async function getMonitoringTemplateWithOptions(request: GetMonitoringTemplateRequest, runtime: Util.RuntimeOptions): GetMonitoringTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMonitoringTemplate',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMonitoringTemplateRequest
 * @return GetMonitoringTemplateResponse
 */
async function getMonitoringTemplate(request: GetMonitoringTemplateRequest): GetMonitoringTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMonitoringTemplateWithOptions(request, runtime);
}

model GetMyGroupsRequest {
  bindUrl?: string(name='BindUrl'),
  groupId?: long(name='GroupId'),
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  selectContactGroups?: boolean(name='SelectContactGroups'),
  type?: string(name='Type'),
}

model GetMyGroupsResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  group?: {
    bindUrl?: string(name='BindUrl'),
    contactGroups?: {
      contactGroup?: [ 
      {
        name?: string(name='Name'),
      }
    ](name='ContactGroup')
    }(name='ContactGroups'),
    groupId?: long(name='GroupId'),
    groupName?: string(name='GroupName'),
    serviceId?: long(name='ServiceId'),
    type?: string(name='Type'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMyGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMyGroupsResponseBody(name='body'),
}

/**
 * @param request GetMyGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMyGroupsResponse
 */
async function getMyGroupsWithOptions(request: GetMyGroupsRequest, runtime: Util.RuntimeOptions): GetMyGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bindUrl)) {
    query['BindUrl'] = request.bindUrl;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.selectContactGroups)) {
    query['SelectContactGroups'] = request.selectContactGroups;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMyGroups',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMyGroupsRequest
 * @return GetMyGroupsResponse
 */
async function getMyGroups(request: GetMyGroupsRequest): GetMyGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMyGroupsWithOptions(request, runtime);
}

model ListAlarmRequest {
  dimension?: string(name='Dimension', example='{"instanceId":"XXX"}'),
  id?: string(name='Id', example='i-2ze3w55tr2rcpejpcfap_72071739-396b-497d-849c-59a73de44bcf'),
  isEnable?: boolean(name='IsEnable', example='true'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace', example='acs_ecs_dashboard'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='2'),
  regionId?: string(name='RegionId'),
  state?: string(name='State', example='ok'),
}

model ListAlarmResponseBody = {
  alarmList?: {
    alarm?: [ 
    {
      comparisonOperator?: string(name='ComparisonOperator', example='>'),
      contactGroups?: string(name='ContactGroups', example='["test4nudou"]'),
      dimensions?: string(name='Dimensions', example='["{\\\\"instanceId\\\\":\\\\" i-abcdefgh123456\\\\"}"]'),
      enable?: boolean(name='Enable', example='true'),
      endTime?: int32(name='EndTime', example='24'),
      evaluationCount?: int32(name='EvaluationCount', example='3'),
      id?: string(name='Id', example='i-2ze3w55tr2rcpejpcfap_72071739-396b-497d-849c-59a73de44bcf'),
      metricName?: string(name='MetricName', example='CPUUtilization'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace', example='acs_ecs_dashboard'),
      notifyType?: int32(name='NotifyType', example='0'),
      period?: int32(name='Period', example='300'),
      silenceTime?: int32(name='SilenceTime', example='86400'),
      startTime?: int32(name='StartTime', example='0'),
      state?: string(name='State', example='ok'),
      statistics?: string(name='Statistics', example='Average'),
      threshold?: string(name='Threshold', example='90'),
      webhook?: string(name='Webhook', example='null'),
    }
  ](name='Alarm')
  }(name='AlarmList'),
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='Success'),
  nextToken?: int32(name='NextToken', example='2'),
  requestId?: string(name='RequestId', example='EFD27F56-5799-4CE8-B625-56DF3332331C'),
  success?: boolean(name='Success', example='true'),
  total?: int32(name='Total', example='27'),
}

model ListAlarmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAlarmResponseBody(name='body'),
}

/**
 * @summary ListAlarm
 *
 * @param request ListAlarmRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAlarmResponse
 */
async function listAlarmWithOptions(request: ListAlarmRequest, runtime: Util.RuntimeOptions): ListAlarmResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dimension)) {
    query['Dimension'] = request.dimension;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.isEnable)) {
    query['IsEnable'] = request.isEnable;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlarm',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary ListAlarm
 *
 * @param request ListAlarmRequest
 * @return ListAlarmResponse
 */
async function listAlarm(request: ListAlarmRequest): ListAlarmResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmWithOptions(request, runtime);
}

model ListAlarmHistoryRequest {
  cursor?: string(name='Cursor', example='1'),
  endTime?: string(name='EndTime', example='1548927491223'),
  id?: string(name='Id', example='1a775e37-dfba-430c-ab9f-7036475c8bfb_2dbe619b-0483-402e-9437-7c7a38fba7ed'),
  regionId?: string(name='RegionId'),
  size?: int32(name='Size', example='3'),
  startTime?: string(name='StartTime', example='1548913091223'),
}

model ListAlarmHistoryResponseBody = {
  alarmHistoryList?: {
    alarmHistory?: [ 
    {
      alarmTime?: long(name='AlarmTime', example='1548926982000'),
      contactGroups?: string(name='ContactGroups'),
      dimension?: string(name='Dimension', example='{"instanceId":"XXX"}'),
      evaluationCount?: int32(name='EvaluationCount', example='3'),
      id?: string(name='Id', example='1a775e37-dfba-430c-ab9f-7036475c8bfb_2dbe619b-0483-402e-9437-7c7a38fba7ed'),
      instanceName?: string(name='InstanceName', example='test-demo'),
      lastTime?: long(name='LastTime', example='2851651669'),
      metricName?: string(name='MetricName', example='CPUUtilization'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace', example='acs_ecs_dashboard'),
      state?: string(name='State', example='ALARM'),
      status?: int32(name='Status', example='2'),
      value?: string(name='Value', example='84401454'),
    }
  ](name='AlarmHistory')
  }(name='AlarmHistoryList'),
  code?: string(name='Code', example='200'),
  cursor?: string(name='Cursor', example='1'),
  message?: string(name='Message', example='Success'),
  requestId?: string(name='RequestId', example='1DBBCE29-0F69-435C-B65C-53D1011D1D72'),
  success?: boolean(name='Success', example='true'),
}

model ListAlarmHistoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAlarmHistoryResponseBody(name='body'),
}

/**
 * @summary ListAlarmHistory
 *
 * @param request ListAlarmHistoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAlarmHistoryResponse
 */
async function listAlarmHistoryWithOptions(request: ListAlarmHistoryRequest, runtime: Util.RuntimeOptions): ListAlarmHistoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cursor)) {
    query['Cursor'] = request.cursor;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlarmHistory',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary ListAlarmHistory
 *
 * @param request ListAlarmHistoryRequest
 * @return ListAlarmHistoryResponse
 */
async function listAlarmHistory(request: ListAlarmHistoryRequest): ListAlarmHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmHistoryWithOptions(request, runtime);
}

model ListContactGroupRequest {
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='100'),
  regionId?: string(name='RegionId'),
}

model ListContactGroupResponseBody = {
  code?: string(name='Code', example='200'),
  contactGroups?: {
    contactGroup?: [ string ](name='ContactGroup')
  }(name='ContactGroups'),
  message?: string(name='Message', example='Success'),
  nextToken?: int32(name='NextToken', example='2'),
  requestId?: string(name='RequestId', example='D3D03B0A-CF1A-4DAB-BF0D-D4B6ACD5677A'),
  success?: boolean(name='Success', example='true'),
  total?: int32(name='Total', example='3'),
}

model ListContactGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListContactGroupResponseBody(name='body'),
}

/**
 * @param request ListContactGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListContactGroupResponse
 */
async function listContactGroupWithOptions(request: ListContactGroupRequest, runtime: Util.RuntimeOptions): ListContactGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListContactGroup',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListContactGroupRequest
 * @return ListContactGroupResponse
 */
async function listContactGroup(request: ListContactGroupRequest): ListContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listContactGroupWithOptions(request, runtime);
}

model ListEventRulesRequest {
  groupId?: string(name='GroupId'),
  namePrefix?: string(name='NamePrefix'),
  page?: string(name='Page'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model ListEventRulesResponseBody = {
  code?: string(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  datapoints?: {
    eventRule?: [ 
    {
      description?: string(name='Description'),
      eventPattern?: {
        eventPattern?: [ 
        {
          eventTypeList?: {
            eventTypeList?: [ string ](name='EventTypeList')
          }(name='EventTypeList'),
          levelList?: {
            levelList?: [ string ](name='LevelList')
          }(name='LevelList'),
          nameList?: {
            nameList?: [ string ](name='NameList')
          }(name='NameList'),
          product?: string(name='Product'),
          statusList?: {
            statusList?: [ string ](name='StatusList')
          }(name='StatusList'),
        }
      ](name='EventPattern')
      }(name='EventPattern'),
      eventType?: string(name='EventType'),
      groupId?: string(name='GroupId'),
      name?: string(name='Name'),
      state?: string(name='State'),
    }
  ](name='EventRule')
  }(name='Datapoints'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListEventRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEventRulesResponseBody(name='body'),
}

/**
 * @param request ListEventRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListEventRulesResponse
 */
async function listEventRulesWithOptions(request: ListEventRulesRequest, runtime: Util.RuntimeOptions): ListEventRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namePrefix)) {
    query['NamePrefix'] = request.namePrefix;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEventRules',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListEventRulesRequest
 * @return ListEventRulesResponse
 */
async function listEventRules(request: ListEventRulesRequest): ListEventRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventRulesWithOptions(request, runtime);
}

model ListMyGroupInstancesRequest {
  category?: string(name='Category'),
  groupId?: long(name='GroupId', description='This parameter is required.'),
  instanceIds?: string(name='InstanceIds'),
  keyword?: string(name='Keyword'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  total?: boolean(name='Total'),
}

model ListMyGroupInstancesResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  resources?: {
    resource?: [ 
    {
      aliUid?: long(name='AliUid'),
      category?: string(name='Category'),
      id?: long(name='Id'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Resource')
  }(name='Resources'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListMyGroupInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMyGroupInstancesResponseBody(name='body'),
}

/**
 * @param request ListMyGroupInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMyGroupInstancesResponse
 */
async function listMyGroupInstancesWithOptions(request: ListMyGroupInstancesRequest, runtime: Util.RuntimeOptions): ListMyGroupInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.total)) {
    query['Total'] = request.total;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMyGroupInstances',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMyGroupInstancesRequest
 * @return ListMyGroupInstancesResponse
 */
async function listMyGroupInstances(request: ListMyGroupInstancesRequest): ListMyGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMyGroupInstancesWithOptions(request, runtime);
}

model ListMyGroupsRequest {
  bindUrls?: string(name='BindUrls'),
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId'),
  keyword?: string(name='Keyword'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  selectContactGroups?: boolean(name='SelectContactGroups'),
  type?: string(name='Type'),
}

model ListMyGroupsResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  resources?: {
    resource?: [ 
    {
      bindUrl?: string(name='BindUrl'),
      bindUrls?: string(name='BindUrls'),
      contactGroups?: {
        contactGroup?: [ 
        {
          name?: string(name='Name'),
        }
      ](name='ContactGroup')
      }(name='ContactGroups'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      groupId?: long(name='GroupId'),
      groupName?: string(name='GroupName'),
      serviceId?: string(name='ServiceId'),
      type?: string(name='Type'),
    }
  ](name='Resource')
  }(name='Resources'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListMyGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMyGroupsResponseBody(name='body'),
}

/**
 * @param request ListMyGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMyGroupsResponse
 */
async function listMyGroupsWithOptions(request: ListMyGroupsRequest, runtime: Util.RuntimeOptions): ListMyGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bindUrls)) {
    query['BindUrls'] = request.bindUrls;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.selectContactGroups)) {
    query['SelectContactGroups'] = request.selectContactGroups;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMyGroups',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMyGroupsRequest
 * @return ListMyGroupsResponse
 */
async function listMyGroups(request: ListMyGroupsRequest): ListMyGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMyGroupsWithOptions(request, runtime);
}

model ModifyTaskRequest {
  address?: string(name='Address', example='http://www.aliyun.com'),
  alertIds?: string(name='AlertIds', example='5e9b-4c12-b39e-7f277ac44b11'),
  alertRule?: string(name='AlertRule', example='[{"alarmActions":"xxx","metricName":"Availability","expression":"$Availability<96"}]'),
  interval?: string(name='Interval', example='1'),
  intervalUnit?: string(name='IntervalUnit'),
  ispCity?: string(name='IspCity', example='[{"city":"546","isp":"465"},{"city":"572","isp":"465"},{"city":"738","isp":"465"}]'),
  options?: string(name='Options'),
  regionId?: string(name='RegionId'),
  taskId?: string(name='TaskId', description='This parameter is required.', example='8f880e3d-d924-47ab-84d2-fa1a72e24211'),
  taskName?: string(name='TaskName', example='aliyunTest'),
  caller?: string(name='caller', example='cms'),
}

model ModifyTaskResponseBody = {
  code?: string(name='Code', example='200'),
  data?: string(name='Data', example='{"count":1}'),
  message?: string(name='Message', example='successfull'),
  requestId?: string(name='RequestId', example='a4e6f550-7eac-4a13-b11f-6742aa2d42d1'),
  success?: string(name='Success', example='true'),
}

model ModifyTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyTaskResponseBody(name='body'),
}

/**
 * @param request ModifyTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyTaskResponse
 */
async function modifyTaskWithOptions(request: ModifyTaskRequest, runtime: Util.RuntimeOptions): ModifyTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.alertIds)) {
    query['AlertIds'] = request.alertIds;
  }
  if (!Util.isUnset(request.alertRule)) {
    query['AlertRule'] = request.alertRule;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.intervalUnit)) {
    query['IntervalUnit'] = request.intervalUnit;
  }
  if (!Util.isUnset(request.ispCity)) {
    query['IspCity'] = request.ispCity;
  }
  if (!Util.isUnset(request.options)) {
    query['Options'] = request.options;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.caller)) {
    query['caller'] = request.caller;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyTask',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ModifyTaskRequest
 * @return ModifyTaskResponse
 */
async function modifyTask(request: ModifyTaskRequest): ModifyTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTaskWithOptions(request, runtime);
}

model NodeListRequest {
  hostName?: string(name='HostName'),
  instanceIds?: string(name='InstanceIds'),
  instanceRegionId?: string(name='InstanceRegionId'),
  keyWord?: string(name='KeyWord'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  serialNumbers?: string(name='SerialNumbers'),
  status?: string(name='Status'),
  userId?: long(name='UserId', description='This parameter is required.'),
}

model NodeListResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  nodes?: {
    node?: [ 
    {
      aliUid?: long(name='AliUid'),
      aliyunHost?: boolean(name='AliyunHost'),
      eipAddress?: string(name='EipAddress'),
      eipId?: string(name='EipId'),
      hostName?: string(name='HostName'),
      instanceId?: string(name='InstanceId'),
      instanceTypeFamily?: string(name='InstanceTypeFamily'),
      ipGroup?: string(name='IpGroup'),
      natIp?: string(name='NatIp'),
      networkType?: string(name='NetworkType'),
      operatingSystem?: string(name='OperatingSystem'),
      region?: string(name='Region'),
      serialNumber?: string(name='SerialNumber'),
      tianjimonVersion?: string(name='TianjimonVersion'),
    }
  ](name='Node')
  }(name='Nodes'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  pageTotal?: int32(name='PageTotal'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model NodeListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: NodeListResponseBody(name='body'),
}

/**
 * @summary NodeList
 *
 * @param request NodeListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return NodeListResponse
 */
async function nodeListWithOptions(request: NodeListRequest, runtime: Util.RuntimeOptions): NodeListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.instanceRegionId)) {
    query['InstanceRegionId'] = request.instanceRegionId;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serialNumbers)) {
    query['SerialNumbers'] = request.serialNumbers;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'NodeList',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary NodeList
 *
 * @param request NodeListRequest
 * @return NodeListResponse
 */
async function nodeList(request: NodeListRequest): NodeListResponse {
  var runtime = new Util.RuntimeOptions{};
  return nodeListWithOptions(request, runtime);
}

model NodeProcessCreateRequest {
  command?: string(name='Command'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  name?: string(name='Name'),
  processName?: string(name='ProcessName'),
  processUser?: string(name='ProcessUser'),
  regionId?: string(name='RegionId'),
}

model NodeProcessCreateResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model NodeProcessCreateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: NodeProcessCreateResponseBody(name='body'),
}

/**
 * @summary NodeProcessCreate
 *
 * @param request NodeProcessCreateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return NodeProcessCreateResponse
 */
async function nodeProcessCreateWithOptions(request: NodeProcessCreateRequest, runtime: Util.RuntimeOptions): NodeProcessCreateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.command)) {
    query['Command'] = request.command;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.processName)) {
    query['ProcessName'] = request.processName;
  }
  if (!Util.isUnset(request.processUser)) {
    query['ProcessUser'] = request.processUser;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'NodeProcessCreate',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary NodeProcessCreate
 *
 * @param request NodeProcessCreateRequest
 * @return NodeProcessCreateResponse
 */
async function nodeProcessCreate(request: NodeProcessCreateRequest): NodeProcessCreateResponse {
  var runtime = new Util.RuntimeOptions{};
  return nodeProcessCreateWithOptions(request, runtime);
}

model NodeProcessesRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model NodeProcessesResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  nodeProcesses?: {
    nodeProcess?: [ 
    {
      command?: string(name='Command'),
      id?: long(name='Id'),
      instanceId?: string(name='InstanceId'),
      name?: string(name='Name'),
      processName?: string(name='ProcessName'),
      processUser?: string(name='ProcessUser'),
    }
  ](name='NodeProcess')
  }(name='NodeProcesses'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model NodeProcessesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: NodeProcessesResponseBody(name='body'),
}

/**
 * @summary NodeProcesses
 *
 * @param request NodeProcessesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return NodeProcessesResponse
 */
async function nodeProcessesWithOptions(request: NodeProcessesRequest, runtime: Util.RuntimeOptions): NodeProcessesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'NodeProcesses',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary NodeProcesses
 *
 * @param request NodeProcessesRequest
 * @return NodeProcessesResponse
 */
async function nodeProcesses(request: NodeProcessesRequest): NodeProcessesResponse {
  var runtime = new Util.RuntimeOptions{};
  return nodeProcessesWithOptions(request, runtime);
}

model NodeStatusListRequest {
  instanceIds?: string(name='InstanceIds', description='This parameter is required.', example='i-abcdefgh123456,i-abcdefgh123457'),
  regionId?: string(name='RegionId'),
}

model NodeStatusListResponseBody = {
  errorCode?: int32(name='ErrorCode', example='200'),
  errorMessage?: string(name='ErrorMessage', example='InstanceIds is mandatory for this action.'),
  nodeStatusList?: {
    nodeStatus?: [ 
    {
      autoInstall?: boolean(name='AutoInstall', example='true'),
      instanceId?: string(name='InstanceId', example='i-abcdefgh123456'),
      status?: string(name='Status', example='running'),
    }
  ](name='NodeStatus')
  }(name='NodeStatusList'),
  requestId?: string(name='RequestId', example='1BB8FE8E-9BBE-490F-82EC-BF70FB849D55'),
  success?: boolean(name='Success', example='true'),
}

model NodeStatusListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: NodeStatusListResponseBody(name='body'),
}

/**
 * @summary NodeStatusList
 *
 * @param request NodeStatusListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return NodeStatusListResponse
 */
async function nodeStatusListWithOptions(request: NodeStatusListRequest, runtime: Util.RuntimeOptions): NodeStatusListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'NodeStatusList',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary NodeStatusList
 *
 * @param request NodeStatusListRequest
 * @return NodeStatusListResponse
 */
async function nodeStatusList(request: NodeStatusListRequest): NodeStatusListResponse {
  var runtime = new Util.RuntimeOptions{};
  return nodeStatusListWithOptions(request, runtime);
}

model NodeUninstallRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model NodeUninstallResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model NodeUninstallResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: NodeUninstallResponseBody(name='body'),
}

/**
 * @summary NodeUninstall
 *
 * @param request NodeUninstallRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return NodeUninstallResponse
 */
async function nodeUninstallWithOptions(request: NodeUninstallRequest, runtime: Util.RuntimeOptions): NodeUninstallResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'NodeUninstall',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary NodeUninstall
 *
 * @param request NodeUninstallRequest
 * @return NodeUninstallResponse
 */
async function nodeUninstall(request: NodeUninstallRequest): NodeUninstallResponse {
  var runtime = new Util.RuntimeOptions{};
  return nodeUninstallWithOptions(request, runtime);
}

model PutCustomMetricRequest {
  metricList?: string(name='MetricList'),
  regionId?: string(name='RegionId'),
}

model PutCustomMetricResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model PutCustomMetricResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PutCustomMetricResponseBody(name='body'),
}

/**
 * @summary PutCustomMetric
 *
 * @param request PutCustomMetricRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutCustomMetricResponse
 */
async function putCustomMetricWithOptions(request: PutCustomMetricRequest, runtime: Util.RuntimeOptions): PutCustomMetricResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.metricList)) {
    query['MetricList'] = request.metricList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutCustomMetric',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary PutCustomMetric
 *
 * @param request PutCustomMetricRequest
 * @return PutCustomMetricResponse
 */
async function putCustomMetric(request: PutCustomMetricRequest): PutCustomMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return putCustomMetricWithOptions(request, runtime);
}

model PutEventRequest {
  eventInfo?: string(name='EventInfo'),
  regionId?: string(name='RegionId'),
}

model PutEventResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model PutEventResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PutEventResponseBody(name='body'),
}

/**
 * @summary PutEvent
 *
 * @param request PutEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutEventResponse
 */
async function putEventWithOptions(request: PutEventRequest, runtime: Util.RuntimeOptions): PutEventResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventInfo)) {
    query['EventInfo'] = request.eventInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutEvent',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary PutEvent
 *
 * @param request PutEventRequest
 * @return PutEventResponse
 */
async function putEvent(request: PutEventRequest): PutEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return putEventWithOptions(request, runtime);
}

model PutEventRuleRequest {
  description?: string(name='Description'),
  eventPattern?: [ 
    {
      eventTypeList?: [ string ](name='EventTypeList'),
      levelList?: [ string ](name='LevelList'),
      nameList?: [ string ](name='NameList'),
      product?: string(name='Product'),
      statusList?: [ string ](name='StatusList'),
    }
  ](name='EventPattern', description='This parameter is required.'),
  eventType?: string(name='EventType'),
  groupId?: string(name='GroupId'),
  name?: string(name='Name', description='This parameter is required.'),
  regionId?: string(name='RegionId'),
  state?: string(name='State'),
}

model PutEventRuleResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutEventRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PutEventRuleResponseBody(name='body'),
}

/**
 * @param request PutEventRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutEventRuleResponse
 */
async function putEventRuleWithOptions(request: PutEventRuleRequest, runtime: Util.RuntimeOptions): PutEventRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventPattern)) {
    query['EventPattern'] = request.eventPattern;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutEventRule',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PutEventRuleRequest
 * @return PutEventRuleResponse
 */
async function putEventRule(request: PutEventRuleRequest): PutEventRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putEventRuleWithOptions(request, runtime);
}

model PutEventTargetsRequest {
  contactParameters?: [ 
    {
      contactGroupName?: string(name='ContactGroupName'),
      id?: string(name='Id'),
      level?: string(name='Level'),
    }
  ](name='ContactParameters'),
  fcParameters?: [ 
    {
      functionName?: string(name='FunctionName'),
      id?: string(name='Id'),
      region?: string(name='Region'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='FcParameters'),
  mnsParameters?: [ 
    {
      id?: string(name='Id'),
      queue?: string(name='Queue'),
      region?: string(name='Region'),
    }
  ](name='MnsParameters'),
  regionId?: string(name='RegionId'),
  ruleName?: string(name='RuleName', description='This parameter is required.'),
  slsParameters?: [ 
    {
      id?: string(name='Id'),
      logStore?: string(name='LogStore'),
      project?: string(name='Project'),
      region?: string(name='Region'),
    }
  ](name='SlsParameters'),
  webhookParameters?: [ 
    {
      id?: string(name='Id'),
      method?: string(name='Method'),
      protocol?: string(name='Protocol'),
      url?: string(name='Url'),
    }
  ](name='WebhookParameters'),
}

model PutEventTargetsResponseBody = {
  code?: string(name='Code'),
  contactParameters?: {
    contactParameter?: [ 
    {
      contactGroupName?: string(name='ContactGroupName'),
      id?: int32(name='Id'),
      level?: string(name='Level'),
    }
  ](name='ContactParameter')
  }(name='ContactParameters'),
  failedContactParameters?: {
    contactParameter?: [ 
    {
      contactGroupName?: string(name='ContactGroupName'),
      id?: int32(name='Id'),
      level?: string(name='Level'),
    }
  ](name='ContactParameter')
  }(name='FailedContactParameters'),
  failedFcParameters?: {
    fcParameter?: [ 
    {
      functionName?: string(name='FunctionName'),
      id?: int32(name='Id'),
      region?: string(name='Region'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='FcParameter')
  }(name='FailedFcParameters'),
  failedMnsParameters?: {
    mnsParameter?: [ 
    {
      id?: int32(name='Id'),
      queue?: string(name='Queue'),
      region?: string(name='Region'),
    }
  ](name='MnsParameter')
  }(name='FailedMnsParameters'),
  failedParameterCount?: string(name='FailedParameterCount'),
  failedSlsParameters?: {
    failedSlsParameter?: [ 
    {
      id?: string(name='Id'),
      logStore?: string(name='LogStore'),
      project?: string(name='Project'),
      region?: string(name='Region'),
    }
  ](name='FailedSlsParameter')
  }(name='FailedSlsParameters'),
  fcParameters?: {
    fcParameter?: [ 
    {
      functionName?: string(name='FunctionName'),
      id?: int32(name='Id'),
      region?: string(name='Region'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='FcParameter')
  }(name='FcParameters'),
  message?: string(name='Message'),
  mnsParameters?: {
    mnsParameter?: [ 
    {
      id?: int32(name='Id'),
      queue?: string(name='Queue'),
      region?: string(name='Region'),
    }
  ](name='MnsParameter')
  }(name='MnsParameters'),
  parameterCount?: string(name='ParameterCount'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutEventTargetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PutEventTargetsResponseBody(name='body'),
}

/**
 * @param request PutEventTargetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutEventTargetsResponse
 */
async function putEventTargetsWithOptions(request: PutEventTargetsRequest, runtime: Util.RuntimeOptions): PutEventTargetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactParameters)) {
    query['ContactParameters'] = request.contactParameters;
  }
  if (!Util.isUnset(request.fcParameters)) {
    query['FcParameters'] = request.fcParameters;
  }
  if (!Util.isUnset(request.mnsParameters)) {
    query['MnsParameters'] = request.mnsParameters;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.slsParameters)) {
    query['SlsParameters'] = request.slsParameters;
  }
  if (!Util.isUnset(request.webhookParameters)) {
    query['WebhookParameters'] = request.webhookParameters;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutEventTargets',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PutEventTargetsRequest
 * @return PutEventTargetsResponse
 */
async function putEventTargets(request: PutEventTargetsRequest): PutEventTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return putEventTargetsWithOptions(request, runtime);
}

model PutMetricRuleTargetsRequest {
  actions?: string(name='Actions'),
  regionId?: string(name='RegionId'),
  ruleName?: string(name='RuleName', description='This parameter is required.'),
  targets?: [ 
    {
      arn?: string(name='Arn'),
      id?: string(name='Id'),
      level?: string(name='Level'),
    }
  ](name='Targets', description='This parameter is required.'),
}

model PutMetricRuleTargetsResponseBody = {
  code?: string(name='Code'),
  failData?: {
    targets?: {
      target?: [ 
      {
        arn?: string(name='Arn'),
        id?: string(name='Id'),
        level?: string(name='Level'),
      }
    ](name='Target')
    }(name='Targets'),
  }(name='FailData'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutMetricRuleTargetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PutMetricRuleTargetsResponseBody(name='body'),
}

/**
 * @summary PutMetricRuleTargets
 *
 * @param request PutMetricRuleTargetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutMetricRuleTargetsResponse
 */
async function putMetricRuleTargetsWithOptions(request: PutMetricRuleTargetsRequest, runtime: Util.RuntimeOptions): PutMetricRuleTargetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.targets)) {
    query['Targets'] = request.targets;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.actions)) {
    body['Actions'] = request.actions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutMetricRuleTargets',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary PutMetricRuleTargets
 *
 * @param request PutMetricRuleTargetsRequest
 * @return PutMetricRuleTargetsResponse
 */
async function putMetricRuleTargets(request: PutMetricRuleTargetsRequest): PutMetricRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return putMetricRuleTargetsWithOptions(request, runtime);
}

model PutResourceMetricRuleRequest {
  escalations?: {
    critical?: {
        comparisonOperator?: string(name='ComparisonOperator'),
        statistics?: string(name='Statistics'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Critical'),
    info?: {
        comparisonOperator?: string(name='ComparisonOperator'),
        statistics?: string(name='Statistics'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Info'),
    warn?: {
        comparisonOperator?: string(name='ComparisonOperator'),
        statistics?: string(name='Statistics'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Warn'),
  }(name='Escalations'),
  contactGroups?: string(name='ContactGroups'),
  effectiveInterval?: string(name='EffectiveInterval'),
  emailSubject?: string(name='EmailSubject'),
  interval?: string(name='Interval'),
  metricName?: string(name='MetricName', description='This parameter is required.'),
  namespace?: string(name='Namespace', description='This parameter is required.'),
  noEffectiveInterval?: string(name='NoEffectiveInterval'),
  period?: string(name='Period'),
  resources?: string(name='Resources', description='This parameter is required.'),
  ruleId?: string(name='RuleId', description='This parameter is required.'),
  ruleName?: string(name='RuleName'),
  silenceTime?: int32(name='SilenceTime'),
  webhook?: string(name='Webhook'),
}

model PutResourceMetricRuleResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutResourceMetricRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PutResourceMetricRuleResponseBody(name='body'),
}

/**
 * @summary PutResourceMetricRule
 *
 * @param request PutResourceMetricRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutResourceMetricRuleResponse
 */
async function putResourceMetricRuleWithOptions(request: PutResourceMetricRuleRequest, runtime: Util.RuntimeOptions): PutResourceMetricRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroups)) {
    query['ContactGroups'] = request.contactGroups;
  }
  if (!Util.isUnset(request.effectiveInterval)) {
    query['EffectiveInterval'] = request.effectiveInterval;
  }
  if (!Util.isUnset(request.emailSubject)) {
    query['EmailSubject'] = request.emailSubject;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.noEffectiveInterval)) {
    query['NoEffectiveInterval'] = request.noEffectiveInterval;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.resources)) {
    query['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.silenceTime)) {
    query['SilenceTime'] = request.silenceTime;
  }
  if (!Util.isUnset(request.webhook)) {
    query['Webhook'] = request.webhook;
  }
  if (!Util.isUnset(request.escalations)) {
    query['Escalations'] = request.escalations;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutResourceMetricRule',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary PutResourceMetricRule
 *
 * @param request PutResourceMetricRuleRequest
 * @return PutResourceMetricRuleResponse
 */
async function putResourceMetricRule(request: PutResourceMetricRuleRequest): PutResourceMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putResourceMetricRuleWithOptions(request, runtime);
}

model QueryCustomMetricListRequest {
  dimension?: string(name='Dimension'),
  groupId?: string(name='GroupId', description='This parameter is required.'),
  md5?: string(name='Md5'),
  metricName?: string(name='MetricName'),
  page?: string(name='Page'),
  size?: string(name='Size'),
}

model QueryCustomMetricListResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model QueryCustomMetricListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryCustomMetricListResponseBody(name='body'),
}

/**
 * @param request QueryCustomMetricListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryCustomMetricListResponse
 */
async function queryCustomMetricListWithOptions(request: QueryCustomMetricListRequest, runtime: Util.RuntimeOptions): QueryCustomMetricListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dimension)) {
    query['Dimension'] = request.dimension;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.md5)) {
    query['Md5'] = request.md5;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryCustomMetricList',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryCustomMetricListRequest
 * @return QueryCustomMetricListResponse
 */
async function queryCustomMetricList(request: QueryCustomMetricListRequest): QueryCustomMetricListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCustomMetricListWithOptions(request, runtime);
}

model QueryMetricDataRequest {
  dimensions?: string(name='Dimensions'),
  endTime?: string(name='EndTime'),
  express?: string(name='Express'),
  length?: string(name='Length'),
  metric?: string(name='Metric', description='This parameter is required.'),
  period?: string(name='Period'),
  project?: string(name='Project', description='This parameter is required.'),
  regionId?: string(name='RegionId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model QueryMetricDataResponseBody = {
  code?: string(name='Code'),
  datapoints?: string(name='Datapoints'),
  message?: string(name='Message'),
  period?: string(name='Period'),
  requestId?: string(name='RequestId'),
}

model QueryMetricDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMetricDataResponseBody(name='body'),
}

/**
 * @summary QueryMetricData
 *
 * @param request QueryMetricDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMetricDataResponse
 */
async function queryMetricDataWithOptions(request: QueryMetricDataRequest, runtime: Util.RuntimeOptions): QueryMetricDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.express)) {
    query['Express'] = request.express;
  }
  if (!Util.isUnset(request.length)) {
    query['Length'] = request.length;
  }
  if (!Util.isUnset(request.metric)) {
    query['Metric'] = request.metric;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMetricData',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary QueryMetricData
 *
 * @param request QueryMetricDataRequest
 * @return QueryMetricDataResponse
 */
async function queryMetricData(request: QueryMetricDataRequest): QueryMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMetricDataWithOptions(request, runtime);
}

model QueryMetricLastRequest {
  cursor?: string(name='Cursor', example='1000'),
  dimensions?: string(name='Dimensions', example='[{"instanceId":"XXX"}]'),
  endTime?: string(name='EndTime', example='2019-01-31 10:10:00'),
  express?: string(name='Express', example='{"groupby":["userId","instanceId"]}'),
  length?: string(name='Length', example='1000'),
  metric?: string(name='Metric', description='This parameter is required.', example='CPUUtilization'),
  page?: string(name='Page', example='1'),
  period?: string(name='Period', example='60'),
  project?: string(name='Project', description='This parameter is required.', example='acs_ecs_dashboard'),
  regionId?: string(name='RegionId'),
  resourceOwnerId?: long(name='ResourceOwnerId', example='000'),
  startTime?: string(name='StartTime', example='2019-01-31 10:00:00'),
}

model QueryMetricLastResponseBody = {
  code?: string(name='Code', example='200'),
  cursor?: string(name='Cursor', example='10000'),
  datapoints?: string(name='Datapoints', example='[{"timestamp":1548900600000,"userId":"000","instanceId":"abc","Minimum":6.3,"Average":6.3,"Maximum":6.3}]'),
  message?: string(name='Message', example='Success'),
  period?: string(name='Period', example='60'),
  requestId?: string(name='RequestId', example='021472A6-25E3-4094-8D00-BA4B6A5486C3'),
  success?: string(name='Success', example='true'),
}

model QueryMetricLastResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMetricLastResponseBody(name='body'),
}

/**
 * @param request QueryMetricLastRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMetricLastResponse
 */
async function queryMetricLastWithOptions(request: QueryMetricLastRequest, runtime: Util.RuntimeOptions): QueryMetricLastResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cursor)) {
    query['Cursor'] = request.cursor;
  }
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.express)) {
    query['Express'] = request.express;
  }
  if (!Util.isUnset(request.length)) {
    query['Length'] = request.length;
  }
  if (!Util.isUnset(request.metric)) {
    query['Metric'] = request.metric;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMetricLast',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMetricLastRequest
 * @return QueryMetricLastResponse
 */
async function queryMetricLast(request: QueryMetricLastRequest): QueryMetricLastResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMetricLastWithOptions(request, runtime);
}

model QueryMetricListRequest {
  cursor?: string(name='Cursor', example='1000'),
  dimensions?: string(name='Dimensions', example='[{"instanceId": "i-abcdefgh123456"}]'),
  endTime?: string(name='EndTime', example='2019-01-30 00:10:00'),
  express?: string(name='Express', example='“{"groupby":["userId","instanceId"]}”'),
  length?: string(name='Length', example='1000'),
  metric?: string(name='Metric', description='This parameter is required.', example='cpu_idle'),
  period?: string(name='Period', example='60'),
  project?: string(name='Project', description='This parameter is required.', example='acs_ecs_dashboard'),
  regionId?: string(name='RegionId'),
  resourceOwnerId?: long(name='ResourceOwnerId', example='000'),
  startTime?: string(name='StartTime', example='2019-01-30 00:00:00'),
}

model QueryMetricListResponseBody = {
  code?: string(name='Code', example='200'),
  cursor?: string(name='Cursor', example='1000'),
  datapoints?: string(name='Datapoints', example='[{"timestamp":1548777660000,"userId":"123","instanceId":"i-abc","Minimum":9.92,"Average":9.92,"Maximum":9.92}]'),
  message?: string(name='Message', example='Success'),
  period?: string(name='Period', example='60'),
  requestId?: string(name='RequestId', example='3121AE7D-4AFF-4C25-8F1D-C8226EBB1F42'),
  success?: string(name='Success', example='true'),
}

model QueryMetricListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMetricListResponseBody(name='body'),
}

/**
 * @param request QueryMetricListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMetricListResponse
 */
async function queryMetricListWithOptions(request: QueryMetricListRequest, runtime: Util.RuntimeOptions): QueryMetricListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cursor)) {
    query['Cursor'] = request.cursor;
  }
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.express)) {
    query['Express'] = request.express;
  }
  if (!Util.isUnset(request.length)) {
    query['Length'] = request.length;
  }
  if (!Util.isUnset(request.metric)) {
    query['Metric'] = request.metric;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMetricList',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMetricListRequest
 * @return QueryMetricListResponse
 */
async function queryMetricList(request: QueryMetricListRequest): QueryMetricListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMetricListWithOptions(request, runtime);
}

model QueryMetricMetaRequest {
  labels?: string(name='Labels', example='[{\\\\"name\\\\":\\\\"alertUnit\\\\",\\\\"value\\\\":\\\\"%\\\\"}]'),
  metric?: string(name='Metric', example='CPUUtilization'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  project?: string(name='Project', example='acs_ecs_dashboard'),
}

model QueryMetricMetaResponseBody = {
  errorCode?: string(name='ErrorCode', example='200'),
  errorMessage?: string(name='ErrorMessage', example='Success'),
  requestId?: string(name='RequestId', example='0CCE0AF0-053C-4B13-A583-DC9A85785D49'),
  resources?: {
    resource?: [ 
    {
      description?: string(name='Description', example='ECS.CPUUtilization'),
      dimensions?: string(name='Dimensions', example='instanceId'),
      labels?: string(name='Labels', example='[{\\\\"name\\\\":\\\\"alertUnit\\\\",\\\\"value\\\\":\\\\"%\\\\"},{\\\\"name\\\\":\\\\"alertDefault\\\\",\\\\"value\\\\":\\\\"80\\\\"},{\\\\"name\\\\":\\\\"minAlertPeriod\\\\",\\\\"value\\\\":\\\\"60\\\\"},{\\\\"name\\\\":\\\\"metricCategory\\\\",\\\\"value\\\\":\\\\"instanceId\\\\"},{\\\\"name\\\\":\\\\"is_alarm\\\\",\\\\"value\\\\":\\\\"true\\\\"}]"'),
      metric?: string(name='Metric', example='CPUUtilization'),
      periods?: string(name='Periods', example='60,300'),
      project?: string(name='Project', example='acs_ecs_dashboard'),
      statistics?: string(name='Statistics', example='Average,Minimum,Maximum'),
      unit?: string(name='Unit', example='%'),
    }
  ](name='Resource')
  }(name='Resources'),
  success?: boolean(name='Success', example='true'),
}

model QueryMetricMetaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMetricMetaResponseBody(name='body'),
}

/**
 * @summary 查询云监控开放的监控项详情
 *
 * @param request QueryMetricMetaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMetricMetaResponse
 */
async function queryMetricMetaWithOptions(request: QueryMetricMetaRequest, runtime: Util.RuntimeOptions): QueryMetricMetaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.metric)) {
    query['Metric'] = request.metric;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMetricMeta',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询云监控开放的监控项详情
 *
 * @param request QueryMetricMetaRequest
 * @return QueryMetricMetaResponse
 */
async function queryMetricMeta(request: QueryMetricMetaRequest): QueryMetricMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMetricMetaWithOptions(request, runtime);
}

model QueryMetricTopRequest {
  dimensions?: string(name='Dimensions'),
  endTime?: string(name='EndTime'),
  express?: string(name='Express'),
  length?: string(name='Length'),
  metric?: string(name='Metric', description='This parameter is required.'),
  orderDesc?: string(name='OrderDesc'),
  orderby?: string(name='Orderby'),
  period?: string(name='Period'),
  project?: string(name='Project', description='This parameter is required.'),
  regionId?: string(name='RegionId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model QueryMetricTopResponseBody = {
  code?: string(name='Code'),
  datapoints?: string(name='Datapoints'),
  message?: string(name='Message'),
  period?: string(name='Period'),
  requestId?: string(name='RequestId'),
}

model QueryMetricTopResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMetricTopResponseBody(name='body'),
}

/**
 * @summary QueryMetricTop
 *
 * @param request QueryMetricTopRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMetricTopResponse
 */
async function queryMetricTopWithOptions(request: QueryMetricTopRequest, runtime: Util.RuntimeOptions): QueryMetricTopResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.express)) {
    query['Express'] = request.express;
  }
  if (!Util.isUnset(request.length)) {
    query['Length'] = request.length;
  }
  if (!Util.isUnset(request.metric)) {
    query['Metric'] = request.metric;
  }
  if (!Util.isUnset(request.orderDesc)) {
    query['OrderDesc'] = request.orderDesc;
  }
  if (!Util.isUnset(request.orderby)) {
    query['Orderby'] = request.orderby;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMetricTop',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary QueryMetricTop
 *
 * @param request QueryMetricTopRequest
 * @return QueryMetricTopResponse
 */
async function queryMetricTop(request: QueryMetricTopRequest): QueryMetricTopResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMetricTopWithOptions(request, runtime);
}

model QueryProjectMetaRequest {
  labels?: string(name='Labels', example='[{\\\\"name\\\\":\\\\"product\\\\",\\\\"value\\\\":\\\\"MongoDB\\\\"]'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
}

model QueryProjectMetaResponseBody = {
  errorCode?: string(name='ErrorCode', example='200'),
  errorMessage?: string(name='ErrorMessage', example='Success'),
  requestId?: string(name='RequestId', example='D3DBF9F5-7C4D-4A67-B869-097C069C481D'),
  resources?: {
    resource?: [ 
    {
      description?: string(name='Description', example='ApsaraDB for MongoDB'),
      labels?: string(name='Labels', example='[{\\\\"name\\\\":\\\\"product\\\\",\\\\"value\\\\":\\\\"MongoDB\\\\"]'),
      project?: string(name='Project', example='acs_mongodb'),
    }
  ](name='Resource')
  }(name='Resources'),
  success?: boolean(name='Success', example='true'),
}

model QueryProjectMetaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryProjectMetaResponseBody(name='body'),
}

/**
 * @summary 查询云监控支持的时序类监控项产品列表
 *
 * @param request QueryProjectMetaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryProjectMetaResponse
 */
async function queryProjectMetaWithOptions(request: QueryProjectMetaRequest, runtime: Util.RuntimeOptions): QueryProjectMetaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryProjectMeta',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询云监控支持的时序类监控项产品列表
 *
 * @param request QueryProjectMetaRequest
 * @return QueryProjectMetaResponse
 */
async function queryProjectMeta(request: QueryProjectMetaRequest): QueryProjectMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryProjectMetaWithOptions(request, runtime);
}

model QueryStaticsAvailabilityRequest {
  regionId?: string(name='RegionId'),
  taskId?: string(name='TaskId', description='This parameter is required.'),
  timeRange?: string(name='TimeRange'),
}

model QueryStaticsAvailabilityResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QueryStaticsAvailabilityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryStaticsAvailabilityResponseBody(name='body'),
}

/**
 * @param request QueryStaticsAvailabilityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryStaticsAvailabilityResponse
 */
async function queryStaticsAvailabilityWithOptions(request: QueryStaticsAvailabilityRequest, runtime: Util.RuntimeOptions): QueryStaticsAvailabilityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.timeRange)) {
    query['TimeRange'] = request.timeRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryStaticsAvailability',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryStaticsAvailabilityRequest
 * @return QueryStaticsAvailabilityResponse
 */
async function queryStaticsAvailability(request: QueryStaticsAvailabilityRequest): QueryStaticsAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryStaticsAvailabilityWithOptions(request, runtime);
}

model QueryStaticsResponseTimeRequest {
  regionId?: string(name='RegionId'),
  taskId?: string(name='TaskId', description='This parameter is required.'),
  timeRange?: string(name='TimeRange'),
}

model QueryStaticsResponseTimeResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QueryStaticsResponseTimeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryStaticsResponseTimeResponseBody(name='body'),
}

/**
 * @param request QueryStaticsResponseTimeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryStaticsResponseTimeResponse
 */
async function queryStaticsResponseTimeWithOptions(request: QueryStaticsResponseTimeRequest, runtime: Util.RuntimeOptions): QueryStaticsResponseTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.timeRange)) {
    query['TimeRange'] = request.timeRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryStaticsResponseTime',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryStaticsResponseTimeRequest
 * @return QueryStaticsResponseTimeResponse
 */
async function queryStaticsResponseTime(request: QueryStaticsResponseTimeRequest): QueryStaticsResponseTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryStaticsResponseTimeWithOptions(request, runtime);
}

model QuerySystemEventCountRequest {
  queryJson?: string(name='QueryJson'),
  regionId?: string(name='RegionId'),
}

model QuerySystemEventCountResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QuerySystemEventCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySystemEventCountResponseBody(name='body'),
}

/**
 * @summary QuerySystemEventCount
 *
 * @param request QuerySystemEventCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySystemEventCountResponse
 */
async function querySystemEventCountWithOptions(request: QuerySystemEventCountRequest, runtime: Util.RuntimeOptions): QuerySystemEventCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.queryJson)) {
    query['QueryJson'] = request.queryJson;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySystemEventCount',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary QuerySystemEventCount
 *
 * @param request QuerySystemEventCountRequest
 * @return QuerySystemEventCountResponse
 */
async function querySystemEventCount(request: QuerySystemEventCountRequest): QuerySystemEventCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySystemEventCountWithOptions(request, runtime);
}

model QuerySystemEventDemoRequest {
  eventName?: string(name='EventName', description='This parameter is required.'),
  product?: string(name='Product', description='This parameter is required.'),
  regionId?: string(name='RegionId'),
}

model QuerySystemEventDemoResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QuerySystemEventDemoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySystemEventDemoResponseBody(name='body'),
}

/**
 * @param request QuerySystemEventDemoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySystemEventDemoResponse
 */
async function querySystemEventDemoWithOptions(request: QuerySystemEventDemoRequest, runtime: Util.RuntimeOptions): QuerySystemEventDemoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventName)) {
    query['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySystemEventDemo',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySystemEventDemoRequest
 * @return QuerySystemEventDemoResponse
 */
async function querySystemEventDemo(request: QuerySystemEventDemoRequest): QuerySystemEventDemoResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySystemEventDemoWithOptions(request, runtime);
}

model QueryTaskConfigRequest {
  regionId?: string(name='RegionId'),
}

model QueryTaskConfigResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QueryTaskConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryTaskConfigResponseBody(name='body'),
}

/**
 * @param request QueryTaskConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryTaskConfigResponse
 */
async function queryTaskConfigWithOptions(request: QueryTaskConfigRequest, runtime: Util.RuntimeOptions): QueryTaskConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
  };
  var params = new OpenApi.Params{
    action = 'QueryTaskConfig',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryTaskConfigRequest
 * @return QueryTaskConfigResponse
 */
async function queryTaskConfig(request: QueryTaskConfigRequest): QueryTaskConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTaskConfigWithOptions(request, runtime);
}

model QueryTaskMonitorDataRequest {
  cursor?: string(name='Cursor'),
  endTime?: string(name='EndTime'),
  length?: int32(name='Length'),
  period?: string(name='Period'),
  regionId?: string(name='RegionId'),
  startTime?: string(name='StartTime'),
  taskId?: string(name='TaskId', description='This parameter is required.'),
  type?: string(name='Type'),
  metricName?: string(name='metricName', description='This parameter is required.'),
}

model QueryTaskMonitorDataResponseBody = {
  code?: string(name='Code'),
  cursor?: string(name='Cursor'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  traceId?: string(name='TraceId'),
}

model QueryTaskMonitorDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryTaskMonitorDataResponseBody(name='body'),
}

/**
 * @summary QueryTaskMonitorData
 *
 * @param request QueryTaskMonitorDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryTaskMonitorDataResponse
 */
async function queryTaskMonitorDataWithOptions(request: QueryTaskMonitorDataRequest, runtime: Util.RuntimeOptions): QueryTaskMonitorDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cursor)) {
    query['Cursor'] = request.cursor;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.length)) {
    query['Length'] = request.length;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.metricName)) {
    query['metricName'] = request.metricName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTaskMonitorData',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary QueryTaskMonitorData
 *
 * @param request QueryTaskMonitorDataRequest
 * @return QueryTaskMonitorDataResponse
 */
async function queryTaskMonitorData(request: QueryTaskMonitorDataRequest): QueryTaskMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTaskMonitorDataWithOptions(request, runtime);
}

model TaskConfigListRequest {
  groupId?: long(name='GroupId'),
  id?: long(name='Id'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  taskName?: string(name='TaskName'),
}

model TaskConfigListResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  pageTotal?: int32(name='PageTotal'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskList?: {
    nodeTaskConfig?: [ 
    {
      alertConfig?: string(name='AlertConfig'),
      disabled?: boolean(name='Disabled'),
      groupId?: long(name='GroupId'),
      groupName?: string(name='GroupName'),
      id?: long(name='Id'),
      instanceList?: {
        string?: [ string ](name='String')
      }(name='InstanceList'),
      jsonData?: string(name='JsonData'),
      taskName?: string(name='TaskName'),
      taskScope?: string(name='TaskScope'),
      taskType?: string(name='TaskType'),
    }
  ](name='NodeTaskConfig')
  }(name='TaskList'),
  total?: int32(name='Total'),
}

model TaskConfigListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TaskConfigListResponseBody(name='body'),
}

/**
 * @param request TaskConfigListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TaskConfigListResponse
 */
async function taskConfigListWithOptions(request: TaskConfigListRequest, runtime: Util.RuntimeOptions): TaskConfigListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TaskConfigList',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request TaskConfigListRequest
 * @return TaskConfigListResponse
 */
async function taskConfigList(request: TaskConfigListRequest): TaskConfigListResponse {
  var runtime = new Util.RuntimeOptions{};
  return taskConfigListWithOptions(request, runtime);
}

model UpdateAlarmRequest {
  comparisonOperator?: string(name='ComparisonOperator', example='>'),
  contactGroups?: string(name='ContactGroups'),
  dryRun?: boolean(name='DryRun', example='false'),
  endTime?: int32(name='EndTime', example='24'),
  evaluationCount?: int32(name='EvaluationCount', example='3'),
  id?: string(name='Id', description='This parameter is required.', example='576fbae7-2fd1-411a-ae13-6f09f4fafdde'),
  name?: string(name='Name', example='test_modify'),
  notifyType?: int32(name='NotifyType', example='1'),
  period?: int32(name='Period', example='60'),
  regionId?: string(name='RegionId'),
  silenceTime?: int32(name='SilenceTime', example='86400'),
  startTime?: int32(name='StartTime', example='0'),
  statistics?: string(name='Statistics', example='Average'),
  threshold?: string(name='Threshold', description='This parameter is required.', example='40'),
  webhook?: string(name='Webhook', example='http://www.net.cn/example_callback.htm'),
}

model UpdateAlarmResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='Success'),
  requestId?: string(name='RequestId', example='945B9183-95C0-44FF-B30C-9ED37D44F6DC'),
  success?: boolean(name='Success', example='true'),
}

model UpdateAlarmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAlarmResponseBody(name='body'),
}

/**
 * @summary UpdateAlarm
 *
 * @param request UpdateAlarmRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAlarmResponse
 */
async function updateAlarmWithOptions(request: UpdateAlarmRequest, runtime: Util.RuntimeOptions): UpdateAlarmResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comparisonOperator)) {
    query['ComparisonOperator'] = request.comparisonOperator;
  }
  if (!Util.isUnset(request.contactGroups)) {
    query['ContactGroups'] = request.contactGroups;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.notifyType)) {
    query['NotifyType'] = request.notifyType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.silenceTime)) {
    query['SilenceTime'] = request.silenceTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.statistics)) {
    query['Statistics'] = request.statistics;
  }
  if (!Util.isUnset(request.threshold)) {
    query['Threshold'] = request.threshold;
  }
  if (!Util.isUnset(request.webhook)) {
    query['Webhook'] = request.webhook;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlarm',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary UpdateAlarm
 *
 * @param request UpdateAlarmRequest
 * @return UpdateAlarmResponse
 */
async function updateAlarm(request: UpdateAlarmRequest): UpdateAlarmResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAlarmWithOptions(request, runtime);
}

model UpdateMonitoringTemplateRequest {
  alertTemplatesJson?: string(name='AlertTemplatesJson', description='This parameter is required.'),
  description?: string(name='Description'),
  hostAvailabilityTemplate?: string(name='HostAvailabilityTemplate'),
  id?: long(name='Id', description='This parameter is required.'),
  name?: string(name='Name'),
  processMonitorTemplates?: string(name='ProcessMonitorTemplates'),
  regionId?: string(name='RegionId'),
  restVersion?: long(name='RestVersion', description='This parameter is required.'),
  systemEventTemplates?: string(name='SystemEventTemplates'),
}

model UpdateMonitoringTemplateResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateMonitoringTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMonitoringTemplateResponseBody(name='body'),
}

/**
 * @param request UpdateMonitoringTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMonitoringTemplateResponse
 */
async function updateMonitoringTemplateWithOptions(request: UpdateMonitoringTemplateRequest, runtime: Util.RuntimeOptions): UpdateMonitoringTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertTemplatesJson)) {
    query['AlertTemplatesJson'] = request.alertTemplatesJson;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.hostAvailabilityTemplate)) {
    query['HostAvailabilityTemplate'] = request.hostAvailabilityTemplate;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.processMonitorTemplates)) {
    query['ProcessMonitorTemplates'] = request.processMonitorTemplates;
  }
  if (!Util.isUnset(request.restVersion)) {
    query['RestVersion'] = request.restVersion;
  }
  if (!Util.isUnset(request.systemEventTemplates)) {
    query['SystemEventTemplates'] = request.systemEventTemplates;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMonitoringTemplate',
    version = '2018-03-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateMonitoringTemplateRequest
 * @return UpdateMonitoringTemplateResponse
 */
async function updateMonitoringTemplate(request: UpdateMonitoringTemplateRequest): UpdateMonitoringTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMonitoringTemplateWithOptions(request, runtime);
}

