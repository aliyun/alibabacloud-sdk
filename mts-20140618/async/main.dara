/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Mts';
  @version = '2014-06-18';
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'mts.aliyuncs.com',
    ap-southeast-2 = 'mts.aliyuncs.com',
    ap-southeast-3 = 'mts.aliyuncs.com',
    cn-beijing-finance-1 = 'mts.aliyuncs.com',
    cn-beijing-finance-pop = 'mts.aliyuncs.com',
    cn-beijing-gov-1 = 'mts.aliyuncs.com',
    cn-beijing-nu16-b01 = 'mts.aliyuncs.com',
    cn-chengdu = 'mts.aliyuncs.com',
    cn-edge-1 = 'mts.aliyuncs.com',
    cn-fujian = 'mts.aliyuncs.com',
    cn-haidian-cm12-c01 = 'mts.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'mts.aliyuncs.com',
    cn-hangzhou-finance = 'mts.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'mts.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'mts.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'mts.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'mts.aliyuncs.com',
    cn-hangzhou-test-306 = 'mts.aliyuncs.com',
    cn-hongkong-finance-pop = 'mts.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'mts.aliyuncs.com',
    cn-north-2-gov-1 = 'mts.aliyuncs.com',
    cn-qingdao-nebula = 'mts.aliyuncs.com',
    cn-shanghai-et15-b01 = 'mts.aliyuncs.com',
    cn-shanghai-et2-b01 = 'mts.aliyuncs.com',
    cn-shanghai-finance-1 = 'mts.aliyuncs.com',
    cn-shanghai-inner = 'mts.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'mts.aliyuncs.com',
    cn-shenzhen-finance-1 = 'mts.aliyuncs.com',
    cn-shenzhen-inner = 'mts.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'mts.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'mts.aliyuncs.com',
    cn-wuhan = 'mts.aliyuncs.com',
    cn-wulanchabu = 'mts.aliyuncs.com',
    cn-yushanfang = 'mts.aliyuncs.com',
    cn-zhangbei = 'mts.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'mts.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'mts.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'mts.aliyuncs.com',
    eu-west-1-oxs = 'mts.aliyuncs.com',
    me-east-1 = 'mts.aliyuncs.com',
    rus-west-1-pop = 'mts.aliyuncs.com',
    us-east-1 = 'mts.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model ActivateMediaWorkflowRequest {
  mediaWorkflowId: string(name='MediaWorkflowId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ActivateMediaWorkflowResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model ActivateMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: ActivateMediaWorkflowResponseBody(name='body'),
}

async function activateMediaWorkflow(request: ActivateMediaWorkflowRequest): ActivateMediaWorkflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ActivateMediaWorkflow', 'POST', '/', 'json', false, 'json', request);
}

model AddCensorPipelineRequest {
  name: string(name='Name', position='Query'),
  notifyConfig?: string(name='NotifyConfig', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  priority?: int32(name='Priority', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AddCensorPipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      queue?: string(name='Queue'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model AddCensorPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: AddCensorPipelineResponseBody(name='body'),
}

async function addCensorPipeline(request: AddCensorPipelineRequest): AddCensorPipelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddCensorPipeline', 'POST', '/', 'json', false, 'json', request);
}

model AddMediaRequest {
  cateId?: long(name='CateId', position='Query'),
  coverURL?: string(name='CoverURL', position='Query'),
  description?: string(name='Description', position='Query'),
  fileURL: string(name='FileURL', position='Query'),
  inputUnbind?: boolean(name='InputUnbind', position='Query'),
  mediaWorkflowId?: string(name='MediaWorkflowId', position='Query'),
  mediaWorkflowUserData?: string(name='MediaWorkflowUserData', position='Query'),
  overrideParams?: string(name='OverrideParams', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tags?: string(name='Tags', position='Query'),
  title?: string(name='Title', position='Query'),
}

model AddMediaResponseBody = {
  media?: {
    bitrate?: string(name='Bitrate'),
    cateId?: long(name='CateId'),
    censorState?: string(name='CensorState'),
    coverURL?: string(name='CoverURL'),
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    duration?: string(name='Duration'),
    file?: {
      state?: string(name='State'),
      URL?: string(name='URL'),
    }(name='File'),
    format?: string(name='Format'),
    fps?: string(name='Fps'),
    height?: string(name='Height'),
    mediaId?: string(name='MediaId'),
    publishState?: string(name='PublishState'),
    runIdList?: {
      runId?: [ string ](name='RunId')
    }(name='RunIdList'),
    size?: string(name='Size'),
    tags?: {
      tag?: [ string ](name='Tag')
    }(name='Tags'),
    title?: string(name='Title'),
    width?: string(name='Width'),
  }(name='Media'),
  requestId?: string(name='RequestId'),
}

model AddMediaResponse = {
  headers: map[string]string(name='headers'),
  body: AddMediaResponseBody(name='body'),
}

async function addMedia(request: AddMediaRequest): AddMediaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddMedia', 'POST', '/', 'json', false, 'json', request);
}

model AddMediaTagRequest {
  mediaId: string(name='MediaId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: string(name='Tag', position='Query'),
}

model AddMediaTagResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddMediaTagResponse = {
  headers: map[string]string(name='headers'),
  body: AddMediaTagResponseBody(name='body'),
}

async function addMediaTag(request: AddMediaTagRequest): AddMediaTagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddMediaTag', 'POST', '/', 'json', false, 'json', request);
}

model AddMediaWorkflowRequest {
  name: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  topology: string(name='Topology', position='Query'),
  triggerMode?: string(name='TriggerMode', position='Query'),
}

model AddMediaWorkflowResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
    triggerMode?: string(name='TriggerMode'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model AddMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: AddMediaWorkflowResponseBody(name='body'),
}

async function addMediaWorkflow(request: AddMediaWorkflowRequest): AddMediaWorkflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddMediaWorkflow', 'POST', '/', 'json', false, 'json', request);
}

model AddPipelineRequest {
  name: string(name='Name', position='Query'),
  notifyConfig?: string(name='NotifyConfig', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  role?: string(name='Role', position='Query'),
  speed?: string(name='Speed', position='Query'),
  speedLevel?: long(name='SpeedLevel', position='Query'),
}

model AddPipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      mqTag?: string(name='MqTag'),
      mqTopic?: string(name='MqTopic'),
      queueName?: string(name='QueueName'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    quotaAllocate?: long(name='QuotaAllocate'),
    role?: string(name='Role'),
    speed?: string(name='Speed'),
    speedLevel?: long(name='SpeedLevel'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model AddPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: AddPipelineResponseBody(name='body'),
}

async function addPipeline(request: AddPipelineRequest): AddPipelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddPipeline', 'POST', '/', 'json', false, 'json', request);
}

model AddSmarttagTemplateRequest {
  analyseTypes: string(name='AnalyseTypes', position='Query'),
  faceCategoryIds?: string(name='FaceCategoryIds', position='Query'),
  faceCustomParamsConfig?: string(name='FaceCustomParamsConfig', position='Query'),
  industry: string(name='Industry', position='Query'),
  isDefault?: boolean(name='IsDefault', position='Query'),
  keywordConfig?: string(name='KeywordConfig', position='Query'),
  knowledgeConfig?: string(name='KnowledgeConfig', position='Query'),
  labelType?: string(name='LabelType', position='Query'),
  labelVersion?: string(name='LabelVersion', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scene: string(name='Scene', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
}

model AddSmarttagTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model AddSmarttagTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddSmarttagTemplateResponseBody(name='body'),
}

async function addSmarttagTemplate(request: AddSmarttagTemplateRequest): AddSmarttagTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddSmarttagTemplate', 'POST', '/', 'json', false, 'json', request);
}

model AddTemplateRequest {
  audio?: string(name='Audio', position='Query'),
  container?: string(name='Container', position='Query'),
  muxConfig?: string(name='MuxConfig', position='Query'),
  name: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  transConfig?: string(name='TransConfig', position='Query'),
  video?: string(name='Video', position='Query'),
}

model AddTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    audio?: {
      bitrate?: string(name='Bitrate'),
      channels?: string(name='Channels'),
      codec?: string(name='Codec'),
      profile?: string(name='Profile'),
      qscale?: string(name='Qscale'),
      remove?: string(name='Remove'),
      samplerate?: string(name='Samplerate'),
      volume?: {
        level?: string(name='Level'),
        method?: string(name='Method'),
      }(name='Volume'),
    }(name='Audio'),
    container?: {
      format?: string(name='Format'),
    }(name='Container'),
    id?: string(name='Id'),
    muxConfig?: {
      gif?: {
        ditherMode?: string(name='DitherMode'),
        finalDelay?: string(name='FinalDelay'),
        isCustomPalette?: string(name='IsCustomPalette'),
        loop?: string(name='Loop'),
      }(name='Gif'),
      segment?: {
        duration?: string(name='Duration'),
      }(name='Segment'),
      webp?: {
        loop?: string(name='Loop'),
      }(name='Webp'),
    }(name='MuxConfig'),
    name?: string(name='Name'),
    state?: string(name='State'),
    transConfig?: {
      adjDarMethod?: string(name='AdjDarMethod'),
      isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
      isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
      isCheckReso?: string(name='IsCheckReso'),
      isCheckResoFail?: string(name='IsCheckResoFail'),
      isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
      isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
      transMode?: string(name='TransMode'),
    }(name='TransConfig'),
    video?: {
      bitrate?: string(name='Bitrate'),
      bitrateBnd?: {
        max?: string(name='Max'),
        min?: string(name='Min'),
      }(name='BitrateBnd'),
      bufsize?: string(name='Bufsize'),
      codec?: string(name='Codec'),
      crf?: string(name='Crf'),
      crop?: string(name='Crop'),
      degrain?: string(name='Degrain'),
      fps?: string(name='Fps'),
      gop?: string(name='Gop'),
      height?: string(name='Height'),
      longShortMode?: string(name='LongShortMode'),
      maxFps?: string(name='MaxFps'),
      maxrate?: string(name='Maxrate'),
      pad?: string(name='Pad'),
      pixFmt?: string(name='PixFmt'),
      preset?: string(name='Preset'),
      profile?: string(name='Profile'),
      qscale?: string(name='Qscale'),
      remove?: string(name='Remove'),
      resoPriority?: string(name='ResoPriority'),
      scanMode?: string(name='ScanMode'),
      width?: string(name='Width'),
    }(name='Video'),
  }(name='Template'),
}

model AddTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddTemplateResponseBody(name='body'),
}

async function addTemplate(request: AddTemplateRequest): AddTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddTemplate', 'POST', '/', 'json', false, 'json', request);
}

model AddWaterMarkTemplateRequest {
  config: string(name='Config', position='Query'),
  name: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AddWaterMarkTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  waterMarkTemplate?: {
    dx?: string(name='Dx'),
    dy?: string(name='Dy'),
    height?: string(name='Height'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    ratioRefer?: {
      dx?: string(name='Dx'),
      dy?: string(name='Dy'),
      height?: string(name='Height'),
      width?: string(name='Width'),
    }(name='RatioRefer'),
    referPos?: string(name='ReferPos'),
    state?: string(name='State'),
    timeline?: {
      duration?: string(name='Duration'),
      start?: string(name='Start'),
    }(name='Timeline'),
    type?: string(name='Type'),
    width?: string(name='Width'),
  }(name='WaterMarkTemplate'),
}

model AddWaterMarkTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddWaterMarkTemplateResponseBody(name='body'),
}

async function addWaterMarkTemplate(request: AddWaterMarkTemplateRequest): AddWaterMarkTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddWaterMarkTemplate', 'POST', '/', 'json', false, 'json', request);
}

model BindInputBucketRequest {
  bucket: string(name='Bucket', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  referer?: string(name='Referer', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleArn?: string(name='RoleArn', position='Query'),
}

model BindInputBucketResponseBody = {
  requestId?: string(name='RequestId'),
}

model BindInputBucketResponse = {
  headers: map[string]string(name='headers'),
  body: BindInputBucketResponseBody(name='body'),
}

async function bindInputBucket(request: BindInputBucketRequest): BindInputBucketResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BindInputBucket', 'POST', '/', 'json', false, 'json', request);
}

model BindOutputBucketRequest {
  bucket: string(name='Bucket', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleArn?: string(name='RoleArn', position='Query'),
}

model BindOutputBucketResponseBody = {
  requestId?: string(name='RequestId'),
}

model BindOutputBucketResponse = {
  headers: map[string]string(name='headers'),
  body: BindOutputBucketResponseBody(name='body'),
}

async function bindOutputBucket(request: BindOutputBucketRequest): BindOutputBucketResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BindOutputBucket', 'POST', '/', 'json', false, 'json', request);
}

model CancelJobRequest {
  jobId: string(name='JobId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CancelJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model CancelJobResponse = {
  headers: map[string]string(name='headers'),
  body: CancelJobResponseBody(name='body'),
}

async function cancelJob(request: CancelJobRequest): CancelJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelJob', 'POST', '/', 'json', false, 'json', request);
}

model CategoryTreeRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CategoryTreeResponseBody = {
  categoryTree?: string(name='CategoryTree'),
  requestId?: string(name='RequestId'),
}

model CategoryTreeResponse = {
  headers: map[string]string(name='headers'),
  body: CategoryTreeResponseBody(name='body'),
}

async function categoryTree(request: CategoryTreeRequest): CategoryTreeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CategoryTree', 'POST', '/', 'json', false, 'json', request);
}

model CreateFpShotDBRequest {
  config?: string(name='Config', position='Query'),
  description?: string(name='Description', position='Query'),
  modelId?: int32(name='ModelId', position='Query'),
  name: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateFpShotDBResponseBody = {
  fpShotDB?: {
    config?: string(name='Config'),
    description?: string(name='Description'),
    fpDBId?: string(name='FpDBId'),
    modelId?: int32(name='ModelId'),
    name?: string(name='Name'),
    state?: string(name='State'),
  }(name='FpShotDB'),
  requestId?: string(name='RequestId'),
}

model CreateFpShotDBResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFpShotDBResponseBody(name='body'),
}

async function createFpShotDB(request: CreateFpShotDBRequest): CreateFpShotDBResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFpShotDB', 'POST', '/', 'json', false, 'json', request);
}

model DeactivateMediaWorkflowRequest {
  mediaWorkflowId: string(name='MediaWorkflowId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeactivateMediaWorkflowResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model DeactivateMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: DeactivateMediaWorkflowResponseBody(name='body'),
}

async function deactivateMediaWorkflow(request: DeactivateMediaWorkflowRequest): DeactivateMediaWorkflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeactivateMediaWorkflow', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCategoryRequest {
  cateId: long(name='CateId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteCategoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCategoryResponseBody(name='body'),
}

async function deleteCategory(request: DeleteCategoryRequest): DeleteCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCategory', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMediaRequest {
  mediaIds: string(name='MediaIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteMediaResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMediaResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMediaResponseBody(name='body'),
}

async function deleteMedia(request: DeleteMediaRequest): DeleteMediaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMedia', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMediaTagRequest {
  mediaId: string(name='MediaId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: string(name='Tag', position='Query'),
}

model DeleteMediaTagResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMediaTagResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMediaTagResponseBody(name='body'),
}

async function deleteMediaTag(request: DeleteMediaTagRequest): DeleteMediaTagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMediaTag', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMediaWorkflowRequest {
  mediaWorkflowId: string(name='MediaWorkflowId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteMediaWorkflowResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model DeleteMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMediaWorkflowResponseBody(name='body'),
}

async function deleteMediaWorkflow(request: DeleteMediaWorkflowRequest): DeleteMediaWorkflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMediaWorkflow', 'POST', '/', 'json', false, 'json', request);
}

model DeletePipelineRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeletePipelineResponseBody = {
  pipelineId?: string(name='PipelineId'),
  requestId?: string(name='RequestId'),
}

model DeletePipelineResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePipelineResponseBody(name='body'),
}

async function deletePipeline(request: DeletePipelineRequest): DeletePipelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePipeline', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSmarttagTemplateRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  templateId: string(name='TemplateId', position='Query'),
}

model DeleteSmarttagTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSmarttagTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSmarttagTemplateResponseBody(name='body'),
}

async function deleteSmarttagTemplate(request: DeleteSmarttagTemplateRequest): DeleteSmarttagTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSmarttagTemplate', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTemplateRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  templateId: string(name='TemplateId', position='Query'),
}

model DeleteTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model DeleteTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTemplateResponseBody(name='body'),
}

async function deleteTemplate(request: DeleteTemplateRequest): DeleteTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTemplate', 'POST', '/', 'json', false, 'json', request);
}

model DeleteWaterMarkTemplateRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  waterMarkTemplateId: string(name='WaterMarkTemplateId', position='Query'),
}

model DeleteWaterMarkTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
}

model DeleteWaterMarkTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteWaterMarkTemplateResponseBody(name='body'),
}

async function deleteWaterMarkTemplate(request: DeleteWaterMarkTemplateRequest): DeleteWaterMarkTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWaterMarkTemplate', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMtsUserResourcePackageRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeMtsUserResourcePackageResponseBody = {
  requestId?: string(name='RequestId'),
  resourcePackageInfos?: {
    resourcePackageInfo?: [ 
    {
      commodityCode?: string(name='CommodityCode'),
      currCapacity?: string(name='CurrCapacity'),
      displayName?: string(name='DisplayName'),
      initCapacity?: string(name='InitCapacity'),
      instanceId?: string(name='InstanceId'),
      status?: string(name='Status'),
    }
  ](name='ResourcePackageInfo')
  }(name='ResourcePackageInfos'),
}

model DescribeMtsUserResourcePackageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMtsUserResourcePackageResponseBody(name='body'),
}

async function describeMtsUserResourcePackage(request: DescribeMtsUserResourcePackageRequest): DescribeMtsUserResourcePackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMtsUserResourcePackage', 'POST', '/', 'json', false, 'json', request);
}

model DetectImageSyncRequest {
  image?: string(name='Image', description='图片url链接', position='Query'),
}

model DetectImageSyncResponseBody = {
  message?: string(name='Message', description='返回信息'),
  requestId?: string(name='RequestId', description='Id of the request'),
  result?: string(name='Result', description='返回结果'),
  status?: string(name='Status', description='请求状态'),
}

model DetectImageSyncResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageSyncResponseBody(name='body'),
}

async function detectImageSync(request: DetectImageSyncRequest): DetectImageSyncResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetectImageSync', 'POST', '/', 'json', false, 'json', request);
}

model GetJobInfoRequest {
  regionId?: string(name='RegionId', position='Host'),
  jobId?: string(name='jobId', position='Query'),
}

model GetJobInfoResponseBody = {
  mtsTransferJob?: {
    createTime?: string(name='CreateTime'),
    errorCode?: string(name='ErrorCode'),
    errorMessage?: string(name='ErrorMessage'),
    extend?: string(name='Extend'),
    finishedTime?: string(name='FinishedTime'),
    jobId?: string(name='JobId'),
    jobType?: string(name='JobType'),
    modifiedTime?: string(name='ModifiedTime'),
    requestJson?: string(name='RequestJson'),
    state?: string(name='State'),
    userData?: string(name='UserData'),
  }(name='MtsTransferJob'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetJobInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobInfoResponseBody(name='body'),
}

async function getJobInfo(request: GetJobInfoRequest): GetJobInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetJobInfo', 'GET', '/', 'json', false, 'json', request);
}

model ImAuditRequest {
  bizType?: string(name='BizType', position='Query'),
  contents?: string(name='Contents', position='Query'),
  images?: string(name='Images', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scenes: string(name='Scenes', position='Query'),
}

model ImAuditResponseBody = {
  imageQuotaExceed?: boolean(name='ImageQuotaExceed'),
  imageResults?: {
    result?: [ 
      {
        code?: long(name='code'),
        dataId?: string(name='dataId'),
        extras?: map[string]any(name='extras'),
        msg?: string(name='msg'),
        results?: [ 
          {
            label?: string(name='Label'),
            rate?: double(name='Rate'),
            scene?: string(name='Scene'),
            suggestion?: string(name='Suggestion'),
          }
        ](name='results'),
        taskId?: string(name='taskId'),
        url?: string(name='url'),
      }
    ](name='result'),
  }(name='ImageResults'),
  requestId?: string(name='RequestId'),
  textQuotaExceed?: boolean(name='TextQuotaExceed'),
  textResults?: {
    result?: [ 
      {
        code?: long(name='code'),
        content?: string(name='content'),
        dataId?: string(name='dataId'),
        msg?: string(name='msg'),
        results?: [ 
          {
            details?: [ 
              {
                label?: string(name='Label'),
              }
            ](name='details'),
            label?: string(name='label'),
            rate?: double(name='rate'),
            scene?: string(name='scene'),
            suggestion?: string(name='suggestion'),
          }
        ](name='results'),
        taskId?: string(name='taskId'),
      }
    ](name='result'),
  }(name='TextResults'),
}

model ImAuditResponse = {
  headers: map[string]string(name='headers'),
  body: ImAuditResponseBody(name='body'),
}

async function imAudit(request: ImAuditRequest): ImAuditResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImAudit', 'POST', '/', 'json', false, 'json', request);
}

model ImportFpShotJobRequest {
  fpDBId?: string(name='FpDBId', position='Query'),
  fpImportConfig?: string(name='FpImportConfig', position='Query'),
  input: string(name='Input', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId?: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model ImportFpShotJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ImportFpShotJobResponse = {
  headers: map[string]string(name='headers'),
  body: ImportFpShotJobResponseBody(name='body'),
}

async function importFpShotJob(request: ImportFpShotJobRequest): ImportFpShotJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportFpShotJob', 'POST', '/', 'json', false, 'json', request);
}

model ListAllCategoryRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListAllCategoryResponseBody = {
  categoryList?: {
    category?: [ 
    {
      cateId?: string(name='CateId'),
      cateName?: string(name='CateName'),
      level?: string(name='Level'),
      parentId?: string(name='ParentId'),
    }
  ](name='Category')
  }(name='CategoryList'),
  requestId?: string(name='RequestId'),
}

model ListAllCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: ListAllCategoryResponseBody(name='body'),
}

async function listAllCategory(request: ListAllCategoryRequest): ListAllCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAllCategory', 'POST', '/', 'json', false, 'json', request);
}

model ListAllMediaBucketRequest {
  maximumPageSize?: int32(name='MaximumPageSize', position='Query'),
  nextPageToken?: string(name='NextPageToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListAllMediaBucketResponseBody = {
  mediaBucketList?: {
    mediaBucket?: [ 
    {
      bucket?: string(name='Bucket'),
      referer?: string(name='Referer'),
      type?: string(name='Type'),
    }
  ](name='MediaBucket')
  }(name='MediaBucketList'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListAllMediaBucketResponse = {
  headers: map[string]string(name='headers'),
  body: ListAllMediaBucketResponseBody(name='body'),
}

async function listAllMediaBucket(request: ListAllMediaBucketRequest): ListAllMediaBucketResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAllMediaBucket', 'POST', '/', 'json', false, 'json', request);
}

model ListCensorPipelineRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  state?: string(name='State', position='Query'),
}

model ListCensorPipelineResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  pipelineList?: {
    pipeline?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      notifyConfig?: {
        queue?: string(name='Queue'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      state?: string(name='State'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListCensorPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: ListCensorPipelineResponseBody(name='body'),
}

async function listCensorPipeline(request: ListCensorPipelineRequest): ListCensorPipelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCensorPipeline', 'POST', '/', 'json', false, 'json', request);
}

model ListCustomPersonsRequest {
  categoryId?: string(name='CategoryId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  personId?: string(name='PersonId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListCustomPersonsResponseBody = {
  categories?: {
    category?: [ 
    {
      categoryDescription?: string(name='CategoryDescription'),
      categoryId?: string(name='CategoryId'),
      categoryName?: string(name='CategoryName'),
      persons?: {
        person?: [ 
        {
          faces?: {
            face?: [ 
            {
              faceId?: string(name='FaceId'),
              imageUrl?: string(name='ImageUrl'),
            }
          ](name='Face')
          }(name='Faces'),
          personDescription?: string(name='PersonDescription'),
          personId?: string(name='PersonId'),
          personName?: string(name='PersonName'),
        }
      ](name='Person')
      }(name='Persons'),
    }
  ](name='Category')
  }(name='Categories'),
  requestId?: string(name='RequestId'),
}

model ListCustomPersonsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCustomPersonsResponseBody(name='body'),
}

async function listCustomPersons(request: ListCustomPersonsRequest): ListCustomPersonsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCustomPersons', 'POST', '/', 'json', false, 'json', request);
}

model ListFpShotDBRequest {
  fpDBIds?: string(name='FpDBIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListFpShotDBResponseBody = {
  fpShotDBList?: {
    fpShotDB?: [ 
    {
      description?: string(name='Description'),
      fpDBId?: string(name='FpDBId'),
      modelId?: int32(name='ModelId'),
      name?: string(name='Name'),
      status?: string(name='Status'),
    }
  ](name='FpShotDB')
  }(name='FpShotDBList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model ListFpShotDBResponse = {
  headers: map[string]string(name='headers'),
  body: ListFpShotDBResponseBody(name='body'),
}

async function listFpShotDB(request: ListFpShotDBRequest): ListFpShotDBResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFpShotDB', 'POST', '/', 'json', false, 'json', request);
}

model ListFpShotFilesRequest {
  fpDBId: string(name='FpDBId', position='Query'),
  nextPageToken?: string(name='NextPageToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListFpShotFilesResponseBody = {
  fpShotFileList?: {
    fpShotFile?: [ 
    {
      fileId?: string(name='FileId'),
      inputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='InputFile'),
      primaryKey?: string(name='PrimaryKey'),
    }
  ](name='FpShotFile')
  }(name='FpShotFileList'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListFpShotFilesResponse = {
  headers: map[string]string(name='headers'),
  body: ListFpShotFilesResponseBody(name='body'),
}

async function listFpShotFiles(request: ListFpShotFilesRequest): ListFpShotFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFpShotFiles', 'POST', '/', 'json', false, 'json', request);
}

model ListJobRequest {
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange', position='Query'),
  maximumPageSize?: long(name='MaximumPageSize', minimum=1, maximum=100, position='Query'),
  nextPageToken?: string(name='NextPageToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId?: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange', position='Query'),
  state?: string(name='State', position='Query'),
}

model ListJobResponseBody = {
  jobList?: {
    job?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      output?: {
        audio?: {
          bitrate?: string(name='Bitrate'),
          channels?: string(name='Channels'),
          codec?: string(name='Codec'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          samplerate?: string(name='Samplerate'),
          volume?: {
            level?: string(name='Level'),
            method?: string(name='Method'),
          }(name='Volume'),
        }(name='Audio'),
        audioStreamMap?: string(name='AudioStreamMap'),
        clip?: {
          timeSpan?: {
            duration?: string(name='Duration'),
            seek?: string(name='Seek'),
          }(name='TimeSpan'),
        }(name='Clip'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        deWatermark?: string(name='DeWatermark'),
        encryption?: {
          id?: string(name='Id'),
          key?: string(name='Key'),
          keyType?: string(name='KeyType'),
          keyUri?: string(name='KeyUri'),
          skipCnt?: string(name='SkipCnt'),
          type?: string(name='Type'),
        }(name='Encryption'),
        m3U8NonStandardSupport?: {
          TS?: {
            md5Support?: boolean(name='Md5Support'),
            sizeSupport?: boolean(name='SizeSupport'),
          }(name='TS'),
        }(name='M3U8NonStandardSupport'),
        mergeConfigUrl?: string(name='MergeConfigUrl'),
        mergeList?: {
          merge?: [ 
          {
            duration?: string(name='Duration'),
            mergeURL?: string(name='MergeURL'),
            roleArn?: string(name='RoleArn'),
            start?: string(name='Start'),
          }
        ](name='Merge')
        }(name='MergeList'),
        muxConfig?: {
          gif?: {
            ditherMode?: string(name='DitherMode'),
            finalDelay?: string(name='FinalDelay'),
            isCustomPalette?: string(name='IsCustomPalette'),
            loop?: string(name='Loop'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
          webp?: {
            loop?: string(name='Loop'),
          }(name='Webp'),
        }(name='MuxConfig'),
        openingList?: {
          opening?: [ 
          {
            height?: string(name='Height'),
            start?: string(name='Start'),
            width?: string(name='Width'),
            openUrl?: string(name='openUrl'),
          }
        ](name='Opening')
        }(name='OpeningList'),
        outSubtitleList?: {
          outSubtitle?: [ 
          {
            map?: string(name='Map'),
            message?: string(name='Message'),
            outSubtitleFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
              roleArn?: string(name='RoleArn'),
            }(name='OutSubtitleFile'),
            success?: boolean(name='Success'),
          }
        ](name='OutSubtitle')
        }(name='OutSubtitleList'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='OutputFile'),
        priority?: string(name='Priority'),
        properties?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          fileFormat?: string(name='FileFormat'),
          fileSize?: string(name='FileSize'),
          format?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            formatLongName?: string(name='FormatLongName'),
            formatName?: string(name='FormatName'),
            numPrograms?: string(name='NumPrograms'),
            numStreams?: string(name='NumStreams'),
            size?: string(name='Size'),
            startTime?: string(name='StartTime'),
          }(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          streams?: {
            audioStreamList?: {
              audioStream?: [ 
              {
                bitrate?: string(name='Bitrate'),
                channelLayout?: string(name='ChannelLayout'),
                channels?: string(name='Channels'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                duration?: string(name='Duration'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                numFrames?: string(name='NumFrames'),
                sampleFmt?: string(name='SampleFmt'),
                samplerate?: string(name='Samplerate'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
              }
            ](name='AudioStream')
            }(name='AudioStreamList'),
            subtitleStreamList?: {
              subtitleStream?: [ 
              {
                index?: string(name='Index'),
                lang?: string(name='Lang'),
              }
            ](name='SubtitleStream')
            }(name='SubtitleStreamList'),
            videoStreamList?: {
              videoStream?: [ 
              {
                avgFPS?: string(name='AvgFPS'),
                bitrate?: string(name='Bitrate'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                dar?: string(name='Dar'),
                duration?: string(name='Duration'),
                fps?: string(name='Fps'),
                hasBFrames?: string(name='HasBFrames'),
                height?: string(name='Height'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                level?: string(name='Level'),
                networkCost?: {
                  avgBitrate?: string(name='AvgBitrate'),
                  costBandwidth?: string(name='CostBandwidth'),
                  preloadTime?: string(name='PreloadTime'),
                }(name='NetworkCost'),
                numFrames?: string(name='NumFrames'),
                pixFmt?: string(name='PixFmt'),
                profile?: string(name='Profile'),
                sar?: string(name='Sar'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
                width?: string(name='Width'),
              }
            ](name='VideoStream')
            }(name='VideoStreamList'),
          }(name='Streams'),
          width?: string(name='Width'),
        }(name='Properties'),
        rotate?: string(name='Rotate'),
        subtitleConfig?: {
          extSubtitleList?: {
            extSubtitle?: [ 
            {
              charEnc?: string(name='CharEnc'),
              fontName?: string(name='FontName'),
              input?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='Input'),
            }
          ](name='ExtSubtitle')
          }(name='ExtSubtitleList'),
          subtitleList?: {
            subtitle?: [ 
            {
              map?: string(name='Map'),
            }
          ](name='Subtitle')
          }(name='SubtitleList'),
        }(name='SubtitleConfig'),
        superReso?: {
          isHalfSample?: string(name='IsHalfSample'),
        }(name='SuperReso'),
        tailSlateList?: {
          tailSlate?: [ 
          {
            bgColor?: string(name='BgColor'),
            blendDuration?: string(name='BlendDuration'),
            height?: string(name='Height'),
            isMergeAudio?: boolean(name='IsMergeAudio'),
            start?: string(name='Start'),
            tailUrl?: string(name='TailUrl'),
            width?: string(name='Width'),
          }
        ](name='TailSlate')
        }(name='TailSlateList'),
        templateId?: string(name='TemplateId'),
        transConfig?: {
          adjDarMethod?: string(name='AdjDarMethod'),
          isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
          isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
          isCheckReso?: string(name='IsCheckReso'),
          isCheckResoFail?: string(name='IsCheckResoFail'),
          isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
          isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
          transMode?: string(name='TransMode'),
        }(name='TransConfig'),
        userData?: string(name='UserData'),
        video?: {
          bitrate?: string(name='Bitrate'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          bufsize?: string(name='Bufsize'),
          codec?: string(name='Codec'),
          crf?: string(name='Crf'),
          crop?: string(name='Crop'),
          degrain?: string(name='Degrain'),
          fps?: string(name='Fps'),
          gop?: string(name='Gop'),
          height?: string(name='Height'),
          maxFps?: string(name='MaxFps'),
          maxrate?: string(name='Maxrate'),
          pad?: string(name='Pad'),
          pixFmt?: string(name='PixFmt'),
          preset?: string(name='Preset'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          resoPriority?: string(name='ResoPriority'),
          scanMode?: string(name='ScanMode'),
          width?: string(name='Width'),
        }(name='Video'),
        videoStreamMap?: string(name='VideoStreamMap'),
        waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
        waterMarkList?: {
          waterMark?: [ 
          {
            dx?: string(name='Dx'),
            dy?: string(name='Dy'),
            height?: string(name='Height'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
            referPos?: string(name='ReferPos'),
            type?: string(name='Type'),
            waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
            width?: string(name='Width'),
          }
        ](name='WaterMark')
        }(name='WaterMarkList'),
      }(name='Output'),
      percent?: long(name='Percent'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
    }
  ](name='Job')
  }(name='JobList'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListJobResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobResponseBody(name='body'),
}

async function listJob(request: ListJobRequest): ListJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListJob', 'POST', '/', 'json', false, 'json', request);
}

model ListMediaRequest {
  from?: string(name='From', position='Query'),
  maximumPageSize?: long(name='MaximumPageSize', minimum=1, maximum=100, position='Query'),
  nextPageToken?: string(name='NextPageToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  to?: string(name='To', position='Query'),
}

model ListMediaResponseBody = {
  mediaList?: {
    media?: [ 
    {
      bitrate?: string(name='Bitrate'),
      cateId?: long(name='CateId'),
      censorState?: string(name='CensorState'),
      coverURL?: string(name='CoverURL'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      duration?: string(name='Duration'),
      file?: {
        state?: string(name='State'),
        URL?: string(name='URL'),
      }(name='File'),
      format?: string(name='Format'),
      fps?: string(name='Fps'),
      height?: string(name='Height'),
      mediaId?: string(name='MediaId'),
      publishState?: string(name='PublishState'),
      runIdList?: {
        runId?: [ string ](name='RunId')
      }(name='RunIdList'),
      size?: string(name='Size'),
      tags?: {
        tag?: [ string ](name='Tag')
      }(name='Tags'),
      title?: string(name='Title'),
      width?: string(name='Width'),
    }
  ](name='Media')
  }(name='MediaList'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListMediaResponse = {
  headers: map[string]string(name='headers'),
  body: ListMediaResponseBody(name='body'),
}

async function listMedia(request: ListMediaRequest): ListMediaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMedia', 'POST', '/', 'json', false, 'json', request);
}

model ListMediaWorkflowExecutionsRequest {
  inputFileURL?: string(name='InputFileURL', position='Query'),
  maximumPageSize?: long(name='MaximumPageSize', minimum=1, maximum=100, position='Query'),
  mediaWorkflowId?: string(name='MediaWorkflowId', position='Query'),
  mediaWorkflowName?: string(name='MediaWorkflowName', position='Query'),
  nextPageToken?: string(name='NextPageToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListMediaWorkflowExecutionsResponseBody = {
  mediaWorkflowExecutionList?: {
    mediaWorkflowExecution?: [ 
    {
      activityList?: {
        activity?: [ 
        {
          code?: string(name='Code'),
          endTime?: string(name='EndTime'),
          jobId?: string(name='JobId'),
          MNSMessageResult?: {
            errorCode?: string(name='ErrorCode'),
            errorMessage?: string(name='ErrorMessage'),
            messageId?: string(name='MessageId'),
          }(name='MNSMessageResult'),
          message?: string(name='Message'),
          name?: string(name='Name'),
          startTime?: string(name='StartTime'),
          state?: string(name='State'),
          type?: string(name='Type'),
        }
      ](name='Activity')
      }(name='ActivityList'),
      creationTime?: string(name='CreationTime'),
      input?: {
        inputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='InputFile'),
        userData?: string(name='UserData'),
      }(name='Input'),
      mediaId?: string(name='MediaId'),
      mediaWorkflowId?: string(name='MediaWorkflowId'),
      name?: string(name='Name'),
      runId?: string(name='RunId'),
      state?: string(name='State'),
    }
  ](name='MediaWorkflowExecution')
  }(name='MediaWorkflowExecutionList'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListMediaWorkflowExecutionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListMediaWorkflowExecutionsResponseBody(name='body'),
}

async function listMediaWorkflowExecutions(request: ListMediaWorkflowExecutionsRequest): ListMediaWorkflowExecutionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMediaWorkflowExecutions', 'POST', '/', 'json', false, 'json', request);
}

model LogicalDeleteResourceRequest {
  bid: string(name='Bid', position='Query'),
  country: string(name='Country', position='Query'),
  gmtWakeup: string(name='GmtWakeup', position='Query'),
  hid: long(name='Hid', position='Query'),
  interrupt?: boolean(name='Interrupt', position='Query'),
  invoker: string(name='Invoker', position='Query'),
  message?: string(name='Message', position='Query'),
  pk: string(name='Pk', position='Query'),
  success?: boolean(name='Success', position='Query'),
  taskExtraData: string(name='TaskExtraData', position='Query'),
  taskIdentifier: string(name='TaskIdentifier', position='Query'),
}

model LogicalDeleteResourceResponseBody = {
  bid?: string(name='Bid'),
  country?: string(name='Country'),
  gmtWakeup?: string(name='GmtWakeup'),
  hid?: long(name='Hid'),
  interrupt?: boolean(name='Interrupt'),
  invoker?: string(name='Invoker'),
  message?: string(name='Message'),
  pk?: string(name='Pk'),
  success?: boolean(name='Success'),
  taskExtraData?: string(name='TaskExtraData'),
  taskIdentifier?: string(name='TaskIdentifier'),
}

model LogicalDeleteResourceResponse = {
  headers: map[string]string(name='headers'),
  body: LogicalDeleteResourceResponseBody(name='body'),
}

async function logicalDeleteResource(request: LogicalDeleteResourceRequest): LogicalDeleteResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'LogicalDeleteResource', 'POST', '/', 'json', false, 'json', request);
}

model PhysicalDeleteResourceRequest {
  bid: string(name='Bid', position='Query'),
  country: string(name='Country', position='Query'),
  gmtWakeup: string(name='GmtWakeup', position='Query'),
  hid: long(name='Hid', position='Query'),
  interrupt?: boolean(name='Interrupt', position='Query'),
  invoker: string(name='Invoker', position='Query'),
  message?: string(name='Message', position='Query'),
  pk: string(name='Pk', position='Query'),
  success?: boolean(name='Success', position='Query'),
  taskExtraData: string(name='TaskExtraData', position='Query'),
  taskIdentifier: string(name='TaskIdentifier', position='Query'),
}

model PhysicalDeleteResourceResponseBody = {
  bid?: string(name='Bid'),
  country?: string(name='Country'),
  gmtWakeup?: string(name='GmtWakeup'),
  hid?: long(name='Hid'),
  interrupt?: boolean(name='Interrupt'),
  invoker?: string(name='Invoker'),
  message?: string(name='Message'),
  pk?: string(name='Pk'),
  success?: boolean(name='Success'),
  taskExtraData?: string(name='TaskExtraData'),
  taskIdentifier?: string(name='TaskIdentifier'),
}

model PhysicalDeleteResourceResponse = {
  headers: map[string]string(name='headers'),
  body: PhysicalDeleteResourceResponseBody(name='body'),
}

async function physicalDeleteResource(request: PhysicalDeleteResourceRequest): PhysicalDeleteResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PhysicalDeleteResource', 'POST', '/', 'json', false, 'json', request);
}

model PlayInfoRequest {
  authInfo: string(name='AuthInfo', position='Query'),
  authTimeout?: long(name='AuthTimeout', position='Query'),
  formats: string(name='Formats', position='Query'),
  hlsUriToken?: string(name='HlsUriToken', position='Query'),
  mediaId: string(name='MediaId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  playDomain?: string(name='PlayDomain', position='Query'),
  rand?: string(name='Rand', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
  terminal?: string(name='Terminal', position='Query'),
}

model PlayInfoResponseBody = {
  notFoundCDNDomain?: {
    string?: [ string ](name='String')
  }(name='NotFoundCDNDomain'),
  playInfoList?: {
    playInfo?: [ 
    {
      url?: string(name='Url'),
      activityName?: string(name='activityName'),
      bitrate?: string(name='bitrate'),
      complexity?: string(name='complexity'),
      definition?: string(name='definition'),
      downloadType?: string(name='downloadType'),
      duration?: string(name='duration'),
      encryption?: string(name='encryption'),
      encryptionType?: string(name='encryptionType'),
      format?: string(name='format'),
      fps?: string(name='fps'),
      height?: string(name='height'),
      plaintext?: string(name='plaintext'),
      rand?: string(name='rand'),
      size?: string(name='size'),
      width?: string(name='width'),
    }
  ](name='PlayInfo')
  }(name='PlayInfoList'),
  requestId?: string(name='RequestId'),
}

model PlayInfoResponse = {
  headers: map[string]string(name='headers'),
  body: PlayInfoResponseBody(name='body'),
}

async function playInfo(request: PlayInfoRequest): PlayInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PlayInfo', 'POST', '/', 'json', false, 'json', request);
}

model PlayerAuthRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model PlayerAuthResponseBody = {
  logURL?: string(name='LogURL'),
  requestId?: string(name='RequestId'),
  switchList?: {
    switch?: [ 
    {
      functionId?: string(name='FunctionId'),
      functionName?: string(name='FunctionName'),
      state?: string(name='State'),
      switchId?: string(name='SwitchId'),
    }
  ](name='Switch')
  }(name='SwitchList'),
}

model PlayerAuthResponse = {
  headers: map[string]string(name='headers'),
  body: PlayerAuthResponseBody(name='body'),
}

async function playerAuth(request: PlayerAuthRequest): PlayerAuthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PlayerAuth', 'POST', '/', 'json', false, 'json', request);
}

model QueryAnalysisJobListRequest {
  analysisJobIds: string(name='AnalysisJobIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryAnalysisJobListResponseBody = {
  analysisJobList?: {
    analysisJob?: [ 
    {
      analysisConfig?: {
        propertiesControl?: {
          crop?: {
            height?: string(name='Height'),
            left?: string(name='Left'),
            mode?: string(name='Mode'),
            top?: string(name='Top'),
            width?: string(name='Width'),
          }(name='Crop'),
          deinterlace?: string(name='Deinterlace'),
        }(name='PropertiesControl'),
        qualityControl?: {
          methodStreaming?: string(name='MethodStreaming'),
          rateQuality?: string(name='RateQuality'),
        }(name='QualityControl'),
      }(name='AnalysisConfig'),
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      inputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='InputFile'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      percent?: long(name='Percent'),
      pipelineId?: string(name='PipelineId'),
      priority?: string(name='Priority'),
      state?: string(name='State'),
      templateList?: {
        template?: [ 
        {
          audio?: {
            bitrate?: string(name='Bitrate'),
            channels?: string(name='Channels'),
            codec?: string(name='Codec'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            samplerate?: string(name='Samplerate'),
          }(name='Audio'),
          container?: {
            format?: string(name='Format'),
          }(name='Container'),
          id?: string(name='Id'),
          muxConfig?: {
            gif?: {
              finalDelay?: string(name='FinalDelay'),
              loop?: string(name='Loop'),
            }(name='Gif'),
            segment?: {
              duration?: string(name='Duration'),
            }(name='Segment'),
          }(name='MuxConfig'),
          name?: string(name='Name'),
          state?: string(name='State'),
          transConfig?: {
            transMode?: string(name='TransMode'),
          }(name='TransConfig'),
          video?: {
            bitrate?: string(name='Bitrate'),
            bitrateBnd?: {
              max?: string(name='Max'),
              min?: string(name='Min'),
            }(name='BitrateBnd'),
            bufsize?: string(name='Bufsize'),
            codec?: string(name='Codec'),
            crf?: string(name='Crf'),
            degrain?: string(name='Degrain'),
            fps?: string(name='Fps'),
            gop?: string(name='Gop'),
            height?: string(name='Height'),
            maxrate?: string(name='Maxrate'),
            pixFmt?: string(name='PixFmt'),
            preset?: string(name='Preset'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            scanMode?: string(name='ScanMode'),
            width?: string(name='Width'),
          }(name='Video'),
        }
      ](name='Template')
      }(name='TemplateList'),
      userData?: string(name='UserData'),
    }
  ](name='AnalysisJob')
  }(name='AnalysisJobList'),
  nonExistAnalysisJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistAnalysisJobIds'),
  requestId?: string(name='RequestId'),
}

model QueryAnalysisJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAnalysisJobListResponseBody(name='body'),
}

async function queryAnalysisJobList(request: QueryAnalysisJobListRequest): QueryAnalysisJobListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryAnalysisJobList', 'POST', '/', 'json', false, 'json', request);
}

model QueryAuthConfigRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model QueryAuthConfigResponseBody = {
  key1?: string(name='Key1'),
  key2?: string(name='Key2'),
  requestId?: string(name='RequestId'),
}

model QueryAuthConfigResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAuthConfigResponseBody(name='body'),
}

async function queryAuthConfig(request: QueryAuthConfigRequest): QueryAuthConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryAuthConfig', 'POST', '/', 'json', false, 'json', request);
}

model QueryCensorJobListRequest {
  jobIds: string(name='JobIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryCensorJobListResponseBody = {
  censorJobList?: {
    censorJob?: [ 
    {
      barrageCensorResult?: string(name='BarrageCensorResult'),
      censorConfig?: {
        bizType?: string(name='BizType'),
        interval?: string(name='Interval'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='OutputFile'),
        saveType?: string(name='SaveType'),
        scenes?: string(name='Scenes'),
      }(name='CensorConfig'),
      censorPornResult?: {
        averageScore?: string(name='AverageScore'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
        pornCounterList?: {
          counter?: [ 
          {
            count?: int32(name='Count'),
            label?: string(name='Label'),
          }
        ](name='Counter')
        }(name='PornCounterList'),
        pornTopList?: {
          top?: [ 
          {
            index?: string(name='Index'),
            label?: string(name='Label'),
            object?: string(name='Object'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
          }
        ](name='Top')
        }(name='PornTopList'),
        suggestion?: string(name='Suggestion'),
      }(name='CensorPornResult'),
      censorTerrorismResult?: {
        averageScore?: string(name='AverageScore'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
        suggestion?: string(name='Suggestion'),
        terrorismCounterList?: {
          counter?: [ 
          {
            count?: int32(name='Count'),
            label?: string(name='Label'),
          }
        ](name='Counter')
        }(name='TerrorismCounterList'),
        terrorismTopList?: {
          top?: [ 
          {
            index?: string(name='Index'),
            label?: string(name='Label'),
            object?: string(name='Object'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
          }
        ](name='Top')
        }(name='TerrorismTopList'),
      }(name='CensorTerrorismResult'),
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      descCensorResult?: string(name='DescCensorResult'),
      id?: string(name='Id'),
      imageCensorResults?: {
        imageCensorResult?: [ 
        {
          imageBucket?: string(name='ImageBucket'),
          imageLocation?: string(name='ImageLocation'),
          imageObject?: string(name='ImageObject'),
          result?: string(name='Result'),
        }
      ](name='ImageCensorResult')
      }(name='ImageCensorResults'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      resultSaveObject?: string(name='ResultSaveObject'),
      state?: string(name='State'),
      titleCensorResult?: string(name='TitleCensorResult'),
      userData?: string(name='UserData'),
    }
  ](name='CensorJob')
  }(name='CensorJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryCensorJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryCensorJobListResponseBody(name='body'),
}

async function queryCensorJobList(request: QueryCensorJobListRequest): QueryCensorJobListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryCensorJobList', 'POST', '/', 'json', false, 'json', request);
}

model QueryCensorPipelineListRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineIds: string(name='PipelineIds', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryCensorPipelineListResponseBody = {
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  pipelineList?: {
    pipeline?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      notifyConfig?: {
        queue?: string(name='Queue'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      state?: string(name='State'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
}

model QueryCensorPipelineListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryCensorPipelineListResponseBody(name='body'),
}

async function queryCensorPipelineList(request: QueryCensorPipelineListRequest): QueryCensorPipelineListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryCensorPipelineList', 'POST', '/', 'json', false, 'json', request);
}

model QueryComplexJobListRequest {
  jobIds?: string(name='JobIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryComplexJobListResponseBody = {
  jobList?: {
    job?: [ 
    {
      code?: string(name='Code'),
      complexEditingConfigs?: {
        complexEditingConfigs?: [ 
        {
          editing?: {
            clipList?: {
              clip?: [ 
              {
                effects?: {
                  effect?: [ 
                  {
                    effect?: string(name='Effect'),
                    effectConfig?: string(name='EffectConfig'),
                  }
                ](name='Effect')
                }(name='Effects'),
                id?: string(name='Id'),
                in?: string(name='In'),
                out?: string(name='Out'),
                sourceID?: string(name='SourceID'),
                sourceStrmMap?: string(name='SourceStrmMap'),
                sourceType?: string(name='SourceType'),
                type?: string(name='Type'),
              }
            ](name='Clip')
            }(name='ClipList'),
            timeline?: {
              timelineConfig?: {
                timelineConfigAudio?: {
                  channelLayout?: string(name='ChannelLayout'),
                  channels?: string(name='Channels'),
                  samplerate?: string(name='Samplerate'),
                }(name='TimelineConfigAudio'),
                timelineConfigVideo?: {
                  bgColor?: string(name='BgColor'),
                  fps?: string(name='Fps'),
                  height?: string(name='Height'),
                  isGpuData?: string(name='IsGpuData'),
                  isOneTrackData?: string(name='IsOneTrackData'),
                  reclosePrec?: string(name='ReclosePrec'),
                  renderRatio?: string(name='RenderRatio'),
                  width?: string(name='Width'),
                }(name='TimelineConfigVideo'),
              }(name='TimelineConfig'),
              trackList?: {
                track?: [ 
                {
                  clips?: {
                    clip?: [ 
                    {
                      clipsConfig?: {
                        clipsConfigVideo?: {
                          l?: string(name='L'),
                          t?: string(name='T'),
                        }(name='ClipsConfigVideo'),
                      }(name='ClipsConfig'),
                      in?: string(name='In'),
                      out?: string(name='Out'),
                      clipID?: string(name='clipID'),
                    }
                  ](name='Clip')
                  }(name='Clips'),
                  id?: string(name='Id'),
                  order?: string(name='Order'),
                  type?: string(name='Type'),
                }
              ](name='Track')
              }(name='TrackList'),
            }(name='Timeline'),
          }(name='Editing'),
        }
      ](name='ComplexEditingConfigs')
      }(name='ComplexEditingConfigs'),
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      inputs?: {
        inputs?: [ 
        {
          editingInputs?: {
            editingInput?: [ 
            {
              id?: string(name='Id'),
              inputConfig?: {
                deinterlaceMethod?: string(name='DeinterlaceMethod'),
                isNormalSar?: string(name='IsNormalSar'),
              }(name='InputConfig'),
              inputFile?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='InputFile'),
            }
          ](name='EditingInput')
          }(name='EditingInputs'),
        }
      ](name='Inputs')
      }(name='Inputs'),
      jobId?: string(name='JobId'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      percent?: long(name='Percent'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      transcodeOutput?: {
        audio?: {
          bitrate?: string(name='Bitrate'),
          channels?: string(name='Channels'),
          codec?: string(name='Codec'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          samplerate?: string(name='Samplerate'),
          volume?: {
            level?: string(name='Level'),
            method?: string(name='Method'),
          }(name='Volume'),
        }(name='Audio'),
        audioStreamMap?: string(name='AudioStreamMap'),
        clip?: {
          timeSpan?: {
            duration?: string(name='Duration'),
            seek?: string(name='Seek'),
          }(name='TimeSpan'),
        }(name='Clip'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        deWatermark?: string(name='DeWatermark'),
        digiWaterMark?: {
          alpha?: string(name='Alpha'),
          inputFile?: {
            bucket?: string(name='Bucket'),
            location?: string(name='Location'),
            object?: string(name='Object'),
          }(name='InputFile'),
          type?: string(name='Type'),
        }(name='DigiWaterMark'),
        encryption?: {
          id?: string(name='Id'),
          key?: string(name='Key'),
          keyType?: string(name='KeyType'),
          keyUri?: string(name='KeyUri'),
          skipCnt?: string(name='SkipCnt'),
          type?: string(name='Type'),
        }(name='Encryption'),
        m3U8NonStandardSupport?: {
          TS?: {
            md5Support?: boolean(name='Md5Support'),
            sizeSupport?: boolean(name='SizeSupport'),
          }(name='TS'),
        }(name='M3U8NonStandardSupport'),
        mergeConfigUrl?: string(name='MergeConfigUrl'),
        mergeList?: {
          merge?: [ 
          {
            duration?: string(name='Duration'),
            mergeURL?: string(name='MergeURL'),
            roleArn?: string(name='RoleArn'),
            start?: string(name='Start'),
          }
        ](name='Merge')
        }(name='MergeList'),
        muxConfig?: {
          gif?: {
            ditherMode?: string(name='DitherMode'),
            finalDelay?: string(name='FinalDelay'),
            isCustomPalette?: string(name='IsCustomPalette'),
            loop?: string(name='Loop'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
        }(name='MuxConfig'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='OutputFile'),
        priority?: string(name='Priority'),
        properties?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          fileFormat?: string(name='FileFormat'),
          fileSize?: string(name='FileSize'),
          format?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            formatLongName?: string(name='FormatLongName'),
            formatName?: string(name='FormatName'),
            numPrograms?: string(name='NumPrograms'),
            numStreams?: string(name='NumStreams'),
            size?: string(name='Size'),
            startTime?: string(name='StartTime'),
          }(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          streams?: {
            audioStreamList?: {
              audioStream?: [ 
              {
                bitrate?: string(name='Bitrate'),
                channelLayout?: string(name='ChannelLayout'),
                channels?: string(name='Channels'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                duration?: string(name='Duration'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                numFrames?: string(name='NumFrames'),
                sampleFmt?: string(name='SampleFmt'),
                samplerate?: string(name='Samplerate'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
              }
            ](name='AudioStream')
            }(name='AudioStreamList'),
            subtitleStreamList?: {
              subtitleStream?: [ 
              {
                index?: string(name='Index'),
                lang?: string(name='Lang'),
              }
            ](name='SubtitleStream')
            }(name='SubtitleStreamList'),
            videoStreamList?: {
              videoStream?: [ 
              {
                avgFPS?: string(name='AvgFPS'),
                bitrate?: string(name='Bitrate'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                dar?: string(name='Dar'),
                duration?: string(name='Duration'),
                fps?: string(name='Fps'),
                hasBFrames?: string(name='HasBFrames'),
                height?: string(name='Height'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                level?: string(name='Level'),
                networkCost?: {
                  avgBitrate?: string(name='AvgBitrate'),
                  costBandwidth?: string(name='CostBandwidth'),
                  preloadTime?: string(name='PreloadTime'),
                }(name='NetworkCost'),
                numFrames?: string(name='NumFrames'),
                pixFmt?: string(name='PixFmt'),
                profile?: string(name='Profile'),
                sar?: string(name='Sar'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
                width?: string(name='Width'),
              }
            ](name='VideoStream')
            }(name='VideoStreamList'),
          }(name='Streams'),
          width?: string(name='Width'),
        }(name='Properties'),
        rotate?: string(name='Rotate'),
        subtitleConfig?: {
          extSubtitleList?: {
            extSubtitle?: [ 
            {
              charEnc?: string(name='CharEnc'),
              fontName?: string(name='FontName'),
              input?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='Input'),
            }
          ](name='ExtSubtitle')
          }(name='ExtSubtitleList'),
          subtitleList?: {
            subtitle?: [ 
            {
              map?: string(name='Map'),
            }
          ](name='Subtitle')
          }(name='SubtitleList'),
        }(name='SubtitleConfig'),
        superReso?: {
          isHalfSample?: string(name='IsHalfSample'),
        }(name='SuperReso'),
        templateId?: string(name='TemplateId'),
        transConfig?: {
          adjDarMethod?: string(name='AdjDarMethod'),
          duration?: string(name='Duration'),
          isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
          isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
          isCheckReso?: string(name='IsCheckReso'),
          isCheckResoFail?: string(name='IsCheckResoFail'),
          isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
          isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
          transMode?: string(name='TransMode'),
        }(name='TransConfig'),
        userData?: string(name='UserData'),
        video?: {
          bitrate?: string(name='Bitrate'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          bufsize?: string(name='Bufsize'),
          codec?: string(name='Codec'),
          crf?: string(name='Crf'),
          crop?: string(name='Crop'),
          degrain?: string(name='Degrain'),
          fps?: string(name='Fps'),
          gop?: string(name='Gop'),
          height?: string(name='Height'),
          maxFps?: string(name='MaxFps'),
          maxrate?: string(name='Maxrate'),
          pad?: string(name='Pad'),
          pixFmt?: string(name='PixFmt'),
          preset?: string(name='Preset'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          scanMode?: string(name='ScanMode'),
          width?: string(name='Width'),
        }(name='Video'),
        videoStreamMap?: string(name='VideoStreamMap'),
        waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
        waterMarkList?: {
          waterMark?: [ 
          {
            dx?: string(name='Dx'),
            dy?: string(name='Dy'),
            height?: string(name='Height'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
            referPos?: string(name='ReferPos'),
            type?: string(name='Type'),
            waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
            width?: string(name='Width'),
          }
        ](name='WaterMark')
        }(name='WaterMarkList'),
      }(name='transcodeOutput'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
}

model QueryComplexJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryComplexJobListResponseBody(name='body'),
}

async function queryComplexJobList(request: QueryComplexJobListRequest): QueryComplexJobListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryComplexJobList', 'POST', '/', 'json', false, 'json', request);
}

model QueryEditingJobListRequest {
  jobIds?: string(name='JobIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryEditingJobListResponseBody = {
  jobList?: {
    job?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      editingConfig?: {
        audio?: {
          bitrate?: string(name='Bitrate'),
          channels?: string(name='Channels'),
          codec?: string(name='Codec'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          samplerate?: string(name='Samplerate'),
          volume?: {
            level?: string(name='Level'),
            method?: string(name='Method'),
          }(name='Volume'),
        }(name='Audio'),
        audioStreamMap?: string(name='AudioStreamMap'),
        clip?: {
          timeSpan?: {
            duration?: string(name='Duration'),
            seek?: string(name='Seek'),
          }(name='TimeSpan'),
        }(name='Clip'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        deWatermark?: string(name='DeWatermark'),
        digiWaterMark?: {
          alpha?: string(name='Alpha'),
          inputFile?: {
            bucket?: string(name='Bucket'),
            location?: string(name='Location'),
            object?: string(name='Object'),
          }(name='InputFile'),
          type?: string(name='Type'),
        }(name='DigiWaterMark'),
        editing?: {
          clipList?: {
            clip?: [ 
            {
              effects?: {
                effect?: [ 
                {
                  effect?: string(name='Effect'),
                  effectConfig?: string(name='EffectConfig'),
                }
              ](name='Effect')
              }(name='Effects'),
              id?: string(name='Id'),
              in?: string(name='In'),
              out?: string(name='Out'),
              sourceID?: string(name='SourceID'),
              sourceStrmMap?: string(name='SourceStrmMap'),
              sourceType?: string(name='SourceType'),
              type?: string(name='Type'),
            }
          ](name='Clip')
          }(name='ClipList'),
          timeline?: {
            timelineConfig?: {
              timelineConfigAudio?: {
                channelLayout?: string(name='ChannelLayout'),
                channels?: string(name='Channels'),
                samplerate?: string(name='Samplerate'),
              }(name='TimelineConfigAudio'),
              timelineConfigVideo?: {
                bgColor?: string(name='BgColor'),
                fps?: string(name='Fps'),
                height?: string(name='Height'),
                isGpuData?: string(name='IsGpuData'),
                isOneTrackData?: string(name='IsOneTrackData'),
                reclosePrec?: string(name='ReclosePrec'),
                renderRatio?: string(name='RenderRatio'),
                width?: string(name='Width'),
              }(name='TimelineConfigVideo'),
            }(name='TimelineConfig'),
            trackList?: {
              track?: [ 
              {
                clips?: {
                  clip?: [ 
                  {
                    clipsConfig?: {
                      clipsConfigVideo?: {
                        l?: string(name='L'),
                        t?: string(name='T'),
                      }(name='ClipsConfigVideo'),
                    }(name='ClipsConfig'),
                    in?: string(name='In'),
                    out?: string(name='Out'),
                    clipID?: string(name='clipID'),
                  }
                ](name='Clip')
                }(name='Clips'),
                id?: string(name='Id'),
                order?: string(name='Order'),
                type?: string(name='Type'),
              }
            ](name='Track')
            }(name='TrackList'),
          }(name='Timeline'),
        }(name='Editing'),
        encryption?: {
          id?: string(name='Id'),
          key?: string(name='Key'),
          keyType?: string(name='KeyType'),
          keyUri?: string(name='KeyUri'),
          skipCnt?: string(name='SkipCnt'),
          type?: string(name='Type'),
        }(name='Encryption'),
        m3U8NonStandardSupport?: {
          TS?: {
            md5Support?: boolean(name='Md5Support'),
            sizeSupport?: boolean(name='SizeSupport'),
          }(name='TS'),
        }(name='M3U8NonStandardSupport'),
        mergeConfigUrl?: string(name='MergeConfigUrl'),
        mergeList?: {
          merge?: [ 
          {
            duration?: string(name='Duration'),
            mergeURL?: string(name='MergeURL'),
            roleArn?: string(name='RoleArn'),
            start?: string(name='Start'),
          }
        ](name='Merge')
        }(name='MergeList'),
        muxConfig?: {
          gif?: {
            ditherMode?: string(name='DitherMode'),
            finalDelay?: string(name='FinalDelay'),
            isCustomPalette?: string(name='IsCustomPalette'),
            loop?: string(name='Loop'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
        }(name='MuxConfig'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='OutputFile'),
        priority?: string(name='Priority'),
        properties?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          fileFormat?: string(name='FileFormat'),
          fileSize?: string(name='FileSize'),
          format?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            formatLongName?: string(name='FormatLongName'),
            formatName?: string(name='FormatName'),
            numPrograms?: string(name='NumPrograms'),
            numStreams?: string(name='NumStreams'),
            size?: string(name='Size'),
            startTime?: string(name='StartTime'),
          }(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          streams?: {
            audioStreamList?: {
              audioStream?: [ 
              {
                bitrate?: string(name='Bitrate'),
                channelLayout?: string(name='ChannelLayout'),
                channels?: string(name='Channels'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                duration?: string(name='Duration'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                numFrames?: string(name='NumFrames'),
                sampleFmt?: string(name='SampleFmt'),
                samplerate?: string(name='Samplerate'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
              }
            ](name='AudioStream')
            }(name='AudioStreamList'),
            subtitleStreamList?: {
              subtitleStream?: [ 
              {
                index?: string(name='Index'),
                lang?: string(name='Lang'),
              }
            ](name='SubtitleStream')
            }(name='SubtitleStreamList'),
            videoStreamList?: {
              videoStream?: [ 
              {
                avgFPS?: string(name='AvgFPS'),
                bitrate?: string(name='Bitrate'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                dar?: string(name='Dar'),
                duration?: string(name='Duration'),
                fps?: string(name='Fps'),
                hasBFrames?: string(name='HasBFrames'),
                height?: string(name='Height'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                level?: string(name='Level'),
                networkCost?: {
                  avgBitrate?: string(name='AvgBitrate'),
                  costBandwidth?: string(name='CostBandwidth'),
                  preloadTime?: string(name='PreloadTime'),
                }(name='NetworkCost'),
                numFrames?: string(name='NumFrames'),
                pixFmt?: string(name='PixFmt'),
                profile?: string(name='Profile'),
                sar?: string(name='Sar'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
                width?: string(name='Width'),
              }
            ](name='VideoStream')
            }(name='VideoStreamList'),
          }(name='Streams'),
          width?: string(name='Width'),
        }(name='Properties'),
        rotate?: string(name='Rotate'),
        subtitleConfig?: {
          extSubtitleList?: {
            extSubtitle?: [ 
            {
              charEnc?: string(name='CharEnc'),
              fontName?: string(name='FontName'),
              input?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='Input'),
            }
          ](name='ExtSubtitle')
          }(name='ExtSubtitleList'),
          subtitleList?: {
            subtitle?: [ 
            {
              map?: string(name='Map'),
            }
          ](name='Subtitle')
          }(name='SubtitleList'),
        }(name='SubtitleConfig'),
        superReso?: {
          isHalfSample?: string(name='IsHalfSample'),
        }(name='SuperReso'),
        templateId?: string(name='TemplateId'),
        transConfig?: {
          adjDarMethod?: string(name='AdjDarMethod'),
          duration?: string(name='Duration'),
          isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
          isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
          isCheckReso?: string(name='IsCheckReso'),
          isCheckResoFail?: string(name='IsCheckResoFail'),
          isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
          isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
          transMode?: string(name='TransMode'),
        }(name='TransConfig'),
        userData?: string(name='UserData'),
        video?: {
          bitrate?: string(name='Bitrate'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          bufsize?: string(name='Bufsize'),
          codec?: string(name='Codec'),
          crf?: string(name='Crf'),
          crop?: string(name='Crop'),
          degrain?: string(name='Degrain'),
          fps?: string(name='Fps'),
          gop?: string(name='Gop'),
          height?: string(name='Height'),
          maxFps?: string(name='MaxFps'),
          maxrate?: string(name='Maxrate'),
          pad?: string(name='Pad'),
          pixFmt?: string(name='PixFmt'),
          preset?: string(name='Preset'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          scanMode?: string(name='ScanMode'),
          width?: string(name='Width'),
        }(name='Video'),
        videoStreamMap?: string(name='VideoStreamMap'),
        waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
        waterMarkList?: {
          waterMark?: [ 
          {
            dx?: string(name='Dx'),
            dy?: string(name='Dy'),
            height?: string(name='Height'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
            referPos?: string(name='ReferPos'),
            type?: string(name='Type'),
            waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
            width?: string(name='Width'),
          }
        ](name='WaterMark')
        }(name='WaterMarkList'),
      }(name='EditingConfig'),
      editingInputs?: {
        editingInput?: [ 
        {
          id?: string(name='Id'),
          inputConfig?: {
            deinterlaceMethod?: string(name='DeinterlaceMethod'),
            isNormalSar?: string(name='IsNormalSar'),
          }(name='InputConfig'),
          inputFile?: {
            bucket?: string(name='Bucket'),
            location?: string(name='Location'),
            object?: string(name='Object'),
          }(name='InputFile'),
        }
      ](name='EditingInput')
      }(name='EditingInputs'),
      finishTime?: string(name='FinishTime'),
      jobId?: string(name='JobId'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      percent?: long(name='Percent'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
}

model QueryEditingJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryEditingJobListResponseBody(name='body'),
}

async function queryEditingJobList(request: QueryEditingJobListRequest): QueryEditingJobListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryEditingJobList', 'POST', '/', 'json', false, 'json', request);
}

model QueryFpDBDeleteJobListRequest {
  jobIds?: string(name='JobIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryFpDBDeleteJobListResponseBody = {
  fpDBDeleteJobList?: {
    fpDBDeleteJob?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      delType?: string(name='DelType'),
      finishTime?: string(name='FinishTime'),
      fpDBId?: string(name='FpDBId'),
      id?: string(name='Id'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      status?: string(name='Status'),
      userData?: string(name='UserData'),
    }
  ](name='FpDBDeleteJob')
  }(name='FpDBDeleteJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryFpDBDeleteJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFpDBDeleteJobListResponseBody(name='body'),
}

async function queryFpDBDeleteJobList(request: QueryFpDBDeleteJobListRequest): QueryFpDBDeleteJobListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryFpDBDeleteJobList', 'POST', '/', 'json', false, 'json', request);
}

model QueryFpFileDeleteJobListRequest {
  jobIds?: string(name='JobIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryFpFileDeleteJobListResponseBody = {
  fpFileDeleteJobList?: {
    fpFileDeleteJob?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      fileIds?: string(name='FileIds'),
      finishTime?: string(name='FinishTime'),
      fpDBId?: string(name='FpDBId'),
      id?: string(name='Id'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      status?: string(name='Status'),
      userData?: string(name='UserData'),
    }
  ](name='FpFileDeleteJob')
  }(name='FpFileDeleteJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryFpFileDeleteJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFpFileDeleteJobListResponseBody(name='body'),
}

async function queryFpFileDeleteJobList(request: QueryFpFileDeleteJobListRequest): QueryFpFileDeleteJobListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryFpFileDeleteJobList', 'POST', '/', 'json', false, 'json', request);
}

model QueryFpShotJobListRequest {
  jobIds?: string(name='JobIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryFpShotJobListResponseBody = {
  fpShotJobList?: {
    fpShotJob?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      fileId?: string(name='FileId'),
      finishTime?: string(name='FinishTime'),
      fpShotConfig?: {
        fpDBId?: string(name='FpDBId'),
        primaryKey?: string(name='PrimaryKey'),
        saveType?: string(name='SaveType'),
      }(name='FpShotConfig'),
      fpShotResult?: {
        audioFpShots?: {
          fpShot?: [ 
          {
            fpShotSlices?: {
              fpShotSlice?: [ 
              {
                duplication?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='Duplication'),
                input?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='Input'),
                similarity?: string(name='Similarity'),
              }
            ](name='FpShotSlice')
            }(name='FpShotSlices'),
            primaryKey?: string(name='PrimaryKey'),
            similarity?: string(name='Similarity'),
          }
        ](name='FpShot')
        }(name='AudioFpShots'),
        fpShots?: {
          fpShot?: [ 
          {
            fpShotSlices?: {
              fpShotSlice?: [ 
              {
                duplication?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='Duplication'),
                input?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='Input'),
                similarity?: string(name='Similarity'),
              }
            ](name='FpShotSlice')
            }(name='FpShotSlices'),
            primaryKey?: string(name='PrimaryKey'),
            similarity?: string(name='Similarity'),
          }
        ](name='FpShot')
        }(name='FpShots'),
        textFpShots?: {
          textFpShot?: [ 
          {
            primaryKey?: string(name='PrimaryKey'),
            similarity?: string(name='Similarity'),
            textFpShotSlices?: {
              textFpShotSlice?: [ 
              {
                duplicationText?: string(name='DuplicationText'),
                inputFragment?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='InputFragment'),
                inputText?: string(name='InputText'),
                similarity?: string(name='Similarity'),
              }
            ](name='TextFpShotSlice')
            }(name='TextFpShotSlices'),
          }
        ](name='TextFpShot')
        }(name='TextFpShots'),
      }(name='FpShotResult'),
      id?: string(name='Id'),
      input?: string(name='Input'),
      inputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='InputFile'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
    }
  ](name='FpShotJob')
  }(name='FpShotJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryFpShotJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFpShotJobListResponseBody(name='body'),
}

async function queryFpShotJobList(request: QueryFpShotJobListRequest): QueryFpShotJobListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryFpShotJobList', 'POST', '/', 'json', false, 'json', request);
}

model QueryIProductionJobRequest {
  jobId?: string(name='JobId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryIProductionJobResponseBody = {
  functionName?: string(name='FunctionName'),
  input?: string(name='Input'),
  jobId?: string(name='JobId'),
  jobParams?: string(name='JobParams'),
  output?: string(name='Output'),
  pipelineId?: string(name='PipelineId'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  state?: string(name='State'),
  userData?: string(name='UserData'),
}

model QueryIProductionJobResponse = {
  headers: map[string]string(name='headers'),
  body: QueryIProductionJobResponseBody(name='body'),
}

async function queryIProductionJob(request: QueryIProductionJobRequest): QueryIProductionJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryIProductionJob', 'POST', '/', 'json', false, 'json', request);
}

model QueryInnerJobRequest {
  jobId: string(name='JobId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryInnerJobResponseBody = {
  image?: {
    result?: [ 
    {
      code?: string(name='Code'),
      index?: int32(name='Index'),
      result?: int32(name='Result'),
    }
  ](name='Result')
  }(name='Image'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  suggestion?: string(name='Suggestion'),
  video?: {
    code?: string(name='Code'),
    index?: int32(name='Index'),
    result?: int32(name='Result'),
  }(name='Video'),
}

model QueryInnerJobResponse = {
  headers: map[string]string(name='headers'),
  body: QueryInnerJobResponseBody(name='body'),
}

async function queryInnerJob(request: QueryInnerJobRequest): QueryInnerJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryInnerJob', 'POST', '/', 'json', false, 'json', request);
}

model QueryJobListRequest {
  jobIds?: string(name='JobIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryJobListResponseBody = {
  jobList?: {
    job?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      output?: {
        audio?: {
          bitrate?: string(name='Bitrate'),
          channels?: string(name='Channels'),
          codec?: string(name='Codec'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          samplerate?: string(name='Samplerate'),
          volume?: {
            level?: string(name='Level'),
            method?: string(name='Method'),
          }(name='Volume'),
        }(name='Audio'),
        audioStreamMap?: string(name='AudioStreamMap'),
        clip?: {
          timeSpan?: {
            duration?: string(name='Duration'),
            seek?: string(name='Seek'),
          }(name='TimeSpan'),
        }(name='Clip'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        deWatermark?: string(name='DeWatermark'),
        encryption?: {
          id?: string(name='Id'),
          key?: string(name='Key'),
          keyType?: string(name='KeyType'),
          keyUri?: string(name='KeyUri'),
          skipCnt?: string(name='SkipCnt'),
          type?: string(name='Type'),
        }(name='Encryption'),
        extendData?: string(name='ExtendData', description='扩展字段'),
        m3U8NonStandardSupport?: {
          TS?: {
            md5Support?: boolean(name='Md5Support'),
            sizeSupport?: boolean(name='SizeSupport'),
          }(name='TS'),
        }(name='M3U8NonStandardSupport'),
        mergeConfigUrl?: string(name='MergeConfigUrl'),
        mergeList?: {
          merge?: [ 
          {
            duration?: string(name='Duration'),
            mergeURL?: string(name='MergeURL'),
            roleArn?: string(name='RoleArn'),
            start?: string(name='Start'),
          }
        ](name='Merge')
        }(name='MergeList'),
        muxConfig?: {
          gif?: {
            ditherMode?: string(name='DitherMode'),
            finalDelay?: string(name='FinalDelay'),
            isCustomPalette?: string(name='IsCustomPalette'),
            loop?: string(name='Loop'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
          webp?: {
            loop?: string(name='Loop'),
          }(name='Webp'),
        }(name='MuxConfig'),
        openingList?: {
          opening?: [ 
          {
            height?: string(name='Height'),
            start?: string(name='Start'),
            width?: string(name='Width'),
            openUrl?: string(name='openUrl'),
          }
        ](name='Opening')
        }(name='OpeningList'),
        outSubtitleList?: {
          outSubtitle?: [ 
          {
            map?: string(name='Map'),
            message?: string(name='Message'),
            outSubtitleFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
              roleArn?: string(name='RoleArn'),
            }(name='OutSubtitleFile'),
            success?: boolean(name='Success'),
          }
        ](name='OutSubtitle')
        }(name='OutSubtitleList'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='OutputFile'),
        priority?: string(name='Priority'),
        properties?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          fileFormat?: string(name='FileFormat'),
          fileSize?: string(name='FileSize'),
          format?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            formatLongName?: string(name='FormatLongName'),
            formatName?: string(name='FormatName'),
            numPrograms?: string(name='NumPrograms'),
            numStreams?: string(name='NumStreams'),
            size?: string(name='Size'),
            startTime?: string(name='StartTime'),
          }(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          sourceLogos?: {
            sourceLogo?: [ 
            {
              source?: string(name='Source'),
            }
          ](name='SourceLogo')
          }(name='SourceLogos'),
          streams?: {
            audioStreamList?: {
              audioStream?: [ 
              {
                bitrate?: string(name='Bitrate'),
                channelLayout?: string(name='ChannelLayout'),
                channels?: string(name='Channels'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                duration?: string(name='Duration'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                numFrames?: string(name='NumFrames'),
                sampleFmt?: string(name='SampleFmt'),
                samplerate?: string(name='Samplerate'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
              }
            ](name='AudioStream')
            }(name='AudioStreamList'),
            subtitleStreamList?: {
              subtitleStream?: [ 
              {
                index?: string(name='Index'),
                lang?: string(name='Lang'),
              }
            ](name='SubtitleStream')
            }(name='SubtitleStreamList'),
            videoStreamList?: {
              videoStream?: [ 
              {
                avgFPS?: string(name='AvgFPS'),
                bitrate?: string(name='Bitrate'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                dar?: string(name='Dar'),
                duration?: string(name='Duration'),
                fps?: string(name='Fps'),
                hasBFrames?: string(name='HasBFrames'),
                height?: string(name='Height'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                level?: string(name='Level'),
                networkCost?: {
                  avgBitrate?: string(name='AvgBitrate'),
                  costBandwidth?: string(name='CostBandwidth'),
                  preloadTime?: string(name='PreloadTime'),
                }(name='NetworkCost'),
                numFrames?: string(name='NumFrames'),
                pixFmt?: string(name='PixFmt'),
                profile?: string(name='Profile'),
                sar?: string(name='Sar'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
                width?: string(name='Width'),
                bitsPerRawSample?: string(name='bitsPerRawSample'),
                colorPrimaries?: string(name='colorPrimaries'),
                colorTransfer?: string(name='colorTransfer'),
              }
            ](name='VideoStream')
            }(name='VideoStreamList'),
          }(name='Streams'),
          width?: string(name='Width'),
        }(name='Properties'),
        rotate?: string(name='Rotate'),
        subtitleConfig?: {
          extSubtitleList?: {
            extSubtitle?: [ 
            {
              charEnc?: string(name='CharEnc'),
              fontName?: string(name='FontName'),
              input?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='Input'),
            }
          ](name='ExtSubtitle')
          }(name='ExtSubtitleList'),
          subtitleList?: {
            subtitle?: [ 
            {
              map?: string(name='Map'),
            }
          ](name='Subtitle')
          }(name='SubtitleList'),
        }(name='SubtitleConfig'),
        superReso?: {
          isHalfSample?: string(name='IsHalfSample'),
        }(name='SuperReso'),
        tailSlateList?: {
          tailSlate?: [ 
          {
            bgColor?: string(name='BgColor'),
            blendDuration?: string(name='BlendDuration'),
            height?: string(name='Height'),
            isMergeAudio?: boolean(name='IsMergeAudio'),
            start?: string(name='Start'),
            tailUrl?: string(name='TailUrl'),
            width?: string(name='Width'),
          }
        ](name='TailSlate')
        }(name='TailSlateList'),
        templateId?: string(name='TemplateId'),
        transConfig?: {
          adjDarMethod?: string(name='AdjDarMethod'),
          isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
          isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
          isCheckReso?: string(name='IsCheckReso'),
          isCheckResoFail?: string(name='IsCheckResoFail'),
          isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
          isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
          transMode?: string(name='TransMode'),
        }(name='TransConfig'),
        userData?: string(name='UserData'),
        video?: {
          bitrate?: string(name='Bitrate'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          bufsize?: string(name='Bufsize'),
          codec?: string(name='Codec'),
          crf?: string(name='Crf'),
          crop?: string(name='Crop'),
          degrain?: string(name='Degrain'),
          fps?: string(name='Fps'),
          gop?: string(name='Gop'),
          height?: string(name='Height'),
          maxFps?: string(name='MaxFps'),
          maxrate?: string(name='Maxrate'),
          pad?: string(name='Pad'),
          pixFmt?: string(name='PixFmt'),
          preset?: string(name='Preset'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          resoPriority?: string(name='ResoPriority'),
          scanMode?: string(name='ScanMode'),
          width?: string(name='Width'),
        }(name='Video'),
        videoStreamMap?: string(name='VideoStreamMap'),
        waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
        waterMarkList?: {
          waterMark?: [ 
          {
            dx?: string(name='Dx'),
            dy?: string(name='Dy'),
            height?: string(name='Height'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
            referPos?: string(name='ReferPos'),
            type?: string(name='Type'),
            waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
            width?: string(name='Width'),
          }
        ](name='WaterMark')
        }(name='WaterMarkList'),
      }(name='Output'),
      percent?: long(name='Percent'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
}

model QueryJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryJobListResponseBody(name='body'),
}

async function queryJobList(request: QueryJobListRequest): QueryJobListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryJobList', 'POST', '/', 'json', false, 'json', request);
}

model QueryMediaCensorJobDetailRequest {
  jobId: string(name='JobId', position='Query'),
  maximumPageSize?: long(name='MaximumPageSize', position='Query'),
  nextPageToken?: string(name='NextPageToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryMediaCensorJobDetailResponseBody = {
  mediaCensorJobDetail?: {
    barrageCensorResult?: {
      label?: string(name='Label'),
      rate?: string(name='Rate'),
      scene?: string(name='Scene'),
      suggestion?: string(name='Suggestion'),
    }(name='BarrageCensorResult'),
    code?: string(name='Code'),
    coverImageCensorResults?: {
      coverImageCensorResult?: [ 
      {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        results?: {
          result?: [ 
          {
            label?: string(name='Label'),
            rate?: string(name='Rate'),
            scene?: string(name='Scene'),
            suggestion?: string(name='Suggestion'),
          }
        ](name='Result')
        }(name='Results'),
      }
    ](name='CoverImageCensorResult')
    }(name='CoverImageCensorResults'),
    creationTime?: string(name='CreationTime'),
    descCensorResult?: {
      label?: string(name='Label'),
      rate?: string(name='Rate'),
      scene?: string(name='Scene'),
      suggestion?: string(name='Suggestion'),
    }(name='DescCensorResult'),
    finishTime?: string(name='FinishTime'),
    input?: {
      bucket?: string(name='Bucket'),
      location?: string(name='Location'),
      object?: string(name='Object'),
    }(name='Input'),
    jobId?: string(name='JobId'),
    message?: string(name='Message'),
    pipelineId?: string(name='PipelineId'),
    state?: string(name='State'),
    suggestion?: string(name='Suggestion'),
    titleCensorResult?: {
      label?: string(name='Label'),
      rate?: string(name='Rate'),
      scene?: string(name='Scene'),
      suggestion?: string(name='Suggestion'),
    }(name='TitleCensorResult'),
    userData?: string(name='UserData'),
    vensorCensorResult?: {
      censorResults?: {
        censorResult?: [ 
        {
          label?: string(name='Label'),
          rate?: string(name='Rate'),
          scene?: string(name='Scene'),
          suggestion?: string(name='Suggestion'),
        }
      ](name='CensorResult')
      }(name='CensorResults'),
      nextPageToken?: string(name='NextPageToken'),
      videoTimelines?: {
        videoTimeline?: [ 
        {
          censorResults?: {
            censorResult?: [ 
            {
              label?: string(name='Label'),
              rate?: string(name='Rate'),
              scene?: string(name='Scene'),
              suggestion?: string(name='Suggestion'),
            }
          ](name='CensorResult')
          }(name='CensorResults'),
          object?: string(name='Object'),
          timestamp?: string(name='Timestamp'),
        }
      ](name='VideoTimeline')
      }(name='VideoTimelines'),
    }(name='VensorCensorResult'),
    videoCensorConfig?: {
      bizType?: string(name='BizType'),
      outputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='OutputFile'),
      videoCensor?: string(name='VideoCensor'),
    }(name='VideoCensorConfig'),
  }(name='MediaCensorJobDetail'),
  requestId?: string(name='RequestId'),
}

model QueryMediaCensorJobDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaCensorJobDetailResponseBody(name='body'),
}

async function queryMediaCensorJobDetail(request: QueryMediaCensorJobDetailRequest): QueryMediaCensorJobDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMediaCensorJobDetail', 'POST', '/', 'json', false, 'json', request);
}

model QueryMediaCensorJobListRequest {
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange', position='Query'),
  jobId?: string(name='JobId', position='Query'),
  maximumPageSize?: long(name='MaximumPageSize', minimum=1, maximum=100, position='Query'),
  nextPageToken?: string(name='NextPageToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId?: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange', position='Query'),
  state?: string(name='State', position='Query'),
}

model QueryMediaCensorJobListResponseBody = {
  mediaCensorJobList?: {
    mediaCensorJob?: [ 
    {
      barrageCensorResult?: {
        label?: string(name='Label'),
        rate?: string(name='Rate'),
        scene?: string(name='Scene'),
        suggestion?: string(name='Suggestion'),
      }(name='BarrageCensorResult'),
      code?: string(name='Code'),
      coverImageCensorResults?: {
        coverImageCensorResult?: [ 
        {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          results?: {
            result?: [ 
            {
              label?: string(name='Label'),
              rate?: string(name='Rate'),
              scene?: string(name='Scene'),
              suggestion?: string(name='Suggestion'),
            }
          ](name='Result')
          }(name='Results'),
        }
      ](name='CoverImageCensorResult')
      }(name='CoverImageCensorResults'),
      creationTime?: string(name='CreationTime'),
      descCensorResult?: {
        label?: string(name='Label'),
        rate?: string(name='Rate'),
        scene?: string(name='Scene'),
        suggestion?: string(name='Suggestion'),
      }(name='DescCensorResult'),
      finishTime?: string(name='FinishTime'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      suggestion?: string(name='Suggestion'),
      titleCensorResult?: {
        label?: string(name='Label'),
        rate?: string(name='Rate'),
        scene?: string(name='Scene'),
        suggestion?: string(name='Suggestion'),
      }(name='TitleCensorResult'),
      userData?: string(name='UserData'),
      vensorCensorResult?: {
        censorResults?: {
          censorResult?: [ 
          {
            label?: string(name='Label'),
            rate?: string(name='Rate'),
            scene?: string(name='Scene'),
            suggestion?: string(name='Suggestion'),
          }
        ](name='CensorResult')
        }(name='CensorResults'),
        nextPageToken?: string(name='NextPageToken'),
        videoTimelines?: {
          videoTimeline?: [ 
          {
            censorResults?: {
              censorResult?: [ 
              {
                label?: string(name='Label'),
                rate?: string(name='Rate'),
                scene?: string(name='Scene'),
                suggestion?: string(name='Suggestion'),
              }
            ](name='CensorResult')
            }(name='CensorResults'),
            object?: string(name='Object'),
            timestamp?: string(name='Timestamp'),
          }
        ](name='VideoTimeline')
        }(name='VideoTimelines'),
      }(name='VensorCensorResult'),
      videoCensorConfig?: {
        bizType?: string(name='BizType'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='OutputFile'),
        videoCensor?: string(name='VideoCensor'),
      }(name='VideoCensorConfig'),
    }
  ](name='MediaCensorJob')
  }(name='MediaCensorJobList'),
  nextPageToken?: string(name='NextPageToken'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryMediaCensorJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaCensorJobListResponseBody(name='body'),
}

async function queryMediaCensorJobList(request: QueryMediaCensorJobListRequest): QueryMediaCensorJobListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMediaCensorJobList', 'POST', '/', 'json', false, 'json', request);
}

model QueryMediaInfoJobListRequest {
  mediaInfoJobIds: string(name='MediaInfoJobIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryMediaInfoJobListResponseBody = {
  mediaInfoJobList?: {
    mediaInfoJob?: [ 
    {
      async?: boolean(name='Async'),
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      properties?: {
        bitrate?: string(name='Bitrate'),
        duration?: string(name='Duration'),
        fileFormat?: string(name='FileFormat'),
        fileSize?: string(name='FileSize'),
        format?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          formatLongName?: string(name='FormatLongName'),
          formatName?: string(name='FormatName'),
          numPrograms?: string(name='NumPrograms'),
          numStreams?: string(name='NumStreams'),
          size?: string(name='Size'),
          startTime?: string(name='StartTime'),
        }(name='Format'),
        fps?: string(name='Fps'),
        height?: string(name='Height'),
        streams?: {
          audioStreamList?: {
            audioStream?: [ 
            {
              bitrate?: string(name='Bitrate'),
              channelLayout?: string(name='ChannelLayout'),
              channels?: string(name='Channels'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              numFrames?: string(name='NumFrames'),
              sampleFmt?: string(name='SampleFmt'),
              samplerate?: string(name='Samplerate'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='AudioStream')
          }(name='AudioStreamList'),
          subtitleStreamList?: {
            subtitleStream?: [ 
            {
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='SubtitleStream')
          }(name='SubtitleStreamList'),
          videoStreamList?: {
            videoStream?: [ 
            {
              avgFPS?: string(name='AvgFPS'),
              bitrate?: string(name='Bitrate'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              colorPrimaries?: string(name='ColorPrimaries'),
              colorRange?: string(name='ColorRange'),
              colorTransfer?: string(name='ColorTransfer'),
              dar?: string(name='Dar'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              hasBFrames?: string(name='HasBFrames'),
              height?: string(name='Height'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              level?: string(name='Level'),
              networkCost?: {
                avgBitrate?: string(name='AvgBitrate'),
                costBandwidth?: string(name='CostBandwidth'),
                preloadTime?: string(name='PreloadTime'),
              }(name='NetworkCost'),
              numFrames?: string(name='NumFrames'),
              pixFmt?: string(name='PixFmt'),
              profile?: string(name='Profile'),
              rotate?: string(name='Rotate'),
              sar?: string(name='Sar'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
              width?: string(name='Width'),
            }
          ](name='VideoStream')
          }(name='VideoStreamList'),
        }(name='Streams'),
        width?: string(name='Width'),
      }(name='Properties'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
    }
  ](name='MediaInfoJob')
  }(name='MediaInfoJobList'),
  nonExistMediaInfoJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistMediaInfoJobIds'),
  requestId?: string(name='RequestId'),
}

model QueryMediaInfoJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaInfoJobListResponseBody(name='body'),
}

async function queryMediaInfoJobList(request: QueryMediaInfoJobListRequest): QueryMediaInfoJobListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMediaInfoJobList', 'POST', '/', 'json', false, 'json', request);
}

model QueryMediaListRequest {
  includeMediaInfo?: boolean(name='IncludeMediaInfo', position='Query'),
  includePlayList?: boolean(name='IncludePlayList', position='Query'),
  includeSnapshotList?: boolean(name='IncludeSnapshotList', position='Query'),
  includeSummaryList?: boolean(name='IncludeSummaryList', position='Query'),
  mediaIds: string(name='MediaIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryMediaListResponseBody = {
  mediaList?: {
    media?: [ 
    {
      bitrate?: string(name='Bitrate'),
      cateId?: long(name='CateId'),
      censorState?: string(name='CensorState'),
      coverURL?: string(name='CoverURL'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      duration?: string(name='Duration'),
      file?: {
        state?: string(name='State'),
        URL?: string(name='URL'),
      }(name='File'),
      format?: string(name='Format'),
      fps?: string(name='Fps'),
      height?: string(name='Height'),
      mediaId?: string(name='MediaId'),
      mediaInfo?: {
        format?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          formatLongName?: string(name='FormatLongName'),
          formatName?: string(name='FormatName'),
          numPrograms?: string(name='NumPrograms'),
          numStreams?: string(name='NumStreams'),
          size?: string(name='Size'),
          startTime?: string(name='StartTime'),
        }(name='Format'),
        streams?: {
          audioStreamList?: {
            audioStream?: [ 
            {
              bitrate?: string(name='Bitrate'),
              channelLayout?: string(name='ChannelLayout'),
              channels?: string(name='Channels'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              numFrames?: string(name='NumFrames'),
              sampleFmt?: string(name='SampleFmt'),
              samplerate?: string(name='Samplerate'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='AudioStream')
          }(name='AudioStreamList'),
          subtitleStreamList?: {
            subtitleStream?: [ 
            {
              index?: string(name='Index'),
              lang?: string(name='Lang'),
            }
          ](name='SubtitleStream')
          }(name='SubtitleStreamList'),
          videoStreamList?: {
            videoStream?: [ 
            {
              avgFPS?: string(name='AvgFPS'),
              bitrate?: string(name='Bitrate'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              dar?: string(name='Dar'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              hasBFrames?: string(name='HasBFrames'),
              height?: string(name='Height'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              level?: string(name='Level'),
              networkCost?: {
                avgBitrate?: string(name='AvgBitrate'),
                costBandwidth?: string(name='CostBandwidth'),
                preloadTime?: string(name='PreloadTime'),
              }(name='NetworkCost'),
              numFrames?: string(name='NumFrames'),
              pixFmt?: string(name='PixFmt'),
              profile?: string(name='Profile'),
              rotate?: string(name='Rotate'),
              sar?: string(name='Sar'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
              width?: string(name='Width'),
            }
          ](name='VideoStream')
          }(name='VideoStreamList'),
        }(name='Streams'),
      }(name='MediaInfo'),
      playList?: {
        play?: [ 
        {
          activityName?: string(name='ActivityName'),
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          encryption?: string(name='Encryption'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          format?: string(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          size?: string(name='Size'),
          width?: string(name='Width'),
        }
      ](name='Play')
      }(name='PlayList'),
      publishState?: string(name='PublishState'),
      runIdList?: {
        runId?: [ string ](name='RunId')
      }(name='RunIdList'),
      size?: string(name='Size'),
      snapshotList?: {
        snapshot?: [ 
        {
          activityName?: string(name='ActivityName'),
          count?: string(name='Count'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          type?: string(name='Type'),
        }
      ](name='Snapshot')
      }(name='SnapshotList'),
      summaryList?: {
        summary?: [ 
        {
          activityName?: string(name='ActivityName'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          type?: string(name='Type'),
        }
      ](name='Summary')
      }(name='SummaryList'),
      tags?: {
        tag?: [ string ](name='Tag')
      }(name='Tags'),
      title?: string(name='Title'),
      width?: string(name='Width'),
    }
  ](name='Media')
  }(name='MediaList'),
  nonExistMediaIds?: {
    mediaId?: [ string ](name='MediaId')
  }(name='NonExistMediaIds'),
  requestId?: string(name='RequestId'),
}

model QueryMediaListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaListResponseBody(name='body'),
}

async function queryMediaList(request: QueryMediaListRequest): QueryMediaListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMediaList', 'POST', '/', 'json', false, 'json', request);
}

model QueryMediaListByURLRequest {
  fileURLs: string(name='FileURLs', position='Query'),
  includeMediaInfo?: boolean(name='IncludeMediaInfo', position='Query'),
  includePlayList?: boolean(name='IncludePlayList', position='Query'),
  includeSnapshotList?: boolean(name='IncludeSnapshotList', position='Query'),
  includeSummaryList?: boolean(name='IncludeSummaryList', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryMediaListByURLResponseBody = {
  mediaList?: {
    media?: [ 
    {
      bitrate?: string(name='Bitrate'),
      cateId?: long(name='CateId'),
      censorState?: string(name='CensorState'),
      coverURL?: string(name='CoverURL'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      duration?: string(name='Duration'),
      file?: {
        state?: string(name='State'),
        URL?: string(name='URL'),
      }(name='File'),
      format?: string(name='Format'),
      fps?: string(name='Fps'),
      height?: string(name='Height'),
      mediaId?: string(name='MediaId'),
      mediaInfo?: {
        format?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          formatLongName?: string(name='FormatLongName'),
          formatName?: string(name='FormatName'),
          numPrograms?: string(name='NumPrograms'),
          numStreams?: string(name='NumStreams'),
          size?: string(name='Size'),
          startTime?: string(name='StartTime'),
        }(name='Format'),
        streams?: {
          audioStreamList?: {
            audioStream?: [ 
            {
              bitrate?: string(name='Bitrate'),
              channelLayout?: string(name='ChannelLayout'),
              channels?: string(name='Channels'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              numFrames?: string(name='NumFrames'),
              sampleFmt?: string(name='SampleFmt'),
              samplerate?: string(name='Samplerate'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='AudioStream')
          }(name='AudioStreamList'),
          subtitleStreamList?: {
            subtitleStream?: [ 
            {
              index?: string(name='Index'),
              lang?: string(name='Lang'),
            }
          ](name='SubtitleStream')
          }(name='SubtitleStreamList'),
          videoStreamList?: {
            videoStream?: [ 
            {
              avgFPS?: string(name='AvgFPS'),
              bitrate?: string(name='Bitrate'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              dar?: string(name='Dar'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              hasBFrames?: string(name='HasBFrames'),
              height?: string(name='Height'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              level?: string(name='Level'),
              networkCost?: {
                avgBitrate?: string(name='AvgBitrate'),
                costBandwidth?: string(name='CostBandwidth'),
                preloadTime?: string(name='PreloadTime'),
              }(name='NetworkCost'),
              numFrames?: string(name='NumFrames'),
              pixFmt?: string(name='PixFmt'),
              profile?: string(name='Profile'),
              rotate?: string(name='Rotate'),
              sar?: string(name='Sar'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
              width?: string(name='Width'),
            }
          ](name='VideoStream')
          }(name='VideoStreamList'),
        }(name='Streams'),
      }(name='MediaInfo'),
      playList?: {
        play?: [ 
        {
          activityName?: string(name='ActivityName'),
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          encryption?: string(name='Encryption'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          format?: string(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          size?: string(name='Size'),
          width?: string(name='Width'),
        }
      ](name='Play')
      }(name='PlayList'),
      publishState?: string(name='PublishState'),
      runIdList?: {
        runId?: [ string ](name='RunId')
      }(name='RunIdList'),
      size?: string(name='Size'),
      snapshotList?: {
        snapshot?: [ 
        {
          activityName?: string(name='ActivityName'),
          count?: string(name='Count'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          type?: string(name='Type'),
        }
      ](name='Snapshot')
      }(name='SnapshotList'),
      summaryList?: {
        summary?: [ 
        {
          activityName?: string(name='ActivityName'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          type?: string(name='Type'),
        }
      ](name='Summary')
      }(name='SummaryList'),
      tags?: {
        tag?: [ string ](name='Tag')
      }(name='Tags'),
      title?: string(name='Title'),
      width?: string(name='Width'),
    }
  ](name='Media')
  }(name='MediaList'),
  nonExistFileURLs?: {
    fileURL?: [ string ](name='FileURL')
  }(name='NonExistFileURLs'),
  requestId?: string(name='RequestId'),
}

model QueryMediaListByURLResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaListByURLResponseBody(name='body'),
}

async function queryMediaListByURL(request: QueryMediaListByURLRequest): QueryMediaListByURLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMediaListByURL', 'POST', '/', 'json', false, 'json', request);
}

model QueryMediaWorkflowExecutionListRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  runIds: string(name='RunIds', position='Query'),
}

model QueryMediaWorkflowExecutionListResponseBody = {
  mediaWorkflowExecutionList?: {
    mediaWorkflowExecution?: [ 
    {
      activityList?: {
        activity?: [ 
        {
          code?: string(name='Code'),
          endTime?: string(name='EndTime'),
          jobId?: string(name='JobId'),
          MNSMessageResult?: {
            errorCode?: string(name='ErrorCode'),
            errorMessage?: string(name='ErrorMessage'),
            messageId?: string(name='MessageId'),
          }(name='MNSMessageResult'),
          message?: string(name='Message'),
          name?: string(name='Name'),
          startTime?: string(name='StartTime'),
          state?: string(name='State'),
          type?: string(name='Type'),
        }
      ](name='Activity')
      }(name='ActivityList'),
      creationTime?: string(name='CreationTime'),
      input?: {
        inputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='InputFile'),
        userData?: string(name='UserData'),
      }(name='Input'),
      mediaId?: string(name='MediaId'),
      mediaWorkflowId?: string(name='MediaWorkflowId'),
      name?: string(name='Name'),
      runId?: string(name='RunId'),
      state?: string(name='State'),
    }
  ](name='MediaWorkflowExecution')
  }(name='MediaWorkflowExecutionList'),
  nonExistRunIds?: {
    runId?: [ string ](name='RunId')
  }(name='NonExistRunIds'),
  requestId?: string(name='RequestId'),
}

model QueryMediaWorkflowExecutionListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaWorkflowExecutionListResponseBody(name='body'),
}

async function queryMediaWorkflowExecutionList(request: QueryMediaWorkflowExecutionListRequest): QueryMediaWorkflowExecutionListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMediaWorkflowExecutionList', 'POST', '/', 'json', false, 'json', request);
}

model QueryMediaWorkflowListRequest {
  mediaWorkflowIds: string(name='MediaWorkflowIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryMediaWorkflowListResponseBody = {
  mediaWorkflowList?: {
    mediaWorkflow?: [ 
    {
      creationTime?: string(name='CreationTime'),
      mediaWorkflowId?: string(name='MediaWorkflowId'),
      name?: string(name='Name'),
      state?: string(name='State'),
      topology?: string(name='Topology'),
      triggerMode?: string(name='TriggerMode'),
    }
  ](name='MediaWorkflow')
  }(name='MediaWorkflowList'),
  nonExistMediaWorkflowIds?: {
    mediaWorkflowId?: [ string ](name='MediaWorkflowId')
  }(name='NonExistMediaWorkflowIds'),
  requestId?: string(name='RequestId'),
}

model QueryMediaWorkflowListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaWorkflowListResponseBody(name='body'),
}

async function queryMediaWorkflowList(request: QueryMediaWorkflowListRequest): QueryMediaWorkflowListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMediaWorkflowList', 'POST', '/', 'json', false, 'json', request);
}

model QueryPipelineListRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineIds: string(name='PipelineIds', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryPipelineListResponseBody = {
  nonExistPids?: {
    string?: [ string ](name='String')
  }(name='NonExistPids'),
  pipelineList?: {
    pipeline?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      notifyConfig?: {
        mqTag?: string(name='MqTag'),
        mqTopic?: string(name='MqTopic'),
        queueName?: string(name='QueueName'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      quotaAllocate?: long(name='QuotaAllocate'),
      role?: string(name='Role'),
      speed?: string(name='Speed'),
      speedLevel?: long(name='SpeedLevel'),
      state?: string(name='State'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
}

model QueryPipelineListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryPipelineListResponseBody(name='body'),
}

async function queryPipelineList(request: QueryPipelineListRequest): QueryPipelineListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryPipelineList', 'POST', '/', 'json', false, 'json', request);
}

model QuerySmarttagJobRequest {
  jobId: string(name='JobId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  params?: string(name='Params', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QuerySmarttagJobResponseBody = {
  jobStatus?: string(name='JobStatus'),
  requestId?: string(name='RequestId'),
  results?: {
    result?: [ 
    {
      data?: string(name='Data'),
      type?: string(name='Type'),
    }
  ](name='Result')
  }(name='Results'),
  userData?: string(name='UserData'),
}

model QuerySmarttagJobResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySmarttagJobResponseBody(name='body'),
}

async function querySmarttagJob(request: QuerySmarttagJobRequest): QuerySmarttagJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QuerySmarttagJob', 'POST', '/', 'json', false, 'json', request);
}

model QuerySmarttagTemplateListRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
}

model QuerySmarttagTemplateListResponseBody = {
  requestId?: string(name='RequestId'),
  templates?: {
    template?: [ 
    {
      analyseTypes?: string(name='AnalyseTypes'),
      faceCategoryIds?: string(name='FaceCategoryIds'),
      faceCustomParamsConfig?: string(name='FaceCustomParamsConfig'),
      industry?: string(name='Industry'),
      isDefault?: boolean(name='IsDefault'),
      keywordConfig?: string(name='KeywordConfig'),
      knowledgeConfig?: string(name='KnowledgeConfig'),
      labelType?: string(name='LabelType'),
      labelVersion?: string(name='LabelVersion'),
      scene?: string(name='Scene'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
    }
  ](name='Template')
  }(name='Templates'),
}

model QuerySmarttagTemplateListResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySmarttagTemplateListResponseBody(name='body'),
}

async function querySmarttagTemplateList(request: QuerySmarttagTemplateListRequest): QuerySmarttagTemplateListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QuerySmarttagTemplateList', 'POST', '/', 'json', false, 'json', request);
}

model QuerySnapshotJobListRequest {
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange', position='Query'),
  maximumPageSize?: long(name='MaximumPageSize', minimum=1, maximum=100, position='Query'),
  nextPageToken?: string(name='NextPageToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId?: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snapshotJobIds?: string(name='SnapshotJobIds', position='Query'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange', position='Query'),
  state?: string(name='State', position='Query'),
}

model QuerySnapshotJobListResponseBody = {
  nextPageToken?: string(name='NextPageToken'),
  nonExistSnapshotJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistSnapshotJobIds'),
  requestId?: string(name='RequestId'),
  snapshotJobList?: {
    snapshotJob?: [ 
    {
      code?: string(name='Code'),
      count?: string(name='Count'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        roleArn?: string(name='RoleArn'),
      }(name='Input'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      snapshotConfig?: {
        frameType?: string(name='FrameType'),
        height?: string(name='Height'),
        interval?: string(name='Interval'),
        num?: string(name='Num'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='OutputFile'),
        tileOut?: {
          cellHeight?: string(name='CellHeight'),
          cellSelStep?: string(name='CellSelStep'),
          cellWidth?: string(name='CellWidth'),
          color?: string(name='Color'),
          columns?: string(name='Columns'),
          isKeepCellPic?: string(name='IsKeepCellPic'),
          lines?: string(name='Lines'),
          margin?: string(name='Margin'),
          padding?: string(name='Padding'),
        }(name='TileOut'),
        tileOutputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='TileOutputFile'),
        time?: string(name='Time'),
        width?: string(name='Width'),
      }(name='SnapshotConfig'),
      state?: string(name='State'),
      tileCount?: string(name='TileCount'),
      userData?: string(name='UserData'),
    }
  ](name='SnapshotJob')
  }(name='SnapshotJobList'),
}

model QuerySnapshotJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySnapshotJobListResponseBody(name='body'),
}

async function querySnapshotJobList(request: QuerySnapshotJobListRequest): QuerySnapshotJobListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QuerySnapshotJobList', 'POST', '/', 'json', false, 'json', request);
}

model QuerySubtitleJobListRequest {
  jobIds?: string(name='JobIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QuerySubtitleJobListResponseBody = {
  jobList?: {
    job?: [ 
    {
      inputConfig?: string(name='InputConfig'),
      jobId?: string(name='JobId'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      outputConfig?: string(name='OutputConfig'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
}

model QuerySubtitleJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySubtitleJobListResponseBody(name='body'),
}

async function querySubtitleJobList(request: QuerySubtitleJobListRequest): QuerySubtitleJobListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QuerySubtitleJobList', 'POST', '/', 'json', false, 'json', request);
}

model QueryTemplateListRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  templateIds: string(name='TemplateIds', position='Query'),
}

model QueryTemplateListResponseBody = {
  nonExistTids?: {
    string?: [ string ](name='String')
  }(name='NonExistTids'),
  requestId?: string(name='RequestId'),
  templateList?: {
    template?: [ 
    {
      audio?: {
        bitrate?: string(name='Bitrate'),
        channels?: string(name='Channels'),
        codec?: string(name='Codec'),
        profile?: string(name='Profile'),
        qscale?: string(name='Qscale'),
        remove?: string(name='Remove'),
        samplerate?: string(name='Samplerate'),
      }(name='Audio'),
      container?: {
        format?: string(name='Format'),
      }(name='Container'),
      id?: string(name='Id'),
      muxConfig?: {
        gif?: {
          ditherMode?: string(name='DitherMode'),
          finalDelay?: string(name='FinalDelay'),
          isCustomPalette?: string(name='IsCustomPalette'),
          loop?: string(name='Loop'),
        }(name='Gif'),
        segment?: {
          duration?: string(name='Duration'),
        }(name='Segment'),
        webp?: {
          loop?: string(name='Loop'),
        }(name='Webp'),
      }(name='MuxConfig'),
      name?: string(name='Name'),
      state?: string(name='State'),
      transConfig?: {
        adjDarMethod?: string(name='AdjDarMethod'),
        isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
        isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
        isCheckReso?: string(name='IsCheckReso'),
        isCheckResoFail?: string(name='IsCheckResoFail'),
        isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
        isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
        transMode?: string(name='TransMode'),
      }(name='TransConfig'),
      video?: {
        bitrate?: string(name='Bitrate'),
        bitrateBnd?: {
          max?: string(name='Max'),
          min?: string(name='Min'),
        }(name='BitrateBnd'),
        bufsize?: string(name='Bufsize'),
        codec?: string(name='Codec'),
        crf?: string(name='Crf'),
        crop?: string(name='Crop'),
        degrain?: string(name='Degrain'),
        fps?: string(name='Fps'),
        gop?: string(name='Gop'),
        height?: string(name='Height'),
        longShortMode?: string(name='LongShortMode'),
        maxFps?: string(name='MaxFps'),
        maxrate?: string(name='Maxrate'),
        pad?: string(name='Pad'),
        pixFmt?: string(name='PixFmt'),
        preset?: string(name='Preset'),
        profile?: string(name='Profile'),
        qscale?: string(name='Qscale'),
        remove?: string(name='Remove'),
        resoPriority?: string(name='ResoPriority'),
        scanMode?: string(name='ScanMode'),
        width?: string(name='Width'),
      }(name='Video'),
    }
  ](name='Template')
  }(name='TemplateList'),
}

model QueryTemplateListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTemplateListResponseBody(name='body'),
}

async function queryTemplateList(request: QueryTemplateListRequest): QueryTemplateListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryTemplateList', 'POST', '/', 'json', false, 'json', request);
}

model QueryVideoQualityJobRequest {
  jobId: string(name='JobId', position='Query'),
  userId?: long(name='UserId', minimum=0, maximum=999999999999999999, position='Query'),
}

model QueryVideoQualityJobResponseBody = {
  code?: string(name='Code'),
  job?: {
    jobId?: string(name='JobId'),
    message?: string(name='Message'),
    output?: string(name='Output'),
    status?: string(name='Status'),
    userId?: long(name='UserId'),
    videoQualityResults?: string(name='VideoQualityResults'),
  }(name='Job'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryVideoQualityJobResponse = {
  headers: map[string]string(name='headers'),
  body: QueryVideoQualityJobResponseBody(name='body'),
}

async function queryVideoQualityJob(request: QueryVideoQualityJobRequest): QueryVideoQualityJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryVideoQualityJob', 'POST', '/', 'json', false, 'json', request);
}

model QueryWaterMarkTemplateListRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  waterMarkTemplateIds: string(name='WaterMarkTemplateIds', position='Query'),
}

model QueryWaterMarkTemplateListResponseBody = {
  nonExistWids?: {
    string?: [ string ](name='String')
  }(name='NonExistWids'),
  requestId?: string(name='RequestId'),
  waterMarkTemplateList?: {
    waterMarkTemplate?: [ 
    {
      dx?: string(name='Dx'),
      dy?: string(name='Dy'),
      height?: string(name='Height'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      ratioRefer?: {
        dx?: string(name='Dx'),
        dy?: string(name='Dy'),
        height?: string(name='Height'),
        width?: string(name='Width'),
      }(name='RatioRefer'),
      referPos?: string(name='ReferPos'),
      state?: string(name='State'),
      timeline?: {
        duration?: string(name='Duration'),
        start?: string(name='Start'),
      }(name='Timeline'),
      type?: string(name='Type'),
      width?: string(name='Width'),
    }
  ](name='WaterMarkTemplate')
  }(name='WaterMarkTemplateList'),
}

model QueryWaterMarkTemplateListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryWaterMarkTemplateListResponseBody(name='body'),
}

async function queryWaterMarkTemplateList(request: QueryWaterMarkTemplateListRequest): QueryWaterMarkTemplateListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryWaterMarkTemplateList', 'POST', '/', 'json', false, 'json', request);
}

model RefreshCdnDomainConfigsCacheRequest {
  domains: string(name='Domains', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model RefreshCdnDomainConfigsCacheResponseBody = {
  failedDomains?: {
    string?: [ string ](name='String')
  }(name='FailedDomains'),
  requestId?: string(name='RequestId'),
  sucessDomains?: {
    string?: [ string ](name='String')
  }(name='SucessDomains'),
}

model RefreshCdnDomainConfigsCacheResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshCdnDomainConfigsCacheResponseBody(name='body'),
}

async function refreshCdnDomainConfigsCache(request: RefreshCdnDomainConfigsCacheRequest): RefreshCdnDomainConfigsCacheResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RefreshCdnDomainConfigsCache', 'POST', '/', 'json', false, 'json', request);
}

model RegisterCustomFaceRequest {
  categoryId: string(name='CategoryId', position='Query'),
  imageUrl: string(name='ImageUrl', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  personId: string(name='PersonId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RegisterCustomFaceResponseBody = {
  faceId?: string(name='FaceId'),
  requestId?: string(name='RequestId'),
}

model RegisterCustomFaceResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterCustomFaceResponseBody(name='body'),
}

async function registerCustomFace(request: RegisterCustomFaceRequest): RegisterCustomFaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RegisterCustomFace', 'POST', '/', 'json', false, 'json', request);
}

model ReportCensorJobResultRequest {
  detail?: string(name='Detail', position='Query'),
  jobId: string(name='JobId', position='Query'),
  label: string(name='Label', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ReportCensorJobResultResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model ReportCensorJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportCensorJobResultResponseBody(name='body'),
}

async function reportCensorJobResult(request: ReportCensorJobResultRequest): ReportCensorJobResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReportCensorJobResult', 'POST', '/', 'json', false, 'json', request);
}

model ReportFpShotJobResultRequest {
  details?: string(name='Details', position='Query'),
  jobId: string(name='JobId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  result: string(name='Result', position='Query'),
}

model ReportFpShotJobResultResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model ReportFpShotJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportFpShotJobResultResponseBody(name='body'),
}

async function reportFpShotJobResult(request: ReportFpShotJobResultRequest): ReportFpShotJobResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReportFpShotJobResult', 'POST', '/', 'json', false, 'json', request);
}

model SearchMediaRequest {
  cateId?: string(name='CateId', position='Query'),
  description?: string(name='Description', position='Query'),
  from?: string(name='From', position='Query'),
  keyWord?: string(name='KeyWord', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
  tag?: string(name='Tag', position='Query'),
  title?: string(name='Title', position='Query'),
  to?: string(name='To', position='Query'),
}

model SearchMediaResponseBody = {
  mediaList?: {
    media?: [ 
    {
      bitrate?: string(name='Bitrate'),
      cateId?: long(name='CateId'),
      coverURL?: string(name='CoverURL'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      duration?: string(name='Duration'),
      file?: {
        state?: string(name='State'),
        URL?: string(name='URL'),
      }(name='File'),
      format?: string(name='Format'),
      fps?: string(name='Fps'),
      height?: string(name='Height'),
      mediaId?: string(name='MediaId'),
      publishState?: string(name='PublishState'),
      runIdList?: {
        runId?: [ string ](name='RunId')
      }(name='RunIdList'),
      size?: string(name='Size'),
      tags?: {
        tag?: [ string ](name='Tag')
      }(name='Tags'),
      title?: string(name='Title'),
      width?: string(name='Width'),
    }
  ](name='Media')
  }(name='MediaList'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalNum?: long(name='TotalNum'),
}

model SearchMediaResponse = {
  headers: map[string]string(name='headers'),
  body: SearchMediaResponseBody(name='body'),
}

async function searchMedia(request: SearchMediaRequest): SearchMediaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchMedia', 'POST', '/', 'json', false, 'json', request);
}

model SearchMediaWorkflowRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  stateList?: string(name='StateList', position='Query'),
}

model SearchMediaWorkflowResponseBody = {
  mediaWorkflowList?: {
    mediaWorkflow?: [ 
    {
      creationTime?: string(name='CreationTime'),
      mediaWorkflowId?: string(name='MediaWorkflowId'),
      name?: string(name='Name'),
      state?: string(name='State'),
      topology?: string(name='Topology'),
      triggerMode?: string(name='TriggerMode'),
    }
  ](name='MediaWorkflow')
  }(name='MediaWorkflowList'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model SearchMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: SearchMediaWorkflowResponseBody(name='body'),
}

async function searchMediaWorkflow(request: SearchMediaWorkflowRequest): SearchMediaWorkflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchMediaWorkflow', 'POST', '/', 'json', false, 'json', request);
}

model SearchPipelineRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  state?: string(name='State', position='Query'),
}

model SearchPipelineResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  pipelineList?: {
    pipeline?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      notifyConfig?: {
        mqTag?: string(name='MqTag'),
        mqTopic?: string(name='MqTopic'),
        queueName?: string(name='QueueName'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      quotaAllocate?: long(name='QuotaAllocate'),
      role?: string(name='Role'),
      speed?: string(name='Speed'),
      speedLevel?: long(name='SpeedLevel'),
      state?: string(name='State'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model SearchPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: SearchPipelineResponseBody(name='body'),
}

async function searchPipeline(request: SearchPipelineRequest): SearchPipelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchPipeline', 'POST', '/', 'json', false, 'json', request);
}

model SearchTemplateRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  state?: string(name='State', position='Query'),
}

model SearchTemplateResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  templateList?: {
    template?: [ 
    {
      audio?: {
        bitrate?: string(name='Bitrate'),
        channels?: string(name='Channels'),
        codec?: string(name='Codec'),
        profile?: string(name='Profile'),
        qscale?: string(name='Qscale'),
        remove?: string(name='Remove'),
        samplerate?: string(name='Samplerate'),
      }(name='Audio'),
      container?: {
        format?: string(name='Format'),
      }(name='Container'),
      id?: string(name='Id'),
      muxConfig?: {
        gif?: {
          ditherMode?: string(name='DitherMode'),
          finalDelay?: string(name='FinalDelay'),
          isCustomPalette?: string(name='IsCustomPalette'),
          loop?: string(name='Loop'),
        }(name='Gif'),
        segment?: {
          duration?: string(name='Duration'),
        }(name='Segment'),
      }(name='MuxConfig'),
      name?: string(name='Name'),
      state?: string(name='State'),
      transConfig?: {
        adjDarMethod?: string(name='AdjDarMethod'),
        isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
        isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
        isCheckReso?: string(name='IsCheckReso'),
        isCheckResoFail?: string(name='IsCheckResoFail'),
        isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
        isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
        transMode?: string(name='TransMode'),
      }(name='TransConfig'),
      video?: {
        bitrate?: string(name='Bitrate'),
        bitrateBnd?: {
          max?: string(name='Max'),
          min?: string(name='Min'),
        }(name='BitrateBnd'),
        bufsize?: string(name='Bufsize'),
        codec?: string(name='Codec'),
        crf?: string(name='Crf'),
        crop?: string(name='Crop'),
        degrain?: string(name='Degrain'),
        fps?: string(name='Fps'),
        gop?: string(name='Gop'),
        height?: string(name='Height'),
        longShortMode?: string(name='LongShortMode'),
        maxFps?: string(name='MaxFps'),
        maxrate?: string(name='Maxrate'),
        pad?: string(name='Pad'),
        pixFmt?: string(name='PixFmt'),
        preset?: string(name='Preset'),
        profile?: string(name='Profile'),
        qscale?: string(name='Qscale'),
        remove?: string(name='Remove'),
        scanMode?: string(name='ScanMode'),
        width?: string(name='Width'),
      }(name='Video'),
    }
  ](name='Template')
  }(name='TemplateList'),
  totalCount?: long(name='TotalCount'),
}

model SearchTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: SearchTemplateResponseBody(name='body'),
}

async function searchTemplate(request: SearchTemplateRequest): SearchTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchTemplate', 'POST', '/', 'json', false, 'json', request);
}

model SearchWaterMarkTemplateRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  state?: string(name='State', position='Query'),
}

model SearchWaterMarkTemplateResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  waterMarkTemplateList?: {
    waterMarkTemplate?: [ 
    {
      dx?: string(name='Dx'),
      dy?: string(name='Dy'),
      height?: string(name='Height'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      ratioRefer?: {
        dx?: string(name='Dx'),
        dy?: string(name='Dy'),
        height?: string(name='Height'),
        width?: string(name='Width'),
      }(name='RatioRefer'),
      referPos?: string(name='ReferPos'),
      state?: string(name='State'),
      timeline?: {
        duration?: string(name='Duration'),
        start?: string(name='Start'),
      }(name='Timeline'),
      type?: string(name='Type'),
      width?: string(name='Width'),
    }
  ](name='WaterMarkTemplate')
  }(name='WaterMarkTemplateList'),
}

model SearchWaterMarkTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: SearchWaterMarkTemplateResponseBody(name='body'),
}

async function searchWaterMarkTemplate(request: SearchWaterMarkTemplateRequest): SearchWaterMarkTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchWaterMarkTemplate', 'POST', '/', 'json', false, 'json', request);
}

model SetAuthConfigRequest {
  key1?: string(name='Key1', position='Query'),
  key2?: string(name='Key2', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model SetAuthConfigResponseBody = {
  key1?: string(name='Key1'),
  key2?: string(name='Key2'),
  requestId?: string(name='RequestId'),
}

model SetAuthConfigResponse = {
  headers: map[string]string(name='headers'),
  body: SetAuthConfigResponseBody(name='body'),
}

async function setAuthConfig(request: SetAuthConfigRequest): SetAuthConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetAuthConfig', 'POST', '/', 'json', false, 'json', request);
}

model SubmitAnalysisJobRequest {
  analysisConfig?: string(name='AnalysisConfig', position='Query'),
  input: string(name='Input', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId: string(name='PipelineId', position='Query'),
  priority?: string(name='Priority', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model SubmitAnalysisJobResponseBody = {
  analysisJob?: {
    analysisConfig?: {
      propertiesControl?: {
        crop?: {
          height?: string(name='Height'),
          left?: string(name='Left'),
          mode?: string(name='Mode'),
          top?: string(name='Top'),
          width?: string(name='Width'),
        }(name='Crop'),
        deinterlace?: string(name='Deinterlace'),
      }(name='PropertiesControl'),
      qualityControl?: {
        methodStreaming?: string(name='MethodStreaming'),
        rateQuality?: string(name='RateQuality'),
      }(name='QualityControl'),
    }(name='AnalysisConfig'),
    code?: string(name='Code'),
    creationTime?: string(name='CreationTime'),
    id?: string(name='Id'),
    inputFile?: {
      bucket?: string(name='Bucket'),
      location?: string(name='Location'),
      object?: string(name='Object'),
    }(name='InputFile'),
    MNSMessageResult?: {
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      messageId?: string(name='MessageId'),
    }(name='MNSMessageResult'),
    message?: string(name='Message'),
    percent?: long(name='Percent'),
    pipelineId?: string(name='PipelineId'),
    priority?: string(name='Priority'),
    state?: string(name='State'),
    templateList?: {
      template?: [ 
      {
        audio?: {
          bitrate?: string(name='Bitrate'),
          channels?: string(name='Channels'),
          codec?: string(name='Codec'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          samplerate?: string(name='Samplerate'),
        }(name='Audio'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        id?: string(name='Id'),
        muxConfig?: {
          gif?: {
            finalDelay?: string(name='FinalDelay'),
            loop?: string(name='Loop'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
        }(name='MuxConfig'),
        name?: string(name='Name'),
        state?: string(name='State'),
        transConfig?: {
          transMode?: string(name='TransMode'),
        }(name='TransConfig'),
        video?: {
          bitrate?: string(name='Bitrate'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          bufsize?: string(name='Bufsize'),
          codec?: string(name='Codec'),
          crf?: string(name='Crf'),
          degrain?: string(name='Degrain'),
          fps?: string(name='Fps'),
          gop?: string(name='Gop'),
          height?: string(name='Height'),
          maxrate?: string(name='Maxrate'),
          pixFmt?: string(name='PixFmt'),
          preset?: string(name='Preset'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          scanMode?: string(name='ScanMode'),
          width?: string(name='Width'),
        }(name='Video'),
      }
    ](name='Template')
    }(name='TemplateList'),
    userData?: string(name='UserData'),
  }(name='AnalysisJob'),
  requestId?: string(name='RequestId'),
}

model SubmitAnalysisJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitAnalysisJobResponseBody(name='body'),
}

async function submitAnalysisJob(request: SubmitAnalysisJobRequest): SubmitAnalysisJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitAnalysisJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitComplexJobRequest {
  complexConfigs: string(name='ComplexConfigs', position='Query'),
  inputs: string(name='Inputs', position='Query'),
  outputBucket: string(name='OutputBucket', position='Query'),
  outputLocation?: string(name='OutputLocation', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  transcodeOutput: string(name='TranscodeOutput', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model SubmitComplexJobResponseBody = {
  complexJob?: {
    code?: string(name='Code'),
    complexEditingConfigs?: {
      complexEditingConfigs?: [ 
      {
        editing?: {
          clipList?: {
            clip?: [ 
            {
              effects?: {
                effect?: [ 
                {
                  effect?: string(name='Effect'),
                  effectConfig?: string(name='EffectConfig'),
                }
              ](name='Effect')
              }(name='Effects'),
              id?: string(name='Id'),
              in?: string(name='In'),
              out?: string(name='Out'),
              sourceID?: string(name='SourceID'),
              sourceStrmMap?: string(name='SourceStrmMap'),
              sourceType?: string(name='SourceType'),
              type?: string(name='Type'),
            }
          ](name='Clip')
          }(name='ClipList'),
          timeline?: {
            timelineConfig?: {
              timelineConfigAudio?: {
                channelLayout?: string(name='ChannelLayout'),
                channels?: string(name='Channels'),
                samplerate?: string(name='Samplerate'),
              }(name='TimelineConfigAudio'),
              timelineConfigVideo?: {
                bgColor?: string(name='BgColor'),
                fps?: string(name='Fps'),
                height?: string(name='Height'),
                isGpuData?: string(name='IsGpuData'),
                isOneTrackData?: string(name='IsOneTrackData'),
                reclosePrec?: string(name='ReclosePrec'),
                renderRatio?: string(name='RenderRatio'),
                width?: string(name='Width'),
              }(name='TimelineConfigVideo'),
            }(name='TimelineConfig'),
            trackList?: {
              track?: [ 
              {
                clips?: {
                  clip?: [ 
                  {
                    clipsConfig?: {
                      clipsConfigVideo?: {
                        l?: string(name='L'),
                        t?: string(name='T'),
                      }(name='ClipsConfigVideo'),
                    }(name='ClipsConfig'),
                    in?: string(name='In'),
                    out?: string(name='Out'),
                    clipID?: string(name='clipID'),
                  }
                ](name='Clip')
                }(name='Clips'),
                id?: string(name='Id'),
                order?: string(name='Order'),
                type?: string(name='Type'),
              }
            ](name='Track')
            }(name='TrackList'),
          }(name='Timeline'),
        }(name='Editing'),
      }
    ](name='ComplexEditingConfigs')
    }(name='ComplexEditingConfigs'),
    creationTime?: string(name='CreationTime'),
    finishTime?: string(name='FinishTime'),
    inputs?: {
      inputs?: [ 
      {
        editingInputs?: {
          editingInput?: [ 
          {
            id?: string(name='Id'),
            inputConfig?: {
              deinterlaceMethod?: string(name='DeinterlaceMethod'),
              isNormalSar?: string(name='IsNormalSar'),
            }(name='InputConfig'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
          }
        ](name='EditingInput')
        }(name='EditingInputs'),
      }
    ](name='Inputs')
    }(name='Inputs'),
    jobId?: string(name='JobId'),
    MNSMessageResult?: {
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      messageId?: string(name='MessageId'),
    }(name='MNSMessageResult'),
    message?: string(name='Message'),
    percent?: long(name='Percent'),
    pipelineId?: string(name='PipelineId'),
    state?: string(name='State'),
    transcodeOutput?: {
      audio?: {
        bitrate?: string(name='Bitrate'),
        channels?: string(name='Channels'),
        codec?: string(name='Codec'),
        profile?: string(name='Profile'),
        qscale?: string(name='Qscale'),
        samplerate?: string(name='Samplerate'),
        volume?: {
          level?: string(name='Level'),
          method?: string(name='Method'),
        }(name='Volume'),
      }(name='Audio'),
      audioStreamMap?: string(name='AudioStreamMap'),
      clip?: {
        timeSpan?: {
          duration?: string(name='Duration'),
          seek?: string(name='Seek'),
        }(name='TimeSpan'),
      }(name='Clip'),
      container?: {
        format?: string(name='Format'),
      }(name='Container'),
      deWatermark?: string(name='DeWatermark'),
      digiWaterMark?: {
        alpha?: string(name='Alpha'),
        inputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='InputFile'),
        type?: string(name='Type'),
      }(name='DigiWaterMark'),
      encryption?: {
        id?: string(name='Id'),
        key?: string(name='Key'),
        keyType?: string(name='KeyType'),
        keyUri?: string(name='KeyUri'),
        skipCnt?: string(name='SkipCnt'),
        type?: string(name='Type'),
      }(name='Encryption'),
      m3U8NonStandardSupport?: {
        TS?: {
          md5Support?: boolean(name='Md5Support'),
          sizeSupport?: boolean(name='SizeSupport'),
        }(name='TS'),
      }(name='M3U8NonStandardSupport'),
      mergeConfigUrl?: string(name='MergeConfigUrl'),
      mergeList?: {
        merge?: [ 
        {
          duration?: string(name='Duration'),
          mergeURL?: string(name='MergeURL'),
          roleArn?: string(name='RoleArn'),
          start?: string(name='Start'),
        }
      ](name='Merge')
      }(name='MergeList'),
      muxConfig?: {
        gif?: {
          ditherMode?: string(name='DitherMode'),
          finalDelay?: string(name='FinalDelay'),
          isCustomPalette?: string(name='IsCustomPalette'),
          loop?: string(name='Loop'),
        }(name='Gif'),
        segment?: {
          duration?: string(name='Duration'),
        }(name='Segment'),
      }(name='MuxConfig'),
      outputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        roleArn?: string(name='RoleArn'),
      }(name='OutputFile'),
      priority?: string(name='Priority'),
      properties?: {
        bitrate?: string(name='Bitrate'),
        duration?: string(name='Duration'),
        fileFormat?: string(name='FileFormat'),
        fileSize?: string(name='FileSize'),
        format?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          formatLongName?: string(name='FormatLongName'),
          formatName?: string(name='FormatName'),
          numPrograms?: string(name='NumPrograms'),
          numStreams?: string(name='NumStreams'),
          size?: string(name='Size'),
          startTime?: string(name='StartTime'),
        }(name='Format'),
        fps?: string(name='Fps'),
        height?: string(name='Height'),
        streams?: {
          audioStreamList?: {
            audioStream?: [ 
            {
              bitrate?: string(name='Bitrate'),
              channelLayout?: string(name='ChannelLayout'),
              channels?: string(name='Channels'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              numFrames?: string(name='NumFrames'),
              sampleFmt?: string(name='SampleFmt'),
              samplerate?: string(name='Samplerate'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='AudioStream')
          }(name='AudioStreamList'),
          subtitleStreamList?: {
            subtitleStream?: [ 
            {
              index?: string(name='Index'),
              lang?: string(name='Lang'),
            }
          ](name='SubtitleStream')
          }(name='SubtitleStreamList'),
          videoStreamList?: {
            videoStream?: [ 
            {
              avgFPS?: string(name='AvgFPS'),
              bitrate?: string(name='Bitrate'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              dar?: string(name='Dar'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              hasBFrames?: string(name='HasBFrames'),
              height?: string(name='Height'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              level?: string(name='Level'),
              networkCost?: {
                avgBitrate?: string(name='AvgBitrate'),
                costBandwidth?: string(name='CostBandwidth'),
                preloadTime?: string(name='PreloadTime'),
              }(name='NetworkCost'),
              numFrames?: string(name='NumFrames'),
              pixFmt?: string(name='PixFmt'),
              profile?: string(name='Profile'),
              sar?: string(name='Sar'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
              width?: string(name='Width'),
            }
          ](name='VideoStream')
          }(name='VideoStreamList'),
        }(name='Streams'),
        width?: string(name='Width'),
      }(name='Properties'),
      rotate?: string(name='Rotate'),
      subtitleConfig?: {
        extSubtitleList?: {
          extSubtitle?: [ 
          {
            charEnc?: string(name='CharEnc'),
            fontName?: string(name='FontName'),
            input?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='Input'),
          }
        ](name='ExtSubtitle')
        }(name='ExtSubtitleList'),
        subtitleList?: {
          subtitle?: [ 
          {
            map?: string(name='Map'),
          }
        ](name='Subtitle')
        }(name='SubtitleList'),
      }(name='SubtitleConfig'),
      superReso?: {
        isHalfSample?: string(name='IsHalfSample'),
      }(name='SuperReso'),
      templateId?: string(name='TemplateId'),
      transConfig?: {
        adjDarMethod?: string(name='AdjDarMethod'),
        duration?: string(name='Duration'),
        isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
        isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
        isCheckReso?: string(name='IsCheckReso'),
        isCheckResoFail?: string(name='IsCheckResoFail'),
        isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
        isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
        transMode?: string(name='TransMode'),
      }(name='TransConfig'),
      userData?: string(name='UserData'),
      video?: {
        bitrate?: string(name='Bitrate'),
        bitrateBnd?: {
          max?: string(name='Max'),
          min?: string(name='Min'),
        }(name='BitrateBnd'),
        bufsize?: string(name='Bufsize'),
        codec?: string(name='Codec'),
        crf?: string(name='Crf'),
        crop?: string(name='Crop'),
        degrain?: string(name='Degrain'),
        fps?: string(name='Fps'),
        gop?: string(name='Gop'),
        height?: string(name='Height'),
        maxFps?: string(name='MaxFps'),
        maxrate?: string(name='Maxrate'),
        pad?: string(name='Pad'),
        pixFmt?: string(name='PixFmt'),
        preset?: string(name='Preset'),
        profile?: string(name='Profile'),
        qscale?: string(name='Qscale'),
        scanMode?: string(name='ScanMode'),
        width?: string(name='Width'),
      }(name='Video'),
      videoStreamMap?: string(name='VideoStreamMap'),
      waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
      waterMarkList?: {
        waterMark?: [ 
        {
          dx?: string(name='Dx'),
          dy?: string(name='Dy'),
          height?: string(name='Height'),
          inputFile?: {
            bucket?: string(name='Bucket'),
            location?: string(name='Location'),
            object?: string(name='Object'),
          }(name='InputFile'),
          referPos?: string(name='ReferPos'),
          type?: string(name='Type'),
          waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
          width?: string(name='Width'),
        }
      ](name='WaterMark')
      }(name='WaterMarkList'),
    }(name='transcodeOutput'),
  }(name='ComplexJob'),
  requestId?: string(name='RequestId'),
}

model SubmitComplexJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitComplexJobResponseBody(name='body'),
}

async function submitComplexJob(request: SubmitComplexJobRequest): SubmitComplexJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitComplexJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitEditingJobsRequest {
  editingInputs?: string(name='EditingInputs', position='Query'),
  editingJobOssFileRoleArn?: string(name='EditingJobOssFileRoleArn', position='Query'),
  editingJobOssFileUid?: long(name='EditingJobOssFileUid', position='Query'),
  editingJobOutputs?: string(name='EditingJobOutputs', position='Query'),
  editingJobURL?: string(name='EditingJobURL', position='Query'),
  outputBucket?: string(name='OutputBucket', position='Query'),
  outputLocation?: string(name='OutputLocation', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId?: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model SubmitEditingJobsResponseBody = {
  jobResultList?: {
    jobResult?: [ 
    {
      code?: string(name='Code'),
      job?: {
        code?: string(name='Code'),
        creationTime?: string(name='CreationTime'),
        editingConfig?: {
          audio?: {
            bitrate?: string(name='Bitrate'),
            channels?: string(name='Channels'),
            codec?: string(name='Codec'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            samplerate?: string(name='Samplerate'),
            volume?: {
              level?: string(name='Level'),
              method?: string(name='Method'),
            }(name='Volume'),
          }(name='Audio'),
          audioStreamMap?: string(name='AudioStreamMap'),
          clip?: {
            timeSpan?: {
              duration?: string(name='Duration'),
              seek?: string(name='Seek'),
            }(name='TimeSpan'),
          }(name='Clip'),
          container?: {
            format?: string(name='Format'),
          }(name='Container'),
          deWatermark?: string(name='DeWatermark'),
          digiWaterMark?: {
            alpha?: string(name='Alpha'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
            type?: string(name='Type'),
          }(name='DigiWaterMark'),
          editing?: {
            clipList?: {
              clip?: [ 
              {
                effects?: {
                  effect?: [ 
                  {
                    effect?: string(name='Effect'),
                    effectConfig?: string(name='EffectConfig'),
                  }
                ](name='Effect')
                }(name='Effects'),
                id?: string(name='Id'),
                in?: string(name='In'),
                out?: string(name='Out'),
                sourceID?: string(name='SourceID'),
                sourceStrmMap?: string(name='SourceStrmMap'),
                sourceType?: string(name='SourceType'),
                type?: string(name='Type'),
              }
            ](name='Clip')
            }(name='ClipList'),
            timeline?: {
              timelineConfig?: {
                timelineConfigAudio?: {
                  channelLayout?: string(name='ChannelLayout'),
                  channels?: string(name='Channels'),
                  samplerate?: string(name='Samplerate'),
                }(name='TimelineConfigAudio'),
                timelineConfigVideo?: {
                  bgColor?: string(name='BgColor'),
                  fps?: string(name='Fps'),
                  height?: string(name='Height'),
                  isGpuData?: string(name='IsGpuData'),
                  isOneTrackData?: string(name='IsOneTrackData'),
                  reclosePrec?: string(name='ReclosePrec'),
                  renderRatio?: string(name='RenderRatio'),
                  width?: string(name='Width'),
                }(name='TimelineConfigVideo'),
              }(name='TimelineConfig'),
              trackList?: {
                track?: [ 
                {
                  clips?: {
                    clip?: [ 
                    {
                      clipsConfig?: {
                        clipsConfigVideo?: {
                          l?: string(name='L'),
                          t?: string(name='T'),
                        }(name='ClipsConfigVideo'),
                      }(name='ClipsConfig'),
                      in?: string(name='In'),
                      out?: string(name='Out'),
                      clipID?: string(name='clipID'),
                    }
                  ](name='Clip')
                  }(name='Clips'),
                  id?: string(name='Id'),
                  order?: string(name='Order'),
                  type?: string(name='Type'),
                }
              ](name='Track')
              }(name='TrackList'),
            }(name='Timeline'),
          }(name='Editing'),
          encryption?: {
            id?: string(name='Id'),
            key?: string(name='Key'),
            keyType?: string(name='KeyType'),
            keyUri?: string(name='KeyUri'),
            skipCnt?: string(name='SkipCnt'),
            type?: string(name='Type'),
          }(name='Encryption'),
          m3U8NonStandardSupport?: {
            TS?: {
              md5Support?: boolean(name='Md5Support'),
              sizeSupport?: boolean(name='SizeSupport'),
            }(name='TS'),
          }(name='M3U8NonStandardSupport'),
          mergeConfigUrl?: string(name='MergeConfigUrl'),
          mergeList?: {
            merge?: [ 
            {
              duration?: string(name='Duration'),
              mergeURL?: string(name='MergeURL'),
              roleArn?: string(name='RoleArn'),
              start?: string(name='Start'),
            }
          ](name='Merge')
          }(name='MergeList'),
          muxConfig?: {
            gif?: {
              ditherMode?: string(name='DitherMode'),
              finalDelay?: string(name='FinalDelay'),
              isCustomPalette?: string(name='IsCustomPalette'),
              loop?: string(name='Loop'),
            }(name='Gif'),
            segment?: {
              duration?: string(name='Duration'),
            }(name='Segment'),
          }(name='MuxConfig'),
          outputFile?: {
            bucket?: string(name='Bucket'),
            location?: string(name='Location'),
            object?: string(name='Object'),
            roleArn?: string(name='RoleArn'),
          }(name='OutputFile'),
          priority?: string(name='Priority'),
          properties?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            fileFormat?: string(name='FileFormat'),
            fileSize?: string(name='FileSize'),
            format?: {
              bitrate?: string(name='Bitrate'),
              duration?: string(name='Duration'),
              formatLongName?: string(name='FormatLongName'),
              formatName?: string(name='FormatName'),
              numPrograms?: string(name='NumPrograms'),
              numStreams?: string(name='NumStreams'),
              size?: string(name='Size'),
              startTime?: string(name='StartTime'),
            }(name='Format'),
            fps?: string(name='Fps'),
            height?: string(name='Height'),
            streams?: {
              audioStreamList?: {
                audioStream?: [ 
                {
                  bitrate?: string(name='Bitrate'),
                  channelLayout?: string(name='ChannelLayout'),
                  channels?: string(name='Channels'),
                  codecLongName?: string(name='CodecLongName'),
                  codecName?: string(name='CodecName'),
                  codecTag?: string(name='CodecTag'),
                  codecTagString?: string(name='CodecTagString'),
                  codecTimeBase?: string(name='CodecTimeBase'),
                  duration?: string(name='Duration'),
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                  numFrames?: string(name='NumFrames'),
                  sampleFmt?: string(name='SampleFmt'),
                  samplerate?: string(name='Samplerate'),
                  startTime?: string(name='StartTime'),
                  timebase?: string(name='Timebase'),
                }
              ](name='AudioStream')
              }(name='AudioStreamList'),
              subtitleStreamList?: {
                subtitleStream?: [ 
                {
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                }
              ](name='SubtitleStream')
              }(name='SubtitleStreamList'),
              videoStreamList?: {
                videoStream?: [ 
                {
                  avgFPS?: string(name='AvgFPS'),
                  bitrate?: string(name='Bitrate'),
                  codecLongName?: string(name='CodecLongName'),
                  codecName?: string(name='CodecName'),
                  codecTag?: string(name='CodecTag'),
                  codecTagString?: string(name='CodecTagString'),
                  codecTimeBase?: string(name='CodecTimeBase'),
                  dar?: string(name='Dar'),
                  duration?: string(name='Duration'),
                  fps?: string(name='Fps'),
                  hasBFrames?: string(name='HasBFrames'),
                  height?: string(name='Height'),
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                  level?: string(name='Level'),
                  networkCost?: {
                    avgBitrate?: string(name='AvgBitrate'),
                    costBandwidth?: string(name='CostBandwidth'),
                    preloadTime?: string(name='PreloadTime'),
                  }(name='NetworkCost'),
                  numFrames?: string(name='NumFrames'),
                  pixFmt?: string(name='PixFmt'),
                  profile?: string(name='Profile'),
                  sar?: string(name='Sar'),
                  startTime?: string(name='StartTime'),
                  timebase?: string(name='Timebase'),
                  width?: string(name='Width'),
                }
              ](name='VideoStream')
              }(name='VideoStreamList'),
            }(name='Streams'),
            width?: string(name='Width'),
          }(name='Properties'),
          rotate?: string(name='Rotate'),
          subtitleConfig?: {
            extSubtitleList?: {
              extSubtitle?: [ 
              {
                charEnc?: string(name='CharEnc'),
                fontName?: string(name='FontName'),
                input?: {
                  bucket?: string(name='Bucket'),
                  location?: string(name='Location'),
                  object?: string(name='Object'),
                }(name='Input'),
              }
            ](name='ExtSubtitle')
            }(name='ExtSubtitleList'),
            subtitleList?: {
              subtitle?: [ 
              {
                map?: string(name='Map'),
              }
            ](name='Subtitle')
            }(name='SubtitleList'),
          }(name='SubtitleConfig'),
          superReso?: {
            isHalfSample?: string(name='IsHalfSample'),
          }(name='SuperReso'),
          templateId?: string(name='TemplateId'),
          transConfig?: {
            adjDarMethod?: string(name='AdjDarMethod'),
            duration?: string(name='Duration'),
            isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
            isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
            isCheckReso?: string(name='IsCheckReso'),
            isCheckResoFail?: string(name='IsCheckResoFail'),
            isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
            isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
            transMode?: string(name='TransMode'),
          }(name='TransConfig'),
          userData?: string(name='UserData'),
          video?: {
            bitrate?: string(name='Bitrate'),
            bitrateBnd?: {
              max?: string(name='Max'),
              min?: string(name='Min'),
            }(name='BitrateBnd'),
            bufsize?: string(name='Bufsize'),
            codec?: string(name='Codec'),
            crf?: string(name='Crf'),
            crop?: string(name='Crop'),
            degrain?: string(name='Degrain'),
            fps?: string(name='Fps'),
            gop?: string(name='Gop'),
            height?: string(name='Height'),
            maxFps?: string(name='MaxFps'),
            maxrate?: string(name='Maxrate'),
            pad?: string(name='Pad'),
            pixFmt?: string(name='PixFmt'),
            preset?: string(name='Preset'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            scanMode?: string(name='ScanMode'),
            width?: string(name='Width'),
          }(name='Video'),
          videoStreamMap?: string(name='VideoStreamMap'),
          waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
          waterMarkList?: {
            waterMark?: [ 
            {
              dx?: string(name='Dx'),
              dy?: string(name='Dy'),
              height?: string(name='Height'),
              inputFile?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='InputFile'),
              referPos?: string(name='ReferPos'),
              type?: string(name='Type'),
              waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
              width?: string(name='Width'),
            }
          ](name='WaterMark')
          }(name='WaterMarkList'),
        }(name='EditingConfig'),
        editingInputs?: {
          editingInput?: [ 
          {
            id?: string(name='Id'),
            inputConfig?: {
              deinterlaceMethod?: string(name='DeinterlaceMethod'),
              isNormalSar?: string(name='IsNormalSar'),
            }(name='InputConfig'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
          }
        ](name='EditingInput')
        }(name='EditingInputs'),
        finishTime?: string(name='FinishTime'),
        jobId?: string(name='JobId'),
        MNSMessageResult?: {
          errorCode?: string(name='ErrorCode'),
          errorMessage?: string(name='ErrorMessage'),
          messageId?: string(name='MessageId'),
        }(name='MNSMessageResult'),
        message?: string(name='Message'),
        percent?: long(name='Percent'),
        pipelineId?: string(name='PipelineId'),
        state?: string(name='State'),
      }(name='Job'),
      message?: string(name='Message'),
      success?: boolean(name='Success'),
    }
  ](name='JobResult')
  }(name='JobResultList'),
  requestId?: string(name='RequestId'),
}

model SubmitEditingJobsResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitEditingJobsResponseBody(name='body'),
}

async function submitEditingJobs(request: SubmitEditingJobsRequest): SubmitEditingJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitEditingJobs', 'POST', '/', 'json', false, 'json', request);
}

model SubmitFpDBDeleteJobRequest {
  delType?: string(name='DelType', position='Query'),
  fpDBId: string(name='FpDBId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId?: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model SubmitFpDBDeleteJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitFpDBDeleteJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFpDBDeleteJobResponseBody(name='body'),
}

async function submitFpDBDeleteJob(request: SubmitFpDBDeleteJobRequest): SubmitFpDBDeleteJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitFpDBDeleteJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitFpFileDeleteJobRequest {
  fileIds: string(name='FileIds', position='Query'),
  fpDBId: string(name='FpDBId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId?: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model SubmitFpFileDeleteJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitFpFileDeleteJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFpFileDeleteJobResponseBody(name='body'),
}

async function submitFpFileDeleteJob(request: SubmitFpFileDeleteJobRequest): SubmitFpFileDeleteJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitFpFileDeleteJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitFpShotJobRequest {
  fpShotConfig: string(name='FpShotConfig', position='Query'),
  input: string(name='Input', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId?: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model SubmitFpShotJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitFpShotJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFpShotJobResponseBody(name='body'),
}

async function submitFpShotJob(request: SubmitFpShotJobRequest): SubmitFpShotJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitFpShotJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitIProductionJobRequest {
  functionName: string(name='FunctionName', position='Query'),
  input?: string(name='Input', position='Query'),
  jobParams?: string(name='JobParams', position='Query'),
  modelId?: string(name='ModelId', position='Query'),
  notifyUrl?: string(name='NotifyUrl', position='Query'),
  output?: string(name='Output', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId?: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scheduleParams?: string(name='ScheduleParams', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model SubmitIProductionJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model SubmitIProductionJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitIProductionJobResponseBody(name='body'),
}

async function submitIProductionJob(request: SubmitIProductionJobRequest): SubmitIProductionJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitIProductionJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitInnerJobRequest {
  config?: string(name='Config', position='Query'),
  images?: string(name='Images', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId?: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  uid: long(name='Uid', position='Query'),
  video?: string(name='Video', position='Query'),
}

model SubmitInnerJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitInnerJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitInnerJobResponseBody(name='body'),
}

async function submitInnerJob(request: SubmitInnerJobRequest): SubmitInnerJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitInnerJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitJobsRequest {
  input: string(name='Input', position='Query'),
  outputBucket: string(name='OutputBucket', position='Query'),
  outputLocation?: string(name='OutputLocation', position='Query'),
  outputs: string(name='Outputs', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model SubmitJobsResponseBody = {
  jobResultList?: {
    jobResult?: [ 
    {
      code?: string(name='Code'),
      job?: {
        code?: string(name='Code'),
        creationTime?: string(name='CreationTime'),
        finishTime?: string(name='FinishTime'),
        input?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='Input'),
        jobId?: string(name='JobId'),
        MNSMessageResult?: {
          errorCode?: string(name='ErrorCode'),
          errorMessage?: string(name='ErrorMessage'),
          messageId?: string(name='MessageId'),
        }(name='MNSMessageResult'),
        message?: string(name='Message'),
        output?: {
          amixList?: {
            amix?: [ 
            {
              amixURL?: string(name='AmixURL'),
              duration?: string(name='Duration'),
              map?: string(name='Map'),
              mixDurMode?: string(name='MixDurMode'),
              start?: string(name='Start'),
            }
          ](name='Amix')
          }(name='AmixList'),
          audio?: {
            bitrate?: string(name='Bitrate'),
            channels?: string(name='Channels'),
            codec?: string(name='Codec'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            samplerate?: string(name='Samplerate'),
            volume?: {
              level?: string(name='Level'),
              method?: string(name='Method'),
            }(name='Volume'),
          }(name='Audio'),
          audioStreamMap?: string(name='AudioStreamMap'),
          clip?: {
            timeSpan?: {
              duration?: string(name='Duration'),
              seek?: string(name='Seek'),
            }(name='TimeSpan'),
          }(name='Clip'),
          container?: {
            format?: string(name='Format'),
          }(name='Container'),
          deWatermark?: string(name='DeWatermark'),
          digiWaterMark?: {
            alpha?: string(name='Alpha'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
            type?: string(name='Type'),
          }(name='DigiWaterMark'),
          encryption?: {
            id?: string(name='Id'),
            key?: string(name='Key'),
            keyType?: string(name='KeyType'),
            keyUri?: string(name='KeyUri'),
            skipCnt?: string(name='SkipCnt'),
            type?: string(name='Type'),
          }(name='Encryption'),
          m3U8NonStandardSupport?: {
            TS?: {
              md5Support?: boolean(name='Md5Support'),
              sizeSupport?: boolean(name='SizeSupport'),
            }(name='TS'),
          }(name='M3U8NonStandardSupport'),
          mergeConfigUrl?: string(name='MergeConfigUrl'),
          mergeList?: {
            merge?: [ 
            {
              duration?: string(name='Duration'),
              mergeURL?: string(name='MergeURL'),
              roleArn?: string(name='RoleArn'),
              start?: string(name='Start'),
            }
          ](name='Merge')
          }(name='MergeList'),
          muxConfig?: {
            gif?: {
              ditherMode?: string(name='DitherMode'),
              finalDelay?: string(name='FinalDelay'),
              isCustomPalette?: string(name='IsCustomPalette'),
              loop?: string(name='Loop'),
            }(name='Gif'),
            segment?: {
              duration?: string(name='Duration'),
            }(name='Segment'),
            webp?: {
              loop?: string(name='Loop'),
            }(name='Webp'),
          }(name='MuxConfig'),
          openingList?: {
            opening?: [ 
            {
              height?: string(name='Height'),
              start?: string(name='Start'),
              width?: string(name='Width'),
              openUrl?: string(name='openUrl'),
            }
          ](name='Opening')
          }(name='OpeningList'),
          outSubtitleList?: {
            outSubtitle?: [ 
            {
              map?: string(name='Map'),
              message?: string(name='Message'),
              outSubtitleFile?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
                roleArn?: string(name='RoleArn'),
              }(name='OutSubtitleFile'),
              success?: boolean(name='Success'),
            }
          ](name='OutSubtitle')
          }(name='OutSubtitleList'),
          outputFile?: {
            bucket?: string(name='Bucket'),
            location?: string(name='Location'),
            object?: string(name='Object'),
            roleArn?: string(name='RoleArn'),
          }(name='OutputFile'),
          priority?: string(name='Priority'),
          properties?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            fileFormat?: string(name='FileFormat'),
            fileSize?: string(name='FileSize'),
            format?: {
              bitrate?: string(name='Bitrate'),
              duration?: string(name='Duration'),
              formatLongName?: string(name='FormatLongName'),
              formatName?: string(name='FormatName'),
              numPrograms?: string(name='NumPrograms'),
              numStreams?: string(name='NumStreams'),
              size?: string(name='Size'),
              startTime?: string(name='StartTime'),
            }(name='Format'),
            fps?: string(name='Fps'),
            height?: string(name='Height'),
            streams?: {
              audioStreamList?: {
                audioStream?: [ 
                {
                  bitrate?: string(name='Bitrate'),
                  channelLayout?: string(name='ChannelLayout'),
                  channels?: string(name='Channels'),
                  codecLongName?: string(name='CodecLongName'),
                  codecName?: string(name='CodecName'),
                  codecTag?: string(name='CodecTag'),
                  codecTagString?: string(name='CodecTagString'),
                  codecTimeBase?: string(name='CodecTimeBase'),
                  duration?: string(name='Duration'),
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                  numFrames?: string(name='NumFrames'),
                  sampleFmt?: string(name='SampleFmt'),
                  samplerate?: string(name='Samplerate'),
                  startTime?: string(name='StartTime'),
                  timebase?: string(name='Timebase'),
                }
              ](name='AudioStream')
              }(name='AudioStreamList'),
              subtitleStreamList?: {
                subtitleStream?: [ 
                {
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                }
              ](name='SubtitleStream')
              }(name='SubtitleStreamList'),
              videoStreamList?: {
                videoStream?: [ 
                {
                  avgFPS?: string(name='AvgFPS'),
                  bitrate?: string(name='Bitrate'),
                  codecLongName?: string(name='CodecLongName'),
                  codecName?: string(name='CodecName'),
                  codecTag?: string(name='CodecTag'),
                  codecTagString?: string(name='CodecTagString'),
                  codecTimeBase?: string(name='CodecTimeBase'),
                  dar?: string(name='Dar'),
                  duration?: string(name='Duration'),
                  fps?: string(name='Fps'),
                  hasBFrames?: string(name='HasBFrames'),
                  height?: string(name='Height'),
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                  level?: string(name='Level'),
                  networkCost?: {
                    avgBitrate?: string(name='AvgBitrate'),
                    costBandwidth?: string(name='CostBandwidth'),
                    preloadTime?: string(name='PreloadTime'),
                  }(name='NetworkCost'),
                  numFrames?: string(name='NumFrames'),
                  pixFmt?: string(name='PixFmt'),
                  profile?: string(name='Profile'),
                  sar?: string(name='Sar'),
                  startTime?: string(name='StartTime'),
                  timebase?: string(name='Timebase'),
                  width?: string(name='Width'),
                }
              ](name='VideoStream')
              }(name='VideoStreamList'),
            }(name='Streams'),
            width?: string(name='Width'),
          }(name='Properties'),
          rotate?: string(name='Rotate'),
          subtitleConfig?: {
            extSubtitleList?: {
              extSubtitle?: [ 
              {
                charEnc?: string(name='CharEnc'),
                fontName?: string(name='FontName'),
                input?: {
                  bucket?: string(name='Bucket'),
                  location?: string(name='Location'),
                  object?: string(name='Object'),
                }(name='Input'),
              }
            ](name='ExtSubtitle')
            }(name='ExtSubtitleList'),
            subtitleList?: {
              subtitle?: [ 
              {
                map?: string(name='Map'),
              }
            ](name='Subtitle')
            }(name='SubtitleList'),
          }(name='SubtitleConfig'),
          superReso?: {
            isHalfSample?: string(name='IsHalfSample'),
          }(name='SuperReso'),
          tailSlateList?: {
            tailSlate?: [ 
            {
              bgColor?: string(name='BgColor'),
              blendDuration?: string(name='BlendDuration'),
              height?: string(name='Height'),
              isMergeAudio?: boolean(name='IsMergeAudio'),
              start?: string(name='Start'),
              tailUrl?: string(name='TailUrl'),
              width?: string(name='Width'),
            }
          ](name='TailSlate')
          }(name='TailSlateList'),
          templateId?: string(name='TemplateId'),
          transConfig?: {
            adjDarMethod?: string(name='AdjDarMethod'),
            isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
            isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
            isCheckReso?: string(name='IsCheckReso'),
            isCheckResoFail?: string(name='IsCheckResoFail'),
            isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
            isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
            transMode?: string(name='TransMode'),
          }(name='TransConfig'),
          userData?: string(name='UserData'),
          video?: {
            bitrate?: string(name='Bitrate'),
            bitrateBnd?: {
              max?: string(name='Max'),
              min?: string(name='Min'),
            }(name='BitrateBnd'),
            bufsize?: string(name='Bufsize'),
            codec?: string(name='Codec'),
            crf?: string(name='Crf'),
            crop?: string(name='Crop'),
            degrain?: string(name='Degrain'),
            fps?: string(name='Fps'),
            gop?: string(name='Gop'),
            height?: string(name='Height'),
            maxFps?: string(name='MaxFps'),
            maxrate?: string(name='Maxrate'),
            pad?: string(name='Pad'),
            pixFmt?: string(name='PixFmt'),
            preset?: string(name='Preset'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            resoPriority?: string(name='ResoPriority'),
            scanMode?: string(name='ScanMode'),
            width?: string(name='Width'),
          }(name='Video'),
          videoStreamMap?: string(name='VideoStreamMap'),
          waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
          waterMarkList?: {
            waterMark?: [ 
            {
              dx?: string(name='Dx'),
              dy?: string(name='Dy'),
              height?: string(name='Height'),
              inputFile?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='InputFile'),
              referPos?: string(name='ReferPos'),
              type?: string(name='Type'),
              waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
              width?: string(name='Width'),
            }
          ](name='WaterMark')
          }(name='WaterMarkList'),
        }(name='Output'),
        percent?: long(name='Percent'),
        pipelineId?: string(name='PipelineId'),
        state?: string(name='State'),
      }(name='Job'),
      message?: string(name='Message'),
      success?: boolean(name='Success'),
    }
  ](name='JobResult')
  }(name='JobResultList'),
  requestId?: string(name='RequestId'),
}

model SubmitJobsResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitJobsResponseBody(name='body'),
}

async function submitJobs(request: SubmitJobsRequest): SubmitJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitJobs', 'POST', '/', 'json', false, 'json', request);
}

model SubmitMediaCensorJobRequest {
  barrages?: string(name='Barrages', position='Query'),
  coverImages?: string(name='CoverImages', position='Query'),
  description?: string(name='Description', position='Query'),
  externalUrl?: string(name='ExternalUrl', position='Query'),
  input?: string(name='Input', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId?: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  title?: string(name='Title', position='Query'),
  userData?: string(name='UserData', position='Query'),
  videoCensorConfig: string(name='VideoCensorConfig', position='Query'),
}

model SubmitMediaCensorJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitMediaCensorJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitMediaCensorJobResponseBody(name='body'),
}

async function submitMediaCensorJob(request: SubmitMediaCensorJobRequest): SubmitMediaCensorJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitMediaCensorJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitMediaInfoJobRequest {
  async?: boolean(name='Async', position='Query'),
  input: string(name='Input', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId?: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model SubmitMediaInfoJobResponseBody = {
  mediaInfoJob?: {
    async?: boolean(name='Async'),
    code?: string(name='Code'),
    creationTime?: string(name='CreationTime'),
    input?: {
      bucket?: string(name='Bucket'),
      location?: string(name='Location'),
      object?: string(name='Object'),
    }(name='Input'),
    jobId?: string(name='JobId'),
    MNSMessageResult?: {
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      messageId?: string(name='MessageId'),
    }(name='MNSMessageResult'),
    message?: string(name='Message'),
    pipelineId?: string(name='PipelineId'),
    properties?: {
      bitrate?: string(name='Bitrate'),
      duration?: string(name='Duration'),
      fileFormat?: string(name='FileFormat'),
      fileSize?: string(name='FileSize'),
      format?: {
        bitrate?: string(name='Bitrate'),
        duration?: string(name='Duration'),
        formatLongName?: string(name='FormatLongName'),
        formatName?: string(name='FormatName'),
        numPrograms?: string(name='NumPrograms'),
        numStreams?: string(name='NumStreams'),
        size?: string(name='Size'),
        startTime?: string(name='StartTime'),
      }(name='Format'),
      fps?: string(name='Fps'),
      height?: string(name='Height'),
      streams?: {
        audioStreamList?: {
          audioStream?: [ 
          {
            bitrate?: string(name='Bitrate'),
            channelLayout?: string(name='ChannelLayout'),
            channels?: string(name='Channels'),
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            duration?: string(name='Duration'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            numFrames?: string(name='NumFrames'),
            sampleFmt?: string(name='SampleFmt'),
            samplerate?: string(name='Samplerate'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
          }
        ](name='AudioStream')
        }(name='AudioStreamList'),
        subtitleStreamList?: {
          subtitleStream?: [ 
          {
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            duration?: string(name='Duration'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
          }
        ](name='SubtitleStream')
        }(name='SubtitleStreamList'),
        videoStreamList?: {
          videoStream?: [ 
          {
            avgFPS?: string(name='AvgFPS'),
            bitrate?: string(name='Bitrate'),
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            colorPrimaries?: string(name='ColorPrimaries'),
            colorRange?: string(name='ColorRange'),
            colorTransfer?: string(name='ColorTransfer'),
            dar?: string(name='Dar'),
            duration?: string(name='Duration'),
            fps?: string(name='Fps'),
            hasBFrames?: string(name='HasBFrames'),
            height?: string(name='Height'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            level?: string(name='Level'),
            networkCost?: {
              avgBitrate?: string(name='AvgBitrate'),
              costBandwidth?: string(name='CostBandwidth'),
              preloadTime?: string(name='PreloadTime'),
            }(name='NetworkCost'),
            numFrames?: string(name='NumFrames'),
            pixFmt?: string(name='PixFmt'),
            profile?: string(name='Profile'),
            rotate?: string(name='Rotate'),
            sar?: string(name='Sar'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
            width?: string(name='Width'),
          }
        ](name='VideoStream')
        }(name='VideoStreamList'),
      }(name='Streams'),
      width?: string(name='Width'),
    }(name='Properties'),
    state?: string(name='State'),
    userData?: string(name='UserData'),
  }(name='MediaInfoJob'),
  requestId?: string(name='RequestId'),
}

model SubmitMediaInfoJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitMediaInfoJobResponseBody(name='body'),
}

async function submitMediaInfoJob(request: SubmitMediaInfoJobRequest): SubmitMediaInfoJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitMediaInfoJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitOssFileCopyJobRequest {
  notify?: string(name='Notify', position='Query'),
  region?: string(name='Region', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  sourceStorage?: {
    bucket?: string(name='Bucket'),
    bucketOwnerId?: long(name='BucketOwnerId'),
    fileNames?: string(name='FileNames'),
    objectPrefix?: string(name='ObjectPrefix'),
    objectRoleName?: string(name='ObjectRoleName'),
    s3AccessKey?: string(name='S3AccessKey'),
    s3Endpoint?: string(name='S3Endpoint'),
    s3Provider?: string(name='S3Provider'),
    s3SecretKey?: string(name='S3SecretKey'),
    s3SessionToken?: string(name='S3SessionToken'),
  }(name='SourceStorage', position='Query'),
  targetStorage?: {
    bucket?: string(name='Bucket'),
    bucketOwnerId?: long(name='BucketOwnerId'),
    objectPrefix?: string(name='ObjectPrefix'),
    objectRoleName?: string(name='ObjectRoleName'),
    s3AccessKey?: string(name='S3AccessKey'),
    s3Endpoint?: string(name='S3Endpoint'),
    s3Provider?: string(name='S3Provider'),
    s3SecretKey?: string(name='S3SecretKey'),
    s3SessionToken?: string(name='S3SessionToken'),
  }(name='TargetStorage', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model SubmitOssFileCopyJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SubmitOssFileCopyJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitOssFileCopyJobResponseBody(name='body'),
}

async function submitOssFileCopyJob(request: SubmitOssFileCopyJobRequest): SubmitOssFileCopyJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitOssFileCopyJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitPornJobRequest {
  input: string(name='Input', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId: string(name='PipelineId', position='Query'),
  pornConfig: string(name='PornConfig', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model SubmitPornJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitPornJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitPornJobResponseBody(name='body'),
}

async function submitPornJob(request: SubmitPornJobRequest): SubmitPornJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitPornJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitSmarttagJobRequest {
  content?: string(name='Content', position='Query'),
  contentAddr?: string(name='ContentAddr', position='Query'),
  contentType?: string(name='ContentType', position='Query'),
  input?: string(name='Input', position='Query'),
  notifyUrl?: string(name='NotifyUrl', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  params?: string(name='Params', position='Query'),
  pipelineId: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
  title: string(name='Title', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model SubmitSmarttagJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitSmarttagJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitSmarttagJobResponseBody(name='body'),
}

async function submitSmarttagJob(request: SubmitSmarttagJobRequest): SubmitSmarttagJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitSmarttagJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitSnapshotJobRequest {
  input: string(name='Input', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId?: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snapshotConfig: string(name='SnapshotConfig', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model SubmitSnapshotJobResponseBody = {
  requestId?: string(name='RequestId'),
  snapshotJob?: {
    code?: string(name='Code'),
    count?: string(name='Count'),
    creationTime?: string(name='CreationTime'),
    id?: string(name='Id'),
    input?: {
      bucket?: string(name='Bucket'),
      location?: string(name='Location'),
      object?: string(name='Object'),
      roleArn?: string(name='RoleArn'),
    }(name='Input'),
    MNSMessageResult?: {
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      messageId?: string(name='MessageId'),
    }(name='MNSMessageResult'),
    message?: string(name='Message'),
    pipelineId?: string(name='PipelineId'),
    snapshotConfig?: {
      frameType?: string(name='FrameType'),
      height?: string(name='Height'),
      interval?: string(name='Interval'),
      num?: string(name='Num'),
      outputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        roleArn?: string(name='RoleArn'),
      }(name='OutputFile'),
      tileOut?: {
        cellHeight?: string(name='CellHeight'),
        cellSelStep?: string(name='CellSelStep'),
        cellWidth?: string(name='CellWidth'),
        color?: string(name='Color'),
        columns?: string(name='Columns'),
        isKeepCellPic?: string(name='IsKeepCellPic'),
        lines?: string(name='Lines'),
        margin?: string(name='Margin'),
        padding?: string(name='Padding'),
      }(name='TileOut'),
      tileOutputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        roleArn?: string(name='RoleArn'),
      }(name='TileOutputFile'),
      time?: string(name='Time'),
      width?: string(name='Width'),
    }(name='SnapshotConfig'),
    state?: string(name='State'),
    tileCount?: string(name='TileCount'),
    userData?: string(name='UserData'),
  }(name='SnapshotJob'),
}

model SubmitSnapshotJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitSnapshotJobResponseBody(name='body'),
}

async function submitSnapshotJob(request: SubmitSnapshotJobRequest): SubmitSnapshotJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitSnapshotJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitSubtitleJobRequest {
  inputConfig: string(name='InputConfig', position='Query'),
  outputConfig: string(name='OutputConfig', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model SubmitSubtitleJobResponseBody = {
  requestId?: string(name='RequestId'),
  subtitleJob?: {
    inputConfig?: string(name='InputConfig'),
    jobId?: string(name='JobId'),
    outputConfig?: string(name='OutputConfig'),
    state?: string(name='State'),
    userData?: string(name='UserData'),
  }(name='SubtitleJob'),
}

model SubmitSubtitleJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitSubtitleJobResponseBody(name='body'),
}

async function submitSubtitleJob(request: SubmitSubtitleJobRequest): SubmitSubtitleJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitSubtitleJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitURLUploadJobRequest {
  notify?: string(name='Notify', position='Query'),
  region?: string(name='Region', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  sourceFileURL?: string(name='SourceFileURL', position='Query'),
  targetStorage?: {
    bucket?: string(name='Bucket'),
    bucketOwnerId?: string(name='BucketOwnerId'),
    objectKey?: string(name='ObjectKey'),
    objectRoleName?: string(name='ObjectRoleName'),
    s3AccessKey?: string(name='S3AccessKey'),
    s3Endpoint?: string(name='S3Endpoint'),
    s3Provider?: string(name='S3Provider'),
    s3SecretKey?: string(name='S3SecretKey'),
    s3SessionToken?: string(name='S3SessionToken'),
  }(name='TargetStorage', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model SubmitURLUploadJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SubmitURLUploadJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitURLUploadJobResponseBody(name='body'),
}

async function submitURLUploadJob(request: SubmitURLUploadJobRequest): SubmitURLUploadJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitURLUploadJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitVideoQualityJobRequest {
  input: string(name='Input', position='Query'),
  jobParams?: string(name='JobParams', position='Query'),
  modelId?: string(name='ModelId', position='Query'),
  notifyUrl?: string(name='NotifyUrl', position='Query'),
  output: string(name='Output', position='Query'),
  pipelineId?: string(name='PipelineId', position='Query'),
  scheduleParams?: string(name='ScheduleParams', position='Query'),
  sourceType: string(name='SourceType', position='Query'),
  userData?: string(name='UserData', position='Query'),
  userId?: long(name='UserId', minimum=0, maximum=999999999999999999, position='Query'),
}

model SubmitVideoQualityJobResponseBody = {
  code?: string(name='Code'),
  jobId?: string(name='JobId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SubmitVideoQualityJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitVideoQualityJobResponseBody(name='body'),
}

async function submitVideoQualityJob(request: SubmitVideoQualityJobRequest): SubmitVideoQualityJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitVideoQualityJob', 'POST', '/', 'json', false, 'json', request);
}

model TagCustomPersonRequest {
  categoryDescription?: string(name='CategoryDescription', position='Query'),
  categoryId?: string(name='CategoryId', position='Query'),
  categoryName?: string(name='CategoryName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  personDescription?: string(name='PersonDescription', position='Query'),
  personId?: string(name='PersonId', position='Query'),
  personName?: string(name='PersonName', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model TagCustomPersonResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagCustomPersonResponse = {
  headers: map[string]string(name='headers'),
  body: TagCustomPersonResponseBody(name='body'),
}

async function tagCustomPerson(request: TagCustomPersonRequest): TagCustomPersonResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagCustomPerson', 'POST', '/', 'json', false, 'json', request);
}

model UnbindInputBucketRequest {
  bucket: string(name='Bucket', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleArn?: string(name='RoleArn', position='Query'),
}

model UnbindInputBucketResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnbindInputBucketResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindInputBucketResponseBody(name='body'),
}

async function unbindInputBucket(request: UnbindInputBucketRequest): UnbindInputBucketResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnbindInputBucket', 'POST', '/', 'json', false, 'json', request);
}

model UnbindOutputBucketRequest {
  bucket: string(name='Bucket', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UnbindOutputBucketResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnbindOutputBucketResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindOutputBucketResponseBody(name='body'),
}

async function unbindOutputBucket(request: UnbindOutputBucketRequest): UnbindOutputBucketResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnbindOutputBucket', 'POST', '/', 'json', false, 'json', request);
}

model UnregisterCustomFaceRequest {
  categoryId: string(name='CategoryId', position='Query'),
  faceId: string(name='FaceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  personId: string(name='PersonId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UnregisterCustomFaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnregisterCustomFaceResponse = {
  headers: map[string]string(name='headers'),
  body: UnregisterCustomFaceResponseBody(name='body'),
}

async function unregisterCustomFace(request: UnregisterCustomFaceRequest): UnregisterCustomFaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnregisterCustomFace', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCategoryNameRequest {
  cateId: string(name='CateId', position='Query'),
  cateName: string(name='CateName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UpdateCategoryNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateCategoryNameResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCategoryNameResponseBody(name='body'),
}

async function updateCategoryName(request: UpdateCategoryNameRequest): UpdateCategoryNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCategoryName', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCensorPipelineRequest {
  name: string(name='Name', position='Query'),
  notifyConfig?: string(name='NotifyConfig', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId: string(name='PipelineId', position='Query'),
  priority: int32(name='Priority', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  state: string(name='State', position='Query'),
}

model UpdateCensorPipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      queue?: string(name='Queue'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model UpdateCensorPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCensorPipelineResponseBody(name='body'),
}

async function updateCensorPipeline(request: UpdateCensorPipelineRequest): UpdateCensorPipelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCensorPipeline', 'POST', '/', 'json', false, 'json', request);
}

model UpdateMediaRequest {
  cateId?: long(name='CateId', position='Query'),
  coverURL?: string(name='CoverURL', position='Query'),
  description?: string(name='Description', position='Query'),
  mediaId: string(name='MediaId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tags?: string(name='Tags', position='Query'),
  title?: string(name='Title', position='Query'),
}

model UpdateMediaResponseBody = {
  media?: {
    bitrate?: string(name='Bitrate'),
    cateId?: long(name='CateId'),
    censorState?: string(name='CensorState'),
    coverURL?: string(name='CoverURL'),
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    duration?: string(name='Duration'),
    file?: {
      state?: string(name='State'),
      URL?: string(name='URL'),
    }(name='File'),
    format?: string(name='Format'),
    fps?: string(name='Fps'),
    height?: string(name='Height'),
    mediaId?: string(name='MediaId'),
    publishState?: string(name='PublishState'),
    runIdList?: {
      runId?: [ string ](name='RunId')
    }(name='RunIdList'),
    size?: string(name='Size'),
    tags?: {
      tag?: [ string ](name='Tag')
    }(name='Tags'),
    title?: string(name='Title'),
    width?: string(name='Width'),
  }(name='Media'),
  requestId?: string(name='RequestId'),
}

model UpdateMediaResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaResponseBody(name='body'),
}

async function updateMedia(request: UpdateMediaRequest): UpdateMediaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMedia', 'POST', '/', 'json', false, 'json', request);
}

model UpdateMediaCategoryRequest {
  cateId?: long(name='CateId', position='Query'),
  mediaId: string(name='MediaId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UpdateMediaCategoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMediaCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaCategoryResponseBody(name='body'),
}

async function updateMediaCategory(request: UpdateMediaCategoryRequest): UpdateMediaCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMediaCategory', 'POST', '/', 'json', false, 'json', request);
}

model UpdateMediaCoverRequest {
  coverURL?: string(name='CoverURL', position='Query'),
  mediaId: string(name='MediaId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UpdateMediaCoverResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMediaCoverResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaCoverResponseBody(name='body'),
}

async function updateMediaCover(request: UpdateMediaCoverRequest): UpdateMediaCoverResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMediaCover', 'POST', '/', 'json', false, 'json', request);
}

model UpdateMediaPublishStateRequest {
  mediaId: string(name='MediaId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  publish?: boolean(name='Publish', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UpdateMediaPublishStateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMediaPublishStateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaPublishStateResponseBody(name='body'),
}

async function updateMediaPublishState(request: UpdateMediaPublishStateRequest): UpdateMediaPublishStateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMediaPublishState', 'POST', '/', 'json', false, 'json', request);
}

model UpdateMediaWorkflowRequest {
  mediaWorkflowId: string(name='MediaWorkflowId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  topology: string(name='Topology', position='Query'),
}

model UpdateMediaWorkflowResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
    triggerMode?: string(name='TriggerMode'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model UpdateMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaWorkflowResponseBody(name='body'),
}

async function updateMediaWorkflow(request: UpdateMediaWorkflowRequest): UpdateMediaWorkflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMediaWorkflow', 'POST', '/', 'json', false, 'json', request);
}

model UpdateMediaWorkflowTriggerModeRequest {
  mediaWorkflowId: string(name='MediaWorkflowId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  triggerMode: string(name='TriggerMode', position='Query'),
}

model UpdateMediaWorkflowTriggerModeResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
    triggerMode?: string(name='TriggerMode'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model UpdateMediaWorkflowTriggerModeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaWorkflowTriggerModeResponseBody(name='body'),
}

async function updateMediaWorkflowTriggerMode(request: UpdateMediaWorkflowTriggerModeRequest): UpdateMediaWorkflowTriggerModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMediaWorkflowTriggerMode', 'POST', '/', 'json', false, 'json', request);
}

model UpdatePipelineRequest {
  name: string(name='Name', position='Query'),
  notifyConfig?: string(name='NotifyConfig', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pipelineId: string(name='PipelineId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  role?: string(name='Role', position='Query'),
  state: string(name='State', position='Query'),
}

model UpdatePipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      mqTag?: string(name='MqTag'),
      mqTopic?: string(name='MqTopic'),
      queueName?: string(name='QueueName'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    quotaAllocate?: long(name='QuotaAllocate'),
    role?: string(name='Role'),
    speed?: string(name='Speed'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model UpdatePipelineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePipelineResponseBody(name='body'),
}

async function updatePipeline(request: UpdatePipelineRequest): UpdatePipelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdatePipeline', 'POST', '/', 'json', false, 'json', request);
}

model UpdateSmarttagTemplateRequest {
  analyseTypes?: string(name='AnalyseTypes', position='Query'),
  faceCategoryIds?: string(name='FaceCategoryIds', position='Query'),
  faceCustomParamsConfig?: string(name='FaceCustomParamsConfig', position='Query'),
  industry?: string(name='Industry', position='Query'),
  isDefault?: boolean(name='IsDefault', position='Query'),
  keywordConfig?: string(name='KeywordConfig', position='Query'),
  knowledgeConfig?: string(name='KnowledgeConfig', position='Query'),
  labelType?: string(name='LabelType', position='Query'),
  labelVersion?: string(name='LabelVersion', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scene?: string(name='Scene', position='Query'),
  templateId: string(name='TemplateId', position='Query'),
  templateName?: string(name='TemplateName', position='Query'),
}

model UpdateSmarttagTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateSmarttagTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSmarttagTemplateResponseBody(name='body'),
}

async function updateSmarttagTemplate(request: UpdateSmarttagTemplateRequest): UpdateSmarttagTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSmarttagTemplate', 'POST', '/', 'json', false, 'json', request);
}

model UpdateTemplateRequest {
  audio?: string(name='Audio', position='Query'),
  container?: string(name='Container', position='Query'),
  muxConfig?: string(name='MuxConfig', position='Query'),
  name: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  templateId: string(name='TemplateId', position='Query'),
  transConfig?: string(name='TransConfig', position='Query'),
  video?: string(name='Video', position='Query'),
}

model UpdateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    audio?: {
      bitrate?: string(name='Bitrate'),
      channels?: string(name='Channels'),
      codec?: string(name='Codec'),
      profile?: string(name='Profile'),
      qscale?: string(name='Qscale'),
      remove?: string(name='Remove'),
      samplerate?: string(name='Samplerate'),
    }(name='Audio'),
    container?: {
      format?: string(name='Format'),
    }(name='Container'),
    id?: string(name='Id'),
    muxConfig?: {
      gif?: {
        ditherMode?: string(name='DitherMode'),
        finalDelay?: string(name='FinalDelay'),
        isCustomPalette?: string(name='IsCustomPalette'),
        loop?: string(name='Loop'),
      }(name='Gif'),
      segment?: {
        duration?: string(name='Duration'),
      }(name='Segment'),
      webp?: {
        loop?: string(name='Loop'),
      }(name='Webp'),
    }(name='MuxConfig'),
    name?: string(name='Name'),
    state?: string(name='State'),
    transConfig?: {
      adjDarMethod?: string(name='AdjDarMethod'),
      isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
      isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
      isCheckReso?: string(name='IsCheckReso'),
      isCheckResoFail?: string(name='IsCheckResoFail'),
      isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
      isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
      transMode?: string(name='TransMode'),
    }(name='TransConfig'),
    video?: {
      bitrate?: string(name='Bitrate'),
      bitrateBnd?: {
        max?: string(name='Max'),
        min?: string(name='Min'),
      }(name='BitrateBnd'),
      bufsize?: string(name='Bufsize'),
      codec?: string(name='Codec'),
      crf?: string(name='Crf'),
      crop?: string(name='Crop'),
      degrain?: string(name='Degrain'),
      fps?: string(name='Fps'),
      gop?: string(name='Gop'),
      height?: string(name='Height'),
      longShortMode?: string(name='LongShortMode'),
      maxFps?: string(name='MaxFps'),
      maxrate?: string(name='Maxrate'),
      pad?: string(name='Pad'),
      pixFmt?: string(name='PixFmt'),
      preset?: string(name='Preset'),
      profile?: string(name='Profile'),
      qscale?: string(name='Qscale'),
      remove?: string(name='Remove'),
      resoPriority?: string(name='ResoPriority'),
      scanMode?: string(name='ScanMode'),
      width?: string(name='Width'),
    }(name='Video'),
  }(name='Template'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTemplateResponseBody(name='body'),
}

async function updateTemplate(request: UpdateTemplateRequest): UpdateTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateTemplate', 'POST', '/', 'json', false, 'json', request);
}

model UpdateWaterMarkTemplateRequest {
  config: string(name='Config', position='Query'),
  name: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  waterMarkTemplateId: string(name='WaterMarkTemplateId', position='Query'),
}

model UpdateWaterMarkTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  waterMarkTemplate?: {
    dx?: string(name='Dx'),
    dy?: string(name='Dy'),
    height?: string(name='Height'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    ratioRefer?: {
      dx?: string(name='Dx'),
      dy?: string(name='Dy'),
      height?: string(name='Height'),
      width?: string(name='Width'),
    }(name='RatioRefer'),
    referPos?: string(name='ReferPos'),
    state?: string(name='State'),
    timeline?: {
      duration?: string(name='Duration'),
      start?: string(name='Start'),
    }(name='Timeline'),
    type?: string(name='Type'),
    width?: string(name='Width'),
  }(name='WaterMarkTemplate'),
}

model UpdateWaterMarkTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWaterMarkTemplateResponseBody(name='body'),
}

async function updateWaterMarkTemplate(request: UpdateWaterMarkTemplateRequest): UpdateWaterMarkTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateWaterMarkTemplate', 'POST', '/', 'json', false, 'json', request);
}

