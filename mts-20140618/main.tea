/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'mts.aliyuncs.com',
    ap-southeast-2 = 'mts.aliyuncs.com',
    ap-southeast-3 = 'mts.aliyuncs.com',
    cn-beijing-finance-1 = 'mts.aliyuncs.com',
    cn-beijing-finance-pop = 'mts.aliyuncs.com',
    cn-beijing-gov-1 = 'mts.aliyuncs.com',
    cn-beijing-nu16-b01 = 'mts.aliyuncs.com',
    cn-chengdu = 'mts.aliyuncs.com',
    cn-edge-1 = 'mts.aliyuncs.com',
    cn-fujian = 'mts.aliyuncs.com',
    cn-haidian-cm12-c01 = 'mts.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'mts.aliyuncs.com',
    cn-hangzhou-finance = 'mts.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'mts.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'mts.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'mts.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'mts.aliyuncs.com',
    cn-hangzhou-test-306 = 'mts.aliyuncs.com',
    cn-hongkong-finance-pop = 'mts.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'mts.aliyuncs.com',
    cn-north-2-gov-1 = 'mts.aliyuncs.com',
    cn-qingdao-nebula = 'mts.aliyuncs.com',
    cn-shanghai-et15-b01 = 'mts.aliyuncs.com',
    cn-shanghai-et2-b01 = 'mts.aliyuncs.com',
    cn-shanghai-finance-1 = 'mts.aliyuncs.com',
    cn-shanghai-inner = 'mts.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'mts.aliyuncs.com',
    cn-shenzhen-finance-1 = 'mts.aliyuncs.com',
    cn-shenzhen-inner = 'mts.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'mts.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'mts.aliyuncs.com',
    cn-wuhan = 'mts.aliyuncs.com',
    cn-wulanchabu = 'mts.aliyuncs.com',
    cn-yushanfang = 'mts.aliyuncs.com',
    cn-zhangbei = 'mts.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'mts.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'mts.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'mts.aliyuncs.com',
    eu-west-1-oxs = 'mts.aliyuncs.com',
    me-east-1 = 'mts.aliyuncs.com',
    rus-west-1-pop = 'mts.aliyuncs.com',
    us-east-1 = 'mts.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('mts', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ActivateMediaWorkflowRequest {
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ActivateMediaWorkflowResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model ActivateMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ActivateMediaWorkflowResponseBody(name='body'),
}

async function activateMediaWorkflowWithOptions(request: ActivateMediaWorkflowRequest, runtime: Util.RuntimeOptions): ActivateMediaWorkflowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaWorkflowId)) {
    query['MediaWorkflowId'] = request.mediaWorkflowId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ActivateMediaWorkflow',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function activateMediaWorkflow(request: ActivateMediaWorkflowRequest): ActivateMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return activateMediaWorkflowWithOptions(request, runtime);
}

model AddMediaRequest {
  cateId?: long(name='CateId'),
  coverURL?: string(name='CoverURL'),
  description?: string(name='Description'),
  fileURL?: string(name='FileURL'),
  inputUnbind?: boolean(name='InputUnbind'),
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  mediaWorkflowUserData?: string(name='MediaWorkflowUserData'),
  overrideParams?: string(name='OverrideParams'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tags?: string(name='Tags'),
  title?: string(name='Title'),
}

model AddMediaResponseBody = {
  media?: {
    bitrate?: string(name='Bitrate'),
    cateId?: long(name='CateId'),
    censorState?: string(name='CensorState'),
    coverURL?: string(name='CoverURL'),
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    duration?: string(name='Duration'),
    file?: {
      state?: string(name='State'),
      URL?: string(name='URL'),
    }(name='File'),
    format?: string(name='Format'),
    fps?: string(name='Fps'),
    height?: string(name='Height'),
    mediaId?: string(name='MediaId'),
    publishState?: string(name='PublishState'),
    runIdList?: {
      runId?: [ string ](name='RunId')
    }(name='RunIdList'),
    size?: string(name='Size'),
    tags?: {
      tag?: [ string ](name='Tag')
    }(name='Tags'),
    title?: string(name='Title'),
    width?: string(name='Width'),
  }(name='Media'),
  requestId?: string(name='RequestId'),
}

model AddMediaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddMediaResponseBody(name='body'),
}

async function addMediaWithOptions(request: AddMediaRequest, runtime: Util.RuntimeOptions): AddMediaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.coverURL)) {
    query['CoverURL'] = request.coverURL;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.fileURL)) {
    query['FileURL'] = request.fileURL;
  }
  if (!Util.isUnset(request.inputUnbind)) {
    query['InputUnbind'] = request.inputUnbind;
  }
  if (!Util.isUnset(request.mediaWorkflowId)) {
    query['MediaWorkflowId'] = request.mediaWorkflowId;
  }
  if (!Util.isUnset(request.mediaWorkflowUserData)) {
    query['MediaWorkflowUserData'] = request.mediaWorkflowUserData;
  }
  if (!Util.isUnset(request.overrideParams)) {
    query['OverrideParams'] = request.overrideParams;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddMedia',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addMedia(request: AddMediaRequest): AddMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMediaWithOptions(request, runtime);
}

model AddMediaTagRequest {
  mediaId?: string(name='MediaId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tag?: string(name='Tag'),
}

model AddMediaTagResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddMediaTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddMediaTagResponseBody(name='body'),
}

async function addMediaTagWithOptions(request: AddMediaTagRequest, runtime: Util.RuntimeOptions): AddMediaTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddMediaTag',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addMediaTag(request: AddMediaTagRequest): AddMediaTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMediaTagWithOptions(request, runtime);
}

model AddMediaWorkflowRequest {
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  topology?: string(name='Topology'),
  triggerMode?: string(name='TriggerMode'),
}

model AddMediaWorkflowResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
    triggerMode?: string(name='TriggerMode'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model AddMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddMediaWorkflowResponseBody(name='body'),
}

async function addMediaWorkflowWithOptions(request: AddMediaWorkflowRequest, runtime: Util.RuntimeOptions): AddMediaWorkflowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.topology)) {
    query['Topology'] = request.topology;
  }
  if (!Util.isUnset(request.triggerMode)) {
    query['TriggerMode'] = request.triggerMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddMediaWorkflow',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addMediaWorkflow(request: AddMediaWorkflowRequest): AddMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMediaWorkflowWithOptions(request, runtime);
}

model AddPipelineRequest {
  name?: string(name='Name'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  role?: string(name='Role'),
  speed?: string(name='Speed'),
  speedLevel?: long(name='SpeedLevel'),
}

model AddPipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      mqTag?: string(name='MqTag'),
      mqTopic?: string(name='MqTopic'),
      queueName?: string(name='QueueName'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    quotaAllocate?: long(name='QuotaAllocate'),
    role?: string(name='Role'),
    speed?: string(name='Speed'),
    speedLevel?: long(name='SpeedLevel'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model AddPipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddPipelineResponseBody(name='body'),
}

async function addPipelineWithOptions(request: AddPipelineRequest, runtime: Util.RuntimeOptions): AddPipelineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.notifyConfig)) {
    query['NotifyConfig'] = request.notifyConfig;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.role)) {
    query['Role'] = request.role;
  }
  if (!Util.isUnset(request.speed)) {
    query['Speed'] = request.speed;
  }
  if (!Util.isUnset(request.speedLevel)) {
    query['SpeedLevel'] = request.speedLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addPipeline(request: AddPipelineRequest): AddPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPipelineWithOptions(request, runtime);
}

model AddSmarttagTemplateRequest {
  analyseTypes?: string(name='AnalyseTypes'),
  faceCategoryIds?: string(name='FaceCategoryIds'),
  faceCustomParamsConfig?: string(name='FaceCustomParamsConfig'),
  industry?: string(name='Industry'),
  isDefault?: boolean(name='IsDefault'),
  keywordConfig?: string(name='KeywordConfig'),
  knowledgeConfig?: string(name='KnowledgeConfig'),
  labelType?: string(name='LabelType'),
  labelVersion?: string(name='LabelVersion'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scene?: string(name='Scene'),
  templateName?: string(name='TemplateName'),
}

model AddSmarttagTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model AddSmarttagTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddSmarttagTemplateResponseBody(name='body'),
}

async function addSmarttagTemplateWithOptions(request: AddSmarttagTemplateRequest, runtime: Util.RuntimeOptions): AddSmarttagTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.analyseTypes)) {
    query['AnalyseTypes'] = request.analyseTypes;
  }
  if (!Util.isUnset(request.faceCategoryIds)) {
    query['FaceCategoryIds'] = request.faceCategoryIds;
  }
  if (!Util.isUnset(request.faceCustomParamsConfig)) {
    query['FaceCustomParamsConfig'] = request.faceCustomParamsConfig;
  }
  if (!Util.isUnset(request.industry)) {
    query['Industry'] = request.industry;
  }
  if (!Util.isUnset(request.isDefault)) {
    query['IsDefault'] = request.isDefault;
  }
  if (!Util.isUnset(request.keywordConfig)) {
    query['KeywordConfig'] = request.keywordConfig;
  }
  if (!Util.isUnset(request.knowledgeConfig)) {
    query['KnowledgeConfig'] = request.knowledgeConfig;
  }
  if (!Util.isUnset(request.labelType)) {
    query['LabelType'] = request.labelType;
  }
  if (!Util.isUnset(request.labelVersion)) {
    query['LabelVersion'] = request.labelVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scene)) {
    query['Scene'] = request.scene;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddSmarttagTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addSmarttagTemplate(request: AddSmarttagTemplateRequest): AddSmarttagTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSmarttagTemplateWithOptions(request, runtime);
}

model AddTemplateRequest {
  audio?: string(name='Audio'),
  container?: string(name='Container'),
  muxConfig?: string(name='MuxConfig'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  transConfig?: string(name='TransConfig'),
  video?: string(name='Video'),
}

model AddTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    audio?: {
      bitrate?: string(name='Bitrate'),
      channels?: string(name='Channels'),
      codec?: string(name='Codec'),
      profile?: string(name='Profile'),
      qscale?: string(name='Qscale'),
      remove?: string(name='Remove'),
      samplerate?: string(name='Samplerate'),
      volume?: {
        level?: string(name='Level'),
        method?: string(name='Method'),
      }(name='Volume'),
    }(name='Audio'),
    container?: {
      format?: string(name='Format'),
    }(name='Container'),
    id?: string(name='Id'),
    muxConfig?: {
      gif?: {
        ditherMode?: string(name='DitherMode'),
        finalDelay?: string(name='FinalDelay'),
        isCustomPalette?: string(name='IsCustomPalette'),
        loop?: string(name='Loop'),
      }(name='Gif'),
      segment?: {
        duration?: string(name='Duration'),
      }(name='Segment'),
      webp?: {
        loop?: string(name='Loop'),
      }(name='Webp'),
    }(name='MuxConfig'),
    name?: string(name='Name'),
    state?: string(name='State'),
    transConfig?: {
      adjDarMethod?: string(name='AdjDarMethod'),
      isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
      isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
      isCheckReso?: string(name='IsCheckReso'),
      isCheckResoFail?: string(name='IsCheckResoFail'),
      isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
      isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
      transMode?: string(name='TransMode'),
    }(name='TransConfig'),
    video?: {
      bitrate?: string(name='Bitrate'),
      bitrateBnd?: {
        max?: string(name='Max'),
        min?: string(name='Min'),
      }(name='BitrateBnd'),
      bufsize?: string(name='Bufsize'),
      codec?: string(name='Codec'),
      crf?: string(name='Crf'),
      crop?: string(name='Crop'),
      degrain?: string(name='Degrain'),
      fps?: string(name='Fps'),
      gop?: string(name='Gop'),
      height?: string(name='Height'),
      longShortMode?: string(name='LongShortMode'),
      maxFps?: string(name='MaxFps'),
      maxrate?: string(name='Maxrate'),
      pad?: string(name='Pad'),
      pixFmt?: string(name='PixFmt'),
      preset?: string(name='Preset'),
      profile?: string(name='Profile'),
      qscale?: string(name='Qscale'),
      remove?: string(name='Remove'),
      resoPriority?: string(name='ResoPriority'),
      scanMode?: string(name='ScanMode'),
      width?: string(name='Width'),
    }(name='Video'),
  }(name='Template'),
}

model AddTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddTemplateResponseBody(name='body'),
}

async function addTemplateWithOptions(request: AddTemplateRequest, runtime: Util.RuntimeOptions): AddTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.audio)) {
    query['Audio'] = request.audio;
  }
  if (!Util.isUnset(request.container)) {
    query['Container'] = request.container;
  }
  if (!Util.isUnset(request.muxConfig)) {
    query['MuxConfig'] = request.muxConfig;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.transConfig)) {
    query['TransConfig'] = request.transConfig;
  }
  if (!Util.isUnset(request.video)) {
    query['Video'] = request.video;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addTemplate(request: AddTemplateRequest): AddTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTemplateWithOptions(request, runtime);
}

model AddWaterMarkTemplateRequest {
  config?: string(name='Config'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddWaterMarkTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  waterMarkTemplate?: {
    dx?: string(name='Dx'),
    dy?: string(name='Dy'),
    height?: string(name='Height'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    ratioRefer?: {
      dx?: string(name='Dx'),
      dy?: string(name='Dy'),
      height?: string(name='Height'),
      width?: string(name='Width'),
    }(name='RatioRefer'),
    referPos?: string(name='ReferPos'),
    state?: string(name='State'),
    timeline?: {
      duration?: string(name='Duration'),
      start?: string(name='Start'),
    }(name='Timeline'),
    type?: string(name='Type'),
    width?: string(name='Width'),
  }(name='WaterMarkTemplate'),
}

model AddWaterMarkTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddWaterMarkTemplateResponseBody(name='body'),
}

async function addWaterMarkTemplateWithOptions(request: AddWaterMarkTemplateRequest, runtime: Util.RuntimeOptions): AddWaterMarkTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddWaterMarkTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addWaterMarkTemplate(request: AddWaterMarkTemplateRequest): AddWaterMarkTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addWaterMarkTemplateWithOptions(request, runtime);
}

model BindInputBucketRequest {
  bucket?: string(name='Bucket'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  referer?: string(name='Referer'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleArn?: string(name='RoleArn'),
}

model BindInputBucketResponseBody = {
  requestId?: string(name='RequestId'),
}

model BindInputBucketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindInputBucketResponseBody(name='body'),
}

async function bindInputBucketWithOptions(request: BindInputBucketRequest, runtime: Util.RuntimeOptions): BindInputBucketResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bucket)) {
    query['Bucket'] = request.bucket;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.referer)) {
    query['Referer'] = request.referer;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.roleArn)) {
    query['RoleArn'] = request.roleArn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindInputBucket',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bindInputBucket(request: BindInputBucketRequest): BindInputBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindInputBucketWithOptions(request, runtime);
}

model BindOutputBucketRequest {
  bucket?: string(name='Bucket'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleArn?: string(name='RoleArn'),
}

model BindOutputBucketResponseBody = {
  requestId?: string(name='RequestId'),
}

model BindOutputBucketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindOutputBucketResponseBody(name='body'),
}

async function bindOutputBucketWithOptions(request: BindOutputBucketRequest, runtime: Util.RuntimeOptions): BindOutputBucketResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bucket)) {
    query['Bucket'] = request.bucket;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.roleArn)) {
    query['RoleArn'] = request.roleArn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindOutputBucket',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bindOutputBucket(request: BindOutputBucketRequest): BindOutputBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindOutputBucketWithOptions(request, runtime);
}

model CancelJobRequest {
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CancelJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model CancelJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelJobResponseBody(name='body'),
}

async function cancelJobWithOptions(request: CancelJobRequest, runtime: Util.RuntimeOptions): CancelJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelJob(request: CancelJobRequest): CancelJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelJobWithOptions(request, runtime);
}

model CreateFpShotDBRequest {
  config?: string(name='Config'),
  description?: string(name='Description'),
  modelId?: int32(name='ModelId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateFpShotDBResponseBody = {
  fpShotDB?: {
    config?: string(name='Config'),
    description?: string(name='Description'),
    fpDBId?: string(name='FpDBId'),
    modelId?: int32(name='ModelId'),
    name?: string(name='Name'),
    state?: string(name='State'),
  }(name='FpShotDB'),
  requestId?: string(name='RequestId'),
}

model CreateFpShotDBResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFpShotDBResponseBody(name='body'),
}

async function createFpShotDBWithOptions(request: CreateFpShotDBRequest, runtime: Util.RuntimeOptions): CreateFpShotDBResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.modelId)) {
    query['ModelId'] = request.modelId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFpShotDB',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFpShotDB(request: CreateFpShotDBRequest): CreateFpShotDBResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFpShotDBWithOptions(request, runtime);
}

model DeactivateMediaWorkflowRequest {
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeactivateMediaWorkflowResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model DeactivateMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeactivateMediaWorkflowResponseBody(name='body'),
}

async function deactivateMediaWorkflowWithOptions(request: DeactivateMediaWorkflowRequest, runtime: Util.RuntimeOptions): DeactivateMediaWorkflowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaWorkflowId)) {
    query['MediaWorkflowId'] = request.mediaWorkflowId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeactivateMediaWorkflow',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deactivateMediaWorkflow(request: DeactivateMediaWorkflowRequest): DeactivateMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deactivateMediaWorkflowWithOptions(request, runtime);
}

model DeleteMediaRequest {
  mediaIds?: string(name='MediaIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteMediaResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMediaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMediaResponseBody(name='body'),
}

async function deleteMediaWithOptions(request: DeleteMediaRequest, runtime: Util.RuntimeOptions): DeleteMediaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaIds)) {
    query['MediaIds'] = request.mediaIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMedia',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMedia(request: DeleteMediaRequest): DeleteMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMediaWithOptions(request, runtime);
}

model DeleteMediaTagRequest {
  mediaId?: string(name='MediaId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tag?: string(name='Tag'),
}

model DeleteMediaTagResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMediaTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMediaTagResponseBody(name='body'),
}

async function deleteMediaTagWithOptions(request: DeleteMediaTagRequest, runtime: Util.RuntimeOptions): DeleteMediaTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMediaTag',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMediaTag(request: DeleteMediaTagRequest): DeleteMediaTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMediaTagWithOptions(request, runtime);
}

model DeleteMediaWorkflowRequest {
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteMediaWorkflowResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model DeleteMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMediaWorkflowResponseBody(name='body'),
}

async function deleteMediaWorkflowWithOptions(request: DeleteMediaWorkflowRequest, runtime: Util.RuntimeOptions): DeleteMediaWorkflowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaWorkflowId)) {
    query['MediaWorkflowId'] = request.mediaWorkflowId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMediaWorkflow',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMediaWorkflow(request: DeleteMediaWorkflowRequest): DeleteMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMediaWorkflowWithOptions(request, runtime);
}

model DeletePipelineRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeletePipelineResponseBody = {
  pipelineId?: string(name='PipelineId'),
  requestId?: string(name='RequestId'),
}

model DeletePipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePipelineResponseBody(name='body'),
}

async function deletePipelineWithOptions(request: DeletePipelineRequest, runtime: Util.RuntimeOptions): DeletePipelineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePipeline(request: DeletePipelineRequest): DeletePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePipelineWithOptions(request, runtime);
}

model DeleteSmarttagTemplateRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
}

model DeleteSmarttagTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSmarttagTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSmarttagTemplateResponseBody(name='body'),
}

async function deleteSmarttagTemplateWithOptions(request: DeleteSmarttagTemplateRequest, runtime: Util.RuntimeOptions): DeleteSmarttagTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSmarttagTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSmarttagTemplate(request: DeleteSmarttagTemplateRequest): DeleteSmarttagTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSmarttagTemplateWithOptions(request, runtime);
}

model DeleteTemplateRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
}

model DeleteTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model DeleteTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTemplateResponseBody(name='body'),
}

async function deleteTemplateWithOptions(request: DeleteTemplateRequest, runtime: Util.RuntimeOptions): DeleteTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTemplate(request: DeleteTemplateRequest): DeleteTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTemplateWithOptions(request, runtime);
}

model DeleteWaterMarkTemplateRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
}

model DeleteWaterMarkTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
}

model DeleteWaterMarkTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteWaterMarkTemplateResponseBody(name='body'),
}

async function deleteWaterMarkTemplateWithOptions(request: DeleteWaterMarkTemplateRequest, runtime: Util.RuntimeOptions): DeleteWaterMarkTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.waterMarkTemplateId)) {
    query['WaterMarkTemplateId'] = request.waterMarkTemplateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWaterMarkTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWaterMarkTemplate(request: DeleteWaterMarkTemplateRequest): DeleteWaterMarkTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWaterMarkTemplateWithOptions(request, runtime);
}

model ImAuditRequest {
  bizType?: string(name='BizType'),
  contents?: string(name='Contents'),
  images?: string(name='Images'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scenes?: string(name='Scenes'),
}

model ImAuditResponseBody = {
  imageQuotaExceed?: boolean(name='ImageQuotaExceed'),
  imageResults?: {
    result?: [ 
      {
        code?: long(name='code'),
        dataId?: string(name='dataId'),
        extras?: map[string]any(name='extras'),
        msg?: string(name='msg'),
        results?: [ 
          {
            label?: string(name='Label'),
            rate?: double(name='Rate'),
            scene?: string(name='Scene'),
            suggestion?: string(name='Suggestion'),
          }
        ](name='results'),
        taskId?: string(name='taskId'),
        url?: string(name='url'),
      }
    ](name='result'),
  }(name='ImageResults'),
  requestId?: string(name='RequestId'),
  textQuotaExceed?: boolean(name='TextQuotaExceed'),
  textResults?: {
    result?: [ 
      {
        code?: long(name='code'),
        content?: string(name='content'),
        dataId?: string(name='dataId'),
        msg?: string(name='msg'),
        results?: [ 
          {
            details?: [ 
              {
                label?: string(name='Label'),
              }
            ](name='details'),
            label?: string(name='label'),
            rate?: double(name='rate'),
            scene?: string(name='scene'),
            suggestion?: string(name='suggestion'),
          }
        ](name='results'),
        taskId?: string(name='taskId'),
      }
    ](name='result'),
  }(name='TextResults'),
}

model ImAuditResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ImAuditResponseBody(name='body'),
}

async function imAuditWithOptions(request: ImAuditRequest, runtime: Util.RuntimeOptions): ImAuditResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.contents)) {
    query['Contents'] = request.contents;
  }
  if (!Util.isUnset(request.images)) {
    query['Images'] = request.images;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scenes)) {
    query['Scenes'] = request.scenes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImAudit',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function imAudit(request: ImAuditRequest): ImAuditResponse {
  var runtime = new Util.RuntimeOptions{};
  return imAuditWithOptions(request, runtime);
}

model ImportFpShotJobRequest {
  fpDBId?: string(name='FpDBId'),
  fpImportConfig?: string(name='FpImportConfig'),
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model ImportFpShotJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ImportFpShotJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ImportFpShotJobResponseBody(name='body'),
}

async function importFpShotJobWithOptions(request: ImportFpShotJobRequest, runtime: Util.RuntimeOptions): ImportFpShotJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fpDBId)) {
    query['FpDBId'] = request.fpDBId;
  }
  if (!Util.isUnset(request.fpImportConfig)) {
    query['FpImportConfig'] = request.fpImportConfig;
  }
  if (!Util.isUnset(request.input)) {
    query['Input'] = request.input;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportFpShotJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importFpShotJob(request: ImportFpShotJobRequest): ImportFpShotJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return importFpShotJobWithOptions(request, runtime);
}

model ListAllMediaBucketRequest {
  maximumPageSize?: int32(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListAllMediaBucketResponseBody = {
  mediaBucketList?: {
    mediaBucket?: [ 
    {
      bucket?: string(name='Bucket'),
      referer?: string(name='Referer'),
      type?: string(name='Type'),
    }
  ](name='MediaBucket')
  }(name='MediaBucketList'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListAllMediaBucketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAllMediaBucketResponseBody(name='body'),
}

async function listAllMediaBucketWithOptions(request: ListAllMediaBucketRequest, runtime: Util.RuntimeOptions): ListAllMediaBucketResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maximumPageSize)) {
    query['MaximumPageSize'] = request.maximumPageSize;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAllMediaBucket',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAllMediaBucket(request: ListAllMediaBucketRequest): ListAllMediaBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAllMediaBucketWithOptions(request, runtime);
}

model ListCustomPersonsRequest {
  categoryId?: string(name='CategoryId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  personId?: string(name='PersonId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListCustomPersonsResponseBody = {
  categories?: {
    category?: [ 
    {
      categoryDescription?: string(name='CategoryDescription'),
      categoryId?: string(name='CategoryId'),
      categoryName?: string(name='CategoryName'),
      persons?: {
        person?: [ 
        {
          faces?: {
            face?: [ 
            {
              faceId?: string(name='FaceId'),
              imageUrl?: string(name='ImageUrl'),
            }
          ](name='Face')
          }(name='Faces'),
          personDescription?: string(name='PersonDescription'),
          personId?: string(name='PersonId'),
          personName?: string(name='PersonName'),
        }
      ](name='Person')
      }(name='Persons'),
    }
  ](name='Category')
  }(name='Categories'),
  requestId?: string(name='RequestId'),
}

model ListCustomPersonsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCustomPersonsResponseBody(name='body'),
}

async function listCustomPersonsWithOptions(request: ListCustomPersonsRequest, runtime: Util.RuntimeOptions): ListCustomPersonsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.categoryId)) {
    query['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.personId)) {
    query['PersonId'] = request.personId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCustomPersons',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCustomPersons(request: ListCustomPersonsRequest): ListCustomPersonsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCustomPersonsWithOptions(request, runtime);
}

model ListFpShotDBRequest {
  fpDBIds?: string(name='FpDBIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListFpShotDBResponseBody = {
  fpShotDBList?: {
    fpShotDB?: [ 
    {
      description?: string(name='Description'),
      fpDBId?: string(name='FpDBId'),
      modelId?: int32(name='ModelId'),
      name?: string(name='Name'),
      status?: string(name='Status'),
    }
  ](name='FpShotDB')
  }(name='FpShotDBList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model ListFpShotDBResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFpShotDBResponseBody(name='body'),
}

async function listFpShotDBWithOptions(request: ListFpShotDBRequest, runtime: Util.RuntimeOptions): ListFpShotDBResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fpDBIds)) {
    query['FpDBIds'] = request.fpDBIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFpShotDB',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFpShotDB(request: ListFpShotDBRequest): ListFpShotDBResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFpShotDBWithOptions(request, runtime);
}

model ListFpShotFilesRequest {
  fpDBId?: string(name='FpDBId'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListFpShotFilesResponseBody = {
  fpShotFileList?: {
    fpShotFile?: [ 
    {
      fileId?: string(name='FileId'),
      inputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='InputFile'),
      primaryKey?: string(name='PrimaryKey'),
    }
  ](name='FpShotFile')
  }(name='FpShotFileList'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListFpShotFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFpShotFilesResponseBody(name='body'),
}

async function listFpShotFilesWithOptions(request: ListFpShotFilesRequest, runtime: Util.RuntimeOptions): ListFpShotFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fpDBId)) {
    query['FpDBId'] = request.fpDBId;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFpShotFiles',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFpShotFiles(request: ListFpShotFilesRequest): ListFpShotFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFpShotFilesWithOptions(request, runtime);
}

model ListFpShotImportJobRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListFpShotImportJobResponseBody = {
  fpShotImportJobList?: [ 
    {
      code?: string(name='Code'),
      createTime?: string(name='CreateTime'),
      finishTime?: string(name='FinishTime'),
      fpDBId?: string(name='FpDBId'),
      fpImportConfig?: string(name='FpImportConfig'),
      id?: string(name='Id'),
      input?: string(name='Input'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      processMessage?: string(name='ProcessMessage'),
      status?: string(name='Status'),
      userData?: string(name='UserData'),
    }
  ](name='FpShotImportJobList'),
  nonExistIds?: [ string ](name='NonExistIds'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListFpShotImportJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFpShotImportJobResponseBody(name='body'),
}

async function listFpShotImportJobWithOptions(request: ListFpShotImportJobRequest, runtime: Util.RuntimeOptions): ListFpShotImportJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobIds)) {
    query['JobIds'] = request.jobIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFpShotImportJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFpShotImportJob(request: ListFpShotImportJobRequest): ListFpShotImportJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFpShotImportJobWithOptions(request, runtime);
}

model ListJobRequest {
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange'),
  maximumPageSize?: long(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange'),
  state?: string(name='State'),
}

model ListJobResponseBody = {
  jobList?: {
    job?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      output?: {
        audio?: {
          bitrate?: string(name='Bitrate'),
          channels?: string(name='Channels'),
          codec?: string(name='Codec'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          samplerate?: string(name='Samplerate'),
          volume?: {
            level?: string(name='Level'),
            method?: string(name='Method'),
          }(name='Volume'),
        }(name='Audio'),
        audioStreamMap?: string(name='AudioStreamMap'),
        clip?: {
          timeSpan?: {
            duration?: string(name='Duration'),
            seek?: string(name='Seek'),
          }(name='TimeSpan'),
        }(name='Clip'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        deWatermark?: string(name='DeWatermark'),
        encryption?: {
          id?: string(name='Id'),
          key?: string(name='Key'),
          keyType?: string(name='KeyType'),
          keyUri?: string(name='KeyUri'),
          skipCnt?: string(name='SkipCnt'),
          type?: string(name='Type'),
        }(name='Encryption'),
        m3U8NonStandardSupport?: {
          TS?: {
            md5Support?: boolean(name='Md5Support'),
            sizeSupport?: boolean(name='SizeSupport'),
          }(name='TS'),
        }(name='M3U8NonStandardSupport'),
        mergeConfigUrl?: string(name='MergeConfigUrl'),
        mergeList?: {
          merge?: [ 
          {
            duration?: string(name='Duration'),
            mergeURL?: string(name='MergeURL'),
            roleArn?: string(name='RoleArn'),
            start?: string(name='Start'),
          }
        ](name='Merge')
        }(name='MergeList'),
        muxConfig?: {
          gif?: {
            ditherMode?: string(name='DitherMode'),
            finalDelay?: string(name='FinalDelay'),
            isCustomPalette?: string(name='IsCustomPalette'),
            loop?: string(name='Loop'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
          webp?: {
            loop?: string(name='Loop'),
          }(name='Webp'),
        }(name='MuxConfig'),
        openingList?: {
          opening?: [ 
          {
            height?: string(name='Height'),
            start?: string(name='Start'),
            width?: string(name='Width'),
            openUrl?: string(name='openUrl'),
          }
        ](name='Opening')
        }(name='OpeningList'),
        outSubtitleList?: {
          outSubtitle?: [ 
          {
            map?: string(name='Map'),
            message?: string(name='Message'),
            outSubtitleFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
              roleArn?: string(name='RoleArn'),
            }(name='OutSubtitleFile'),
            success?: boolean(name='Success'),
          }
        ](name='OutSubtitle')
        }(name='OutSubtitleList'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='OutputFile'),
        priority?: string(name='Priority'),
        properties?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          fileFormat?: string(name='FileFormat'),
          fileSize?: string(name='FileSize'),
          format?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            formatLongName?: string(name='FormatLongName'),
            formatName?: string(name='FormatName'),
            numPrograms?: string(name='NumPrograms'),
            numStreams?: string(name='NumStreams'),
            size?: string(name='Size'),
            startTime?: string(name='StartTime'),
          }(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          streams?: {
            audioStreamList?: {
              audioStream?: [ 
              {
                bitrate?: string(name='Bitrate'),
                channelLayout?: string(name='ChannelLayout'),
                channels?: string(name='Channels'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                duration?: string(name='Duration'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                numFrames?: string(name='NumFrames'),
                sampleFmt?: string(name='SampleFmt'),
                samplerate?: string(name='Samplerate'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
              }
            ](name='AudioStream')
            }(name='AudioStreamList'),
            subtitleStreamList?: {
              subtitleStream?: [ 
              {
                index?: string(name='Index'),
                lang?: string(name='Lang'),
              }
            ](name='SubtitleStream')
            }(name='SubtitleStreamList'),
            videoStreamList?: {
              videoStream?: [ 
              {
                avgFPS?: string(name='AvgFPS'),
                bitrate?: string(name='Bitrate'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                dar?: string(name='Dar'),
                duration?: string(name='Duration'),
                fps?: string(name='Fps'),
                hasBFrames?: string(name='HasBFrames'),
                height?: string(name='Height'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                level?: string(name='Level'),
                networkCost?: {
                  avgBitrate?: string(name='AvgBitrate'),
                  costBandwidth?: string(name='CostBandwidth'),
                  preloadTime?: string(name='PreloadTime'),
                }(name='NetworkCost'),
                numFrames?: string(name='NumFrames'),
                pixFmt?: string(name='PixFmt'),
                profile?: string(name='Profile'),
                sar?: string(name='Sar'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
                width?: string(name='Width'),
              }
            ](name='VideoStream')
            }(name='VideoStreamList'),
          }(name='Streams'),
          width?: string(name='Width'),
        }(name='Properties'),
        rotate?: string(name='Rotate'),
        subtitleConfig?: {
          extSubtitleList?: {
            extSubtitle?: [ 
            {
              charEnc?: string(name='CharEnc'),
              fontName?: string(name='FontName'),
              input?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='Input'),
            }
          ](name='ExtSubtitle')
          }(name='ExtSubtitleList'),
          subtitleList?: {
            subtitle?: [ 
            {
              map?: string(name='Map'),
            }
          ](name='Subtitle')
          }(name='SubtitleList'),
        }(name='SubtitleConfig'),
        superReso?: {
          isHalfSample?: string(name='IsHalfSample'),
        }(name='SuperReso'),
        tailSlateList?: {
          tailSlate?: [ 
          {
            bgColor?: string(name='BgColor'),
            blendDuration?: string(name='BlendDuration'),
            height?: string(name='Height'),
            isMergeAudio?: boolean(name='IsMergeAudio'),
            start?: string(name='Start'),
            tailUrl?: string(name='TailUrl'),
            width?: string(name='Width'),
          }
        ](name='TailSlate')
        }(name='TailSlateList'),
        templateId?: string(name='TemplateId'),
        transConfig?: {
          adjDarMethod?: string(name='AdjDarMethod'),
          isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
          isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
          isCheckReso?: string(name='IsCheckReso'),
          isCheckResoFail?: string(name='IsCheckResoFail'),
          isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
          isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
          transMode?: string(name='TransMode'),
        }(name='TransConfig'),
        userData?: string(name='UserData'),
        video?: {
          bitrate?: string(name='Bitrate'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          bufsize?: string(name='Bufsize'),
          codec?: string(name='Codec'),
          crf?: string(name='Crf'),
          crop?: string(name='Crop'),
          degrain?: string(name='Degrain'),
          fps?: string(name='Fps'),
          gop?: string(name='Gop'),
          height?: string(name='Height'),
          maxFps?: string(name='MaxFps'),
          maxrate?: string(name='Maxrate'),
          pad?: string(name='Pad'),
          pixFmt?: string(name='PixFmt'),
          preset?: string(name='Preset'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          resoPriority?: string(name='ResoPriority'),
          scanMode?: string(name='ScanMode'),
          width?: string(name='Width'),
        }(name='Video'),
        videoStreamMap?: string(name='VideoStreamMap'),
        waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
        waterMarkList?: {
          waterMark?: [ 
          {
            dx?: string(name='Dx'),
            dy?: string(name='Dy'),
            height?: string(name='Height'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
            referPos?: string(name='ReferPos'),
            type?: string(name='Type'),
            waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
            width?: string(name='Width'),
          }
        ](name='WaterMark')
        }(name='WaterMarkList'),
      }(name='Output'),
      percent?: long(name='Percent'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
    }
  ](name='Job')
  }(name='JobList'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobResponseBody(name='body'),
}

async function listJobWithOptions(request: ListJobRequest, runtime: Util.RuntimeOptions): ListJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endOfJobCreatedTimeRange)) {
    query['EndOfJobCreatedTimeRange'] = request.endOfJobCreatedTimeRange;
  }
  if (!Util.isUnset(request.maximumPageSize)) {
    query['MaximumPageSize'] = request.maximumPageSize;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startOfJobCreatedTimeRange)) {
    query['StartOfJobCreatedTimeRange'] = request.startOfJobCreatedTimeRange;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJob(request: ListJobRequest): ListJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobWithOptions(request, runtime);
}

model ListMediaWorkflowExecutionsRequest {
  inputFileURL?: string(name='InputFileURL'),
  maximumPageSize?: long(name='MaximumPageSize'),
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  mediaWorkflowName?: string(name='MediaWorkflowName'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListMediaWorkflowExecutionsResponseBody = {
  mediaWorkflowExecutionList?: {
    mediaWorkflowExecution?: [ 
    {
      activityList?: {
        activity?: [ 
        {
          code?: string(name='Code'),
          endTime?: string(name='EndTime'),
          jobId?: string(name='JobId'),
          MNSMessageResult?: {
            errorCode?: string(name='ErrorCode'),
            errorMessage?: string(name='ErrorMessage'),
            messageId?: string(name='MessageId'),
          }(name='MNSMessageResult'),
          message?: string(name='Message'),
          name?: string(name='Name'),
          startTime?: string(name='StartTime'),
          state?: string(name='State'),
          type?: string(name='Type'),
        }
      ](name='Activity')
      }(name='ActivityList'),
      creationTime?: string(name='CreationTime'),
      input?: {
        inputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='InputFile'),
        userData?: string(name='UserData'),
      }(name='Input'),
      mediaId?: string(name='MediaId'),
      mediaWorkflowId?: string(name='MediaWorkflowId'),
      name?: string(name='Name'),
      runId?: string(name='RunId'),
      state?: string(name='State'),
    }
  ](name='MediaWorkflowExecution')
  }(name='MediaWorkflowExecutionList'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListMediaWorkflowExecutionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMediaWorkflowExecutionsResponseBody(name='body'),
}

async function listMediaWorkflowExecutionsWithOptions(request: ListMediaWorkflowExecutionsRequest, runtime: Util.RuntimeOptions): ListMediaWorkflowExecutionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.inputFileURL)) {
    query['InputFileURL'] = request.inputFileURL;
  }
  if (!Util.isUnset(request.maximumPageSize)) {
    query['MaximumPageSize'] = request.maximumPageSize;
  }
  if (!Util.isUnset(request.mediaWorkflowId)) {
    query['MediaWorkflowId'] = request.mediaWorkflowId;
  }
  if (!Util.isUnset(request.mediaWorkflowName)) {
    query['MediaWorkflowName'] = request.mediaWorkflowName;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMediaWorkflowExecutions',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMediaWorkflowExecutions(request: ListMediaWorkflowExecutionsRequest): ListMediaWorkflowExecutionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMediaWorkflowExecutionsWithOptions(request, runtime);
}

model QueryAnalysisJobListRequest {
  analysisJobIds?: string(name='AnalysisJobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryAnalysisJobListResponseBody = {
  analysisJobList?: {
    analysisJob?: [ 
    {
      analysisConfig?: {
        propertiesControl?: {
          crop?: {
            height?: string(name='Height'),
            left?: string(name='Left'),
            mode?: string(name='Mode'),
            top?: string(name='Top'),
            width?: string(name='Width'),
          }(name='Crop'),
          deinterlace?: string(name='Deinterlace'),
        }(name='PropertiesControl'),
        qualityControl?: {
          methodStreaming?: string(name='MethodStreaming'),
          rateQuality?: string(name='RateQuality'),
        }(name='QualityControl'),
      }(name='AnalysisConfig'),
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      inputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='InputFile'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      percent?: long(name='Percent'),
      pipelineId?: string(name='PipelineId'),
      priority?: string(name='Priority'),
      state?: string(name='State'),
      templateList?: {
        template?: [ 
        {
          audio?: {
            bitrate?: string(name='Bitrate'),
            channels?: string(name='Channels'),
            codec?: string(name='Codec'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            samplerate?: string(name='Samplerate'),
          }(name='Audio'),
          container?: {
            format?: string(name='Format'),
          }(name='Container'),
          id?: string(name='Id'),
          muxConfig?: {
            gif?: {
              finalDelay?: string(name='FinalDelay'),
              loop?: string(name='Loop'),
            }(name='Gif'),
            segment?: {
              duration?: string(name='Duration'),
            }(name='Segment'),
          }(name='MuxConfig'),
          name?: string(name='Name'),
          state?: string(name='State'),
          transConfig?: {
            transMode?: string(name='TransMode'),
          }(name='TransConfig'),
          video?: {
            bitrate?: string(name='Bitrate'),
            bitrateBnd?: {
              max?: string(name='Max'),
              min?: string(name='Min'),
            }(name='BitrateBnd'),
            bufsize?: string(name='Bufsize'),
            codec?: string(name='Codec'),
            crf?: string(name='Crf'),
            degrain?: string(name='Degrain'),
            fps?: string(name='Fps'),
            gop?: string(name='Gop'),
            height?: string(name='Height'),
            maxrate?: string(name='Maxrate'),
            pixFmt?: string(name='PixFmt'),
            preset?: string(name='Preset'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            scanMode?: string(name='ScanMode'),
            width?: string(name='Width'),
          }(name='Video'),
        }
      ](name='Template')
      }(name='TemplateList'),
      userData?: string(name='UserData'),
    }
  ](name='AnalysisJob')
  }(name='AnalysisJobList'),
  nonExistAnalysisJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistAnalysisJobIds'),
  requestId?: string(name='RequestId'),
}

model QueryAnalysisJobListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryAnalysisJobListResponseBody(name='body'),
}

async function queryAnalysisJobListWithOptions(request: QueryAnalysisJobListRequest, runtime: Util.RuntimeOptions): QueryAnalysisJobListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.analysisJobIds)) {
    query['AnalysisJobIds'] = request.analysisJobIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryAnalysisJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryAnalysisJobList(request: QueryAnalysisJobListRequest): QueryAnalysisJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAnalysisJobListWithOptions(request, runtime);
}

model QueryEditingJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryEditingJobListResponseBody = {
  jobList?: {
    job?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      editingConfig?: {
        audio?: {
          bitrate?: string(name='Bitrate'),
          channels?: string(name='Channels'),
          codec?: string(name='Codec'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          samplerate?: string(name='Samplerate'),
          volume?: {
            level?: string(name='Level'),
            method?: string(name='Method'),
          }(name='Volume'),
        }(name='Audio'),
        audioStreamMap?: string(name='AudioStreamMap'),
        clip?: {
          timeSpan?: {
            duration?: string(name='Duration'),
            seek?: string(name='Seek'),
          }(name='TimeSpan'),
        }(name='Clip'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        deWatermark?: string(name='DeWatermark'),
        digiWaterMark?: {
          alpha?: string(name='Alpha'),
          inputFile?: {
            bucket?: string(name='Bucket'),
            location?: string(name='Location'),
            object?: string(name='Object'),
          }(name='InputFile'),
          type?: string(name='Type'),
        }(name='DigiWaterMark'),
        editing?: {
          clipList?: {
            clip?: [ 
            {
              effects?: {
                effect?: [ 
                {
                  effect?: string(name='Effect'),
                  effectConfig?: string(name='EffectConfig'),
                }
              ](name='Effect')
              }(name='Effects'),
              id?: string(name='Id'),
              in?: string(name='In'),
              out?: string(name='Out'),
              sourceID?: string(name='SourceID'),
              sourceStrmMap?: string(name='SourceStrmMap'),
              sourceType?: string(name='SourceType'),
              type?: string(name='Type'),
            }
          ](name='Clip')
          }(name='ClipList'),
          timeline?: {
            timelineConfig?: {
              timelineConfigAudio?: {
                channelLayout?: string(name='ChannelLayout'),
                channels?: string(name='Channels'),
                samplerate?: string(name='Samplerate'),
              }(name='TimelineConfigAudio'),
              timelineConfigVideo?: {
                bgColor?: string(name='BgColor'),
                fps?: string(name='Fps'),
                height?: string(name='Height'),
                isGpuData?: string(name='IsGpuData'),
                isOneTrackData?: string(name='IsOneTrackData'),
                reclosePrec?: string(name='ReclosePrec'),
                renderRatio?: string(name='RenderRatio'),
                width?: string(name='Width'),
              }(name='TimelineConfigVideo'),
            }(name='TimelineConfig'),
            trackList?: {
              track?: [ 
              {
                clips?: {
                  clip?: [ 
                  {
                    clipsConfig?: {
                      clipsConfigVideo?: {
                        l?: string(name='L'),
                        t?: string(name='T'),
                      }(name='ClipsConfigVideo'),
                    }(name='ClipsConfig'),
                    in?: string(name='In'),
                    out?: string(name='Out'),
                    clipID?: string(name='clipID'),
                  }
                ](name='Clip')
                }(name='Clips'),
                id?: string(name='Id'),
                order?: string(name='Order'),
                type?: string(name='Type'),
              }
            ](name='Track')
            }(name='TrackList'),
          }(name='Timeline'),
        }(name='Editing'),
        encryption?: {
          id?: string(name='Id'),
          key?: string(name='Key'),
          keyType?: string(name='KeyType'),
          keyUri?: string(name='KeyUri'),
          skipCnt?: string(name='SkipCnt'),
          type?: string(name='Type'),
        }(name='Encryption'),
        m3U8NonStandardSupport?: {
          TS?: {
            md5Support?: boolean(name='Md5Support'),
            sizeSupport?: boolean(name='SizeSupport'),
          }(name='TS'),
        }(name='M3U8NonStandardSupport'),
        mergeConfigUrl?: string(name='MergeConfigUrl'),
        mergeList?: {
          merge?: [ 
          {
            duration?: string(name='Duration'),
            mergeURL?: string(name='MergeURL'),
            roleArn?: string(name='RoleArn'),
            start?: string(name='Start'),
          }
        ](name='Merge')
        }(name='MergeList'),
        muxConfig?: {
          gif?: {
            ditherMode?: string(name='DitherMode'),
            finalDelay?: string(name='FinalDelay'),
            isCustomPalette?: string(name='IsCustomPalette'),
            loop?: string(name='Loop'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
        }(name='MuxConfig'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='OutputFile'),
        priority?: string(name='Priority'),
        properties?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          fileFormat?: string(name='FileFormat'),
          fileSize?: string(name='FileSize'),
          format?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            formatLongName?: string(name='FormatLongName'),
            formatName?: string(name='FormatName'),
            numPrograms?: string(name='NumPrograms'),
            numStreams?: string(name='NumStreams'),
            size?: string(name='Size'),
            startTime?: string(name='StartTime'),
          }(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          streams?: {
            audioStreamList?: {
              audioStream?: [ 
              {
                bitrate?: string(name='Bitrate'),
                channelLayout?: string(name='ChannelLayout'),
                channels?: string(name='Channels'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                duration?: string(name='Duration'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                numFrames?: string(name='NumFrames'),
                sampleFmt?: string(name='SampleFmt'),
                samplerate?: string(name='Samplerate'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
              }
            ](name='AudioStream')
            }(name='AudioStreamList'),
            subtitleStreamList?: {
              subtitleStream?: [ 
              {
                index?: string(name='Index'),
                lang?: string(name='Lang'),
              }
            ](name='SubtitleStream')
            }(name='SubtitleStreamList'),
            videoStreamList?: {
              videoStream?: [ 
              {
                avgFPS?: string(name='AvgFPS'),
                bitrate?: string(name='Bitrate'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                dar?: string(name='Dar'),
                duration?: string(name='Duration'),
                fps?: string(name='Fps'),
                hasBFrames?: string(name='HasBFrames'),
                height?: string(name='Height'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                level?: string(name='Level'),
                networkCost?: {
                  avgBitrate?: string(name='AvgBitrate'),
                  costBandwidth?: string(name='CostBandwidth'),
                  preloadTime?: string(name='PreloadTime'),
                }(name='NetworkCost'),
                numFrames?: string(name='NumFrames'),
                pixFmt?: string(name='PixFmt'),
                profile?: string(name='Profile'),
                sar?: string(name='Sar'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
                width?: string(name='Width'),
              }
            ](name='VideoStream')
            }(name='VideoStreamList'),
          }(name='Streams'),
          width?: string(name='Width'),
        }(name='Properties'),
        rotate?: string(name='Rotate'),
        subtitleConfig?: {
          extSubtitleList?: {
            extSubtitle?: [ 
            {
              charEnc?: string(name='CharEnc'),
              fontName?: string(name='FontName'),
              input?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='Input'),
            }
          ](name='ExtSubtitle')
          }(name='ExtSubtitleList'),
          subtitleList?: {
            subtitle?: [ 
            {
              map?: string(name='Map'),
            }
          ](name='Subtitle')
          }(name='SubtitleList'),
        }(name='SubtitleConfig'),
        superReso?: {
          isHalfSample?: string(name='IsHalfSample'),
        }(name='SuperReso'),
        templateId?: string(name='TemplateId'),
        transConfig?: {
          adjDarMethod?: string(name='AdjDarMethod'),
          duration?: string(name='Duration'),
          isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
          isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
          isCheckReso?: string(name='IsCheckReso'),
          isCheckResoFail?: string(name='IsCheckResoFail'),
          isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
          isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
          transMode?: string(name='TransMode'),
        }(name='TransConfig'),
        userData?: string(name='UserData'),
        video?: {
          bitrate?: string(name='Bitrate'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          bufsize?: string(name='Bufsize'),
          codec?: string(name='Codec'),
          crf?: string(name='Crf'),
          crop?: string(name='Crop'),
          degrain?: string(name='Degrain'),
          fps?: string(name='Fps'),
          gop?: string(name='Gop'),
          height?: string(name='Height'),
          maxFps?: string(name='MaxFps'),
          maxrate?: string(name='Maxrate'),
          pad?: string(name='Pad'),
          pixFmt?: string(name='PixFmt'),
          preset?: string(name='Preset'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          scanMode?: string(name='ScanMode'),
          width?: string(name='Width'),
        }(name='Video'),
        videoStreamMap?: string(name='VideoStreamMap'),
        waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
        waterMarkList?: {
          waterMark?: [ 
          {
            dx?: string(name='Dx'),
            dy?: string(name='Dy'),
            height?: string(name='Height'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
            referPos?: string(name='ReferPos'),
            type?: string(name='Type'),
            waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
            width?: string(name='Width'),
          }
        ](name='WaterMark')
        }(name='WaterMarkList'),
      }(name='EditingConfig'),
      editingInputs?: {
        editingInput?: [ 
        {
          id?: string(name='Id'),
          inputConfig?: {
            deinterlaceMethod?: string(name='DeinterlaceMethod'),
            isNormalSar?: string(name='IsNormalSar'),
          }(name='InputConfig'),
          inputFile?: {
            bucket?: string(name='Bucket'),
            location?: string(name='Location'),
            object?: string(name='Object'),
          }(name='InputFile'),
        }
      ](name='EditingInput')
      }(name='EditingInputs'),
      finishTime?: string(name='FinishTime'),
      jobId?: string(name='JobId'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      percent?: long(name='Percent'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
}

model QueryEditingJobListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryEditingJobListResponseBody(name='body'),
}

async function queryEditingJobListWithOptions(request: QueryEditingJobListRequest, runtime: Util.RuntimeOptions): QueryEditingJobListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobIds)) {
    query['JobIds'] = request.jobIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEditingJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryEditingJobList(request: QueryEditingJobListRequest): QueryEditingJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEditingJobListWithOptions(request, runtime);
}

model QueryFpDBDeleteJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryFpDBDeleteJobListResponseBody = {
  fpDBDeleteJobList?: {
    fpDBDeleteJob?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      delType?: string(name='DelType'),
      finishTime?: string(name='FinishTime'),
      fpDBId?: string(name='FpDBId'),
      id?: string(name='Id'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      status?: string(name='Status'),
      userData?: string(name='UserData'),
    }
  ](name='FpDBDeleteJob')
  }(name='FpDBDeleteJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryFpDBDeleteJobListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryFpDBDeleteJobListResponseBody(name='body'),
}

async function queryFpDBDeleteJobListWithOptions(request: QueryFpDBDeleteJobListRequest, runtime: Util.RuntimeOptions): QueryFpDBDeleteJobListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobIds)) {
    query['JobIds'] = request.jobIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryFpDBDeleteJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryFpDBDeleteJobList(request: QueryFpDBDeleteJobListRequest): QueryFpDBDeleteJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFpDBDeleteJobListWithOptions(request, runtime);
}

model QueryFpFileDeleteJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryFpFileDeleteJobListResponseBody = {
  fpFileDeleteJobList?: {
    fpFileDeleteJob?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      fileIds?: string(name='FileIds'),
      finishTime?: string(name='FinishTime'),
      fpDBId?: string(name='FpDBId'),
      id?: string(name='Id'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      status?: string(name='Status'),
      userData?: string(name='UserData'),
    }
  ](name='FpFileDeleteJob')
  }(name='FpFileDeleteJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryFpFileDeleteJobListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryFpFileDeleteJobListResponseBody(name='body'),
}

async function queryFpFileDeleteJobListWithOptions(request: QueryFpFileDeleteJobListRequest, runtime: Util.RuntimeOptions): QueryFpFileDeleteJobListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobIds)) {
    query['JobIds'] = request.jobIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryFpFileDeleteJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryFpFileDeleteJobList(request: QueryFpFileDeleteJobListRequest): QueryFpFileDeleteJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFpFileDeleteJobListWithOptions(request, runtime);
}

model QueryFpShotJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryFpShotJobListResponseBody = {
  fpShotJobList?: {
    fpShotJob?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      fileId?: string(name='FileId'),
      finishTime?: string(name='FinishTime'),
      fpShotConfig?: {
        fpDBId?: string(name='FpDBId'),
        primaryKey?: string(name='PrimaryKey'),
        saveType?: string(name='SaveType'),
      }(name='FpShotConfig'),
      fpShotResult?: {
        audioFpShots?: {
          fpShot?: [ 
          {
            fpShotSlices?: {
              fpShotSlice?: [ 
              {
                duplication?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='Duplication'),
                input?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='Input'),
                similarity?: string(name='Similarity'),
              }
            ](name='FpShotSlice')
            }(name='FpShotSlices'),
            primaryKey?: string(name='PrimaryKey'),
            similarity?: string(name='Similarity'),
          }
        ](name='FpShot')
        }(name='AudioFpShots'),
        fpShots?: {
          fpShot?: [ 
          {
            fpShotSlices?: {
              fpShotSlice?: [ 
              {
                duplication?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='Duplication'),
                input?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='Input'),
                similarity?: string(name='Similarity'),
              }
            ](name='FpShotSlice')
            }(name='FpShotSlices'),
            primaryKey?: string(name='PrimaryKey'),
            similarity?: string(name='Similarity'),
          }
        ](name='FpShot')
        }(name='FpShots'),
        textFpShots?: {
          textFpShot?: [ 
          {
            primaryKey?: string(name='PrimaryKey'),
            similarity?: string(name='Similarity'),
            textFpShotSlices?: {
              textFpShotSlice?: [ 
              {
                duplicationText?: string(name='DuplicationText'),
                inputFragment?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='InputFragment'),
                inputText?: string(name='InputText'),
                similarity?: string(name='Similarity'),
              }
            ](name='TextFpShotSlice')
            }(name='TextFpShotSlices'),
          }
        ](name='TextFpShot')
        }(name='TextFpShots'),
      }(name='FpShotResult'),
      id?: string(name='Id'),
      input?: string(name='Input'),
      inputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='InputFile'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
    }
  ](name='FpShotJob')
  }(name='FpShotJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryFpShotJobListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryFpShotJobListResponseBody(name='body'),
}

async function queryFpShotJobListWithOptions(request: QueryFpShotJobListRequest, runtime: Util.RuntimeOptions): QueryFpShotJobListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobIds)) {
    query['JobIds'] = request.jobIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryFpShotJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryFpShotJobList(request: QueryFpShotJobListRequest): QueryFpShotJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFpShotJobListWithOptions(request, runtime);
}

model QueryIProductionJobRequest {
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryIProductionJobResponseBody = {
  functionName?: string(name='FunctionName'),
  input?: string(name='Input'),
  jobId?: string(name='JobId'),
  jobParams?: string(name='JobParams'),
  output?: string(name='Output'),
  pipelineId?: string(name='PipelineId'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  state?: string(name='State'),
  userData?: string(name='UserData'),
}

model QueryIProductionJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryIProductionJobResponseBody(name='body'),
}

async function queryIProductionJobWithOptions(request: QueryIProductionJobRequest, runtime: Util.RuntimeOptions): QueryIProductionJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryIProductionJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryIProductionJob(request: QueryIProductionJobRequest): QueryIProductionJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIProductionJobWithOptions(request, runtime);
}

model QueryJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryJobListResponseBody = {
  jobList?: {
    job?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      output?: {
        audio?: {
          bitrate?: string(name='Bitrate'),
          channels?: string(name='Channels'),
          codec?: string(name='Codec'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          samplerate?: string(name='Samplerate'),
          volume?: {
            level?: string(name='Level'),
            method?: string(name='Method'),
          }(name='Volume'),
        }(name='Audio'),
        audioStreamMap?: string(name='AudioStreamMap'),
        clip?: {
          timeSpan?: {
            duration?: string(name='Duration'),
            seek?: string(name='Seek'),
          }(name='TimeSpan'),
        }(name='Clip'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        deWatermark?: string(name='DeWatermark'),
        encryption?: {
          id?: string(name='Id'),
          key?: string(name='Key'),
          keyType?: string(name='KeyType'),
          keyUri?: string(name='KeyUri'),
          skipCnt?: string(name='SkipCnt'),
          type?: string(name='Type'),
        }(name='Encryption'),
        extendData?: string(name='ExtendData', description='扩展字段'),
        m3U8NonStandardSupport?: {
          TS?: {
            md5Support?: boolean(name='Md5Support'),
            sizeSupport?: boolean(name='SizeSupport'),
          }(name='TS'),
        }(name='M3U8NonStandardSupport'),
        mergeConfigUrl?: string(name='MergeConfigUrl'),
        mergeList?: {
          merge?: [ 
          {
            duration?: string(name='Duration'),
            mergeURL?: string(name='MergeURL'),
            roleArn?: string(name='RoleArn'),
            start?: string(name='Start'),
          }
        ](name='Merge')
        }(name='MergeList'),
        muxConfig?: {
          gif?: {
            ditherMode?: string(name='DitherMode'),
            finalDelay?: string(name='FinalDelay'),
            isCustomPalette?: string(name='IsCustomPalette'),
            loop?: string(name='Loop'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
          webp?: {
            loop?: string(name='Loop'),
          }(name='Webp'),
        }(name='MuxConfig'),
        openingList?: {
          opening?: [ 
          {
            height?: string(name='Height'),
            start?: string(name='Start'),
            width?: string(name='Width'),
            openUrl?: string(name='openUrl'),
          }
        ](name='Opening')
        }(name='OpeningList'),
        outSubtitleList?: {
          outSubtitle?: [ 
          {
            map?: string(name='Map'),
            message?: string(name='Message'),
            outSubtitleFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
              roleArn?: string(name='RoleArn'),
            }(name='OutSubtitleFile'),
            success?: boolean(name='Success'),
          }
        ](name='OutSubtitle')
        }(name='OutSubtitleList'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='OutputFile'),
        priority?: string(name='Priority'),
        properties?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          fileFormat?: string(name='FileFormat'),
          fileSize?: string(name='FileSize'),
          format?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            formatLongName?: string(name='FormatLongName'),
            formatName?: string(name='FormatName'),
            numPrograms?: string(name='NumPrograms'),
            numStreams?: string(name='NumStreams'),
            size?: string(name='Size'),
            startTime?: string(name='StartTime'),
          }(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          sourceLogos?: {
            sourceLogo?: [ 
            {
              source?: string(name='Source'),
            }
          ](name='SourceLogo')
          }(name='SourceLogos'),
          streams?: {
            audioStreamList?: {
              audioStream?: [ 
              {
                bitrate?: string(name='Bitrate'),
                channelLayout?: string(name='ChannelLayout'),
                channels?: string(name='Channels'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                duration?: string(name='Duration'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                numFrames?: string(name='NumFrames'),
                sampleFmt?: string(name='SampleFmt'),
                samplerate?: string(name='Samplerate'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
              }
            ](name='AudioStream')
            }(name='AudioStreamList'),
            subtitleStreamList?: {
              subtitleStream?: [ 
              {
                index?: string(name='Index'),
                lang?: string(name='Lang'),
              }
            ](name='SubtitleStream')
            }(name='SubtitleStreamList'),
            videoStreamList?: {
              videoStream?: [ 
              {
                avgFPS?: string(name='AvgFPS'),
                bitrate?: string(name='Bitrate'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                dar?: string(name='Dar'),
                duration?: string(name='Duration'),
                fps?: string(name='Fps'),
                hasBFrames?: string(name='HasBFrames'),
                height?: string(name='Height'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                level?: string(name='Level'),
                networkCost?: {
                  avgBitrate?: string(name='AvgBitrate'),
                  costBandwidth?: string(name='CostBandwidth'),
                  preloadTime?: string(name='PreloadTime'),
                }(name='NetworkCost'),
                numFrames?: string(name='NumFrames'),
                pixFmt?: string(name='PixFmt'),
                profile?: string(name='Profile'),
                sar?: string(name='Sar'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
                width?: string(name='Width'),
                bitsPerRawSample?: string(name='bitsPerRawSample'),
                colorPrimaries?: string(name='colorPrimaries'),
                colorTransfer?: string(name='colorTransfer'),
              }
            ](name='VideoStream')
            }(name='VideoStreamList'),
          }(name='Streams'),
          width?: string(name='Width'),
        }(name='Properties'),
        rotate?: string(name='Rotate'),
        subtitleConfig?: {
          extSubtitleList?: {
            extSubtitle?: [ 
            {
              charEnc?: string(name='CharEnc'),
              fontName?: string(name='FontName'),
              input?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='Input'),
            }
          ](name='ExtSubtitle')
          }(name='ExtSubtitleList'),
          subtitleList?: {
            subtitle?: [ 
            {
              map?: string(name='Map'),
            }
          ](name='Subtitle')
          }(name='SubtitleList'),
        }(name='SubtitleConfig'),
        superReso?: {
          isHalfSample?: string(name='IsHalfSample'),
        }(name='SuperReso'),
        tailSlateList?: {
          tailSlate?: [ 
          {
            bgColor?: string(name='BgColor'),
            blendDuration?: string(name='BlendDuration'),
            height?: string(name='Height'),
            isMergeAudio?: boolean(name='IsMergeAudio'),
            start?: string(name='Start'),
            tailUrl?: string(name='TailUrl'),
            width?: string(name='Width'),
          }
        ](name='TailSlate')
        }(name='TailSlateList'),
        templateId?: string(name='TemplateId'),
        transConfig?: {
          adjDarMethod?: string(name='AdjDarMethod'),
          isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
          isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
          isCheckReso?: string(name='IsCheckReso'),
          isCheckResoFail?: string(name='IsCheckResoFail'),
          isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
          isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
          transMode?: string(name='TransMode'),
        }(name='TransConfig'),
        userData?: string(name='UserData'),
        video?: {
          bitrate?: string(name='Bitrate'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          bufsize?: string(name='Bufsize'),
          codec?: string(name='Codec'),
          crf?: string(name='Crf'),
          crop?: string(name='Crop'),
          degrain?: string(name='Degrain'),
          fps?: string(name='Fps'),
          gop?: string(name='Gop'),
          height?: string(name='Height'),
          maxFps?: string(name='MaxFps'),
          maxrate?: string(name='Maxrate'),
          pad?: string(name='Pad'),
          pixFmt?: string(name='PixFmt'),
          preset?: string(name='Preset'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          resoPriority?: string(name='ResoPriority'),
          scanMode?: string(name='ScanMode'),
          width?: string(name='Width'),
        }(name='Video'),
        videoStreamMap?: string(name='VideoStreamMap'),
        waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
        waterMarkList?: {
          waterMark?: [ 
          {
            dx?: string(name='Dx'),
            dy?: string(name='Dy'),
            height?: string(name='Height'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
            referPos?: string(name='ReferPos'),
            type?: string(name='Type'),
            waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
            width?: string(name='Width'),
          }
        ](name='WaterMark')
        }(name='WaterMarkList'),
      }(name='Output'),
      percent?: long(name='Percent'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
}

model QueryJobListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryJobListResponseBody(name='body'),
}

async function queryJobListWithOptions(request: QueryJobListRequest, runtime: Util.RuntimeOptions): QueryJobListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobIds)) {
    query['JobIds'] = request.jobIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryJobList(request: QueryJobListRequest): QueryJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryJobListWithOptions(request, runtime);
}

model QueryMediaCensorJobDetailRequest {
  jobId?: string(name='JobId'),
  maximumPageSize?: long(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryMediaCensorJobDetailResponseBody = {
  mediaCensorJobDetail?: {
    barrageCensorResult?: {
      label?: string(name='Label'),
      rate?: string(name='Rate'),
      scene?: string(name='Scene'),
      suggestion?: string(name='Suggestion'),
    }(name='BarrageCensorResult'),
    code?: string(name='Code'),
    coverImageCensorResults?: {
      coverImageCensorResult?: [ 
      {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        results?: {
          result?: [ 
          {
            label?: string(name='Label'),
            rate?: string(name='Rate'),
            scene?: string(name='Scene'),
            suggestion?: string(name='Suggestion'),
          }
        ](name='Result')
        }(name='Results'),
      }
    ](name='CoverImageCensorResult')
    }(name='CoverImageCensorResults'),
    creationTime?: string(name='CreationTime'),
    descCensorResult?: {
      label?: string(name='Label'),
      rate?: string(name='Rate'),
      scene?: string(name='Scene'),
      suggestion?: string(name='Suggestion'),
    }(name='DescCensorResult'),
    finishTime?: string(name='FinishTime'),
    input?: {
      bucket?: string(name='Bucket'),
      location?: string(name='Location'),
      object?: string(name='Object'),
    }(name='Input'),
    jobId?: string(name='JobId'),
    message?: string(name='Message'),
    pipelineId?: string(name='PipelineId'),
    state?: string(name='State'),
    suggestion?: string(name='Suggestion'),
    titleCensorResult?: {
      label?: string(name='Label'),
      rate?: string(name='Rate'),
      scene?: string(name='Scene'),
      suggestion?: string(name='Suggestion'),
    }(name='TitleCensorResult'),
    userData?: string(name='UserData'),
    vensorCensorResult?: {
      censorResults?: {
        censorResult?: [ 
        {
          label?: string(name='Label'),
          rate?: string(name='Rate'),
          scene?: string(name='Scene'),
          suggestion?: string(name='Suggestion'),
        }
      ](name='CensorResult')
      }(name='CensorResults'),
      nextPageToken?: string(name='NextPageToken'),
      videoTimelines?: {
        videoTimeline?: [ 
        {
          censorResults?: {
            censorResult?: [ 
            {
              label?: string(name='Label'),
              rate?: string(name='Rate'),
              scene?: string(name='Scene'),
              suggestion?: string(name='Suggestion'),
            }
          ](name='CensorResult')
          }(name='CensorResults'),
          object?: string(name='Object'),
          timestamp?: string(name='Timestamp'),
        }
      ](name='VideoTimeline')
      }(name='VideoTimelines'),
    }(name='VensorCensorResult'),
    videoCensorConfig?: {
      bizType?: string(name='BizType'),
      outputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='OutputFile'),
      videoCensor?: string(name='VideoCensor'),
    }(name='VideoCensorConfig'),
  }(name='MediaCensorJobDetail'),
  requestId?: string(name='RequestId'),
}

model QueryMediaCensorJobDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMediaCensorJobDetailResponseBody(name='body'),
}

async function queryMediaCensorJobDetailWithOptions(request: QueryMediaCensorJobDetailRequest, runtime: Util.RuntimeOptions): QueryMediaCensorJobDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.maximumPageSize)) {
    query['MaximumPageSize'] = request.maximumPageSize;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaCensorJobDetail',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaCensorJobDetail(request: QueryMediaCensorJobDetailRequest): QueryMediaCensorJobDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaCensorJobDetailWithOptions(request, runtime);
}

model QueryMediaCensorJobListRequest {
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange'),
  jobId?: string(name='JobId'),
  maximumPageSize?: long(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange'),
  state?: string(name='State'),
}

model QueryMediaCensorJobListResponseBody = {
  mediaCensorJobList?: {
    mediaCensorJob?: [ 
    {
      barrageCensorResult?: {
        label?: string(name='Label'),
        rate?: string(name='Rate'),
        scene?: string(name='Scene'),
        suggestion?: string(name='Suggestion'),
      }(name='BarrageCensorResult'),
      code?: string(name='Code'),
      coverImageCensorResults?: {
        coverImageCensorResult?: [ 
        {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          results?: {
            result?: [ 
            {
              label?: string(name='Label'),
              rate?: string(name='Rate'),
              scene?: string(name='Scene'),
              suggestion?: string(name='Suggestion'),
            }
          ](name='Result')
          }(name='Results'),
        }
      ](name='CoverImageCensorResult')
      }(name='CoverImageCensorResults'),
      creationTime?: string(name='CreationTime'),
      descCensorResult?: {
        label?: string(name='Label'),
        rate?: string(name='Rate'),
        scene?: string(name='Scene'),
        suggestion?: string(name='Suggestion'),
      }(name='DescCensorResult'),
      finishTime?: string(name='FinishTime'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      suggestion?: string(name='Suggestion'),
      titleCensorResult?: {
        label?: string(name='Label'),
        rate?: string(name='Rate'),
        scene?: string(name='Scene'),
        suggestion?: string(name='Suggestion'),
      }(name='TitleCensorResult'),
      userData?: string(name='UserData'),
      vensorCensorResult?: {
        censorResults?: {
          censorResult?: [ 
          {
            label?: string(name='Label'),
            rate?: string(name='Rate'),
            scene?: string(name='Scene'),
            suggestion?: string(name='Suggestion'),
          }
        ](name='CensorResult')
        }(name='CensorResults'),
        nextPageToken?: string(name='NextPageToken'),
        videoTimelines?: {
          videoTimeline?: [ 
          {
            censorResults?: {
              censorResult?: [ 
              {
                label?: string(name='Label'),
                rate?: string(name='Rate'),
                scene?: string(name='Scene'),
                suggestion?: string(name='Suggestion'),
              }
            ](name='CensorResult')
            }(name='CensorResults'),
            object?: string(name='Object'),
            timestamp?: string(name='Timestamp'),
          }
        ](name='VideoTimeline')
        }(name='VideoTimelines'),
      }(name='VensorCensorResult'),
      videoCensorConfig?: {
        bizType?: string(name='BizType'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='OutputFile'),
        videoCensor?: string(name='VideoCensor'),
      }(name='VideoCensorConfig'),
    }
  ](name='MediaCensorJob')
  }(name='MediaCensorJobList'),
  nextPageToken?: string(name='NextPageToken'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryMediaCensorJobListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMediaCensorJobListResponseBody(name='body'),
}

async function queryMediaCensorJobListWithOptions(request: QueryMediaCensorJobListRequest, runtime: Util.RuntimeOptions): QueryMediaCensorJobListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endOfJobCreatedTimeRange)) {
    query['EndOfJobCreatedTimeRange'] = request.endOfJobCreatedTimeRange;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.maximumPageSize)) {
    query['MaximumPageSize'] = request.maximumPageSize;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startOfJobCreatedTimeRange)) {
    query['StartOfJobCreatedTimeRange'] = request.startOfJobCreatedTimeRange;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaCensorJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaCensorJobList(request: QueryMediaCensorJobListRequest): QueryMediaCensorJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaCensorJobListWithOptions(request, runtime);
}

model QueryMediaInfoJobListRequest {
  mediaInfoJobIds?: string(name='MediaInfoJobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryMediaInfoJobListResponseBody = {
  mediaInfoJobList?: {
    mediaInfoJob?: [ 
    {
      async?: boolean(name='Async'),
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      properties?: {
        bitrate?: string(name='Bitrate'),
        duration?: string(name='Duration'),
        fileFormat?: string(name='FileFormat'),
        fileSize?: string(name='FileSize'),
        format?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          formatLongName?: string(name='FormatLongName'),
          formatName?: string(name='FormatName'),
          numPrograms?: string(name='NumPrograms'),
          numStreams?: string(name='NumStreams'),
          size?: string(name='Size'),
          startTime?: string(name='StartTime'),
        }(name='Format'),
        fps?: string(name='Fps'),
        height?: string(name='Height'),
        streams?: {
          audioStreamList?: {
            audioStream?: [ 
            {
              bitrate?: string(name='Bitrate'),
              channelLayout?: string(name='ChannelLayout'),
              channels?: string(name='Channels'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              numFrames?: string(name='NumFrames'),
              sampleFmt?: string(name='SampleFmt'),
              samplerate?: string(name='Samplerate'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='AudioStream')
          }(name='AudioStreamList'),
          subtitleStreamList?: {
            subtitleStream?: [ 
            {
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='SubtitleStream')
          }(name='SubtitleStreamList'),
          videoStreamList?: {
            videoStream?: [ 
            {
              avgFPS?: string(name='AvgFPS'),
              bitrate?: string(name='Bitrate'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              colorPrimaries?: string(name='ColorPrimaries'),
              colorRange?: string(name='ColorRange'),
              colorTransfer?: string(name='ColorTransfer'),
              dar?: string(name='Dar'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              hasBFrames?: string(name='HasBFrames'),
              height?: string(name='Height'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              level?: string(name='Level'),
              networkCost?: {
                avgBitrate?: string(name='AvgBitrate'),
                costBandwidth?: string(name='CostBandwidth'),
                preloadTime?: string(name='PreloadTime'),
              }(name='NetworkCost'),
              numFrames?: string(name='NumFrames'),
              pixFmt?: string(name='PixFmt'),
              profile?: string(name='Profile'),
              rotate?: string(name='Rotate'),
              sar?: string(name='Sar'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
              width?: string(name='Width'),
            }
          ](name='VideoStream')
          }(name='VideoStreamList'),
        }(name='Streams'),
        width?: string(name='Width'),
      }(name='Properties'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
    }
  ](name='MediaInfoJob')
  }(name='MediaInfoJobList'),
  nonExistMediaInfoJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistMediaInfoJobIds'),
  requestId?: string(name='RequestId'),
}

model QueryMediaInfoJobListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMediaInfoJobListResponseBody(name='body'),
}

async function queryMediaInfoJobListWithOptions(request: QueryMediaInfoJobListRequest, runtime: Util.RuntimeOptions): QueryMediaInfoJobListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaInfoJobIds)) {
    query['MediaInfoJobIds'] = request.mediaInfoJobIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaInfoJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaInfoJobList(request: QueryMediaInfoJobListRequest): QueryMediaInfoJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaInfoJobListWithOptions(request, runtime);
}

model QueryMediaListRequest {
  includeMediaInfo?: boolean(name='IncludeMediaInfo'),
  includePlayList?: boolean(name='IncludePlayList'),
  includeSnapshotList?: boolean(name='IncludeSnapshotList'),
  includeSummaryList?: boolean(name='IncludeSummaryList'),
  mediaIds?: string(name='MediaIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryMediaListResponseBody = {
  mediaList?: {
    media?: [ 
    {
      bitrate?: string(name='Bitrate'),
      cateId?: long(name='CateId'),
      censorState?: string(name='CensorState'),
      coverURL?: string(name='CoverURL'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      duration?: string(name='Duration'),
      file?: {
        state?: string(name='State'),
        URL?: string(name='URL'),
      }(name='File'),
      format?: string(name='Format'),
      fps?: string(name='Fps'),
      height?: string(name='Height'),
      mediaId?: string(name='MediaId'),
      mediaInfo?: {
        format?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          formatLongName?: string(name='FormatLongName'),
          formatName?: string(name='FormatName'),
          numPrograms?: string(name='NumPrograms'),
          numStreams?: string(name='NumStreams'),
          size?: string(name='Size'),
          startTime?: string(name='StartTime'),
        }(name='Format'),
        streams?: {
          audioStreamList?: {
            audioStream?: [ 
            {
              bitrate?: string(name='Bitrate'),
              channelLayout?: string(name='ChannelLayout'),
              channels?: string(name='Channels'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              numFrames?: string(name='NumFrames'),
              sampleFmt?: string(name='SampleFmt'),
              samplerate?: string(name='Samplerate'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='AudioStream')
          }(name='AudioStreamList'),
          subtitleStreamList?: {
            subtitleStream?: [ 
            {
              index?: string(name='Index'),
              lang?: string(name='Lang'),
            }
          ](name='SubtitleStream')
          }(name='SubtitleStreamList'),
          videoStreamList?: {
            videoStream?: [ 
            {
              avgFPS?: string(name='AvgFPS'),
              bitrate?: string(name='Bitrate'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              dar?: string(name='Dar'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              hasBFrames?: string(name='HasBFrames'),
              height?: string(name='Height'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              level?: string(name='Level'),
              networkCost?: {
                avgBitrate?: string(name='AvgBitrate'),
                costBandwidth?: string(name='CostBandwidth'),
                preloadTime?: string(name='PreloadTime'),
              }(name='NetworkCost'),
              numFrames?: string(name='NumFrames'),
              pixFmt?: string(name='PixFmt'),
              profile?: string(name='Profile'),
              rotate?: string(name='Rotate'),
              sar?: string(name='Sar'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
              width?: string(name='Width'),
            }
          ](name='VideoStream')
          }(name='VideoStreamList'),
        }(name='Streams'),
      }(name='MediaInfo'),
      playList?: {
        play?: [ 
        {
          activityName?: string(name='ActivityName'),
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          encryption?: string(name='Encryption'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          format?: string(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          size?: string(name='Size'),
          width?: string(name='Width'),
        }
      ](name='Play')
      }(name='PlayList'),
      publishState?: string(name='PublishState'),
      runIdList?: {
        runId?: [ string ](name='RunId')
      }(name='RunIdList'),
      size?: string(name='Size'),
      snapshotList?: {
        snapshot?: [ 
        {
          activityName?: string(name='ActivityName'),
          count?: string(name='Count'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          type?: string(name='Type'),
        }
      ](name='Snapshot')
      }(name='SnapshotList'),
      summaryList?: {
        summary?: [ 
        {
          activityName?: string(name='ActivityName'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          type?: string(name='Type'),
        }
      ](name='Summary')
      }(name='SummaryList'),
      tags?: {
        tag?: [ string ](name='Tag')
      }(name='Tags'),
      title?: string(name='Title'),
      width?: string(name='Width'),
    }
  ](name='Media')
  }(name='MediaList'),
  nonExistMediaIds?: {
    mediaId?: [ string ](name='MediaId')
  }(name='NonExistMediaIds'),
  requestId?: string(name='RequestId'),
}

model QueryMediaListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMediaListResponseBody(name='body'),
}

async function queryMediaListWithOptions(request: QueryMediaListRequest, runtime: Util.RuntimeOptions): QueryMediaListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.includeMediaInfo)) {
    query['IncludeMediaInfo'] = request.includeMediaInfo;
  }
  if (!Util.isUnset(request.includePlayList)) {
    query['IncludePlayList'] = request.includePlayList;
  }
  if (!Util.isUnset(request.includeSnapshotList)) {
    query['IncludeSnapshotList'] = request.includeSnapshotList;
  }
  if (!Util.isUnset(request.includeSummaryList)) {
    query['IncludeSummaryList'] = request.includeSummaryList;
  }
  if (!Util.isUnset(request.mediaIds)) {
    query['MediaIds'] = request.mediaIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaList(request: QueryMediaListRequest): QueryMediaListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaListWithOptions(request, runtime);
}

model QueryMediaListByURLRequest {
  fileURLs?: string(name='FileURLs'),
  includeMediaInfo?: boolean(name='IncludeMediaInfo'),
  includePlayList?: boolean(name='IncludePlayList'),
  includeSnapshotList?: boolean(name='IncludeSnapshotList'),
  includeSummaryList?: boolean(name='IncludeSummaryList'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryMediaListByURLResponseBody = {
  mediaList?: {
    media?: [ 
    {
      bitrate?: string(name='Bitrate'),
      cateId?: long(name='CateId'),
      censorState?: string(name='CensorState'),
      coverURL?: string(name='CoverURL'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      duration?: string(name='Duration'),
      file?: {
        state?: string(name='State'),
        URL?: string(name='URL'),
      }(name='File'),
      format?: string(name='Format'),
      fps?: string(name='Fps'),
      height?: string(name='Height'),
      mediaId?: string(name='MediaId'),
      mediaInfo?: {
        format?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          formatLongName?: string(name='FormatLongName'),
          formatName?: string(name='FormatName'),
          numPrograms?: string(name='NumPrograms'),
          numStreams?: string(name='NumStreams'),
          size?: string(name='Size'),
          startTime?: string(name='StartTime'),
        }(name='Format'),
        streams?: {
          audioStreamList?: {
            audioStream?: [ 
            {
              bitrate?: string(name='Bitrate'),
              channelLayout?: string(name='ChannelLayout'),
              channels?: string(name='Channels'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              numFrames?: string(name='NumFrames'),
              sampleFmt?: string(name='SampleFmt'),
              samplerate?: string(name='Samplerate'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='AudioStream')
          }(name='AudioStreamList'),
          subtitleStreamList?: {
            subtitleStream?: [ 
            {
              index?: string(name='Index'),
              lang?: string(name='Lang'),
            }
          ](name='SubtitleStream')
          }(name='SubtitleStreamList'),
          videoStreamList?: {
            videoStream?: [ 
            {
              avgFPS?: string(name='AvgFPS'),
              bitrate?: string(name='Bitrate'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              dar?: string(name='Dar'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              hasBFrames?: string(name='HasBFrames'),
              height?: string(name='Height'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              level?: string(name='Level'),
              networkCost?: {
                avgBitrate?: string(name='AvgBitrate'),
                costBandwidth?: string(name='CostBandwidth'),
                preloadTime?: string(name='PreloadTime'),
              }(name='NetworkCost'),
              numFrames?: string(name='NumFrames'),
              pixFmt?: string(name='PixFmt'),
              profile?: string(name='Profile'),
              rotate?: string(name='Rotate'),
              sar?: string(name='Sar'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
              width?: string(name='Width'),
            }
          ](name='VideoStream')
          }(name='VideoStreamList'),
        }(name='Streams'),
      }(name='MediaInfo'),
      playList?: {
        play?: [ 
        {
          activityName?: string(name='ActivityName'),
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          encryption?: string(name='Encryption'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          format?: string(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          size?: string(name='Size'),
          width?: string(name='Width'),
        }
      ](name='Play')
      }(name='PlayList'),
      publishState?: string(name='PublishState'),
      runIdList?: {
        runId?: [ string ](name='RunId')
      }(name='RunIdList'),
      size?: string(name='Size'),
      snapshotList?: {
        snapshot?: [ 
        {
          activityName?: string(name='ActivityName'),
          count?: string(name='Count'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          type?: string(name='Type'),
        }
      ](name='Snapshot')
      }(name='SnapshotList'),
      summaryList?: {
        summary?: [ 
        {
          activityName?: string(name='ActivityName'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          type?: string(name='Type'),
        }
      ](name='Summary')
      }(name='SummaryList'),
      tags?: {
        tag?: [ string ](name='Tag')
      }(name='Tags'),
      title?: string(name='Title'),
      width?: string(name='Width'),
    }
  ](name='Media')
  }(name='MediaList'),
  nonExistFileURLs?: {
    fileURL?: [ string ](name='FileURL')
  }(name='NonExistFileURLs'),
  requestId?: string(name='RequestId'),
}

model QueryMediaListByURLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMediaListByURLResponseBody(name='body'),
}

async function queryMediaListByURLWithOptions(request: QueryMediaListByURLRequest, runtime: Util.RuntimeOptions): QueryMediaListByURLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileURLs)) {
    query['FileURLs'] = request.fileURLs;
  }
  if (!Util.isUnset(request.includeMediaInfo)) {
    query['IncludeMediaInfo'] = request.includeMediaInfo;
  }
  if (!Util.isUnset(request.includePlayList)) {
    query['IncludePlayList'] = request.includePlayList;
  }
  if (!Util.isUnset(request.includeSnapshotList)) {
    query['IncludeSnapshotList'] = request.includeSnapshotList;
  }
  if (!Util.isUnset(request.includeSummaryList)) {
    query['IncludeSummaryList'] = request.includeSummaryList;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaListByURL',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaListByURL(request: QueryMediaListByURLRequest): QueryMediaListByURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaListByURLWithOptions(request, runtime);
}

model QueryMediaWorkflowExecutionListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  runIds?: string(name='RunIds'),
}

model QueryMediaWorkflowExecutionListResponseBody = {
  mediaWorkflowExecutionList?: {
    mediaWorkflowExecution?: [ 
    {
      activityList?: {
        activity?: [ 
        {
          code?: string(name='Code'),
          endTime?: string(name='EndTime'),
          jobId?: string(name='JobId'),
          MNSMessageResult?: {
            errorCode?: string(name='ErrorCode'),
            errorMessage?: string(name='ErrorMessage'),
            messageId?: string(name='MessageId'),
          }(name='MNSMessageResult'),
          message?: string(name='Message'),
          name?: string(name='Name'),
          startTime?: string(name='StartTime'),
          state?: string(name='State'),
          type?: string(name='Type'),
        }
      ](name='Activity')
      }(name='ActivityList'),
      creationTime?: string(name='CreationTime'),
      input?: {
        inputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='InputFile'),
        userData?: string(name='UserData'),
      }(name='Input'),
      mediaId?: string(name='MediaId'),
      mediaWorkflowId?: string(name='MediaWorkflowId'),
      name?: string(name='Name'),
      runId?: string(name='RunId'),
      state?: string(name='State'),
    }
  ](name='MediaWorkflowExecution')
  }(name='MediaWorkflowExecutionList'),
  nonExistRunIds?: {
    runId?: [ string ](name='RunId')
  }(name='NonExistRunIds'),
  requestId?: string(name='RequestId'),
}

model QueryMediaWorkflowExecutionListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMediaWorkflowExecutionListResponseBody(name='body'),
}

async function queryMediaWorkflowExecutionListWithOptions(request: QueryMediaWorkflowExecutionListRequest, runtime: Util.RuntimeOptions): QueryMediaWorkflowExecutionListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.runIds)) {
    query['RunIds'] = request.runIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaWorkflowExecutionList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaWorkflowExecutionList(request: QueryMediaWorkflowExecutionListRequest): QueryMediaWorkflowExecutionListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaWorkflowExecutionListWithOptions(request, runtime);
}

model QueryMediaWorkflowListRequest {
  mediaWorkflowIds?: string(name='MediaWorkflowIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryMediaWorkflowListResponseBody = {
  mediaWorkflowList?: {
    mediaWorkflow?: [ 
    {
      creationTime?: string(name='CreationTime'),
      mediaWorkflowId?: string(name='MediaWorkflowId'),
      name?: string(name='Name'),
      state?: string(name='State'),
      topology?: string(name='Topology'),
      triggerMode?: string(name='TriggerMode'),
    }
  ](name='MediaWorkflow')
  }(name='MediaWorkflowList'),
  nonExistMediaWorkflowIds?: {
    mediaWorkflowId?: [ string ](name='MediaWorkflowId')
  }(name='NonExistMediaWorkflowIds'),
  requestId?: string(name='RequestId'),
}

model QueryMediaWorkflowListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMediaWorkflowListResponseBody(name='body'),
}

async function queryMediaWorkflowListWithOptions(request: QueryMediaWorkflowListRequest, runtime: Util.RuntimeOptions): QueryMediaWorkflowListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaWorkflowIds)) {
    query['MediaWorkflowIds'] = request.mediaWorkflowIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaWorkflowList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaWorkflowList(request: QueryMediaWorkflowListRequest): QueryMediaWorkflowListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaWorkflowListWithOptions(request, runtime);
}

model QueryPipelineListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineIds?: string(name='PipelineIds'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryPipelineListResponseBody = {
  nonExistPids?: {
    string?: [ string ](name='String')
  }(name='NonExistPids'),
  pipelineList?: {
    pipeline?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      notifyConfig?: {
        mqTag?: string(name='MqTag'),
        mqTopic?: string(name='MqTopic'),
        queueName?: string(name='QueueName'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      quotaAllocate?: long(name='QuotaAllocate'),
      role?: string(name='Role'),
      speed?: string(name='Speed'),
      speedLevel?: long(name='SpeedLevel'),
      state?: string(name='State'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
}

model QueryPipelineListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryPipelineListResponseBody(name='body'),
}

async function queryPipelineListWithOptions(request: QueryPipelineListRequest, runtime: Util.RuntimeOptions): QueryPipelineListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineIds)) {
    query['PipelineIds'] = request.pipelineIds;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryPipelineList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryPipelineList(request: QueryPipelineListRequest): QueryPipelineListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPipelineListWithOptions(request, runtime);
}

model QuerySmarttagJobRequest {
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  params?: string(name='Params'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QuerySmarttagJobResponseBody = {
  jobStatus?: string(name='JobStatus'),
  requestId?: string(name='RequestId'),
  results?: {
    result?: [ 
    {
      data?: string(name='Data'),
      type?: string(name='Type'),
    }
  ](name='Result')
  }(name='Results'),
  userData?: string(name='UserData'),
}

model QuerySmarttagJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySmarttagJobResponseBody(name='body'),
}

async function querySmarttagJobWithOptions(request: QuerySmarttagJobRequest, runtime: Util.RuntimeOptions): QuerySmarttagJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.params)) {
    query['Params'] = request.params;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySmarttagJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySmarttagJob(request: QuerySmarttagJobRequest): QuerySmarttagJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySmarttagJobWithOptions(request, runtime);
}

model QuerySmarttagTemplateListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
}

model QuerySmarttagTemplateListResponseBody = {
  requestId?: string(name='RequestId'),
  templates?: {
    template?: [ 
    {
      analyseTypes?: string(name='AnalyseTypes'),
      faceCategoryIds?: string(name='FaceCategoryIds'),
      faceCustomParamsConfig?: string(name='FaceCustomParamsConfig'),
      industry?: string(name='Industry'),
      isDefault?: boolean(name='IsDefault'),
      keywordConfig?: string(name='KeywordConfig'),
      knowledgeConfig?: string(name='KnowledgeConfig'),
      labelType?: string(name='LabelType'),
      labelVersion?: string(name='LabelVersion'),
      scene?: string(name='Scene'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
    }
  ](name='Template')
  }(name='Templates'),
}

model QuerySmarttagTemplateListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySmarttagTemplateListResponseBody(name='body'),
}

async function querySmarttagTemplateListWithOptions(request: QuerySmarttagTemplateListRequest, runtime: Util.RuntimeOptions): QuerySmarttagTemplateListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySmarttagTemplateList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySmarttagTemplateList(request: QuerySmarttagTemplateListRequest): QuerySmarttagTemplateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySmarttagTemplateListWithOptions(request, runtime);
}

model QuerySnapshotJobListRequest {
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange'),
  maximumPageSize?: long(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  snapshotJobIds?: string(name='SnapshotJobIds'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange'),
  state?: string(name='State'),
}

model QuerySnapshotJobListResponseBody = {
  nextPageToken?: string(name='NextPageToken'),
  nonExistSnapshotJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistSnapshotJobIds'),
  requestId?: string(name='RequestId'),
  snapshotJobList?: {
    snapshotJob?: [ 
    {
      code?: string(name='Code'),
      count?: string(name='Count'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        roleArn?: string(name='RoleArn'),
      }(name='Input'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      snapshotConfig?: {
        frameType?: string(name='FrameType'),
        height?: string(name='Height'),
        interval?: string(name='Interval'),
        num?: string(name='Num'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='OutputFile'),
        tileOut?: {
          cellHeight?: string(name='CellHeight'),
          cellSelStep?: string(name='CellSelStep'),
          cellWidth?: string(name='CellWidth'),
          color?: string(name='Color'),
          columns?: string(name='Columns'),
          isKeepCellPic?: string(name='IsKeepCellPic'),
          lines?: string(name='Lines'),
          margin?: string(name='Margin'),
          padding?: string(name='Padding'),
        }(name='TileOut'),
        tileOutputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='TileOutputFile'),
        time?: string(name='Time'),
        width?: string(name='Width'),
      }(name='SnapshotConfig'),
      state?: string(name='State'),
      tileCount?: string(name='TileCount'),
      userData?: string(name='UserData'),
    }
  ](name='SnapshotJob')
  }(name='SnapshotJobList'),
}

model QuerySnapshotJobListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySnapshotJobListResponseBody(name='body'),
}

async function querySnapshotJobListWithOptions(request: QuerySnapshotJobListRequest, runtime: Util.RuntimeOptions): QuerySnapshotJobListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endOfJobCreatedTimeRange)) {
    query['EndOfJobCreatedTimeRange'] = request.endOfJobCreatedTimeRange;
  }
  if (!Util.isUnset(request.maximumPageSize)) {
    query['MaximumPageSize'] = request.maximumPageSize;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.snapshotJobIds)) {
    query['SnapshotJobIds'] = request.snapshotJobIds;
  }
  if (!Util.isUnset(request.startOfJobCreatedTimeRange)) {
    query['StartOfJobCreatedTimeRange'] = request.startOfJobCreatedTimeRange;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySnapshotJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySnapshotJobList(request: QuerySnapshotJobListRequest): QuerySnapshotJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySnapshotJobListWithOptions(request, runtime);
}

model QueryTemplateListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateIds?: string(name='TemplateIds'),
}

model QueryTemplateListResponseBody = {
  nonExistTids?: {
    string?: [ string ](name='String')
  }(name='NonExistTids'),
  requestId?: string(name='RequestId'),
  templateList?: {
    template?: [ 
    {
      audio?: {
        bitrate?: string(name='Bitrate'),
        channels?: string(name='Channels'),
        codec?: string(name='Codec'),
        profile?: string(name='Profile'),
        qscale?: string(name='Qscale'),
        remove?: string(name='Remove'),
        samplerate?: string(name='Samplerate'),
      }(name='Audio'),
      container?: {
        format?: string(name='Format'),
      }(name='Container'),
      id?: string(name='Id'),
      muxConfig?: {
        gif?: {
          ditherMode?: string(name='DitherMode'),
          finalDelay?: string(name='FinalDelay'),
          isCustomPalette?: string(name='IsCustomPalette'),
          loop?: string(name='Loop'),
        }(name='Gif'),
        segment?: {
          duration?: string(name='Duration'),
        }(name='Segment'),
        webp?: {
          loop?: string(name='Loop'),
        }(name='Webp'),
      }(name='MuxConfig'),
      name?: string(name='Name'),
      state?: string(name='State'),
      transConfig?: {
        adjDarMethod?: string(name='AdjDarMethod'),
        isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
        isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
        isCheckReso?: string(name='IsCheckReso'),
        isCheckResoFail?: string(name='IsCheckResoFail'),
        isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
        isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
        transMode?: string(name='TransMode'),
      }(name='TransConfig'),
      video?: {
        bitrate?: string(name='Bitrate'),
        bitrateBnd?: {
          max?: string(name='Max'),
          min?: string(name='Min'),
        }(name='BitrateBnd'),
        bufsize?: string(name='Bufsize'),
        codec?: string(name='Codec'),
        crf?: string(name='Crf'),
        crop?: string(name='Crop'),
        degrain?: string(name='Degrain'),
        fps?: string(name='Fps'),
        gop?: string(name='Gop'),
        height?: string(name='Height'),
        longShortMode?: string(name='LongShortMode'),
        maxFps?: string(name='MaxFps'),
        maxrate?: string(name='Maxrate'),
        pad?: string(name='Pad'),
        pixFmt?: string(name='PixFmt'),
        preset?: string(name='Preset'),
        profile?: string(name='Profile'),
        qscale?: string(name='Qscale'),
        remove?: string(name='Remove'),
        resoPriority?: string(name='ResoPriority'),
        scanMode?: string(name='ScanMode'),
        width?: string(name='Width'),
      }(name='Video'),
    }
  ](name='Template')
  }(name='TemplateList'),
}

model QueryTemplateListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTemplateListResponseBody(name='body'),
}

async function queryTemplateListWithOptions(request: QueryTemplateListRequest, runtime: Util.RuntimeOptions): QueryTemplateListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.templateIds)) {
    query['TemplateIds'] = request.templateIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTemplateList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTemplateList(request: QueryTemplateListRequest): QueryTemplateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTemplateListWithOptions(request, runtime);
}

model QueryVideoQualityJobRequest {
  jobId?: string(name='JobId'),
  userId?: long(name='UserId'),
}

model QueryVideoQualityJobResponseBody = {
  code?: string(name='Code'),
  job?: {
    jobId?: string(name='JobId'),
    message?: string(name='Message'),
    output?: string(name='Output'),
    status?: string(name='Status'),
    userId?: long(name='UserId'),
    videoQualityResults?: string(name='VideoQualityResults'),
  }(name='Job'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryVideoQualityJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryVideoQualityJobResponseBody(name='body'),
}

async function queryVideoQualityJobWithOptions(request: QueryVideoQualityJobRequest, runtime: Util.RuntimeOptions): QueryVideoQualityJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryVideoQualityJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryVideoQualityJob(request: QueryVideoQualityJobRequest): QueryVideoQualityJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryVideoQualityJobWithOptions(request, runtime);
}

model QueryWaterMarkTemplateListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  waterMarkTemplateIds?: string(name='WaterMarkTemplateIds'),
}

model QueryWaterMarkTemplateListResponseBody = {
  nonExistWids?: {
    string?: [ string ](name='String')
  }(name='NonExistWids'),
  requestId?: string(name='RequestId'),
  waterMarkTemplateList?: {
    waterMarkTemplate?: [ 
    {
      dx?: string(name='Dx'),
      dy?: string(name='Dy'),
      height?: string(name='Height'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      ratioRefer?: {
        dx?: string(name='Dx'),
        dy?: string(name='Dy'),
        height?: string(name='Height'),
        width?: string(name='Width'),
      }(name='RatioRefer'),
      referPos?: string(name='ReferPos'),
      state?: string(name='State'),
      timeline?: {
        duration?: string(name='Duration'),
        start?: string(name='Start'),
      }(name='Timeline'),
      type?: string(name='Type'),
      width?: string(name='Width'),
    }
  ](name='WaterMarkTemplate')
  }(name='WaterMarkTemplateList'),
}

model QueryWaterMarkTemplateListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryWaterMarkTemplateListResponseBody(name='body'),
}

async function queryWaterMarkTemplateListWithOptions(request: QueryWaterMarkTemplateListRequest, runtime: Util.RuntimeOptions): QueryWaterMarkTemplateListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.waterMarkTemplateIds)) {
    query['WaterMarkTemplateIds'] = request.waterMarkTemplateIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryWaterMarkTemplateList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryWaterMarkTemplateList(request: QueryWaterMarkTemplateListRequest): QueryWaterMarkTemplateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryWaterMarkTemplateListWithOptions(request, runtime);
}

model RegisterCustomFaceRequest {
  categoryId?: string(name='CategoryId'),
  imageUrl?: string(name='ImageUrl'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  personId?: string(name='PersonId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RegisterCustomFaceResponseBody = {
  faceId?: string(name='FaceId'),
  requestId?: string(name='RequestId'),
}

model RegisterCustomFaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterCustomFaceResponseBody(name='body'),
}

async function registerCustomFaceWithOptions(request: RegisterCustomFaceRequest, runtime: Util.RuntimeOptions): RegisterCustomFaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.categoryId)) {
    query['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.imageUrl)) {
    query['ImageUrl'] = request.imageUrl;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.personId)) {
    query['PersonId'] = request.personId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RegisterCustomFace',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerCustomFace(request: RegisterCustomFaceRequest): RegisterCustomFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerCustomFaceWithOptions(request, runtime);
}

model ReportFpShotJobResultRequest {
  details?: string(name='Details'),
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  result?: string(name='Result'),
}

model ReportFpShotJobResultResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model ReportFpShotJobResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReportFpShotJobResultResponseBody(name='body'),
}

async function reportFpShotJobResultWithOptions(request: ReportFpShotJobResultRequest, runtime: Util.RuntimeOptions): ReportFpShotJobResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.details)) {
    query['Details'] = request.details;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.result)) {
    query['Result'] = request.result;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReportFpShotJobResult',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportFpShotJobResult(request: ReportFpShotJobResultRequest): ReportFpShotJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportFpShotJobResultWithOptions(request, runtime);
}

model SearchMediaWorkflowRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  stateList?: string(name='StateList'),
}

model SearchMediaWorkflowResponseBody = {
  mediaWorkflowList?: {
    mediaWorkflow?: [ 
    {
      creationTime?: string(name='CreationTime'),
      mediaWorkflowId?: string(name='MediaWorkflowId'),
      name?: string(name='Name'),
      state?: string(name='State'),
      topology?: string(name='Topology'),
      triggerMode?: string(name='TriggerMode'),
    }
  ](name='MediaWorkflow')
  }(name='MediaWorkflowList'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model SearchMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchMediaWorkflowResponseBody(name='body'),
}

async function searchMediaWorkflowWithOptions(request: SearchMediaWorkflowRequest, runtime: Util.RuntimeOptions): SearchMediaWorkflowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.stateList)) {
    query['StateList'] = request.stateList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchMediaWorkflow',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchMediaWorkflow(request: SearchMediaWorkflowRequest): SearchMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchMediaWorkflowWithOptions(request, runtime);
}

model SearchPipelineRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  state?: string(name='State'),
}

model SearchPipelineResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  pipelineList?: {
    pipeline?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      notifyConfig?: {
        mqTag?: string(name='MqTag'),
        mqTopic?: string(name='MqTopic'),
        queueName?: string(name='QueueName'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      quotaAllocate?: long(name='QuotaAllocate'),
      role?: string(name='Role'),
      speed?: string(name='Speed'),
      speedLevel?: long(name='SpeedLevel'),
      state?: string(name='State'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model SearchPipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchPipelineResponseBody(name='body'),
}

async function searchPipelineWithOptions(request: SearchPipelineRequest, runtime: Util.RuntimeOptions): SearchPipelineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchPipeline(request: SearchPipelineRequest): SearchPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchPipelineWithOptions(request, runtime);
}

model SearchTemplateRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  state?: string(name='State'),
}

model SearchTemplateResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  templateList?: {
    template?: [ 
    {
      audio?: {
        bitrate?: string(name='Bitrate'),
        channels?: string(name='Channels'),
        codec?: string(name='Codec'),
        profile?: string(name='Profile'),
        qscale?: string(name='Qscale'),
        remove?: string(name='Remove'),
        samplerate?: string(name='Samplerate'),
      }(name='Audio'),
      container?: {
        format?: string(name='Format'),
      }(name='Container'),
      id?: string(name='Id'),
      muxConfig?: {
        gif?: {
          ditherMode?: string(name='DitherMode'),
          finalDelay?: string(name='FinalDelay'),
          isCustomPalette?: string(name='IsCustomPalette'),
          loop?: string(name='Loop'),
        }(name='Gif'),
        segment?: {
          duration?: string(name='Duration'),
        }(name='Segment'),
      }(name='MuxConfig'),
      name?: string(name='Name'),
      state?: string(name='State'),
      transConfig?: {
        adjDarMethod?: string(name='AdjDarMethod'),
        isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
        isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
        isCheckReso?: string(name='IsCheckReso'),
        isCheckResoFail?: string(name='IsCheckResoFail'),
        isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
        isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
        transMode?: string(name='TransMode'),
      }(name='TransConfig'),
      video?: {
        bitrate?: string(name='Bitrate'),
        bitrateBnd?: {
          max?: string(name='Max'),
          min?: string(name='Min'),
        }(name='BitrateBnd'),
        bufsize?: string(name='Bufsize'),
        codec?: string(name='Codec'),
        crf?: string(name='Crf'),
        crop?: string(name='Crop'),
        degrain?: string(name='Degrain'),
        fps?: string(name='Fps'),
        gop?: string(name='Gop'),
        height?: string(name='Height'),
        longShortMode?: string(name='LongShortMode'),
        maxFps?: string(name='MaxFps'),
        maxrate?: string(name='Maxrate'),
        pad?: string(name='Pad'),
        pixFmt?: string(name='PixFmt'),
        preset?: string(name='Preset'),
        profile?: string(name='Profile'),
        qscale?: string(name='Qscale'),
        remove?: string(name='Remove'),
        scanMode?: string(name='ScanMode'),
        width?: string(name='Width'),
      }(name='Video'),
    }
  ](name='Template')
  }(name='TemplateList'),
  totalCount?: long(name='TotalCount'),
}

model SearchTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchTemplateResponseBody(name='body'),
}

async function searchTemplateWithOptions(request: SearchTemplateRequest, runtime: Util.RuntimeOptions): SearchTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchTemplate(request: SearchTemplateRequest): SearchTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTemplateWithOptions(request, runtime);
}

model SearchWaterMarkTemplateRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  state?: string(name='State'),
}

model SearchWaterMarkTemplateResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  waterMarkTemplateList?: {
    waterMarkTemplate?: [ 
    {
      dx?: string(name='Dx'),
      dy?: string(name='Dy'),
      height?: string(name='Height'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      ratioRefer?: {
        dx?: string(name='Dx'),
        dy?: string(name='Dy'),
        height?: string(name='Height'),
        width?: string(name='Width'),
      }(name='RatioRefer'),
      referPos?: string(name='ReferPos'),
      state?: string(name='State'),
      timeline?: {
        duration?: string(name='Duration'),
        start?: string(name='Start'),
      }(name='Timeline'),
      type?: string(name='Type'),
      width?: string(name='Width'),
    }
  ](name='WaterMarkTemplate')
  }(name='WaterMarkTemplateList'),
}

model SearchWaterMarkTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchWaterMarkTemplateResponseBody(name='body'),
}

async function searchWaterMarkTemplateWithOptions(request: SearchWaterMarkTemplateRequest, runtime: Util.RuntimeOptions): SearchWaterMarkTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchWaterMarkTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchWaterMarkTemplate(request: SearchWaterMarkTemplateRequest): SearchWaterMarkTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchWaterMarkTemplateWithOptions(request, runtime);
}

model SubmitAnalysisJobRequest {
  analysisConfig?: string(name='AnalysisConfig'),
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  priority?: string(name='Priority'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitAnalysisJobResponseBody = {
  analysisJob?: {
    analysisConfig?: {
      propertiesControl?: {
        crop?: {
          height?: string(name='Height'),
          left?: string(name='Left'),
          mode?: string(name='Mode'),
          top?: string(name='Top'),
          width?: string(name='Width'),
        }(name='Crop'),
        deinterlace?: string(name='Deinterlace'),
      }(name='PropertiesControl'),
      qualityControl?: {
        methodStreaming?: string(name='MethodStreaming'),
        rateQuality?: string(name='RateQuality'),
      }(name='QualityControl'),
    }(name='AnalysisConfig'),
    code?: string(name='Code'),
    creationTime?: string(name='CreationTime'),
    id?: string(name='Id'),
    inputFile?: {
      bucket?: string(name='Bucket'),
      location?: string(name='Location'),
      object?: string(name='Object'),
    }(name='InputFile'),
    MNSMessageResult?: {
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      messageId?: string(name='MessageId'),
    }(name='MNSMessageResult'),
    message?: string(name='Message'),
    percent?: long(name='Percent'),
    pipelineId?: string(name='PipelineId'),
    priority?: string(name='Priority'),
    state?: string(name='State'),
    templateList?: {
      template?: [ 
      {
        audio?: {
          bitrate?: string(name='Bitrate'),
          channels?: string(name='Channels'),
          codec?: string(name='Codec'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          samplerate?: string(name='Samplerate'),
        }(name='Audio'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        id?: string(name='Id'),
        muxConfig?: {
          gif?: {
            finalDelay?: string(name='FinalDelay'),
            loop?: string(name='Loop'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
        }(name='MuxConfig'),
        name?: string(name='Name'),
        state?: string(name='State'),
        transConfig?: {
          transMode?: string(name='TransMode'),
        }(name='TransConfig'),
        video?: {
          bitrate?: string(name='Bitrate'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          bufsize?: string(name='Bufsize'),
          codec?: string(name='Codec'),
          crf?: string(name='Crf'),
          degrain?: string(name='Degrain'),
          fps?: string(name='Fps'),
          gop?: string(name='Gop'),
          height?: string(name='Height'),
          maxrate?: string(name='Maxrate'),
          pixFmt?: string(name='PixFmt'),
          preset?: string(name='Preset'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          scanMode?: string(name='ScanMode'),
          width?: string(name='Width'),
        }(name='Video'),
      }
    ](name='Template')
    }(name='TemplateList'),
    userData?: string(name='UserData'),
  }(name='AnalysisJob'),
  requestId?: string(name='RequestId'),
}

model SubmitAnalysisJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitAnalysisJobResponseBody(name='body'),
}

async function submitAnalysisJobWithOptions(request: SubmitAnalysisJobRequest, runtime: Util.RuntimeOptions): SubmitAnalysisJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.analysisConfig)) {
    query['AnalysisConfig'] = request.analysisConfig;
  }
  if (!Util.isUnset(request.input)) {
    query['Input'] = request.input;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitAnalysisJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitAnalysisJob(request: SubmitAnalysisJobRequest): SubmitAnalysisJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAnalysisJobWithOptions(request, runtime);
}

model SubmitEditingJobsRequest {
  editingInputs?: string(name='EditingInputs'),
  editingJobOssFileRoleArn?: string(name='EditingJobOssFileRoleArn'),
  editingJobOssFileUid?: long(name='EditingJobOssFileUid'),
  editingJobOutputs?: string(name='EditingJobOutputs'),
  editingJobURL?: string(name='EditingJobURL'),
  outputBucket?: string(name='OutputBucket'),
  outputLocation?: string(name='OutputLocation'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SubmitEditingJobsResponseBody = {
  jobResultList?: {
    jobResult?: [ 
    {
      code?: string(name='Code'),
      job?: {
        code?: string(name='Code'),
        creationTime?: string(name='CreationTime'),
        editingConfig?: {
          audio?: {
            bitrate?: string(name='Bitrate'),
            channels?: string(name='Channels'),
            codec?: string(name='Codec'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            samplerate?: string(name='Samplerate'),
            volume?: {
              level?: string(name='Level'),
              method?: string(name='Method'),
            }(name='Volume'),
          }(name='Audio'),
          audioStreamMap?: string(name='AudioStreamMap'),
          clip?: {
            timeSpan?: {
              duration?: string(name='Duration'),
              seek?: string(name='Seek'),
            }(name='TimeSpan'),
          }(name='Clip'),
          container?: {
            format?: string(name='Format'),
          }(name='Container'),
          deWatermark?: string(name='DeWatermark'),
          digiWaterMark?: {
            alpha?: string(name='Alpha'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
            type?: string(name='Type'),
          }(name='DigiWaterMark'),
          editing?: {
            clipList?: {
              clip?: [ 
              {
                effects?: {
                  effect?: [ 
                  {
                    effect?: string(name='Effect'),
                    effectConfig?: string(name='EffectConfig'),
                  }
                ](name='Effect')
                }(name='Effects'),
                id?: string(name='Id'),
                in?: string(name='In'),
                out?: string(name='Out'),
                sourceID?: string(name='SourceID'),
                sourceStrmMap?: string(name='SourceStrmMap'),
                sourceType?: string(name='SourceType'),
                type?: string(name='Type'),
              }
            ](name='Clip')
            }(name='ClipList'),
            timeline?: {
              timelineConfig?: {
                timelineConfigAudio?: {
                  channelLayout?: string(name='ChannelLayout'),
                  channels?: string(name='Channels'),
                  samplerate?: string(name='Samplerate'),
                }(name='TimelineConfigAudio'),
                timelineConfigVideo?: {
                  bgColor?: string(name='BgColor'),
                  fps?: string(name='Fps'),
                  height?: string(name='Height'),
                  isGpuData?: string(name='IsGpuData'),
                  isOneTrackData?: string(name='IsOneTrackData'),
                  reclosePrec?: string(name='ReclosePrec'),
                  renderRatio?: string(name='RenderRatio'),
                  width?: string(name='Width'),
                }(name='TimelineConfigVideo'),
              }(name='TimelineConfig'),
              trackList?: {
                track?: [ 
                {
                  clips?: {
                    clip?: [ 
                    {
                      clipsConfig?: {
                        clipsConfigVideo?: {
                          l?: string(name='L'),
                          t?: string(name='T'),
                        }(name='ClipsConfigVideo'),
                      }(name='ClipsConfig'),
                      in?: string(name='In'),
                      out?: string(name='Out'),
                      clipID?: string(name='clipID'),
                    }
                  ](name='Clip')
                  }(name='Clips'),
                  id?: string(name='Id'),
                  order?: string(name='Order'),
                  type?: string(name='Type'),
                }
              ](name='Track')
              }(name='TrackList'),
            }(name='Timeline'),
          }(name='Editing'),
          encryption?: {
            id?: string(name='Id'),
            key?: string(name='Key'),
            keyType?: string(name='KeyType'),
            keyUri?: string(name='KeyUri'),
            skipCnt?: string(name='SkipCnt'),
            type?: string(name='Type'),
          }(name='Encryption'),
          m3U8NonStandardSupport?: {
            TS?: {
              md5Support?: boolean(name='Md5Support'),
              sizeSupport?: boolean(name='SizeSupport'),
            }(name='TS'),
          }(name='M3U8NonStandardSupport'),
          mergeConfigUrl?: string(name='MergeConfigUrl'),
          mergeList?: {
            merge?: [ 
            {
              duration?: string(name='Duration'),
              mergeURL?: string(name='MergeURL'),
              roleArn?: string(name='RoleArn'),
              start?: string(name='Start'),
            }
          ](name='Merge')
          }(name='MergeList'),
          muxConfig?: {
            gif?: {
              ditherMode?: string(name='DitherMode'),
              finalDelay?: string(name='FinalDelay'),
              isCustomPalette?: string(name='IsCustomPalette'),
              loop?: string(name='Loop'),
            }(name='Gif'),
            segment?: {
              duration?: string(name='Duration'),
            }(name='Segment'),
          }(name='MuxConfig'),
          outputFile?: {
            bucket?: string(name='Bucket'),
            location?: string(name='Location'),
            object?: string(name='Object'),
            roleArn?: string(name='RoleArn'),
          }(name='OutputFile'),
          priority?: string(name='Priority'),
          properties?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            fileFormat?: string(name='FileFormat'),
            fileSize?: string(name='FileSize'),
            format?: {
              bitrate?: string(name='Bitrate'),
              duration?: string(name='Duration'),
              formatLongName?: string(name='FormatLongName'),
              formatName?: string(name='FormatName'),
              numPrograms?: string(name='NumPrograms'),
              numStreams?: string(name='NumStreams'),
              size?: string(name='Size'),
              startTime?: string(name='StartTime'),
            }(name='Format'),
            fps?: string(name='Fps'),
            height?: string(name='Height'),
            streams?: {
              audioStreamList?: {
                audioStream?: [ 
                {
                  bitrate?: string(name='Bitrate'),
                  channelLayout?: string(name='ChannelLayout'),
                  channels?: string(name='Channels'),
                  codecLongName?: string(name='CodecLongName'),
                  codecName?: string(name='CodecName'),
                  codecTag?: string(name='CodecTag'),
                  codecTagString?: string(name='CodecTagString'),
                  codecTimeBase?: string(name='CodecTimeBase'),
                  duration?: string(name='Duration'),
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                  numFrames?: string(name='NumFrames'),
                  sampleFmt?: string(name='SampleFmt'),
                  samplerate?: string(name='Samplerate'),
                  startTime?: string(name='StartTime'),
                  timebase?: string(name='Timebase'),
                }
              ](name='AudioStream')
              }(name='AudioStreamList'),
              subtitleStreamList?: {
                subtitleStream?: [ 
                {
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                }
              ](name='SubtitleStream')
              }(name='SubtitleStreamList'),
              videoStreamList?: {
                videoStream?: [ 
                {
                  avgFPS?: string(name='AvgFPS'),
                  bitrate?: string(name='Bitrate'),
                  codecLongName?: string(name='CodecLongName'),
                  codecName?: string(name='CodecName'),
                  codecTag?: string(name='CodecTag'),
                  codecTagString?: string(name='CodecTagString'),
                  codecTimeBase?: string(name='CodecTimeBase'),
                  dar?: string(name='Dar'),
                  duration?: string(name='Duration'),
                  fps?: string(name='Fps'),
                  hasBFrames?: string(name='HasBFrames'),
                  height?: string(name='Height'),
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                  level?: string(name='Level'),
                  networkCost?: {
                    avgBitrate?: string(name='AvgBitrate'),
                    costBandwidth?: string(name='CostBandwidth'),
                    preloadTime?: string(name='PreloadTime'),
                  }(name='NetworkCost'),
                  numFrames?: string(name='NumFrames'),
                  pixFmt?: string(name='PixFmt'),
                  profile?: string(name='Profile'),
                  sar?: string(name='Sar'),
                  startTime?: string(name='StartTime'),
                  timebase?: string(name='Timebase'),
                  width?: string(name='Width'),
                }
              ](name='VideoStream')
              }(name='VideoStreamList'),
            }(name='Streams'),
            width?: string(name='Width'),
          }(name='Properties'),
          rotate?: string(name='Rotate'),
          subtitleConfig?: {
            extSubtitleList?: {
              extSubtitle?: [ 
              {
                charEnc?: string(name='CharEnc'),
                fontName?: string(name='FontName'),
                input?: {
                  bucket?: string(name='Bucket'),
                  location?: string(name='Location'),
                  object?: string(name='Object'),
                }(name='Input'),
              }
            ](name='ExtSubtitle')
            }(name='ExtSubtitleList'),
            subtitleList?: {
              subtitle?: [ 
              {
                map?: string(name='Map'),
              }
            ](name='Subtitle')
            }(name='SubtitleList'),
          }(name='SubtitleConfig'),
          superReso?: {
            isHalfSample?: string(name='IsHalfSample'),
          }(name='SuperReso'),
          templateId?: string(name='TemplateId'),
          transConfig?: {
            adjDarMethod?: string(name='AdjDarMethod'),
            duration?: string(name='Duration'),
            isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
            isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
            isCheckReso?: string(name='IsCheckReso'),
            isCheckResoFail?: string(name='IsCheckResoFail'),
            isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
            isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
            transMode?: string(name='TransMode'),
          }(name='TransConfig'),
          userData?: string(name='UserData'),
          video?: {
            bitrate?: string(name='Bitrate'),
            bitrateBnd?: {
              max?: string(name='Max'),
              min?: string(name='Min'),
            }(name='BitrateBnd'),
            bufsize?: string(name='Bufsize'),
            codec?: string(name='Codec'),
            crf?: string(name='Crf'),
            crop?: string(name='Crop'),
            degrain?: string(name='Degrain'),
            fps?: string(name='Fps'),
            gop?: string(name='Gop'),
            height?: string(name='Height'),
            maxFps?: string(name='MaxFps'),
            maxrate?: string(name='Maxrate'),
            pad?: string(name='Pad'),
            pixFmt?: string(name='PixFmt'),
            preset?: string(name='Preset'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            scanMode?: string(name='ScanMode'),
            width?: string(name='Width'),
          }(name='Video'),
          videoStreamMap?: string(name='VideoStreamMap'),
          waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
          waterMarkList?: {
            waterMark?: [ 
            {
              dx?: string(name='Dx'),
              dy?: string(name='Dy'),
              height?: string(name='Height'),
              inputFile?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='InputFile'),
              referPos?: string(name='ReferPos'),
              type?: string(name='Type'),
              waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
              width?: string(name='Width'),
            }
          ](name='WaterMark')
          }(name='WaterMarkList'),
        }(name='EditingConfig'),
        editingInputs?: {
          editingInput?: [ 
          {
            id?: string(name='Id'),
            inputConfig?: {
              deinterlaceMethod?: string(name='DeinterlaceMethod'),
              isNormalSar?: string(name='IsNormalSar'),
            }(name='InputConfig'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
          }
        ](name='EditingInput')
        }(name='EditingInputs'),
        finishTime?: string(name='FinishTime'),
        jobId?: string(name='JobId'),
        MNSMessageResult?: {
          errorCode?: string(name='ErrorCode'),
          errorMessage?: string(name='ErrorMessage'),
          messageId?: string(name='MessageId'),
        }(name='MNSMessageResult'),
        message?: string(name='Message'),
        percent?: long(name='Percent'),
        pipelineId?: string(name='PipelineId'),
        state?: string(name='State'),
      }(name='Job'),
      message?: string(name='Message'),
      success?: boolean(name='Success'),
    }
  ](name='JobResult')
  }(name='JobResultList'),
  requestId?: string(name='RequestId'),
}

model SubmitEditingJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitEditingJobsResponseBody(name='body'),
}

async function submitEditingJobsWithOptions(request: SubmitEditingJobsRequest, runtime: Util.RuntimeOptions): SubmitEditingJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.editingInputs)) {
    query['EditingInputs'] = request.editingInputs;
  }
  if (!Util.isUnset(request.editingJobOssFileRoleArn)) {
    query['EditingJobOssFileRoleArn'] = request.editingJobOssFileRoleArn;
  }
  if (!Util.isUnset(request.editingJobOssFileUid)) {
    query['EditingJobOssFileUid'] = request.editingJobOssFileUid;
  }
  if (!Util.isUnset(request.editingJobOutputs)) {
    query['EditingJobOutputs'] = request.editingJobOutputs;
  }
  if (!Util.isUnset(request.editingJobURL)) {
    query['EditingJobURL'] = request.editingJobURL;
  }
  if (!Util.isUnset(request.outputBucket)) {
    query['OutputBucket'] = request.outputBucket;
  }
  if (!Util.isUnset(request.outputLocation)) {
    query['OutputLocation'] = request.outputLocation;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitEditingJobs',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitEditingJobs(request: SubmitEditingJobsRequest): SubmitEditingJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitEditingJobsWithOptions(request, runtime);
}

model SubmitFpDBDeleteJobRequest {
  delType?: string(name='DelType'),
  fpDBId?: string(name='FpDBId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitFpDBDeleteJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitFpDBDeleteJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitFpDBDeleteJobResponseBody(name='body'),
}

async function submitFpDBDeleteJobWithOptions(request: SubmitFpDBDeleteJobRequest, runtime: Util.RuntimeOptions): SubmitFpDBDeleteJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.delType)) {
    query['DelType'] = request.delType;
  }
  if (!Util.isUnset(request.fpDBId)) {
    query['FpDBId'] = request.fpDBId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitFpDBDeleteJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitFpDBDeleteJob(request: SubmitFpDBDeleteJobRequest): SubmitFpDBDeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFpDBDeleteJobWithOptions(request, runtime);
}

model SubmitFpFileDeleteJobRequest {
  fileIds?: string(name='FileIds'),
  fpDBId?: string(name='FpDBId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitFpFileDeleteJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitFpFileDeleteJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitFpFileDeleteJobResponseBody(name='body'),
}

async function submitFpFileDeleteJobWithOptions(request: SubmitFpFileDeleteJobRequest, runtime: Util.RuntimeOptions): SubmitFpFileDeleteJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileIds)) {
    query['FileIds'] = request.fileIds;
  }
  if (!Util.isUnset(request.fpDBId)) {
    query['FpDBId'] = request.fpDBId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitFpFileDeleteJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitFpFileDeleteJob(request: SubmitFpFileDeleteJobRequest): SubmitFpFileDeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFpFileDeleteJobWithOptions(request, runtime);
}

model SubmitFpShotJobRequest {
  fpShotConfig?: string(name='FpShotConfig'),
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitFpShotJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitFpShotJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitFpShotJobResponseBody(name='body'),
}

async function submitFpShotJobWithOptions(request: SubmitFpShotJobRequest, runtime: Util.RuntimeOptions): SubmitFpShotJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fpShotConfig)) {
    query['FpShotConfig'] = request.fpShotConfig;
  }
  if (!Util.isUnset(request.input)) {
    query['Input'] = request.input;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitFpShotJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitFpShotJob(request: SubmitFpShotJobRequest): SubmitFpShotJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFpShotJobWithOptions(request, runtime);
}

model SubmitIProductionJobRequest {
  functionName?: string(name='FunctionName'),
  input?: string(name='Input'),
  jobParams?: string(name='JobParams'),
  modelId?: string(name='ModelId'),
  notifyUrl?: string(name='NotifyUrl'),
  output?: string(name='Output'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scheduleParams?: string(name='ScheduleParams'),
  userData?: string(name='UserData'),
}

model SubmitIProductionJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model SubmitIProductionJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitIProductionJobResponseBody(name='body'),
}

async function submitIProductionJobWithOptions(request: SubmitIProductionJobRequest, runtime: Util.RuntimeOptions): SubmitIProductionJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }
  if (!Util.isUnset(request.input)) {
    query['Input'] = request.input;
  }
  if (!Util.isUnset(request.jobParams)) {
    query['JobParams'] = request.jobParams;
  }
  if (!Util.isUnset(request.modelId)) {
    query['ModelId'] = request.modelId;
  }
  if (!Util.isUnset(request.notifyUrl)) {
    query['NotifyUrl'] = request.notifyUrl;
  }
  if (!Util.isUnset(request.output)) {
    query['Output'] = request.output;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scheduleParams)) {
    query['ScheduleParams'] = request.scheduleParams;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitIProductionJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitIProductionJob(request: SubmitIProductionJobRequest): SubmitIProductionJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitIProductionJobWithOptions(request, runtime);
}

model SubmitJobsRequest {
  input?: string(name='Input'),
  outputBucket?: string(name='OutputBucket'),
  outputLocation?: string(name='OutputLocation'),
  outputs?: string(name='Outputs'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SubmitJobsResponseBody = {
  jobResultList?: {
    jobResult?: [ 
    {
      code?: string(name='Code'),
      job?: {
        code?: string(name='Code'),
        creationTime?: string(name='CreationTime'),
        finishTime?: string(name='FinishTime'),
        input?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='Input'),
        jobId?: string(name='JobId'),
        MNSMessageResult?: {
          errorCode?: string(name='ErrorCode'),
          errorMessage?: string(name='ErrorMessage'),
          messageId?: string(name='MessageId'),
        }(name='MNSMessageResult'),
        message?: string(name='Message'),
        output?: {
          amixList?: {
            amix?: [ 
            {
              amixURL?: string(name='AmixURL'),
              duration?: string(name='Duration'),
              map?: string(name='Map'),
              mixDurMode?: string(name='MixDurMode'),
              start?: string(name='Start'),
            }
          ](name='Amix')
          }(name='AmixList'),
          audio?: {
            bitrate?: string(name='Bitrate'),
            channels?: string(name='Channels'),
            codec?: string(name='Codec'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            samplerate?: string(name='Samplerate'),
            volume?: {
              level?: string(name='Level'),
              method?: string(name='Method'),
            }(name='Volume'),
          }(name='Audio'),
          audioStreamMap?: string(name='AudioStreamMap'),
          clip?: {
            timeSpan?: {
              duration?: string(name='Duration'),
              seek?: string(name='Seek'),
            }(name='TimeSpan'),
          }(name='Clip'),
          container?: {
            format?: string(name='Format'),
          }(name='Container'),
          deWatermark?: string(name='DeWatermark'),
          digiWaterMark?: {
            alpha?: string(name='Alpha'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
            type?: string(name='Type'),
          }(name='DigiWaterMark'),
          encryption?: {
            id?: string(name='Id'),
            key?: string(name='Key'),
            keyType?: string(name='KeyType'),
            keyUri?: string(name='KeyUri'),
            skipCnt?: string(name='SkipCnt'),
            type?: string(name='Type'),
          }(name='Encryption'),
          m3U8NonStandardSupport?: {
            TS?: {
              md5Support?: boolean(name='Md5Support'),
              sizeSupport?: boolean(name='SizeSupport'),
            }(name='TS'),
          }(name='M3U8NonStandardSupport'),
          mergeConfigUrl?: string(name='MergeConfigUrl'),
          mergeList?: {
            merge?: [ 
            {
              duration?: string(name='Duration'),
              mergeURL?: string(name='MergeURL'),
              roleArn?: string(name='RoleArn'),
              start?: string(name='Start'),
            }
          ](name='Merge')
          }(name='MergeList'),
          muxConfig?: {
            gif?: {
              ditherMode?: string(name='DitherMode'),
              finalDelay?: string(name='FinalDelay'),
              isCustomPalette?: string(name='IsCustomPalette'),
              loop?: string(name='Loop'),
            }(name='Gif'),
            segment?: {
              duration?: string(name='Duration'),
            }(name='Segment'),
            webp?: {
              loop?: string(name='Loop'),
            }(name='Webp'),
          }(name='MuxConfig'),
          openingList?: {
            opening?: [ 
            {
              height?: string(name='Height'),
              start?: string(name='Start'),
              width?: string(name='Width'),
              openUrl?: string(name='openUrl'),
            }
          ](name='Opening')
          }(name='OpeningList'),
          outSubtitleList?: {
            outSubtitle?: [ 
            {
              map?: string(name='Map'),
              message?: string(name='Message'),
              outSubtitleFile?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
                roleArn?: string(name='RoleArn'),
              }(name='OutSubtitleFile'),
              success?: boolean(name='Success'),
            }
          ](name='OutSubtitle')
          }(name='OutSubtitleList'),
          outputFile?: {
            bucket?: string(name='Bucket'),
            location?: string(name='Location'),
            object?: string(name='Object'),
            roleArn?: string(name='RoleArn'),
          }(name='OutputFile'),
          priority?: string(name='Priority'),
          properties?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            fileFormat?: string(name='FileFormat'),
            fileSize?: string(name='FileSize'),
            format?: {
              bitrate?: string(name='Bitrate'),
              duration?: string(name='Duration'),
              formatLongName?: string(name='FormatLongName'),
              formatName?: string(name='FormatName'),
              numPrograms?: string(name='NumPrograms'),
              numStreams?: string(name='NumStreams'),
              size?: string(name='Size'),
              startTime?: string(name='StartTime'),
            }(name='Format'),
            fps?: string(name='Fps'),
            height?: string(name='Height'),
            streams?: {
              audioStreamList?: {
                audioStream?: [ 
                {
                  bitrate?: string(name='Bitrate'),
                  channelLayout?: string(name='ChannelLayout'),
                  channels?: string(name='Channels'),
                  codecLongName?: string(name='CodecLongName'),
                  codecName?: string(name='CodecName'),
                  codecTag?: string(name='CodecTag'),
                  codecTagString?: string(name='CodecTagString'),
                  codecTimeBase?: string(name='CodecTimeBase'),
                  duration?: string(name='Duration'),
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                  numFrames?: string(name='NumFrames'),
                  sampleFmt?: string(name='SampleFmt'),
                  samplerate?: string(name='Samplerate'),
                  startTime?: string(name='StartTime'),
                  timebase?: string(name='Timebase'),
                }
              ](name='AudioStream')
              }(name='AudioStreamList'),
              subtitleStreamList?: {
                subtitleStream?: [ 
                {
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                }
              ](name='SubtitleStream')
              }(name='SubtitleStreamList'),
              videoStreamList?: {
                videoStream?: [ 
                {
                  avgFPS?: string(name='AvgFPS'),
                  bitrate?: string(name='Bitrate'),
                  codecLongName?: string(name='CodecLongName'),
                  codecName?: string(name='CodecName'),
                  codecTag?: string(name='CodecTag'),
                  codecTagString?: string(name='CodecTagString'),
                  codecTimeBase?: string(name='CodecTimeBase'),
                  dar?: string(name='Dar'),
                  duration?: string(name='Duration'),
                  fps?: string(name='Fps'),
                  hasBFrames?: string(name='HasBFrames'),
                  height?: string(name='Height'),
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                  level?: string(name='Level'),
                  networkCost?: {
                    avgBitrate?: string(name='AvgBitrate'),
                    costBandwidth?: string(name='CostBandwidth'),
                    preloadTime?: string(name='PreloadTime'),
                  }(name='NetworkCost'),
                  numFrames?: string(name='NumFrames'),
                  pixFmt?: string(name='PixFmt'),
                  profile?: string(name='Profile'),
                  sar?: string(name='Sar'),
                  startTime?: string(name='StartTime'),
                  timebase?: string(name='Timebase'),
                  width?: string(name='Width'),
                }
              ](name='VideoStream')
              }(name='VideoStreamList'),
            }(name='Streams'),
            width?: string(name='Width'),
          }(name='Properties'),
          rotate?: string(name='Rotate'),
          subtitleConfig?: {
            extSubtitleList?: {
              extSubtitle?: [ 
              {
                charEnc?: string(name='CharEnc'),
                fontName?: string(name='FontName'),
                input?: {
                  bucket?: string(name='Bucket'),
                  location?: string(name='Location'),
                  object?: string(name='Object'),
                }(name='Input'),
              }
            ](name='ExtSubtitle')
            }(name='ExtSubtitleList'),
            subtitleList?: {
              subtitle?: [ 
              {
                map?: string(name='Map'),
              }
            ](name='Subtitle')
            }(name='SubtitleList'),
          }(name='SubtitleConfig'),
          superReso?: {
            isHalfSample?: string(name='IsHalfSample'),
          }(name='SuperReso'),
          tailSlateList?: {
            tailSlate?: [ 
            {
              bgColor?: string(name='BgColor'),
              blendDuration?: string(name='BlendDuration'),
              height?: string(name='Height'),
              isMergeAudio?: boolean(name='IsMergeAudio'),
              start?: string(name='Start'),
              tailUrl?: string(name='TailUrl'),
              width?: string(name='Width'),
            }
          ](name='TailSlate')
          }(name='TailSlateList'),
          templateId?: string(name='TemplateId'),
          transConfig?: {
            adjDarMethod?: string(name='AdjDarMethod'),
            isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
            isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
            isCheckReso?: string(name='IsCheckReso'),
            isCheckResoFail?: string(name='IsCheckResoFail'),
            isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
            isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
            transMode?: string(name='TransMode'),
          }(name='TransConfig'),
          userData?: string(name='UserData'),
          video?: {
            bitrate?: string(name='Bitrate'),
            bitrateBnd?: {
              max?: string(name='Max'),
              min?: string(name='Min'),
            }(name='BitrateBnd'),
            bufsize?: string(name='Bufsize'),
            codec?: string(name='Codec'),
            crf?: string(name='Crf'),
            crop?: string(name='Crop'),
            degrain?: string(name='Degrain'),
            fps?: string(name='Fps'),
            gop?: string(name='Gop'),
            height?: string(name='Height'),
            maxFps?: string(name='MaxFps'),
            maxrate?: string(name='Maxrate'),
            pad?: string(name='Pad'),
            pixFmt?: string(name='PixFmt'),
            preset?: string(name='Preset'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            resoPriority?: string(name='ResoPriority'),
            scanMode?: string(name='ScanMode'),
            width?: string(name='Width'),
          }(name='Video'),
          videoStreamMap?: string(name='VideoStreamMap'),
          waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
          waterMarkList?: {
            waterMark?: [ 
            {
              dx?: string(name='Dx'),
              dy?: string(name='Dy'),
              height?: string(name='Height'),
              inputFile?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='InputFile'),
              referPos?: string(name='ReferPos'),
              type?: string(name='Type'),
              waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
              width?: string(name='Width'),
            }
          ](name='WaterMark')
          }(name='WaterMarkList'),
        }(name='Output'),
        percent?: long(name='Percent'),
        pipelineId?: string(name='PipelineId'),
        state?: string(name='State'),
      }(name='Job'),
      message?: string(name='Message'),
      success?: boolean(name='Success'),
    }
  ](name='JobResult')
  }(name='JobResultList'),
  requestId?: string(name='RequestId'),
}

model SubmitJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitJobsResponseBody(name='body'),
}

async function submitJobsWithOptions(request: SubmitJobsRequest, runtime: Util.RuntimeOptions): SubmitJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.input)) {
    query['Input'] = request.input;
  }
  if (!Util.isUnset(request.outputBucket)) {
    query['OutputBucket'] = request.outputBucket;
  }
  if (!Util.isUnset(request.outputLocation)) {
    query['OutputLocation'] = request.outputLocation;
  }
  if (!Util.isUnset(request.outputs)) {
    query['Outputs'] = request.outputs;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitJobs',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitJobs(request: SubmitJobsRequest): SubmitJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitJobsWithOptions(request, runtime);
}

model SubmitMediaCensorJobRequest {
  barrages?: string(name='Barrages'),
  coverImages?: string(name='CoverImages'),
  description?: string(name='Description'),
  externalUrl?: string(name='ExternalUrl'),
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  title?: string(name='Title'),
  userData?: string(name='UserData'),
  videoCensorConfig?: string(name='VideoCensorConfig'),
}

model SubmitMediaCensorJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitMediaCensorJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitMediaCensorJobResponseBody(name='body'),
}

async function submitMediaCensorJobWithOptions(request: SubmitMediaCensorJobRequest, runtime: Util.RuntimeOptions): SubmitMediaCensorJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.barrages)) {
    query['Barrages'] = request.barrages;
  }
  if (!Util.isUnset(request.coverImages)) {
    query['CoverImages'] = request.coverImages;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.externalUrl)) {
    query['ExternalUrl'] = request.externalUrl;
  }
  if (!Util.isUnset(request.input)) {
    query['Input'] = request.input;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  if (!Util.isUnset(request.videoCensorConfig)) {
    query['VideoCensorConfig'] = request.videoCensorConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitMediaCensorJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitMediaCensorJob(request: SubmitMediaCensorJobRequest): SubmitMediaCensorJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMediaCensorJobWithOptions(request, runtime);
}

model SubmitMediaInfoJobRequest {
  async?: boolean(name='Async'),
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitMediaInfoJobResponseBody = {
  mediaInfoJob?: {
    async?: boolean(name='Async'),
    code?: string(name='Code'),
    creationTime?: string(name='CreationTime'),
    input?: {
      bucket?: string(name='Bucket'),
      location?: string(name='Location'),
      object?: string(name='Object'),
    }(name='Input'),
    jobId?: string(name='JobId'),
    MNSMessageResult?: {
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      messageId?: string(name='MessageId'),
    }(name='MNSMessageResult'),
    message?: string(name='Message'),
    pipelineId?: string(name='PipelineId'),
    properties?: {
      bitrate?: string(name='Bitrate'),
      duration?: string(name='Duration'),
      fileFormat?: string(name='FileFormat'),
      fileSize?: string(name='FileSize'),
      format?: {
        bitrate?: string(name='Bitrate'),
        duration?: string(name='Duration'),
        formatLongName?: string(name='FormatLongName'),
        formatName?: string(name='FormatName'),
        numPrograms?: string(name='NumPrograms'),
        numStreams?: string(name='NumStreams'),
        size?: string(name='Size'),
        startTime?: string(name='StartTime'),
      }(name='Format'),
      fps?: string(name='Fps'),
      height?: string(name='Height'),
      streams?: {
        audioStreamList?: {
          audioStream?: [ 
          {
            bitrate?: string(name='Bitrate'),
            channelLayout?: string(name='ChannelLayout'),
            channels?: string(name='Channels'),
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            duration?: string(name='Duration'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            numFrames?: string(name='NumFrames'),
            sampleFmt?: string(name='SampleFmt'),
            samplerate?: string(name='Samplerate'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
          }
        ](name='AudioStream')
        }(name='AudioStreamList'),
        subtitleStreamList?: {
          subtitleStream?: [ 
          {
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            duration?: string(name='Duration'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
          }
        ](name='SubtitleStream')
        }(name='SubtitleStreamList'),
        videoStreamList?: {
          videoStream?: [ 
          {
            avgFPS?: string(name='AvgFPS'),
            bitrate?: string(name='Bitrate'),
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            colorPrimaries?: string(name='ColorPrimaries'),
            colorRange?: string(name='ColorRange'),
            colorTransfer?: string(name='ColorTransfer'),
            dar?: string(name='Dar'),
            duration?: string(name='Duration'),
            fps?: string(name='Fps'),
            hasBFrames?: string(name='HasBFrames'),
            height?: string(name='Height'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            level?: string(name='Level'),
            networkCost?: {
              avgBitrate?: string(name='AvgBitrate'),
              costBandwidth?: string(name='CostBandwidth'),
              preloadTime?: string(name='PreloadTime'),
            }(name='NetworkCost'),
            numFrames?: string(name='NumFrames'),
            pixFmt?: string(name='PixFmt'),
            profile?: string(name='Profile'),
            rotate?: string(name='Rotate'),
            sar?: string(name='Sar'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
            width?: string(name='Width'),
          }
        ](name='VideoStream')
        }(name='VideoStreamList'),
      }(name='Streams'),
      width?: string(name='Width'),
    }(name='Properties'),
    state?: string(name='State'),
    userData?: string(name='UserData'),
  }(name='MediaInfoJob'),
  requestId?: string(name='RequestId'),
}

model SubmitMediaInfoJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitMediaInfoJobResponseBody(name='body'),
}

async function submitMediaInfoJobWithOptions(request: SubmitMediaInfoJobRequest, runtime: Util.RuntimeOptions): SubmitMediaInfoJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.async)) {
    query['Async'] = request.async;
  }
  if (!Util.isUnset(request.input)) {
    query['Input'] = request.input;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitMediaInfoJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitMediaInfoJob(request: SubmitMediaInfoJobRequest): SubmitMediaInfoJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMediaInfoJobWithOptions(request, runtime);
}

model SubmitSmarttagJobRequest {
  content?: string(name='Content'),
  contentAddr?: string(name='ContentAddr'),
  contentType?: string(name='ContentType'),
  input?: string(name='Input'),
  notifyUrl?: string(name='NotifyUrl'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  params?: string(name='Params'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
  title?: string(name='Title'),
  userData?: string(name='UserData'),
}

model SubmitSmarttagJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitSmarttagJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitSmarttagJobResponseBody(name='body'),
}

async function submitSmarttagJobWithOptions(request: SubmitSmarttagJobRequest, runtime: Util.RuntimeOptions): SubmitSmarttagJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.contentAddr)) {
    query['ContentAddr'] = request.contentAddr;
  }
  if (!Util.isUnset(request.contentType)) {
    query['ContentType'] = request.contentType;
  }
  if (!Util.isUnset(request.input)) {
    query['Input'] = request.input;
  }
  if (!Util.isUnset(request.notifyUrl)) {
    query['NotifyUrl'] = request.notifyUrl;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.params)) {
    query['Params'] = request.params;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitSmarttagJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitSmarttagJob(request: SubmitSmarttagJobRequest): SubmitSmarttagJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSmarttagJobWithOptions(request, runtime);
}

model SubmitSnapshotJobRequest {
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  snapshotConfig?: string(name='SnapshotConfig'),
  userData?: string(name='UserData'),
}

model SubmitSnapshotJobResponseBody = {
  requestId?: string(name='RequestId'),
  snapshotJob?: {
    code?: string(name='Code'),
    count?: string(name='Count'),
    creationTime?: string(name='CreationTime'),
    id?: string(name='Id'),
    input?: {
      bucket?: string(name='Bucket'),
      location?: string(name='Location'),
      object?: string(name='Object'),
      roleArn?: string(name='RoleArn'),
    }(name='Input'),
    MNSMessageResult?: {
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      messageId?: string(name='MessageId'),
    }(name='MNSMessageResult'),
    message?: string(name='Message'),
    pipelineId?: string(name='PipelineId'),
    snapshotConfig?: {
      frameType?: string(name='FrameType'),
      height?: string(name='Height'),
      interval?: string(name='Interval'),
      num?: string(name='Num'),
      outputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        roleArn?: string(name='RoleArn'),
      }(name='OutputFile'),
      tileOut?: {
        cellHeight?: string(name='CellHeight'),
        cellSelStep?: string(name='CellSelStep'),
        cellWidth?: string(name='CellWidth'),
        color?: string(name='Color'),
        columns?: string(name='Columns'),
        isKeepCellPic?: string(name='IsKeepCellPic'),
        lines?: string(name='Lines'),
        margin?: string(name='Margin'),
        padding?: string(name='Padding'),
      }(name='TileOut'),
      tileOutputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        roleArn?: string(name='RoleArn'),
      }(name='TileOutputFile'),
      time?: string(name='Time'),
      width?: string(name='Width'),
    }(name='SnapshotConfig'),
    state?: string(name='State'),
    tileCount?: string(name='TileCount'),
    userData?: string(name='UserData'),
  }(name='SnapshotJob'),
}

model SubmitSnapshotJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitSnapshotJobResponseBody(name='body'),
}

async function submitSnapshotJobWithOptions(request: SubmitSnapshotJobRequest, runtime: Util.RuntimeOptions): SubmitSnapshotJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.input)) {
    query['Input'] = request.input;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.snapshotConfig)) {
    query['SnapshotConfig'] = request.snapshotConfig;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitSnapshotJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitSnapshotJob(request: SubmitSnapshotJobRequest): SubmitSnapshotJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSnapshotJobWithOptions(request, runtime);
}

model SubmitVideoQualityJobRequest {
  input?: string(name='Input'),
  jobParams?: string(name='JobParams'),
  modelId?: string(name='ModelId'),
  notifyUrl?: string(name='NotifyUrl'),
  output?: string(name='Output'),
  pipelineId?: string(name='PipelineId'),
  scheduleParams?: string(name='ScheduleParams'),
  sourceType?: string(name='SourceType'),
  userData?: string(name='UserData'),
  userId?: long(name='UserId'),
}

model SubmitVideoQualityJobResponseBody = {
  code?: string(name='Code'),
  jobId?: string(name='JobId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SubmitVideoQualityJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitVideoQualityJobResponseBody(name='body'),
}

async function submitVideoQualityJobWithOptions(request: SubmitVideoQualityJobRequest, runtime: Util.RuntimeOptions): SubmitVideoQualityJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.input)) {
    query['Input'] = request.input;
  }
  if (!Util.isUnset(request.jobParams)) {
    query['JobParams'] = request.jobParams;
  }
  if (!Util.isUnset(request.modelId)) {
    query['ModelId'] = request.modelId;
  }
  if (!Util.isUnset(request.notifyUrl)) {
    query['NotifyUrl'] = request.notifyUrl;
  }
  if (!Util.isUnset(request.output)) {
    query['Output'] = request.output;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.scheduleParams)) {
    query['ScheduleParams'] = request.scheduleParams;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitVideoQualityJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitVideoQualityJob(request: SubmitVideoQualityJobRequest): SubmitVideoQualityJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitVideoQualityJobWithOptions(request, runtime);
}

model TagCustomPersonRequest {
  categoryDescription?: string(name='CategoryDescription'),
  categoryId?: string(name='CategoryId'),
  categoryName?: string(name='CategoryName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  personDescription?: string(name='PersonDescription'),
  personId?: string(name='PersonId'),
  personName?: string(name='PersonName'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model TagCustomPersonResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagCustomPersonResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagCustomPersonResponseBody(name='body'),
}

async function tagCustomPersonWithOptions(request: TagCustomPersonRequest, runtime: Util.RuntimeOptions): TagCustomPersonResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.categoryDescription)) {
    query['CategoryDescription'] = request.categoryDescription;
  }
  if (!Util.isUnset(request.categoryId)) {
    query['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.categoryName)) {
    query['CategoryName'] = request.categoryName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.personDescription)) {
    query['PersonDescription'] = request.personDescription;
  }
  if (!Util.isUnset(request.personId)) {
    query['PersonId'] = request.personId;
  }
  if (!Util.isUnset(request.personName)) {
    query['PersonName'] = request.personName;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagCustomPerson',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagCustomPerson(request: TagCustomPersonRequest): TagCustomPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagCustomPersonWithOptions(request, runtime);
}

model UnbindInputBucketRequest {
  bucket?: string(name='Bucket'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleArn?: string(name='RoleArn'),
}

model UnbindInputBucketResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnbindInputBucketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindInputBucketResponseBody(name='body'),
}

async function unbindInputBucketWithOptions(request: UnbindInputBucketRequest, runtime: Util.RuntimeOptions): UnbindInputBucketResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bucket)) {
    query['Bucket'] = request.bucket;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.roleArn)) {
    query['RoleArn'] = request.roleArn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindInputBucket',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindInputBucket(request: UnbindInputBucketRequest): UnbindInputBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindInputBucketWithOptions(request, runtime);
}

model UnbindOutputBucketRequest {
  bucket?: string(name='Bucket'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UnbindOutputBucketResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnbindOutputBucketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindOutputBucketResponseBody(name='body'),
}

async function unbindOutputBucketWithOptions(request: UnbindOutputBucketRequest, runtime: Util.RuntimeOptions): UnbindOutputBucketResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bucket)) {
    query['Bucket'] = request.bucket;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindOutputBucket',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindOutputBucket(request: UnbindOutputBucketRequest): UnbindOutputBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindOutputBucketWithOptions(request, runtime);
}

model UnregisterCustomFaceRequest {
  categoryId?: string(name='CategoryId'),
  faceId?: string(name='FaceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  personId?: string(name='PersonId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UnregisterCustomFaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnregisterCustomFaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnregisterCustomFaceResponseBody(name='body'),
}

async function unregisterCustomFaceWithOptions(request: UnregisterCustomFaceRequest, runtime: Util.RuntimeOptions): UnregisterCustomFaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.categoryId)) {
    query['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.faceId)) {
    query['FaceId'] = request.faceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.personId)) {
    query['PersonId'] = request.personId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnregisterCustomFace',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unregisterCustomFace(request: UnregisterCustomFaceRequest): UnregisterCustomFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unregisterCustomFaceWithOptions(request, runtime);
}

model UpdateMediaRequest {
  cateId?: long(name='CateId'),
  coverURL?: string(name='CoverURL'),
  description?: string(name='Description'),
  mediaId?: string(name='MediaId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tags?: string(name='Tags'),
  title?: string(name='Title'),
}

model UpdateMediaResponseBody = {
  media?: {
    bitrate?: string(name='Bitrate'),
    cateId?: long(name='CateId'),
    censorState?: string(name='CensorState'),
    coverURL?: string(name='CoverURL'),
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    duration?: string(name='Duration'),
    file?: {
      state?: string(name='State'),
      URL?: string(name='URL'),
    }(name='File'),
    format?: string(name='Format'),
    fps?: string(name='Fps'),
    height?: string(name='Height'),
    mediaId?: string(name='MediaId'),
    publishState?: string(name='PublishState'),
    runIdList?: {
      runId?: [ string ](name='RunId')
    }(name='RunIdList'),
    size?: string(name='Size'),
    tags?: {
      tag?: [ string ](name='Tag')
    }(name='Tags'),
    title?: string(name='Title'),
    width?: string(name='Width'),
  }(name='Media'),
  requestId?: string(name='RequestId'),
}

model UpdateMediaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMediaResponseBody(name='body'),
}

async function updateMediaWithOptions(request: UpdateMediaRequest, runtime: Util.RuntimeOptions): UpdateMediaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.coverURL)) {
    query['CoverURL'] = request.coverURL;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMedia',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMedia(request: UpdateMediaRequest): UpdateMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaWithOptions(request, runtime);
}

model UpdateMediaCategoryRequest {
  cateId?: long(name='CateId'),
  mediaId?: string(name='MediaId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdateMediaCategoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMediaCategoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMediaCategoryResponseBody(name='body'),
}

async function updateMediaCategoryWithOptions(request: UpdateMediaCategoryRequest, runtime: Util.RuntimeOptions): UpdateMediaCategoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMediaCategory',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMediaCategory(request: UpdateMediaCategoryRequest): UpdateMediaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaCategoryWithOptions(request, runtime);
}

model UpdateMediaCoverRequest {
  coverURL?: string(name='CoverURL'),
  mediaId?: string(name='MediaId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdateMediaCoverResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMediaCoverResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMediaCoverResponseBody(name='body'),
}

async function updateMediaCoverWithOptions(request: UpdateMediaCoverRequest, runtime: Util.RuntimeOptions): UpdateMediaCoverResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.coverURL)) {
    query['CoverURL'] = request.coverURL;
  }
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMediaCover',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMediaCover(request: UpdateMediaCoverRequest): UpdateMediaCoverResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaCoverWithOptions(request, runtime);
}

model UpdateMediaPublishStateRequest {
  mediaId?: string(name='MediaId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  publish?: boolean(name='Publish'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdateMediaPublishStateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMediaPublishStateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMediaPublishStateResponseBody(name='body'),
}

async function updateMediaPublishStateWithOptions(request: UpdateMediaPublishStateRequest, runtime: Util.RuntimeOptions): UpdateMediaPublishStateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaId)) {
    query['MediaId'] = request.mediaId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.publish)) {
    query['Publish'] = request.publish;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMediaPublishState',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMediaPublishState(request: UpdateMediaPublishStateRequest): UpdateMediaPublishStateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaPublishStateWithOptions(request, runtime);
}

model UpdateMediaWorkflowRequest {
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  topology?: string(name='Topology'),
}

model UpdateMediaWorkflowResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
    triggerMode?: string(name='TriggerMode'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model UpdateMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMediaWorkflowResponseBody(name='body'),
}

async function updateMediaWorkflowWithOptions(request: UpdateMediaWorkflowRequest, runtime: Util.RuntimeOptions): UpdateMediaWorkflowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaWorkflowId)) {
    query['MediaWorkflowId'] = request.mediaWorkflowId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.topology)) {
    query['Topology'] = request.topology;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMediaWorkflow',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMediaWorkflow(request: UpdateMediaWorkflowRequest): UpdateMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaWorkflowWithOptions(request, runtime);
}

model UpdateMediaWorkflowTriggerModeRequest {
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  triggerMode?: string(name='TriggerMode'),
}

model UpdateMediaWorkflowTriggerModeResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
    triggerMode?: string(name='TriggerMode'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model UpdateMediaWorkflowTriggerModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMediaWorkflowTriggerModeResponseBody(name='body'),
}

async function updateMediaWorkflowTriggerModeWithOptions(request: UpdateMediaWorkflowTriggerModeRequest, runtime: Util.RuntimeOptions): UpdateMediaWorkflowTriggerModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaWorkflowId)) {
    query['MediaWorkflowId'] = request.mediaWorkflowId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.triggerMode)) {
    query['TriggerMode'] = request.triggerMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMediaWorkflowTriggerMode',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMediaWorkflowTriggerMode(request: UpdateMediaWorkflowTriggerModeRequest): UpdateMediaWorkflowTriggerModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaWorkflowTriggerModeWithOptions(request, runtime);
}

model UpdatePipelineRequest {
  name?: string(name='Name'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  role?: string(name='Role'),
  state?: string(name='State'),
}

model UpdatePipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      mqTag?: string(name='MqTag'),
      mqTopic?: string(name='MqTopic'),
      queueName?: string(name='QueueName'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    quotaAllocate?: long(name='QuotaAllocate'),
    role?: string(name='Role'),
    speed?: string(name='Speed'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model UpdatePipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePipelineResponseBody(name='body'),
}

async function updatePipelineWithOptions(request: UpdatePipelineRequest, runtime: Util.RuntimeOptions): UpdatePipelineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.notifyConfig)) {
    query['NotifyConfig'] = request.notifyConfig;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.role)) {
    query['Role'] = request.role;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePipeline(request: UpdatePipelineRequest): UpdatePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePipelineWithOptions(request, runtime);
}

model UpdateSmarttagTemplateRequest {
  analyseTypes?: string(name='AnalyseTypes'),
  faceCategoryIds?: string(name='FaceCategoryIds'),
  faceCustomParamsConfig?: string(name='FaceCustomParamsConfig'),
  industry?: string(name='Industry'),
  isDefault?: boolean(name='IsDefault'),
  keywordConfig?: string(name='KeywordConfig'),
  knowledgeConfig?: string(name='KnowledgeConfig'),
  labelType?: string(name='LabelType'),
  labelVersion?: string(name='LabelVersion'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scene?: string(name='Scene'),
  templateId?: string(name='TemplateId'),
  templateName?: string(name='TemplateName'),
}

model UpdateSmarttagTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateSmarttagTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSmarttagTemplateResponseBody(name='body'),
}

async function updateSmarttagTemplateWithOptions(request: UpdateSmarttagTemplateRequest, runtime: Util.RuntimeOptions): UpdateSmarttagTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.analyseTypes)) {
    query['AnalyseTypes'] = request.analyseTypes;
  }
  if (!Util.isUnset(request.faceCategoryIds)) {
    query['FaceCategoryIds'] = request.faceCategoryIds;
  }
  if (!Util.isUnset(request.faceCustomParamsConfig)) {
    query['FaceCustomParamsConfig'] = request.faceCustomParamsConfig;
  }
  if (!Util.isUnset(request.industry)) {
    query['Industry'] = request.industry;
  }
  if (!Util.isUnset(request.isDefault)) {
    query['IsDefault'] = request.isDefault;
  }
  if (!Util.isUnset(request.keywordConfig)) {
    query['KeywordConfig'] = request.keywordConfig;
  }
  if (!Util.isUnset(request.knowledgeConfig)) {
    query['KnowledgeConfig'] = request.knowledgeConfig;
  }
  if (!Util.isUnset(request.labelType)) {
    query['LabelType'] = request.labelType;
  }
  if (!Util.isUnset(request.labelVersion)) {
    query['LabelVersion'] = request.labelVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scene)) {
    query['Scene'] = request.scene;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSmarttagTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSmarttagTemplate(request: UpdateSmarttagTemplateRequest): UpdateSmarttagTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSmarttagTemplateWithOptions(request, runtime);
}

model UpdateTemplateRequest {
  audio?: string(name='Audio'),
  container?: string(name='Container'),
  muxConfig?: string(name='MuxConfig'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
  transConfig?: string(name='TransConfig'),
  video?: string(name='Video'),
}

model UpdateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    audio?: {
      bitrate?: string(name='Bitrate'),
      channels?: string(name='Channels'),
      codec?: string(name='Codec'),
      profile?: string(name='Profile'),
      qscale?: string(name='Qscale'),
      remove?: string(name='Remove'),
      samplerate?: string(name='Samplerate'),
    }(name='Audio'),
    container?: {
      format?: string(name='Format'),
    }(name='Container'),
    id?: string(name='Id'),
    muxConfig?: {
      gif?: {
        ditherMode?: string(name='DitherMode'),
        finalDelay?: string(name='FinalDelay'),
        isCustomPalette?: string(name='IsCustomPalette'),
        loop?: string(name='Loop'),
      }(name='Gif'),
      segment?: {
        duration?: string(name='Duration'),
      }(name='Segment'),
      webp?: {
        loop?: string(name='Loop'),
      }(name='Webp'),
    }(name='MuxConfig'),
    name?: string(name='Name'),
    state?: string(name='State'),
    transConfig?: {
      adjDarMethod?: string(name='AdjDarMethod'),
      isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
      isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
      isCheckReso?: string(name='IsCheckReso'),
      isCheckResoFail?: string(name='IsCheckResoFail'),
      isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
      isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
      transMode?: string(name='TransMode'),
    }(name='TransConfig'),
    video?: {
      bitrate?: string(name='Bitrate'),
      bitrateBnd?: {
        max?: string(name='Max'),
        min?: string(name='Min'),
      }(name='BitrateBnd'),
      bufsize?: string(name='Bufsize'),
      codec?: string(name='Codec'),
      crf?: string(name='Crf'),
      crop?: string(name='Crop'),
      degrain?: string(name='Degrain'),
      fps?: string(name='Fps'),
      gop?: string(name='Gop'),
      height?: string(name='Height'),
      longShortMode?: string(name='LongShortMode'),
      maxFps?: string(name='MaxFps'),
      maxrate?: string(name='Maxrate'),
      pad?: string(name='Pad'),
      pixFmt?: string(name='PixFmt'),
      preset?: string(name='Preset'),
      profile?: string(name='Profile'),
      qscale?: string(name='Qscale'),
      remove?: string(name='Remove'),
      resoPriority?: string(name='ResoPriority'),
      scanMode?: string(name='ScanMode'),
      width?: string(name='Width'),
    }(name='Video'),
  }(name='Template'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTemplateResponseBody(name='body'),
}

async function updateTemplateWithOptions(request: UpdateTemplateRequest, runtime: Util.RuntimeOptions): UpdateTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.audio)) {
    query['Audio'] = request.audio;
  }
  if (!Util.isUnset(request.container)) {
    query['Container'] = request.container;
  }
  if (!Util.isUnset(request.muxConfig)) {
    query['MuxConfig'] = request.muxConfig;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.transConfig)) {
    query['TransConfig'] = request.transConfig;
  }
  if (!Util.isUnset(request.video)) {
    query['Video'] = request.video;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTemplate(request: UpdateTemplateRequest): UpdateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTemplateWithOptions(request, runtime);
}

model UpdateWaterMarkTemplateRequest {
  config?: string(name='Config'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
}

model UpdateWaterMarkTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  waterMarkTemplate?: {
    dx?: string(name='Dx'),
    dy?: string(name='Dy'),
    height?: string(name='Height'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    ratioRefer?: {
      dx?: string(name='Dx'),
      dy?: string(name='Dy'),
      height?: string(name='Height'),
      width?: string(name='Width'),
    }(name='RatioRefer'),
    referPos?: string(name='ReferPos'),
    state?: string(name='State'),
    timeline?: {
      duration?: string(name='Duration'),
      start?: string(name='Start'),
    }(name='Timeline'),
    type?: string(name='Type'),
    width?: string(name='Width'),
  }(name='WaterMarkTemplate'),
}

model UpdateWaterMarkTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateWaterMarkTemplateResponseBody(name='body'),
}

async function updateWaterMarkTemplateWithOptions(request: UpdateWaterMarkTemplateRequest, runtime: Util.RuntimeOptions): UpdateWaterMarkTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.waterMarkTemplateId)) {
    query['WaterMarkTemplateId'] = request.waterMarkTemplateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWaterMarkTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateWaterMarkTemplate(request: UpdateWaterMarkTemplateRequest): UpdateWaterMarkTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWaterMarkTemplateWithOptions(request, runtime);
}

