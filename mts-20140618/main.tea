/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  @endpointMap = {
    ap-northeast-2-pop = 'mts.ap-northeast-1.aliyuncs.com',
    ap-southeast-2 = 'mts.ap-northeast-1.aliyuncs.com',
    ap-southeast-3 = 'mts.ap-northeast-1.aliyuncs.com',
    cn-beijing-finance-1 = 'mts.aliyuncs.com',
    cn-beijing-finance-pop = 'mts.aliyuncs.com',
    cn-beijing-gov-1 = 'mts.aliyuncs.com',
    cn-beijing-nu16-b01 = 'mts.aliyuncs.com',
    cn-chengdu = 'mts.aliyuncs.com',
    cn-edge-1 = 'mts.aliyuncs.com',
    cn-fujian = 'mts.aliyuncs.com',
    cn-haidian-cm12-c01 = 'mts.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'mts.aliyuncs.com',
    cn-hangzhou-finance = 'mts.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'mts.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'mts.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'mts.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'mts.aliyuncs.com',
    cn-hangzhou-test-306 = 'mts.aliyuncs.com',
    cn-hongkong-finance-pop = 'mts.aliyuncs.com',
    cn-north-2-gov-1 = 'mts.aliyuncs.com',
    cn-qingdao = 'mts.aliyuncs.com',
    cn-qingdao-nebula = 'mts.aliyuncs.com',
    cn-shanghai-et15-b01 = 'mts.aliyuncs.com',
    cn-shanghai-et2-b01 = 'mts.aliyuncs.com',
    cn-shanghai-finance-1 = 'mts.aliyuncs.com',
    cn-shanghai-inner = 'mts.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'mts.aliyuncs.com',
    cn-shenzhen-finance-1 = 'mts.aliyuncs.com',
    cn-shenzhen-inner = 'mts.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'mts.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'mts.aliyuncs.com',
    cn-wuhan = 'mts.aliyuncs.com',
    cn-yushanfang = 'mts.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'mts.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'mts.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'mts.aliyuncs.com',
    eu-west-1-oxs = 'mts.ap-northeast-1.aliyuncs.com',
    me-east-1 = 'mts.ap-northeast-1.aliyuncs.com',
    rus-west-1-pop = 'mts.ap-northeast-1.aliyuncs.com',
    us-east-1 = 'mts.ap-northeast-1.aliyuncs.com',
  };
  checkConfig(config);
  @endpoint = getEndpoint('mts', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model ActivateMediaWorkflowRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ActivateMediaWorkflowResponseBody = {
  requestId?: string(name='RequestId'),
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    state?: string(name='State'),
    name?: string(name='Name'),
    topology?: string(name='Topology'),
  }(name='MediaWorkflow'),
}

model ActivateMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: ActivateMediaWorkflowResponseBody(name='body'),
}

async function activateMediaWorkflowWithOptions(request: ActivateMediaWorkflowRequest, runtime: Util.RuntimeOptions): ActivateMediaWorkflowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ActivateMediaWorkflow', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function activateMediaWorkflow(request: ActivateMediaWorkflowRequest): ActivateMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return activateMediaWorkflowWithOptions(request, runtime);
}

model AddAsrPipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  name?: string(name='Name'),
  priority?: int32(name='Priority'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AddAsrPipelineResponseBody = {
  requestId?: string(name='RequestId'),
  pipeline?: {
    state?: string(name='State'),
    notifyConfig?: {
      topic?: string(name='Topic'),
      queue?: string(name='Queue'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    name?: string(name='Name'),
    id?: string(name='Id'),
  }(name='Pipeline'),
}

model AddAsrPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: AddAsrPipelineResponseBody(name='body'),
}

async function addAsrPipelineWithOptions(request: AddAsrPipelineRequest, runtime: Util.RuntimeOptions): AddAsrPipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddAsrPipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addAsrPipeline(request: AddAsrPipelineRequest): AddAsrPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAsrPipelineWithOptions(request, runtime);
}

model AddCategoryRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  cateName?: string(name='CateName'),
  parentId?: long(name='ParentId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AddCategoryResponseBody = {
  category?: {
    cateName?: string(name='CateName'),
    parentId?: string(name='ParentId'),
    cateId?: string(name='CateId'),
    level?: string(name='Level'),
  }(name='Category'),
  requestId?: string(name='RequestId'),
}

model AddCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: AddCategoryResponseBody(name='body'),
}

async function addCategoryWithOptions(request: AddCategoryRequest, runtime: Util.RuntimeOptions): AddCategoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddCategory', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addCategory(request: AddCategoryRequest): AddCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCategoryWithOptions(request, runtime);
}

model AddCensorPipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  name?: string(name='Name'),
  priority?: int32(name='Priority'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AddCensorPipelineResponseBody = {
  requestId?: string(name='RequestId'),
  pipeline?: {
    state?: string(name='State'),
    notifyConfig?: {
      topic?: string(name='Topic'),
      queue?: string(name='Queue'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    name?: string(name='Name'),
    id?: string(name='Id'),
  }(name='Pipeline'),
}

model AddCensorPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: AddCensorPipelineResponseBody(name='body'),
}

async function addCensorPipelineWithOptions(request: AddCensorPipelineRequest, runtime: Util.RuntimeOptions): AddCensorPipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddCensorPipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addCensorPipeline(request: AddCensorPipelineRequest): AddCensorPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCensorPipelineWithOptions(request, runtime);
}

model AddCoverPipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  name?: string(name='Name'),
  priority?: string(name='Priority'),
  notifyConfig?: string(name='NotifyConfig'),
  role?: string(name='Role'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AddCoverPipelineResponseBody = {
  requestId?: string(name='RequestId'),
  pipeline?: {
    state?: string(name='State'),
    notifyConfig?: {
      topic?: string(name='Topic'),
      queue?: string(name='Queue'),
    }(name='NotifyConfig'),
    priority?: string(name='Priority'),
    role?: string(name='Role'),
    name?: string(name='Name'),
    id?: string(name='Id'),
  }(name='Pipeline'),
}

model AddCoverPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: AddCoverPipelineResponseBody(name='body'),
}

async function addCoverPipelineWithOptions(request: AddCoverPipelineRequest, runtime: Util.RuntimeOptions): AddCoverPipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddCoverPipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addCoverPipeline(request: AddCoverPipelineRequest): AddCoverPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCoverPipelineWithOptions(request, runtime);
}

model AddMCTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  name?: string(name='Name'),
  porn?: string(name='Porn'),
  terrorism?: string(name='Terrorism'),
  politics?: string(name='Politics'),
  ad?: string(name='Ad'),
  qrcode?: string(name='Qrcode'),
  live?: string(name='Live'),
  logo?: string(name='Logo'),
  abuse?: string(name='Abuse'),
  contraband?: string(name='Contraband'),
  spam?: string(name='spam'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AddMCTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    logo?: string(name='Logo'),
    abuse?: string(name='Abuse'),
    terrorism?: string(name='Terrorism'),
    politics?: string(name='Politics'),
    qrcode?: string(name='Qrcode'),
    spam?: string(name='Spam'),
    live?: string(name='Live'),
    contraband?: string(name='Contraband'),
    ad?: string(name='Ad'),
    porn?: string(name='Porn'),
    name?: string(name='Name'),
    templateId?: string(name='TemplateId'),
  }(name='Template'),
}

model AddMCTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddMCTemplateResponseBody(name='body'),
}

async function addMCTemplateWithOptions(request: AddMCTemplateRequest, runtime: Util.RuntimeOptions): AddMCTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddMCTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addMCTemplate(request: AddMCTemplateRequest): AddMCTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMCTemplateWithOptions(request, runtime);
}

model AddMediaRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  fileURL?: string(name='FileURL'),
  title?: string(name='Title'),
  description?: string(name='Description'),
  coverURL?: string(name='CoverURL'),
  tags?: string(name='Tags'),
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  mediaWorkflowUserData?: string(name='MediaWorkflowUserData'),
  inputUnbind?: boolean(name='InputUnbind'),
  cateId?: long(name='CateId'),
  overrideParams?: string(name='OverrideParams'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AddMediaResponseBody = {
  requestId?: string(name='RequestId'),
  media?: {
    creationTime?: string(name='CreationTime'),
    cateId?: long(name='CateId'),
    height?: string(name='Height'),
    censorState?: string(name='CensorState'),
    tags?: {
      tag?: [ string ](name='Tag')
    }(name='Tags'),
    bitrate?: string(name='Bitrate'),
    mediaId?: string(name='MediaId'),
    file?: {
      state?: string(name='State'),
      URL?: string(name='URL'),
    }(name='File'),
    publishState?: string(name='PublishState'),
    description?: string(name='Description'),
    width?: string(name='Width'),
    size?: string(name='Size'),
    coverURL?: string(name='CoverURL'),
    runIdList?: {
      runId?: [ string ](name='RunId')
    }(name='RunIdList'),
    duration?: string(name='Duration'),
    fps?: string(name='Fps'),
    title?: string(name='Title'),
    format?: string(name='Format'),
  }(name='Media'),
}

model AddMediaResponse = {
  headers: map[string]string(name='headers'),
  body: AddMediaResponseBody(name='body'),
}

async function addMediaWithOptions(request: AddMediaRequest, runtime: Util.RuntimeOptions): AddMediaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddMedia', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addMedia(request: AddMediaRequest): AddMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMediaWithOptions(request, runtime);
}

model AddMediaTagRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  mediaId?: string(name='MediaId'),
  tag?: string(name='Tag'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AddMediaTagResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddMediaTagResponse = {
  headers: map[string]string(name='headers'),
  body: AddMediaTagResponseBody(name='body'),
}

async function addMediaTagWithOptions(request: AddMediaTagRequest, runtime: Util.RuntimeOptions): AddMediaTagResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddMediaTag', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addMediaTag(request: AddMediaTagRequest): AddMediaTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMediaTagWithOptions(request, runtime);
}

model AddMediaWorkflowRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  name?: string(name='Name'),
  topology?: string(name='Topology'),
  triggerMode?: string(name='TriggerMode'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AddMediaWorkflowResponseBody = {
  requestId?: string(name='RequestId'),
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    state?: string(name='State'),
    triggerMode?: string(name='TriggerMode'),
    name?: string(name='Name'),
    topology?: string(name='Topology'),
  }(name='MediaWorkflow'),
}

model AddMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: AddMediaWorkflowResponseBody(name='body'),
}

async function addMediaWorkflowWithOptions(request: AddMediaWorkflowRequest, runtime: Util.RuntimeOptions): AddMediaWorkflowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddMediaWorkflow', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addMediaWorkflow(request: AddMediaWorkflowRequest): AddMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMediaWorkflowWithOptions(request, runtime);
}

model AddPipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  name?: string(name='Name'),
  speed?: string(name='Speed'),
  speedLevel?: long(name='SpeedLevel'),
  notifyConfig?: string(name='NotifyConfig'),
  role?: string(name='Role'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AddPipelineResponseBody = {
  requestId?: string(name='RequestId'),
  pipeline?: {
    speed?: string(name='Speed'),
    state?: string(name='State'),
    speedLevel?: long(name='SpeedLevel'),
    notifyConfig?: {
      mqTopic?: string(name='MqTopic'),
      queueName?: string(name='QueueName'),
      mqTag?: string(name='MqTag'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    role?: string(name='Role'),
    name?: string(name='Name'),
    id?: string(name='Id'),
    quotaAllocate?: long(name='QuotaAllocate'),
  }(name='Pipeline'),
}

model AddPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: AddPipelineResponseBody(name='body'),
}

async function addPipelineWithOptions(request: AddPipelineRequest, runtime: Util.RuntimeOptions): AddPipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddPipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addPipeline(request: AddPipelineRequest): AddPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPipelineWithOptions(request, runtime);
}

model AddPornPipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  name?: string(name='Name'),
  priority?: int32(name='Priority'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AddPornPipelineResponseBody = {
  requestId?: string(name='RequestId'),
  pipeline?: {
    state?: string(name='State'),
    notifyConfig?: {
      topic?: string(name='Topic'),
      queue?: string(name='Queue'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    name?: string(name='Name'),
    id?: string(name='Id'),
  }(name='Pipeline'),
}

model AddPornPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: AddPornPipelineResponseBody(name='body'),
}

async function addPornPipelineWithOptions(request: AddPornPipelineRequest, runtime: Util.RuntimeOptions): AddPornPipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddPornPipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addPornPipeline(request: AddPornPipelineRequest): AddPornPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPornPipelineWithOptions(request, runtime);
}

model AddSmarttagTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  templateName?: string(name='TemplateName'),
  industry?: string(name='Industry'),
  scene?: string(name='Scene'),
  analyseTypes?: string(name='AnalyseTypes'),
  faceCategoryIds?: string(name='FaceCategoryIds'),
  isDefault?: boolean(name='IsDefault'),
}

model AddSmarttagTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model AddSmarttagTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddSmarttagTemplateResponseBody(name='body'),
}

async function addSmarttagTemplateWithOptions(request: AddSmarttagTemplateRequest, runtime: Util.RuntimeOptions): AddSmarttagTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddSmarttagTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addSmarttagTemplate(request: AddSmarttagTemplateRequest): AddSmarttagTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSmarttagTemplateWithOptions(request, runtime);
}

model AddTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  name?: string(name='Name'),
  container?: string(name='Container'),
  video?: string(name='Video'),
  audio?: string(name='Audio'),
  transConfig?: string(name='TransConfig'),
  muxConfig?: string(name='MuxConfig'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AddTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    video?: {
      bufsize?: string(name='Bufsize'),
      longShortMode?: string(name='LongShortMode'),
      degrain?: string(name='Degrain'),
      bitrateBnd?: {
        max?: string(name='Max'),
        min?: string(name='Min'),
      }(name='BitrateBnd'),
      pixFmt?: string(name='PixFmt'),
      pad?: string(name='Pad'),
      codec?: string(name='Codec'),
      height?: string(name='Height'),
      qscale?: string(name='Qscale'),
      crop?: string(name='Crop'),
      bitrate?: string(name='Bitrate'),
      maxrate?: string(name='Maxrate'),
      maxFps?: string(name='MaxFps'),
      profile?: string(name='Profile'),
      crf?: string(name='Crf'),
      remove?: string(name='Remove'),
      gop?: string(name='Gop'),
      width?: string(name='Width'),
      fps?: string(name='Fps'),
      preset?: string(name='Preset'),
      scanMode?: string(name='ScanMode'),
      resoPriority?: string(name='ResoPriority'),
    }(name='Video'),
    transConfig?: {
      isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
      transMode?: string(name='TransMode'),
      isCheckReso?: string(name='IsCheckReso'),
      isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
      adjDarMethod?: string(name='AdjDarMethod'),
      isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
      isCheckResoFail?: string(name='IsCheckResoFail'),
      isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
    }(name='TransConfig'),
    state?: string(name='State'),
    muxConfig?: {
      webp?: {
        loop?: string(name='Loop'),
      }(name='Webp'),
      gif?: {
        finalDelay?: string(name='FinalDelay'),
        ditherMode?: string(name='DitherMode'),
        loop?: string(name='Loop'),
        isCustomPalette?: string(name='IsCustomPalette'),
      }(name='Gif'),
      segment?: {
        duration?: string(name='Duration'),
      }(name='Segment'),
    }(name='MuxConfig'),
    name?: string(name='Name'),
    audio?: {
      profile?: string(name='Profile'),
      remove?: string(name='Remove'),
      codec?: string(name='Codec'),
      samplerate?: string(name='Samplerate'),
      qscale?: string(name='Qscale'),
      channels?: string(name='Channels'),
      volume?: {
        method?: string(name='Method'),
        level?: string(name='Level'),
      }(name='Volume'),
      bitrate?: string(name='Bitrate'),
    }(name='Audio'),
    id?: string(name='Id'),
    container?: {
      format?: string(name='Format'),
    }(name='Container'),
  }(name='Template'),
}

model AddTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddTemplateResponseBody(name='body'),
}

async function addTemplateWithOptions(request: AddTemplateRequest, runtime: Util.RuntimeOptions): AddTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addTemplate(request: AddTemplateRequest): AddTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTemplateWithOptions(request, runtime);
}

model AddTerrorismPipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  name?: string(name='Name'),
  priority?: int32(name='Priority'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AddTerrorismPipelineResponseBody = {
  requestId?: string(name='RequestId'),
  pipeline?: {
    state?: string(name='State'),
    notifyConfig?: {
      topic?: string(name='Topic'),
      queue?: string(name='Queue'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    name?: string(name='Name'),
    id?: string(name='Id'),
  }(name='Pipeline'),
}

model AddTerrorismPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: AddTerrorismPipelineResponseBody(name='body'),
}

async function addTerrorismPipelineWithOptions(request: AddTerrorismPipelineRequest, runtime: Util.RuntimeOptions): AddTerrorismPipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddTerrorismPipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addTerrorismPipeline(request: AddTerrorismPipelineRequest): AddTerrorismPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTerrorismPipelineWithOptions(request, runtime);
}

model AddWaterMarkTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  name?: string(name='Name'),
  config?: string(name='Config'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AddWaterMarkTemplateResponseBody = {
  waterMarkTemplate?: {
    type?: string(name='Type'),
    ratioRefer?: {
      dx?: string(name='Dx'),
      width?: string(name='Width'),
      height?: string(name='Height'),
      dy?: string(name='Dy'),
    }(name='RatioRefer'),
    referPos?: string(name='ReferPos'),
    state?: string(name='State'),
    dx?: string(name='Dx'),
    width?: string(name='Width'),
    height?: string(name='Height'),
    timeline?: {
      start?: string(name='Start'),
      duration?: string(name='Duration'),
    }(name='Timeline'),
    name?: string(name='Name'),
    dy?: string(name='Dy'),
    id?: string(name='Id'),
  }(name='WaterMarkTemplate'),
  requestId?: string(name='RequestId'),
}

model AddWaterMarkTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddWaterMarkTemplateResponseBody(name='body'),
}

async function addWaterMarkTemplateWithOptions(request: AddWaterMarkTemplateRequest, runtime: Util.RuntimeOptions): AddWaterMarkTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddWaterMarkTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addWaterMarkTemplate(request: AddWaterMarkTemplateRequest): AddWaterMarkTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addWaterMarkTemplateWithOptions(request, runtime);
}

model BindInputBucketRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  bucket?: string(name='Bucket'),
  roleArn?: string(name='RoleArn'),
  ownerAccount?: string(name='OwnerAccount'),
}

model BindInputBucketResponseBody = {
  requestId?: string(name='RequestId'),
}

model BindInputBucketResponse = {
  headers: map[string]string(name='headers'),
  body: BindInputBucketResponseBody(name='body'),
}

async function bindInputBucketWithOptions(request: BindInputBucketRequest, runtime: Util.RuntimeOptions): BindInputBucketResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('BindInputBucket', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function bindInputBucket(request: BindInputBucketRequest): BindInputBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindInputBucketWithOptions(request, runtime);
}

model BindOutputBucketRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  bucket?: string(name='Bucket'),
  roleArn?: string(name='RoleArn'),
  ownerAccount?: string(name='OwnerAccount'),
}

model BindOutputBucketResponseBody = {
  requestId?: string(name='RequestId'),
}

model BindOutputBucketResponse = {
  headers: map[string]string(name='headers'),
  body: BindOutputBucketResponseBody(name='body'),
}

async function bindOutputBucketWithOptions(request: BindOutputBucketRequest, runtime: Util.RuntimeOptions): BindOutputBucketResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('BindOutputBucket', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function bindOutputBucket(request: BindOutputBucketRequest): BindOutputBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindOutputBucketWithOptions(request, runtime);
}

model CancelJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model CancelJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model CancelJobResponse = {
  headers: map[string]string(name='headers'),
  body: CancelJobResponseBody(name='body'),
}

async function cancelJobWithOptions(request: CancelJobRequest, runtime: Util.RuntimeOptions): CancelJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelJob(request: CancelJobRequest): CancelJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelJobWithOptions(request, runtime);
}

model CategoryTreeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model CategoryTreeResponseBody = {
  requestId?: string(name='RequestId'),
  categoryTree?: string(name='CategoryTree'),
}

model CategoryTreeResponse = {
  headers: map[string]string(name='headers'),
  body: CategoryTreeResponseBody(name='body'),
}

async function categoryTreeWithOptions(request: CategoryTreeRequest, runtime: Util.RuntimeOptions): CategoryTreeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CategoryTree', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function categoryTree(request: CategoryTreeRequest): CategoryTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  return categoryTreeWithOptions(request, runtime);
}

model CheckResourceRequest {
  interrupt?: boolean(name='Interrupt'),
  invoker?: string(name='Invoker'),
  pk?: string(name='Pk'),
  bid?: string(name='Bid'),
  hid?: long(name='Hid'),
  country?: string(name='Country'),
  taskIdentifier?: string(name='TaskIdentifier'),
  taskExtraData?: string(name='TaskExtraData'),
  gmtWakeup?: string(name='GmtWakeup'),
  success?: boolean(name='Success'),
  message?: string(name='Message'),
  level?: long(name='Level'),
  url?: string(name='Url'),
  prompt?: string(name='Prompt'),
}

model CheckResourceResponseBody = {
  gmtWakeup?: string(name='GmtWakeup'),
  hid?: long(name='Hid'),
  message?: string(name='Message'),
  taskIdentifier?: string(name='TaskIdentifier'),
  success?: boolean(name='Success'),
  url?: string(name='Url'),
  interrupt?: boolean(name='Interrupt'),
  invoker?: string(name='Invoker'),
  taskExtraData?: string(name='TaskExtraData'),
  country?: string(name='Country'),
  prompt?: string(name='Prompt'),
  level?: long(name='Level'),
  pk?: string(name='Pk'),
  bid?: string(name='Bid'),
}

model CheckResourceResponse = {
  headers: map[string]string(name='headers'),
  body: CheckResourceResponseBody(name='body'),
}

async function checkResourceWithOptions(request: CheckResourceRequest, runtime: Util.RuntimeOptions): CheckResourceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CheckResource', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function checkResource(request: CheckResourceRequest): CheckResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkResourceWithOptions(request, runtime);
}

model CreateFpShotDBRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  name?: string(name='Name'),
  modelId?: int32(name='ModelId'),
  config?: string(name='Config'),
  description?: string(name='Description'),
  ownerAccount?: string(name='OwnerAccount'),
}

model CreateFpShotDBResponseBody = {
  requestId?: string(name='RequestId'),
  fpShotDB?: {
    description?: string(name='Description'),
    state?: string(name='State'),
    name?: string(name='Name'),
    fpDBId?: string(name='FpDBId'),
    modelId?: int32(name='ModelId'),
    config?: string(name='Config'),
  }(name='FpShotDB'),
}

model CreateFpShotDBResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFpShotDBResponseBody(name='body'),
}

async function createFpShotDBWithOptions(request: CreateFpShotDBRequest, runtime: Util.RuntimeOptions): CreateFpShotDBResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateFpShotDB', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createFpShotDB(request: CreateFpShotDBRequest): CreateFpShotDBResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFpShotDBWithOptions(request, runtime);
}

model CreateMcuTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  template?: string(name='Template'),
}

model CreateMcuTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model CreateMcuTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMcuTemplateResponseBody(name='body'),
}

async function createMcuTemplateWithOptions(request: CreateMcuTemplateRequest, runtime: Util.RuntimeOptions): CreateMcuTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateMcuTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createMcuTemplate(request: CreateMcuTemplateRequest): CreateMcuTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcuTemplateWithOptions(request, runtime);
}

model CreateSessionRequest {
  ownerId?: string(name='OwnerId'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount'),
  endUserId?: string(name='EndUserId'),
  sessionTime?: int32(name='SessionTime'),
  mediaId?: string(name='MediaId'),
}

model CreateSessionResponseBody = {
  ticket?: string(name='Ticket'),
  requestId?: string(name='RequestId'),
  sessionId?: string(name='SessionId'),
}

model CreateSessionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSessionResponseBody(name='body'),
}

async function createSessionWithOptions(request: CreateSessionRequest, runtime: Util.RuntimeOptions): CreateSessionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateSession', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createSession(request: CreateSessionRequest): CreateSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSessionWithOptions(request, runtime);
}

model DeactivateMediaWorkflowRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeactivateMediaWorkflowResponseBody = {
  requestId?: string(name='RequestId'),
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    state?: string(name='State'),
    name?: string(name='Name'),
    topology?: string(name='Topology'),
  }(name='MediaWorkflow'),
}

model DeactivateMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: DeactivateMediaWorkflowResponseBody(name='body'),
}

async function deactivateMediaWorkflowWithOptions(request: DeactivateMediaWorkflowRequest, runtime: Util.RuntimeOptions): DeactivateMediaWorkflowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeactivateMediaWorkflow', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deactivateMediaWorkflow(request: DeactivateMediaWorkflowRequest): DeactivateMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deactivateMediaWorkflowWithOptions(request, runtime);
}

model DecryptKeyRequest {
  ownerId?: string(name='OwnerId'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount'),
  ciphertextBlob?: string(name='CiphertextBlob'),
  rand?: string(name='Rand'),
}

model DecryptKeyResponseBody = {
  rand?: string(name='Rand'),
  requestId?: string(name='RequestId'),
  plaintext?: string(name='Plaintext'),
}

model DecryptKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DecryptKeyResponseBody(name='body'),
}

async function decryptKeyWithOptions(request: DecryptKeyRequest, runtime: Util.RuntimeOptions): DecryptKeyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DecryptKey', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function decryptKey(request: DecryptKeyRequest): DecryptKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return decryptKeyWithOptions(request, runtime);
}

model DeleteCategoryRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  cateId?: long(name='CateId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteCategoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCategoryResponseBody(name='body'),
}

async function deleteCategoryWithOptions(request: DeleteCategoryRequest, runtime: Util.RuntimeOptions): DeleteCategoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteCategory', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteCategory(request: DeleteCategoryRequest): DeleteCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCategoryWithOptions(request, runtime);
}

model DeleteMCTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteMCTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model DeleteMCTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMCTemplateResponseBody(name='body'),
}

async function deleteMCTemplateWithOptions(request: DeleteMCTemplateRequest, runtime: Util.RuntimeOptions): DeleteMCTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMCTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMCTemplate(request: DeleteMCTemplateRequest): DeleteMCTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMCTemplateWithOptions(request, runtime);
}

model DeleteMcuJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  jobIds?: string(name='JobIds'),
}

model DeleteMcuJobResponseBody = {
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
  deletedJobIds?: {
    string?: [ string ](name='String')
  }(name='DeletedJobIds'),
}

model DeleteMcuJobResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMcuJobResponseBody(name='body'),
}

async function deleteMcuJobWithOptions(request: DeleteMcuJobRequest, runtime: Util.RuntimeOptions): DeleteMcuJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMcuJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMcuJob(request: DeleteMcuJobRequest): DeleteMcuJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcuJobWithOptions(request, runtime);
}

model DeleteMcuTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  templateId?: string(name='TemplateId'),
}

model DeleteMcuTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model DeleteMcuTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMcuTemplateResponseBody(name='body'),
}

async function deleteMcuTemplateWithOptions(request: DeleteMcuTemplateRequest, runtime: Util.RuntimeOptions): DeleteMcuTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMcuTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMcuTemplate(request: DeleteMcuTemplateRequest): DeleteMcuTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcuTemplateWithOptions(request, runtime);
}

model DeleteMediaRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  mediaIds?: string(name='MediaIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteMediaResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMediaResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMediaResponseBody(name='body'),
}

async function deleteMediaWithOptions(request: DeleteMediaRequest, runtime: Util.RuntimeOptions): DeleteMediaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMedia', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMedia(request: DeleteMediaRequest): DeleteMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMediaWithOptions(request, runtime);
}

model DeleteMediaTagRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  mediaId?: string(name='MediaId'),
  tag?: string(name='Tag'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteMediaTagResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMediaTagResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMediaTagResponseBody(name='body'),
}

async function deleteMediaTagWithOptions(request: DeleteMediaTagRequest, runtime: Util.RuntimeOptions): DeleteMediaTagResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMediaTag', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMediaTag(request: DeleteMediaTagRequest): DeleteMediaTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMediaTagWithOptions(request, runtime);
}

model DeleteMediaWorkflowRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteMediaWorkflowResponseBody = {
  requestId?: string(name='RequestId'),
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    state?: string(name='State'),
    name?: string(name='Name'),
    topology?: string(name='Topology'),
  }(name='MediaWorkflow'),
}

model DeleteMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMediaWorkflowResponseBody(name='body'),
}

async function deleteMediaWorkflowWithOptions(request: DeleteMediaWorkflowRequest, runtime: Util.RuntimeOptions): DeleteMediaWorkflowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMediaWorkflow', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMediaWorkflow(request: DeleteMediaWorkflowRequest): DeleteMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMediaWorkflowWithOptions(request, runtime);
}

model DeletePipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pipelineId?: string(name='PipelineId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeletePipelineResponseBody = {
  requestId?: string(name='RequestId'),
  pipelineId?: string(name='PipelineId'),
}

model DeletePipelineResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePipelineResponseBody(name='body'),
}

async function deletePipelineWithOptions(request: DeletePipelineRequest, runtime: Util.RuntimeOptions): DeletePipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeletePipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deletePipeline(request: DeletePipelineRequest): DeletePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePipelineWithOptions(request, runtime);
}

model DeleteSmarttagTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  templateId?: string(name='TemplateId'),
}

model DeleteSmarttagTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSmarttagTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSmarttagTemplateResponseBody(name='body'),
}

async function deleteSmarttagTemplateWithOptions(request: DeleteSmarttagTemplateRequest, runtime: Util.RuntimeOptions): DeleteSmarttagTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSmarttagTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSmarttagTemplate(request: DeleteSmarttagTemplateRequest): DeleteSmarttagTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSmarttagTemplateWithOptions(request, runtime);
}

model DeleteTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model DeleteTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTemplateResponseBody(name='body'),
}

async function deleteTemplateWithOptions(request: DeleteTemplateRequest, runtime: Util.RuntimeOptions): DeleteTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteTemplate(request: DeleteTemplateRequest): DeleteTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTemplateWithOptions(request, runtime);
}

model DeleteWaterMarkTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteWaterMarkTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
}

model DeleteWaterMarkTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteWaterMarkTemplateResponseBody(name='body'),
}

async function deleteWaterMarkTemplateWithOptions(request: DeleteWaterMarkTemplateRequest, runtime: Util.RuntimeOptions): DeleteWaterMarkTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteWaterMarkTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteWaterMarkTemplate(request: DeleteWaterMarkTemplateRequest): DeleteWaterMarkTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWaterMarkTemplateWithOptions(request, runtime);
}

model DescribeMtsUserResourcePackageRequest {
  securityToken?: string(name='SecurityToken'),
  ownerId?: long(name='OwnerId'),
  showLog?: string(name='ShowLog'),
}

model DescribeMtsUserResourcePackageResponseBody = {
  requestId?: string(name='RequestId'),
  resourcePackageInfos?: {
    resourcePackageInfo?: [ 
    {
      displayName?: string(name='DisplayName'),
      status?: string(name='Status'),
      commodityCode?: string(name='CommodityCode'),
      currCapacity?: string(name='CurrCapacity'),
      initCapacity?: string(name='InitCapacity'),
      instanceId?: string(name='InstanceId'),
    }
  ](name='ResourcePackageInfo')
  }(name='ResourcePackageInfos'),
}

model DescribeMtsUserResourcePackageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMtsUserResourcePackageResponseBody(name='body'),
}

async function describeMtsUserResourcePackageWithOptions(request: DescribeMtsUserResourcePackageRequest, runtime: Util.RuntimeOptions): DescribeMtsUserResourcePackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMtsUserResourcePackage', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMtsUserResourcePackage(request: DescribeMtsUserResourcePackageRequest): DescribeMtsUserResourcePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMtsUserResourcePackageWithOptions(request, runtime);
}

model GetLicenseRequest {
  ownerId?: string(name='OwnerId'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount'),
  licenseUrl?: string(name='LicenseUrl'),
  data?: string(name='Data'),
  mediaId?: string(name='MediaId'),
  header?: string(name='Header'),
  type?: string(name='Type'),
}

model GetLicenseResponseBody = {
  requestId?: string(name='RequestId'),
  license?: string(name='License'),
}

model GetLicenseResponse = {
  headers: map[string]string(name='headers'),
  body: GetLicenseResponseBody(name='body'),
}

async function getLicenseWithOptions(request: GetLicenseRequest, runtime: Util.RuntimeOptions): GetLicenseResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetLicense', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getLicense(request: GetLicenseRequest): GetLicenseResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLicenseWithOptions(request, runtime);
}

model GetPackageRequest {
  ownerId?: string(name='OwnerId'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount'),
  data?: string(name='Data'),
}

model GetPackageResponseBody = {
  certPackage?: string(name='CertPackage'),
  requestId?: string(name='RequestId'),
}

model GetPackageResponse = {
  headers: map[string]string(name='headers'),
  body: GetPackageResponseBody(name='body'),
}

async function getPackageWithOptions(request: GetPackageRequest, runtime: Util.RuntimeOptions): GetPackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetPackage', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getPackage(request: GetPackageRequest): GetPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPackageWithOptions(request, runtime);
}

model ListAllCategoryRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ListAllCategoryResponseBody = {
  categoryList?: {
    category?: [ 
    {
      cateName?: string(name='CateName'),
      parentId?: string(name='ParentId'),
      cateId?: string(name='CateId'),
      level?: string(name='Level'),
    }
  ](name='Category')
  }(name='CategoryList'),
  requestId?: string(name='RequestId'),
}

model ListAllCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: ListAllCategoryResponseBody(name='body'),
}

async function listAllCategoryWithOptions(request: ListAllCategoryRequest, runtime: Util.RuntimeOptions): ListAllCategoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListAllCategory', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listAllCategory(request: ListAllCategoryRequest): ListAllCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAllCategoryWithOptions(request, runtime);
}

model ListAllMediaBucketRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  nextPageToken?: string(name='NextPageToken'),
  maximumPageSize?: int32(name='MaximumPageSize'),
}

model ListAllMediaBucketResponseBody = {
  requestId?: string(name='RequestId'),
  nextPageToken?: string(name='NextPageToken'),
  mediaBucketList?: {
    mediaBucket?: [ 
    {
      type?: string(name='Type'),
      bucket?: string(name='Bucket'),
    }
  ](name='MediaBucket')
  }(name='MediaBucketList'),
}

model ListAllMediaBucketResponse = {
  headers: map[string]string(name='headers'),
  body: ListAllMediaBucketResponseBody(name='body'),
}

async function listAllMediaBucketWithOptions(request: ListAllMediaBucketRequest, runtime: Util.RuntimeOptions): ListAllMediaBucketResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListAllMediaBucket', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listAllMediaBucket(request: ListAllMediaBucketRequest): ListAllMediaBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAllMediaBucketWithOptions(request, runtime);
}

model ListAsrPipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pageSize?: long(name='PageSize'),
  pageNumber?: long(name='PageNumber'),
  state?: string(name='State'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ListAsrPipelineResponseBody = {
  totalCount?: long(name='TotalCount'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: long(name='PageNumber'),
  pipelineList?: {
    pipeline?: [ 
    {
      state?: string(name='State'),
      notifyConfig?: {
        queueName?: string(name='QueueName'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
}

model ListAsrPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: ListAsrPipelineResponseBody(name='body'),
}

async function listAsrPipelineWithOptions(request: ListAsrPipelineRequest, runtime: Util.RuntimeOptions): ListAsrPipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListAsrPipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listAsrPipeline(request: ListAsrPipelineRequest): ListAsrPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAsrPipelineWithOptions(request, runtime);
}

model ListCensorPipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pageSize?: long(name='PageSize'),
  pageNumber?: long(name='PageNumber'),
  state?: string(name='State'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ListCensorPipelineResponseBody = {
  totalCount?: long(name='TotalCount'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: long(name='PageNumber'),
  pipelineList?: {
    pipeline?: [ 
    {
      state?: string(name='State'),
      notifyConfig?: {
        topic?: string(name='Topic'),
        queue?: string(name='Queue'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
}

model ListCensorPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: ListCensorPipelineResponseBody(name='body'),
}

async function listCensorPipelineWithOptions(request: ListCensorPipelineRequest, runtime: Util.RuntimeOptions): ListCensorPipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListCensorPipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listCensorPipeline(request: ListCensorPipelineRequest): ListCensorPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCensorPipelineWithOptions(request, runtime);
}

model ListCoverPipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pageSize?: long(name='PageSize'),
  pageNumber?: long(name='PageNumber'),
  state?: string(name='State'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ListCoverPipelineResponseBody = {
  totalCount?: long(name='TotalCount'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: long(name='PageNumber'),
  pipelineList?: {
    pipeline?: [ 
    {
      state?: string(name='State'),
      quotaNum?: int32(name='quotaNum'),
      userId?: long(name='UserId'),
      notifyConfig?: string(name='NotifyConfig'),
      extendConfig?: string(name='ExtendConfig'),
      priority?: string(name='Priority'),
      role?: string(name='Role'),
      name?: string(name='Name'),
      pipelineId?: string(name='PipelineId'),
      quotaUsed?: int32(name='quotaUsed'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
}

model ListCoverPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: ListCoverPipelineResponseBody(name='body'),
}

async function listCoverPipelineWithOptions(request: ListCoverPipelineRequest, runtime: Util.RuntimeOptions): ListCoverPipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListCoverPipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listCoverPipeline(request: ListCoverPipelineRequest): ListCoverPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCoverPipelineWithOptions(request, runtime);
}

model ListCustomPersonsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  categoryId?: string(name='CategoryId'),
  personId?: string(name='PersonId'),
}

model ListCustomPersonsResponseBody = {
  requestId?: string(name='RequestId'),
  categories?: {
    category?: [ 
    {
      persons?: {
        person?: [ 
        {
          personName?: string(name='PersonName'),
          personDescription?: string(name='PersonDescription'),
          faces?: {
            face?: [ 
            {
              imageUrl?: string(name='ImageUrl'),
              faceId?: string(name='FaceId'),
            }
          ](name='Face')
          }(name='Faces'),
          personId?: string(name='PersonId'),
        }
      ](name='Person')
      }(name='Persons'),
      categoryId?: string(name='CategoryId'),
      categoryName?: string(name='CategoryName'),
      categoryDescription?: string(name='CategoryDescription'),
    }
  ](name='Category')
  }(name='Categories'),
}

model ListCustomPersonsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCustomPersonsResponseBody(name='body'),
}

async function listCustomPersonsWithOptions(request: ListCustomPersonsRequest, runtime: Util.RuntimeOptions): ListCustomPersonsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListCustomPersons', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listCustomPersons(request: ListCustomPersonsRequest): ListCustomPersonsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCustomPersonsWithOptions(request, runtime);
}

model ListFpShotDBRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  fpDBIds?: string(name='FpDBIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ListFpShotDBResponseBody = {
  fpShotDBList?: {
    fpShotDB?: [ 
    {
      status?: string(name='Status'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      modelId?: int32(name='ModelId'),
      fpDBId?: string(name='FpDBId'),
    }
  ](name='FpShotDB')
  }(name='FpShotDBList'),
  requestId?: string(name='RequestId'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model ListFpShotDBResponse = {
  headers: map[string]string(name='headers'),
  body: ListFpShotDBResponseBody(name='body'),
}

async function listFpShotDBWithOptions(request: ListFpShotDBRequest, runtime: Util.RuntimeOptions): ListFpShotDBResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFpShotDB', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFpShotDB(request: ListFpShotDBRequest): ListFpShotDBResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFpShotDBWithOptions(request, runtime);
}

model ListFpShotFilesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: long(name='PageSize'),
  fpDBId?: string(name='FpDBId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ListFpShotFilesResponseBody = {
  requestId?: string(name='RequestId'),
  nextPageToken?: string(name='NextPageToken'),
  fpShotFileList?: {
    fpShotFile?: [ 
    {
      primaryKey?: string(name='PrimaryKey'),
      inputFile?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='InputFile'),
      fileId?: string(name='FileId'),
    }
  ](name='FpShotFile')
  }(name='FpShotFileList'),
}

model ListFpShotFilesResponse = {
  headers: map[string]string(name='headers'),
  body: ListFpShotFilesResponseBody(name='body'),
}

async function listFpShotFilesWithOptions(request: ListFpShotFilesRequest, runtime: Util.RuntimeOptions): ListFpShotFilesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFpShotFiles', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFpShotFiles(request: ListFpShotFilesRequest): ListFpShotFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFpShotFilesWithOptions(request, runtime);
}

model ListFpShotNotaryRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  nextPageToken?: string(name='NextPageToken'),
  maximumPageSize?: long(name='MaximumPageSize'),
  startOfCreatedTimeRange?: string(name='StartOfCreatedTimeRange'),
  endOfCreatedTimeRange?: string(name='EndOfCreatedTimeRange'),
  fpDBId?: string(name='FpDBId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ListFpShotNotaryResponseBody = {
  requestId?: string(name='RequestId'),
  fpShotNotaryList?: {
    fpShotNotary?: [ 
    {
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      jobId?: string(name='JobId'),
      txHash?: string(name='TxHash'),
      transactionId?: string(name='TransactionId'),
      fpDBId?: string(name='FpDBId'),
      detail?: string(name='Detail'),
    }
  ](name='FpShotNotary')
  }(name='FpShotNotaryList'),
  nextPageToken?: string(name='NextPageToken'),
}

model ListFpShotNotaryResponse = {
  headers: map[string]string(name='headers'),
  body: ListFpShotNotaryResponseBody(name='body'),
}

async function listFpShotNotaryWithOptions(request: ListFpShotNotaryRequest, runtime: Util.RuntimeOptions): ListFpShotNotaryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFpShotNotary', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFpShotNotary(request: ListFpShotNotaryRequest): ListFpShotNotaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFpShotNotaryWithOptions(request, runtime);
}

model ListJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  nextPageToken?: string(name='NextPageToken'),
  maximumPageSize?: long(name='MaximumPageSize'),
  state?: string(name='State'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange'),
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange'),
  pipelineId?: string(name='PipelineId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ListJobResponseBody = {
  requestId?: string(name='RequestId'),
  nextPageToken?: string(name='NextPageToken'),
  jobList?: {
    job?: [ 
    {
      creationTime?: string(name='CreationTime'),
      percent?: long(name='Percent'),
      finishTime?: string(name='FinishTime'),
      state?: string(name='State'),
      jobId?: string(name='JobId'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      output?: {
        video?: {
          bufsize?: string(name='Bufsize'),
          degrain?: string(name='Degrain'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          pixFmt?: string(name='PixFmt'),
          pad?: string(name='Pad'),
          codec?: string(name='Codec'),
          height?: string(name='Height'),
          qscale?: string(name='Qscale'),
          crop?: string(name='Crop'),
          bitrate?: string(name='Bitrate'),
          maxrate?: string(name='Maxrate'),
          maxFps?: string(name='MaxFps'),
          profile?: string(name='Profile'),
          crf?: string(name='Crf'),
          gop?: string(name='Gop'),
          width?: string(name='Width'),
          fps?: string(name='Fps'),
          preset?: string(name='Preset'),
          scanMode?: string(name='ScanMode'),
          resoPriority?: string(name='ResoPriority'),
        }(name='Video'),
        transConfig?: {
          isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
          transMode?: string(name='TransMode'),
          isCheckReso?: string(name='IsCheckReso'),
          isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
          adjDarMethod?: string(name='AdjDarMethod'),
          isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
          isCheckResoFail?: string(name='IsCheckResoFail'),
          isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
        }(name='TransConfig'),
        encryption?: {
          type?: string(name='Type'),
          key?: string(name='Key'),
          keyType?: string(name='KeyType'),
          id?: string(name='Id'),
          keyUri?: string(name='KeyUri'),
          skipCnt?: string(name='SkipCnt'),
        }(name='Encryption'),
        waterMarkList?: {
          waterMark?: [ 
          {
            type?: string(name='Type'),
            referPos?: string(name='ReferPos'),
            dx?: string(name='Dx'),
            width?: string(name='Width'),
            height?: string(name='Height'),
            inputFile?: {
              object?: string(name='Object'),
              location?: string(name='Location'),
              bucket?: string(name='Bucket'),
            }(name='InputFile'),
            waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
            dy?: string(name='Dy'),
          }
        ](name='WaterMark')
        }(name='WaterMarkList'),
        waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
        deWatermark?: string(name='DeWatermark'),
        m3U8NonStandardSupport?: {
          TS?: {
            sizeSupport?: boolean(name='SizeSupport'),
            md5Support?: boolean(name='Md5Support'),
          }(name='TS'),
        }(name='M3U8NonStandardSupport'),
        priority?: string(name='Priority'),
        audio?: {
          profile?: string(name='Profile'),
          codec?: string(name='Codec'),
          samplerate?: string(name='Samplerate'),
          qscale?: string(name='Qscale'),
          channels?: string(name='Channels'),
          volume?: {
            method?: string(name='Method'),
            level?: string(name='Level'),
          }(name='Volume'),
          bitrate?: string(name='Bitrate'),
        }(name='Audio'),
        audioStreamMap?: string(name='AudioStreamMap'),
        mergeList?: {
          merge?: [ 
          {
            start?: string(name='Start'),
            roleArn?: string(name='RoleArn'),
            mergeURL?: string(name='MergeURL'),
            duration?: string(name='Duration'),
          }
        ](name='Merge')
        }(name='MergeList'),
        superReso?: {
          isHalfSample?: string(name='IsHalfSample'),
        }(name='SuperReso'),
        userData?: string(name='UserData'),
        outSubtitleList?: {
          outSubtitle?: [ 
          {
            map?: string(name='Map'),
            outSubtitleFile?: {
              roleArn?: string(name='RoleArn'),
              object?: string(name='Object'),
              location?: string(name='Location'),
              bucket?: string(name='Bucket'),
            }(name='OutSubtitleFile'),
            success?: boolean(name='Success'),
            message?: string(name='Message'),
          }
        ](name='OutSubtitle')
        }(name='OutSubtitleList'),
        videoStreamMap?: string(name='VideoStreamMap'),
        outputFile?: {
          roleArn?: string(name='RoleArn'),
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='OutputFile'),
        rotate?: string(name='Rotate'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        clip?: {
          timeSpan?: {
            seek?: string(name='Seek'),
            duration?: string(name='Duration'),
          }(name='TimeSpan'),
        }(name='Clip'),
        mergeConfigUrl?: string(name='MergeConfigUrl'),
        openingList?: {
          opening?: [ 
          {
            openUrl?: string(name='openUrl'),
            start?: string(name='Start'),
            width?: string(name='Width'),
            height?: string(name='Height'),
          }
        ](name='Opening')
        }(name='OpeningList'),
        muxConfig?: {
          webp?: {
            loop?: string(name='Loop'),
          }(name='Webp'),
          gif?: {
            finalDelay?: string(name='FinalDelay'),
            ditherMode?: string(name='DitherMode'),
            loop?: string(name='Loop'),
            isCustomPalette?: string(name='IsCustomPalette'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
        }(name='MuxConfig'),
        tailSlateList?: {
          tailSlate?: [ 
          {
            start?: string(name='Start'),
            bgColor?: string(name='BgColor'),
            isMergeAudio?: boolean(name='IsMergeAudio'),
            width?: string(name='Width'),
            height?: string(name='Height'),
            blendDuration?: string(name='BlendDuration'),
            tailUrl?: string(name='TailUrl'),
          }
        ](name='TailSlate')
        }(name='TailSlateList'),
        templateId?: string(name='TemplateId'),
        subtitleConfig?: {
          extSubtitleList?: {
            extSubtitle?: [ 
            {
              charEnc?: string(name='CharEnc'),
              fontName?: string(name='FontName'),
              input?: {
                object?: string(name='Object'),
                location?: string(name='Location'),
                bucket?: string(name='Bucket'),
              }(name='Input'),
            }
          ](name='ExtSubtitle')
          }(name='ExtSubtitleList'),
          subtitleList?: {
            subtitle?: [ 
            {
              map?: string(name='Map'),
            }
          ](name='Subtitle')
          }(name='SubtitleList'),
        }(name='SubtitleConfig'),
        properties?: {
          width?: string(name='Width'),
          height?: string(name='Height'),
          duration?: string(name='Duration'),
          fps?: string(name='Fps'),
          bitrate?: string(name='Bitrate'),
          fileFormat?: string(name='FileFormat'),
          streams?: {
            videoStreamList?: {
              videoStream?: [ 
              {
                index?: string(name='Index'),
                timebase?: string(name='Timebase'),
                avgFPS?: string(name='AvgFPS'),
                pixFmt?: string(name='PixFmt'),
                sar?: string(name='Sar'),
                lang?: string(name='Lang'),
                codecLongName?: string(name='CodecLongName'),
                height?: string(name='Height'),
                numFrames?: string(name='NumFrames'),
                bitrate?: string(name='Bitrate'),
                codecTagString?: string(name='CodecTagString'),
                hasBFrames?: string(name='HasBFrames'),
                profile?: string(name='Profile'),
                startTime?: string(name='StartTime'),
                networkCost?: {
                  preloadTime?: string(name='PreloadTime'),
                  avgBitrate?: string(name='AvgBitrate'),
                  costBandwidth?: string(name='CostBandwidth'),
                }(name='NetworkCost'),
                dar?: string(name='Dar'),
                codecName?: string(name='CodecName'),
                width?: string(name='Width'),
                duration?: string(name='Duration'),
                fps?: string(name='Fps'),
                codecTag?: string(name='CodecTag'),
                codecTimeBase?: string(name='CodecTimeBase'),
                level?: string(name='Level'),
              }
            ](name='VideoStream')
            }(name='VideoStreamList'),
            audioStreamList?: {
              audioStream?: [ 
              {
                timebase?: string(name='Timebase'),
                index?: string(name='Index'),
                sampleFmt?: string(name='SampleFmt'),
                channelLayout?: string(name='ChannelLayout'),
                lang?: string(name='Lang'),
                samplerate?: string(name='Samplerate'),
                codecLongName?: string(name='CodecLongName'),
                channels?: string(name='Channels'),
                numFrames?: string(name='NumFrames'),
                bitrate?: string(name='Bitrate'),
                codecTagString?: string(name='CodecTagString'),
                startTime?: string(name='StartTime'),
                codecName?: string(name='CodecName'),
                duration?: string(name='Duration'),
                codecTag?: string(name='CodecTag'),
                codecTimeBase?: string(name='CodecTimeBase'),
              }
            ](name='AudioStream')
            }(name='AudioStreamList'),
            subtitleStreamList?: {
              subtitleStream?: [ 
              {
                index?: string(name='Index'),
                lang?: string(name='Lang'),
              }
            ](name='SubtitleStream')
            }(name='SubtitleStreamList'),
          }(name='Streams'),
          format?: {
            startTime?: string(name='StartTime'),
            numPrograms?: string(name='NumPrograms'),
            size?: string(name='Size'),
            numStreams?: string(name='NumStreams'),
            formatLongName?: string(name='FormatLongName'),
            duration?: string(name='Duration'),
            bitrate?: string(name='Bitrate'),
            formatName?: string(name='FormatName'),
          }(name='Format'),
          fileSize?: string(name='FileSize'),
        }(name='Properties'),
      }(name='Output'),
      pipelineId?: string(name='PipelineId'),
      input?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      MNSMessageResult?: {
        messageId?: string(name='MessageId'),
        errorMessage?: string(name='ErrorMessage'),
        errorCode?: string(name='ErrorCode'),
      }(name='MNSMessageResult'),
    }
  ](name='Job')
  }(name='JobList'),
}

model ListJobResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobResponseBody(name='body'),
}

async function listJobWithOptions(request: ListJobRequest, runtime: Util.RuntimeOptions): ListJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listJob(request: ListJobRequest): ListJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobWithOptions(request, runtime);
}

model ListMediaRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  nextPageToken?: string(name='NextPageToken'),
  maximumPageSize?: long(name='MaximumPageSize'),
  from?: string(name='From'),
  to?: string(name='To'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ListMediaResponseBody = {
  mediaList?: {
    media?: [ 
    {
      creationTime?: string(name='CreationTime'),
      cateId?: long(name='CateId'),
      height?: string(name='Height'),
      censorState?: string(name='CensorState'),
      tags?: {
        tag?: [ string ](name='Tag')
      }(name='Tags'),
      bitrate?: string(name='Bitrate'),
      mediaId?: string(name='MediaId'),
      file?: {
        state?: string(name='State'),
        URL?: string(name='URL'),
      }(name='File'),
      publishState?: string(name='PublishState'),
      description?: string(name='Description'),
      width?: string(name='Width'),
      size?: string(name='Size'),
      coverURL?: string(name='CoverURL'),
      runIdList?: {
        runId?: [ string ](name='RunId')
      }(name='RunIdList'),
      duration?: string(name='Duration'),
      fps?: string(name='Fps'),
      title?: string(name='Title'),
      format?: string(name='Format'),
    }
  ](name='Media')
  }(name='MediaList'),
  requestId?: string(name='RequestId'),
  nextPageToken?: string(name='NextPageToken'),
}

model ListMediaResponse = {
  headers: map[string]string(name='headers'),
  body: ListMediaResponseBody(name='body'),
}

async function listMediaWithOptions(request: ListMediaRequest, runtime: Util.RuntimeOptions): ListMediaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListMedia', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listMedia(request: ListMediaRequest): ListMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMediaWithOptions(request, runtime);
}

model ListMediaWorkflowExecutionsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  mediaWorkflowName?: string(name='MediaWorkflowName'),
  inputFileURL?: string(name='InputFileURL'),
  nextPageToken?: string(name='NextPageToken'),
  maximumPageSize?: long(name='MaximumPageSize'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ListMediaWorkflowExecutionsResponseBody = {
  mediaWorkflowExecutionList?: {
    mediaWorkflowExecution?: [ 
    {
      creationTime?: string(name='CreationTime'),
      mediaWorkflowId?: string(name='MediaWorkflowId'),
      state?: string(name='State'),
      activityList?: {
        activity?: [ 
        {
          endTime?: string(name='EndTime'),
          type?: string(name='Type'),
          startTime?: string(name='StartTime'),
          state?: string(name='State'),
          jobId?: string(name='JobId'),
          code?: string(name='Code'),
          message?: string(name='Message'),
          name?: string(name='Name'),
          MNSMessageResult?: {
            messageId?: string(name='MessageId'),
            errorMessage?: string(name='ErrorMessage'),
            errorCode?: string(name='ErrorCode'),
          }(name='MNSMessageResult'),
        }
      ](name='Activity')
      }(name='ActivityList'),
      name?: string(name='Name'),
      input?: {
        userData?: string(name='UserData'),
        inputFile?: {
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='InputFile'),
      }(name='Input'),
      mediaId?: string(name='MediaId'),
      runId?: string(name='RunId'),
    }
  ](name='MediaWorkflowExecution')
  }(name='MediaWorkflowExecutionList'),
  requestId?: string(name='RequestId'),
  nextPageToken?: string(name='NextPageToken'),
}

model ListMediaWorkflowExecutionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListMediaWorkflowExecutionsResponseBody(name='body'),
}

async function listMediaWorkflowExecutionsWithOptions(request: ListMediaWorkflowExecutionsRequest, runtime: Util.RuntimeOptions): ListMediaWorkflowExecutionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListMediaWorkflowExecutions', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listMediaWorkflowExecutions(request: ListMediaWorkflowExecutionsRequest): ListMediaWorkflowExecutionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMediaWorkflowExecutionsWithOptions(request, runtime);
}

model ListPornPipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pageSize?: long(name='PageSize'),
  pageNumber?: long(name='PageNumber'),
  state?: string(name='State'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ListPornPipelineResponseBody = {
  totalCount?: long(name='TotalCount'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: long(name='PageNumber'),
  pipelineList?: {
    pipeline?: [ 
    {
      state?: string(name='State'),
      notifyConfig?: {
        topic?: string(name='Topic'),
        queue?: string(name='Queue'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
}

model ListPornPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: ListPornPipelineResponseBody(name='body'),
}

async function listPornPipelineWithOptions(request: ListPornPipelineRequest, runtime: Util.RuntimeOptions): ListPornPipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListPornPipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listPornPipeline(request: ListPornPipelineRequest): ListPornPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPornPipelineWithOptions(request, runtime);
}

model ListTerrorismPipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pageSize?: long(name='PageSize'),
  pageNumber?: long(name='PageNumber'),
  state?: string(name='State'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ListTerrorismPipelineResponseBody = {
  totalCount?: long(name='TotalCount'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: long(name='PageNumber'),
  pipelineList?: {
    pipeline?: [ 
    {
      state?: string(name='State'),
      notifyConfig?: {
        topic?: string(name='Topic'),
        queue?: string(name='Queue'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
}

model ListTerrorismPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: ListTerrorismPipelineResponseBody(name='body'),
}

async function listTerrorismPipelineWithOptions(request: ListTerrorismPipelineRequest, runtime: Util.RuntimeOptions): ListTerrorismPipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTerrorismPipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTerrorismPipeline(request: ListTerrorismPipelineRequest): ListTerrorismPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTerrorismPipelineWithOptions(request, runtime);
}

model LogicalDeleteResourceRequest {
  interrupt?: boolean(name='Interrupt'),
  invoker?: string(name='Invoker'),
  pk?: string(name='Pk'),
  bid?: string(name='Bid'),
  hid?: long(name='Hid'),
  country?: string(name='Country'),
  taskIdentifier?: string(name='TaskIdentifier'),
  taskExtraData?: string(name='TaskExtraData'),
  gmtWakeup?: string(name='GmtWakeup'),
  success?: boolean(name='Success'),
  message?: string(name='Message'),
}

model LogicalDeleteResourceResponseBody = {
  gmtWakeup?: string(name='GmtWakeup'),
  hid?: long(name='Hid'),
  invoker?: string(name='Invoker'),
  message?: string(name='Message'),
  taskIdentifier?: string(name='TaskIdentifier'),
  taskExtraData?: string(name='TaskExtraData'),
  country?: string(name='Country'),
  pk?: string(name='Pk'),
  bid?: string(name='Bid'),
  success?: boolean(name='Success'),
  interrupt?: boolean(name='Interrupt'),
}

model LogicalDeleteResourceResponse = {
  headers: map[string]string(name='headers'),
  body: LogicalDeleteResourceResponseBody(name='body'),
}

async function logicalDeleteResourceWithOptions(request: LogicalDeleteResourceRequest, runtime: Util.RuntimeOptions): LogicalDeleteResourceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('LogicalDeleteResource', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function logicalDeleteResource(request: LogicalDeleteResourceRequest): LogicalDeleteResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return logicalDeleteResourceWithOptions(request, runtime);
}

model PhysicalDeleteResourceRequest {
  interrupt?: boolean(name='Interrupt'),
  invoker?: string(name='Invoker'),
  pk?: string(name='Pk'),
  bid?: string(name='Bid'),
  hid?: long(name='Hid'),
  country?: string(name='Country'),
  taskIdentifier?: string(name='TaskIdentifier'),
  taskExtraData?: string(name='TaskExtraData'),
  gmtWakeup?: string(name='GmtWakeup'),
  success?: boolean(name='Success'),
  message?: string(name='Message'),
}

model PhysicalDeleteResourceResponseBody = {
  gmtWakeup?: string(name='GmtWakeup'),
  hid?: long(name='Hid'),
  invoker?: string(name='Invoker'),
  message?: string(name='Message'),
  taskIdentifier?: string(name='TaskIdentifier'),
  taskExtraData?: string(name='TaskExtraData'),
  country?: string(name='Country'),
  pk?: string(name='Pk'),
  bid?: string(name='Bid'),
  success?: boolean(name='Success'),
  interrupt?: boolean(name='Interrupt'),
}

model PhysicalDeleteResourceResponse = {
  headers: map[string]string(name='headers'),
  body: PhysicalDeleteResourceResponseBody(name='body'),
}

async function physicalDeleteResourceWithOptions(request: PhysicalDeleteResourceRequest, runtime: Util.RuntimeOptions): PhysicalDeleteResourceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PhysicalDeleteResource', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function physicalDeleteResource(request: PhysicalDeleteResourceRequest): PhysicalDeleteResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return physicalDeleteResourceWithOptions(request, runtime);
}

model PlayerAuthRequest {
  ownerId?: string(name='OwnerId'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount'),
}

model PlayerAuthResponseBody = {
  requestId?: string(name='RequestId'),
  logURL?: string(name='LogURL'),
  switchList?: {
    switch?: [ 
    {
      functionId?: string(name='FunctionId'),
      functionName?: string(name='FunctionName'),
      state?: string(name='State'),
      switchId?: string(name='SwitchId'),
    }
  ](name='Switch')
  }(name='SwitchList'),
}

model PlayerAuthResponse = {
  headers: map[string]string(name='headers'),
  body: PlayerAuthResponseBody(name='body'),
}

async function playerAuthWithOptions(request: PlayerAuthRequest, runtime: Util.RuntimeOptions): PlayerAuthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PlayerAuth', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function playerAuth(request: PlayerAuthRequest): PlayerAuthResponse {
  var runtime = new Util.RuntimeOptions{};
  return playerAuthWithOptions(request, runtime);
}

model PlayInfoRequest {
  ownerId?: string(name='OwnerId'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount'),
  mediaId?: string(name='MediaId'),
  formats?: string(name='Formats'),
  authInfo?: string(name='AuthInfo'),
  authTimeout?: long(name='AuthTimeout'),
  rand?: string(name='Rand'),
  playDomain?: string(name='PlayDomain'),
  hlsUriToken?: string(name='HlsUriToken'),
  terminal?: string(name='Terminal'),
}

model PlayInfoResponseBody = {
  requestId?: string(name='RequestId'),
  notFoundCDNDomain?: {
    string?: [ string ](name='String')
  }(name='NotFoundCDNDomain'),
  playInfoList?: {
    playInfo?: [ 
    {
      downloadType?: string(name='downloadType'),
      width?: string(name='width'),
      definition?: string(name='definition'),
      rand?: string(name='rand'),
      url?: string(name='Url'),
      complexity?: string(name='complexity'),
      encryption?: string(name='encryption'),
      fps?: string(name='fps'),
      encryptionType?: string(name='encryptionType'),
      height?: string(name='height'),
      activityName?: string(name='activityName'),
      size?: string(name='size'),
      bitrate?: string(name='bitrate'),
      plaintext?: string(name='plaintext'),
      duration?: string(name='duration'),
      format?: string(name='format'),
    }
  ](name='PlayInfo')
  }(name='PlayInfoList'),
}

model PlayInfoResponse = {
  headers: map[string]string(name='headers'),
  body: PlayInfoResponseBody(name='body'),
}

async function playInfoWithOptions(request: PlayInfoRequest, runtime: Util.RuntimeOptions): PlayInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PlayInfo', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function playInfo(request: PlayInfoRequest): PlayInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return playInfoWithOptions(request, runtime);
}

model QueryAnalysisJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  analysisJobIds?: string(name='AnalysisJobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryAnalysisJobListResponseBody = {
  requestId?: string(name='RequestId'),
  analysisJobList?: {
    analysisJob?: [ 
    {
      creationTime?: string(name='CreationTime'),
      percent?: long(name='Percent'),
      state?: string(name='State'),
      analysisConfig?: {
        qualityControl?: {
          methodStreaming?: string(name='MethodStreaming'),
          rateQuality?: string(name='RateQuality'),
        }(name='QualityControl'),
        propertiesControl?: {
          deinterlace?: string(name='Deinterlace'),
          crop?: {
            top?: string(name='Top'),
            width?: string(name='Width'),
            height?: string(name='Height'),
            left?: string(name='Left'),
            mode?: string(name='Mode'),
          }(name='Crop'),
        }(name='PropertiesControl'),
      }(name='AnalysisConfig'),
      message?: string(name='Message'),
      priority?: string(name='Priority'),
      MNSMessageResult?: {
        messageId?: string(name='MessageId'),
        errorMessage?: string(name='ErrorMessage'),
        errorCode?: string(name='ErrorCode'),
      }(name='MNSMessageResult'),
      templateList?: {
        template?: [ 
        {
          video?: {
            bufsize?: string(name='Bufsize'),
            degrain?: string(name='Degrain'),
            bitrateBnd?: {
              max?: string(name='Max'),
              min?: string(name='Min'),
            }(name='BitrateBnd'),
            pixFmt?: string(name='PixFmt'),
            codec?: string(name='Codec'),
            height?: string(name='Height'),
            qscale?: string(name='Qscale'),
            bitrate?: string(name='Bitrate'),
            maxrate?: string(name='Maxrate'),
            profile?: string(name='Profile'),
            crf?: string(name='Crf'),
            gop?: string(name='Gop'),
            width?: string(name='Width'),
            fps?: string(name='Fps'),
            preset?: string(name='Preset'),
            scanMode?: string(name='ScanMode'),
          }(name='Video'),
          transConfig?: {
            transMode?: string(name='TransMode'),
          }(name='TransConfig'),
          state?: string(name='State'),
          muxConfig?: {
            gif?: {
              finalDelay?: string(name='FinalDelay'),
              loop?: string(name='Loop'),
            }(name='Gif'),
            segment?: {
              duration?: string(name='Duration'),
            }(name='Segment'),
          }(name='MuxConfig'),
          name?: string(name='Name'),
          audio?: {
            profile?: string(name='Profile'),
            codec?: string(name='Codec'),
            samplerate?: string(name='Samplerate'),
            qscale?: string(name='Qscale'),
            channels?: string(name='Channels'),
            bitrate?: string(name='Bitrate'),
          }(name='Audio'),
          id?: string(name='Id'),
          container?: {
            format?: string(name='Format'),
          }(name='Container'),
        }
      ](name='Template')
      }(name='TemplateList'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      inputFile?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='InputFile'),
      pipelineId?: string(name='PipelineId'),
      id?: string(name='Id'),
    }
  ](name='AnalysisJob')
  }(name='AnalysisJobList'),
  nonExistAnalysisJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistAnalysisJobIds'),
}

model QueryAnalysisJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAnalysisJobListResponseBody(name='body'),
}

async function queryAnalysisJobListWithOptions(request: QueryAnalysisJobListRequest, runtime: Util.RuntimeOptions): QueryAnalysisJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryAnalysisJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryAnalysisJobList(request: QueryAnalysisJobListRequest): QueryAnalysisJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAnalysisJobListWithOptions(request, runtime);
}

model QueryAnnotationJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  annotationJobIds?: string(name='AnnotationJobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryAnnotationJobListResponseBody = {
  annotationJobList?: {
    annotationJob?: [ 
    {
      creationTime?: string(name='CreationTime'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      input?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      id?: string(name='Id'),
      videoAnnotationResult?: {
        annotations?: {
          annotation?: [ 
          {
            score?: string(name='Score'),
            label?: string(name='Label'),
          }
        ](name='Annotation')
        }(name='Annotations'),
        details?: string(name='Details'),
      }(name='VideoAnnotationResult'),
    }
  ](name='AnnotationJob')
  }(name='AnnotationJobList'),
  requestId?: string(name='RequestId'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryAnnotationJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAnnotationJobListResponseBody(name='body'),
}

async function queryAnnotationJobListWithOptions(request: QueryAnnotationJobListRequest, runtime: Util.RuntimeOptions): QueryAnnotationJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryAnnotationJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryAnnotationJobList(request: QueryAnnotationJobListRequest): QueryAnnotationJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAnnotationJobListWithOptions(request, runtime);
}

model QueryAsrJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryAsrJobListResponseBody = {
  requestId?: string(name='RequestId'),
  jobList?: {
    job?: [ 
    {
      creationTime?: string(name='CreationTime'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      asrConfig?: {
        scene?: string(name='Scene'),
      }(name='AsrConfig'),
      pipelineId?: string(name='PipelineId'),
      input?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      id?: string(name='Id'),
      asrResult?: {
        duration?: string(name='Duration'),
        asrTextList?: {
          asrText?: [ 
          {
            endTime?: string(name='EndTime'),
            startTime?: int32(name='StartTime'),
            channelId?: string(name='ChannelId'),
            text?: string(name='Text'),
            speechRate?: string(name='SpeechRate'),
          }
        ](name='AsrText')
        }(name='AsrTextList'),
      }(name='AsrResult'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryAsrJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAsrJobListResponseBody(name='body'),
}

async function queryAsrJobListWithOptions(request: QueryAsrJobListRequest, runtime: Util.RuntimeOptions): QueryAsrJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryAsrJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryAsrJobList(request: QueryAsrJobListRequest): QueryAsrJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAsrJobListWithOptions(request, runtime);
}

model QueryAsrPipelineListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pipelineIds?: string(name='PipelineIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryAsrPipelineListResponseBody = {
  requestId?: string(name='RequestId'),
  pipelineList?: {
    pipeline?: [ 
    {
      state?: string(name='State'),
      notifyConfig?: {
        queueName?: string(name='QueueName'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryAsrPipelineListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAsrPipelineListResponseBody(name='body'),
}

async function queryAsrPipelineListWithOptions(request: QueryAsrPipelineListRequest, runtime: Util.RuntimeOptions): QueryAsrPipelineListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryAsrPipelineList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryAsrPipelineList(request: QueryAsrPipelineListRequest): QueryAsrPipelineListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAsrPipelineListWithOptions(request, runtime);
}

model QueryAuthConfigRequest {
  ownerId?: string(name='OwnerId'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryAuthConfigResponseBody = {
  key2?: string(name='Key2'),
  key1?: string(name='Key1'),
  requestId?: string(name='RequestId'),
}

model QueryAuthConfigResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAuthConfigResponseBody(name='body'),
}

async function queryAuthConfigWithOptions(request: QueryAuthConfigRequest, runtime: Util.RuntimeOptions): QueryAuthConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryAuthConfig', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryAuthConfig(request: QueryAuthConfigRequest): QueryAuthConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAuthConfigWithOptions(request, runtime);
}

model QueryCensorJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryCensorJobListResponseBody = {
  requestId?: string(name='RequestId'),
  censorJobList?: {
    censorJob?: [ 
    {
      creationTime?: string(name='CreationTime'),
      state?: string(name='State'),
      censorTerrorismResult?: {
        terrorismTopList?: {
          top?: [ 
          {
            index?: string(name='Index'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
            object?: string(name='Object'),
            label?: string(name='Label'),
          }
        ](name='Top')
        }(name='TerrorismTopList'),
        suggestion?: string(name='Suggestion'),
        averageScore?: string(name='AverageScore'),
        terrorismCounterList?: {
          counter?: [ 
          {
            label?: string(name='Label'),
            count?: int32(name='Count'),
          }
        ](name='Counter')
        }(name='TerrorismCounterList'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
      }(name='CensorTerrorismResult'),
      imageCensorResults?: {
        imageCensorResult?: [ 
        {
          imageBucket?: string(name='ImageBucket'),
          result?: string(name='Result'),
          imageLocation?: string(name='ImageLocation'),
          imageObject?: string(name='ImageObject'),
        }
      ](name='ImageCensorResult')
      }(name='ImageCensorResults'),
      titleCensorResult?: string(name='TitleCensorResult'),
      message?: string(name='Message'),
      input?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      barrageCensorResult?: string(name='BarrageCensorResult'),
      descCensorResult?: string(name='DescCensorResult'),
      resultSaveObject?: string(name='ResultSaveObject'),
      censorConfig?: {
        interval?: string(name='Interval'),
        saveType?: string(name='SaveType'),
        outputFile?: {
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='OutputFile'),
        scenes?: string(name='Scenes'),
        bizType?: string(name='BizType'),
      }(name='CensorConfig'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      censorPornResult?: {
        pornCounterList?: {
          counter?: [ 
          {
            label?: string(name='Label'),
            count?: int32(name='Count'),
          }
        ](name='Counter')
        }(name='PornCounterList'),
        suggestion?: string(name='Suggestion'),
        averageScore?: string(name='AverageScore'),
        pornTopList?: {
          top?: [ 
          {
            index?: string(name='Index'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
            object?: string(name='Object'),
            label?: string(name='Label'),
          }
        ](name='Top')
        }(name='PornTopList'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
      }(name='CensorPornResult'),
      pipelineId?: string(name='PipelineId'),
      id?: string(name='Id'),
    }
  ](name='CensorJob')
  }(name='CensorJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryCensorJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryCensorJobListResponseBody(name='body'),
}

async function queryCensorJobListWithOptions(request: QueryCensorJobListRequest, runtime: Util.RuntimeOptions): QueryCensorJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryCensorJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryCensorJobList(request: QueryCensorJobListRequest): QueryCensorJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCensorJobListWithOptions(request, runtime);
}

model QueryCensorPipelineListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pipelineIds?: string(name='PipelineIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryCensorPipelineListResponseBody = {
  requestId?: string(name='RequestId'),
  pipelineList?: {
    pipeline?: [ 
    {
      state?: string(name='State'),
      notifyConfig?: {
        topic?: string(name='Topic'),
        queue?: string(name='Queue'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryCensorPipelineListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryCensorPipelineListResponseBody(name='body'),
}

async function queryCensorPipelineListWithOptions(request: QueryCensorPipelineListRequest, runtime: Util.RuntimeOptions): QueryCensorPipelineListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryCensorPipelineList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryCensorPipelineList(request: QueryCensorPipelineListRequest): QueryCensorPipelineListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCensorPipelineListWithOptions(request, runtime);
}

model QueryComplexJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryComplexJobListResponseBody = {
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
  jobList?: {
    job?: [ 
    {
      creationTime?: string(name='CreationTime'),
      percent?: long(name='Percent'),
      finishTime?: string(name='FinishTime'),
      state?: string(name='State'),
      transcodeOutput?: {
        video?: {
          bufsize?: string(name='Bufsize'),
          degrain?: string(name='Degrain'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          pixFmt?: string(name='PixFmt'),
          pad?: string(name='Pad'),
          codec?: string(name='Codec'),
          height?: string(name='Height'),
          qscale?: string(name='Qscale'),
          crop?: string(name='Crop'),
          bitrate?: string(name='Bitrate'),
          maxrate?: string(name='Maxrate'),
          maxFps?: string(name='MaxFps'),
          profile?: string(name='Profile'),
          crf?: string(name='Crf'),
          gop?: string(name='Gop'),
          width?: string(name='Width'),
          fps?: string(name='Fps'),
          preset?: string(name='Preset'),
          scanMode?: string(name='ScanMode'),
        }(name='Video'),
        transConfig?: {
          isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
          isCheckReso?: string(name='IsCheckReso'),
          transMode?: string(name='TransMode'),
          isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
          adjDarMethod?: string(name='AdjDarMethod'),
          duration?: string(name='Duration'),
          isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
          isCheckResoFail?: string(name='IsCheckResoFail'),
          isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
        }(name='TransConfig'),
        encryption?: {
          type?: string(name='Type'),
          key?: string(name='Key'),
          keyType?: string(name='KeyType'),
          id?: string(name='Id'),
          keyUri?: string(name='KeyUri'),
          skipCnt?: string(name='SkipCnt'),
        }(name='Encryption'),
        waterMarkList?: {
          waterMark?: [ 
          {
            type?: string(name='Type'),
            referPos?: string(name='ReferPos'),
            dx?: string(name='Dx'),
            width?: string(name='Width'),
            height?: string(name='Height'),
            inputFile?: {
              object?: string(name='Object'),
              location?: string(name='Location'),
              bucket?: string(name='Bucket'),
            }(name='InputFile'),
            waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
            dy?: string(name='Dy'),
          }
        ](name='WaterMark')
        }(name='WaterMarkList'),
        deWatermark?: string(name='DeWatermark'),
        waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
        m3U8NonStandardSupport?: {
          TS?: {
            sizeSupport?: boolean(name='SizeSupport'),
            md5Support?: boolean(name='Md5Support'),
          }(name='TS'),
        }(name='M3U8NonStandardSupport'),
        priority?: string(name='Priority'),
        audio?: {
          profile?: string(name='Profile'),
          codec?: string(name='Codec'),
          samplerate?: string(name='Samplerate'),
          qscale?: string(name='Qscale'),
          channels?: string(name='Channels'),
          volume?: {
            method?: string(name='Method'),
            level?: string(name='Level'),
          }(name='Volume'),
          bitrate?: string(name='Bitrate'),
        }(name='Audio'),
        audioStreamMap?: string(name='AudioStreamMap'),
        mergeList?: {
          merge?: [ 
          {
            start?: string(name='Start'),
            roleArn?: string(name='RoleArn'),
            mergeURL?: string(name='MergeURL'),
            duration?: string(name='Duration'),
          }
        ](name='Merge')
        }(name='MergeList'),
        superReso?: {
          isHalfSample?: string(name='IsHalfSample'),
        }(name='SuperReso'),
        userData?: string(name='UserData'),
        digiWaterMark?: {
          type?: string(name='Type'),
          alpha?: string(name='Alpha'),
          inputFile?: {
            object?: string(name='Object'),
            location?: string(name='Location'),
            bucket?: string(name='Bucket'),
          }(name='InputFile'),
        }(name='DigiWaterMark'),
        videoStreamMap?: string(name='VideoStreamMap'),
        outputFile?: {
          roleArn?: string(name='RoleArn'),
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='OutputFile'),
        rotate?: string(name='Rotate'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        clip?: {
          timeSpan?: {
            seek?: string(name='Seek'),
            duration?: string(name='Duration'),
          }(name='TimeSpan'),
        }(name='Clip'),
        mergeConfigUrl?: string(name='MergeConfigUrl'),
        muxConfig?: {
          gif?: {
            finalDelay?: string(name='FinalDelay'),
            ditherMode?: string(name='DitherMode'),
            loop?: string(name='Loop'),
            isCustomPalette?: string(name='IsCustomPalette'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
        }(name='MuxConfig'),
        templateId?: string(name='TemplateId'),
        subtitleConfig?: {
          extSubtitleList?: {
            extSubtitle?: [ 
            {
              charEnc?: string(name='CharEnc'),
              fontName?: string(name='FontName'),
              input?: {
                object?: string(name='Object'),
                location?: string(name='Location'),
                bucket?: string(name='Bucket'),
              }(name='Input'),
            }
          ](name='ExtSubtitle')
          }(name='ExtSubtitleList'),
          subtitleList?: {
            subtitle?: [ 
            {
              map?: string(name='Map'),
            }
          ](name='Subtitle')
          }(name='SubtitleList'),
        }(name='SubtitleConfig'),
        properties?: {
          width?: string(name='Width'),
          height?: string(name='Height'),
          duration?: string(name='Duration'),
          fps?: string(name='Fps'),
          bitrate?: string(name='Bitrate'),
          fileFormat?: string(name='FileFormat'),
          streams?: {
            videoStreamList?: {
              videoStream?: [ 
              {
                index?: string(name='Index'),
                timebase?: string(name='Timebase'),
                avgFPS?: string(name='AvgFPS'),
                pixFmt?: string(name='PixFmt'),
                sar?: string(name='Sar'),
                lang?: string(name='Lang'),
                codecLongName?: string(name='CodecLongName'),
                height?: string(name='Height'),
                numFrames?: string(name='NumFrames'),
                bitrate?: string(name='Bitrate'),
                codecTagString?: string(name='CodecTagString'),
                hasBFrames?: string(name='HasBFrames'),
                profile?: string(name='Profile'),
                startTime?: string(name='StartTime'),
                networkCost?: {
                  preloadTime?: string(name='PreloadTime'),
                  avgBitrate?: string(name='AvgBitrate'),
                  costBandwidth?: string(name='CostBandwidth'),
                }(name='NetworkCost'),
                dar?: string(name='Dar'),
                codecName?: string(name='CodecName'),
                width?: string(name='Width'),
                duration?: string(name='Duration'),
                fps?: string(name='Fps'),
                codecTag?: string(name='CodecTag'),
                codecTimeBase?: string(name='CodecTimeBase'),
                level?: string(name='Level'),
              }
            ](name='VideoStream')
            }(name='VideoStreamList'),
            audioStreamList?: {
              audioStream?: [ 
              {
                timebase?: string(name='Timebase'),
                index?: string(name='Index'),
                sampleFmt?: string(name='SampleFmt'),
                channelLayout?: string(name='ChannelLayout'),
                lang?: string(name='Lang'),
                samplerate?: string(name='Samplerate'),
                codecLongName?: string(name='CodecLongName'),
                channels?: string(name='Channels'),
                numFrames?: string(name='NumFrames'),
                bitrate?: string(name='Bitrate'),
                codecTagString?: string(name='CodecTagString'),
                startTime?: string(name='StartTime'),
                codecName?: string(name='CodecName'),
                duration?: string(name='Duration'),
                codecTag?: string(name='CodecTag'),
                codecTimeBase?: string(name='CodecTimeBase'),
              }
            ](name='AudioStream')
            }(name='AudioStreamList'),
            subtitleStreamList?: {
              subtitleStream?: [ 
              {
                index?: string(name='Index'),
                lang?: string(name='Lang'),
              }
            ](name='SubtitleStream')
            }(name='SubtitleStreamList'),
          }(name='Streams'),
          format?: {
            startTime?: string(name='StartTime'),
            numPrograms?: string(name='NumPrograms'),
            size?: string(name='Size'),
            numStreams?: string(name='NumStreams'),
            formatLongName?: string(name='FormatLongName'),
            duration?: string(name='Duration'),
            bitrate?: string(name='Bitrate'),
            formatName?: string(name='FormatName'),
          }(name='Format'),
          fileSize?: string(name='FileSize'),
        }(name='Properties'),
      }(name='transcodeOutput'),
      message?: string(name='Message'),
      MNSMessageResult?: {
        messageId?: string(name='MessageId'),
        errorMessage?: string(name='ErrorMessage'),
        errorCode?: string(name='ErrorCode'),
      }(name='MNSMessageResult'),
      complexEditingConfigs?: {
        complexEditingConfigs?: [ 
        {
          editing?: {
            timeline?: {
              trackList?: {
                track?: [ 
                {
                  type?: string(name='Type'),
                  order?: string(name='Order'),
                  id?: string(name='Id'),
                  clips?: {
                    clip?: [ 
                    {
                      clipsConfig?: {
                        clipsConfigVideo?: {
                          t?: string(name='T'),
                          l?: string(name='L'),
                        }(name='ClipsConfigVideo'),
                      }(name='ClipsConfig'),
                      out?: string(name='Out'),
                      in?: string(name='In'),
                      clipID?: string(name='clipID'),
                    }
                  ](name='Clip')
                  }(name='Clips'),
                }
              ](name='Track')
              }(name='TrackList'),
              timelineConfig?: {
                timelineConfigAudio?: {
                  channelLayout?: string(name='ChannelLayout'),
                  samplerate?: string(name='Samplerate'),
                  channels?: string(name='Channels'),
                }(name='TimelineConfigAudio'),
                timelineConfigVideo?: {
                  bgColor?: string(name='BgColor'),
                  width?: string(name='Width'),
                  renderRatio?: string(name='RenderRatio'),
                  isGpuData?: string(name='IsGpuData'),
                  height?: string(name='Height'),
                  isOneTrackData?: string(name='IsOneTrackData'),
                  fps?: string(name='Fps'),
                  reclosePrec?: string(name='ReclosePrec'),
                }(name='TimelineConfigVideo'),
              }(name='TimelineConfig'),
            }(name='Timeline'),
            clipList?: {
              clip?: [ 
              {
                type?: string(name='Type'),
                sourceID?: string(name='SourceID'),
                effects?: {
                  effect?: [ 
                  {
                    effect?: string(name='Effect'),
                    effectConfig?: string(name='EffectConfig'),
                  }
                ](name='Effect')
                }(name='Effects'),
                sourceType?: string(name='SourceType'),
                sourceStrmMap?: string(name='SourceStrmMap'),
                out?: string(name='Out'),
                in?: string(name='In'),
                id?: string(name='Id'),
              }
            ](name='Clip')
            }(name='ClipList'),
          }(name='Editing'),
        }
      ](name='ComplexEditingConfigs')
      }(name='ComplexEditingConfigs'),
      inputs?: {
        inputs?: [ 
        {
          editingInputs?: {
            editingInput?: [ 
            {
              inputFile?: {
                object?: string(name='Object'),
                location?: string(name='Location'),
                bucket?: string(name='Bucket'),
              }(name='InputFile'),
              inputConfig?: {
                isNormalSar?: string(name='IsNormalSar'),
                deinterlaceMethod?: string(name='DeinterlaceMethod'),
              }(name='InputConfig'),
              id?: string(name='Id'),
            }
          ](name='EditingInput')
          }(name='EditingInputs'),
        }
      ](name='Inputs')
      }(name='Inputs'),
      jobId?: string(name='JobId'),
      code?: string(name='Code'),
      pipelineId?: string(name='PipelineId'),
    }
  ](name='Job')
  }(name='JobList'),
}

model QueryComplexJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryComplexJobListResponseBody(name='body'),
}

async function queryComplexJobListWithOptions(request: QueryComplexJobListRequest, runtime: Util.RuntimeOptions): QueryComplexJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryComplexJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryComplexJobList(request: QueryComplexJobListRequest): QueryComplexJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryComplexJobListWithOptions(request, runtime);
}

model QueryCoverJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  coverJobIds?: string(name='CoverJobIds'),
  nextPageToken?: string(name='NextPageToken'),
  maximumPageSize?: long(name='MaximumPageSize'),
  state?: string(name='State'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange'),
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange'),
  pipelineId?: string(name='PipelineId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryCoverJobListResponseBody = {
  coverJobList?: {
    coverJob?: [ 
    {
      creationTime?: string(name='CreationTime'),
      state?: string(name='State'),
      coverImageList?: {
        coverImage?: [ 
        {
          time?: string(name='Time'),
          score?: string(name='Score'),
          url?: string(name='Url'),
        }
      ](name='CoverImage')
      }(name='CoverImageList'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      input?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      id?: string(name='Id'),
      coverConfig?: {
        outputFile?: {
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='OutputFile'),
      }(name='CoverConfig'),
    }
  ](name='CoverJob')
  }(name='CoverJobList'),
  requestId?: string(name='RequestId'),
  nextPageToken?: string(name='NextPageToken'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryCoverJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryCoverJobListResponseBody(name='body'),
}

async function queryCoverJobListWithOptions(request: QueryCoverJobListRequest, runtime: Util.RuntimeOptions): QueryCoverJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryCoverJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryCoverJobList(request: QueryCoverJobListRequest): QueryCoverJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCoverJobListWithOptions(request, runtime);
}

model QueryCoverPipelineListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pipelineIds?: string(name='PipelineIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryCoverPipelineListResponseBody = {
  requestId?: string(name='RequestId'),
  pipelineList?: {
    pipeline?: [ 
    {
      state?: string(name='State'),
      notifyConfig?: {
        topic?: string(name='Topic'),
        queue?: string(name='Queue'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      role?: string(name='Role'),
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryCoverPipelineListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryCoverPipelineListResponseBody(name='body'),
}

async function queryCoverPipelineListWithOptions(request: QueryCoverPipelineListRequest, runtime: Util.RuntimeOptions): QueryCoverPipelineListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryCoverPipelineList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryCoverPipelineList(request: QueryCoverPipelineListRequest): QueryCoverPipelineListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCoverPipelineListWithOptions(request, runtime);
}

model QueryEditingJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryEditingJobListResponseBody = {
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
  jobList?: {
    job?: [ 
    {
      creationTime?: string(name='CreationTime'),
      percent?: long(name='Percent'),
      finishTime?: string(name='FinishTime'),
      state?: string(name='State'),
      jobId?: string(name='JobId'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      editingInputs?: {
        editingInput?: [ 
        {
          inputFile?: {
            object?: string(name='Object'),
            location?: string(name='Location'),
            bucket?: string(name='Bucket'),
          }(name='InputFile'),
          inputConfig?: {
            isNormalSar?: string(name='IsNormalSar'),
            deinterlaceMethod?: string(name='DeinterlaceMethod'),
          }(name='InputConfig'),
          id?: string(name='Id'),
        }
      ](name='EditingInput')
      }(name='EditingInputs'),
      pipelineId?: string(name='PipelineId'),
      editingConfig?: {
        video?: {
          bufsize?: string(name='Bufsize'),
          degrain?: string(name='Degrain'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          pixFmt?: string(name='PixFmt'),
          pad?: string(name='Pad'),
          codec?: string(name='Codec'),
          height?: string(name='Height'),
          qscale?: string(name='Qscale'),
          crop?: string(name='Crop'),
          bitrate?: string(name='Bitrate'),
          maxrate?: string(name='Maxrate'),
          maxFps?: string(name='MaxFps'),
          profile?: string(name='Profile'),
          crf?: string(name='Crf'),
          gop?: string(name='Gop'),
          width?: string(name='Width'),
          fps?: string(name='Fps'),
          preset?: string(name='Preset'),
          scanMode?: string(name='ScanMode'),
        }(name='Video'),
        transConfig?: {
          isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
          isCheckReso?: string(name='IsCheckReso'),
          transMode?: string(name='TransMode'),
          isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
          adjDarMethod?: string(name='AdjDarMethod'),
          duration?: string(name='Duration'),
          isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
          isCheckResoFail?: string(name='IsCheckResoFail'),
          isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
        }(name='TransConfig'),
        encryption?: {
          type?: string(name='Type'),
          key?: string(name='Key'),
          keyType?: string(name='KeyType'),
          id?: string(name='Id'),
          keyUri?: string(name='KeyUri'),
          skipCnt?: string(name='SkipCnt'),
        }(name='Encryption'),
        waterMarkList?: {
          waterMark?: [ 
          {
            type?: string(name='Type'),
            referPos?: string(name='ReferPos'),
            dx?: string(name='Dx'),
            width?: string(name='Width'),
            height?: string(name='Height'),
            inputFile?: {
              object?: string(name='Object'),
              location?: string(name='Location'),
              bucket?: string(name='Bucket'),
            }(name='InputFile'),
            waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
            dy?: string(name='Dy'),
          }
        ](name='WaterMark')
        }(name='WaterMarkList'),
        deWatermark?: string(name='DeWatermark'),
        waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
        m3U8NonStandardSupport?: {
          TS?: {
            sizeSupport?: boolean(name='SizeSupport'),
            md5Support?: boolean(name='Md5Support'),
          }(name='TS'),
        }(name='M3U8NonStandardSupport'),
        priority?: string(name='Priority'),
        audio?: {
          profile?: string(name='Profile'),
          codec?: string(name='Codec'),
          samplerate?: string(name='Samplerate'),
          qscale?: string(name='Qscale'),
          channels?: string(name='Channels'),
          volume?: {
            method?: string(name='Method'),
            level?: string(name='Level'),
          }(name='Volume'),
          bitrate?: string(name='Bitrate'),
        }(name='Audio'),
        audioStreamMap?: string(name='AudioStreamMap'),
        mergeList?: {
          merge?: [ 
          {
            start?: string(name='Start'),
            roleArn?: string(name='RoleArn'),
            mergeURL?: string(name='MergeURL'),
            duration?: string(name='Duration'),
          }
        ](name='Merge')
        }(name='MergeList'),
        superReso?: {
          isHalfSample?: string(name='IsHalfSample'),
        }(name='SuperReso'),
        userData?: string(name='UserData'),
        digiWaterMark?: {
          type?: string(name='Type'),
          alpha?: string(name='Alpha'),
          inputFile?: {
            object?: string(name='Object'),
            location?: string(name='Location'),
            bucket?: string(name='Bucket'),
          }(name='InputFile'),
        }(name='DigiWaterMark'),
        videoStreamMap?: string(name='VideoStreamMap'),
        outputFile?: {
          roleArn?: string(name='RoleArn'),
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='OutputFile'),
        rotate?: string(name='Rotate'),
        editing?: {
          timeline?: {
            trackList?: {
              track?: [ 
              {
                type?: string(name='Type'),
                order?: string(name='Order'),
                id?: string(name='Id'),
                clips?: {
                  clip?: [ 
                  {
                    clipsConfig?: {
                      clipsConfigVideo?: {
                        t?: string(name='T'),
                        l?: string(name='L'),
                      }(name='ClipsConfigVideo'),
                    }(name='ClipsConfig'),
                    out?: string(name='Out'),
                    in?: string(name='In'),
                    clipID?: string(name='clipID'),
                  }
                ](name='Clip')
                }(name='Clips'),
              }
            ](name='Track')
            }(name='TrackList'),
            timelineConfig?: {
              timelineConfigAudio?: {
                channelLayout?: string(name='ChannelLayout'),
                samplerate?: string(name='Samplerate'),
                channels?: string(name='Channels'),
              }(name='TimelineConfigAudio'),
              timelineConfigVideo?: {
                bgColor?: string(name='BgColor'),
                width?: string(name='Width'),
                renderRatio?: string(name='RenderRatio'),
                isGpuData?: string(name='IsGpuData'),
                height?: string(name='Height'),
                isOneTrackData?: string(name='IsOneTrackData'),
                fps?: string(name='Fps'),
                reclosePrec?: string(name='ReclosePrec'),
              }(name='TimelineConfigVideo'),
            }(name='TimelineConfig'),
          }(name='Timeline'),
          clipList?: {
            clip?: [ 
            {
              type?: string(name='Type'),
              sourceID?: string(name='SourceID'),
              effects?: {
                effect?: [ 
                {
                  effect?: string(name='Effect'),
                  effectConfig?: string(name='EffectConfig'),
                }
              ](name='Effect')
              }(name='Effects'),
              sourceType?: string(name='SourceType'),
              sourceStrmMap?: string(name='SourceStrmMap'),
              out?: string(name='Out'),
              in?: string(name='In'),
              id?: string(name='Id'),
            }
          ](name='Clip')
          }(name='ClipList'),
        }(name='Editing'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        clip?: {
          timeSpan?: {
            seek?: string(name='Seek'),
            duration?: string(name='Duration'),
          }(name='TimeSpan'),
        }(name='Clip'),
        mergeConfigUrl?: string(name='MergeConfigUrl'),
        muxConfig?: {
          gif?: {
            finalDelay?: string(name='FinalDelay'),
            ditherMode?: string(name='DitherMode'),
            loop?: string(name='Loop'),
            isCustomPalette?: string(name='IsCustomPalette'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
        }(name='MuxConfig'),
        templateId?: string(name='TemplateId'),
        subtitleConfig?: {
          extSubtitleList?: {
            extSubtitle?: [ 
            {
              charEnc?: string(name='CharEnc'),
              fontName?: string(name='FontName'),
              input?: {
                object?: string(name='Object'),
                location?: string(name='Location'),
                bucket?: string(name='Bucket'),
              }(name='Input'),
            }
          ](name='ExtSubtitle')
          }(name='ExtSubtitleList'),
          subtitleList?: {
            subtitle?: [ 
            {
              map?: string(name='Map'),
            }
          ](name='Subtitle')
          }(name='SubtitleList'),
        }(name='SubtitleConfig'),
        properties?: {
          width?: string(name='Width'),
          height?: string(name='Height'),
          duration?: string(name='Duration'),
          fps?: string(name='Fps'),
          bitrate?: string(name='Bitrate'),
          fileFormat?: string(name='FileFormat'),
          streams?: {
            videoStreamList?: {
              videoStream?: [ 
              {
                index?: string(name='Index'),
                timebase?: string(name='Timebase'),
                avgFPS?: string(name='AvgFPS'),
                pixFmt?: string(name='PixFmt'),
                sar?: string(name='Sar'),
                lang?: string(name='Lang'),
                codecLongName?: string(name='CodecLongName'),
                height?: string(name='Height'),
                numFrames?: string(name='NumFrames'),
                bitrate?: string(name='Bitrate'),
                codecTagString?: string(name='CodecTagString'),
                hasBFrames?: string(name='HasBFrames'),
                profile?: string(name='Profile'),
                startTime?: string(name='StartTime'),
                networkCost?: {
                  preloadTime?: string(name='PreloadTime'),
                  avgBitrate?: string(name='AvgBitrate'),
                  costBandwidth?: string(name='CostBandwidth'),
                }(name='NetworkCost'),
                dar?: string(name='Dar'),
                codecName?: string(name='CodecName'),
                width?: string(name='Width'),
                duration?: string(name='Duration'),
                fps?: string(name='Fps'),
                codecTag?: string(name='CodecTag'),
                codecTimeBase?: string(name='CodecTimeBase'),
                level?: string(name='Level'),
              }
            ](name='VideoStream')
            }(name='VideoStreamList'),
            audioStreamList?: {
              audioStream?: [ 
              {
                timebase?: string(name='Timebase'),
                index?: string(name='Index'),
                sampleFmt?: string(name='SampleFmt'),
                channelLayout?: string(name='ChannelLayout'),
                lang?: string(name='Lang'),
                samplerate?: string(name='Samplerate'),
                codecLongName?: string(name='CodecLongName'),
                channels?: string(name='Channels'),
                numFrames?: string(name='NumFrames'),
                bitrate?: string(name='Bitrate'),
                codecTagString?: string(name='CodecTagString'),
                startTime?: string(name='StartTime'),
                codecName?: string(name='CodecName'),
                duration?: string(name='Duration'),
                codecTag?: string(name='CodecTag'),
                codecTimeBase?: string(name='CodecTimeBase'),
              }
            ](name='AudioStream')
            }(name='AudioStreamList'),
            subtitleStreamList?: {
              subtitleStream?: [ 
              {
                index?: string(name='Index'),
                lang?: string(name='Lang'),
              }
            ](name='SubtitleStream')
            }(name='SubtitleStreamList'),
          }(name='Streams'),
          format?: {
            startTime?: string(name='StartTime'),
            numPrograms?: string(name='NumPrograms'),
            size?: string(name='Size'),
            numStreams?: string(name='NumStreams'),
            formatLongName?: string(name='FormatLongName'),
            duration?: string(name='Duration'),
            bitrate?: string(name='Bitrate'),
            formatName?: string(name='FormatName'),
          }(name='Format'),
          fileSize?: string(name='FileSize'),
        }(name='Properties'),
      }(name='EditingConfig'),
      MNSMessageResult?: {
        messageId?: string(name='MessageId'),
        errorMessage?: string(name='ErrorMessage'),
        errorCode?: string(name='ErrorCode'),
      }(name='MNSMessageResult'),
    }
  ](name='Job')
  }(name='JobList'),
}

model QueryEditingJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryEditingJobListResponseBody(name='body'),
}

async function queryEditingJobListWithOptions(request: QueryEditingJobListRequest, runtime: Util.RuntimeOptions): QueryEditingJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryEditingJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryEditingJobList(request: QueryEditingJobListRequest): QueryEditingJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEditingJobListWithOptions(request, runtime);
}

model QueryFacerecogJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  facerecogJobIds?: string(name='FacerecogJobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryFacerecogJobListResponseBody = {
  requestId?: string(name='RequestId'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  facerecogJobList?: {
    facerecogJob?: [ 
    {
      creationTime?: string(name='CreationTime'),
      videoFacerecogResult?: {
        facerecogs?: {
          facerecog?: [ 
          {
            time?: string(name='Time'),
            faces?: {
              face?: [ 
              {
                score?: string(name='Score'),
                name?: string(name='Name'),
                target?: string(name='Target'),
              }
            ](name='Face')
            }(name='Faces'),
          }
        ](name='Facerecog')
        }(name='Facerecogs'),
      }(name='VideoFacerecogResult'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      input?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      id?: string(name='Id'),
    }
  ](name='FacerecogJob')
  }(name='FacerecogJobList'),
}

model QueryFacerecogJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFacerecogJobListResponseBody(name='body'),
}

async function queryFacerecogJobListWithOptions(request: QueryFacerecogJobListRequest, runtime: Util.RuntimeOptions): QueryFacerecogJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryFacerecogJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryFacerecogJobList(request: QueryFacerecogJobListRequest): QueryFacerecogJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFacerecogJobListWithOptions(request, runtime);
}

model QueryFpCompareJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryFpCompareJobListResponseBody = {
  fpCompareJobList?: {
    fpCompareJob?: [ 
    {
      masterFile?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='MasterFile'),
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      state?: string(name='State'),
      message?: string(name='Message'),
      queryFile?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='QueryFile'),
      fpDBId?: string(name='FpDBId'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      matchFrameStorage?: {
        masterMediaFrames?: {
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='MasterMediaFrames'),
        matchedFramesDescFile?: {
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='MatchedFramesDescFile'),
        queryMediaFrames?: {
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='QueryMediaFrames'),
      }(name='MatchFrameStorage'),
      pipelineId?: string(name='PipelineId'),
      id?: string(name='Id'),
      fpCompareResult?: {
        mediaMatchSegments?: {
          mediaMatchSegment?: [ 
          {
            queryStartTime?: string(name='QueryStartTime'),
            queryEndFrame?: string(name='QueryEndFrame'),
            score?: string(name='Score'),
            totalMatchFrameNum?: string(name='TotalMatchFrameNum'),
            masterEndTime?: string(name='MasterEndTime'),
            masterStartTime?: string(name='MasterStartTime'),
            queryStartFrame?: string(name='QueryStartFrame'),
            masterEndFrame?: string(name='MasterEndFrame'),
            masterStartFrame?: string(name='MasterStartFrame'),
            queryEndTime?: string(name='QueryEndTime'),
          }
        ](name='MediaMatchSegment')
        }(name='MediaMatchSegments'),
        queryMediaInfo?: {
          audioSampleRate?: string(name='AudioSampleRate'),
          audioBitRate?: string(name='AudioBitRate'),
          fpNum?: string(name='FpNum'),
          width?: string(name='Width'),
          height?: string(name='Height'),
          totalVideoFrame?: string(name='TotalVideoFrame'),
          fps?: string(name='Fps'),
          duration?: string(name='Duration'),
          audioChannels?: string(name='AudioChannels'),
        }(name='QueryMediaInfo'),
        masterMediaInfo?: {
          audioSampleRate?: string(name='AudioSampleRate'),
          audioBitRate?: string(name='AudioBitRate'),
          fpNum?: string(name='FpNum'),
          width?: string(name='Width'),
          height?: string(name='Height'),
          totalVideoFrame?: string(name='TotalVideoFrame'),
          fps?: string(name='Fps'),
          duration?: string(name='Duration'),
          audioChannels?: string(name='AudioChannels'),
        }(name='MasterMediaInfo'),
      }(name='FpCompareResult'),
    }
  ](name='FpCompareJob')
  }(name='FpCompareJobList'),
  requestId?: string(name='RequestId'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryFpCompareJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFpCompareJobListResponseBody(name='body'),
}

async function queryFpCompareJobListWithOptions(request: QueryFpCompareJobListRequest, runtime: Util.RuntimeOptions): QueryFpCompareJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryFpCompareJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryFpCompareJobList(request: QueryFpCompareJobListRequest): QueryFpCompareJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFpCompareJobListWithOptions(request, runtime);
}

model QueryFpDBDeleteJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryFpDBDeleteJobListResponseBody = {
  requestId?: string(name='RequestId'),
  fpDBDeleteJobList?: {
    fpDBDeleteJob?: [ 
    {
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      finishTime?: string(name='FinishTime'),
      delType?: string(name='DelType'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      fpDBId?: string(name='FpDBId'),
      id?: string(name='Id'),
    }
  ](name='FpDBDeleteJob')
  }(name='FpDBDeleteJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryFpDBDeleteJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFpDBDeleteJobListResponseBody(name='body'),
}

async function queryFpDBDeleteJobListWithOptions(request: QueryFpDBDeleteJobListRequest, runtime: Util.RuntimeOptions): QueryFpDBDeleteJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryFpDBDeleteJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryFpDBDeleteJobList(request: QueryFpDBDeleteJobListRequest): QueryFpDBDeleteJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFpDBDeleteJobListWithOptions(request, runtime);
}

model QueryFpFileDeleteJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryFpFileDeleteJobListResponseBody = {
  requestId?: string(name='RequestId'),
  fpFileDeleteJobList?: {
    fpFileDeleteJob?: [ 
    {
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      finishTime?: string(name='FinishTime'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      fpDBId?: string(name='FpDBId'),
      id?: string(name='Id'),
      fileIds?: string(name='FileIds'),
    }
  ](name='FpFileDeleteJob')
  }(name='FpFileDeleteJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryFpFileDeleteJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFpFileDeleteJobListResponseBody(name='body'),
}

async function queryFpFileDeleteJobListWithOptions(request: QueryFpFileDeleteJobListRequest, runtime: Util.RuntimeOptions): QueryFpFileDeleteJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryFpFileDeleteJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryFpFileDeleteJobList(request: QueryFpFileDeleteJobListRequest): QueryFpFileDeleteJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFpFileDeleteJobListWithOptions(request, runtime);
}

model QueryFpImportResultRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  pageSize?: long(name='PageSize'),
  pageIndex?: long(name='PageIndex'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryFpImportResultResponseBody = {
  pageInfo?: {
    pageIndex?: long(name='PageIndex'),
    pageSize?: long(name='PageSize'),
    total?: long(name='Total'),
  }(name='PageInfo'),
  fpResultLogInfoList?: {
    fpResultLogInfo?: [ 
    {
      logStartTime?: long(name='LogStartTime'),
      logPath?: string(name='LogPath'),
      createTime?: long(name='CreateTime'),
      logSize?: long(name='LogSize'),
      logName?: string(name='LogName'),
      logEndTime?: long(name='LogEndTime'),
    }
  ](name='FpResultLogInfo')
  }(name='FpResultLogInfoList'),
  requestId?: string(name='RequestId'),
  logCount?: long(name='LogCount'),
}

model QueryFpImportResultResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFpImportResultResponseBody(name='body'),
}

async function queryFpImportResultWithOptions(request: QueryFpImportResultRequest, runtime: Util.RuntimeOptions): QueryFpImportResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryFpImportResult', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryFpImportResult(request: QueryFpImportResultRequest): QueryFpImportResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFpImportResultWithOptions(request, runtime);
}

model QueryFpShotJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  nextPageToken?: string(name='NextPageToken'),
  maximumPageSize?: long(name='MaximumPageSize'),
  state?: string(name='State'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange'),
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange'),
  primaryKeyList?: string(name='PrimaryKeyList'),
  pipelineId?: string(name='PipelineId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryFpShotJobListResponseBody = {
  requestId?: string(name='RequestId'),
  nextPageToken?: string(name='NextPageToken'),
  nonExistPrimaryKeys?: {
    string?: [ string ](name='String')
  }(name='NonExistPrimaryKeys'),
  fpShotJobList?: {
    fpShotJob?: [ 
    {
      fpShotResult?: {
        audioFpShots?: {
          fpShot?: [ 
          {
            primaryKey?: string(name='PrimaryKey'),
            fpShotSlices?: {
              fpShotSlice?: [ 
              {
                duplication?: {
                  start?: string(name='Start'),
                  duration?: string(name='Duration'),
                }(name='Duplication'),
                similarity?: string(name='Similarity'),
                input?: {
                  start?: string(name='Start'),
                  duration?: string(name='Duration'),
                }(name='Input'),
              }
            ](name='FpShotSlice')
            }(name='FpShotSlices'),
            similarity?: string(name='Similarity'),
          }
        ](name='FpShot')
        }(name='AudioFpShots'),
        fpShots?: {
          fpShot?: [ 
          {
            primaryKey?: string(name='PrimaryKey'),
            fpShotSlices?: {
              fpShotSlice?: [ 
              {
                duplication?: {
                  start?: string(name='Start'),
                  duration?: string(name='Duration'),
                }(name='Duplication'),
                similarity?: string(name='Similarity'),
                input?: {
                  start?: string(name='Start'),
                  duration?: string(name='Duration'),
                }(name='Input'),
              }
            ](name='FpShotSlice')
            }(name='FpShotSlices'),
            similarity?: string(name='Similarity'),
          }
        ](name='FpShot')
        }(name='FpShots'),
      }(name='FpShotResult'),
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      state?: string(name='State'),
      message?: string(name='Message'),
      txHash?: string(name='TxHash'),
      transactionId?: string(name='TransactionId'),
      fpShotConfig?: {
        primaryKey?: string(name='PrimaryKey'),
        saveType?: string(name='SaveType'),
        notary?: string(name='Notary'),
        fpDBId?: string(name='FpDBId'),
      }(name='FpShotConfig'),
      fileId?: string(name='FileId'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      inputFile?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='InputFile'),
      pipelineId?: string(name='PipelineId'),
      id?: string(name='Id'),
    }
  ](name='FpShotJob')
  }(name='FpShotJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryFpShotJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFpShotJobListResponseBody(name='body'),
}

async function queryFpShotJobListWithOptions(request: QueryFpShotJobListRequest, runtime: Util.RuntimeOptions): QueryFpShotJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryFpShotJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryFpShotJobList(request: QueryFpShotJobListRequest): QueryFpShotJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFpShotJobListWithOptions(request, runtime);
}

model QueryImageSearchJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryImageSearchJobListResponseBody = {
  imageSearchJobList?: {
    imageSearchJob?: [ 
    {
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      result?: {
        imageSearchShots?: {
          imageSearchShots?: [ 
          {
            matchedFrame?: string(name='MatchedFrame'),
            matchedTimestamp?: string(name='MatchedTimestamp'),
            similarity?: string(name='Similarity'),
          }
        ](name='ImageSearchShots')
        }(name='ImageSearchShots'),
      }(name='Result'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      inputImage?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='inputImage'),
      id?: string(name='Id'),
      inputVideo?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='InputVideo'),
    }
  ](name='ImageSearchJob')
  }(name='ImageSearchJobList'),
  requestId?: string(name='RequestId'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryImageSearchJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryImageSearchJobListResponseBody(name='body'),
}

async function queryImageSearchJobListWithOptions(request: QueryImageSearchJobListRequest, runtime: Util.RuntimeOptions): QueryImageSearchJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryImageSearchJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryImageSearchJobList(request: QueryImageSearchJobListRequest): QueryImageSearchJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryImageSearchJobListWithOptions(request, runtime);
}

model QueryInnerJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobId?: string(name='JobId'),
}

model QueryInnerJobResponseBody = {
  status?: string(name='Status'),
  suggestion?: string(name='Suggestion'),
  requestId?: string(name='RequestId'),
  video?: {
    index?: int32(name='Index'),
    result?: int32(name='Result'),
    code?: string(name='Code'),
  }(name='Video'),
  image?: {
    result?: [ 
    {
      index?: int32(name='Index'),
      result?: int32(name='Result'),
      code?: string(name='Code'),
    }
  ](name='Result')
  }(name='Image'),
}

model QueryInnerJobResponse = {
  headers: map[string]string(name='headers'),
  body: QueryInnerJobResponseBody(name='body'),
}

async function queryInnerJobWithOptions(request: QueryInnerJobRequest, runtime: Util.RuntimeOptions): QueryInnerJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryInnerJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryInnerJob(request: QueryInnerJobRequest): QueryInnerJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryInnerJobWithOptions(request, runtime);
}

model QueryIProductionJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryIProductionJobResponseBody = {
  functionName?: string(name='FunctionName'),
  input?: string(name='Input'),
  requestId?: string(name='RequestId'),
  userData?: string(name='UserData'),
  state?: string(name='State'),
  output?: string(name='Output'),
  pipelineId?: string(name='PipelineId'),
  jobParams?: string(name='JobParams'),
  jobId?: string(name='JobId'),
  result?: string(name='Result'),
}

model QueryIProductionJobResponse = {
  headers: map[string]string(name='headers'),
  body: QueryIProductionJobResponseBody(name='body'),
}

async function queryIProductionJobWithOptions(request: QueryIProductionJobRequest, runtime: Util.RuntimeOptions): QueryIProductionJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryIProductionJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryIProductionJob(request: QueryIProductionJobRequest): QueryIProductionJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIProductionJobWithOptions(request, runtime);
}

model QueryIProductionJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  IProductionJobIds?: string(name='IProductionJobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryIProductionJobListResponseBody = {
  requestId?: string(name='RequestId'),
  jobs?: {
    string?: [ string ](name='String')
  }(name='Jobs'),
  nextPageToken?: string(name='NextPageToken'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryIProductionJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryIProductionJobListResponseBody(name='body'),
}

async function queryIProductionJobListWithOptions(request: QueryIProductionJobListRequest, runtime: Util.RuntimeOptions): QueryIProductionJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryIProductionJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryIProductionJobList(request: QueryIProductionJobListRequest): QueryIProductionJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIProductionJobListWithOptions(request, runtime);
}

model QueryJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryJobListResponseBody = {
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
  jobList?: {
    job?: [ 
    {
      creationTime?: string(name='CreationTime'),
      percent?: long(name='Percent'),
      finishTime?: string(name='FinishTime'),
      state?: string(name='State'),
      jobId?: string(name='JobId'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      output?: {
        video?: {
          bufsize?: string(name='Bufsize'),
          degrain?: string(name='Degrain'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          pixFmt?: string(name='PixFmt'),
          pad?: string(name='Pad'),
          codec?: string(name='Codec'),
          height?: string(name='Height'),
          qscale?: string(name='Qscale'),
          crop?: string(name='Crop'),
          bitrate?: string(name='Bitrate'),
          maxrate?: string(name='Maxrate'),
          maxFps?: string(name='MaxFps'),
          profile?: string(name='Profile'),
          crf?: string(name='Crf'),
          gop?: string(name='Gop'),
          width?: string(name='Width'),
          fps?: string(name='Fps'),
          preset?: string(name='Preset'),
          scanMode?: string(name='ScanMode'),
          resoPriority?: string(name='ResoPriority'),
        }(name='Video'),
        transConfig?: {
          isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
          transMode?: string(name='TransMode'),
          isCheckReso?: string(name='IsCheckReso'),
          isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
          adjDarMethod?: string(name='AdjDarMethod'),
          isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
          isCheckResoFail?: string(name='IsCheckResoFail'),
          isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
        }(name='TransConfig'),
        encryption?: {
          type?: string(name='Type'),
          key?: string(name='Key'),
          keyType?: string(name='KeyType'),
          id?: string(name='Id'),
          keyUri?: string(name='KeyUri'),
          skipCnt?: string(name='SkipCnt'),
        }(name='Encryption'),
        waterMarkList?: {
          waterMark?: [ 
          {
            type?: string(name='Type'),
            referPos?: string(name='ReferPos'),
            dx?: string(name='Dx'),
            width?: string(name='Width'),
            height?: string(name='Height'),
            inputFile?: {
              object?: string(name='Object'),
              location?: string(name='Location'),
              bucket?: string(name='Bucket'),
            }(name='InputFile'),
            waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
            dy?: string(name='Dy'),
          }
        ](name='WaterMark')
        }(name='WaterMarkList'),
        waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
        deWatermark?: string(name='DeWatermark'),
        m3U8NonStandardSupport?: {
          TS?: {
            sizeSupport?: boolean(name='SizeSupport'),
            md5Support?: boolean(name='Md5Support'),
          }(name='TS'),
        }(name='M3U8NonStandardSupport'),
        priority?: string(name='Priority'),
        audio?: {
          profile?: string(name='Profile'),
          codec?: string(name='Codec'),
          samplerate?: string(name='Samplerate'),
          qscale?: string(name='Qscale'),
          channels?: string(name='Channels'),
          volume?: {
            method?: string(name='Method'),
            level?: string(name='Level'),
          }(name='Volume'),
          bitrate?: string(name='Bitrate'),
        }(name='Audio'),
        audioStreamMap?: string(name='AudioStreamMap'),
        mergeList?: {
          merge?: [ 
          {
            start?: string(name='Start'),
            roleArn?: string(name='RoleArn'),
            mergeURL?: string(name='MergeURL'),
            duration?: string(name='Duration'),
          }
        ](name='Merge')
        }(name='MergeList'),
        superReso?: {
          isHalfSample?: string(name='IsHalfSample'),
        }(name='SuperReso'),
        userData?: string(name='UserData'),
        outSubtitleList?: {
          outSubtitle?: [ 
          {
            map?: string(name='Map'),
            outSubtitleFile?: {
              roleArn?: string(name='RoleArn'),
              object?: string(name='Object'),
              location?: string(name='Location'),
              bucket?: string(name='Bucket'),
            }(name='OutSubtitleFile'),
            success?: boolean(name='Success'),
            message?: string(name='Message'),
          }
        ](name='OutSubtitle')
        }(name='OutSubtitleList'),
        videoStreamMap?: string(name='VideoStreamMap'),
        outputFile?: {
          roleArn?: string(name='RoleArn'),
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='OutputFile'),
        rotate?: string(name='Rotate'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        clip?: {
          timeSpan?: {
            seek?: string(name='Seek'),
            duration?: string(name='Duration'),
          }(name='TimeSpan'),
        }(name='Clip'),
        mergeConfigUrl?: string(name='MergeConfigUrl'),
        openingList?: {
          opening?: [ 
          {
            openUrl?: string(name='openUrl'),
            start?: string(name='Start'),
            width?: string(name='Width'),
            height?: string(name='Height'),
          }
        ](name='Opening')
        }(name='OpeningList'),
        muxConfig?: {
          webp?: {
            loop?: string(name='Loop'),
          }(name='Webp'),
          gif?: {
            finalDelay?: string(name='FinalDelay'),
            ditherMode?: string(name='DitherMode'),
            loop?: string(name='Loop'),
            isCustomPalette?: string(name='IsCustomPalette'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
        }(name='MuxConfig'),
        tailSlateList?: {
          tailSlate?: [ 
          {
            start?: string(name='Start'),
            bgColor?: string(name='BgColor'),
            isMergeAudio?: boolean(name='IsMergeAudio'),
            width?: string(name='Width'),
            height?: string(name='Height'),
            blendDuration?: string(name='BlendDuration'),
            tailUrl?: string(name='TailUrl'),
          }
        ](name='TailSlate')
        }(name='TailSlateList'),
        templateId?: string(name='TemplateId'),
        subtitleConfig?: {
          extSubtitleList?: {
            extSubtitle?: [ 
            {
              charEnc?: string(name='CharEnc'),
              fontName?: string(name='FontName'),
              input?: {
                object?: string(name='Object'),
                location?: string(name='Location'),
                bucket?: string(name='Bucket'),
              }(name='Input'),
            }
          ](name='ExtSubtitle')
          }(name='ExtSubtitleList'),
          subtitleList?: {
            subtitle?: [ 
            {
              map?: string(name='Map'),
            }
          ](name='Subtitle')
          }(name='SubtitleList'),
        }(name='SubtitleConfig'),
        properties?: {
          width?: string(name='Width'),
          height?: string(name='Height'),
          sourceLogos?: {
            sourceLogo?: [ 
            {
              source?: string(name='Source'),
            }
          ](name='SourceLogo')
          }(name='SourceLogos'),
          duration?: string(name='Duration'),
          fps?: string(name='Fps'),
          bitrate?: string(name='Bitrate'),
          fileFormat?: string(name='FileFormat'),
          streams?: {
            videoStreamList?: {
              videoStream?: [ 
              {
                index?: string(name='Index'),
                timebase?: string(name='Timebase'),
                avgFPS?: string(name='AvgFPS'),
                pixFmt?: string(name='PixFmt'),
                sar?: string(name='Sar'),
                lang?: string(name='Lang'),
                codecLongName?: string(name='CodecLongName'),
                height?: string(name='Height'),
                numFrames?: string(name='NumFrames'),
                bitrate?: string(name='Bitrate'),
                codecTagString?: string(name='CodecTagString'),
                hasBFrames?: string(name='HasBFrames'),
                profile?: string(name='Profile'),
                startTime?: string(name='StartTime'),
                networkCost?: {
                  preloadTime?: string(name='PreloadTime'),
                  avgBitrate?: string(name='AvgBitrate'),
                  costBandwidth?: string(name='CostBandwidth'),
                }(name='NetworkCost'),
                dar?: string(name='Dar'),
                codecName?: string(name='CodecName'),
                width?: string(name='Width'),
                duration?: string(name='Duration'),
                fps?: string(name='Fps'),
                codecTag?: string(name='CodecTag'),
                codecTimeBase?: string(name='CodecTimeBase'),
                level?: string(name='Level'),
              }
            ](name='VideoStream')
            }(name='VideoStreamList'),
            audioStreamList?: {
              audioStream?: [ 
              {
                timebase?: string(name='Timebase'),
                index?: string(name='Index'),
                sampleFmt?: string(name='SampleFmt'),
                channelLayout?: string(name='ChannelLayout'),
                lang?: string(name='Lang'),
                samplerate?: string(name='Samplerate'),
                codecLongName?: string(name='CodecLongName'),
                channels?: string(name='Channels'),
                numFrames?: string(name='NumFrames'),
                bitrate?: string(name='Bitrate'),
                codecTagString?: string(name='CodecTagString'),
                startTime?: string(name='StartTime'),
                codecName?: string(name='CodecName'),
                duration?: string(name='Duration'),
                codecTag?: string(name='CodecTag'),
                codecTimeBase?: string(name='CodecTimeBase'),
              }
            ](name='AudioStream')
            }(name='AudioStreamList'),
            subtitleStreamList?: {
              subtitleStream?: [ 
              {
                index?: string(name='Index'),
                lang?: string(name='Lang'),
              }
            ](name='SubtitleStream')
            }(name='SubtitleStreamList'),
          }(name='Streams'),
          format?: {
            startTime?: string(name='StartTime'),
            numPrograms?: string(name='NumPrograms'),
            size?: string(name='Size'),
            numStreams?: string(name='NumStreams'),
            formatLongName?: string(name='FormatLongName'),
            duration?: string(name='Duration'),
            bitrate?: string(name='Bitrate'),
            formatName?: string(name='FormatName'),
          }(name='Format'),
          fileSize?: string(name='FileSize'),
        }(name='Properties'),
      }(name='Output'),
      pipelineId?: string(name='PipelineId'),
      input?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      MNSMessageResult?: {
        messageId?: string(name='MessageId'),
        errorMessage?: string(name='ErrorMessage'),
        errorCode?: string(name='ErrorCode'),
      }(name='MNSMessageResult'),
    }
  ](name='Job')
  }(name='JobList'),
}

model QueryJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryJobListResponseBody(name='body'),
}

async function queryJobListWithOptions(request: QueryJobListRequest, runtime: Util.RuntimeOptions): QueryJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryJobList(request: QueryJobListRequest): QueryJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryJobListWithOptions(request, runtime);
}

model QueryMCJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  nextPageToken?: string(name='NextPageToken'),
  maximumPageSize?: long(name='MaximumPageSize'),
  state?: string(name='State'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange'),
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange'),
  pipelineId?: string(name='PipelineId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryMCJobListResponseBody = {
  requestId?: string(name='RequestId'),
  nextPageToken?: string(name='NextPageToken'),
  jobList?: {
    job?: [ 
    {
      creationTime?: string(name='CreationTime'),
      resultOutputFile?: string(name='ResultOutputFile'),
      result?: {
        suggestion?: string(name='Suggestion'),
        pornResult?: {
          pornTexts?: {
            pornText?: [ 
            {
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
            }
          ](name='PornText')
          }(name='PornTexts'),
          pornVideos?: {
            pornVideo?: [ 
            {
              time?: string(name='Time'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              object?: string(name='Object'),
            }
          ](name='PornVideo')
          }(name='PornVideos'),
          pornAudios?: {
            pornAudio?: [ 
            {
              endTime?: string(name='EndTime'),
              startTime?: string(name='StartTime'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
              object?: string(name='Object'),
            }
          ](name='PornAudio')
          }(name='PornAudios'),
          pornImages?: {
            pornImage?: [ 
            {
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              url?: string(name='Url'),
              text?: string(name='Text'),
            }
          ](name='PornImage')
          }(name='PornImages'),
          pornOcrs?: {
            pornOcr?: [ 
            {
              time?: string(name='Time'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
              object?: string(name='Object'),
            }
          ](name='PornOcr')
          }(name='PornOcrs'),
        }(name='PornResult'),
        adResult?: {
          adOcrs?: {
            adOcr?: [ 
            {
              time?: string(name='Time'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
              object?: string(name='Object'),
            }
          ](name='AdOcr')
          }(name='AdOcrs'),
          adTexts?: {
            adText?: [ 
            {
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
            }
          ](name='AdText')
          }(name='AdTexts'),
          adImages?: {
            adImage?: [ 
            {
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              url?: string(name='Url'),
              text?: string(name='Text'),
            }
          ](name='AdImage')
          }(name='AdImages'),
          adAudios?: {
            adAudio?: [ 
            {
              endTime?: string(name='EndTime'),
              startTime?: string(name='StartTime'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
              object?: string(name='Object'),
            }
          ](name='AdAudio')
          }(name='AdAudios'),
          adVideos?: {
            adVideo?: [ 
            {
              time?: string(name='Time'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              object?: string(name='Object'),
            }
          ](name='AdVideo')
          }(name='AdVideos'),
        }(name='AdResult'),
        score?: string(name='Score'),
        logoResult?: {
          logoImages?: {
            logoImage?: [ 
            {
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              url?: string(name='Url'),
              text?: string(name='Text'),
            }
          ](name='LogoImage')
          }(name='LogoImages'),
          logoVideos?: {
            logoVideo?: [ 
            {
              time?: string(name='Time'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              object?: string(name='Object'),
            }
          ](name='LogoVideo')
          }(name='LogoVideos'),
        }(name='LogoResult'),
        qrcodeResult?: {
          qrcodeImages?: {
            qrcodeImage?: [ 
            {
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              url?: string(name='Url'),
              text?: string(name='Text'),
            }
          ](name='QrcodeImage')
          }(name='QrcodeImages'),
          qrcodeVideos?: {
            qrcodeVideo?: [ 
            {
              time?: string(name='Time'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              object?: string(name='Object'),
            }
          ](name='QrcodeVideo')
          }(name='QrcodeVideos'),
        }(name='QrcodeResult'),
        politicsResult?: {
          politicsOcrs?: {
            politicsOcr?: [ 
            {
              time?: string(name='Time'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
              object?: string(name='Object'),
            }
          ](name='PoliticsOcr')
          }(name='PoliticsOcrs'),
          politicsVideos?: {
            politicsVideo?: [ 
            {
              time?: string(name='Time'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              object?: string(name='Object'),
            }
          ](name='PoliticsVideo')
          }(name='PoliticsVideos'),
          politicsImages?: {
            politicsImage?: [ 
            {
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              url?: string(name='Url'),
              text?: string(name='Text'),
            }
          ](name='PoliticsImage')
          }(name='PoliticsImages'),
          politicsTexts?: {
            politicsText?: [ 
            {
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
            }
          ](name='PoliticsText')
          }(name='PoliticsTexts'),
          politicsAudios?: {
            politicsAudio?: [ 
            {
              endTime?: string(name='EndTime'),
              startTime?: string(name='StartTime'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
              object?: string(name='Object'),
            }
          ](name='PoliticsAudio')
          }(name='PoliticsAudios'),
        }(name='PoliticsResult'),
        liveResult?: {
          liveImages?: {
            liveImage?: [ 
            {
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              url?: string(name='Url'),
              text?: string(name='Text'),
            }
          ](name='LiveImage')
          }(name='LiveImages'),
          liveVideos?: {
            liveVideo?: [ 
            {
              time?: string(name='Time'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              object?: string(name='Object'),
            }
          ](name='LiveVideo')
          }(name='LiveVideos'),
        }(name='LiveResult'),
        abuseResult?: {
          abuseOcrs?: {
            abuseOcr?: [ 
            {
              time?: string(name='Time'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
              object?: string(name='Object'),
            }
          ](name='AbuseOcr')
          }(name='AbuseOcrs'),
          abuseAudios?: {
            abuseAudio?: [ 
            {
              endTime?: string(name='EndTime'),
              startTime?: string(name='StartTime'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
              object?: string(name='Object'),
            }
          ](name='AbuseAudio')
          }(name='AbuseAudios'),
          abuseTexts?: {
            abuseText?: [ 
            {
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
            }
          ](name='AbuseText')
          }(name='AbuseTexts'),
        }(name='AbuseResult'),
        spamResult?: {
          spamTexts?: {
            spamText?: [ 
            {
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
            }
          ](name='SpamText')
          }(name='SpamTexts'),
          spamAudios?: {
            spamAudio?: [ 
            {
              endTime?: string(name='EndTime'),
              startTime?: string(name='StartTime'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
              object?: string(name='Object'),
            }
          ](name='SpamAudio')
          }(name='SpamAudios'),
          spamOcrs?: {
            spamOcr?: [ 
            {
              time?: string(name='Time'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
              object?: string(name='Object'),
            }
          ](name='SpamOcr')
          }(name='SpamOcrs'),
        }(name='SpamResult'),
        contrabandResult?: {
          contrabandAudios?: {
            contrabandAudio?: [ 
            {
              endTime?: string(name='EndTime'),
              startTime?: string(name='StartTime'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
              object?: string(name='Object'),
            }
          ](name='ContrabandAudio')
          }(name='ContrabandAudios'),
          contrabandOcrs?: {
            contrabandOcr?: [ 
            {
              time?: string(name='Time'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
              object?: string(name='Object'),
            }
          ](name='ContrabandOcr')
          }(name='ContrabandOcrs'),
          contrabandTexts?: {
            contrabandText?: [ 
            {
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
            }
          ](name='ContrabandText')
          }(name='ContrabandTexts'),
        }(name='ContrabandResult'),
        terrorismResult?: {
          terrorismOcrs?: {
            terrorismOcr?: [ 
            {
              time?: string(name='Time'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
              object?: string(name='Object'),
            }
          ](name='TerrorismOcr')
          }(name='TerrorismOcrs'),
          terrorismAudios?: {
            terrorismAudio?: [ 
            {
              endTime?: string(name='EndTime'),
              startTime?: string(name='StartTime'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
              object?: string(name='Object'),
            }
          ](name='TerrorismAudio')
          }(name='TerrorismAudios'),
          terrorismVideos?: {
            terrorismVideo?: [ 
            {
              time?: string(name='Time'),
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              object?: string(name='Object'),
            }
          ](name='TerrorismVideo')
          }(name='TerrorismVideos'),
          terrorismTexts?: {
            terrorismText?: [ 
            {
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              text?: string(name='Text'),
            }
          ](name='TerrorismText')
          }(name='TerrorismTexts'),
          terrorismImages?: {
            terrorismImage?: [ 
            {
              suggestion?: string(name='Suggestion'),
              score?: string(name='Score'),
              url?: string(name='Url'),
              text?: string(name='Text'),
            }
          ](name='TerrorismImage')
          }(name='TerrorismImages'),
        }(name='TerrorismResult'),
      }(name='Result'),
      state?: string(name='State'),
      jobId?: string(name='JobId'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryMCJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMCJobListResponseBody(name='body'),
}

async function queryMCJobListWithOptions(request: QueryMCJobListRequest, runtime: Util.RuntimeOptions): QueryMCJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMCJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMCJobList(request: QueryMCJobListRequest): QueryMCJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMCJobListWithOptions(request, runtime);
}

model QueryMCTemplateListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateIds?: string(name='TemplateIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryMCTemplateListResponseBody = {
  nonExistTids?: {
    string?: [ string ](name='String')
  }(name='NonExistTids'),
  templateList?: {
    template?: [ 
    {
      logo?: string(name='Logo'),
      abuse?: string(name='Abuse'),
      state?: string(name='State'),
      terrorism?: string(name='Terrorism'),
      politics?: string(name='Politics'),
      qrcode?: string(name='Qrcode'),
      live?: string(name='Live'),
      spam?: string(name='Spam'),
      contraband?: string(name='Contraband'),
      ad?: string(name='Ad'),
      porn?: string(name='Porn'),
      name?: string(name='Name'),
      templateId?: string(name='TemplateId'),
    }
  ](name='Template')
  }(name='TemplateList'),
  requestId?: string(name='RequestId'),
}

model QueryMCTemplateListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMCTemplateListResponseBody(name='body'),
}

async function queryMCTemplateListWithOptions(request: QueryMCTemplateListRequest, runtime: Util.RuntimeOptions): QueryMCTemplateListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMCTemplateList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMCTemplateList(request: QueryMCTemplateListRequest): QueryMCTemplateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMCTemplateListWithOptions(request, runtime);
}

model QueryMcuJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  jobIds?: string(name='JobIds'),
}

model QueryMcuJobResponseBody = {
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
  jobResult?: {
    job?: [ 
    {
      tagResult?: {
        tag?: [ 
        {
          time?: string(name='Time'),
          imageUrl?: string(name='ImageUrl'),
          frameTagInfos?: {
            frameTagInfo?: [ 
            {
              score?: string(name='Score'),
              category?: string(name='Category'),
              tag?: string(name='Tag'),
            }
          ](name='FrameTagInfo')
          }(name='FrameTagInfos'),
          imageId?: string(name='ImageId'),
        }
      ](name='Tag')
      }(name='TagResult'),
      jobId?: string(name='JobId'),
      ocrResult?: {
        ocr?: [ 
        {
          time?: string(name='Time'),
          imageUrl?: string(name='ImageUrl'),
          ocrText?: string(name='OcrText'),
          imageId?: string(name='ImageId'),
        }
      ](name='Ocr')
      }(name='OcrResult'),
      template?: string(name='Template'),
      userData?: string(name='UserData'),
      subTaskInfo?: {
        subTask?: [ 
        {
          type?: string(name='Type'),
          code?: string(name='Code'),
          message?: string(name='Message'),
        }
      ](name='SubTask')
      }(name='SubTaskInfo'),
      categoryResult?: {
        categories?: {
          category?: [ 
          {
            score?: string(name='Score'),
            label?: string(name='Label'),
          }
        ](name='Category')
        }(name='Categories'),
        details?: string(name='Details'),
      }(name='CategoryResult'),
      faceResult?: {
        face?: [ 
        {
          time?: string(name='Time'),
          imageUrl?: string(name='ImageUrl'),
          celebrities?: {
            celebrity?: [ 
            {
              score?: string(name='Score'),
              name?: string(name='Name'),
              target?: string(name='Target'),
            }
          ](name='Celebrity')
          }(name='Celebrities'),
          imageId?: string(name='ImageId'),
        }
      ](name='Face')
      }(name='FaceResult'),
      templateId?: string(name='TemplateId'),
      input?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      asrResult?: {
        duration?: string(name='Duration'),
        asrTextList?: {
          asrText?: [ 
          {
            endTime?: string(name='EndTime'),
            startTime?: int32(name='StartTime'),
            channelId?: string(name='ChannelId'),
            text?: string(name='Text'),
            speechRate?: string(name='SpeechRate'),
          }
        ](name='AsrText')
        }(name='AsrTextList'),
      }(name='AsrResult'),
    }
  ](name='Job')
  }(name='JobResult'),
}

model QueryMcuJobResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMcuJobResponseBody(name='body'),
}

async function queryMcuJobWithOptions(request: QueryMcuJobRequest, runtime: Util.RuntimeOptions): QueryMcuJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMcuJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMcuJob(request: QueryMcuJobRequest): QueryMcuJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMcuJobWithOptions(request, runtime);
}

model QueryMcuTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  templateId?: string(name='TemplateId'),
}

model QueryMcuTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templates?: {
    job?: [ 
    {
      template?: string(name='Template'),
      templateId?: string(name='TemplateId'),
    }
  ](name='Job')
  }(name='Templates'),
}

model QueryMcuTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMcuTemplateResponseBody(name='body'),
}

async function queryMcuTemplateWithOptions(request: QueryMcuTemplateRequest, runtime: Util.RuntimeOptions): QueryMcuTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMcuTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMcuTemplate(request: QueryMcuTemplateRequest): QueryMcuTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMcuTemplateWithOptions(request, runtime);
}

model QueryMediaCensorJobDetailRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  nextPageToken?: string(name='NextPageToken'),
  maximumPageSize?: long(name='MaximumPageSize'),
}

model QueryMediaCensorJobDetailResponseBody = {
  requestId?: string(name='RequestId'),
  mediaCensorJobDetail?: {
    creationTime?: string(name='CreationTime'),
    finishTime?: string(name='FinishTime'),
    suggestion?: string(name='Suggestion'),
    coverImageCensorResults?: {
      coverImageCensorResult?: [ 
      {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
        results?: {
          result?: [ 
          {
            suggestion?: string(name='Suggestion'),
            label?: string(name='Label'),
            scene?: string(name='Scene'),
            rate?: string(name='Rate'),
          }
        ](name='Result')
        }(name='Results'),
      }
    ](name='CoverImageCensorResult')
    }(name='CoverImageCensorResults'),
    state?: string(name='State'),
    titleCensorResult?: {
      suggestion?: string(name='Suggestion'),
      label?: string(name='Label'),
      scene?: string(name='Scene'),
      rate?: string(name='Rate'),
    }(name='TitleCensorResult'),
    message?: string(name='Message'),
    input?: {
      object?: string(name='Object'),
      location?: string(name='Location'),
      bucket?: string(name='Bucket'),
    }(name='Input'),
    barrageCensorResult?: {
      suggestion?: string(name='Suggestion'),
      label?: string(name='Label'),
      scene?: string(name='Scene'),
      rate?: string(name='Rate'),
    }(name='BarrageCensorResult'),
    descCensorResult?: {
      suggestion?: string(name='Suggestion'),
      label?: string(name='Label'),
      scene?: string(name='Scene'),
      rate?: string(name='Rate'),
    }(name='DescCensorResult'),
    videoCensorConfig?: {
      outputFile?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='OutputFile'),
      videoCensor?: string(name='VideoCensor'),
      bizType?: string(name='BizType'),
    }(name='VideoCensorConfig'),
    jobId?: string(name='JobId'),
    userData?: string(name='UserData'),
    code?: string(name='Code'),
    vensorCensorResult?: {
      videoTimelines?: {
        videoTimeline?: [ 
        {
          timestamp?: string(name='Timestamp'),
          object?: string(name='Object'),
          censorResults?: {
            censorResult?: [ 
            {
              suggestion?: string(name='Suggestion'),
              label?: string(name='Label'),
              scene?: string(name='Scene'),
              rate?: string(name='Rate'),
            }
          ](name='CensorResult')
          }(name='CensorResults'),
        }
      ](name='VideoTimeline')
      }(name='VideoTimelines'),
      nextPageToken?: string(name='NextPageToken'),
      censorResults?: {
        censorResult?: [ 
        {
          suggestion?: string(name='Suggestion'),
          label?: string(name='Label'),
          scene?: string(name='Scene'),
          rate?: string(name='Rate'),
        }
      ](name='CensorResult')
      }(name='CensorResults'),
    }(name='VensorCensorResult'),
    pipelineId?: string(name='PipelineId'),
  }(name='MediaCensorJobDetail'),
}

model QueryMediaCensorJobDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaCensorJobDetailResponseBody(name='body'),
}

async function queryMediaCensorJobDetailWithOptions(request: QueryMediaCensorJobDetailRequest, runtime: Util.RuntimeOptions): QueryMediaCensorJobDetailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMediaCensorJobDetail', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMediaCensorJobDetail(request: QueryMediaCensorJobDetailRequest): QueryMediaCensorJobDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaCensorJobDetailWithOptions(request, runtime);
}

model QueryMediaCensorJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  nextPageToken?: string(name='NextPageToken'),
  maximumPageSize?: long(name='MaximumPageSize'),
  state?: string(name='State'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange'),
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange'),
  pipelineId?: string(name='PipelineId'),
}

model QueryMediaCensorJobListResponseBody = {
  mediaCensorJobList?: {
    mediaCensorJob?: [ 
    {
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      suggestion?: string(name='Suggestion'),
      coverImageCensorResults?: {
        coverImageCensorResult?: [ 
        {
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
          results?: {
            result?: [ 
            {
              suggestion?: string(name='Suggestion'),
              label?: string(name='Label'),
              scene?: string(name='Scene'),
              rate?: string(name='Rate'),
            }
          ](name='Result')
          }(name='Results'),
        }
      ](name='CoverImageCensorResult')
      }(name='CoverImageCensorResults'),
      state?: string(name='State'),
      titleCensorResult?: {
        suggestion?: string(name='Suggestion'),
        label?: string(name='Label'),
        scene?: string(name='Scene'),
        rate?: string(name='Rate'),
      }(name='TitleCensorResult'),
      message?: string(name='Message'),
      input?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      barrageCensorResult?: {
        suggestion?: string(name='Suggestion'),
        label?: string(name='Label'),
        scene?: string(name='Scene'),
        rate?: string(name='Rate'),
      }(name='BarrageCensorResult'),
      descCensorResult?: {
        suggestion?: string(name='Suggestion'),
        label?: string(name='Label'),
        scene?: string(name='Scene'),
        rate?: string(name='Rate'),
      }(name='DescCensorResult'),
      videoCensorConfig?: {
        outputFile?: {
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='OutputFile'),
        videoCensor?: string(name='VideoCensor'),
        bizType?: string(name='BizType'),
      }(name='VideoCensorConfig'),
      jobId?: string(name='JobId'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      vensorCensorResult?: {
        videoTimelines?: {
          videoTimeline?: [ 
          {
            timestamp?: string(name='Timestamp'),
            object?: string(name='Object'),
            censorResults?: {
              censorResult?: [ 
              {
                suggestion?: string(name='Suggestion'),
                label?: string(name='Label'),
                scene?: string(name='Scene'),
                rate?: string(name='Rate'),
              }
            ](name='CensorResult')
            }(name='CensorResults'),
          }
        ](name='VideoTimeline')
        }(name='VideoTimelines'),
        nextPageToken?: string(name='NextPageToken'),
        censorResults?: {
          censorResult?: [ 
          {
            suggestion?: string(name='Suggestion'),
            label?: string(name='Label'),
            scene?: string(name='Scene'),
            rate?: string(name='Rate'),
          }
        ](name='CensorResult')
        }(name='CensorResults'),
      }(name='VensorCensorResult'),
      pipelineId?: string(name='PipelineId'),
    }
  ](name='MediaCensorJob')
  }(name='MediaCensorJobList'),
  requestId?: string(name='RequestId'),
  nextPageToken?: string(name='NextPageToken'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryMediaCensorJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaCensorJobListResponseBody(name='body'),
}

async function queryMediaCensorJobListWithOptions(request: QueryMediaCensorJobListRequest, runtime: Util.RuntimeOptions): QueryMediaCensorJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMediaCensorJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMediaCensorJobList(request: QueryMediaCensorJobListRequest): QueryMediaCensorJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaCensorJobListWithOptions(request, runtime);
}

model QueryMediaDetailJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryMediaDetailJobListResponseBody = {
  requestId?: string(name='RequestId'),
  jobList?: {
    job?: [ 
    {
      creationTime?: string(name='CreationTime'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      mediaDetailResult?: {
        status?: string(name='Status'),
        mediaDetailRecgResults?: {
          mediaDetailRecgResult?: [ 
          {
            time?: string(name='Time'),
            sensitives?: {
              sensitive?: [ 
              {
                score?: string(name='Score'),
                name?: string(name='Name'),
                target?: string(name='Target'),
              }
            ](name='Sensitive')
            }(name='Sensitives'),
            politicians?: {
              politician?: [ 
              {
                score?: string(name='Score'),
                name?: string(name='Name'),
                target?: string(name='Target'),
              }
            ](name='Politician')
            }(name='Politicians'),
            frameTags?: {
              string?: [ string ](name='String')
            }(name='FrameTags'),
            imageUrl?: string(name='ImageUrl'),
            customs?: {
              custom?: [ 
              {
                name?: string(name='Name'),
                clips?: {
                  clip?: [ 
                  {
                    endTime?: string(name='EndTime'),
                    minScore?: string(name='MinScore'),
                    startTime?: string(name='StartTime'),
                    avgScore?: string(name='AvgScore'),
                    maxScore?: string(name='MaxScore'),
                    endTarget?: string(name='EndTarget'),
                    startTarget?: string(name='StartTarget'),
                  }
                ](name='Clip')
                }(name='Clips'),
              }
            ](name='Custom')
            }(name='Customs'),
            frameTagInfos?: {
              frameTagInfo?: [ 
              {
                score?: string(name='Score'),
                category?: string(name='Category'),
                tag?: string(name='Tag'),
              }
            ](name='FrameTagInfo')
            }(name='FrameTagInfos'),
            celebrities?: {
              celebrity?: [ 
              {
                score?: string(name='Score'),
                name?: string(name='Name'),
                target?: string(name='Target'),
              }
            ](name='Celebrity')
            }(name='Celebrities'),
            ocrText?: string(name='OcrText'),
          }
        ](name='MediaDetailRecgResult')
        }(name='MediaDetailRecgResults'),
        tags?: {
          string?: [ string ](name='String')
        }(name='Tags'),
      }(name='MediaDetailResult'),
      message?: string(name='Message'),
      mediaDetailConfig?: {
        outputFile?: {
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='OutputFile'),
        scenario?: string(name='Scenario'),
        detailType?: string(name='DetailType'),
      }(name='MediaDetailConfig'),
      pipelineId?: string(name='PipelineId'),
      input?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      id?: string(name='Id'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryMediaDetailJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaDetailJobListResponseBody(name='body'),
}

async function queryMediaDetailJobListWithOptions(request: QueryMediaDetailJobListRequest, runtime: Util.RuntimeOptions): QueryMediaDetailJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMediaDetailJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMediaDetailJobList(request: QueryMediaDetailJobListRequest): QueryMediaDetailJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaDetailJobListWithOptions(request, runtime);
}

model QueryMediaFpDeleteJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryMediaFpDeleteJobListResponseBody = {
  requestId?: string(name='RequestId'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  mediaFpDeleteJobList?: {
    mediaFpDeleteJob?: [ 
    {
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      primaryKey?: string(name='PrimaryKey'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      fpDBId?: string(name='FpDBId'),
      id?: string(name='Id'),
    }
  ](name='MediaFpDeleteJob')
  }(name='MediaFpDeleteJobList'),
}

model QueryMediaFpDeleteJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaFpDeleteJobListResponseBody(name='body'),
}

async function queryMediaFpDeleteJobListWithOptions(request: QueryMediaFpDeleteJobListRequest, runtime: Util.RuntimeOptions): QueryMediaFpDeleteJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMediaFpDeleteJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMediaFpDeleteJobList(request: QueryMediaFpDeleteJobListRequest): QueryMediaFpDeleteJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaFpDeleteJobListWithOptions(request, runtime);
}

model QueryMediaInfoJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  mediaInfoJobIds?: string(name='MediaInfoJobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryMediaInfoJobListResponseBody = {
  nonExistMediaInfoJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistMediaInfoJobIds'),
  requestId?: string(name='RequestId'),
  mediaInfoJobList?: {
    mediaInfoJob?: [ 
    {
      creationTime?: string(name='CreationTime'),
      state?: string(name='State'),
      jobId?: string(name='JobId'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      async?: boolean(name='Async'),
      input?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      MNSMessageResult?: {
        messageId?: string(name='MessageId'),
        errorMessage?: string(name='ErrorMessage'),
        errorCode?: string(name='ErrorCode'),
      }(name='MNSMessageResult'),
      properties?: {
        width?: string(name='Width'),
        height?: string(name='Height'),
        duration?: string(name='Duration'),
        fps?: string(name='Fps'),
        bitrate?: string(name='Bitrate'),
        fileFormat?: string(name='FileFormat'),
        streams?: {
          videoStreamList?: {
            videoStream?: [ 
            {
              sar?: string(name='Sar'),
              height?: string(name='Height'),
              codecTagString?: string(name='CodecTagString'),
              networkCost?: {
                preloadTime?: string(name='PreloadTime'),
                avgBitrate?: string(name='AvgBitrate'),
                costBandwidth?: string(name='CostBandwidth'),
              }(name='NetworkCost'),
              width?: string(name='Width'),
              index?: string(name='Index'),
              timebase?: string(name='Timebase'),
              avgFPS?: string(name='AvgFPS'),
              pixFmt?: string(name='PixFmt'),
              lang?: string(name='Lang'),
              codecLongName?: string(name='CodecLongName'),
              numFrames?: string(name='NumFrames'),
              rotate?: string(name='Rotate'),
              bitrate?: string(name='Bitrate'),
              hasBFrames?: string(name='HasBFrames'),
              profile?: string(name='Profile'),
              startTime?: string(name='StartTime'),
              dar?: string(name='Dar'),
              codecName?: string(name='CodecName'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              codecTag?: string(name='CodecTag'),
              codecTimeBase?: string(name='CodecTimeBase'),
              level?: string(name='Level'),
            }
          ](name='VideoStream')
          }(name='VideoStreamList'),
          audioStreamList?: {
            audioStream?: [ 
            {
              timebase?: string(name='Timebase'),
              index?: string(name='Index'),
              sampleFmt?: string(name='SampleFmt'),
              channelLayout?: string(name='ChannelLayout'),
              lang?: string(name='Lang'),
              samplerate?: string(name='Samplerate'),
              codecLongName?: string(name='CodecLongName'),
              channels?: string(name='Channels'),
              numFrames?: string(name='NumFrames'),
              bitrate?: string(name='Bitrate'),
              codecTagString?: string(name='CodecTagString'),
              startTime?: string(name='StartTime'),
              codecName?: string(name='CodecName'),
              duration?: string(name='Duration'),
              codecTag?: string(name='CodecTag'),
              codecTimeBase?: string(name='CodecTimeBase'),
            }
          ](name='AudioStream')
          }(name='AudioStreamList'),
          subtitleStreamList?: {
            subtitleStream?: [ 
            {
              timebase?: string(name='Timebase'),
              index?: string(name='Index'),
              startTime?: string(name='StartTime'),
              codecName?: string(name='CodecName'),
              lang?: string(name='Lang'),
              codecLongName?: string(name='CodecLongName'),
              duration?: string(name='Duration'),
              codecTag?: string(name='CodecTag'),
              codecTimeBase?: string(name='CodecTimeBase'),
              codecTagString?: string(name='CodecTagString'),
            }
          ](name='SubtitleStream')
          }(name='SubtitleStreamList'),
        }(name='Streams'),
        format?: {
          startTime?: string(name='StartTime'),
          numPrograms?: string(name='NumPrograms'),
          size?: string(name='Size'),
          numStreams?: string(name='NumStreams'),
          formatLongName?: string(name='FormatLongName'),
          duration?: string(name='Duration'),
          bitrate?: string(name='Bitrate'),
          formatName?: string(name='FormatName'),
        }(name='Format'),
        fileSize?: string(name='FileSize'),
      }(name='Properties'),
    }
  ](name='MediaInfoJob')
  }(name='MediaInfoJobList'),
}

model QueryMediaInfoJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaInfoJobListResponseBody(name='body'),
}

async function queryMediaInfoJobListWithOptions(request: QueryMediaInfoJobListRequest, runtime: Util.RuntimeOptions): QueryMediaInfoJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMediaInfoJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMediaInfoJobList(request: QueryMediaInfoJobListRequest): QueryMediaInfoJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaInfoJobListWithOptions(request, runtime);
}

model QueryMediaListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  mediaIds?: string(name='MediaIds'),
  includePlayList?: boolean(name='IncludePlayList'),
  includeSnapshotList?: boolean(name='IncludeSnapshotList'),
  includeMediaInfo?: boolean(name='IncludeMediaInfo'),
  includeSummaryList?: boolean(name='IncludeSummaryList'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryMediaListResponseBody = {
  nonExistMediaIds?: {
    mediaId?: [ string ](name='MediaId')
  }(name='NonExistMediaIds'),
  mediaList?: {
    media?: [ 
    {
      creationTime?: string(name='CreationTime'),
      cateId?: long(name='CateId'),
      height?: string(name='Height'),
      censorState?: string(name='CensorState'),
      tags?: {
        tag?: [ string ](name='Tag')
      }(name='Tags'),
      playList?: {
        play?: [ 
        {
          encryption?: string(name='Encryption'),
          height?: string(name='Height'),
          bitrate?: string(name='Bitrate'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          width?: string(name='Width'),
          size?: string(name='Size'),
          fps?: string(name='Fps'),
          duration?: string(name='Duration'),
          activityName?: string(name='ActivityName'),
          format?: string(name='Format'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
        }
      ](name='Play')
      }(name='PlayList'),
      bitrate?: string(name='Bitrate'),
      mediaId?: string(name='MediaId'),
      file?: {
        state?: string(name='State'),
        URL?: string(name='URL'),
      }(name='File'),
      summaryList?: {
        summary?: [ 
        {
          type?: string(name='Type'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          activityName?: string(name='ActivityName'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
        }
      ](name='Summary')
      }(name='SummaryList'),
      publishState?: string(name='PublishState'),
      mediaInfo?: {
        streams?: {
          videoStreamList?: {
            videoStream?: [ 
            {
              sar?: string(name='Sar'),
              height?: string(name='Height'),
              codecTagString?: string(name='CodecTagString'),
              networkCost?: {
                preloadTime?: string(name='PreloadTime'),
                avgBitrate?: string(name='AvgBitrate'),
                costBandwidth?: string(name='CostBandwidth'),
              }(name='NetworkCost'),
              width?: string(name='Width'),
              index?: string(name='Index'),
              timebase?: string(name='Timebase'),
              avgFPS?: string(name='AvgFPS'),
              pixFmt?: string(name='PixFmt'),
              lang?: string(name='Lang'),
              codecLongName?: string(name='CodecLongName'),
              numFrames?: string(name='NumFrames'),
              rotate?: string(name='Rotate'),
              bitrate?: string(name='Bitrate'),
              hasBFrames?: string(name='HasBFrames'),
              profile?: string(name='Profile'),
              startTime?: string(name='StartTime'),
              dar?: string(name='Dar'),
              codecName?: string(name='CodecName'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              codecTag?: string(name='CodecTag'),
              codecTimeBase?: string(name='CodecTimeBase'),
              level?: string(name='Level'),
            }
          ](name='VideoStream')
          }(name='VideoStreamList'),
          audioStreamList?: {
            audioStream?: [ 
            {
              timebase?: string(name='Timebase'),
              index?: string(name='Index'),
              sampleFmt?: string(name='SampleFmt'),
              channelLayout?: string(name='ChannelLayout'),
              lang?: string(name='Lang'),
              samplerate?: string(name='Samplerate'),
              codecLongName?: string(name='CodecLongName'),
              channels?: string(name='Channels'),
              numFrames?: string(name='NumFrames'),
              bitrate?: string(name='Bitrate'),
              codecTagString?: string(name='CodecTagString'),
              startTime?: string(name='StartTime'),
              codecName?: string(name='CodecName'),
              duration?: string(name='Duration'),
              codecTag?: string(name='CodecTag'),
              codecTimeBase?: string(name='CodecTimeBase'),
            }
          ](name='AudioStream')
          }(name='AudioStreamList'),
          subtitleStreamList?: {
            subtitleStream?: [ 
            {
              index?: string(name='Index'),
              lang?: string(name='Lang'),
            }
          ](name='SubtitleStream')
          }(name='SubtitleStreamList'),
        }(name='Streams'),
        format?: {
          startTime?: string(name='StartTime'),
          numPrograms?: string(name='NumPrograms'),
          size?: string(name='Size'),
          numStreams?: string(name='NumStreams'),
          formatLongName?: string(name='FormatLongName'),
          duration?: string(name='Duration'),
          bitrate?: string(name='Bitrate'),
          formatName?: string(name='FormatName'),
        }(name='Format'),
      }(name='MediaInfo'),
      description?: string(name='Description'),
      size?: string(name='Size'),
      width?: string(name='Width'),
      coverURL?: string(name='CoverURL'),
      snapshotList?: {
        snapshot?: [ 
        {
          type?: string(name='Type'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          activityName?: string(name='ActivityName'),
          count?: string(name='Count'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
        }
      ](name='Snapshot')
      }(name='SnapshotList'),
      runIdList?: {
        runId?: [ string ](name='RunId')
      }(name='RunIdList'),
      duration?: string(name='Duration'),
      fps?: string(name='Fps'),
      title?: string(name='Title'),
      format?: string(name='Format'),
    }
  ](name='Media')
  }(name='MediaList'),
  requestId?: string(name='RequestId'),
}

model QueryMediaListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaListResponseBody(name='body'),
}

async function queryMediaListWithOptions(request: QueryMediaListRequest, runtime: Util.RuntimeOptions): QueryMediaListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMediaList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMediaList(request: QueryMediaListRequest): QueryMediaListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaListWithOptions(request, runtime);
}

model QueryMediaListByURLRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  fileURLs?: string(name='FileURLs'),
  includePlayList?: boolean(name='IncludePlayList'),
  includeSnapshotList?: boolean(name='IncludeSnapshotList'),
  includeMediaInfo?: boolean(name='IncludeMediaInfo'),
  includeSummaryList?: boolean(name='IncludeSummaryList'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryMediaListByURLResponseBody = {
  mediaList?: {
    media?: [ 
    {
      creationTime?: string(name='CreationTime'),
      cateId?: long(name='CateId'),
      height?: string(name='Height'),
      censorState?: string(name='CensorState'),
      tags?: {
        tag?: [ string ](name='Tag')
      }(name='Tags'),
      playList?: {
        play?: [ 
        {
          encryption?: string(name='Encryption'),
          height?: string(name='Height'),
          bitrate?: string(name='Bitrate'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          width?: string(name='Width'),
          size?: string(name='Size'),
          fps?: string(name='Fps'),
          duration?: string(name='Duration'),
          activityName?: string(name='ActivityName'),
          format?: string(name='Format'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
        }
      ](name='Play')
      }(name='PlayList'),
      bitrate?: string(name='Bitrate'),
      mediaId?: string(name='MediaId'),
      file?: {
        state?: string(name='State'),
        URL?: string(name='URL'),
      }(name='File'),
      summaryList?: {
        summary?: [ 
        {
          type?: string(name='Type'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          activityName?: string(name='ActivityName'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
        }
      ](name='Summary')
      }(name='SummaryList'),
      publishState?: string(name='PublishState'),
      mediaInfo?: {
        streams?: {
          videoStreamList?: {
            videoStream?: [ 
            {
              sar?: string(name='Sar'),
              height?: string(name='Height'),
              codecTagString?: string(name='CodecTagString'),
              networkCost?: {
                preloadTime?: string(name='PreloadTime'),
                avgBitrate?: string(name='AvgBitrate'),
                costBandwidth?: string(name='CostBandwidth'),
              }(name='NetworkCost'),
              width?: string(name='Width'),
              index?: string(name='Index'),
              timebase?: string(name='Timebase'),
              avgFPS?: string(name='AvgFPS'),
              pixFmt?: string(name='PixFmt'),
              lang?: string(name='Lang'),
              codecLongName?: string(name='CodecLongName'),
              numFrames?: string(name='NumFrames'),
              rotate?: string(name='Rotate'),
              bitrate?: string(name='Bitrate'),
              hasBFrames?: string(name='HasBFrames'),
              profile?: string(name='Profile'),
              startTime?: string(name='StartTime'),
              dar?: string(name='Dar'),
              codecName?: string(name='CodecName'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              codecTag?: string(name='CodecTag'),
              codecTimeBase?: string(name='CodecTimeBase'),
              level?: string(name='Level'),
            }
          ](name='VideoStream')
          }(name='VideoStreamList'),
          audioStreamList?: {
            audioStream?: [ 
            {
              timebase?: string(name='Timebase'),
              index?: string(name='Index'),
              sampleFmt?: string(name='SampleFmt'),
              channelLayout?: string(name='ChannelLayout'),
              lang?: string(name='Lang'),
              samplerate?: string(name='Samplerate'),
              codecLongName?: string(name='CodecLongName'),
              channels?: string(name='Channels'),
              numFrames?: string(name='NumFrames'),
              bitrate?: string(name='Bitrate'),
              codecTagString?: string(name='CodecTagString'),
              startTime?: string(name='StartTime'),
              codecName?: string(name='CodecName'),
              duration?: string(name='Duration'),
              codecTag?: string(name='CodecTag'),
              codecTimeBase?: string(name='CodecTimeBase'),
            }
          ](name='AudioStream')
          }(name='AudioStreamList'),
          subtitleStreamList?: {
            subtitleStream?: [ 
            {
              index?: string(name='Index'),
              lang?: string(name='Lang'),
            }
          ](name='SubtitleStream')
          }(name='SubtitleStreamList'),
        }(name='Streams'),
        format?: {
          startTime?: string(name='StartTime'),
          numPrograms?: string(name='NumPrograms'),
          size?: string(name='Size'),
          numStreams?: string(name='NumStreams'),
          formatLongName?: string(name='FormatLongName'),
          duration?: string(name='Duration'),
          bitrate?: string(name='Bitrate'),
          formatName?: string(name='FormatName'),
        }(name='Format'),
      }(name='MediaInfo'),
      description?: string(name='Description'),
      size?: string(name='Size'),
      width?: string(name='Width'),
      coverURL?: string(name='CoverURL'),
      snapshotList?: {
        snapshot?: [ 
        {
          type?: string(name='Type'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          activityName?: string(name='ActivityName'),
          count?: string(name='Count'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
        }
      ](name='Snapshot')
      }(name='SnapshotList'),
      runIdList?: {
        runId?: [ string ](name='RunId')
      }(name='RunIdList'),
      duration?: string(name='Duration'),
      fps?: string(name='Fps'),
      title?: string(name='Title'),
      format?: string(name='Format'),
    }
  ](name='Media')
  }(name='MediaList'),
  nonExistFileURLs?: {
    fileURL?: [ string ](name='FileURL')
  }(name='NonExistFileURLs'),
  requestId?: string(name='RequestId'),
}

model QueryMediaListByURLResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaListByURLResponseBody(name='body'),
}

async function queryMediaListByURLWithOptions(request: QueryMediaListByURLRequest, runtime: Util.RuntimeOptions): QueryMediaListByURLResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMediaListByURL', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMediaListByURL(request: QueryMediaListByURLRequest): QueryMediaListByURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaListByURLWithOptions(request, runtime);
}

model QueryMediaWorkflowExecutionListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  runIds?: string(name='RunIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryMediaWorkflowExecutionListResponseBody = {
  nonExistRunIds?: {
    runId?: [ string ](name='RunId')
  }(name='NonExistRunIds'),
  mediaWorkflowExecutionList?: {
    mediaWorkflowExecution?: [ 
    {
      creationTime?: string(name='CreationTime'),
      mediaWorkflowId?: string(name='MediaWorkflowId'),
      state?: string(name='State'),
      activityList?: {
        activity?: [ 
        {
          endTime?: string(name='EndTime'),
          type?: string(name='Type'),
          startTime?: string(name='StartTime'),
          state?: string(name='State'),
          jobId?: string(name='JobId'),
          code?: string(name='Code'),
          message?: string(name='Message'),
          name?: string(name='Name'),
          MNSMessageResult?: {
            messageId?: string(name='MessageId'),
            errorMessage?: string(name='ErrorMessage'),
            errorCode?: string(name='ErrorCode'),
          }(name='MNSMessageResult'),
        }
      ](name='Activity')
      }(name='ActivityList'),
      name?: string(name='Name'),
      input?: {
        userData?: string(name='UserData'),
        inputFile?: {
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='InputFile'),
      }(name='Input'),
      mediaId?: string(name='MediaId'),
      runId?: string(name='RunId'),
    }
  ](name='MediaWorkflowExecution')
  }(name='MediaWorkflowExecutionList'),
  requestId?: string(name='RequestId'),
}

model QueryMediaWorkflowExecutionListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaWorkflowExecutionListResponseBody(name='body'),
}

async function queryMediaWorkflowExecutionListWithOptions(request: QueryMediaWorkflowExecutionListRequest, runtime: Util.RuntimeOptions): QueryMediaWorkflowExecutionListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMediaWorkflowExecutionList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMediaWorkflowExecutionList(request: QueryMediaWorkflowExecutionListRequest): QueryMediaWorkflowExecutionListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaWorkflowExecutionListWithOptions(request, runtime);
}

model QueryMediaWorkflowListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  mediaWorkflowIds?: string(name='MediaWorkflowIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryMediaWorkflowListResponseBody = {
  nonExistMediaWorkflowIds?: {
    mediaWorkflowId?: [ string ](name='MediaWorkflowId')
  }(name='NonExistMediaWorkflowIds'),
  mediaWorkflowList?: {
    mediaWorkflow?: [ 
    {
      creationTime?: string(name='CreationTime'),
      mediaWorkflowId?: string(name='MediaWorkflowId'),
      state?: string(name='State'),
      triggerMode?: string(name='TriggerMode'),
      name?: string(name='Name'),
      topology?: string(name='Topology'),
    }
  ](name='MediaWorkflow')
  }(name='MediaWorkflowList'),
  requestId?: string(name='RequestId'),
}

model QueryMediaWorkflowListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaWorkflowListResponseBody(name='body'),
}

async function queryMediaWorkflowListWithOptions(request: QueryMediaWorkflowListRequest, runtime: Util.RuntimeOptions): QueryMediaWorkflowListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMediaWorkflowList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMediaWorkflowList(request: QueryMediaWorkflowListRequest): QueryMediaWorkflowListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaWorkflowListWithOptions(request, runtime);
}

model QueryPipelineListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pipelineIds?: string(name='PipelineIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryPipelineListResponseBody = {
  requestId?: string(name='RequestId'),
  pipelineList?: {
    pipeline?: [ 
    {
      speed?: string(name='Speed'),
      state?: string(name='State'),
      speedLevel?: long(name='SpeedLevel'),
      notifyConfig?: {
        mqTopic?: string(name='MqTopic'),
        queueName?: string(name='QueueName'),
        mqTag?: string(name='MqTag'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      role?: string(name='Role'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      quotaAllocate?: long(name='QuotaAllocate'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  nonExistPids?: {
    string?: [ string ](name='String')
  }(name='NonExistPids'),
}

model QueryPipelineListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryPipelineListResponseBody(name='body'),
}

async function queryPipelineListWithOptions(request: QueryPipelineListRequest, runtime: Util.RuntimeOptions): QueryPipelineListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryPipelineList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryPipelineList(request: QueryPipelineListRequest): QueryPipelineListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPipelineListWithOptions(request, runtime);
}

model QueryPornJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryPornJobListResponseBody = {
  requestId?: string(name='RequestId'),
  pornJobList?: {
    pornJob?: [ 
    {
      creationTime?: string(name='CreationTime'),
      pornConfig?: {
        interval?: string(name='Interval'),
        outputFile?: {
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='OutputFile'),
        bizType?: string(name='BizType'),
      }(name='PornConfig'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      censorPornResult?: {
        pornCounterList?: {
          counter?: [ 
          {
            label?: string(name='Label'),
            count?: int32(name='Count'),
          }
        ](name='Counter')
        }(name='PornCounterList'),
        suggestion?: string(name='Suggestion'),
        averageScore?: string(name='AverageScore'),
        pornTopList?: {
          top?: [ 
          {
            index?: string(name='Index'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
            object?: string(name='Object'),
            label?: string(name='Label'),
          }
        ](name='Top')
        }(name='PornTopList'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
      }(name='CensorPornResult'),
      pipelineId?: string(name='PipelineId'),
      input?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      id?: string(name='Id'),
    }
  ](name='PornJob')
  }(name='PornJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryPornJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryPornJobListResponseBody(name='body'),
}

async function queryPornJobListWithOptions(request: QueryPornJobListRequest, runtime: Util.RuntimeOptions): QueryPornJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryPornJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryPornJobList(request: QueryPornJobListRequest): QueryPornJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPornJobListWithOptions(request, runtime);
}

model QueryPornPipelineListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pipelineIds?: string(name='PipelineIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryPornPipelineListResponseBody = {
  requestId?: string(name='RequestId'),
  pipelineList?: {
    pipeline?: [ 
    {
      state?: string(name='State'),
      notifyConfig?: {
        topic?: string(name='Topic'),
        queue?: string(name='Queue'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryPornPipelineListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryPornPipelineListResponseBody(name='body'),
}

async function queryPornPipelineListWithOptions(request: QueryPornPipelineListRequest, runtime: Util.RuntimeOptions): QueryPornPipelineListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryPornPipelineList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryPornPipelineList(request: QueryPornPipelineListRequest): QueryPornPipelineListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPornPipelineListWithOptions(request, runtime);
}

model QuerySmarttagJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  jobId?: string(name='JobId'),
}

model QuerySmarttagJobResponseBody = {
  jobStatus?: string(name='JobStatus'),
  requestId?: string(name='RequestId'),
  userData?: string(name='UserData'),
  results?: {
    result?: [ 
    {
      type?: string(name='Type'),
      data?: string(name='Data'),
    }
  ](name='Result')
  }(name='Results'),
}

model QuerySmarttagJobResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySmarttagJobResponseBody(name='body'),
}

async function querySmarttagJobWithOptions(request: QuerySmarttagJobRequest, runtime: Util.RuntimeOptions): QuerySmarttagJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QuerySmarttagJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function querySmarttagJob(request: QuerySmarttagJobRequest): QuerySmarttagJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySmarttagJobWithOptions(request, runtime);
}

model QuerySmarttagTemplateListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  templateId?: string(name='TemplateId'),
}

model QuerySmarttagTemplateListResponseBody = {
  requestId?: string(name='RequestId'),
  templates?: {
    template?: [ 
    {
      analyseTypes?: string(name='AnalyseTypes'),
      industry?: string(name='Industry'),
      isDefault?: boolean(name='IsDefault'),
      templateName?: string(name='TemplateName'),
      templateId?: string(name='TemplateId'),
      faceCategoryIds?: string(name='FaceCategoryIds'),
      scene?: string(name='Scene'),
    }
  ](name='Template')
  }(name='Templates'),
}

model QuerySmarttagTemplateListResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySmarttagTemplateListResponseBody(name='body'),
}

async function querySmarttagTemplateListWithOptions(request: QuerySmarttagTemplateListRequest, runtime: Util.RuntimeOptions): QuerySmarttagTemplateListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QuerySmarttagTemplateList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function querySmarttagTemplateList(request: QuerySmarttagTemplateListRequest): QuerySmarttagTemplateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySmarttagTemplateListWithOptions(request, runtime);
}

model QuerySnapshotJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  snapshotJobIds?: string(name='SnapshotJobIds'),
  nextPageToken?: string(name='NextPageToken'),
  maximumPageSize?: long(name='MaximumPageSize'),
  state?: string(name='State'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange'),
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange'),
  pipelineId?: string(name='PipelineId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QuerySnapshotJobListResponseBody = {
  snapshotJobList?: {
    snapshotJob?: [ 
    {
      creationTime?: string(name='CreationTime'),
      snapshotConfig?: {
        time?: string(name='Time'),
        tileOut?: {
          padding?: string(name='Padding'),
          color?: string(name='Color'),
          cellSelStep?: string(name='CellSelStep'),
          cellHeight?: string(name='CellHeight'),
          cellWidth?: string(name='CellWidth'),
          margin?: string(name='Margin'),
          columns?: string(name='Columns'),
          isKeepCellPic?: string(name='IsKeepCellPic'),
          lines?: string(name='Lines'),
        }(name='TileOut'),
        interval?: string(name='Interval'),
        frameType?: string(name='FrameType'),
        width?: string(name='Width'),
        height?: string(name='Height'),
        outputFile?: {
          roleArn?: string(name='RoleArn'),
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='OutputFile'),
        num?: string(name='Num'),
        tileOutputFile?: {
          roleArn?: string(name='RoleArn'),
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='TileOutputFile'),
      }(name='SnapshotConfig'),
      state?: string(name='State'),
      message?: string(name='Message'),
      MNSMessageResult?: {
        messageId?: string(name='MessageId'),
        errorMessage?: string(name='ErrorMessage'),
        errorCode?: string(name='ErrorCode'),
      }(name='MNSMessageResult'),
      input?: {
        roleArn?: string(name='RoleArn'),
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      count?: string(name='Count'),
      tileCount?: string(name='TileCount'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      pipelineId?: string(name='PipelineId'),
      id?: string(name='Id'),
    }
  ](name='SnapshotJob')
  }(name='SnapshotJobList'),
  requestId?: string(name='RequestId'),
  nonExistSnapshotJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistSnapshotJobIds'),
  nextPageToken?: string(name='NextPageToken'),
}

model QuerySnapshotJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySnapshotJobListResponseBody(name='body'),
}

async function querySnapshotJobListWithOptions(request: QuerySnapshotJobListRequest, runtime: Util.RuntimeOptions): QuerySnapshotJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QuerySnapshotJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function querySnapshotJobList(request: QuerySnapshotJobListRequest): QuerySnapshotJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySnapshotJobListWithOptions(request, runtime);
}

model QuerySubtitleJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QuerySubtitleJobListResponseBody = {
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
  jobList?: {
    job?: [ 
    {
      outputConfig?: string(name='OutputConfig'),
      state?: string(name='State'),
      jobId?: string(name='JobId'),
      userData?: string(name='UserData'),
      inputConfig?: string(name='InputConfig'),
      MNSMessageResult?: {
        messageId?: string(name='MessageId'),
        errorMessage?: string(name='ErrorMessage'),
        errorCode?: string(name='ErrorCode'),
      }(name='MNSMessageResult'),
    }
  ](name='Job')
  }(name='JobList'),
}

model QuerySubtitleJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySubtitleJobListResponseBody(name='body'),
}

async function querySubtitleJobListWithOptions(request: QuerySubtitleJobListRequest, runtime: Util.RuntimeOptions): QuerySubtitleJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QuerySubtitleJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function querySubtitleJobList(request: QuerySubtitleJobListRequest): QuerySubtitleJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySubtitleJobListWithOptions(request, runtime);
}

model QueryTagJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tagJobIds?: string(name='TagJobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryTagJobListResponseBody = {
  tagJobList?: {
    tagJob?: [ 
    {
      creationTime?: string(name='CreationTime'),
      videoTagResult?: {
        tagAnResults?: {
          tagAnResult?: [ 
          {
            score?: string(name='Score'),
            label?: string(name='Label'),
          }
        ](name='TagAnResult')
        }(name='TagAnResults'),
        tagFrResults?: {
          tagFrResult?: [ 
          {
            tagFaces?: {
              tagFace?: [ 
              {
                score?: string(name='Score'),
                name?: string(name='Name'),
                target?: string(name='Target'),
              }
            ](name='TagFace')
            }(name='TagFaces'),
            time?: string(name='Time'),
          }
        ](name='TagFrResult')
        }(name='TagFrResults'),
        details?: string(name='Details'),
      }(name='VideoTagResult'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      input?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      id?: string(name='Id'),
    }
  ](name='TagJob')
  }(name='TagJobList'),
  requestId?: string(name='RequestId'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryTagJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTagJobListResponseBody(name='body'),
}

async function queryTagJobListWithOptions(request: QueryTagJobListRequest, runtime: Util.RuntimeOptions): QueryTagJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTagJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTagJobList(request: QueryTagJobListRequest): QueryTagJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTagJobListWithOptions(request, runtime);
}

model QueryTemplateListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateIds?: string(name='TemplateIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryTemplateListResponseBody = {
  nonExistTids?: {
    string?: [ string ](name='String')
  }(name='NonExistTids'),
  templateList?: {
    template?: [ 
    {
      video?: {
        bufsize?: string(name='Bufsize'),
        longShortMode?: string(name='LongShortMode'),
        degrain?: string(name='Degrain'),
        bitrateBnd?: {
          max?: string(name='Max'),
          min?: string(name='Min'),
        }(name='BitrateBnd'),
        pixFmt?: string(name='PixFmt'),
        pad?: string(name='Pad'),
        codec?: string(name='Codec'),
        height?: string(name='Height'),
        qscale?: string(name='Qscale'),
        crop?: string(name='Crop'),
        bitrate?: string(name='Bitrate'),
        maxrate?: string(name='Maxrate'),
        maxFps?: string(name='MaxFps'),
        profile?: string(name='Profile'),
        crf?: string(name='Crf'),
        remove?: string(name='Remove'),
        gop?: string(name='Gop'),
        width?: string(name='Width'),
        fps?: string(name='Fps'),
        preset?: string(name='Preset'),
        scanMode?: string(name='ScanMode'),
        resoPriority?: string(name='ResoPriority'),
      }(name='Video'),
      transConfig?: {
        isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
        transMode?: string(name='TransMode'),
        isCheckReso?: string(name='IsCheckReso'),
        isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
        adjDarMethod?: string(name='AdjDarMethod'),
        isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
        isCheckResoFail?: string(name='IsCheckResoFail'),
        isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
      }(name='TransConfig'),
      state?: string(name='State'),
      muxConfig?: {
        webp?: {
          loop?: string(name='Loop'),
        }(name='Webp'),
        gif?: {
          finalDelay?: string(name='FinalDelay'),
          ditherMode?: string(name='DitherMode'),
          loop?: string(name='Loop'),
          isCustomPalette?: string(name='IsCustomPalette'),
        }(name='Gif'),
        segment?: {
          duration?: string(name='Duration'),
        }(name='Segment'),
      }(name='MuxConfig'),
      name?: string(name='Name'),
      audio?: {
        profile?: string(name='Profile'),
        remove?: string(name='Remove'),
        codec?: string(name='Codec'),
        samplerate?: string(name='Samplerate'),
        qscale?: string(name='Qscale'),
        channels?: string(name='Channels'),
        bitrate?: string(name='Bitrate'),
      }(name='Audio'),
      id?: string(name='Id'),
      container?: {
        format?: string(name='Format'),
      }(name='Container'),
    }
  ](name='Template')
  }(name='TemplateList'),
  requestId?: string(name='RequestId'),
}

model QueryTemplateListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTemplateListResponseBody(name='body'),
}

async function queryTemplateListWithOptions(request: QueryTemplateListRequest, runtime: Util.RuntimeOptions): QueryTemplateListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTemplateList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTemplateList(request: QueryTemplateListRequest): QueryTemplateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTemplateListWithOptions(request, runtime);
}

model QueryTerrorismJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryTerrorismJobListResponseBody = {
  requestId?: string(name='RequestId'),
  terrorismJobList?: {
    terrorismJob?: [ 
    {
      creationTime?: string(name='CreationTime'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      censorTerrorismResult?: {
        terrorismTopList?: {
          top?: [ 
          {
            index?: string(name='Index'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
            object?: string(name='Object'),
            label?: string(name='Label'),
          }
        ](name='Top')
        }(name='TerrorismTopList'),
        suggestion?: string(name='Suggestion'),
        averageScore?: string(name='AverageScore'),
        terrorismCounterList?: {
          counter?: [ 
          {
            label?: string(name='Label'),
            count?: int32(name='Count'),
          }
        ](name='Counter')
        }(name='TerrorismCounterList'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
      }(name='CensorTerrorismResult'),
      terrorismConfig?: {
        interval?: string(name='Interval'),
        outputFile?: {
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='OutputFile'),
        bizType?: string(name='BizType'),
      }(name='TerrorismConfig'),
      pipelineId?: string(name='PipelineId'),
      input?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      id?: string(name='Id'),
    }
  ](name='TerrorismJob')
  }(name='TerrorismJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryTerrorismJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTerrorismJobListResponseBody(name='body'),
}

async function queryTerrorismJobListWithOptions(request: QueryTerrorismJobListRequest, runtime: Util.RuntimeOptions): QueryTerrorismJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTerrorismJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTerrorismJobList(request: QueryTerrorismJobListRequest): QueryTerrorismJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTerrorismJobListWithOptions(request, runtime);
}

model QueryTerrorismPipelineListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pipelineIds?: string(name='PipelineIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryTerrorismPipelineListResponseBody = {
  requestId?: string(name='RequestId'),
  pipelineList?: {
    pipeline?: [ 
    {
      state?: string(name='State'),
      notifyConfig?: {
        topic?: string(name='Topic'),
        queue?: string(name='Queue'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryTerrorismPipelineListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTerrorismPipelineListResponseBody(name='body'),
}

async function queryTerrorismPipelineListWithOptions(request: QueryTerrorismPipelineListRequest, runtime: Util.RuntimeOptions): QueryTerrorismPipelineListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTerrorismPipelineList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTerrorismPipelineList(request: QueryTerrorismPipelineListRequest): QueryTerrorismPipelineListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTerrorismPipelineListWithOptions(request, runtime);
}

model QueryVideoGifJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryVideoGifJobListResponseBody = {
  requestId?: string(name='RequestId'),
  jobList?: {
    job?: [ 
    {
      creationTime?: string(name='CreationTime'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      videoGifResult?: {
        outputFile?: {
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='OutputFile'),
      }(name='VideoGifResult'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      input?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      id?: string(name='Id'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryVideoGifJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryVideoGifJobListResponseBody(name='body'),
}

async function queryVideoGifJobListWithOptions(request: QueryVideoGifJobListRequest, runtime: Util.RuntimeOptions): QueryVideoGifJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryVideoGifJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryVideoGifJobList(request: QueryVideoGifJobListRequest): QueryVideoGifJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryVideoGifJobListWithOptions(request, runtime);
}

model QueryVideoPoseJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryVideoPoseJobListResponseBody = {
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
  jobList?: {
    job?: [ 
    {
      outputConfig?: {
        dataFile?: {
          roleArn?: string(name='RoleArn'),
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='DataFile'),
        videoFile?: {
          roleArn?: string(name='RoleArn'),
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='VideoFile'),
      }(name='OutputConfig'),
      state?: string(name='State'),
      jobId?: string(name='JobId'),
      userData?: string(name='UserData'),
      pipelineId?: string(name='PipelineId'),
      MNSMessageResult?: {
        messageId?: string(name='MessageId'),
        errorMessage?: string(name='ErrorMessage'),
        errorCode?: string(name='ErrorCode'),
      }(name='MNSMessageResult'),
      input?: {
        roleArn?: string(name='RoleArn'),
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      properties?: {
        width?: string(name='Width'),
        height?: string(name='Height'),
        duration?: string(name='Duration'),
        fps?: string(name='Fps'),
        bitrate?: string(name='Bitrate'),
        fileFormat?: string(name='FileFormat'),
        streams?: {
          videoStreamList?: {
            videoStream?: [ 
            {
              sar?: string(name='Sar'),
              height?: string(name='Height'),
              codecTagString?: string(name='CodecTagString'),
              networkCost?: {
                preloadTime?: string(name='PreloadTime'),
                avgBitrate?: string(name='AvgBitrate'),
                costBandwidth?: string(name='CostBandwidth'),
              }(name='NetworkCost'),
              width?: string(name='Width'),
              index?: string(name='Index'),
              timebase?: string(name='Timebase'),
              avgFPS?: string(name='AvgFPS'),
              pixFmt?: string(name='PixFmt'),
              lang?: string(name='Lang'),
              codecLongName?: string(name='CodecLongName'),
              numFrames?: string(name='NumFrames'),
              rotate?: string(name='Rotate'),
              bitrate?: string(name='Bitrate'),
              hasBFrames?: string(name='HasBFrames'),
              profile?: string(name='Profile'),
              startTime?: string(name='StartTime'),
              dar?: string(name='Dar'),
              codecName?: string(name='CodecName'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              codecTag?: string(name='CodecTag'),
              codecTimeBase?: string(name='CodecTimeBase'),
              level?: string(name='Level'),
            }
          ](name='VideoStream')
          }(name='VideoStreamList'),
          audioStreamList?: {
            audioStream?: [ 
            {
              timebase?: string(name='Timebase'),
              index?: string(name='Index'),
              sampleFmt?: string(name='SampleFmt'),
              channelLayout?: string(name='ChannelLayout'),
              lang?: string(name='Lang'),
              samplerate?: string(name='Samplerate'),
              codecLongName?: string(name='CodecLongName'),
              channels?: string(name='Channels'),
              numFrames?: string(name='NumFrames'),
              bitrate?: string(name='Bitrate'),
              codecTagString?: string(name='CodecTagString'),
              startTime?: string(name='StartTime'),
              codecName?: string(name='CodecName'),
              duration?: string(name='Duration'),
              codecTag?: string(name='CodecTag'),
              codecTimeBase?: string(name='CodecTimeBase'),
            }
          ](name='AudioStream')
          }(name='AudioStreamList'),
          subtitleStreamList?: {
            subtitleStream?: [ 
            {
              timebase?: string(name='Timebase'),
              index?: string(name='Index'),
              startTime?: string(name='StartTime'),
              codecName?: string(name='CodecName'),
              lang?: string(name='Lang'),
              codecLongName?: string(name='CodecLongName'),
              duration?: string(name='Duration'),
              codecTag?: string(name='CodecTag'),
              codecTimeBase?: string(name='CodecTimeBase'),
              codecTagString?: string(name='CodecTagString'),
            }
          ](name='SubtitleStream')
          }(name='SubtitleStreamList'),
        }(name='Streams'),
        format?: {
          startTime?: string(name='StartTime'),
          numPrograms?: string(name='NumPrograms'),
          size?: string(name='Size'),
          numStreams?: string(name='NumStreams'),
          formatLongName?: string(name='FormatLongName'),
          duration?: string(name='Duration'),
          bitrate?: string(name='Bitrate'),
          formatName?: string(name='FormatName'),
        }(name='Format'),
        fileSize?: string(name='FileSize'),
      }(name='Properties'),
    }
  ](name='Job')
  }(name='JobList'),
}

model QueryVideoPoseJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryVideoPoseJobListResponseBody(name='body'),
}

async function queryVideoPoseJobListWithOptions(request: QueryVideoPoseJobListRequest, runtime: Util.RuntimeOptions): QueryVideoPoseJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryVideoPoseJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryVideoPoseJobList(request: QueryVideoPoseJobListRequest): QueryVideoPoseJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryVideoPoseJobListWithOptions(request, runtime);
}

model QueryVideoQualityJobRequest {
  userId?: long(name='UserId'),
  jobId?: string(name='JobId'),
}

model QueryVideoQualityJobResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  job?: {
    status?: string(name='Status'),
    jobId?: string(name='JobId'),
    userId?: long(name='UserId'),
    videoQualityResults?: string(name='VideoQualityResults'),
    message?: string(name='Message'),
    output?: string(name='Output'),
  }(name='Job'),
  code?: string(name='Code'),
}

model QueryVideoQualityJobResponse = {
  headers: map[string]string(name='headers'),
  body: QueryVideoQualityJobResponseBody(name='body'),
}

async function queryVideoQualityJobWithOptions(request: QueryVideoQualityJobRequest, runtime: Util.RuntimeOptions): QueryVideoQualityJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryVideoQualityJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryVideoQualityJob(request: QueryVideoQualityJobRequest): QueryVideoQualityJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryVideoQualityJobWithOptions(request, runtime);
}

model QueryVideoSplitJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryVideoSplitJobListResponseBody = {
  requestId?: string(name='RequestId'),
  jobList?: {
    job?: [ 
    {
      creationTime?: string(name='CreationTime'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      videoSplitResult?: {
        videoSplitList?: {
          videoSplit?: [ 
          {
            endTime?: string(name='EndTime'),
            startTime?: string(name='StartTime'),
            path?: string(name='Path'),
          }
        ](name='VideoSplit')
        }(name='VideoSplitList'),
      }(name='VideoSplitResult'),
      pipelineId?: string(name='PipelineId'),
      input?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      id?: string(name='Id'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryVideoSplitJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryVideoSplitJobListResponseBody(name='body'),
}

async function queryVideoSplitJobListWithOptions(request: QueryVideoSplitJobListRequest, runtime: Util.RuntimeOptions): QueryVideoSplitJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryVideoSplitJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryVideoSplitJobList(request: QueryVideoSplitJobListRequest): QueryVideoSplitJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryVideoSplitJobListWithOptions(request, runtime);
}

model QueryVideoSummaryJobListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryVideoSummaryJobListResponseBody = {
  requestId?: string(name='RequestId'),
  jobList?: {
    job?: [ 
    {
      creationTime?: string(name='CreationTime'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      videoSummaryResult?: {
        videoSummaryList?: {
          videoSummary?: [ 
          {
            endTime?: string(name='EndTime'),
            startTime?: string(name='StartTime'),
          }
        ](name='VideoSummary')
        }(name='VideoSummaryList'),
        outputFile?: {
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='OutputFile'),
      }(name='VideoSummaryResult'),
      pipelineId?: string(name='PipelineId'),
      input?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      id?: string(name='Id'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
}

model QueryVideoSummaryJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryVideoSummaryJobListResponseBody(name='body'),
}

async function queryVideoSummaryJobListWithOptions(request: QueryVideoSummaryJobListRequest, runtime: Util.RuntimeOptions): QueryVideoSummaryJobListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryVideoSummaryJobList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryVideoSummaryJobList(request: QueryVideoSummaryJobListRequest): QueryVideoSummaryJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryVideoSummaryJobListWithOptions(request, runtime);
}

model QueryWaterMarkTemplateListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  waterMarkTemplateIds?: string(name='WaterMarkTemplateIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model QueryWaterMarkTemplateListResponseBody = {
  requestId?: string(name='RequestId'),
  nonExistWids?: {
    string?: [ string ](name='String')
  }(name='NonExistWids'),
  waterMarkTemplateList?: {
    waterMarkTemplate?: [ 
    {
      type?: string(name='Type'),
      ratioRefer?: {
        dx?: string(name='Dx'),
        width?: string(name='Width'),
        height?: string(name='Height'),
        dy?: string(name='Dy'),
      }(name='RatioRefer'),
      referPos?: string(name='ReferPos'),
      state?: string(name='State'),
      dx?: string(name='Dx'),
      width?: string(name='Width'),
      height?: string(name='Height'),
      timeline?: {
        start?: string(name='Start'),
        duration?: string(name='Duration'),
      }(name='Timeline'),
      name?: string(name='Name'),
      dy?: string(name='Dy'),
      id?: string(name='Id'),
    }
  ](name='WaterMarkTemplate')
  }(name='WaterMarkTemplateList'),
}

model QueryWaterMarkTemplateListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryWaterMarkTemplateListResponseBody(name='body'),
}

async function queryWaterMarkTemplateListWithOptions(request: QueryWaterMarkTemplateListRequest, runtime: Util.RuntimeOptions): QueryWaterMarkTemplateListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryWaterMarkTemplateList', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryWaterMarkTemplateList(request: QueryWaterMarkTemplateListRequest): QueryWaterMarkTemplateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryWaterMarkTemplateListWithOptions(request, runtime);
}

model RefreshCdnDomainConfigsCacheRequest {
  ownerId?: string(name='OwnerId'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount'),
  domains?: string(name='Domains'),
}

model RefreshCdnDomainConfigsCacheResponseBody = {
  sucessDomains?: {
    string?: [ string ](name='String')
  }(name='SucessDomains'),
  failedDomains?: {
    string?: [ string ](name='String')
  }(name='FailedDomains'),
  requestId?: string(name='RequestId'),
}

model RefreshCdnDomainConfigsCacheResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshCdnDomainConfigsCacheResponseBody(name='body'),
}

async function refreshCdnDomainConfigsCacheWithOptions(request: RefreshCdnDomainConfigsCacheRequest, runtime: Util.RuntimeOptions): RefreshCdnDomainConfigsCacheResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RefreshCdnDomainConfigsCache', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function refreshCdnDomainConfigsCache(request: RefreshCdnDomainConfigsCacheRequest): RefreshCdnDomainConfigsCacheResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshCdnDomainConfigsCacheWithOptions(request, runtime);
}

model RegisterCustomFaceRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  categoryId?: string(name='CategoryId'),
  personId?: string(name='PersonId'),
  imageUrl?: string(name='ImageUrl'),
}

model RegisterCustomFaceResponseBody = {
  faceId?: string(name='FaceId'),
  requestId?: string(name='RequestId'),
}

model RegisterCustomFaceResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterCustomFaceResponseBody(name='body'),
}

async function registerCustomFaceWithOptions(request: RegisterCustomFaceRequest, runtime: Util.RuntimeOptions): RegisterCustomFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RegisterCustomFace', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function registerCustomFace(request: RegisterCustomFaceRequest): RegisterCustomFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerCustomFaceWithOptions(request, runtime);
}

model RegisterMediaDetailPersonRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  category?: string(name='Category'),
  personName?: string(name='PersonName'),
  images?: string(name='Images'),
  personLib?: string(name='PersonLib'),
  ownerAccount?: string(name='OwnerAccount'),
}

model RegisterMediaDetailPersonResponseBody = {
  requestId?: string(name='RequestId'),
  registeredPersonages?: {
    registeredPersonage?: [ 
    {
      quality?: string(name='Quality'),
      imageFile?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='ImageFile'),
      personName?: string(name='PersonName'),
      gender?: string(name='Gender'),
      faceId?: string(name='FaceId'),
      target?: string(name='Target'),
      imageId?: string(name='ImageId'),
    }
  ](name='RegisteredPersonage')
  }(name='RegisteredPersonages'),
  failedImages?: {
    failedImage?: [ 
    {
      imageFile?: {
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='ImageFile'),
      success?: string(name='Success'),
      code?: string(name='Code'),
    }
  ](name='FailedImage')
  }(name='FailedImages'),
}

model RegisterMediaDetailPersonResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterMediaDetailPersonResponseBody(name='body'),
}

async function registerMediaDetailPersonWithOptions(request: RegisterMediaDetailPersonRequest, runtime: Util.RuntimeOptions): RegisterMediaDetailPersonResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RegisterMediaDetailPerson', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function registerMediaDetailPerson(request: RegisterMediaDetailPersonRequest): RegisterMediaDetailPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerMediaDetailPersonWithOptions(request, runtime);
}

model RegisterMediaDetailScenarioRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobId?: string(name='JobId'),
  scenario?: string(name='Scenario'),
  description?: string(name='Description'),
  ownerAccount?: string(name='OwnerAccount'),
}

model RegisterMediaDetailScenarioResponseBody = {
  scenarioId?: string(name='ScenarioId'),
  requestId?: string(name='RequestId'),
}

model RegisterMediaDetailScenarioResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterMediaDetailScenarioResponseBody(name='body'),
}

async function registerMediaDetailScenarioWithOptions(request: RegisterMediaDetailScenarioRequest, runtime: Util.RuntimeOptions): RegisterMediaDetailScenarioResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RegisterMediaDetailScenario', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function registerMediaDetailScenario(request: RegisterMediaDetailScenarioRequest): RegisterMediaDetailScenarioResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerMediaDetailScenarioWithOptions(request, runtime);
}

model ReportAnnotationJobResultRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobId?: string(name='JobId'),
  annotation?: string(name='Annotation'),
  details?: string(name='Details'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ReportAnnotationJobResultResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model ReportAnnotationJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportAnnotationJobResultResponseBody(name='body'),
}

async function reportAnnotationJobResultWithOptions(request: ReportAnnotationJobResultRequest, runtime: Util.RuntimeOptions): ReportAnnotationJobResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReportAnnotationJobResult', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function reportAnnotationJobResult(request: ReportAnnotationJobResultRequest): ReportAnnotationJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportAnnotationJobResultWithOptions(request, runtime);
}

model ReportCensorJobResultRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobId?: string(name='JobId'),
  label?: string(name='Label'),
  detail?: string(name='Detail'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ReportCensorJobResultResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model ReportCensorJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportCensorJobResultResponseBody(name='body'),
}

async function reportCensorJobResultWithOptions(request: ReportCensorJobResultRequest, runtime: Util.RuntimeOptions): ReportCensorJobResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReportCensorJobResult', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function reportCensorJobResult(request: ReportCensorJobResultRequest): ReportCensorJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportCensorJobResultWithOptions(request, runtime);
}

model ReportCoverJobResultRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobId?: string(name='JobId'),
  result?: string(name='Result'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ReportCoverJobResultResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model ReportCoverJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportCoverJobResultResponseBody(name='body'),
}

async function reportCoverJobResultWithOptions(request: ReportCoverJobResultRequest, runtime: Util.RuntimeOptions): ReportCoverJobResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReportCoverJobResult', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function reportCoverJobResult(request: ReportCoverJobResultRequest): ReportCoverJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportCoverJobResultWithOptions(request, runtime);
}

model ReportFacerecogJobResultRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobId?: string(name='JobId'),
  facerecog?: string(name='Facerecog'),
  details?: string(name='Details'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ReportFacerecogJobResultResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model ReportFacerecogJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportFacerecogJobResultResponseBody(name='body'),
}

async function reportFacerecogJobResultWithOptions(request: ReportFacerecogJobResultRequest, runtime: Util.RuntimeOptions): ReportFacerecogJobResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReportFacerecogJobResult', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function reportFacerecogJobResult(request: ReportFacerecogJobResultRequest): ReportFacerecogJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportFacerecogJobResultWithOptions(request, runtime);
}

model ReportFpShotJobResultRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobId?: string(name='JobId'),
  result?: string(name='Result'),
  details?: string(name='Details'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ReportFpShotJobResultResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model ReportFpShotJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportFpShotJobResultResponseBody(name='body'),
}

async function reportFpShotJobResultWithOptions(request: ReportFpShotJobResultRequest, runtime: Util.RuntimeOptions): ReportFpShotJobResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReportFpShotJobResult', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function reportFpShotJobResult(request: ReportFpShotJobResultRequest): ReportFpShotJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportFpShotJobResultWithOptions(request, runtime);
}

model ReportMediaDetailJobResultRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobId?: string(name='JobId'),
  tag?: string(name='Tag'),
  results?: string(name='Results'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ReportMediaDetailJobResultResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model ReportMediaDetailJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportMediaDetailJobResultResponseBody(name='body'),
}

async function reportMediaDetailJobResultWithOptions(request: ReportMediaDetailJobResultRequest, runtime: Util.RuntimeOptions): ReportMediaDetailJobResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReportMediaDetailJobResult', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function reportMediaDetailJobResult(request: ReportMediaDetailJobResultRequest): ReportMediaDetailJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportMediaDetailJobResultWithOptions(request, runtime);
}

model ReportPornJobResultRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobId?: string(name='JobId'),
  label?: string(name='Label'),
  detail?: string(name='Detail'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ReportPornJobResultResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model ReportPornJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportPornJobResultResponseBody(name='body'),
}

async function reportPornJobResultWithOptions(request: ReportPornJobResultRequest, runtime: Util.RuntimeOptions): ReportPornJobResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReportPornJobResult', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function reportPornJobResult(request: ReportPornJobResultRequest): ReportPornJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportPornJobResultWithOptions(request, runtime);
}

model ReportTagJobResultRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobId?: string(name='JobId'),
  tag?: string(name='Tag'),
  result?: string(name='Result'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ReportTagJobResultResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model ReportTagJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportTagJobResultResponseBody(name='body'),
}

async function reportTagJobResultWithOptions(request: ReportTagJobResultRequest, runtime: Util.RuntimeOptions): ReportTagJobResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReportTagJobResult', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function reportTagJobResult(request: ReportTagJobResultRequest): ReportTagJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportTagJobResultWithOptions(request, runtime);
}

model ReportTerrorismJobResultRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobId?: string(name='JobId'),
  label?: string(name='Label'),
  detail?: string(name='Detail'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ReportTerrorismJobResultResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model ReportTerrorismJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportTerrorismJobResultResponseBody(name='body'),
}

async function reportTerrorismJobResultWithOptions(request: ReportTerrorismJobResultRequest, runtime: Util.RuntimeOptions): ReportTerrorismJobResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReportTerrorismJobResult', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function reportTerrorismJobResult(request: ReportTerrorismJobResultRequest): ReportTerrorismJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportTerrorismJobResultWithOptions(request, runtime);
}

model ReportVideoSplitJobResultRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobId?: string(name='JobId'),
  result?: string(name='Result'),
  details?: string(name='Details'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ReportVideoSplitJobResultResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model ReportVideoSplitJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportVideoSplitJobResultResponseBody(name='body'),
}

async function reportVideoSplitJobResultWithOptions(request: ReportVideoSplitJobResultRequest, runtime: Util.RuntimeOptions): ReportVideoSplitJobResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReportVideoSplitJobResult', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function reportVideoSplitJobResult(request: ReportVideoSplitJobResultRequest): ReportVideoSplitJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportVideoSplitJobResultWithOptions(request, runtime);
}

model SearchMediaRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  from?: string(name='From'),
  to?: string(name='To'),
  keyWord?: string(name='KeyWord'),
  title?: string(name='Title'),
  description?: string(name='Description'),
  tag?: string(name='Tag'),
  cateId?: string(name='CateId'),
  sortBy?: string(name='SortBy'),
  pageSize?: long(name='PageSize'),
  pageNumber?: long(name='PageNumber'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SearchMediaResponseBody = {
  mediaList?: {
    media?: [ 
    {
      creationTime?: string(name='CreationTime'),
      cateId?: long(name='CateId'),
      height?: string(name='Height'),
      tags?: {
        tag?: [ string ](name='Tag')
      }(name='Tags'),
      bitrate?: string(name='Bitrate'),
      mediaId?: string(name='MediaId'),
      file?: {
        state?: string(name='State'),
        URL?: string(name='URL'),
      }(name='File'),
      publishState?: string(name='PublishState'),
      description?: string(name='Description'),
      width?: string(name='Width'),
      size?: string(name='Size'),
      coverURL?: string(name='CoverURL'),
      runIdList?: {
        runId?: [ string ](name='RunId')
      }(name='RunIdList'),
      duration?: string(name='Duration'),
      fps?: string(name='Fps'),
      title?: string(name='Title'),
      format?: string(name='Format'),
    }
  ](name='Media')
  }(name='MediaList'),
  totalNum?: long(name='TotalNum'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: long(name='PageNumber'),
}

model SearchMediaResponse = {
  headers: map[string]string(name='headers'),
  body: SearchMediaResponseBody(name='body'),
}

async function searchMediaWithOptions(request: SearchMediaRequest, runtime: Util.RuntimeOptions): SearchMediaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchMedia', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchMedia(request: SearchMediaRequest): SearchMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchMediaWithOptions(request, runtime);
}

model SearchMediaWorkflowRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pageSize?: long(name='PageSize'),
  pageNumber?: long(name='PageNumber'),
  stateList?: string(name='StateList'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SearchMediaWorkflowResponseBody = {
  totalCount?: long(name='TotalCount'),
  mediaWorkflowList?: {
    mediaWorkflow?: [ 
    {
      creationTime?: string(name='CreationTime'),
      mediaWorkflowId?: string(name='MediaWorkflowId'),
      state?: string(name='State'),
      triggerMode?: string(name='TriggerMode'),
      name?: string(name='Name'),
      topology?: string(name='Topology'),
    }
  ](name='MediaWorkflow')
  }(name='MediaWorkflowList'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: long(name='PageNumber'),
}

model SearchMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: SearchMediaWorkflowResponseBody(name='body'),
}

async function searchMediaWorkflowWithOptions(request: SearchMediaWorkflowRequest, runtime: Util.RuntimeOptions): SearchMediaWorkflowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchMediaWorkflow', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchMediaWorkflow(request: SearchMediaWorkflowRequest): SearchMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchMediaWorkflowWithOptions(request, runtime);
}

model SearchPipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pageSize?: long(name='PageSize'),
  pageNumber?: long(name='PageNumber'),
  state?: string(name='State'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SearchPipelineResponseBody = {
  totalCount?: long(name='TotalCount'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: long(name='PageNumber'),
  pipelineList?: {
    pipeline?: [ 
    {
      speed?: string(name='Speed'),
      state?: string(name='State'),
      speedLevel?: long(name='SpeedLevel'),
      notifyConfig?: {
        mqTopic?: string(name='MqTopic'),
        queueName?: string(name='QueueName'),
        mqTag?: string(name='MqTag'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      role?: string(name='Role'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      quotaAllocate?: long(name='QuotaAllocate'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
}

model SearchPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: SearchPipelineResponseBody(name='body'),
}

async function searchPipelineWithOptions(request: SearchPipelineRequest, runtime: Util.RuntimeOptions): SearchPipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchPipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchPipeline(request: SearchPipelineRequest): SearchPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchPipelineWithOptions(request, runtime);
}

model SearchTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pageSize?: long(name='PageSize'),
  pageNumber?: long(name='PageNumber'),
  state?: string(name='State'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SearchTemplateResponseBody = {
  totalCount?: long(name='TotalCount'),
  templateList?: {
    template?: [ 
    {
      video?: {
        bufsize?: string(name='Bufsize'),
        longShortMode?: string(name='LongShortMode'),
        degrain?: string(name='Degrain'),
        bitrateBnd?: {
          max?: string(name='Max'),
          min?: string(name='Min'),
        }(name='BitrateBnd'),
        pixFmt?: string(name='PixFmt'),
        pad?: string(name='Pad'),
        codec?: string(name='Codec'),
        height?: string(name='Height'),
        qscale?: string(name='Qscale'),
        crop?: string(name='Crop'),
        bitrate?: string(name='Bitrate'),
        maxrate?: string(name='Maxrate'),
        maxFps?: string(name='MaxFps'),
        profile?: string(name='Profile'),
        crf?: string(name='Crf'),
        remove?: string(name='Remove'),
        gop?: string(name='Gop'),
        width?: string(name='Width'),
        fps?: string(name='Fps'),
        preset?: string(name='Preset'),
        scanMode?: string(name='ScanMode'),
      }(name='Video'),
      transConfig?: {
        isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
        transMode?: string(name='TransMode'),
        isCheckReso?: string(name='IsCheckReso'),
        isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
        adjDarMethod?: string(name='AdjDarMethod'),
        isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
        isCheckResoFail?: string(name='IsCheckResoFail'),
        isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
      }(name='TransConfig'),
      state?: string(name='State'),
      muxConfig?: {
        gif?: {
          finalDelay?: string(name='FinalDelay'),
          ditherMode?: string(name='DitherMode'),
          loop?: string(name='Loop'),
          isCustomPalette?: string(name='IsCustomPalette'),
        }(name='Gif'),
        segment?: {
          duration?: string(name='Duration'),
        }(name='Segment'),
      }(name='MuxConfig'),
      name?: string(name='Name'),
      audio?: {
        profile?: string(name='Profile'),
        remove?: string(name='Remove'),
        codec?: string(name='Codec'),
        samplerate?: string(name='Samplerate'),
        qscale?: string(name='Qscale'),
        channels?: string(name='Channels'),
        bitrate?: string(name='Bitrate'),
      }(name='Audio'),
      id?: string(name='Id'),
      container?: {
        format?: string(name='Format'),
      }(name='Container'),
    }
  ](name='Template')
  }(name='TemplateList'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: long(name='PageNumber'),
}

model SearchTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: SearchTemplateResponseBody(name='body'),
}

async function searchTemplateWithOptions(request: SearchTemplateRequest, runtime: Util.RuntimeOptions): SearchTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchTemplate(request: SearchTemplateRequest): SearchTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTemplateWithOptions(request, runtime);
}

model SearchWaterMarkTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pageSize?: long(name='PageSize'),
  pageNumber?: long(name='PageNumber'),
  state?: string(name='State'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SearchWaterMarkTemplateResponseBody = {
  totalCount?: long(name='TotalCount'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: long(name='PageNumber'),
  waterMarkTemplateList?: {
    waterMarkTemplate?: [ 
    {
      type?: string(name='Type'),
      ratioRefer?: {
        dx?: string(name='Dx'),
        width?: string(name='Width'),
        height?: string(name='Height'),
        dy?: string(name='Dy'),
      }(name='RatioRefer'),
      referPos?: string(name='ReferPos'),
      state?: string(name='State'),
      dx?: string(name='Dx'),
      width?: string(name='Width'),
      height?: string(name='Height'),
      timeline?: {
        start?: string(name='Start'),
        duration?: string(name='Duration'),
      }(name='Timeline'),
      name?: string(name='Name'),
      dy?: string(name='Dy'),
      id?: string(name='Id'),
    }
  ](name='WaterMarkTemplate')
  }(name='WaterMarkTemplateList'),
}

model SearchWaterMarkTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: SearchWaterMarkTemplateResponseBody(name='body'),
}

async function searchWaterMarkTemplateWithOptions(request: SearchWaterMarkTemplateRequest, runtime: Util.RuntimeOptions): SearchWaterMarkTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchWaterMarkTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchWaterMarkTemplate(request: SearchWaterMarkTemplateRequest): SearchWaterMarkTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchWaterMarkTemplateWithOptions(request, runtime);
}

model SetAuthConfigRequest {
  ownerId?: string(name='OwnerId'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount'),
  key1?: string(name='Key1'),
  key2?: string(name='Key2'),
}

model SetAuthConfigResponseBody = {
  key2?: string(name='Key2'),
  key1?: string(name='Key1'),
  requestId?: string(name='RequestId'),
}

model SetAuthConfigResponse = {
  headers: map[string]string(name='headers'),
  body: SetAuthConfigResponseBody(name='body'),
}

async function setAuthConfigWithOptions(request: SetAuthConfigRequest, runtime: Util.RuntimeOptions): SetAuthConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetAuthConfig', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setAuthConfig(request: SetAuthConfigRequest): SetAuthConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setAuthConfigWithOptions(request, runtime);
}

model StopIProductionJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model StopIProductionJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model StopIProductionJobResponse = {
  headers: map[string]string(name='headers'),
  body: StopIProductionJobResponseBody(name='body'),
}

async function stopIProductionJobWithOptions(request: StopIProductionJobRequest, runtime: Util.RuntimeOptions): StopIProductionJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('StopIProductionJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function stopIProductionJob(request: StopIProductionJobRequest): StopIProductionJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopIProductionJobWithOptions(request, runtime);
}

model SubmitAnalysisJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  analysisConfig?: string(name='AnalysisConfig'),
  userData?: string(name='UserData'),
  pipelineId?: string(name='PipelineId'),
  priority?: string(name='Priority'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitAnalysisJobResponseBody = {
  requestId?: string(name='RequestId'),
  analysisJob?: {
    creationTime?: string(name='CreationTime'),
    percent?: long(name='Percent'),
    state?: string(name='State'),
    analysisConfig?: {
      qualityControl?: {
        methodStreaming?: string(name='MethodStreaming'),
        rateQuality?: string(name='RateQuality'),
      }(name='QualityControl'),
      propertiesControl?: {
        deinterlace?: string(name='Deinterlace'),
        crop?: {
          top?: string(name='Top'),
          width?: string(name='Width'),
          height?: string(name='Height'),
          left?: string(name='Left'),
          mode?: string(name='Mode'),
        }(name='Crop'),
      }(name='PropertiesControl'),
    }(name='AnalysisConfig'),
    message?: string(name='Message'),
    priority?: string(name='Priority'),
    MNSMessageResult?: {
      messageId?: string(name='MessageId'),
      errorMessage?: string(name='ErrorMessage'),
      errorCode?: string(name='ErrorCode'),
    }(name='MNSMessageResult'),
    templateList?: {
      template?: [ 
      {
        video?: {
          bufsize?: string(name='Bufsize'),
          degrain?: string(name='Degrain'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          pixFmt?: string(name='PixFmt'),
          codec?: string(name='Codec'),
          height?: string(name='Height'),
          qscale?: string(name='Qscale'),
          bitrate?: string(name='Bitrate'),
          maxrate?: string(name='Maxrate'),
          profile?: string(name='Profile'),
          crf?: string(name='Crf'),
          gop?: string(name='Gop'),
          width?: string(name='Width'),
          fps?: string(name='Fps'),
          preset?: string(name='Preset'),
          scanMode?: string(name='ScanMode'),
        }(name='Video'),
        transConfig?: {
          transMode?: string(name='TransMode'),
        }(name='TransConfig'),
        state?: string(name='State'),
        muxConfig?: {
          gif?: {
            finalDelay?: string(name='FinalDelay'),
            loop?: string(name='Loop'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
        }(name='MuxConfig'),
        name?: string(name='Name'),
        audio?: {
          profile?: string(name='Profile'),
          codec?: string(name='Codec'),
          samplerate?: string(name='Samplerate'),
          qscale?: string(name='Qscale'),
          channels?: string(name='Channels'),
          bitrate?: string(name='Bitrate'),
        }(name='Audio'),
        id?: string(name='Id'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
      }
    ](name='Template')
    }(name='TemplateList'),
    userData?: string(name='UserData'),
    code?: string(name='Code'),
    inputFile?: {
      object?: string(name='Object'),
      location?: string(name='Location'),
      bucket?: string(name='Bucket'),
    }(name='InputFile'),
    pipelineId?: string(name='PipelineId'),
    id?: string(name='Id'),
  }(name='AnalysisJob'),
}

model SubmitAnalysisJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitAnalysisJobResponseBody(name='body'),
}

async function submitAnalysisJobWithOptions(request: SubmitAnalysisJobRequest, runtime: Util.RuntimeOptions): SubmitAnalysisJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitAnalysisJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitAnalysisJob(request: SubmitAnalysisJobRequest): SubmitAnalysisJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAnalysisJobWithOptions(request, runtime);
}

model SubmitAnnotationJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  annotationConfig?: string(name='AnnotationConfig'),
  userData?: string(name='UserData'),
  pipelineId?: string(name='PipelineId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitAnnotationJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitAnnotationJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitAnnotationJobResponseBody(name='body'),
}

async function submitAnnotationJobWithOptions(request: SubmitAnnotationJobRequest, runtime: Util.RuntimeOptions): SubmitAnnotationJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitAnnotationJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitAnnotationJob(request: SubmitAnnotationJobRequest): SubmitAnnotationJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAnnotationJobWithOptions(request, runtime);
}

model SubmitAsrJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  pipelineId?: string(name='PipelineId'),
  asrConfig?: string(name='AsrConfig'),
  userData?: string(name='UserData'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitAsrJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitAsrJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitAsrJobResponseBody(name='body'),
}

async function submitAsrJobWithOptions(request: SubmitAsrJobRequest, runtime: Util.RuntimeOptions): SubmitAsrJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitAsrJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitAsrJob(request: SubmitAsrJobRequest): SubmitAsrJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAsrJobWithOptions(request, runtime);
}

model SubmitBeautifyJobsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  beautifyConfig?: string(name='BeautifyConfig'),
  userData?: string(name='UserData'),
  pipelineId?: string(name='PipelineId'),
  async?: boolean(name='Async'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitBeautifyJobsResponseBody = {
  requestId?: string(name='RequestId'),
  jobList?: {
    job?: [ 
    {
      creationTime?: string(name='CreationTime'),
      beautifyConfig?: {
        outputFile?: {
          roleArn?: string(name='RoleArn'),
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='OutputFile'),
      }(name='BeautifyConfig'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      code?: string(name='Code'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      input?: {
        roleArn?: string(name='RoleArn'),
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='Input'),
      MNSMessageResult?: {
        messageId?: string(name='MessageId'),
        errorMessage?: string(name='ErrorMessage'),
        errorCode?: string(name='ErrorCode'),
      }(name='MNSMessageResult'),
      id?: string(name='Id'),
    }
  ](name='Job')
  }(name='JobList'),
}

model SubmitBeautifyJobsResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitBeautifyJobsResponseBody(name='body'),
}

async function submitBeautifyJobsWithOptions(request: SubmitBeautifyJobsRequest, runtime: Util.RuntimeOptions): SubmitBeautifyJobsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitBeautifyJobs', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitBeautifyJobs(request: SubmitBeautifyJobsRequest): SubmitBeautifyJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitBeautifyJobsWithOptions(request, runtime);
}

model SubmitComplexJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  inputs?: string(name='Inputs'),
  complexConfigs?: string(name='ComplexConfigs'),
  transcodeOutput?: string(name='TranscodeOutput'),
  outputBucket?: string(name='OutputBucket'),
  outputLocation?: string(name='OutputLocation'),
  pipelineId?: string(name='PipelineId'),
  userData?: string(name='UserData'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitComplexJobResponseBody = {
  requestId?: string(name='RequestId'),
  complexJob?: {
    creationTime?: string(name='CreationTime'),
    percent?: long(name='Percent'),
    finishTime?: string(name='FinishTime'),
    state?: string(name='State'),
    transcodeOutput?: {
      video?: {
        bufsize?: string(name='Bufsize'),
        degrain?: string(name='Degrain'),
        bitrateBnd?: {
          max?: string(name='Max'),
          min?: string(name='Min'),
        }(name='BitrateBnd'),
        pixFmt?: string(name='PixFmt'),
        pad?: string(name='Pad'),
        codec?: string(name='Codec'),
        height?: string(name='Height'),
        qscale?: string(name='Qscale'),
        crop?: string(name='Crop'),
        bitrate?: string(name='Bitrate'),
        maxrate?: string(name='Maxrate'),
        maxFps?: string(name='MaxFps'),
        profile?: string(name='Profile'),
        crf?: string(name='Crf'),
        gop?: string(name='Gop'),
        width?: string(name='Width'),
        fps?: string(name='Fps'),
        preset?: string(name='Preset'),
        scanMode?: string(name='ScanMode'),
      }(name='Video'),
      transConfig?: {
        isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
        isCheckReso?: string(name='IsCheckReso'),
        transMode?: string(name='TransMode'),
        isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
        adjDarMethod?: string(name='AdjDarMethod'),
        duration?: string(name='Duration'),
        isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
        isCheckResoFail?: string(name='IsCheckResoFail'),
        isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
      }(name='TransConfig'),
      encryption?: {
        type?: string(name='Type'),
        key?: string(name='Key'),
        keyType?: string(name='KeyType'),
        id?: string(name='Id'),
        keyUri?: string(name='KeyUri'),
        skipCnt?: string(name='SkipCnt'),
      }(name='Encryption'),
      waterMarkList?: {
        waterMark?: [ 
        {
          type?: string(name='Type'),
          referPos?: string(name='ReferPos'),
          dx?: string(name='Dx'),
          width?: string(name='Width'),
          height?: string(name='Height'),
          inputFile?: {
            object?: string(name='Object'),
            location?: string(name='Location'),
            bucket?: string(name='Bucket'),
          }(name='InputFile'),
          waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
          dy?: string(name='Dy'),
        }
      ](name='WaterMark')
      }(name='WaterMarkList'),
      deWatermark?: string(name='DeWatermark'),
      waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
      m3U8NonStandardSupport?: {
        TS?: {
          sizeSupport?: boolean(name='SizeSupport'),
          md5Support?: boolean(name='Md5Support'),
        }(name='TS'),
      }(name='M3U8NonStandardSupport'),
      priority?: string(name='Priority'),
      audio?: {
        profile?: string(name='Profile'),
        codec?: string(name='Codec'),
        samplerate?: string(name='Samplerate'),
        qscale?: string(name='Qscale'),
        channels?: string(name='Channels'),
        volume?: {
          method?: string(name='Method'),
          level?: string(name='Level'),
        }(name='Volume'),
        bitrate?: string(name='Bitrate'),
      }(name='Audio'),
      audioStreamMap?: string(name='AudioStreamMap'),
      mergeList?: {
        merge?: [ 
        {
          start?: string(name='Start'),
          roleArn?: string(name='RoleArn'),
          mergeURL?: string(name='MergeURL'),
          duration?: string(name='Duration'),
        }
      ](name='Merge')
      }(name='MergeList'),
      superReso?: {
        isHalfSample?: string(name='IsHalfSample'),
      }(name='SuperReso'),
      userData?: string(name='UserData'),
      digiWaterMark?: {
        type?: string(name='Type'),
        alpha?: string(name='Alpha'),
        inputFile?: {
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='InputFile'),
      }(name='DigiWaterMark'),
      videoStreamMap?: string(name='VideoStreamMap'),
      outputFile?: {
        roleArn?: string(name='RoleArn'),
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='OutputFile'),
      rotate?: string(name='Rotate'),
      container?: {
        format?: string(name='Format'),
      }(name='Container'),
      clip?: {
        timeSpan?: {
          seek?: string(name='Seek'),
          duration?: string(name='Duration'),
        }(name='TimeSpan'),
      }(name='Clip'),
      mergeConfigUrl?: string(name='MergeConfigUrl'),
      muxConfig?: {
        gif?: {
          finalDelay?: string(name='FinalDelay'),
          ditherMode?: string(name='DitherMode'),
          loop?: string(name='Loop'),
          isCustomPalette?: string(name='IsCustomPalette'),
        }(name='Gif'),
        segment?: {
          duration?: string(name='Duration'),
        }(name='Segment'),
      }(name='MuxConfig'),
      templateId?: string(name='TemplateId'),
      subtitleConfig?: {
        extSubtitleList?: {
          extSubtitle?: [ 
          {
            charEnc?: string(name='CharEnc'),
            fontName?: string(name='FontName'),
            input?: {
              object?: string(name='Object'),
              location?: string(name='Location'),
              bucket?: string(name='Bucket'),
            }(name='Input'),
          }
        ](name='ExtSubtitle')
        }(name='ExtSubtitleList'),
        subtitleList?: {
          subtitle?: [ 
          {
            map?: string(name='Map'),
          }
        ](name='Subtitle')
        }(name='SubtitleList'),
      }(name='SubtitleConfig'),
      properties?: {
        width?: string(name='Width'),
        height?: string(name='Height'),
        duration?: string(name='Duration'),
        fps?: string(name='Fps'),
        bitrate?: string(name='Bitrate'),
        fileFormat?: string(name='FileFormat'),
        streams?: {
          videoStreamList?: {
            videoStream?: [ 
            {
              index?: string(name='Index'),
              timebase?: string(name='Timebase'),
              avgFPS?: string(name='AvgFPS'),
              pixFmt?: string(name='PixFmt'),
              sar?: string(name='Sar'),
              lang?: string(name='Lang'),
              codecLongName?: string(name='CodecLongName'),
              height?: string(name='Height'),
              numFrames?: string(name='NumFrames'),
              bitrate?: string(name='Bitrate'),
              codecTagString?: string(name='CodecTagString'),
              hasBFrames?: string(name='HasBFrames'),
              profile?: string(name='Profile'),
              startTime?: string(name='StartTime'),
              networkCost?: {
                preloadTime?: string(name='PreloadTime'),
                avgBitrate?: string(name='AvgBitrate'),
                costBandwidth?: string(name='CostBandwidth'),
              }(name='NetworkCost'),
              dar?: string(name='Dar'),
              codecName?: string(name='CodecName'),
              width?: string(name='Width'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              codecTag?: string(name='CodecTag'),
              codecTimeBase?: string(name='CodecTimeBase'),
              level?: string(name='Level'),
            }
          ](name='VideoStream')
          }(name='VideoStreamList'),
          audioStreamList?: {
            audioStream?: [ 
            {
              timebase?: string(name='Timebase'),
              index?: string(name='Index'),
              sampleFmt?: string(name='SampleFmt'),
              channelLayout?: string(name='ChannelLayout'),
              lang?: string(name='Lang'),
              samplerate?: string(name='Samplerate'),
              codecLongName?: string(name='CodecLongName'),
              channels?: string(name='Channels'),
              numFrames?: string(name='NumFrames'),
              bitrate?: string(name='Bitrate'),
              codecTagString?: string(name='CodecTagString'),
              startTime?: string(name='StartTime'),
              codecName?: string(name='CodecName'),
              duration?: string(name='Duration'),
              codecTag?: string(name='CodecTag'),
              codecTimeBase?: string(name='CodecTimeBase'),
            }
          ](name='AudioStream')
          }(name='AudioStreamList'),
          subtitleStreamList?: {
            subtitleStream?: [ 
            {
              index?: string(name='Index'),
              lang?: string(name='Lang'),
            }
          ](name='SubtitleStream')
          }(name='SubtitleStreamList'),
        }(name='Streams'),
        format?: {
          startTime?: string(name='StartTime'),
          numPrograms?: string(name='NumPrograms'),
          size?: string(name='Size'),
          numStreams?: string(name='NumStreams'),
          formatLongName?: string(name='FormatLongName'),
          duration?: string(name='Duration'),
          bitrate?: string(name='Bitrate'),
          formatName?: string(name='FormatName'),
        }(name='Format'),
        fileSize?: string(name='FileSize'),
      }(name='Properties'),
    }(name='transcodeOutput'),
    message?: string(name='Message'),
    MNSMessageResult?: {
      messageId?: string(name='MessageId'),
      errorMessage?: string(name='ErrorMessage'),
      errorCode?: string(name='ErrorCode'),
    }(name='MNSMessageResult'),
    complexEditingConfigs?: {
      complexEditingConfigs?: [ 
      {
        editing?: {
          timeline?: {
            trackList?: {
              track?: [ 
              {
                type?: string(name='Type'),
                order?: string(name='Order'),
                id?: string(name='Id'),
                clips?: {
                  clip?: [ 
                  {
                    clipsConfig?: {
                      clipsConfigVideo?: {
                        t?: string(name='T'),
                        l?: string(name='L'),
                      }(name='ClipsConfigVideo'),
                    }(name='ClipsConfig'),
                    out?: string(name='Out'),
                    in?: string(name='In'),
                    clipID?: string(name='clipID'),
                  }
                ](name='Clip')
                }(name='Clips'),
              }
            ](name='Track')
            }(name='TrackList'),
            timelineConfig?: {
              timelineConfigAudio?: {
                channelLayout?: string(name='ChannelLayout'),
                samplerate?: string(name='Samplerate'),
                channels?: string(name='Channels'),
              }(name='TimelineConfigAudio'),
              timelineConfigVideo?: {
                bgColor?: string(name='BgColor'),
                width?: string(name='Width'),
                renderRatio?: string(name='RenderRatio'),
                isGpuData?: string(name='IsGpuData'),
                height?: string(name='Height'),
                isOneTrackData?: string(name='IsOneTrackData'),
                fps?: string(name='Fps'),
                reclosePrec?: string(name='ReclosePrec'),
              }(name='TimelineConfigVideo'),
            }(name='TimelineConfig'),
          }(name='Timeline'),
          clipList?: {
            clip?: [ 
            {
              type?: string(name='Type'),
              sourceID?: string(name='SourceID'),
              effects?: {
                effect?: [ 
                {
                  effect?: string(name='Effect'),
                  effectConfig?: string(name='EffectConfig'),
                }
              ](name='Effect')
              }(name='Effects'),
              sourceType?: string(name='SourceType'),
              sourceStrmMap?: string(name='SourceStrmMap'),
              out?: string(name='Out'),
              in?: string(name='In'),
              id?: string(name='Id'),
            }
          ](name='Clip')
          }(name='ClipList'),
        }(name='Editing'),
      }
    ](name='ComplexEditingConfigs')
    }(name='ComplexEditingConfigs'),
    inputs?: {
      inputs?: [ 
      {
        editingInputs?: {
          editingInput?: [ 
          {
            inputFile?: {
              object?: string(name='Object'),
              location?: string(name='Location'),
              bucket?: string(name='Bucket'),
            }(name='InputFile'),
            inputConfig?: {
              isNormalSar?: string(name='IsNormalSar'),
              deinterlaceMethod?: string(name='DeinterlaceMethod'),
            }(name='InputConfig'),
            id?: string(name='Id'),
          }
        ](name='EditingInput')
        }(name='EditingInputs'),
      }
    ](name='Inputs')
    }(name='Inputs'),
    jobId?: string(name='JobId'),
    code?: string(name='Code'),
    pipelineId?: string(name='PipelineId'),
  }(name='ComplexJob'),
}

model SubmitComplexJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitComplexJobResponseBody(name='body'),
}

async function submitComplexJobWithOptions(request: SubmitComplexJobRequest, runtime: Util.RuntimeOptions): SubmitComplexJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitComplexJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitComplexJob(request: SubmitComplexJobRequest): SubmitComplexJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitComplexJobWithOptions(request, runtime);
}

model SubmitCoverJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  coverConfig?: string(name='CoverConfig'),
  userData?: string(name='UserData'),
  pipelineId?: string(name='PipelineId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitCoverJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitCoverJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitCoverJobResponseBody(name='body'),
}

async function submitCoverJobWithOptions(request: SubmitCoverJobRequest, runtime: Util.RuntimeOptions): SubmitCoverJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitCoverJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitCoverJob(request: SubmitCoverJobRequest): SubmitCoverJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitCoverJobWithOptions(request, runtime);
}

model SubmitEditingJobsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  editingInputs?: string(name='EditingInputs'),
  editingJobOutputs?: string(name='EditingJobOutputs'),
  outputBucket?: string(name='OutputBucket'),
  outputLocation?: string(name='OutputLocation'),
  pipelineId?: string(name='PipelineId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitEditingJobsResponseBody = {
  jobResultList?: {
    jobResult?: [ 
    {
      job?: {
        creationTime?: string(name='CreationTime'),
        percent?: long(name='Percent'),
        finishTime?: string(name='FinishTime'),
        state?: string(name='State'),
        jobId?: string(name='JobId'),
        code?: string(name='Code'),
        message?: string(name='Message'),
        editingInputs?: {
          editingInput?: [ 
          {
            inputFile?: {
              object?: string(name='Object'),
              location?: string(name='Location'),
              bucket?: string(name='Bucket'),
            }(name='InputFile'),
            inputConfig?: {
              isNormalSar?: string(name='IsNormalSar'),
              deinterlaceMethod?: string(name='DeinterlaceMethod'),
            }(name='InputConfig'),
            id?: string(name='Id'),
          }
        ](name='EditingInput')
        }(name='EditingInputs'),
        pipelineId?: string(name='PipelineId'),
        editingConfig?: {
          video?: {
            bufsize?: string(name='Bufsize'),
            degrain?: string(name='Degrain'),
            bitrateBnd?: {
              max?: string(name='Max'),
              min?: string(name='Min'),
            }(name='BitrateBnd'),
            pixFmt?: string(name='PixFmt'),
            pad?: string(name='Pad'),
            codec?: string(name='Codec'),
            height?: string(name='Height'),
            qscale?: string(name='Qscale'),
            crop?: string(name='Crop'),
            bitrate?: string(name='Bitrate'),
            maxrate?: string(name='Maxrate'),
            maxFps?: string(name='MaxFps'),
            profile?: string(name='Profile'),
            crf?: string(name='Crf'),
            gop?: string(name='Gop'),
            width?: string(name='Width'),
            fps?: string(name='Fps'),
            preset?: string(name='Preset'),
            scanMode?: string(name='ScanMode'),
          }(name='Video'),
          transConfig?: {
            isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
            isCheckReso?: string(name='IsCheckReso'),
            transMode?: string(name='TransMode'),
            isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
            adjDarMethod?: string(name='AdjDarMethod'),
            duration?: string(name='Duration'),
            isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
            isCheckResoFail?: string(name='IsCheckResoFail'),
            isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
          }(name='TransConfig'),
          encryption?: {
            type?: string(name='Type'),
            key?: string(name='Key'),
            keyType?: string(name='KeyType'),
            id?: string(name='Id'),
            keyUri?: string(name='KeyUri'),
            skipCnt?: string(name='SkipCnt'),
          }(name='Encryption'),
          waterMarkList?: {
            waterMark?: [ 
            {
              type?: string(name='Type'),
              referPos?: string(name='ReferPos'),
              dx?: string(name='Dx'),
              width?: string(name='Width'),
              height?: string(name='Height'),
              inputFile?: {
                object?: string(name='Object'),
                location?: string(name='Location'),
                bucket?: string(name='Bucket'),
              }(name='InputFile'),
              waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
              dy?: string(name='Dy'),
            }
          ](name='WaterMark')
          }(name='WaterMarkList'),
          deWatermark?: string(name='DeWatermark'),
          waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
          m3U8NonStandardSupport?: {
            TS?: {
              sizeSupport?: boolean(name='SizeSupport'),
              md5Support?: boolean(name='Md5Support'),
            }(name='TS'),
          }(name='M3U8NonStandardSupport'),
          priority?: string(name='Priority'),
          audio?: {
            profile?: string(name='Profile'),
            codec?: string(name='Codec'),
            samplerate?: string(name='Samplerate'),
            qscale?: string(name='Qscale'),
            channels?: string(name='Channels'),
            volume?: {
              method?: string(name='Method'),
              level?: string(name='Level'),
            }(name='Volume'),
            bitrate?: string(name='Bitrate'),
          }(name='Audio'),
          audioStreamMap?: string(name='AudioStreamMap'),
          mergeList?: {
            merge?: [ 
            {
              start?: string(name='Start'),
              roleArn?: string(name='RoleArn'),
              mergeURL?: string(name='MergeURL'),
              duration?: string(name='Duration'),
            }
          ](name='Merge')
          }(name='MergeList'),
          superReso?: {
            isHalfSample?: string(name='IsHalfSample'),
          }(name='SuperReso'),
          userData?: string(name='UserData'),
          digiWaterMark?: {
            type?: string(name='Type'),
            alpha?: string(name='Alpha'),
            inputFile?: {
              object?: string(name='Object'),
              location?: string(name='Location'),
              bucket?: string(name='Bucket'),
            }(name='InputFile'),
          }(name='DigiWaterMark'),
          videoStreamMap?: string(name='VideoStreamMap'),
          outputFile?: {
            roleArn?: string(name='RoleArn'),
            object?: string(name='Object'),
            location?: string(name='Location'),
            bucket?: string(name='Bucket'),
          }(name='OutputFile'),
          rotate?: string(name='Rotate'),
          editing?: {
            timeline?: {
              trackList?: {
                track?: [ 
                {
                  type?: string(name='Type'),
                  order?: string(name='Order'),
                  id?: string(name='Id'),
                  clips?: {
                    clip?: [ 
                    {
                      clipsConfig?: {
                        clipsConfigVideo?: {
                          t?: string(name='T'),
                          l?: string(name='L'),
                        }(name='ClipsConfigVideo'),
                      }(name='ClipsConfig'),
                      out?: string(name='Out'),
                      in?: string(name='In'),
                      clipID?: string(name='clipID'),
                    }
                  ](name='Clip')
                  }(name='Clips'),
                }
              ](name='Track')
              }(name='TrackList'),
              timelineConfig?: {
                timelineConfigAudio?: {
                  channelLayout?: string(name='ChannelLayout'),
                  samplerate?: string(name='Samplerate'),
                  channels?: string(name='Channels'),
                }(name='TimelineConfigAudio'),
                timelineConfigVideo?: {
                  bgColor?: string(name='BgColor'),
                  width?: string(name='Width'),
                  renderRatio?: string(name='RenderRatio'),
                  isGpuData?: string(name='IsGpuData'),
                  height?: string(name='Height'),
                  isOneTrackData?: string(name='IsOneTrackData'),
                  fps?: string(name='Fps'),
                  reclosePrec?: string(name='ReclosePrec'),
                }(name='TimelineConfigVideo'),
              }(name='TimelineConfig'),
            }(name='Timeline'),
            clipList?: {
              clip?: [ 
              {
                type?: string(name='Type'),
                sourceID?: string(name='SourceID'),
                effects?: {
                  effect?: [ 
                  {
                    effect?: string(name='Effect'),
                    effectConfig?: string(name='EffectConfig'),
                  }
                ](name='Effect')
                }(name='Effects'),
                sourceType?: string(name='SourceType'),
                sourceStrmMap?: string(name='SourceStrmMap'),
                out?: string(name='Out'),
                in?: string(name='In'),
                id?: string(name='Id'),
              }
            ](name='Clip')
            }(name='ClipList'),
          }(name='Editing'),
          container?: {
            format?: string(name='Format'),
          }(name='Container'),
          clip?: {
            timeSpan?: {
              seek?: string(name='Seek'),
              duration?: string(name='Duration'),
            }(name='TimeSpan'),
          }(name='Clip'),
          mergeConfigUrl?: string(name='MergeConfigUrl'),
          muxConfig?: {
            gif?: {
              finalDelay?: string(name='FinalDelay'),
              ditherMode?: string(name='DitherMode'),
              loop?: string(name='Loop'),
              isCustomPalette?: string(name='IsCustomPalette'),
            }(name='Gif'),
            segment?: {
              duration?: string(name='Duration'),
            }(name='Segment'),
          }(name='MuxConfig'),
          templateId?: string(name='TemplateId'),
          subtitleConfig?: {
            extSubtitleList?: {
              extSubtitle?: [ 
              {
                charEnc?: string(name='CharEnc'),
                fontName?: string(name='FontName'),
                input?: {
                  object?: string(name='Object'),
                  location?: string(name='Location'),
                  bucket?: string(name='Bucket'),
                }(name='Input'),
              }
            ](name='ExtSubtitle')
            }(name='ExtSubtitleList'),
            subtitleList?: {
              subtitle?: [ 
              {
                map?: string(name='Map'),
              }
            ](name='Subtitle')
            }(name='SubtitleList'),
          }(name='SubtitleConfig'),
          properties?: {
            width?: string(name='Width'),
            height?: string(name='Height'),
            duration?: string(name='Duration'),
            fps?: string(name='Fps'),
            bitrate?: string(name='Bitrate'),
            fileFormat?: string(name='FileFormat'),
            streams?: {
              videoStreamList?: {
                videoStream?: [ 
                {
                  index?: string(name='Index'),
                  timebase?: string(name='Timebase'),
                  avgFPS?: string(name='AvgFPS'),
                  pixFmt?: string(name='PixFmt'),
                  sar?: string(name='Sar'),
                  lang?: string(name='Lang'),
                  codecLongName?: string(name='CodecLongName'),
                  height?: string(name='Height'),
                  numFrames?: string(name='NumFrames'),
                  bitrate?: string(name='Bitrate'),
                  codecTagString?: string(name='CodecTagString'),
                  hasBFrames?: string(name='HasBFrames'),
                  profile?: string(name='Profile'),
                  startTime?: string(name='StartTime'),
                  networkCost?: {
                    preloadTime?: string(name='PreloadTime'),
                    avgBitrate?: string(name='AvgBitrate'),
                    costBandwidth?: string(name='CostBandwidth'),
                  }(name='NetworkCost'),
                  dar?: string(name='Dar'),
                  codecName?: string(name='CodecName'),
                  width?: string(name='Width'),
                  duration?: string(name='Duration'),
                  fps?: string(name='Fps'),
                  codecTag?: string(name='CodecTag'),
                  codecTimeBase?: string(name='CodecTimeBase'),
                  level?: string(name='Level'),
                }
              ](name='VideoStream')
              }(name='VideoStreamList'),
              audioStreamList?: {
                audioStream?: [ 
                {
                  timebase?: string(name='Timebase'),
                  index?: string(name='Index'),
                  sampleFmt?: string(name='SampleFmt'),
                  channelLayout?: string(name='ChannelLayout'),
                  lang?: string(name='Lang'),
                  samplerate?: string(name='Samplerate'),
                  codecLongName?: string(name='CodecLongName'),
                  channels?: string(name='Channels'),
                  numFrames?: string(name='NumFrames'),
                  bitrate?: string(name='Bitrate'),
                  codecTagString?: string(name='CodecTagString'),
                  startTime?: string(name='StartTime'),
                  codecName?: string(name='CodecName'),
                  duration?: string(name='Duration'),
                  codecTag?: string(name='CodecTag'),
                  codecTimeBase?: string(name='CodecTimeBase'),
                }
              ](name='AudioStream')
              }(name='AudioStreamList'),
              subtitleStreamList?: {
                subtitleStream?: [ 
                {
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                }
              ](name='SubtitleStream')
              }(name='SubtitleStreamList'),
            }(name='Streams'),
            format?: {
              startTime?: string(name='StartTime'),
              numPrograms?: string(name='NumPrograms'),
              size?: string(name='Size'),
              numStreams?: string(name='NumStreams'),
              formatLongName?: string(name='FormatLongName'),
              duration?: string(name='Duration'),
              bitrate?: string(name='Bitrate'),
              formatName?: string(name='FormatName'),
            }(name='Format'),
            fileSize?: string(name='FileSize'),
          }(name='Properties'),
        }(name='EditingConfig'),
        MNSMessageResult?: {
          messageId?: string(name='MessageId'),
          errorMessage?: string(name='ErrorMessage'),
          errorCode?: string(name='ErrorCode'),
        }(name='MNSMessageResult'),
      }(name='Job'),
      success?: boolean(name='Success'),
      code?: string(name='Code'),
      message?: string(name='Message'),
    }
  ](name='JobResult')
  }(name='JobResultList'),
  requestId?: string(name='RequestId'),
}

model SubmitEditingJobsResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitEditingJobsResponseBody(name='body'),
}

async function submitEditingJobsWithOptions(request: SubmitEditingJobsRequest, runtime: Util.RuntimeOptions): SubmitEditingJobsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitEditingJobs', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitEditingJobs(request: SubmitEditingJobsRequest): SubmitEditingJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitEditingJobsWithOptions(request, runtime);
}

model SubmitFacerecogJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  facerecogConfig?: string(name='FacerecogConfig'),
  userData?: string(name='UserData'),
  pipelineId?: string(name='PipelineId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitFacerecogJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitFacerecogJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFacerecogJobResponseBody(name='body'),
}

async function submitFacerecogJobWithOptions(request: SubmitFacerecogJobRequest, runtime: Util.RuntimeOptions): SubmitFacerecogJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitFacerecogJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitFacerecogJob(request: SubmitFacerecogJobRequest): SubmitFacerecogJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFacerecogJobWithOptions(request, runtime);
}

model SubmitFpCompareJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  masterMedia?: string(name='MasterMedia'),
  queryMedia?: string(name='QueryMedia'),
  pipelineId?: string(name='PipelineId'),
  fpDBId?: string(name='FpDBId'),
  matchedFrameStorage?: string(name='MatchedFrameStorage'),
  userData?: string(name='UserData'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitFpCompareJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitFpCompareJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFpCompareJobResponseBody(name='body'),
}

async function submitFpCompareJobWithOptions(request: SubmitFpCompareJobRequest, runtime: Util.RuntimeOptions): SubmitFpCompareJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitFpCompareJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitFpCompareJob(request: SubmitFpCompareJobRequest): SubmitFpCompareJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFpCompareJobWithOptions(request, runtime);
}

model SubmitFpDBDeleteJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pipelineId?: string(name='PipelineId'),
  fpDBId?: string(name='FpDBId'),
  userData?: string(name='UserData'),
  delType?: string(name='DelType'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitFpDBDeleteJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitFpDBDeleteJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFpDBDeleteJobResponseBody(name='body'),
}

async function submitFpDBDeleteJobWithOptions(request: SubmitFpDBDeleteJobRequest, runtime: Util.RuntimeOptions): SubmitFpDBDeleteJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitFpDBDeleteJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitFpDBDeleteJob(request: SubmitFpDBDeleteJobRequest): SubmitFpDBDeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFpDBDeleteJobWithOptions(request, runtime);
}

model SubmitFpFileDeleteJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pipelineId?: string(name='PipelineId'),
  fpDBId?: string(name='FpDBId'),
  userData?: string(name='UserData'),
  fileIds?: string(name='FileIds'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitFpFileDeleteJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitFpFileDeleteJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFpFileDeleteJobResponseBody(name='body'),
}

async function submitFpFileDeleteJobWithOptions(request: SubmitFpFileDeleteJobRequest, runtime: Util.RuntimeOptions): SubmitFpFileDeleteJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitFpFileDeleteJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitFpFileDeleteJob(request: SubmitFpFileDeleteJobRequest): SubmitFpFileDeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFpFileDeleteJobWithOptions(request, runtime);
}

model SubmitFpShotJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  pipelineId?: string(name='PipelineId'),
  fpShotConfig?: string(name='FpShotConfig'),
  userData?: string(name='UserData'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitFpShotJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitFpShotJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFpShotJobResponseBody(name='body'),
}

async function submitFpShotJobWithOptions(request: SubmitFpShotJobRequest, runtime: Util.RuntimeOptions): SubmitFpShotJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitFpShotJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitFpShotJob(request: SubmitFpShotJobRequest): SubmitFpShotJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFpShotJobWithOptions(request, runtime);
}

model SubmitImageQualityJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  pipelineId?: string(name='PipelineId'),
  userData?: string(name='UserData'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitImageQualityJobResponseBody = {
  requestId?: string(name='RequestId'),
  imageQualityJob?: {
    creationTime?: string(name='CreationTime'),
    result?: {
      code?: string(name='Code'),
      message?: string(name='Message'),
      score?: string(name='Score'),
    }(name='Result'),
    state?: string(name='State'),
    jobId?: string(name='JobId'),
    userData?: string(name='UserData'),
    pipelineId?: string(name='PipelineId'),
    input?: {
      url?: string(name='Url'),
      object?: string(name='Object'),
      location?: string(name='Location'),
      bucket?: string(name='Bucket'),
    }(name='Input'),
  }(name='ImageQualityJob'),
}

model SubmitImageQualityJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitImageQualityJobResponseBody(name='body'),
}

async function submitImageQualityJobWithOptions(request: SubmitImageQualityJobRequest, runtime: Util.RuntimeOptions): SubmitImageQualityJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitImageQualityJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitImageQualityJob(request: SubmitImageQualityJobRequest): SubmitImageQualityJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitImageQualityJobWithOptions(request, runtime);
}

model SubmitImageSearchJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  inputVideo?: string(name='InputVideo'),
  inputImage?: string(name='InputImage'),
  pipelineId?: string(name='PipelineId'),
  fpDBId?: string(name='FpDBId'),
  config?: string(name='Config'),
  userData?: string(name='UserData'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitImageSearchJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitImageSearchJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitImageSearchJobResponseBody(name='body'),
}

async function submitImageSearchJobWithOptions(request: SubmitImageSearchJobRequest, runtime: Util.RuntimeOptions): SubmitImageSearchJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitImageSearchJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitImageSearchJob(request: SubmitImageSearchJobRequest): SubmitImageSearchJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitImageSearchJobWithOptions(request, runtime);
}

model SubmitInnerJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pipelineId?: string(name='PipelineId'),
  video?: string(name='Video'),
  images?: string(name='Images'),
  uid?: long(name='Uid'),
  config?: string(name='Config'),
}

model SubmitInnerJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitInnerJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitInnerJobResponseBody(name='body'),
}

async function submitInnerJobWithOptions(request: SubmitInnerJobRequest, runtime: Util.RuntimeOptions): SubmitInnerJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitInnerJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitInnerJob(request: SubmitInnerJobRequest): SubmitInnerJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitInnerJobWithOptions(request, runtime);
}

model SubmitIProductionJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  functionName?: string(name='FunctionName'),
  modelId?: string(name='ModelId'),
  jobParams?: string(name='JobParams'),
  scheduleParams?: string(name='ScheduleParams'),
  notifyUrl?: string(name='NotifyUrl'),
  userData?: string(name='UserData'),
  pipelineId?: string(name='PipelineId'),
  ownerAccount?: string(name='OwnerAccount'),
  input?: string(name='Input'),
  output?: string(name='Output'),
}

model SubmitIProductionJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
  result?: string(name='Result'),
}

model SubmitIProductionJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitIProductionJobResponseBody(name='body'),
}

async function submitIProductionJobWithOptions(request: SubmitIProductionJobRequest, runtime: Util.RuntimeOptions): SubmitIProductionJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitIProductionJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitIProductionJob(request: SubmitIProductionJobRequest): SubmitIProductionJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitIProductionJobWithOptions(request, runtime);
}

model SubmitJobsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  outputs?: string(name='Outputs'),
  outputBucket?: string(name='OutputBucket'),
  outputLocation?: string(name='OutputLocation'),
  pipelineId?: string(name='PipelineId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitJobsResponseBody = {
  jobResultList?: {
    jobResult?: [ 
    {
      job?: {
        creationTime?: string(name='CreationTime'),
        percent?: long(name='Percent'),
        finishTime?: string(name='FinishTime'),
        state?: string(name='State'),
        jobId?: string(name='JobId'),
        code?: string(name='Code'),
        message?: string(name='Message'),
        output?: {
          video?: {
            bufsize?: string(name='Bufsize'),
            degrain?: string(name='Degrain'),
            bitrateBnd?: {
              max?: string(name='Max'),
              min?: string(name='Min'),
            }(name='BitrateBnd'),
            pixFmt?: string(name='PixFmt'),
            pad?: string(name='Pad'),
            codec?: string(name='Codec'),
            height?: string(name='Height'),
            qscale?: string(name='Qscale'),
            crop?: string(name='Crop'),
            bitrate?: string(name='Bitrate'),
            maxrate?: string(name='Maxrate'),
            maxFps?: string(name='MaxFps'),
            profile?: string(name='Profile'),
            crf?: string(name='Crf'),
            gop?: string(name='Gop'),
            width?: string(name='Width'),
            fps?: string(name='Fps'),
            preset?: string(name='Preset'),
            scanMode?: string(name='ScanMode'),
            resoPriority?: string(name='ResoPriority'),
          }(name='Video'),
          transConfig?: {
            isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
            transMode?: string(name='TransMode'),
            isCheckReso?: string(name='IsCheckReso'),
            isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
            adjDarMethod?: string(name='AdjDarMethod'),
            isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
            isCheckResoFail?: string(name='IsCheckResoFail'),
            isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
          }(name='TransConfig'),
          encryption?: {
            type?: string(name='Type'),
            key?: string(name='Key'),
            keyType?: string(name='KeyType'),
            id?: string(name='Id'),
            keyUri?: string(name='KeyUri'),
            skipCnt?: string(name='SkipCnt'),
          }(name='Encryption'),
          waterMarkList?: {
            waterMark?: [ 
            {
              type?: string(name='Type'),
              referPos?: string(name='ReferPos'),
              dx?: string(name='Dx'),
              width?: string(name='Width'),
              height?: string(name='Height'),
              inputFile?: {
                object?: string(name='Object'),
                location?: string(name='Location'),
                bucket?: string(name='Bucket'),
              }(name='InputFile'),
              waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
              dy?: string(name='Dy'),
            }
          ](name='WaterMark')
          }(name='WaterMarkList'),
          waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
          deWatermark?: string(name='DeWatermark'),
          m3U8NonStandardSupport?: {
            TS?: {
              sizeSupport?: boolean(name='SizeSupport'),
              md5Support?: boolean(name='Md5Support'),
            }(name='TS'),
          }(name='M3U8NonStandardSupport'),
          priority?: string(name='Priority'),
          audio?: {
            profile?: string(name='Profile'),
            codec?: string(name='Codec'),
            samplerate?: string(name='Samplerate'),
            qscale?: string(name='Qscale'),
            channels?: string(name='Channels'),
            volume?: {
              method?: string(name='Method'),
              level?: string(name='Level'),
            }(name='Volume'),
            bitrate?: string(name='Bitrate'),
          }(name='Audio'),
          audioStreamMap?: string(name='AudioStreamMap'),
          mergeList?: {
            merge?: [ 
            {
              start?: string(name='Start'),
              roleArn?: string(name='RoleArn'),
              mergeURL?: string(name='MergeURL'),
              duration?: string(name='Duration'),
            }
          ](name='Merge')
          }(name='MergeList'),
          superReso?: {
            isHalfSample?: string(name='IsHalfSample'),
          }(name='SuperReso'),
          userData?: string(name='UserData'),
          outSubtitleList?: {
            outSubtitle?: [ 
            {
              map?: string(name='Map'),
              outSubtitleFile?: {
                roleArn?: string(name='RoleArn'),
                object?: string(name='Object'),
                location?: string(name='Location'),
                bucket?: string(name='Bucket'),
              }(name='OutSubtitleFile'),
              success?: boolean(name='Success'),
              message?: string(name='Message'),
            }
          ](name='OutSubtitle')
          }(name='OutSubtitleList'),
          digiWaterMark?: {
            type?: string(name='Type'),
            alpha?: string(name='Alpha'),
            inputFile?: {
              object?: string(name='Object'),
              location?: string(name='Location'),
              bucket?: string(name='Bucket'),
            }(name='InputFile'),
          }(name='DigiWaterMark'),
          videoStreamMap?: string(name='VideoStreamMap'),
          outputFile?: {
            roleArn?: string(name='RoleArn'),
            object?: string(name='Object'),
            location?: string(name='Location'),
            bucket?: string(name='Bucket'),
          }(name='OutputFile'),
          amixList?: {
            amix?: [ 
            {
              map?: string(name='Map'),
              start?: string(name='Start'),
              amixURL?: string(name='AmixURL'),
              duration?: string(name='Duration'),
              mixDurMode?: string(name='MixDurMode'),
            }
          ](name='Amix')
          }(name='AmixList'),
          rotate?: string(name='Rotate'),
          container?: {
            format?: string(name='Format'),
          }(name='Container'),
          clip?: {
            timeSpan?: {
              seek?: string(name='Seek'),
              duration?: string(name='Duration'),
            }(name='TimeSpan'),
          }(name='Clip'),
          mergeConfigUrl?: string(name='MergeConfigUrl'),
          openingList?: {
            opening?: [ 
            {
              openUrl?: string(name='openUrl'),
              start?: string(name='Start'),
              width?: string(name='Width'),
              height?: string(name='Height'),
            }
          ](name='Opening')
          }(name='OpeningList'),
          muxConfig?: {
            webp?: {
              loop?: string(name='Loop'),
            }(name='Webp'),
            gif?: {
              finalDelay?: string(name='FinalDelay'),
              ditherMode?: string(name='DitherMode'),
              loop?: string(name='Loop'),
              isCustomPalette?: string(name='IsCustomPalette'),
            }(name='Gif'),
            segment?: {
              duration?: string(name='Duration'),
            }(name='Segment'),
          }(name='MuxConfig'),
          tailSlateList?: {
            tailSlate?: [ 
            {
              start?: string(name='Start'),
              bgColor?: string(name='BgColor'),
              isMergeAudio?: boolean(name='IsMergeAudio'),
              width?: string(name='Width'),
              height?: string(name='Height'),
              blendDuration?: string(name='BlendDuration'),
              tailUrl?: string(name='TailUrl'),
            }
          ](name='TailSlate')
          }(name='TailSlateList'),
          templateId?: string(name='TemplateId'),
          subtitleConfig?: {
            extSubtitleList?: {
              extSubtitle?: [ 
              {
                charEnc?: string(name='CharEnc'),
                fontName?: string(name='FontName'),
                input?: {
                  object?: string(name='Object'),
                  location?: string(name='Location'),
                  bucket?: string(name='Bucket'),
                }(name='Input'),
              }
            ](name='ExtSubtitle')
            }(name='ExtSubtitleList'),
            subtitleList?: {
              subtitle?: [ 
              {
                map?: string(name='Map'),
              }
            ](name='Subtitle')
            }(name='SubtitleList'),
          }(name='SubtitleConfig'),
          properties?: {
            width?: string(name='Width'),
            height?: string(name='Height'),
            duration?: string(name='Duration'),
            fps?: string(name='Fps'),
            bitrate?: string(name='Bitrate'),
            fileFormat?: string(name='FileFormat'),
            streams?: {
              videoStreamList?: {
                videoStream?: [ 
                {
                  index?: string(name='Index'),
                  timebase?: string(name='Timebase'),
                  avgFPS?: string(name='AvgFPS'),
                  pixFmt?: string(name='PixFmt'),
                  sar?: string(name='Sar'),
                  lang?: string(name='Lang'),
                  codecLongName?: string(name='CodecLongName'),
                  height?: string(name='Height'),
                  numFrames?: string(name='NumFrames'),
                  bitrate?: string(name='Bitrate'),
                  codecTagString?: string(name='CodecTagString'),
                  hasBFrames?: string(name='HasBFrames'),
                  profile?: string(name='Profile'),
                  startTime?: string(name='StartTime'),
                  networkCost?: {
                    preloadTime?: string(name='PreloadTime'),
                    avgBitrate?: string(name='AvgBitrate'),
                    costBandwidth?: string(name='CostBandwidth'),
                  }(name='NetworkCost'),
                  dar?: string(name='Dar'),
                  codecName?: string(name='CodecName'),
                  width?: string(name='Width'),
                  duration?: string(name='Duration'),
                  fps?: string(name='Fps'),
                  codecTag?: string(name='CodecTag'),
                  codecTimeBase?: string(name='CodecTimeBase'),
                  level?: string(name='Level'),
                }
              ](name='VideoStream')
              }(name='VideoStreamList'),
              audioStreamList?: {
                audioStream?: [ 
                {
                  timebase?: string(name='Timebase'),
                  index?: string(name='Index'),
                  sampleFmt?: string(name='SampleFmt'),
                  channelLayout?: string(name='ChannelLayout'),
                  lang?: string(name='Lang'),
                  samplerate?: string(name='Samplerate'),
                  codecLongName?: string(name='CodecLongName'),
                  channels?: string(name='Channels'),
                  numFrames?: string(name='NumFrames'),
                  bitrate?: string(name='Bitrate'),
                  codecTagString?: string(name='CodecTagString'),
                  startTime?: string(name='StartTime'),
                  codecName?: string(name='CodecName'),
                  duration?: string(name='Duration'),
                  codecTag?: string(name='CodecTag'),
                  codecTimeBase?: string(name='CodecTimeBase'),
                }
              ](name='AudioStream')
              }(name='AudioStreamList'),
              subtitleStreamList?: {
                subtitleStream?: [ 
                {
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                }
              ](name='SubtitleStream')
              }(name='SubtitleStreamList'),
            }(name='Streams'),
            format?: {
              startTime?: string(name='StartTime'),
              numPrograms?: string(name='NumPrograms'),
              size?: string(name='Size'),
              numStreams?: string(name='NumStreams'),
              formatLongName?: string(name='FormatLongName'),
              duration?: string(name='Duration'),
              bitrate?: string(name='Bitrate'),
              formatName?: string(name='FormatName'),
            }(name='Format'),
            fileSize?: string(name='FileSize'),
          }(name='Properties'),
        }(name='Output'),
        pipelineId?: string(name='PipelineId'),
        input?: {
          object?: string(name='Object'),
          location?: string(name='Location'),
          bucket?: string(name='Bucket'),
        }(name='Input'),
        MNSMessageResult?: {
          messageId?: string(name='MessageId'),
          errorMessage?: string(name='ErrorMessage'),
          errorCode?: string(name='ErrorCode'),
        }(name='MNSMessageResult'),
      }(name='Job'),
      success?: boolean(name='Success'),
      code?: string(name='Code'),
      message?: string(name='Message'),
    }
  ](name='JobResult')
  }(name='JobResultList'),
  requestId?: string(name='RequestId'),
}

model SubmitJobsResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitJobsResponseBody(name='body'),
}

async function submitJobsWithOptions(request: SubmitJobsRequest, runtime: Util.RuntimeOptions): SubmitJobsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitJobs', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitJobs(request: SubmitJobsRequest): SubmitJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitJobsWithOptions(request, runtime);
}

model SubmitMCJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  video?: string(name='Video'),
  images?: string(name='Images'),
  texts?: string(name='Texts'),
  pipelineId?: string(name='PipelineId'),
  censorConfig?: string(name='CensorConfig'),
  userData?: string(name='UserData'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitMCJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitMCJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitMCJobResponseBody(name='body'),
}

async function submitMCJobWithOptions(request: SubmitMCJobRequest, runtime: Util.RuntimeOptions): SubmitMCJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitMCJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitMCJob(request: SubmitMCJobRequest): SubmitMCJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMCJobWithOptions(request, runtime);
}

model SubmitMcuJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  input?: string(name='Input'),
  pipelineId?: string(name='PipelineId'),
  templateId?: string(name='TemplateId'),
  template?: string(name='Template'),
  userData?: string(name='UserData'),
}

model SubmitMcuJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitMcuJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitMcuJobResponseBody(name='body'),
}

async function submitMcuJobWithOptions(request: SubmitMcuJobRequest, runtime: Util.RuntimeOptions): SubmitMcuJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitMcuJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitMcuJob(request: SubmitMcuJobRequest): SubmitMcuJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMcuJobWithOptions(request, runtime);
}

model SubmitMediaCensorJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  coverImages?: string(name='CoverImages'),
  title?: string(name='Title'),
  description?: string(name='Description'),
  barrages?: string(name='Barrages'),
  pipelineId?: string(name='PipelineId'),
  videoCensorConfig?: string(name='VideoCensorConfig'),
  userData?: string(name='UserData'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitMediaCensorJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitMediaCensorJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitMediaCensorJobResponseBody(name='body'),
}

async function submitMediaCensorJobWithOptions(request: SubmitMediaCensorJobRequest, runtime: Util.RuntimeOptions): SubmitMediaCensorJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitMediaCensorJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitMediaCensorJob(request: SubmitMediaCensorJobRequest): SubmitMediaCensorJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMediaCensorJobWithOptions(request, runtime);
}

model SubmitMediaDetailJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  pipelineId?: string(name='PipelineId'),
  mediaDetailConfig?: string(name='MediaDetailConfig'),
  userData?: string(name='UserData'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitMediaDetailJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitMediaDetailJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitMediaDetailJobResponseBody(name='body'),
}

async function submitMediaDetailJobWithOptions(request: SubmitMediaDetailJobRequest, runtime: Util.RuntimeOptions): SubmitMediaDetailJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitMediaDetailJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitMediaDetailJob(request: SubmitMediaDetailJobRequest): SubmitMediaDetailJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMediaDetailJobWithOptions(request, runtime);
}

model SubmitMediaFpDeleteJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pipelineId?: string(name='PipelineId'),
  primaryKey?: string(name='PrimaryKey'),
  fpDBId?: string(name='FpDBId'),
  userData?: string(name='UserData'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitMediaFpDeleteJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitMediaFpDeleteJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitMediaFpDeleteJobResponseBody(name='body'),
}

async function submitMediaFpDeleteJobWithOptions(request: SubmitMediaFpDeleteJobRequest, runtime: Util.RuntimeOptions): SubmitMediaFpDeleteJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitMediaFpDeleteJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitMediaFpDeleteJob(request: SubmitMediaFpDeleteJobRequest): SubmitMediaFpDeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMediaFpDeleteJobWithOptions(request, runtime);
}

model SubmitMediaInfoJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  userData?: string(name='UserData'),
  pipelineId?: string(name='PipelineId'),
  async?: boolean(name='Async'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitMediaInfoJobResponseBody = {
  mediaInfoJob?: {
    creationTime?: string(name='CreationTime'),
    state?: string(name='State'),
    jobId?: string(name='JobId'),
    userData?: string(name='UserData'),
    code?: string(name='Code'),
    message?: string(name='Message'),
    pipelineId?: string(name='PipelineId'),
    async?: boolean(name='Async'),
    input?: {
      object?: string(name='Object'),
      location?: string(name='Location'),
      bucket?: string(name='Bucket'),
    }(name='Input'),
    MNSMessageResult?: {
      messageId?: string(name='MessageId'),
      errorMessage?: string(name='ErrorMessage'),
      errorCode?: string(name='ErrorCode'),
    }(name='MNSMessageResult'),
    properties?: {
      width?: string(name='Width'),
      height?: string(name='Height'),
      duration?: string(name='Duration'),
      fps?: string(name='Fps'),
      bitrate?: string(name='Bitrate'),
      fileFormat?: string(name='FileFormat'),
      streams?: {
        videoStreamList?: {
          videoStream?: [ 
          {
            sar?: string(name='Sar'),
            height?: string(name='Height'),
            codecTagString?: string(name='CodecTagString'),
            networkCost?: {
              preloadTime?: string(name='PreloadTime'),
              avgBitrate?: string(name='AvgBitrate'),
              costBandwidth?: string(name='CostBandwidth'),
            }(name='NetworkCost'),
            width?: string(name='Width'),
            index?: string(name='Index'),
            timebase?: string(name='Timebase'),
            avgFPS?: string(name='AvgFPS'),
            pixFmt?: string(name='PixFmt'),
            lang?: string(name='Lang'),
            codecLongName?: string(name='CodecLongName'),
            numFrames?: string(name='NumFrames'),
            rotate?: string(name='Rotate'),
            bitrate?: string(name='Bitrate'),
            hasBFrames?: string(name='HasBFrames'),
            profile?: string(name='Profile'),
            startTime?: string(name='StartTime'),
            dar?: string(name='Dar'),
            codecName?: string(name='CodecName'),
            duration?: string(name='Duration'),
            fps?: string(name='Fps'),
            codecTag?: string(name='CodecTag'),
            codecTimeBase?: string(name='CodecTimeBase'),
            level?: string(name='Level'),
          }
        ](name='VideoStream')
        }(name='VideoStreamList'),
        audioStreamList?: {
          audioStream?: [ 
          {
            timebase?: string(name='Timebase'),
            index?: string(name='Index'),
            sampleFmt?: string(name='SampleFmt'),
            channelLayout?: string(name='ChannelLayout'),
            lang?: string(name='Lang'),
            samplerate?: string(name='Samplerate'),
            codecLongName?: string(name='CodecLongName'),
            channels?: string(name='Channels'),
            numFrames?: string(name='NumFrames'),
            bitrate?: string(name='Bitrate'),
            codecTagString?: string(name='CodecTagString'),
            startTime?: string(name='StartTime'),
            codecName?: string(name='CodecName'),
            duration?: string(name='Duration'),
            codecTag?: string(name='CodecTag'),
            codecTimeBase?: string(name='CodecTimeBase'),
          }
        ](name='AudioStream')
        }(name='AudioStreamList'),
        subtitleStreamList?: {
          subtitleStream?: [ 
          {
            timebase?: string(name='Timebase'),
            index?: string(name='Index'),
            startTime?: string(name='StartTime'),
            codecName?: string(name='CodecName'),
            lang?: string(name='Lang'),
            codecLongName?: string(name='CodecLongName'),
            duration?: string(name='Duration'),
            codecTag?: string(name='CodecTag'),
            codecTimeBase?: string(name='CodecTimeBase'),
            codecTagString?: string(name='CodecTagString'),
          }
        ](name='SubtitleStream')
        }(name='SubtitleStreamList'),
      }(name='Streams'),
      format?: {
        startTime?: string(name='StartTime'),
        numPrograms?: string(name='NumPrograms'),
        size?: string(name='Size'),
        numStreams?: string(name='NumStreams'),
        formatLongName?: string(name='FormatLongName'),
        duration?: string(name='Duration'),
        bitrate?: string(name='Bitrate'),
        formatName?: string(name='FormatName'),
      }(name='Format'),
      fileSize?: string(name='FileSize'),
    }(name='Properties'),
  }(name='MediaInfoJob'),
  requestId?: string(name='RequestId'),
}

model SubmitMediaInfoJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitMediaInfoJobResponseBody(name='body'),
}

async function submitMediaInfoJobWithOptions(request: SubmitMediaInfoJobRequest, runtime: Util.RuntimeOptions): SubmitMediaInfoJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitMediaInfoJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitMediaInfoJob(request: SubmitMediaInfoJobRequest): SubmitMediaInfoJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMediaInfoJobWithOptions(request, runtime);
}

model SubmitPornJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  pipelineId?: string(name='PipelineId'),
  pornConfig?: string(name='PornConfig'),
  userData?: string(name='UserData'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitPornJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitPornJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitPornJobResponseBody(name='body'),
}

async function submitPornJobWithOptions(request: SubmitPornJobRequest, runtime: Util.RuntimeOptions): SubmitPornJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitPornJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitPornJob(request: SubmitPornJobRequest): SubmitPornJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitPornJobWithOptions(request, runtime);
}

model SubmitSmarttagJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  pipelineId?: string(name='PipelineId'),
  title?: string(name='Title'),
  content?: string(name='Content'),
  contentType?: string(name='ContentType'),
  contentAddr?: string(name='ContentAddr'),
  params?: string(name='Params'),
  notifyUrl?: string(name='NotifyUrl'),
  userData?: string(name='UserData'),
  input?: string(name='Input'),
  templateId?: string(name='TemplateId'),
}

model SubmitSmarttagJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitSmarttagJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitSmarttagJobResponseBody(name='body'),
}

async function submitSmarttagJobWithOptions(request: SubmitSmarttagJobRequest, runtime: Util.RuntimeOptions): SubmitSmarttagJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitSmarttagJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitSmarttagJob(request: SubmitSmarttagJobRequest): SubmitSmarttagJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSmarttagJobWithOptions(request, runtime);
}

model SubmitSnapshotJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  snapshotConfig?: string(name='SnapshotConfig'),
  userData?: string(name='UserData'),
  pipelineId?: string(name='PipelineId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitSnapshotJobResponseBody = {
  requestId?: string(name='RequestId'),
  snapshotJob?: {
    creationTime?: string(name='CreationTime'),
    snapshotConfig?: {
      time?: string(name='Time'),
      tileOut?: {
        padding?: string(name='Padding'),
        color?: string(name='Color'),
        cellSelStep?: string(name='CellSelStep'),
        cellHeight?: string(name='CellHeight'),
        cellWidth?: string(name='CellWidth'),
        margin?: string(name='Margin'),
        columns?: string(name='Columns'),
        isKeepCellPic?: string(name='IsKeepCellPic'),
        lines?: string(name='Lines'),
      }(name='TileOut'),
      interval?: string(name='Interval'),
      frameType?: string(name='FrameType'),
      width?: string(name='Width'),
      height?: string(name='Height'),
      outputFile?: {
        roleArn?: string(name='RoleArn'),
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='OutputFile'),
      num?: string(name='Num'),
      tileOutputFile?: {
        roleArn?: string(name='RoleArn'),
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='TileOutputFile'),
    }(name='SnapshotConfig'),
    state?: string(name='State'),
    message?: string(name='Message'),
    MNSMessageResult?: {
      messageId?: string(name='MessageId'),
      errorMessage?: string(name='ErrorMessage'),
      errorCode?: string(name='ErrorCode'),
    }(name='MNSMessageResult'),
    input?: {
      roleArn?: string(name='RoleArn'),
      object?: string(name='Object'),
      location?: string(name='Location'),
      bucket?: string(name='Bucket'),
    }(name='Input'),
    count?: string(name='Count'),
    tileCount?: string(name='TileCount'),
    userData?: string(name='UserData'),
    code?: string(name='Code'),
    pipelineId?: string(name='PipelineId'),
    id?: string(name='Id'),
  }(name='SnapshotJob'),
}

model SubmitSnapshotJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitSnapshotJobResponseBody(name='body'),
}

async function submitSnapshotJobWithOptions(request: SubmitSnapshotJobRequest, runtime: Util.RuntimeOptions): SubmitSnapshotJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitSnapshotJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitSnapshotJob(request: SubmitSnapshotJobRequest): SubmitSnapshotJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSnapshotJobWithOptions(request, runtime);
}

model SubmitSubtitleJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  inputConfig?: string(name='InputConfig'),
  outputConfig?: string(name='OutputConfig'),
  pipelineId?: string(name='PipelineId'),
  userData?: string(name='UserData'),
}

model SubmitSubtitleJobResponseBody = {
  requestId?: string(name='RequestId'),
  subtitleJob?: {
    jobId?: string(name='JobId'),
    inputConfig?: string(name='InputConfig'),
    userData?: string(name='UserData'),
    state?: string(name='State'),
  }(name='SubtitleJob'),
}

model SubmitSubtitleJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitSubtitleJobResponseBody(name='body'),
}

async function submitSubtitleJobWithOptions(request: SubmitSubtitleJobRequest, runtime: Util.RuntimeOptions): SubmitSubtitleJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitSubtitleJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitSubtitleJob(request: SubmitSubtitleJobRequest): SubmitSubtitleJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSubtitleJobWithOptions(request, runtime);
}

model SubmitTagJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  tagConfig?: string(name='TagConfig'),
  userData?: string(name='UserData'),
  pipelineId?: string(name='PipelineId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitTagJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitTagJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitTagJobResponseBody(name='body'),
}

async function submitTagJobWithOptions(request: SubmitTagJobRequest, runtime: Util.RuntimeOptions): SubmitTagJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitTagJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitTagJob(request: SubmitTagJobRequest): SubmitTagJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitTagJobWithOptions(request, runtime);
}

model SubmitTerrorismJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  pipelineId?: string(name='PipelineId'),
  terrorismConfig?: string(name='TerrorismConfig'),
  userData?: string(name='UserData'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitTerrorismJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitTerrorismJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitTerrorismJobResponseBody(name='body'),
}

async function submitTerrorismJobWithOptions(request: SubmitTerrorismJobRequest, runtime: Util.RuntimeOptions): SubmitTerrorismJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitTerrorismJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitTerrorismJob(request: SubmitTerrorismJobRequest): SubmitTerrorismJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitTerrorismJobWithOptions(request, runtime);
}

model SubmitVideoGifJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  pipelineId?: string(name='PipelineId'),
  videoGifConfig?: string(name='VideoGifConfig'),
  userData?: string(name='UserData'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitVideoGifJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitVideoGifJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitVideoGifJobResponseBody(name='body'),
}

async function submitVideoGifJobWithOptions(request: SubmitVideoGifJobRequest, runtime: Util.RuntimeOptions): SubmitVideoGifJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitVideoGifJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitVideoGifJob(request: SubmitVideoGifJobRequest): SubmitVideoGifJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitVideoGifJobWithOptions(request, runtime);
}

model SubmitVideoPoseJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  input?: string(name='Input'),
  outputConfig?: string(name='OutputConfig'),
  pipelineId?: string(name='PipelineId'),
  userData?: string(name='UserData'),
}

model SubmitVideoPoseJobResponseBody = {
  requestId?: string(name='RequestId'),
  videoPoseJob?: {
    outputConfig?: {
      dataFile?: {
        roleArn?: string(name='RoleArn'),
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='DataFile'),
      videoFile?: {
        roleArn?: string(name='RoleArn'),
        object?: string(name='Object'),
        location?: string(name='Location'),
        bucket?: string(name='Bucket'),
      }(name='VideoFile'),
    }(name='OutputConfig'),
    state?: string(name='State'),
    jobId?: string(name='JobId'),
    userData?: string(name='UserData'),
    pipelineId?: string(name='PipelineId'),
    MNSMessageResult?: {
      messageId?: string(name='MessageId'),
      errorMessage?: string(name='ErrorMessage'),
      errorCode?: string(name='ErrorCode'),
    }(name='MNSMessageResult'),
    input?: {
      roleArn?: string(name='RoleArn'),
      object?: string(name='Object'),
      location?: string(name='Location'),
      bucket?: string(name='Bucket'),
    }(name='Input'),
    properties?: {
      width?: string(name='Width'),
      height?: string(name='Height'),
      duration?: string(name='Duration'),
      fps?: string(name='Fps'),
      bitrate?: string(name='Bitrate'),
      fileFormat?: string(name='FileFormat'),
      streams?: {
        videoStreamList?: {
          videoStream?: [ 
          {
            sar?: string(name='Sar'),
            height?: string(name='Height'),
            codecTagString?: string(name='CodecTagString'),
            networkCost?: {
              preloadTime?: string(name='PreloadTime'),
              avgBitrate?: string(name='AvgBitrate'),
              costBandwidth?: string(name='CostBandwidth'),
            }(name='NetworkCost'),
            width?: string(name='Width'),
            index?: string(name='Index'),
            timebase?: string(name='Timebase'),
            avgFPS?: string(name='AvgFPS'),
            pixFmt?: string(name='PixFmt'),
            lang?: string(name='Lang'),
            codecLongName?: string(name='CodecLongName'),
            numFrames?: string(name='NumFrames'),
            rotate?: string(name='Rotate'),
            bitrate?: string(name='Bitrate'),
            hasBFrames?: string(name='HasBFrames'),
            profile?: string(name='Profile'),
            startTime?: string(name='StartTime'),
            dar?: string(name='Dar'),
            codecName?: string(name='CodecName'),
            duration?: string(name='Duration'),
            fps?: string(name='Fps'),
            codecTag?: string(name='CodecTag'),
            codecTimeBase?: string(name='CodecTimeBase'),
            level?: string(name='Level'),
          }
        ](name='VideoStream')
        }(name='VideoStreamList'),
        audioStreamList?: {
          audioStream?: [ 
          {
            timebase?: string(name='Timebase'),
            index?: string(name='Index'),
            sampleFmt?: string(name='SampleFmt'),
            channelLayout?: string(name='ChannelLayout'),
            lang?: string(name='Lang'),
            samplerate?: string(name='Samplerate'),
            codecLongName?: string(name='CodecLongName'),
            channels?: string(name='Channels'),
            numFrames?: string(name='NumFrames'),
            bitrate?: string(name='Bitrate'),
            codecTagString?: string(name='CodecTagString'),
            startTime?: string(name='StartTime'),
            codecName?: string(name='CodecName'),
            duration?: string(name='Duration'),
            codecTag?: string(name='CodecTag'),
            codecTimeBase?: string(name='CodecTimeBase'),
          }
        ](name='AudioStream')
        }(name='AudioStreamList'),
        subtitleStreamList?: {
          subtitleStream?: [ 
          {
            timebase?: string(name='Timebase'),
            index?: string(name='Index'),
            startTime?: string(name='StartTime'),
            codecName?: string(name='CodecName'),
            lang?: string(name='Lang'),
            codecLongName?: string(name='CodecLongName'),
            duration?: string(name='Duration'),
            codecTag?: string(name='CodecTag'),
            codecTimeBase?: string(name='CodecTimeBase'),
            codecTagString?: string(name='CodecTagString'),
          }
        ](name='SubtitleStream')
        }(name='SubtitleStreamList'),
      }(name='Streams'),
      format?: {
        startTime?: string(name='StartTime'),
        numPrograms?: string(name='NumPrograms'),
        size?: string(name='Size'),
        numStreams?: string(name='NumStreams'),
        formatLongName?: string(name='FormatLongName'),
        duration?: string(name='Duration'),
        bitrate?: string(name='Bitrate'),
        formatName?: string(name='FormatName'),
      }(name='Format'),
      fileSize?: string(name='FileSize'),
    }(name='Properties'),
  }(name='VideoPoseJob'),
}

model SubmitVideoPoseJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitVideoPoseJobResponseBody(name='body'),
}

async function submitVideoPoseJobWithOptions(request: SubmitVideoPoseJobRequest, runtime: Util.RuntimeOptions): SubmitVideoPoseJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitVideoPoseJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitVideoPoseJob(request: SubmitVideoPoseJobRequest): SubmitVideoPoseJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitVideoPoseJobWithOptions(request, runtime);
}

model SubmitVideoQualityJobRequest {
  userId?: long(name='UserId'),
  pipelineId?: string(name='PipelineId'),
  sourceType?: string(name='SourceType'),
  modelId?: string(name='ModelId'),
  input?: string(name='Input'),
  output?: string(name='Output'),
  jobParams?: string(name='JobParams'),
  scheduleParams?: string(name='ScheduleParams'),
  userData?: string(name='UserData'),
  notifyUrl?: string(name='NotifyUrl'),
}

model SubmitVideoQualityJobResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  jobId?: string(name='JobId'),
}

model SubmitVideoQualityJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitVideoQualityJobResponseBody(name='body'),
}

async function submitVideoQualityJobWithOptions(request: SubmitVideoQualityJobRequest, runtime: Util.RuntimeOptions): SubmitVideoQualityJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitVideoQualityJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitVideoQualityJob(request: SubmitVideoQualityJobRequest): SubmitVideoQualityJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitVideoQualityJobWithOptions(request, runtime);
}

model SubmitVideoSplitJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  pipelineId?: string(name='PipelineId'),
  videoSplitConfig?: string(name='VideoSplitConfig'),
  userData?: string(name='UserData'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitVideoSplitJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitVideoSplitJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitVideoSplitJobResponseBody(name='body'),
}

async function submitVideoSplitJobWithOptions(request: SubmitVideoSplitJobRequest, runtime: Util.RuntimeOptions): SubmitVideoSplitJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitVideoSplitJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitVideoSplitJob(request: SubmitVideoSplitJobRequest): SubmitVideoSplitJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitVideoSplitJobWithOptions(request, runtime);
}

model SubmitVideoSummaryJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  input?: string(name='Input'),
  pipelineId?: string(name='PipelineId'),
  videoSummaryConfig?: string(name='VideoSummaryConfig'),
  userData?: string(name='UserData'),
  ownerAccount?: string(name='OwnerAccount'),
}

model SubmitVideoSummaryJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitVideoSummaryJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitVideoSummaryJobResponseBody(name='body'),
}

async function submitVideoSummaryJobWithOptions(request: SubmitVideoSummaryJobRequest, runtime: Util.RuntimeOptions): SubmitVideoSummaryJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitVideoSummaryJob', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitVideoSummaryJob(request: SubmitVideoSummaryJobRequest): SubmitVideoSummaryJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitVideoSummaryJobWithOptions(request, runtime);
}

model TagCustomPersonRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  categoryId?: string(name='CategoryId'),
  categoryName?: string(name='CategoryName'),
  categoryDescription?: string(name='CategoryDescription'),
  personId?: string(name='PersonId'),
  personName?: string(name='PersonName'),
  personDescription?: string(name='PersonDescription'),
}

model TagCustomPersonResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagCustomPersonResponse = {
  headers: map[string]string(name='headers'),
  body: TagCustomPersonResponseBody(name='body'),
}

async function tagCustomPersonWithOptions(request: TagCustomPersonRequest, runtime: Util.RuntimeOptions): TagCustomPersonResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TagCustomPerson', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function tagCustomPerson(request: TagCustomPersonRequest): TagCustomPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagCustomPersonWithOptions(request, runtime);
}

model UnbindInputBucketRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  bucket?: string(name='Bucket'),
  roleArn?: string(name='RoleArn'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UnbindInputBucketResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnbindInputBucketResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindInputBucketResponseBody(name='body'),
}

async function unbindInputBucketWithOptions(request: UnbindInputBucketRequest, runtime: Util.RuntimeOptions): UnbindInputBucketResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnbindInputBucket', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unbindInputBucket(request: UnbindInputBucketRequest): UnbindInputBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindInputBucketWithOptions(request, runtime);
}

model UnbindOutputBucketRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  bucket?: string(name='Bucket'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UnbindOutputBucketResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnbindOutputBucketResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindOutputBucketResponseBody(name='body'),
}

async function unbindOutputBucketWithOptions(request: UnbindOutputBucketRequest, runtime: Util.RuntimeOptions): UnbindOutputBucketResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnbindOutputBucket', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unbindOutputBucket(request: UnbindOutputBucketRequest): UnbindOutputBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindOutputBucketWithOptions(request, runtime);
}

model UnregisterCustomFaceRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  categoryId?: string(name='CategoryId'),
  personId?: string(name='PersonId'),
  faceId?: string(name='FaceId'),
}

model UnregisterCustomFaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnregisterCustomFaceResponse = {
  headers: map[string]string(name='headers'),
  body: UnregisterCustomFaceResponseBody(name='body'),
}

async function unregisterCustomFaceWithOptions(request: UnregisterCustomFaceRequest, runtime: Util.RuntimeOptions): UnregisterCustomFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnregisterCustomFace', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unregisterCustomFace(request: UnregisterCustomFaceRequest): UnregisterCustomFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unregisterCustomFaceWithOptions(request, runtime);
}

model UpdateAsrPipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pipelineId?: string(name='PipelineId'),
  name?: string(name='Name'),
  state?: string(name='State'),
  priority?: int32(name='Priority'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdateAsrPipelineResponseBody = {
  requestId?: string(name='RequestId'),
  pipeline?: {
    state?: string(name='State'),
    notifyConfig?: {
      queueName?: string(name='QueueName'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    name?: string(name='Name'),
    id?: string(name='Id'),
  }(name='Pipeline'),
}

model UpdateAsrPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAsrPipelineResponseBody(name='body'),
}

async function updateAsrPipelineWithOptions(request: UpdateAsrPipelineRequest, runtime: Util.RuntimeOptions): UpdateAsrPipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateAsrPipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateAsrPipeline(request: UpdateAsrPipelineRequest): UpdateAsrPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAsrPipelineWithOptions(request, runtime);
}

model UpdateCategoryNameRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  cateId?: string(name='CateId'),
  cateName?: string(name='CateName'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdateCategoryNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateCategoryNameResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCategoryNameResponseBody(name='body'),
}

async function updateCategoryNameWithOptions(request: UpdateCategoryNameRequest, runtime: Util.RuntimeOptions): UpdateCategoryNameResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateCategoryName', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateCategoryName(request: UpdateCategoryNameRequest): UpdateCategoryNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCategoryNameWithOptions(request, runtime);
}

model UpdateCensorPipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pipelineId?: string(name='PipelineId'),
  name?: string(name='Name'),
  state?: string(name='State'),
  priority?: int32(name='Priority'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdateCensorPipelineResponseBody = {
  requestId?: string(name='RequestId'),
  pipeline?: {
    state?: string(name='State'),
    notifyConfig?: {
      topic?: string(name='Topic'),
      queue?: string(name='Queue'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    name?: string(name='Name'),
    id?: string(name='Id'),
  }(name='Pipeline'),
}

model UpdateCensorPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCensorPipelineResponseBody(name='body'),
}

async function updateCensorPipelineWithOptions(request: UpdateCensorPipelineRequest, runtime: Util.RuntimeOptions): UpdateCensorPipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateCensorPipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateCensorPipeline(request: UpdateCensorPipelineRequest): UpdateCensorPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCensorPipelineWithOptions(request, runtime);
}

model UpdateCoverPipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pipelineId?: string(name='PipelineId'),
  name?: string(name='Name'),
  state?: string(name='State'),
  priority?: int32(name='Priority'),
  notifyConfig?: string(name='NotifyConfig'),
  role?: string(name='Role'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdateCoverPipelineResponseBody = {
  requestId?: string(name='RequestId'),
  pipeline?: {
    state?: string(name='State'),
    notifyConfig?: {
      topic?: string(name='Topic'),
      queue?: string(name='Queue'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    role?: string(name='Role'),
    name?: string(name='Name'),
    id?: string(name='Id'),
  }(name='Pipeline'),
}

model UpdateCoverPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCoverPipelineResponseBody(name='body'),
}

async function updateCoverPipelineWithOptions(request: UpdateCoverPipelineRequest, runtime: Util.RuntimeOptions): UpdateCoverPipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateCoverPipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateCoverPipeline(request: UpdateCoverPipelineRequest): UpdateCoverPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCoverPipelineWithOptions(request, runtime);
}

model UpdateMCTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
  name?: string(name='Name'),
  porn?: string(name='Porn'),
  terrorism?: string(name='Terrorism'),
  politics?: string(name='Politics'),
  ad?: string(name='Ad'),
  qrcode?: string(name='Qrcode'),
  live?: string(name='Live'),
  logo?: string(name='Logo'),
  abuse?: string(name='Abuse'),
  contraband?: string(name='Contraband'),
  spam?: string(name='spam'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdateMCTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    logo?: string(name='Logo'),
    abuse?: string(name='Abuse'),
    state?: string(name='State'),
    terrorism?: string(name='Terrorism'),
    politics?: string(name='Politics'),
    qrcode?: string(name='Qrcode'),
    live?: string(name='Live'),
    spam?: string(name='Spam'),
    contraband?: string(name='Contraband'),
    ad?: string(name='Ad'),
    porn?: string(name='Porn'),
    name?: string(name='Name'),
    templateId?: string(name='TemplateId'),
  }(name='Template'),
}

model UpdateMCTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMCTemplateResponseBody(name='body'),
}

async function updateMCTemplateWithOptions(request: UpdateMCTemplateRequest, runtime: Util.RuntimeOptions): UpdateMCTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateMCTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateMCTemplate(request: UpdateMCTemplateRequest): UpdateMCTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMCTemplateWithOptions(request, runtime);
}

model UpdateMcuTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  templateId?: string(name='TemplateId'),
  template?: string(name='Template'),
}

model UpdateMcuTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model UpdateMcuTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMcuTemplateResponseBody(name='body'),
}

async function updateMcuTemplateWithOptions(request: UpdateMcuTemplateRequest, runtime: Util.RuntimeOptions): UpdateMcuTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateMcuTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateMcuTemplate(request: UpdateMcuTemplateRequest): UpdateMcuTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMcuTemplateWithOptions(request, runtime);
}

model UpdateMediaRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  mediaId?: string(name='MediaId'),
  title?: string(name='Title'),
  description?: string(name='Description'),
  coverURL?: string(name='CoverURL'),
  cateId?: long(name='CateId'),
  tags?: string(name='Tags'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdateMediaResponseBody = {
  requestId?: string(name='RequestId'),
  media?: {
    creationTime?: string(name='CreationTime'),
    cateId?: long(name='CateId'),
    height?: string(name='Height'),
    censorState?: string(name='CensorState'),
    tags?: {
      tag?: [ string ](name='Tag')
    }(name='Tags'),
    bitrate?: string(name='Bitrate'),
    mediaId?: string(name='MediaId'),
    file?: {
      state?: string(name='State'),
      URL?: string(name='URL'),
    }(name='File'),
    publishState?: string(name='PublishState'),
    description?: string(name='Description'),
    width?: string(name='Width'),
    size?: string(name='Size'),
    coverURL?: string(name='CoverURL'),
    runIdList?: {
      runId?: [ string ](name='RunId')
    }(name='RunIdList'),
    duration?: string(name='Duration'),
    fps?: string(name='Fps'),
    title?: string(name='Title'),
    format?: string(name='Format'),
  }(name='Media'),
}

model UpdateMediaResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaResponseBody(name='body'),
}

async function updateMediaWithOptions(request: UpdateMediaRequest, runtime: Util.RuntimeOptions): UpdateMediaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateMedia', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateMedia(request: UpdateMediaRequest): UpdateMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaWithOptions(request, runtime);
}

model UpdateMediaCategoryRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  mediaId?: string(name='MediaId'),
  cateId?: long(name='CateId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdateMediaCategoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMediaCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaCategoryResponseBody(name='body'),
}

async function updateMediaCategoryWithOptions(request: UpdateMediaCategoryRequest, runtime: Util.RuntimeOptions): UpdateMediaCategoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateMediaCategory', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateMediaCategory(request: UpdateMediaCategoryRequest): UpdateMediaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaCategoryWithOptions(request, runtime);
}

model UpdateMediaCoverRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  mediaId?: string(name='MediaId'),
  coverURL?: string(name='CoverURL'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdateMediaCoverResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMediaCoverResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaCoverResponseBody(name='body'),
}

async function updateMediaCoverWithOptions(request: UpdateMediaCoverRequest, runtime: Util.RuntimeOptions): UpdateMediaCoverResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateMediaCover', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateMediaCover(request: UpdateMediaCoverRequest): UpdateMediaCoverResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaCoverWithOptions(request, runtime);
}

model UpdateMediaPublishStateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  mediaId?: string(name='MediaId'),
  publish?: boolean(name='Publish'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdateMediaPublishStateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMediaPublishStateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaPublishStateResponseBody(name='body'),
}

async function updateMediaPublishStateWithOptions(request: UpdateMediaPublishStateRequest, runtime: Util.RuntimeOptions): UpdateMediaPublishStateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateMediaPublishState', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateMediaPublishState(request: UpdateMediaPublishStateRequest): UpdateMediaPublishStateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaPublishStateWithOptions(request, runtime);
}

model UpdateMediaWorkflowRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  topology?: string(name='Topology'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdateMediaWorkflowResponseBody = {
  requestId?: string(name='RequestId'),
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    state?: string(name='State'),
    triggerMode?: string(name='TriggerMode'),
    name?: string(name='Name'),
    topology?: string(name='Topology'),
  }(name='MediaWorkflow'),
}

model UpdateMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaWorkflowResponseBody(name='body'),
}

async function updateMediaWorkflowWithOptions(request: UpdateMediaWorkflowRequest, runtime: Util.RuntimeOptions): UpdateMediaWorkflowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateMediaWorkflow', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateMediaWorkflow(request: UpdateMediaWorkflowRequest): UpdateMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaWorkflowWithOptions(request, runtime);
}

model UpdateMediaWorkflowTriggerModeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  triggerMode?: string(name='TriggerMode'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdateMediaWorkflowTriggerModeResponseBody = {
  requestId?: string(name='RequestId'),
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    state?: string(name='State'),
    triggerMode?: string(name='TriggerMode'),
    name?: string(name='Name'),
    topology?: string(name='Topology'),
  }(name='MediaWorkflow'),
}

model UpdateMediaWorkflowTriggerModeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaWorkflowTriggerModeResponseBody(name='body'),
}

async function updateMediaWorkflowTriggerModeWithOptions(request: UpdateMediaWorkflowTriggerModeRequest, runtime: Util.RuntimeOptions): UpdateMediaWorkflowTriggerModeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateMediaWorkflowTriggerMode', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateMediaWorkflowTriggerMode(request: UpdateMediaWorkflowTriggerModeRequest): UpdateMediaWorkflowTriggerModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaWorkflowTriggerModeWithOptions(request, runtime);
}

model UpdatePipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pipelineId?: string(name='PipelineId'),
  name?: string(name='Name'),
  state?: string(name='State'),
  notifyConfig?: string(name='NotifyConfig'),
  role?: string(name='Role'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdatePipelineResponseBody = {
  requestId?: string(name='RequestId'),
  pipeline?: {
    speed?: string(name='Speed'),
    state?: string(name='State'),
    notifyConfig?: {
      mqTopic?: string(name='MqTopic'),
      queueName?: string(name='QueueName'),
      mqTag?: string(name='MqTag'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    name?: string(name='Name'),
    role?: string(name='Role'),
    id?: string(name='Id'),
    quotaAllocate?: long(name='QuotaAllocate'),
  }(name='Pipeline'),
}

model UpdatePipelineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePipelineResponseBody(name='body'),
}

async function updatePipelineWithOptions(request: UpdatePipelineRequest, runtime: Util.RuntimeOptions): UpdatePipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdatePipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updatePipeline(request: UpdatePipelineRequest): UpdatePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePipelineWithOptions(request, runtime);
}

model UpdatePornPipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pipelineId?: string(name='PipelineId'),
  name?: string(name='Name'),
  state?: string(name='State'),
  priority?: int32(name='Priority'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdatePornPipelineResponseBody = {
  requestId?: string(name='RequestId'),
  pipeline?: {
    state?: string(name='State'),
    notifyConfig?: {
      topic?: string(name='Topic'),
      queue?: string(name='Queue'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    name?: string(name='Name'),
    id?: string(name='Id'),
  }(name='Pipeline'),
}

model UpdatePornPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePornPipelineResponseBody(name='body'),
}

async function updatePornPipelineWithOptions(request: UpdatePornPipelineRequest, runtime: Util.RuntimeOptions): UpdatePornPipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdatePornPipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updatePornPipeline(request: UpdatePornPipelineRequest): UpdatePornPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePornPipelineWithOptions(request, runtime);
}

model UpdateSmarttagTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  templateId?: string(name='TemplateId'),
  templateName?: string(name='TemplateName'),
  industry?: string(name='Industry'),
  scene?: string(name='Scene'),
  analyseTypes?: string(name='AnalyseTypes'),
  faceCategoryIds?: string(name='FaceCategoryIds'),
  isDefault?: boolean(name='IsDefault'),
}

model UpdateSmarttagTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateSmarttagTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSmarttagTemplateResponseBody(name='body'),
}

async function updateSmarttagTemplateWithOptions(request: UpdateSmarttagTemplateRequest, runtime: Util.RuntimeOptions): UpdateSmarttagTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateSmarttagTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateSmarttagTemplate(request: UpdateSmarttagTemplateRequest): UpdateSmarttagTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSmarttagTemplateWithOptions(request, runtime);
}

model UpdateTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
  name?: string(name='Name'),
  container?: string(name='Container'),
  video?: string(name='Video'),
  audio?: string(name='Audio'),
  muxConfig?: string(name='MuxConfig'),
  transConfig?: string(name='TransConfig'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    video?: {
      longShortMode?: string(name='LongShortMode'),
      bufsize?: string(name='Bufsize'),
      degrain?: string(name='Degrain'),
      bitrateBnd?: {
        max?: string(name='Max'),
        min?: string(name='Min'),
      }(name='BitrateBnd'),
      pixFmt?: string(name='PixFmt'),
      pad?: string(name='Pad'),
      codec?: string(name='Codec'),
      height?: string(name='Height'),
      qscale?: string(name='Qscale'),
      crop?: string(name='Crop'),
      bitrate?: string(name='Bitrate'),
      maxrate?: string(name='Maxrate'),
      maxFps?: string(name='MaxFps'),
      profile?: string(name='Profile'),
      crf?: string(name='Crf'),
      remove?: string(name='Remove'),
      gop?: string(name='Gop'),
      width?: string(name='Width'),
      fps?: string(name='Fps'),
      preset?: string(name='Preset'),
      scanMode?: string(name='ScanMode'),
      resoPriority?: string(name='ResoPriority'),
    }(name='Video'),
    transConfig?: {
      isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
      transMode?: string(name='TransMode'),
      isCheckReso?: string(name='IsCheckReso'),
      isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
      adjDarMethod?: string(name='AdjDarMethod'),
      isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
      isCheckResoFail?: string(name='IsCheckResoFail'),
      isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
    }(name='TransConfig'),
    state?: string(name='State'),
    muxConfig?: {
      webp?: {
        loop?: string(name='Loop'),
      }(name='Webp'),
      gif?: {
        finalDelay?: string(name='FinalDelay'),
        ditherMode?: string(name='DitherMode'),
        loop?: string(name='Loop'),
        isCustomPalette?: string(name='IsCustomPalette'),
      }(name='Gif'),
      segment?: {
        duration?: string(name='Duration'),
      }(name='Segment'),
    }(name='MuxConfig'),
    name?: string(name='Name'),
    audio?: {
      profile?: string(name='Profile'),
      remove?: string(name='Remove'),
      codec?: string(name='Codec'),
      samplerate?: string(name='Samplerate'),
      qscale?: string(name='Qscale'),
      channels?: string(name='Channels'),
      bitrate?: string(name='Bitrate'),
    }(name='Audio'),
    id?: string(name='Id'),
    container?: {
      format?: string(name='Format'),
    }(name='Container'),
  }(name='Template'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTemplateResponseBody(name='body'),
}

async function updateTemplateWithOptions(request: UpdateTemplateRequest, runtime: Util.RuntimeOptions): UpdateTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateTemplate(request: UpdateTemplateRequest): UpdateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTemplateWithOptions(request, runtime);
}

model UpdateTerrorismPipelineRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pipelineId?: string(name='PipelineId'),
  name?: string(name='Name'),
  state?: string(name='State'),
  priority?: int32(name='Priority'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdateTerrorismPipelineResponseBody = {
  requestId?: string(name='RequestId'),
  pipeline?: {
    state?: string(name='State'),
    notifyConfig?: {
      topic?: string(name='Topic'),
      queue?: string(name='Queue'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    name?: string(name='Name'),
    id?: string(name='Id'),
  }(name='Pipeline'),
}

model UpdateTerrorismPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTerrorismPipelineResponseBody(name='body'),
}

async function updateTerrorismPipelineWithOptions(request: UpdateTerrorismPipelineRequest, runtime: Util.RuntimeOptions): UpdateTerrorismPipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateTerrorismPipeline', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateTerrorismPipeline(request: UpdateTerrorismPipelineRequest): UpdateTerrorismPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTerrorismPipelineWithOptions(request, runtime);
}

model UpdateWaterMarkTemplateRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
  name?: string(name='Name'),
  config?: string(name='Config'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdateWaterMarkTemplateResponseBody = {
  waterMarkTemplate?: {
    type?: string(name='Type'),
    ratioRefer?: {
      dx?: string(name='Dx'),
      width?: string(name='Width'),
      height?: string(name='Height'),
      dy?: string(name='Dy'),
    }(name='RatioRefer'),
    referPos?: string(name='ReferPos'),
    state?: string(name='State'),
    dx?: string(name='Dx'),
    width?: string(name='Width'),
    height?: string(name='Height'),
    timeline?: {
      start?: string(name='Start'),
      duration?: string(name='Duration'),
    }(name='Timeline'),
    name?: string(name='Name'),
    dy?: string(name='Dy'),
    id?: string(name='Id'),
  }(name='WaterMarkTemplate'),
  requestId?: string(name='RequestId'),
}

model UpdateWaterMarkTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWaterMarkTemplateResponseBody(name='body'),
}

async function updateWaterMarkTemplateWithOptions(request: UpdateWaterMarkTemplateRequest, runtime: Util.RuntimeOptions): UpdateWaterMarkTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateWaterMarkTemplate', '2014-06-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateWaterMarkTemplate(request: UpdateWaterMarkTemplateRequest): UpdateWaterMarkTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWaterMarkTemplateWithOptions(request, runtime);
}

